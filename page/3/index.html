<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="YwTcBpc08sCpJAE8mKZglCGHjZc1BiK9UUagC8ldlaA">
  <meta name="msvalidate.01" content="true">
  <meta name="yandex-verification" content="true">
  <meta name="baidu-site-verification" content="3PbJKzlOf0">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"thepatterraining.github.io","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="dream">
<meta property="og:url" content="https://thepatterraining.github.io/page/3/index.html">
<meta property="og:site_name" content="dream">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Thepatter">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://thepatterraining.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>dream</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="dream" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dream</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个菜鸟程序员的成长历程</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/mysql%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/mysql%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97.html" class="post-title-link" itemprop="url">mysql优化指南</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-21 14:02:52" itemprop="dateCreated datePublished" datetime="2024-11-21T14:02:52+08:00">2024-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span id="/mysql%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97.html" class="post-meta-item leancloud_visitors" data-flag-title="mysql优化指南" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/mysql%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/mysql%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mysql优化"><a href="#mysql优化" class="headerlink" title="mysql优化"></a>mysql优化</h1><h2 id="数据库级别优化"><a href="#数据库级别优化" class="headerlink" title="数据库级别优化"></a>数据库级别优化</h2><ol>
<li>表结构是否合理？列的数据类型是否正确？</li>
<li>索引设置和选择是否合理？</li>
<li>存储引擎是否合理？通常使用Innodb性能更好</li>
<li>Innodb表压缩是否开启？</li>
<li>获取的锁是否正确？是否可以支持数据库更好的并发运行</li>
<li>buffer pool设置是否正确？</li>
</ol>
<h2 id="硬件级别优化"><a href="#硬件级别优化" class="headerlink" title="硬件级别优化"></a>硬件级别优化</h2><ol>
<li>磁盘寻道时间优化</li>
<li>使用SSD高速硬盘，提升读写效率，或使用磁盘阵列来并行读取</li>
<li>CPU周期</li>
<li>内存带宽</li>
</ol>
<h2 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h2><h3 id="select语句优化"><a href="#select语句优化" class="headerlink" title="select语句优化"></a>select语句优化</h3><p>where语句总是比全表查询更快，尽量避免全表查询，where语句尽量走索引，但需要注意索引对于磁盘空间的占用和增删改的影响。</p>
<p>定期使用<code>ANALYZE TABLE</code>来更新mysql的统计信息，以确保优化器正确选择索引。</p>
<p>了解存储引擎特有的调优技术</p>
<p>避免写出难以理解的查询语句</p>
<p>仔细阅读<code>EXPLAIN</code>查询计划，根据计划来调优</p>
<p>调整buffer pool以容纳更多的缓存</p>
<p>处理锁定问题，以避免锁冲突、锁等待造成查询慢</p>
<h4 id="where子句优化"><a href="#where子句优化" class="headerlink" title="where子句优化"></a>where子句优化</h4><p>在mysql准备阶段，即优化阶段之前，mysql会进行一些语句重写。</p>
<p>删除不必要的括号，比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((a AND b) AND c OR (((a AND b) AND (c AND d))))</span><br></pre></td></tr></table></figure>

<p>删除以后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a AND b AND c) OR (a AND b AND c AND d)</span><br></pre></td></tr></table></figure>

<p>恒定折叠，比如a&lt;b and a &#x3D; 5, 那么可知 b &gt; 5</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a&lt;b AND b=c) AND a=5</span><br></pre></td></tr></table></figure>

<p>优化以后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b&gt;5 AND b=c AND a=5</span><br></pre></td></tr></table></figure>

<p>恒等式移除，比如一些永真式或永假式可以直接移除掉，包括常用的where 1 &#x3D; 1，下面1&#x3D;1永真，5&#x3D;6永假，所以b&#x3D;7也去掉</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(b&gt;=5 AND b=5) OR (b=6 AND 1=1) OR (b=7 AND 5=6)</span><br></pre></td></tr></table></figure>

<p>优化以后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b=5 or b=6</span><br></pre></td></tr></table></figure>

<p>索引使用的常数表达式只计算一次。</p>
<p>早期检测无效的常量表达式。MySQL会快速检测到某些SELECT语句是不可能的，并且不返回任何行。</p>
<p>如果不使用group by，那么having将和where合并</p>
<p>对于联接中的每个表，构造一个更简单的WHERE，以获得表的快速WHERE计算，并尽快跳过行。</p>
<p>在查询中，所有常量表都在任何其他表之前首先读取。常量表是以下任何一种：</p>
<ol>
<li>空表或只有一行的表。</li>
<li>where放在主键索引或者唯一索引上的，所有的索引部分都和常亮表达式比较，并定义为NOT NULL<br>比如<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t WHERE primary_key=1;</span><br><span class="line">SELECT * FROM t1,t2 WHERE t1.primary_key=1 AND t2.primary_key=t1.id;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>通过尝试所有的可能性来找到连接表的最佳连接组合。如果ORDER BY和GROUP BY子句中的所有列都来自同一个表，则在联接时首选该表。</p>
<p>如果有一个ORDER BY子句和一个不同的GROUP BY子句，或者如果ORDER BY或GROUP BY包含来自连接队列中第一个表以外的表的列，则将创建一个临时表。</p>
<p>如果使用SQL_SMALL_RESULT修饰符，MySQL将使用内存中的临时表。</p>
<p>查询每个表索引，并使用最佳索引，除非优化器认为使用表扫描更有效。曾经，扫描是根据最佳索引是否覆盖表的30%以上来使用的，但固定的百分比不再决定使用索引还是扫描。优化器现在更加复杂，它的估计基于其他因素，如表大小、行数和I&#x2F;O块大小。</p>
<p>在某些情况下，MySQL可以从索引中读取行，甚至不需要查阅数据文件。如果索引中使用的所有列都是数值列，则仅使用索引树来解析查询。</p>
<p>在输出每一行之前，将跳过与HAVING子句不匹配的行。</p>
<p>一些非常快的查询示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) FROM tbl_name;</span><br><span class="line"></span><br><span class="line">SELECT MIN(key_part1),MAX(key_part1) FROM tbl_name;</span><br><span class="line"></span><br><span class="line">SELECT MAX(key_part2) FROM tbl_name</span><br><span class="line">  WHERE key_part1=constant;</span><br><span class="line"></span><br><span class="line">SELECT ... FROM tbl_name</span><br><span class="line">  ORDER BY key_part1,key_part2,... LIMIT 10;</span><br><span class="line"></span><br><span class="line">SELECT ... FROM tbl_name</span><br><span class="line">  ORDER BY key_part1 DESC, key_part2 DESC, ... LIMIT 10;</span><br></pre></td></tr></table></figure>

<p>MySQL只使用索引树解析以下查询，假设索引列是数字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT key_part1,key_part2 FROM tbl_name WHERE key_part1=val;</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*) FROM tbl_name</span><br><span class="line">  WHERE key_part1=val1 AND key_part2=val2;</span><br><span class="line"></span><br><span class="line">SELECT MAX(key_part2) FROM tbl_name GROUP BY key_part1;</span><br></pre></td></tr></table></figure>

<p>以下查询使用索引来按排序顺序检索行，而无需单独的排序过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FROM tbl_name</span><br><span class="line">  ORDER BY key_part1,key_part2,... ;</span><br><span class="line"></span><br><span class="line">SELECT ... FROM tbl_name</span><br><span class="line">  ORDER BY key_part1 DESC, key_part2 DESC, ... ;</span><br></pre></td></tr></table></figure>

<h4 id="范围优化"><a href="#范围优化" class="headerlink" title="范围优化"></a>范围优化</h4><p>对于BTREE和HASH索引，当使用&#x3D;、&lt;&#x3D;&gt;、IN（）、IS NULL或IS NOT NULL运算符时，键部分与常量值的比较是范围条件。此外，对于BTREE索引，当使用&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，BETWEEN，！&#x3D; 、或&lt;&gt;运算符，或者LIKE比较（如果LIKE的参数是不以小写字符开头的常量字符串）。对于所有索引类型，多个范围条件与OR或AND组合形成范围条件。</p>
<p>给定数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">key_part1  key_part2  key_part3</span><br><span class="line">  NULL       1          &#x27;abc&#x27;</span><br><span class="line">  NULL       1          &#x27;xyz&#x27;</span><br><span class="line">  NULL       2          &#x27;foo&#x27;</span><br><span class="line">   1         1          &#x27;abc&#x27;</span><br><span class="line">   1         1          &#x27;xyz&#x27;</span><br><span class="line">   1         2          &#x27;abc&#x27;</span><br><span class="line">   2         1          &#x27;aaa&#x27;</span><br></pre></td></tr></table></figure>

<p>执行where key_part1&#x3D; 1，其扫描范围为 1,负无穷，负无穷到 1,正无穷，正无穷</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1,-inf,-inf) &lt;= (key_part1,key_part2,key_part3) &lt; (1,+inf,+inf)</span><br></pre></td></tr></table></figure>
<p>即覆盖了这三行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1         1          &#x27;abc&#x27;</span><br><span class="line">1         1          &#x27;xyz&#x27;</span><br><span class="line">1         2          &#x27;abc&#x27;</span><br></pre></td></tr></table></figure>

<p>index dives，优化器在范围的两端进行dives, 可以帮助优化器更准确的评估扫描的行数，index dives提供了更准确的行估计，但是随着比较值数量的增加，更加耗时，使用统计信息的准确性不如index dives，但允许对大值列表进行更快的行估计。</p>
<p>eq_range_index_dive_limit系统变量使您能够配置优化器从一个行估计策略切换到另一个行估计策略时的值数量。要允许使用索引潜水来比较最多N个相等范围，请将eq_range_index_dive_limit设置为N+ 1。要禁用统计信息并始终使用索引潜水而不管N，请将eq_range_index_dive_limit设置为0。</p>
<p>若要更新表索引统计信息以获得最佳估计值，请使用ANALYZE TABLE。</p>
<p>skip scan,比如有索引(f1,f2)，都知道最左前缀原则，所以一般where f2 &gt; 40是不走索引的，skip scan可以让他走索引，通过构造f1 &#x3D; 1 and f2 &gt; 40，扫描完以后再扫描 f1 &#x3D; 2 and f2 &gt; 40，以此类推，可以通过explain来看extra列是否有skip scan</p>
<p>in优化，in查询可以用如下形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FROM t1 WHERE ( col_1, col_2 ) IN (( &#x27;a&#x27;, &#x27;b&#x27; ), ( &#x27;c&#x27;, &#x27;d&#x27; ));</span><br></pre></td></tr></table></figure>

<p>range_optimizer_max_size_size系统变量可以设置优化器使用的内存</p>
<h4 id="index-merge-优化"><a href="#index-merge-优化" class="headerlink" title="index merge 优化"></a>index merge 优化</h4><p>index merge就是多个索引并发扫描，再将扫描结果合并</p>
<p>索引合并不适用于全文索引。</p>
<p>索引合并访问方法检索具有多个范围扫描的行，并将其结果合并为一个。此访问方法只合并单个表的索引扫描，而不合并多个表的扫描。合并可以产生其底层扫描的并集、交集或交集的并集。</p>
<p>可以使用索引合并的查询示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tbl_name WHERE key1 = 10 OR key2 = 20;</span><br><span class="line"></span><br><span class="line">SELECT * FROM tbl_name</span><br><span class="line">  WHERE (key1 = 10 OR key2 = 20) AND non_key = 30;</span><br><span class="line"></span><br><span class="line">SELECT * FROM t1, t2</span><br><span class="line">  WHERE (t1.key1 IN (1,2) OR t1.key2 LIKE &#x27;value%&#x27;)</span><br><span class="line">  AND t2.key1 = t1.some_col;</span><br><span class="line"></span><br><span class="line">SELECT * FROM t1, t2</span><br><span class="line">  WHERE t1.key1 = 1</span><br><span class="line">  AND (t2.key1 = t1.some_col OR t2.key2 = t1.some_col2);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你的查询有一个带有深度AND&#x2F;OR嵌套的复杂WHERE子句，并且MySQL没有选择最佳计划，请尝试使用以下恒等转换来分发术语：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(x AND y) OR z =&gt; (x OR z) AND (y OR z)</span><br><span class="line">(x OR y) AND z =&gt; (x AND z) OR (y AND z)</span><br></pre></td></tr></table></figure>

<p>在EXPLAIN输出中，Index Merge方法在type列中显示为index_merge。在本例中，key列包含使用的索引列表，key_len包含这些索引的最长键部分列表。</p>
<p>索引合并访问方法有几种算法，它们显示在EXPLAIN输出的Extra字段中：</p>
<ul>
<li>intersect：对多个and条件生效</li>
<li>union：对多个or条件生效</li>
<li>sort_union：sort-union算法和union算法之间的区别在于，sort-union算法必须首先获取所有行的行ID，并在返回任何行之前对其进行排序。</li>
</ul>
<p>索引合并的使用取决于optimizer_switch系统变量的index_merge、index_merge_intersection、index_merge_union和index_merge_sort_union标志的值。默认情况下，所有这些标志都是打开的。</p>
<h4 id="hash-join"><a href="#hash-join" class="headerlink" title="hash join"></a>hash join</h4><p>默认情况下，MySQL尽可能使用哈希连接。可以使用BNL和NO_BNL优化器提示之一来控制是否使用散列连接。</p>
<p>hash join比嵌套join快的多，首先创建hash表，在循环另一个表进行hash，判断是否相等</p>
<p>可以使用join_buffer_size系统变量控制哈希连接的内存使用量;哈希连接使用的内存量不能超过此值。当哈希连接所需的内存超过可用量时，MySQL会使用磁盘上的文件来处理。如果发生这种情况，您应该注意，如果哈希连接无法容纳内存并且它创建的文件比为open_files_limit设置的文件多，则连接可能不会成功。要避免此类问题，请进行以下更改之一：</p>
<ul>
<li>增加join_buffer_size，使哈希连接不会溢出到磁盘。</li>
<li>增加open_files_limit。</li>
</ul>
<h4 id="引擎条件下推"><a href="#引擎条件下推" class="headerlink" title="引擎条件下推"></a>引擎条件下推</h4><p>只有ndb引擎可以使用，假设查询如下，a有索引，b没有索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT a, b FROM t1 WHERE b = 10;</span><br></pre></td></tr></table></figure>

<p>那么可以条件下推给ndb引擎执行where条件，如果where a &#x3D;10则不会下推，因为索引更快</p>
<p>explain里面可以显示为：Extra: Using where with pushed condition</p>
<p>like,between,is null,is not null,in也可以执行下推。</p>
<p>BLOB，TEXT，JSON,BIT,ENUM类型的字段不能执行下推</p>
<h4 id="索引条件下推"><a href="#索引条件下推" class="headerlink" title="索引条件下推"></a>索引条件下推</h4><p>索引条件下推（ICP）是MySQL使用索引从表中检索行的情况下的优化。如果没有ICP，存储引擎将遍历索引以定位基表中的行，并将它们返回到MySQL服务器，该服务器将评估行的WHERE条件。在启用ICP的情况下，如果可以仅使用索引中的列来计算部分WHERE条件，则MySQL服务器会将这部分WHERE条件下推到存储引擎。然后，存储引擎通过使用索引条目来评估推送的索引条件，并且仅当满足该条件时才从表中读取行。ICP可以减少存储引擎必须访问基表的次数以及MySQL服务器必须访问存储引擎的次数。</p>
<p>索引条件下推优化的适用性受以下条件的限制：</p>
<ul>
<li>当需要访问整个表行时，ICP用于range、ref、eq_ref和ref_or_null访问方法。</li>
<li>ICP可以用于InnoDB和MyISAM表，包括分区的InnoDB和MyISAM表。</li>
<li>对于InnoDB表，ICP仅用于辅助索引。ICP的目标是减少整行读取的数量，从而减少I&#x2F;O操作。对于InnoDB聚集索引，完整的记录已经读入InnoDB缓冲区。在这种情况下使用ICP不会减少I&#x2F;O。</li>
<li>ICP不支持在虚拟生成列上创建辅助索引。InnoDB支持虚拟生成列的二级索引。</li>
<li>引用子查询的条件不能下推。</li>
<li>引用存储函数的条件不能下推。存储引擎不能调用存储的函数。</li>
<li>触发的条件不能下推。</li>
<li>不能将条件下推到包含对系统变量的引用的派生表。</li>
</ul>
<p>要理解这种优化是如何工作的，首先考虑当不使用索引条件下推时索引扫描是如何进行的：</p>
<ol>
<li>获取下一行，首先通过阅读索引元组，然后使用索引元组定位并读取整个表行。</li>
<li>测试应用于此表的部分WHERE条件。根据测试结果接受或拒绝行。</li>
</ol>
<p>使用Index Condition Pushdown，扫描过程如下所示：</p>
<ol>
<li>获取下一行的索引元组（但不是整个表行）。</li>
<li>测试应用于此表且只能使用索引列进行检查的WHERE条件部分。如果不满足条件，则继续执行下一行的索引元组。</li>
<li>如果满足条件，则使用索引元组定位并读取整个表行。</li>
<li>测试应用于此表的WHERE条件的其余部分。根据测试结果接受或拒绝行。</li>
</ol>
<p>假设一个表包含有关人员及其地址的信息，并且该表的索引定义为 INDEX (zipcode, lastname, firstname) 。如果我们知道一个人的zipcode值，但不确定他的姓氏，我们可以这样搜索：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM people</span><br><span class="line">  WHERE zipcode=&#x27;95054&#x27;</span><br><span class="line">  AND lastname LIKE &#x27;%etrunia%&#x27;</span><br><span class="line">  AND address LIKE &#x27;%Main Street%&#x27;;</span><br></pre></td></tr></table></figure>
<p>MySQL可以使用索引扫描zipcode &#x3D;’95054’的人。第二部分（lastname LIKE ‘%etrunia%’）不能用于限制必须扫描的行数，因此如果没有Index Condition Pushdown，则此查询必须检索所有zipcode &#x3D;’95054’的人的完整表行。</p>
<p>使用Index Condition Pushdown，MySQL在阅读整个表行之前检查lastname LIKE“%etrunia%”部分。这样可以避免阅读与zipcode条件匹配但与lastname条件不匹配的索引元组对应的整行。</p>
<p>默认情况下，索引条件下推处于启用状态。可以通过设置index_condition_pushdown标志来使用optimizer_switch系统变量控制它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET optimizer_switch = &#x27;index_condition_pushdown=off&#x27;;</span><br><span class="line">SET optimizer_switch = &#x27;index_condition_pushdown=on&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="条件过滤"><a href="#条件过滤" class="headerlink" title="条件过滤"></a>条件过滤</h4><p>在联接处理中，前缀行是在联接中从一个表传递到下一个表的那些行。通常，优化器会尝试将前缀计数较低的表放在连接顺序的早期，以防止行组合的数量快速增加。如果优化器可以使用有关从一个表中选择并传递到下一个表的行的条件的信息，那么它就可以更准确地计算行估计值并选择最佳执行计划。</p>
<p>如果没有条件过滤，表的前缀行计数将基于WHERE子句根据优化器选择的访问方法所选择的估计行数。条件筛选使优化器能够在WHERE子句中使用访问方法未考虑的其他相关条件，从而改进其前缀行计数估计。例如，即使可能有一个基于索引的访问方法可用于在联接中从当前表中选择行，但在WHERE子句中也可能有用于表的附加条件，这些条件可以过滤（进一步限制）传递给下一个表的合格行的估计。</p>
<p>前缀行计数（估计在联接中从当前表传递到下一个表的行数）是行与筛选值的乘积。也就是说，前缀行计数是估计的行计数，减去估计的过滤效果。例如，如果行数为1000，筛选为20%，则条件筛选会将估计的行数1000减少到前缀行数1000 × 20% &#x3D; 1000 × .2 &#x3D; 200。</p>
<p>假设以下查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">  FROM employee JOIN department ON employee.dept_no = department.dept_no</span><br><span class="line">  WHERE employee.first_name = &#x27;John&#x27;</span><br><span class="line">  AND employee.hire_date BETWEEN &#x27;2018-01-01&#x27; AND &#x27;2018-06-01&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>employee表有1024行。</li>
<li>department表有12行。</li>
<li>这两个表都有一个关于dept_no的索引。</li>
<li>employee表在first_name上有一个索引。</li>
<li>在employee.first_name上有8行满足此条件：first_name &#x3D; ‘John’</li>
<li>在employee.hire_date上有150行满足此条件：hire_date BETWEEN ‘2018-01-01’ AND ‘2018-06-01’</li>
<li>1行满足两个条件：WHERE employee.first_name &#x3D; ‘John’ AND employee.hire_date BETWEEN ‘2018-01-01’ AND ‘2018-06-01’;</li>
</ul>
<p>如果没有条件过滤，EXPLAIN会产生如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+------------+--------+------------------+---------+---------+------+----------+</span><br><span class="line">| id | table      | type   | possible_keys    | key     | ref     | rows | filtered |</span><br><span class="line">+----+------------+--------+------------------+---------+---------+------+----------+</span><br><span class="line">| 1  | employee   | ref    | name,h_date,dept | name    | const   | 8    | 100.00   |</span><br><span class="line">| 1  | department | eq_ref | PRIMARY          | PRIMARY | dept_no | 1    | 100.00   |</span><br><span class="line">+----+------------+--------+------------------+---------+---------+------+----------+</span><br></pre></td></tr></table></figure>

<p>对于employee，name索引上的访问方法选取与名称“John”匹配的8行。没有进行过滤（filtered是100%），所以所有行都是下一个表的前缀行：前缀行计数是rows×filtered &#x3D; 8 × 100% &#x3D; 8。</p>
<p>通过条件过滤，优化器还考虑了访问方法没有考虑的WHERE子句中的条件。在本例中，优化器使用BETWEEN条件对employee.hire_date的过滤效果估计为16.31%。因此，EXPLAIN会产生如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+------------+--------+------------------+---------+---------+------+----------+</span><br><span class="line">| id | table      | type   | possible_keys    | key     | ref     | rows | filtered |</span><br><span class="line">+----+------------+--------+------------------+---------+---------+------+----------+</span><br><span class="line">| 1  | employee   | ref    | name,h_date,dept | name    | const   | 8    | 16.31    |</span><br><span class="line">| 1  | department | eq_ref | PRIMARY          | PRIMARY | dept_no | 1    | 100.00   |</span><br><span class="line">+----+------------+--------+------------------+---------+---------+------+----------+</span><br></pre></td></tr></table></figure>

<p>现在前缀行数为rows×filtered &#x3D; 8 × 16.31% &#x3D; 1.3，这更接近于实际数据集。</p>
<p>要控制优化器是否考虑其他筛选条件，请使用optimizer_switch系统变量的condition_fanout_filter标志，默认启用</p>
<p>如果优化器高估了条件筛选的效果，则性能可能会比不使用条件筛选时更差。在这种情况下，这些技术可能有助于：</p>
<ul>
<li>如果某个列没有索引，那么对它进行索引，这样优化器就可以获得一些关于列值分布的信息，并可以改进其行估计。</li>
<li>同样，如果没有列直方图信息可用，则生成一个直方图</li>
<li>更改连接顺序。实现这一点的方法包括连接顺序优化器提示</li>
<li>禁用会话的条件筛选：SET optimizer_switch &#x3D; ‘condition_fanout_filter&#x3D;off’;</li>
</ul>
<h4 id="order-by-优化"><a href="#order-by-优化" class="headerlink" title="order by 优化"></a>order by 优化</h4><p>要提高ORDER BY的速度，请检查是否可以让MySQL使用索引而不是额外的排序阶段。如果无法做到这一点，请尝试以下策略：</p>
<ul>
<li>增加sort_buffer_size变量值。理想情况下，该值应该足够大，以使整个结果集能够放入排序缓冲区（以避免写入磁盘和合并过程）。</li>
<li>请注意，存储在排序缓冲区中的列值的大小受max_sort_length系统变量值的影响。例如，如果元组存储长字符串列的值，并且您增加max_sort_length的值，则排序缓冲区元组的大小也会增加，并且可能需要您增加sort_buffer_size。</li>
<li>要监视合并通道的数量（合并临时文件），请检查Sort_merge_passes状态变量。</li>
<li>增加read_rnd_buffer_size变量值，以便一次读取更多行。</li>
<li>将tmpdir系统变量更改为指向具有大量可用空间的专用文件系统。变量值可以列出以循环方式使用的多个路径;您可以使用此功能将负载分散到多个目录。在Unix上用冒号（：）分隔路径，在Windows上用冒号（;）分隔路径。路径应该命名位于不同物理磁盘上的文件系统中的目录，而不是同一磁盘上的不同分区。</li>
</ul>
<p>如果EXPLAIN输出的Extra列不包含Using filesort，则使用索引，不执行filesort。<br>如果EXPLAIN输出的Extra列包含Using filesort，则不使用索引并执行filesort。</p>
<h4 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h4><p>group by其实就是构建一个hash表，key就是group by的key, value包括Min max之类的值。</p>
<p>将索引用于GROUP BY的最重要的先决条件是，所有GROUP BY列都引用来自同一索引的属性，并且索引按顺序存储其键（例如，对于BTREE索引是这样，但对于HASH索引则不是这样）。索引访问是否可以取代临时表的使用还取决于查询中使用索引的哪些部分、为这些部分指定的条件以及所选的聚合函数。</p>
<p>有两种方法可以通过索引访问执行GROUP BY查询，下面几节将详细介绍。第一个方法将分组操作与所有范围谓词（如果有）一起应用。第二种方法首先执行范围扫描，然后对结果元组进行分组。</p>
<ul>
<li>松散索引扫描</li>
<li>紧密索引扫描</li>
</ul>
<p>松散索引扫描</p>
<p>如果松散索引扫描适用于查询，则EXPLAIN输出在Extra列中显示Using index for group-by。</p>
<p>假设在表t1（c1，c2，c3，c4）上存在索引idx（c1，c2，c3）。松散索引扫描访问方法可用于以下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT c1, c2 FROM t1 GROUP BY c1, c2;</span><br><span class="line">SELECT DISTINCT c1, c2 FROM t1;</span><br><span class="line">SELECT c1, MIN(c2) FROM t1 GROUP BY c1;</span><br><span class="line">SELECT c1, c2 FROM t1 WHERE c1 &lt; const GROUP BY c1, c2;</span><br><span class="line">SELECT MAX(c3), MIN(c3), c1, c2 FROM t1 WHERE c2 &gt; const GROUP BY c1, c2;</span><br><span class="line">SELECT c2 FROM t1 WHERE c1 &lt; const GROUP BY c1, c2;</span><br><span class="line">SELECT c1, c2 FROM t1 WHERE c3 = const GROUP BY c1, c2;</span><br></pre></td></tr></table></figure>

<p>以下查询无法使用此快速选择方法执行，原因如下：</p>
<ul>
<li>除了MIN（）或MAX（）之外，还有其他聚合函数：</li>
<li>GROUP BY子句中的列不构成索引的最左边前缀：</li>
<li>该查询引用位于GROUP BY部分之后的键的一部分，并且对于该部分，不存在与常量相等的情况：</li>
</ul>
<p>假设在表t1（c1，c2，c3，c4）上存在索引idx（c1，c2，c3）。松散索引扫描访问方法可用于以下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT c1), SUM(DISTINCT c1) FROM t1;</span><br><span class="line"></span><br><span class="line">SELECT COUNT(DISTINCT c1, c2), COUNT(DISTINCT c2, c1) FROM t1;</span><br></pre></td></tr></table></figure>

<p>紧密索引扫描</p>
<p>紧密索引扫描可以是全索引扫描，也可以是范围索引扫描，具体取决于查询条件。</p>
<p>当不满足松散索引扫描的条件时，仍然可以避免为GROUP BY查询创建临时表。如果WHERE子句中有范围条件，则此方法只读取满足这些条件的键。否则，它将执行索引扫描。由于此方法读取WHERE子句定义的每个范围中的所有键，或者在没有范围条件的情况下扫描整个索引，因此称为紧密索引扫描。使用紧密索引扫描时，只有在找到满足范围条件的所有键后才执行分组操作。</p>
<p>要使此方法起作用，查询中的所有列都有一个常量相等条件就足够了，该条件引用位于GROUP BY键之前或之间的键部分。相等条件中的常数填充搜索关键字中的任何“空白“，以便可以形成索引的完整前缀。然后，这些索引前缀可以用于索引查找。如果GROUP BY结果需要排序，并且可以形成作为索引前缀的搜索键，MySQL也避免了额外的排序操作，因为在有序索引中使用前缀搜索已经按顺序检索了所有键。</p>
<p>假设在表t1（c1，c2，c3，c4）上存在索引idx（c1，c2，c3）。以下查询不适用于前面描述的松散索引扫描访问方法，但仍适用于紧密索引扫描访问方法。<br>GROUP BY中有一个间隙，但它被条件c2 &#x3D; ‘a’覆盖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT c1, c2, c3 FROM t1 WHERE c2 = &#x27;a&#x27; GROUP BY c1, c3;</span><br></pre></td></tr></table></figure>

<p>GROUP BY并不从键的第一部分开始开始，但有一个条件为该部分提供了一个常量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT c1, c2, c3 FROM t1 WHERE c1 = &#x27;a&#x27; GROUP BY c2, c3;</span><br></pre></td></tr></table></figure>

<h4 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h4><p>比如order by + limit可以启用topN排序，不需要对所有元素排序。</p>
<p>如果将LIMIT与DISTINCT结合使用，MySQL会在找到row_count唯一行时立即停止。</p>
<p>在某些情况下，GROUP BY可以通过按顺序阅读索引（或对索引进行排序），然后计算摘要直到索引值更改来解决。在这种情况下，LIMIT不会计算任何不必要的GROUP BY值。</p>
<p>一旦MySQL向客户端发送了所需的行数，它就会中止查询，除非您使用SQL_CALC_FOUND_ROWS。在这种情况下，可以使用 SELECT FOUND_ROWS() 检索行数。</p>
<p>如果ORDER BY没有使用索引，但也存在LIMIT子句，则优化器可以避免使用合并文件，并使用内存中的文件排序操作对内存中的行进行排序。</p>
<p>总之一句话，最好加上limit</p>
<h4 id="子查询物化"><a href="#子查询物化" class="headerlink" title="子查询物化"></a>子查询物化</h4><p>将子查询的结果保存在临时表，而不是每次都执行。需要开启optimizer_switch &#x3D; materialization </p>
<h4 id="其他优化技巧"><a href="#其他优化技巧" class="headerlink" title="其他优化技巧"></a>其他优化技巧</h4><p>如果应用程序发出多个数据库请求以执行相关更新，则将这些语句组合到存储例程中可以提高性能。同样，如果应用程序基于多个列值或大量数据计算单个结果，则将计算组合到一个函数中可以提高性能。然后，所产生的快速数据库操作可供其他查询、应用程序甚至用不同编程语言编写的代码重用。</p>
<p>如果可能，将报告分类为“实时“或“统计“，其中统计报告所需的数据仅从实时数据定期生成的汇总表中创建。</p>
<p>如果您的数据不符合行列表结构，则可以将数据打包并存储到BLOB列中。在这种情况下，您必须在应用程序中提供代码来打包和解包信息，但这可能会节省I&#x2F;O操作来读取和写入相关值集。</p>
<p>对于Web服务器，将图像和其他二进制资产存储为文件，路径名存储在数据库中，而不是文件本身。大多数Web服务器更擅长缓存文件而不是数据库内容，因此使用文件通常更快。</p>
<p>如果你真的需要很高的速度，看看底层的MySQL接口。例如，通过直接访问MySQLInnoDB或MyISAM存储引擎，与使用SQL接口相比，您可以获得显著的速度提升。</p>
<p>复制可以为某些操作提供性能优势。您可以在副本之间分发客户端检索以分割负载。为了避免在进行备份时降低源的速度，可以使用复制副本进行备份。</p>
<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><p>如果一个表有许多列，并且您查询了许多不同的列组合，那么将不太常用的数据拆分到单独的表中，每个表有几个列，然后通过从主表复制数字ID列将它们关联回主表，这样可能会更有效。这样，每个小表都可以有一个用于快速查找其数据的主键，并且您可以使用连接操作仅查询所需的列集。根据数据的分布方式，查询可能会执行更少的I&#x2F;O并占用更少的缓存内存，因为相关的列在磁盘上打包在一起。</p>
<p>最常见的索引类型涉及单个列，将该列的值的副本存储在数据结构中，允许快速查找具有相应列值的行。B树数据结构允许索引快速查找WHERE子句中与&#x3D;、&gt;、≤、BETWEEN、IN等运算符对应的特定值、一组值或一个值范围。</p>
<p>所有存储引擎都支持每个表至少16个索引，总索引长度至少为256字节。大多数存储引擎有更高的限制。</p>
<p>可以对字符串创建前n个字符串的索引，减少索引长度。</p>
<p>FULLTEXT索引用于全文搜索。只有InnoDB和MyISAM存储引擎支持FULLTEXT索引，并且只支持CHAR、VARCHAR和TEXT列。索引总是在整个列上进行，并且不支持列前缀索引。</p>
<p>存储引擎收集有关表的统计信息供优化器使用。表统计信息基于值组，其中值组是具有相同键前缀值的一组行。出于优化目的，一个重要的统计信息是平均值组大小。</p>
<p>随着索引的平均值组大小的增加，索引对这两个目的的用处越来越小，因为每次查找的平均行数增加了：为了使索引有利于优化，最好每个索引值针对表中的少量行。当给定的索引值产生大量的行时，索引就不那么有用了，MySQL也不太可能使用它。</p>
<p>平均值组大小与表基数有关，表基数是值组的数量。SHOW INDEX语句显示基于N&#x2F;S的基数值，其中N是表中的行数，S是平均值组大小。该比率产生表中的值组的近似数量。<br>对于基于&#x3D;运算符的连接，NULL与非NULL值不同：当expr1或expr2（或两者）为NULL时，expr1&#x3D;expr2不为真。这会影响tbl_name.key&#x3D;expr形式的比较的ref访问：如果expr的当前值为NULL，MySQL不会访问表，因为比较不可能为true。</p>
<p>对于&#x3D;比较，表中有多少NULL值并不重要。出于优化目的，相关值是非NULL值组的平均大小。但是，MySQL目前还不能收集或使用该平均大小。</p>
<p>对于InnoDB和MyISAM表，您可以分别通过innodb_stats_method和myisam_stats_method系统变量来控制表统计信息的收集。这些变量有三个可能的值，其不同之处如下：</p>
<ul>
<li>当变量设置为nulls_equal时，所有NULL值都被视为相同的（即，它们都形成一个值组）。如果NULL值组大小远高于平均非NULL值组大小，则此方法会使平均值组大小向上倾斜。这使得索引在优化器看来没有它在查找非NULL值的联接中实际上那么有用。因此，nulls_equal方法可能会导致优化器在应该使用索引进行ref访问时不使用索引。</li>
<li>当变量设置为nulls_unequal时，NULL值不被认为是相同的。相反，每个NULL值形成一个大小为1的单独的值组。如果有许多NULL值，此方法会使平均值组大小向下倾斜。如果非NULL值组的平均大小很大，则将每个NULL值计为大小为1的组会导致优化器过高估计查找非NULL值的联接的索引值。因此，nulls_unequal方法可能会导致优化器在其他方法可能更好的情况下使用此索引进行ref查找。</li>
<li>当变量设置为nulls_ignored时，NULL值将被忽略。</li>
</ul>
<h4 id="hash-index"><a href="#hash-index" class="headerlink" title="hash index"></a>hash index</h4><p>它们仅用于使用&#x3D;或&lt;&#x3D;&gt;运算符的相等比较（但非常快）。它们不用于查找值范围的比较运算符，如&lt;。依赖于这种单值查找的系统被称为“键值存储”;要将MySQL用于此类应用程序，请尽可能使用散列索引。</p>
<p>优化器不能使用哈希索引来加速ORDER BY操作。(This索引类型不能用于按顺序搜索下一个条目。)</p>
<p>MySQL无法确定两个值之间大约有多少行（这是由范围优化器用来决定使用哪个索引）。如果您将MyISAM或InnoDB表更改为哈希索引的MEMORY表，这可能会影响某些查询。</p>
<p>只能使用整个键来搜索行。(With B树索引，键的任何最左边的前缀都可以用来查找行。)</p>
<h4 id="b树索引"><a href="#b树索引" class="headerlink" title="b树索引"></a>b树索引</h4><p>b-tree索引通常比hash索引更好</p>
<p>B树索引可用于使用&#x3D;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;或BETWEEN运算符的表达式中的列比较。如果LIKE的参数是不以通配符开头的常量字符串，则该索引也可用于LIKE比较。</p>
<h4 id="索引扩展"><a href="#索引扩展" class="headerlink" title="索引扩展"></a>索引扩展</h4><p>InnoDB会自动扩展每个二级索引，将主键列追加到二级索引上。考虑下面的表定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t1 (</span><br><span class="line">  i1 INT NOT NULL DEFAULT 0,</span><br><span class="line">  i2 INT NOT NULL DEFAULT 0,</span><br><span class="line">  d DATE DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (i1, i2),</span><br><span class="line">  INDEX k_d (d)</span><br><span class="line">) ENGINE = InnoDB;</span><br></pre></td></tr></table></figure>

<p>此表定义列（i1，i2）上的主键。它还在列（d）上定义了一个二级索引k_d，但InnoDB内部扩展了这个索引，并将其视为列（d，i1，i2）。</p>
<p>考虑查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = &#x27;2000-01-01&#x27;</span><br></pre></td></tr></table></figure>

<p>如果不扩展索引，那么查询计划如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t1</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: PRIMARY,k_d</span><br><span class="line">          key: k_d</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 5</span><br><span class="line">        Extra: Using where; Using index</span><br></pre></td></tr></table></figure>

<p>如果扩展索引，那么查询计划如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = &#x27;2000-01-01&#x27;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t1</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: PRIMARY,k_d</span><br><span class="line">          key: k_d</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const,const</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: Using index</span><br></pre></td></tr></table></figure>

<ul>
<li>key_len从4个字节变为8个字节，表明键查找使用列d和i1，而不仅仅是d。</li>
<li>ref值从const变为const，const，因为键查找使用两个键部分，而不是一个。</li>
<li>行数从5减少到1，表明InnoDB应该需要检查更少的行来生成结果。</li>
<li>Extra值从Using where; Using index更改为Using index。这意味着可以仅使用索引读取行，而无需查询数据行中的列。</li>
</ul>
<h3 id="优化数据库结构"><a href="#优化数据库结构" class="headerlink" title="优化数据库结构"></a>优化数据库结构</h3><p>设计表以最小化它们在磁盘上的空间。这可以通过减少写入磁盘和从磁盘读取的数据量来实现巨大的改进。较小的表通常需要较少的主内存，而它们的内容在查询执行期间被主动处理。表数据的任何空间减少都会导致索引变小，从而可以更快地处理。</p>
<p>尽可能使用最有效（最小）的数据类型。MySQL有许多专门的类型，可以节省磁盘空间和内存。例如，如果可能的话，使用较小的整数类型来获得较小的表。MEDIUMINT通常是比INT更好的选择，因为MEDIUMINT列使用的空间少25%。</p>
<p>如果可能的话，将列设置为NOT NULL。它通过更好地使用索引和消除测试每个值是否为NULL的开销，使SQL操作更快。您还节省了一些存储空间，每列一位。如果你真的需要空值在你的表，使用它们。只要避免允许每列都有NULL值的默认设置即可。</p>
<p>InnoDB表默认使用DYNAMIC行格式创建。要使用DYNAMIC以外的行格式，请配置innodb_default_row_form，或在CREATE TABLE或ALTER TABLE语句中显式指定ROW_FORMAT选项。</p>
<p>要通过以压缩形式存储表数据来进一步最小化空间，请在创建InnoDB表时指定ROW_FORMAT&#x3D;COMPRESSED，或者在现有的MyISAM表上运行myisampack命令。（InnoDB压缩表是可读和可写的，而MyISAM压缩表是只读的。</p>
<p>表的主索引应尽可能短。这使得每一行的识别变得简单而有效。对于InnoDB表，主键列在每个二级索引条目中是重复的，所以如果有很多二级索引，短主键可以节省相当多的空间。</p>
<p>只创建提高查询性能所需的索引。索引有利于检索，但会降低插入和更新操作的速度。如果您主要通过搜索列的组合来访问表，请在这些列上创建单个复合索引，而不是为每列创建单独的索引。索引的第一部分应该是最常用的列。如果在从表中选择时总是使用许多列，则索引中的第一列应该是具有最多重复项的列，以获得更好的索引压缩。</p>
<p>如果一个长字符串列很可能在第一个字符数上有一个唯一的前缀，那么最好只索引这个前缀，使用MySQL对在列的最左边部分创建索引的支持</p>
<p>在某些情况下，将经常扫描的表分成两部分可能是有益的。如果它是一个动态格式的表，并且可以使用一个较小的静态格式表，以便在扫描表时查找相关行，则尤其如此。</p>
<p>在具有相同数据类型的不同表中删除具有相同信息的列，以加快基于相应列的联接速度。</p>
<p>保持列名称简单，这样您就可以在不同的表中使用相同的名称，并简化连接查询。例如，在名为customer的表中，使用name而不是customer_name的列名。要使您的名称可移植到其他SQL服务器，请考虑将它们保持在18个字符以下。</p>
<p>通常情况下，尽量保持所有数据都是非冗余的（观察数据库理论中所谓的第三范式）。与其重复冗长的值（如名称和地址），不如为它们分配唯一的ID，根据需要在多个较小的表中重复这些ID，并通过引用join子句中的ID在查询中连接表。</p>
<p>如果速度比磁盘空间和保持多个数据副本的维护成本更重要，例如在分析大型表中所有数据的商业智能场景中，您可以放松规范化规则，复制信息或创建汇总表以获得更快的速度。</p>
<p>对于可以表示为字符串或数字的唯一ID或其他值，最好使用数字列而不是字符串列。由于大数值可以存储在比相应字符串更少的字节中，因此传输和比较它们的速度更快，占用的内存更少。</p>
<p>如果您使用的是数值数据，在许多情况下，从数据库（使用实时连接）访问信息比访问文本文件更快。数据库中的信息可能以比文本文件更紧凑的格式存储，因此访问它涉及的磁盘访问较少。还可以在应用程序中保存代码，因为这样可以避免分析文本文件以查找行和列边界。</p>
<p>当不需要特定于语言的排序规则功能时，使用二进制排序规则顺序进行快速比较和排序操作。可以使用BINARY运算符在特定查询中使用二进制排序规则。</p>
<p>当比较来自不同列的值时，尽可能使用相同的字符集和排序规则声明这些列，以避免在运行查询时进行字符串转换。</p>
<p>对于小于8 KB的列值，请使用二进制VARCHAR而不是BLOB。GROUP BY和ORDER BY子句可以生成临时表，如果原始表不包含任何BLOB列，则这些临时表可以使用MEMORY存储引擎。</p>
<p>如果一个表包含字符串列，如名称和地址，但许多查询不检索这些列，请考虑将字符串列拆分到一个单独的表中，并在必要时使用带有外键的联接查询。当MySQL从一行中检索任何值时，它会读取一个包含该行（可能还有其他相邻行）所有列的数据块。保持每一行都很小，只包含最常用的列，这样就可以在每个数据块中容纳更多的行。这样的紧凑表减少了常见查询的磁盘I&#x2F;O和内存使用。</p>
<p>当你使用一个随机生成的值作为InnoDB表中的主键时，如果可能的话，在它前面加上一个升序值，比如当前的日期和时间。当连续的主值物理上存储在彼此附近时，InnoDB可以更快地插入和检索它们。</p>
<h4 id="mysql打开和关闭表"><a href="#mysql打开和关闭表" class="headerlink" title="mysql打开和关闭表"></a>mysql打开和关闭表</h4><p>MySQL是多线程的，因此可能有许多客户端同时对给定的表发出查询。为了最大限度地减少多个客户端会话在同一个表上具有不同状态的问题，该表由每个并发会话独立打开。这会使用额外的内存，但通常会提高性能。对于MyISAM表，每个打开表的客户端的数据文件都需要一个额外的文件描述符。(By相反，索引文件描述符在所有会话之间共享。）</p>
<p>table_open_cache和max_connections系统变量影响服务器保持打开状态的最大文件数。如果您增加这两个值中的一个或两个，您可能会遇到操作系统对每个进程打开的文件描述符数量施加的限制。许多操作系统允许您增加打开文件限制，尽管方法因系统而异。请参阅操作系统文档，以确定是否可以增加限制以及如何增加限制。</p>
<p>table_open_cache与max_connections相关。例如，对于200个并发运行的连接，指定表缓存大小至少为200 *N，其中N是您执行的任何查询中每个连接的最大表数。您还必须为临时表和文件保留一些额外的文件描述符。</p>
<p>确保您的操作系统可以处理table_open_cache设置所暗示的打开文件描述符的数量。如果table_open_cache设置得太高，MySQL可能会耗尽文件描述符，并出现拒绝连接或无法执行查询等症状。</p>
<p>打开表的该高速缓存保持在table_open_cache条目的级别。服务器在启动时自动调整该高速缓存的大小。要显式设置大小，请在启动时设置table_open_cache系统变量。MySQL可能会临时打开比这更多的表来执行查询，如本节后面所述。</p>
<p>MySQL在以下情况下关闭未使用的表并将其从表缓存中删除：</p>
<ul>
<li>当该高速缓存已满并且线程试图打开不在该高速缓存中的表时。</li>
<li>当该高速缓存包含多个table_open_cache条目，并且该高速缓存中的某个表不再被任何线程使用时。</li>
<li>当发生表刷新操作时。当有人发出FLUSH TABLES语句或执行mysqladmin flush-tables或mysqladmin refresh命令时，就会发生这种情况。</li>
</ul>
<p>当表缓存填满时，服务器使用以下过程来定位要使用的缓存条目：用途：</p>
<ul>
<li>从最近最少使用的表开始，释放当前未使用的表。</li>
<li>如果必须打开一个新表，但该高速缓存已满，无法释放任何表，则会根据需要临时扩展该高速缓存。当该高速缓存处于临时扩展状态并且表从已使用状态变为未使用状态时，关闭该表并从该高速缓存释放该表。</li>
</ul>
<p>为每个并发访问打开一个MyISAM表。这意味着如果两个线程访问同一个表，或者如果一个线程在同一个查询中访问该表两次（例如，通过将该表连接到其自身），则需要打开该表两次。每个并发打开都需要表缓存中的一个条目。第一次打开任何MyISAM表都需要两个文件描述符：一个用于数据文件，一个用于索引文件。表的每次额外使用只需要数据文件的一个文件描述符。索引文件描述符在所有线程之间共享。</p>
<p>要确定表缓存是否太小，请检查Opened_tables状态变量，该变量指示自服务器启动以来打开表的操作数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW GLOBAL STATUS LIKE &#x27;Opened_tables&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Opened_tables | 2741  |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure>

<p>如果该值非常大或增加得很快，即使您没有发出很多FLUSH TABLES语句，也要在服务器启动时增加table_open_cache值。</p>
<h3 id="优化innodb表"><a href="#优化innodb表" class="headerlink" title="优化innodb表"></a>优化innodb表</h3><p>一旦数据达到稳定的大小，或者一个不断增长的表增加了几十或几百兆字节，就可以考虑使用OPTIMIZE TABLE语句来重新组织表并压缩任何浪费的空间。重新组织的表需要更少的磁盘I&#x2F;O来执行全表扫描。这是一种简单的技术，当其他技术（如提高索引使用率或调优应用程序代码）不实用时，它可以提高性能。</p>
<p>OPTIMIZE TABLE复制表的数据部分并重建索引。好处来自于改进了索引中的数据打包，并减少了表空间和磁盘上的碎片。收益因每个表中的数据而异。您可能会发现，某些表有显著的收益，而另一些表没有，或者收益会随着时间的推移而减少，直到您下一次优化表。如果表很大，或者正在重建的索引不适合缓冲池，则此操作可能会很慢。向表中添加大量数据后的第一次运行通常比以后的运行慢得多。</p>
<p>在InnoDB中，拥有一个长的PRIMARY KEY（一个单独的列和一个很长的值，或者几个列组成一个很长的复合值）会浪费大量的磁盘空间。行的主键值在指向同一行的所有辅助索引记录中重复。</p>
<p>使用VARCHAR数据类型而不是CHAR来存储可变长度字符串或具有许多NULL值的列。CHAR（N）列总是需要N个字符来存储数据，即使字符串更短或其值为NULL。较小的表更适合缓冲池，并减少磁盘I&#x2F;O。</p>
<p>当使用COMPACT行格式（默认的InnoDB格式）和可变长度字符集（如utf8 mb 4或sjis）时，CHAR（N）列占用的空间量是可变的，但仍然至少是N个字节。</p>
<p>对于较大的表或包含大量重复文本或数值数据的表，请考虑使用COMPRESSED行格式。将数据放入缓冲池或执行全表扫描所需的磁盘I&#x2F;O更少。在做出永久性决定之前，请测量使用COMPRESSED与COMPACT行格式可以实现的压缩量。</p>
<p>MySQL的默认设置AUTOCOMMIT&#x3D;1会对忙碌的数据库服务器施加性能限制。在可行的情况下，通过发出SET AUTOCOMMIT&#x3D;0或START TRANSACTION语句，然后在进行所有更改后发出COMMIT语句，将多个相关的数据更改操作包装到单个事务中。</p>
<p>如果事务对数据库进行了修改，InnoDB必须在每次事务提交时将日志刷新到磁盘。当每次更改后都执行一次提交（与默认的自动提交设置一样）时，存储设备的I&#x2F;O吞吐量会对每秒的潜在操作数设置上限。</p>
<p>或者，对于仅由单个SELECT语句组成的事务，打开AUTOCOMMIT有助于InnoDB识别只读事务并优化它们。</p>
<p>避免在插入、更新或删除大量行后执行回滚。如果一个大的事务降低了服务器的性能，回滚它会使问题变得更糟，可能需要几倍于原始数据更改操作的时间来执行。终止数据库进程没有帮助，因为回滚在服务器启动时再次开始。</p>
<p>为了尽量减少发生此问题的可能性：</p>
<ul>
<li>增加缓冲池的大小，以便所有数据更改都可以缓存，而不是立即写入磁盘。</li>
<li>设置innodb_change_buffering&#x3D;all，以便除了插入操作外，还缓冲更新和删除操作。</li>
<li>考虑在大数据更改操作期间定期发出COMMIT语句，可能会将单个删除或更新分解为多个语句，这些语句对较少的行进行操作。</li>
</ul>
<p>InnoDB可以避免为已知为只读的事务设置事务ID（TRX_ID字段）的开销。只有可能执行写操作或锁定读取（例如SELECT…for update）的事务才需要事务ID。更新。消除不必要的事务ID可以减少每次查询或数据更改语句构造读视图时所查询的内部数据结构的大小。</p>
<p>InnoDB在以下情况下检测只读事务：</p>
<ul>
<li>该事务通过 START TRANSACTION READ ONLY 语句开始。在这种情况下，尝试对数据库进行更改（对于InnoDB，MyISAM或其他类型的表）会导致错误，并且事务将继续处于只读状态.您仍然可以在只读事务中对会话特定的临时表进行更改，或者对它们发出锁定查询，因为这些更改和锁定对任何其他事务都不可见。</li>
<li>autocommit设置被打开，这样就保证了事务是一个单一的语句，并且组成事务的单一语句是一个“非锁定“的SELECT语句。也就是说，SELECT不使用FOR UPDATE或 SHARED MODE子句。</li>
<li>事务在没有READ ONLY选项的情况下启动，但尚未执行任何更新或显式锁定行的语句。在需要更新或显式锁定之前，事务将保持只读模式。<br>因此，对于像报表生成器这样的读取密集型应用程序，您可以通过将InnoDB查询分组到 START TRANSACTION READ ONLY 和COMMIT中，或者在运行SELECT语句之前打开自动提交设置，或者简单地避免任何散布在查询中的数据更改语句来优化InnoDB查询序列。</li>
</ul>
<p>增加redo log文件的大小。当InnoDB已经写满redo log文件时，它必须在检查点中将缓冲池的修改内容写入磁盘。小的redo log文件会导致许多不必要的磁盘写入。</p>
<p>redo log文件大小由innodb_redo_log_capacity决定。InnoDB尝试维护32个相同大小的重做日志文件，每个文件等于1&#x2F;32 *innodb_redo_log_capacity。因此，更改innodb_redo_log_capacity设置会更改redo log文件的大小。</p>
<p>考虑增加日志缓冲区的大小。大型日志缓冲区使大型事务能够运行，而无需在事务提交之前将日志写入磁盘。因此，如果您有更新、插入或删除许多行的事务，那么增大日志缓冲区可以节省磁盘I&#x2F;O。日志缓冲区大小是使用innodb_log_buffer_size配置选项配置的，该选项可以动态配置。</p>
<p>配置innodb_log_write_ahead_size配置选项以避免“写时读“。此选项定义重做日志的预写块大小。设置innodb_log_write_ahead_size以匹配操作系统或文件系统缓存块大小。当由于重做日志的预写块大小与操作系统或文件系统缓存块大小不匹配而导致重做日志块未完全缓存到操作系统或文件系统时，发生写时读。</p>
<p>innodb_log_write_ahead_size的有效值是InnoDB日志文件块大小的倍数（2n）。最小值是InnoDB日志文件块大小（512）。当指定最小值时，不会发生写前操作。最大值等于innodb_page_size值。如果您为innodb_log_write_ahead_size指定的值大于innodb_page_size值，则innodb_log_write_ahead_size设置将被截断为innodb_page_size值。</p>
<p>将innodb_log_write_ahead_size值设置得相对于操作系统或文件系统缓存块大小太低会导致写时读。将该值设置得太高可能会对日志文件写入的fsync性能产生轻微影响，因为会同时写入多个块。</p>
<p>MySQL提供了专用的日志写入器线程，用于将重做日志记录从日志缓冲区写入系统缓冲区，并将系统缓冲区刷新到重做日志文件。您可以使用innodb_log_writer_threads变量启用或禁用日志写入器线程。专用日志写入器线程可以提高高并发系统的性能，但对于低并发系统，禁用专用日志写入器线程可以提供更好的性能。</p>
<p>InnoDB使用Linux上的异步I&#x2F;O子系统（本地AIO）来执行数据文件页面的预读和写入请求。此行为由innodb_use_native_aio配置选项控制，默认情况下启用该选项。对于本机AIO，I&#x2F;O调度程序的类型对I&#x2F;O性能的影响更大。通常，推荐使用noop和deadline I&#x2F;O编译器。执行基准测试以确定哪个I&#x2F;O调度程序可为您的工作负载和环境提供最佳结果。有关更多信息</p>
<h3 id="查询执行计划"><a href="#查询执行计划" class="headerlink" title="查询执行计划"></a>查询执行计划</h3><p>当EXPLAIN与可解释语句一起使用时，MySQL显示来自优化器的有关语句执行计划的信息。也就是说，MySQL解释了它将如何处理语句，包括有关表如何连接以及顺序的信息。</p>
<p>对于SELECT语句，EXPLAIN会生成可使用SHOW WARNINGS显示的其他执行计划信息。</p>
<p>EXPLAIN对于检查涉及分区表的查询很有用。</p>
<p>FORMAT选项可用于选择输出格式。TRADITIONAL以表格格式显示输出。如果不存在FORMAT选项，这是默认值。JSON格式以JSON格式显示信息。</p>
<p>优化器跟踪有时可以提供与EXPLAIN互补的信息。但是，优化器跟踪格式和内容在不同版本之间会发生变化。</p>
<p>如果您认为应该使用索引而没有使用索引，那么运行ANALYZE TABLE来更新表统计信息，例如键的基数，这可能会影响优化器做出的选择。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>EXPLAIN为SELECT语句中使用的每个表返回一行信息。它按照MySQL在处理语句时读取表的顺序列出输出中的表。这意味着MySQL从第一个表中读取一行，然后在第二个表中找到匹配的行，然后在第三个表中找到匹配的行，依此类推。当所有表都被处理完时，MySQL输出所选的列，并回溯表列表，直到找到一个有更多匹配行的表。从该表中读取下一行，然后处理下一个表。</p>
<p>本节介绍EXPLAIN生成的输出列。后面的部分提供了有关类型和附加列的其他信息。</p>
<p>EXPLAIN的每个输出行提供有关一个表的信息。每一行都包含表10 - 1“EXPLAIN输出列”中总结的值，并在下表中进行了更详细的描述。列名显示在表的第一列中;第二列提供使用FORMAT&#x3D;JSON时输出中显示的等效属性名。</p>
<ul>
<li>id: SELECT标识符。这是查询中SELECT的序号。如果行引用其他行的联合结果，则该值可以为NULL。在这种情况下，表列显示一个类似&lt;unionM，N&gt;的值，以指示该行引用id值为M和N的行的并集。</li>
<li>select type: SELECT的类型，可以是下表中显示的任何类型。JSON格式的EXPLAIN将SELECT类型公开为query_block的属性，除非它是SIMPLE或PRIMARY。JSON名称（如适用）也显示在表中。<ul>
<li>SIMPLE: 简单sql，不使用union或子查询</li>
<li>PRIMARY: 最外层查询</li>
<li>UNION: UNION的第二个或以后的select</li>
<li>DEPENDENT UNION: UNION中的第二个或以后的SELECT语句，取决于外部查询</li>
<li>UNION RESULT: UNION的结果</li>
<li>SUBQUERY： 子查询</li>
<li>DEPENDENT SUBQUERY： 子查询的第一个select,取决于外部查询</li>
<li>DERIVED： 派生表</li>
<li>DEPENDENT DERIVED：派生表依赖于另一个表</li>
<li>MATERIALIZED：物化子查询</li>
<li>UNCACHEABLE SUBQUERY： 一个子查询，其结果无法缓存，并且必须为外部查询的每一行重新评估</li>
<li>UNCACHEABLE UNION：属于不可缓存子查询的UNION中的第二个或以后的选择</li>
</ul>
</li>
<li>table: 表名称</li>
<li>partitions: 查询将从中匹配记录的分区。对于未分区的表，该值为NULL。</li>
<li>type: 连接类型</li>
<li>possible_keys：possible_keys列表示MySQL可以从中选择查找此表中的行的索引。请注意，该列与EXPLAIN输出中显示的表顺序完全无关。这意味着possible_keys中的某些键在实际中可能无法使用生成的表顺序。如果此列为NULL（或在JSON格式的输出中未定义），则没有相关索引。在这种情况下，您可以通过检查WHERE子句来检查它是否引用了适合索引的某个或某些列，从而提高查询的性能。如果是，请创建一个适当的索引，并再次使用EXPLAIN检查查询。</li>
<li>key：key列表示MySQL实际决定使用的键（索引）。如果MySQL决定使用一个可能的_keys索引来查找行，则该索引将作为键值列出。对于InnoDB，即使查询也选择了主键，二级索引也可能覆盖选定的列，因为InnoDB将主键值与每个二级索引一起存储。如果key为NULL，则MySQL找不到可以更有效地执行查询的索引。</li>
<li>key_len：key_len列表示MySQL决定使用的键的长度。key_len的值使您能够确定MySQL实际使用了多部分键的多少部分。如果key列显示NULL，key_len列也显示NULL。</li>
<li>ref：ref列显示将哪些列或常数与键列中命名的索引进行比较，以从表中选择行。</li>
<li>rows: rows列表示MySQL认为执行查询必须检查的行数。对于InnoDB表，这个数字是一个估计值，可能并不总是准确的。</li>
<li>filtered:筛选列指示按表条件筛选的表行的估计百分比。最大值为100，这意味着未进行行筛选。值从100减小表示过滤量增加。rows显示检查的估计行数，rows×filtered显示与下表连接的行数。例如，如果行数为1000，筛选为50.00（50%），则要与下表联接的行数为1000 × 50% &#x3D; 500。</li>
<li>Extra:此列包含有关MySQL如何解析查询的其他信息。</li>
</ul>
<p>连接类型，从最好到最坏排序</p>
<ul>
<li>system: 该表只有一行,const类型的一个特例</li>
<li>const: 该表最多有一个匹配行，在查询开始时读取。因为只有一行，所以该行中的列的值可以被优化器的其余部分视为常量。const表非常快，因为它们只被读取一次。</li>
<li>eq_ref: 对于前一个表中的每个行组合，从该表中读取一行。除了system和const类型，这是最好的连接类型。当索引的所有部分都被联接使用并且索引是PRIMARY KEY或UNIQUE NOT NULL索引时，使用它。eq_ref可用于使用&#x3D;运算符进行比较的索引列。比较值可以是常数，也可以是使用在此表之前读取的表中的列的表达式。</li>
<li>ref: 对于以前表中的每个行组合，将从此表中读取具有匹配索引值的所有行。如果连接仅使用键的最左边前缀，或者键不是PRIMARY KEY或UNIQUE索引（换句话说，如果连接无法基于键值选择单行），则使用ref。如果所使用的键只匹配几行，则这是一种很好的联接类型。ref可用于使用&#x3D;或&lt;&#x3D;&gt;运算符进行比较的索引列。</li>
<li>fulltext: 连接是使用FULLTEXT索引执行的。</li>
<li>ref_or_null:这种连接类型类似于ref，但MySQL会额外搜索包含NULL值的行。这种连接类型优化最常用于解析子查询。</li>
<li>index_merge: 此联接类型指示使用索引合并优化。在这种情况下，输出行中的键列包含所使用的索引的列表，而key_len包含所使用的索引的最长键部分的列表。</li>
<li>unique_subquery: 此类型替换以下形式的某些IN子查询的eq_ref：<code>value IN (SELECT primary_key FROM single_table WHERE some_expr)</code></li>
<li>index_subquery: 这个连接类型类似于unique_subquery。它取代了IN子查询，但它适用于以下形式的子查询中的非唯一索引</li>
<li>range: 只检索给定范围内的行，并使用索引选择行。输出行中的键列指示使用的索引。key_len包含使用的最长密钥部分。此类型的ref列为NULL。当使用&#x3D;、&lt;&gt;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、IS NULL、&lt; &#x3D;&gt;、BETWEEN、LIKE或IN（）运算符中的任何一个将键列与常量进行比较时，可以使用range</li>
<li>index: 索引连接类型与ALL相同，只是索引树被扫描。<ul>
<li>如果索引是查询的覆盖索引，并且可以用于满足表中所需的所有数据，则只扫描索引树。在本例中，Extra列显示Using index。仅索引扫描通常比ALL扫描快，因为索引的大小通常小于表数据。</li>
<li>全表扫描是通过从索引中读取数据来执行的，以便按索引顺序查找数据行。使用索引不会出现在“extra”列中。</li>
</ul>
</li>
<li>all: 全表扫描</li>
</ul>
<p>extra信息,EXPLAIN输出的Extra列包含有关MySQL如何解析查询的其他信息.如果你想让你的查询尽可能快，请注意Using filesort和Using temporary的Extra列值，或者，在JSON格式的EXPLAIN输出中，using_filesort和using_temporary_table属性等于true。</p>
<ul>
<li>Backward index scan: 优化器可以在InnoDB表上使用降序索引。与使用索引一起显示。</li>
<li>Child of ‘table’ pushed join@1: 这个表在一个可以下推到NDB内核的连接中被引用为表的子表。仅在NDB集群中启用下推连接时启用。</li>
<li>const row not found: 对于 SELECT … FROM tbl_name 这样的查询，表为空。</li>
<li>Deleting all rows: 对于MySQL，一些存储引擎（如MyISAM）支持一个处理程序方法，该方法以简单快速的方式删除所有表行。如果引擎使用此优化，则会显示此额外值。</li>
<li>Distinct: MySQL正在寻找不同的值，所以它在找到第一个匹配的行后停止为当前行组合搜索更多的行。</li>
<li>FirstMatch: 半连接FirstMatch连接捷径策略用于tbl_name。</li>
<li>Full scan on NULL key: 当优化器无法使用索引查找访问方法时，作为一种回退策略，子查询优化会出现这种情况。</li>
<li>Impossible HAVING: HAVING子句始终为false，不能选择任何行。</li>
<li>Impossible WHERE: WHERE子句始终为false，不能选择任何行。</li>
<li>Impossible WHERE noticed after reading const tables: MySQL已经读取了所有的const（和系统）表，并注意到WHERE子句总是false。</li>
<li>LooseScan: 使用半连接LooseScan策略。m和n是关键部件号。</li>
<li>No matching min&#x2F;max row: 没有行满足查询条件，例如 SELECT MIN(…) FROM … WHERE condition 。</li>
<li>no matching row in const table: 对于具有联接的查询，存在空表或没有满足唯一索引条件的行的表。</li>
<li>No matching rows after partition pruning: 对于DELETE或UPDATE，优化器在分区修剪后没有发现任何要删除或更新的内容。它的含义类似于SELECT语句的Impossible WHERE。</li>
<li>No tables used: 查询没有FROM子句，或者有FROM DUAL子句。</li>
<li>Not exists: MySQL能够对查询进行LEFT JOIN优化，并且在找到一个符合LEFT JOIN条件的行后，不会检查此表中的更多行以查找前一行组合。下面是一个可以通过这种方式优化的查询类型的示例：<code>SELECT * FROM t1 LEFT JOIN t2 ON t1.id=t2.id WHERE t2.id IS NULL;</code></li>
<li>Plan isn’t ready yet: 当优化器尚未完成为在命名连接中执行的语句创建执行计划时，此值与 EXPLAIN FOR CONNECTION 一起出现。如果执行计划输出包含多行，则其中任何一行或所有行都可以具有此Extra值，具体取决于优化器确定完整执行计划的进度。</li>
<li>Range checked for each record: MySQL找不到可用的索引，但发现某些索引可能在前面表中的列值已知后使用。对于前面表中的每个行组合，MySQL检查是否可以使用range或index_merge访问方法来检索行。这不是非常快，但比执行没有索引的连接要快。</li>
<li>Recursive: 这表示该行应用于递归公用表表达式的递归SELECT部分。</li>
<li>Using filesort: MySQL必须执行一个额外的过程来找出如何按排序顺序检索行。排序是通过根据联接类型遍历所有行并为匹配WHERE子句的所有行存储排序键和该行指针来完成的。然后对键进行排序，并按排序顺序检索行。</li>
<li>Using index : 只使用索引树中的信息从表中检索列信息，而不必执行额外的查找来读取实际行。当查询仅使用属于单个索引的列时，可以使用此策略。对于具有用户定义的聚集索引的InnoDB表，即使Extra列中没有Using index，也可以使用该索引。如果type是index，key是PRIMARY，就是这种情况。</li>
<li>Using index condition: 读取表的方法是访问索引元组并首先测试它们以确定是否读取整个表行。通过这种方式，索引信息用于推迟（“下推“）阅读整个表行，除非必要。</li>
<li>Using index for group-by: Using index for group-by表示MySQL找到了一个索引，可以用于检索GROUP BY或DISTINCT查询的所有列，而无需对实际表进行任何额外的磁盘访问。此外，索引以最有效的方式使用，因此对于每个组，仅读取几个索引条目。</li>
<li>Using index for skip scan: 指示使用“跳过扫描”访问方法。</li>
<li>Using join buffer: 来自早期联接的表被逐部分读入联接缓冲区，然后使用缓冲区中的表行与当前表进行联接。（Block Nested Loop）指示使用Block Nested-Loop算法， (Batched Key Access) 指示使用Batched Key Access算法，（hash join）指示使用hash join。也就是说，EXPLAIN输出的前一行上的表中的键被缓冲，匹配的行从Using join buffer出现的行所表示的表中批量获取。</li>
<li>Using MRR: 使用多范围读取优化策略读取表。</li>
<li>Using sort_union(…), Using union(…), Using intersect(…) : 这些指示了特定的算法，该算法显示了如何为index_merge连接类型合并索引扫描。</li>
<li>Using temporary: 要解析查询，MySQL需要创建一个临时表来保存结果。如果查询包含以不同方式列出列的GROUP BY和ORDER BY子句，则通常会发生这种情况。</li>
<li>Using where: WHERE子句用于限制哪些行与下一个表匹配或发送到客户端。除非您特别打算从表中提取或检查所有行，否则如果Extra值不是Using where，并且表连接类型是ALL或index，则查询中可能存在错误。</li>
<li>Zero limit: 查询具有LIMIT 0子句，无法选择任何行。</li>
</ul>
<p>explain输出解释</p>
<p>通过取EXPLAIN输出的rows列中的值的乘积，可以很好地指示连接的好坏。这应该告诉你MySQL执行查询必须检查多少行。如果您使用max_join_size系统变量限制查询，则此行积还用于确定执行哪些多表SELECT语句以及中止哪些多表SELECT语句。</p>
<p>假设您有这里显示的SELECT语句，并且计划使用EXPLAIN检查它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT tt.TicketNumber, tt.TimeIn,</span><br><span class="line">               tt.ProjectReference, tt.EstimatedShipDate,</span><br><span class="line">               tt.ActualShipDate, tt.ClientID,</span><br><span class="line">               tt.ServiceCodes, tt.RepetitiveID,</span><br><span class="line">               tt.CurrentProcess, tt.CurrentDPPerson,</span><br><span class="line">               tt.RecordVolume, tt.DPPrinted, et.COUNTRY,</span><br><span class="line">               et_1.COUNTRY, do.CUSTNAME</span><br><span class="line">        FROM tt, et, et AS et_1, do</span><br><span class="line">        WHERE tt.SubmitTime IS NULL</span><br><span class="line">          AND tt.ActualPC = et.EMPLOYID</span><br><span class="line">          AND tt.AssignedPC = et_1.EMPLOYID</span><br><span class="line">          AND tt.ClientID = do.CUSTNMBR;</span><br></pre></td></tr></table></figure>

<p>表具有以下索引</p>
<ul>
<li>tt: ActualPC</li>
<li>tt: AssignedPC</li>
<li>tt: ClientID</li>
<li>et: EMPLOYID (primary key) </li>
<li>do: CUSTNMBR (primary key)</li>
</ul>
<p>查询计划如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">table type possible_keys key  key_len ref  rows  Extra</span><br><span class="line">et    ALL  PRIMARY       NULL NULL    NULL 74</span><br><span class="line">do    ALL  PRIMARY       NULL NULL    NULL 2135</span><br><span class="line">et_1  ALL  PRIMARY       NULL NULL    NULL 74</span><br><span class="line">tt    ALL  AssignedPC,   NULL NULL    NULL 3872</span><br><span class="line">           ClientID,</span><br><span class="line">           ActualPC</span><br><span class="line">      Range checked for each record (index map: 0x23)</span><br></pre></td></tr></table></figure>

<p>因为每个表的类型都是ALL，所以这个输出表明MySQL正在生成所有表的笛卡尔积;也就是说，每个行的组合。这需要相当长的时间，因为必须检查每个表中行数的乘积。对于手头的情况，这个乘积是74 × 2135 × 74 × 3872 &#x3D; 45，268，558，720行。如果表再大一点，你只能想象要花多长时间。</p>
<p>这里的一个问题是，如果列声明为相同的类型和大小，MySQL可以更有效地使用列上的索引。在这种情况下，如果VARCHAR和CHAR声明为相同的大小，则它们被认为是相同的。</p>
<p>设置为相同大小以后，查询计划如下, 可以看到乘积是 74 * 52 &#x3D; 3848行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">table type   possible_keys key      key_len ref           rows Extra</span><br><span class="line">et    ALL    PRIMARY       NULL     NULL    NULL          74</span><br><span class="line">tt    ref    AssignedPC,   ActualPC 15      et.EMPLOYID   52   Using</span><br><span class="line">             ClientID,                                         where</span><br><span class="line">             ActualPC</span><br><span class="line">et_1  eq_ref PRIMARY       PRIMARY  15      tt.AssignedPC 1</span><br><span class="line">do    eq_ref PRIMARY       PRIMARY  15      tt.ClientID   1</span><br></pre></td></tr></table></figure>

<p>在这一点上，查询几乎是尽可能优化的。剩下的问题是，默认情况下，MySQL假设tt.ActualPC列中的值是均匀分布的，而tt表的情况并非如此。幸运的是，让MySQL分析密钥分布很容易：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ANALYZE TABLE tt;</span><br></pre></td></tr></table></figure>

<p>有了额外的索引信息，连接是完美的，EXPLAIN会产生以下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">table type   possible_keys key     key_len ref           rows Extra</span><br><span class="line">tt    ALL    AssignedPC    NULL    NULL    NULL          3872 Using</span><br><span class="line">             ClientID,                                        where</span><br><span class="line">             ActualPC</span><br><span class="line">et    eq_ref PRIMARY       PRIMARY 15      tt.ActualPC   1</span><br><span class="line">et_1  eq_ref PRIMARY       PRIMARY 15      tt.AssignedPC 1</span><br><span class="line">do    eq_ref PRIMARY       PRIMARY 15      tt.ClientID   1</span><br></pre></td></tr></table></figure>

<p>EXPLAIN输出中的rows列是MySQL连接优化器的合理猜测。通过将行积与查询返回的实际行数进行比较，检查这些数字是否更接近真实情况。如果数字相差很大，那么通过在SELECT语句中使用STRAIGHT_JOIN并尝试在FROM子句中以不同的顺序列出表，可能会获得更好的性能。（但是，STRAIGHT_JOIN可能会阻止使用索引，因为它禁用了半连接转换。</p>
<h3 id="控制查询计划"><a href="#控制查询计划" class="headerlink" title="控制查询计划"></a>控制查询计划</h3><p>查询优化器的任务是找到执行SQL查询的最佳计划。由于“好“和“坏“计划之间的性能差异可能是数量级的（即秒与小时甚至天），大多数查询优化器，包括MySQL的查询优化器，都会在所有可能的查询评估计划中执行或多或少的穷举搜索以找到最佳计划。对于连接查询，MySQL优化器调查的可能计划的数量随着查询中引用的表的数量呈指数级增长。对于少量的表（通常少于7到10个），这不是问题。然而，当提交较大的查询时，查询优化所花费的时间很容易成为服务器性能的主要瓶颈。</p>
<p>更灵活的查询优化方法使用户能够控制优化器在搜索最佳查询评估计划时的详尽程度。一般的想法是，优化器调查的计划越少，编译查询所花费的时间就越少。另一方面，由于优化器跳过了一些计划，它可能会错过寻找最佳计划。</p>
<p>优化器在其评估的计划数量方面的行为可以使用两个系统变量进行控制：</p>
<ul>
<li>optimizer_prune_level变量告诉优化器根据对每个表访问的行数的估计跳过某些计划。我们的经验表明，这种“有根据的猜测”很少会错过最佳计划，并且可以大大减少查询编译时间。这就是为什么这个选项默认为on（optimizer_prune_level &#x3D; 1）。但是，如果您认为优化器错过了一个更好的查询计划，则可以关闭此选项（optimizer_prune_level &#x3D; 0），但查询编译可能需要更长的时间。请注意，即使使用这种启发式方法，优化器仍然会探索大约指数数量的计划。</li>
<li>optimizer_search_depth变量告诉优化器应该查看每个未完成计划的“未来“多远，以评估是否应该进一步扩展它。optimizer_search_depth的值越小，查询编译时间可能会减少几个数量级。例如，如果optimizer_search_depth接近查询中的表数，则包含12、13或更多表的查询可能很容易需要数小时甚至数天来编译。同时，如果编译时optimizer_search_depth等于3或4，优化器可能会在不到一分钟的时间内编译同一个查询。如果您不确定optimizer_search_depth的合理值是多少，可以将此变量设置为0，以告知优化器自动确定该值。</li>
</ul>
<p>optimizer_switch系统变量用于控制优化器的行为。它的值是一组标志，每个标志都有一个值on或off，以指示相应的优化器行为是启用还是禁用。该变量具有全局值和会话值，可以在运行时更改。全局默认值可以在服务器启动时设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT @@optimizer_switch\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@optimizer_switch: index_merge=on,index_merge_union=on,</span><br><span class="line">                    index_merge_sort_union=on,index_merge_intersection=on,</span><br><span class="line">                    engine_condition_pushdown=on,index_condition_pushdown=on,</span><br><span class="line">                    mrr=on,mrr_cost_based=on,block_nested_loop=on,</span><br><span class="line">                    batched_key_access=off,materialization=on,semijoin=on,</span><br><span class="line">                    loosescan=on,firstmatch=on,duplicateweedout=on,</span><br><span class="line">                    subquery_materialization_cost_based=on,</span><br><span class="line">                    use_index_extensions=on,condition_fanout_filter=on,</span><br><span class="line">                    derived_merge=on,use_invisible_indexes=off,skip_scan=on,</span><br><span class="line">                    hash_join=on,subquery_to_derived=off,</span><br><span class="line">                    prefer_ordering_index=on,hypergraph_optimizer=off,</span><br><span class="line">                    derived_condition_pushdown=on,hash_set_operations=on</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>要更改optimizer_switch的值，请分配一个由逗号分隔的一个或多个命令列表组成的值：</p>
<p>优化器提示: 可以通过注释对优化器进行提示，来使用何种方法执行sql。<code>SELECT /*+ BKA(t1) NO_BKA(t2) */ * FROM t1 INNER JOIN t2 WHERE ...;</code></p>
<p>索引提示：可以控制使用哪个索引，后面指明索引名称。<code>SELECT * FROM table1 USE INDEX (col1_index,col2_index)WHERE col1=1 AND col2=2 AND col3=3;</code></p>
<h4 id="成本模型"><a href="#成本模型" class="headerlink" title="成本模型"></a>成本模型</h4><p>为了生成执行计划，优化器使用一个成本模型，该模型基于对查询执行期间发生的各种操作的成本的估计。优化器有一组编译后的默认“成本常量“，可用于制定有关执行计划的决策。</p>
<p>优化器还有一个在执行计划构造期间使用的成本估计数据库。这些估计值存储在mysql系统数据库的server_cost和engine_cost表中，可以随时配置。这些表的目的是使优化器在尝试获得查询执行计划时可以轻松地调整成本估计。</p>
<p>服务器在启动时将成本模型表读入内存，并在运行时使用内存中的值。表中指定的任何非NULL成本估计优先于相应的编译默认成本常量。任何NULL估计值都指示优化器使用编译后的默认值。</p>
<p>在运行时，服务器可以重新读取成本表。当动态加载存储引擎或执行FLUSH OPTIMIZER_COSTS语句时，会发生这种情况。</p>
<p>成本表使服务器管理员能够通过更改表中的条目来轻松调整成本估计。通过将条目的成本设置为NULL，也可以很容易地恢复到默认值。优化器使用内存中的成本值，因此对表的更改应该在FLUSH OPTIMIZER_COSTS之后生效。</p>
<p>当客户端会话开始时，内存中的当前成本估计值将应用于整个会话，直到会话结束。特别是，如果服务器重新读取成本表，任何更改的估计仅适用于随后启动的会话。现有会话不受影响。</p>
<p>成本表特定于给定的服务器实例。服务器不会将成本表更改复制到副本。</p>
<p>优化器成本模型数据库由mysql系统数据库中的两个表组成，它们包含查询执行期间发生的操作的成本估计信息：</p>
<ul>
<li>server_cost：一般服务器操作的优化器成本估计</li>
<li>engine_cost：针对特定存储引擎的操作的优化器成本估计</li>
</ul>
<h4 id="统计信息"><a href="#统计信息" class="headerlink" title="统计信息"></a>统计信息</h4><p>column_statistics数据字典表存储有关列值的直方图统计信息，供优化器在构造查询执行计划时使用。要执行直方图管理，请使用ANALYZE TABLE语句。</p>
<ul>
<li>该表包含除几何类型（空间数据）和JSON之外的所有数据类型的列的统计信息。</li>
<li>该表是持久的，因此不必在每次服务器启动时都创建列统计信息。</li>
<li>服务器对表执行更新，用户不执行。</li>
</ul>
<p>用户不能直接访问column_statistics表，因为它是数据字典的一部分。直方图信息可使用 INFORMATION_SCHEMA.COLUMN_STATISTICS 获得，它是作为数据字典表上的视图实现的。COLUMN_STATISTICS包含以下列：</p>
<ul>
<li>SCHEMA_NAME、TABLE_NAME、COLUMN_NAME：应用统计信息的模式、表和列的名称。</li>
<li>HISTORIO：描述列统计信息的JSON值，存储为直方图。</li>
</ul>
<p>直方图实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;buckets&quot;: [</span><br><span class="line">    [</span><br><span class="line">      1,</span><br><span class="line">      0.3333333333333333</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      2,</span><br><span class="line">      0.6666666666666666</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      3,</span><br><span class="line">      1</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  &quot;null-values&quot;: 0,</span><br><span class="line">  &quot;last-updated&quot;: &quot;2017-03-24 13:32:40.000000&quot;,</span><br><span class="line">  &quot;sampling-rate&quot;: 1,</span><br><span class="line">  &quot;histogram-type&quot;: &quot;singleton&quot;,</span><br><span class="line">  &quot;number-of-buckets-specified&quot;: 128,</span><br><span class="line">  &quot;data-type&quot;: &quot;int&quot;,</span><br><span class="line">  &quot;collation-id&quot;: 8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>buckets：直方图桶。桶结构取决于直方图类型。</li>
<li>null-values：一个介于0.0和1.0之间的数字，表示SQLNULL值的列值的分数。如果为0，则该列不包含NULL值。</li>
<li>last-updated：直方图生成时，以 YYYY-MM-DD hh:mm:ss.uuuuuu 格式的UTC值表示。</li>
<li>sampling-rate：0.0到1.0之间的数字，表示为创建直方图而采样的数据比例。值为1表示已读取所有数据（无采样）。</li>
<li>histogram-type：直方图类型：<ul>
<li>singleton：一个bucket表示列中的一个值。当列中的非重复值数量小于或等于生成直方图的ANALYZE TABLE语句中指定的存储桶数量时，将创建此直方图类型。</li>
<li>equi-height：一个桶表示一个值范围。当列中的非重复值数量大于生成直方图的ANALYZE TABLE语句中指定的存储桶数量时，将创建此直方图类型。</li>
</ul>
</li>
<li>number-of-buckets-specified：生成直方图的ANALYZE TABLE语句中指定的桶数。</li>
<li>data-type：此直方图包含的数据类型。在将直方图从持久性存储器阅读和解析到内存中时，这是需要的。该值是int、uint（无符号整数）、double、decimal、datetime或string（包括字符和二进制字符串）之一。</li>
<li>collation-id：直方图数据的归类ID。当数据类型值是字符串时，它最有意义。值对应于信息架构COLLATIONS表中的ID列值。</li>
</ul>
<p>直方图统计信息主要用于非索引列。将索引添加到直方图统计信息适用的列还可以帮助优化器进行行估计。</p>
<p>优化器更喜欢范围优化器的行估计，而不是从直方图统计信息中获得的行估计。如果优化器确定范围优化器适用，则不使用直方图统计信息。</p>
<p>对于已建立索引的列，可以使用索引潜水获得行估计值以进行相等比较。</p>
<p>在某些情况下，使用直方图统计信息可能不会改善查询执行（例如，如果统计信息过期）。要检查是否是这种情况，请使用ANALYZE TABLE重新生成直方图统计信息，然后再次运行查询。</p>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><p>MySQL对InnoDB表使用行级锁定，以支持多个会话的同时写访问，使其适用于多用户，高并发和OLTP应用程序。</p>
<p>为了避免在单个InnoDB表上执行多个并发写操作时出现死锁，请在事务开始时通过为预期要修改的每组行发出 SELECT … FOR UPDATE 语句来获取必要的锁，即使数据更改语句在事务中稍后出现。如果事务修改或锁定多个表，则在每个事务中以相同的顺序发出适用的语句。死锁会影响性能，而不是代表一个严重的错误，因为InnoDB默认情况下会自动检测死锁条件并回滚其中一个受影响的事务。</p>
<p>在高并发系统中，当多个线程等待同一个锁时，死锁检测可能会导致速度降低。有时，禁用死锁检测并在发生死锁时依赖innodb_lock_wait_timeout设置进行事务回滚可能更有效。可以使用innodb_deadlock_detect配置选项禁用死锁检测。</p>
<p>行级锁定的优点：</p>
<ul>
<li>当不同的会话访问不同的行时，锁冲突更少。</li>
<li>回滚更改更少。</li>
<li>可以长时间锁定单行。</li>
</ul>
<p>MySQL对MyISAM、MEMORY和MERGE表使用表级锁定，每次只允许一个会话更新这些表。这种锁定级别使这些存储引擎更适合只读、多读或单用户应用程序。</p>
<h2 id="innodb优化"><a href="#innodb优化" class="headerlink" title="innodb优化"></a>innodb优化</h2><h3 id="innodb最佳实践"><a href="#innodb最佳实践" class="headerlink" title="innodb最佳实践"></a>innodb最佳实践</h3><p>使用最常查询的列为每个表指定主键，如果没有明显的主键，则指定自动递增值。</p>
<p>只要数据是基于来自多个表的相同ID值从这些表中提取的，就可以使用联接。为了实现快速联接性能，请在联接列上定义外键，并在每个表中用相同的数据类型声明这些列。添加外键可确保对引用的列进行索引，这可以提高性能。外键还将删除和更新传播到所有受影响的表，并且如果父表中不存在对应的ID，则防止在子表中插入数据。</p>
<p>关闭自动提交。每秒提交数百次会限制性能（受存储设备的写入速度限制）。</p>
<p>通过使用START TRANSACTION和COMMIT语句将相关的DML操作集括起来，将它们分组到事务中。虽然您不想提交得太频繁，但也不想发出大量的INSERT、UPDATE或DELETE语句，这些语句会运行数小时而不提交。</p>
<p>不要使用RESTABLES语句。InnoDB可以处理多个会话，所有阅读和写同一个表一次，而不会牺牲可靠性或高性能。要获得对一组行的独占写访问权限，请使用 SELECT … FOR UPDATE 语法仅锁定要更新的行。</p>
<p>启用innodb_file_per_table变量或使用常规表空间将表的数据和索引放在单独的文件中，而不是系统文件夹中。</p>
<p>评估您的数据和访问模式是否受益于InnoDB表或页面压缩功能。您可以压缩InnoDB表而不牺牲读&#x2F;写能力。</p>
<p>使用 –sql_mode&#x3D;NO_ENGINE_SUBSTITUTION 选项运行服务器，以防止使用您不想使用的存储引擎创建表。</p>
<h3 id="buffer-pool"><a href="#buffer-pool" class="headerlink" title="buffer pool"></a>buffer pool</h3><p>建议设置内存的50%以上给buffer pool，设置的越多，就越像内存数据库</p>
<p>淘汰算法类似<code>LRU-K</code>，缓冲池分为Old和young两段，一开始插入old的头，如果再次访问则插入young。缓冲池的3&#x2F;8专用于旧的子列表。</p>
<p>默认情况下，查询读取的页面会立即移动到新的子列表中，这意味着它们在缓冲池中停留的时间更长。例如，为mysqldump操作或不带WHERE子句的SELECT语句执行的表扫描可以将大量数据带入缓冲池并驱逐等量的旧数据，即使新数据永远不会再次使用。类似地，由预读后台线程加载且仅访问过一次的页将被移动到新列表的头部。这些情况可能会将经常使用的页面推到旧的子列表中，在那里它们会被驱逐。</p>
<p>在具有足够内存的64位系统上，可以将缓冲池拆分为多个部分，以最小化并发操作之间对内存结构的争用。</p>
<p>您可以控制如何以及何时执行预读请求，以便在预期即将需要页时将页异步预取到缓冲池中。</p>
<p>您可以控制何时发生后台刷新，以及是否根据工作负载动态调整刷新速率。</p>
<p>您可以配置InnoDB如何保留当前缓冲池状态，以避免服务器重启后的漫长预热期。</p>
<p>可以使用<code>SHOW ENGINE INNODB STATUS </code>来查看缓冲池状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 2198863872</span><br><span class="line">Dictionary memory allocated 776332</span><br><span class="line">Buffer pool size   131072</span><br><span class="line">Free buffers       124908</span><br><span class="line">Database pages     5720</span><br><span class="line">Old database pages 2071</span><br><span class="line">Modified db pages  910</span><br><span class="line">Pending reads 0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 4, not young 0</span><br><span class="line">0.10 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 197, created 5523, written 5060</span><br><span class="line">0.00 reads/s, 190.89 creates/s, 244.94 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not</span><br><span class="line">0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read</span><br><span class="line">ahead 0.00/s</span><br><span class="line">LRU len: 5720, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br></pre></td></tr></table></figure>

<h3 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h3><p>change buffer 是一种特殊的数据结构，当辅助索引页不在缓冲池中时，它会缓存这些页的更改。缓冲的更改（可能是由DELETE、UPDATE或DML操作引起的）在以后通过其他读取操作将页加载到缓冲池时合并。</p>
<p>与聚集索引不同，辅助索引通常是非唯一的，插入辅助索引的顺序相对随机。同样，删除和更新可能会影响索引树中不相邻的二级索引页。当其他操作将受影响的页读入缓冲池时，在以后合并缓存的更改可以避免将辅助索引页从磁盘读入缓冲池所需的大量随机访问I&#x2F;O。</p>
<p>在系统大部分空闲时或缓慢关机期间运行的清除操作会定期将更新的索引页写入磁盘。与立即将每个值写入磁盘相比，清除操作可以更高效地写入一系列索引值的磁盘块。</p>
<p>当有许多受影响的行和许多要更新的辅助索引时，更改缓冲区合并可能需要几个小时。在此期间，磁盘I&#x2F;O会增加，这可能会导致磁盘绑定查询的速度显著降低。更改缓冲区合并也可能在事务提交后继续发生，甚至在服务器关闭并重新启动后也会发生</p>
<p>在内存中，更改缓冲区占用缓冲池的一部分。在磁盘上，更改缓冲区是系统缓存的一部分，当数据库服务器关闭时，索引更改将在其中进行缓冲。</p>
<p>如果索引包含降序索引列，或者如果主键包含降序索引列，则不支持辅助索引的更改缓冲。</p>
<p>当对表执行INSERT, UPDATE和DELETE操作时，索引列的值（特别是辅助键的值）通常是无序的，需要大量的I&#x2F;O来更新辅助索引。当相关页不在缓冲池中时，更改缓冲区将缓存对辅助索引条目的更改，从而避免了昂贵的I&#x2F;O操作，因为它不会立即从磁盘阅读页。当页加载到缓冲池中时，将合并缓冲的更改，更新后的页稍后将刷新到磁盘。InnoDB主线程在服务器接近空闲时和缓慢关闭期间合并缓冲的更改。</p>
<p>由于更改缓冲可以减少磁盘读取和写入，因此它对于I&#x2F;O受限的工作负载最有价值;例如，具有大量DML操作（如批量插入）的应用程序将受益于更改缓冲。</p>
<p>但是，更改缓冲区占用了缓冲池的一部分，从而减少了可用于缓存数据页的内存。如果工作集几乎适合缓冲池，或者表的辅助索引相对较少，则禁用更改缓冲可能很有用。如果工作数据集完全适合缓冲池，则更改缓冲不会产生额外的开销，因为它只应用于不在缓冲池中的页。</p>
<p>innodb_change_buffering变量控制InnoDB执行更改缓冲的程度。您可以为插入、删除操作（当索引记录最初标记为删除时）和清除操作（当索引记录被物理删除时）启用或禁用缓冲。更新操作是插入和删除的组合。默认的innodb_change_buffering值是none</p>
<p>innodb_change_buffer_max_size变量允许将更改缓冲区的最大大小配置为缓冲池总大小的百分比。默认情况下，innodb_change_buffer_max_size设置为25。最大设置为50。</p>
<p>考虑在具有大量插入、更新和删除活动的MySQL服务器上增加innodb_change_buffer_max_size，其中更改缓冲区合并无法跟上新的更改缓冲区条目，导致更改缓冲区达到其最大大小限制。</p>
<p>如果MySQL服务器上的静态数据用于报告，或者如果更改缓冲区占用了太多与缓冲池共享的内存空间，导致页面比预期更快地老化，请考虑减少innodb_change_buffer_max_size。</p>
<p>使用具有代表性的工作负载测试不同的设置以确定最佳配置。innodb_change_buffer_max_size变量是动态的，允许在不重启服务器的情况下修改设置。</p>
<p>要查看监视器数据，请发出SHOW ENGINE INNODB STATUS语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 0, seg size 2, 0 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 4425293, used cells 32, node heap has 1 buffer(s)</span><br><span class="line">13577.57 hash searches/s, 202.47 non-hash searches/s</span><br></pre></td></tr></table></figure>

<h3 id="双写缓冲区"><a href="#双写缓冲区" class="headerlink" title="双写缓冲区"></a>双写缓冲区</h3><p>双写缓冲区是一个存储区域，InnoDB在将页面写入InnoDB数据文件中的适当位置之前，将从缓冲池刷新的页面写入其中。如果在页面写入过程中出现操作系统、存储子系统或意外的mysqld进程退出，InnoDB可以在崩溃恢复期间从doublewrite缓冲区中找到页面的良好副本。</p>
<p>虽然数据被写入两次，但双写缓冲区不需要两倍的I&#x2F;O开销或两倍的I&#x2F;O操作。数据以一个大的顺序块的形式写入双写缓冲区，并对操作系统进行单个fsync（）调用（除非innodb_flush_method设置为O_DIRECT_NO_FSYNC）。</p>
<p>双写缓冲存储区位于双写文件中。</p>
<p>为双写缓冲区配置提供了以下变量：</p>
<ul>
<li>innodb_doublewrite变量控制是否启用双写缓冲区。它在大多数情况下默认启用。要禁用双写缓冲区，请将innodb_doublewrite设置为OFF。如果您更关心的是性能而不是数据完整性，那么可以考虑禁用双写缓冲区，例如，在执行基准测试时可能就是这种情况。</li>
<li>innodb_doublewrite支持DETECT_AND_RECOVER和DETECT_ONLY设置。<ul>
<li>DETECT_AND_RECOVER设置与ON设置相同。通过此设置，双写缓冲区将完全启用，数据库页内容将写入双写缓冲区，在恢复期间将访问该缓冲区以修复不完整的页写入。</li>
<li>使用DETECT_ONLY设置时，仅将元数据写入双写缓冲区。数据库页内容不写入双写缓冲区，恢复不使用双写缓冲区来修复不完整的页写入。此轻量级设置仅用于检测不完整的页写入。</li>
</ul>
</li>
<li>innodb_doublewrite_dir变量定义了InnoDB创建doublewrite文件的目录。如果未指定目录，则在innodb_data_home_dir目录中创建双写文件，如果未指定，则默认为data目录。</li>
<li>innodb_doublewrite_files变量定义了双写文件的数量，默认值为2。默认情况下，为每个缓冲池实例创建两个双写文件：刷新列表双写文件和LRU列表双写文件。刷新列表双写文件用于从缓冲池刷新列表中刷新的页面。刷新列表双写文件的默认大小是InnoDB页面大小 * 双写页面字节。innodb_doublewrite_files变量用于高级性能调优。默认设置应该适合大多数用户。</li>
<li>innodb_doublewrite_pages变量控制每个线程的最大双写页面数。此变量用于高级性能调整。默认值应该适合大多数用户。</li>
</ul>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>重做日志是一种基于磁盘的数据结构，在崩溃恢复期间用于纠正未完成事务写入的数据。在正常操作过程中，重做日志对SQL语句或低级API调用产生的更改表数据的请求进行编码。在意外关闭之前未完成更新数据文件的修改将在初始化期间和接受连接之前自动重播。</p>
<p>重做日志在磁盘上由重做日志文件物理表示。写入重做日志文件的数据按照受影响的记录进行编码，这些数据统称为重做。数据通过重做日志文件的传递由不断增加的LSN值表示。重做日志数据在数据修改时追加，最旧的数据在检查点进行时被截断。</p>
<p>重做日志文件驻留在数据目录中的#innodb_redo目录中，除非innodb_log_group_home_dir变量指定了不同的目录。如果定义了innodb_log_group_home_dir，则重做日志文件驻留在该目录中的#innodb_redo目录中。有两种类型的重做日志文件，普通和备用。普通的重做日志文件是那些正在使用的。备用重做日志文件是那些等待使用的文件。InnoDB尝试总共维护32个重做日志文件，每个文件的大小等于1&#x2F;32 *innodb_redo_log_capacity;但是，在修改innodb_redo_log_capacity设置后，文件大小可能会在一段时间内有所不同。</p>
<p>每个普通重做日志文件都与特定的LSN值范围相关联;例如，以下查询显示上一示例中列出的活动重做日志文件的START_LSN和END_LSN值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT FILE_NAME, START_LSN, END_LSN FROM performance_schema.innodb_redo_log_files;</span><br><span class="line">+----------------------------+--------------+--------------+</span><br><span class="line">| FILE_NAME                  | START_LSN    | END_LSN      |</span><br><span class="line">+----------------------------+--------------+--------------+</span><br><span class="line">| ./#innodb_redo/#ib_redo582 | 117654982144 | 117658256896 |</span><br><span class="line">| ./#innodb_redo/#ib_redo583 | 117658256896 | 117661531648 |</span><br><span class="line">| ./#innodb_redo/#ib_redo584 | 117661531648 | 117664806400 |</span><br><span class="line">| ./#innodb_redo/#ib_redo585 | 117664806400 | 117668081152 |</span><br><span class="line">| ./#innodb_redo/#ib_redo586 | 117668081152 | 117671355904 |</span><br><span class="line">| ./#innodb_redo/#ib_redo587 | 117671355904 | 117674630656 |</span><br><span class="line">| ./#innodb_redo/#ib_redo588 | 117674630656 | 117677905408 |</span><br><span class="line">| ./#innodb_redo/#ib_redo589 | 117677905408 | 117681180160 |</span><br><span class="line">| ./#innodb_redo/#ib_redo590 | 117681180160 | 117684454912 |</span><br><span class="line">| ./#innodb_redo/#ib_redo591 | 117684454912 | 117687729664 |</span><br><span class="line">| ./#innodb_redo/#ib_redo592 | 117687729664 | 117691004416 |</span><br><span class="line">| ./#innodb_redo/#ib_redo593 | 117691004416 | 117694279168 |</span><br><span class="line">| ./#innodb_redo/#ib_redo594 | 117694279168 | 117697553920 |</span><br><span class="line">| ./#innodb_redo/#ib_redo595 | 117697553920 | 117700828672 |</span><br><span class="line">| ./#innodb_redo/#ib_redo596 | 117700828672 | 117704103424 |</span><br><span class="line">| ./#innodb_redo/#ib_redo597 | 117704103424 | 117707378176 |</span><br><span class="line">| ./#innodb_redo/#ib_redo598 | 117707378176 | 117710652928 |</span><br><span class="line">| ./#innodb_redo/#ib_redo599 | 117710652928 | 117713927680 |</span><br><span class="line">| ./#innodb_redo/#ib_redo600 | 117713927680 | 117717202432 |</span><br><span class="line">| ./#innodb_redo/#ib_redo601 | 117717202432 | 117720477184 |</span><br><span class="line">| ./#innodb_redo/#ib_redo602 | 117720477184 | 117723751936 |</span><br><span class="line">+----------------------------+--------------+--------------+</span><br></pre></td></tr></table></figure>

<p>当执行检查点时，InnoDB将检查点LSN存储在包含此LSN的文件的头中。在恢复过程中，将检查所有重做日志文件，并从最新的检查点LSN开始恢复。</p>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>撤消日志是与单个读写事务相关联的撤消日志记录的集合。撤消日志记录包含有关如何撤消事务对聚集索引记录的最新更改的信息。如果另一个事务需要查看作为一致性读取操作的一部分的原始数据，则从撤消日志记录中检索未修改的数据。撤消日志存在于撤消日志段中，撤消日志段包含在回滚段中。回滚段驻留在撤消表空间和全局临时表空间中。</p>
<p>驻留在全局临时表中的撤消日志用于修改用户定义的临时表中的数据的事务。这些撤消日志不会被重新记录，因为它们不是崩溃恢复所必需的。它们仅用于服务器运行时的回滚。这种类型的撤消日志通过避免重做日志记录I&#x2F;O来提高性能。</p>
<h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><p>InnoDB实现了标准的行级锁，其中有两种类型的锁，共享（S）锁和排他（X）锁。</p>
<ul>
<li>共享（S）锁允许持有锁的事务读取行。</li>
<li>排他（X）锁允许持有锁的事务更新或删除行。</li>
</ul>
<p>InnoDB支持多粒度锁，允许行锁和表锁共存。例如，一个语句，如可扩展表… WRITE在指定的表上使用排他锁（X锁）。为了实现多粒度级别的锁定，InnoDB使用了意图锁。意图锁是表级锁，它指示事务稍后需要对表中的行使用哪种类型的锁（共享锁或排他锁）。有两种类型的意图锁</p>
<ul>
<li>意向共享锁（IS）表示事务打算在表中的各个行上设置共享锁。</li>
<li>意向排他锁（IX）表示事务打算在表中的各个行上设置排他锁。</li>
</ul>
<p>例如，SELECT … FOR SHARE设置IS锁，SELECT. FOR UPDATE设置一个IX锁。</p>
<p>意图锁定协议如下</p>
<ul>
<li>在事务可以获取表中某行的共享锁之前，它必须首先获取表中的IS锁或更强锁。</li>
<li>在事务可以获取表中某行的排他锁之前，它必须首先获取表上的IX锁。</li>
</ul>
<p>表级锁类型兼容性总结在下面的矩阵中。</p>
<p>图片</p>
<p>如果请求事务与现有锁兼容，则将锁授予该事务，但如果与现有锁冲突，则不授予该事务。事务等待，直到冲突的现有锁被释放。如果锁请求与现有锁冲突，并且由于会导致死锁而无法授予，则会发生错误。</p>
<p>记录锁是索引记录上的锁。例如， SELECT c1 FROM t WHERE c1 &#x3D; 10 FOR UPDATE; 阻止任何其他事务插入、更新或删除t.c1值为10的行。</p>
<p>记录锁始终锁定索引记录，即使定义的表没有索引。对于这种情况，InnoDB会创建一个隐藏的聚集索引并使用该索引进行记录锁定。</p>
<p>记录锁的事务数据在 SHOW ENGINE INNODB STATUS 和InnoDB监视器输出中类似于以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t`</span><br><span class="line">trx id 10078 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000000274f; asc     &#x27;O;;</span><br><span class="line"> 2: len 7; hex b60000019d0110; asc        ;;</span><br></pre></td></tr></table></figure>

<p>间隙锁是对索引记录之间的间隙的锁，或者对第一个索引记录之前或最后一个索引记录之后的差距的锁。例如， SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE; 阻止其他事务将值15插入列t.c1中，无论该列中是否已经有任何这样的值，因为范围中所有现有值之间的间隙被锁定。</p>
<p>间隙可能跨越单个索引值、多个索引值甚至是空的。</p>
<p>间隙锁是性能和并发性之间权衡的一部分，在某些事务隔离级别中使用，而在其他级别中则不使用。</p>
<p>对于使用唯一索引搜索唯一行来锁定行的语句，不需要间隔锁定。(This不包括搜索条件仅包括多列唯一索引的某些列的情况;在这种情况下，确实会发生间隙锁定。)例如，如果id列具有唯一索引，则以下语句仅对id值为100的行使用索引记录锁，并且其他会话是否在前面的间隙中插入行无关紧要：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM child WHERE id = 100;</span><br></pre></td></tr></table></figure>

<p>如果id没有索引或者有一个非唯一的索引，语句会锁定前面的间隙。</p>
<p>这里还值得注意的是，不同的事务可以在间隙上持有冲突的锁。例如，事务A可以在间隙上持有共享间隙锁（间隙S锁），而事务B在同一间隙上持有排他间隙锁（间隙X锁）。允许间隙锁冲突的原因是，如果从索引中清除记录，则必须合并不同事务在该记录上持有的差距锁。</p>
<p>InnoDB中的间隙锁是“纯粹禁止性的“，这意味着它们的唯一目的是防止其他事务插入到差距中。间隙锁可以共存。一个事务获取的间隙锁不会阻止另一个事务获取同一间隙上的间隙锁。共享间隙锁和独占间隙锁之间没有区别。它们彼此之间并不冲突，它们的功能是相同的。</p>
<p>Next-Key Locks 是索引记录上的记录锁和索引记录之前的差距上的差距锁的组合。</p>
<p>InnoDB执行行级锁定的方式是，当它搜索或扫描表索引时，它会在遇到的索引记录上设置共享或排他锁。因此，行级锁实际上是索引记录锁。索引记录上的下一个键锁也会影响该索引记录之前的“间隙“。也就是说，下一个键锁是索引记录锁加上索引记录之前的差距上的间隙锁。如果一个会话对索引中的记录R具有共享锁或排他锁，则另一个会话不能在索引顺序中紧接在R之前的差距中插入新的索引记录。</p>
<p>假设索引包含值10、11、13和20。此索引可能的下一个键锁涵盖以下区间，其中圆括号表示排除区间端点，方括号表示包含端点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure>

<p>默认情况下，InnoDB在REPEATABLE READ事务隔离级别下运行。在这种情况下，InnoDB使用下一个键锁进行搜索和索引扫描，这可以防止幻读</p>
<p>插入意图锁是一种在行插入之前由INSERT操作设置的间隙锁。该锁以这样一种方式发出插入意图的信号，即如果插入到同一索引间隙中的多个事务不在差距内的相同位置处插入，则它们不需要等待彼此。假设有值为4和7的索引记录。分别尝试插入值5和6的单独事务，每个事务在获得插入行的排他锁之前，用插入意图锁锁定4和7之间的差距，但不阻止彼此，因为行不冲突。</p>
<p>锁定读取、UPDATE或UPDATE通常在SQL语句处理过程中扫描的每个索引记录上设置记录锁。语句中是否有排除该行的WHERE条件并不重要。InnoDB不记得确切的WHERE条件，只知道扫描了哪些索引范围。这些锁通常是下一个键锁，它也会阻止插入记录之前的“间隙”。但是，可以显式禁用间隙锁定，这将导致不使用下一个键锁定。</p>
<p>如果在搜索中使用了二级索引，并且要设置的索引记录锁是独占的，InnoDB也会检索相应的聚集索引记录并对其设置锁。</p>
<p>如果你没有适合你的语句的索引，MySQL必须扫描整个表来处理语句，那么表的每一行都会被锁定，这反过来会阻止其他用户对表的所有插入。创建良好的索引非常重要，这样查询就不会扫描不必要的行。</p>
<p>SELECT … FROM是一致读取，即阅读数据库的快照，并且不设置锁，除非事务隔离级别设置为SERIALIZABLE。对于SERIALIZABLE级别，搜索在它遇到的索引记录上设置共享的下一个键锁。但是，对于使用唯一索引搜索唯一行来锁定行的语句，只需要索引记录锁。</p>
<p>使用唯一索引的 SELECT … FOR UPDATE 和 SELECT … FOR SHARE 语句为扫描的行获取锁，并为不符合结果集中包含条件的行释放锁（例如，如果它们不满足WHERE子句中给定的条件）。但是，在某些情况下，行可能不会立即解锁，因为结果行与其原始源之间的关系在查询执行期间丢失。例如，在UNION中，表中扫描（和锁定）的行可能会插入到临时表中，然后再评估它们是否符合结果集。在这种情况下，临时表中的行与原始表中的行之间的关系将丢失，并且后面的行直到查询执行结束才被解锁。</p>
<p>对于锁定读取（SELECTwithFOR UPDATE或FOR SHARE）、UPDATE和UPDATE语句，所采用的锁取决于语句使用的是具有唯一搜索条件的唯一索引还是具有范围类型搜索条件的唯一索引。</p>
<ul>
<li>对于具有唯一搜索条件的唯一索引，InnoDB只锁定找到的索引记录，而不锁定它之前的差距。</li>
<li>对于其他搜索条件以及非唯一索引，InnoDB会锁定扫描的索引范围，使用间隙锁或下一个键锁来阻止其他会话插入该范围覆盖的间隙。</li>
</ul>
<p>对于搜索遇到的索引记录， SELECT … FOR UPDATE 阻止其他会话执行 SELECT … FOR SHARE 或在某些事务隔离级别中进行阅读。一致性读取将忽略在读取视图中存在的记录上设置的任何锁。</p>
<p>UPDATE … WHERE … 在搜索遇到的每个记录上设置独占的下一个键锁。但是，对于使用唯一索引搜索唯一行来锁定行的语句，只需要索引记录锁。</p>
<p>DELETE FROM … WHERE … 在搜索遇到的每个记录上设置独占的下一个键锁。但是，对于使用唯一索引搜索唯一行来锁定行的语句，只需要索引记录锁。</p>
<p>INSERT 在插入的行上设置独占锁。此锁是索引记录锁，而不是下一个键锁（即没有间隙锁），并且不会阻止其他会话插入到插入行之前的差距中。</p>
<p>在插入行之前，设置一种称为插入意图间隙锁定的间隙锁定。该锁以这样一种方式发出插入意图的信号，即如果插入到同一索引间隙中的多个事务不在差距内的相同位置处插入，则它们不需要等待彼此。假设有值为4和7的索引记录。尝试插入值5和6的单独事务在获得插入行的排他锁之前，每个事务都使用插入意图锁锁定4和7之间的差距，但不会相互阻塞，因为行不冲突。</p>
<p>INSERT INTO T SELECT … FROM S WHERE … 在插入到T中的每一行上设置排他索引记录锁（没有间隙锁）。如果事务隔离级别为READ COMMITTED，InnoDB将在S上执行一致性读取（无锁）。否则，InnoDB会对来自S的行设置共享的下一个键锁。InnoDB必须在后一种情况下设置锁：在使用基于语句的二进制日志进行前滚恢复期间，每个SQL语句都必须以与最初完全相同的方式执行。</p>
<p>当启用死锁检测时（默认值），InnoDB会自动检测事务死锁并回滚一个或多个事务以打破死锁。InnoDB尝试选择小事务进行回滚，其中事务的大小由插入、更新或删除的行数决定。</p>
<p>死锁是事务数据库中的一个典型问题，但它们并不危险，除非它们非常频繁，以至于您根本无法运行某些事务。通常，您必须编写应用程序，以便它们始终准备好在事务由于死锁而回滚时重新发出事务。</p>
<p>InnoDB使用自动行级锁定。即使在只插入或删除单行的事务中，也可能出现死锁。这是因为这些操作并不是真正的“原子“操作;它们会自动对插入或删除的行的（可能是多个）索引记录设置锁。</p>
<p>您可以使用以下技术来科普死锁并降低其发生的可能性：</p>
<ul>
<li>在任何时候，都可以发出 SHOW ENGINE INNODB STATUS 来确定最近一次死锁的原因。这可以帮助您调优应用程序以避免死锁。</li>
<li>如果频繁的死锁警告引起了关注，请通过启用innodb_print_all_deadlocks变量来收集更广泛的调试信息。关于每个死锁的信息，而不仅仅是最新的一个，都记录在MySQL错误日志中。完成调试后禁用此选项。</li>
<li>如果事务由于死锁而失败，请始终准备重新发出事务。死锁并不危险。再试一次</li>
<li>保持事务规模小、持续时间短，以减少冲突。</li>
<li>在进行一组相关更改后立即提交事务，以减少冲突。特别是，不要让一个交互式的mysql会话长时间打开一个未提交的事务。</li>
<li>如果您使用锁定读取（ SELECT … FOR UPDATE 或 SELECT … FOR SHARE ），请尝试使用较低的隔离级别，例如READ COMMITTED。</li>
<li>当修改一个事务中的多个表或同一表中的不同行集时，每次都要以一致的顺序执行这些操作。这样，事务就形成了定义良好的队列，不会死锁。例如，将数据库操作组织到应用程序中的函数中，或调用存储的例程，而不是在不同的地方编写多个类似的UPDATE、UPDATE和UPDATE语句序列。</li>
<li>向表中添加精心选择的索引，这样查询扫描的索引记录和设置的锁就更少。使用EXPLAIN SELECT来确定MySQL服务器认为哪些索引最适合您的查询。</li>
<li>使用较少的锁定。如果您可以允许SELECT从旧快照中返回数据，请不要向其添加FOR UPDATE或FOR SHARE子句。在这里使用READ COMMITTED隔离级别是很好的，因为同一事务中的每个一致性读取都从自己的新快照中读取。</li>
<li>如果没有其他帮助，请使用表级锁序列化事务。在事务表（如InnoDB表）中使用UNESTABLES的正确方法是，开始事务时使用 SET autocommit &#x3D; 0 （不是START TRANSACTION），后跟UNESTABLES，并且在显式提交事务之前不要调用UNESTABLES。</li>
</ul>
<p>InnoDB使用竞争感知事务调度（CATS）算法来优先处理等待锁的事务。当多个事务等待同一对象上的锁时，CATS算法确定哪个事务首先接收锁。</p>
<p>CATS算法通过分配调度权重来对等待的事务进行优先级排序，调度权重是根据事务阻塞的事务数量计算的。例如，如果两个事务正在等待同一对象上的锁，则阻塞事务最多的事务将被分配更大的调度权重。如果权重相等，则将优先级给予等待时间最长的事务。</p>
<h3 id="InnoDB压缩表"><a href="#InnoDB压缩表" class="headerlink" title="InnoDB压缩表"></a>InnoDB压缩表</h3><p>由于处理器和高速缓存存储器的速度比磁盘存储设备提高得更快，因此许多工作负载都是磁盘绑定的。数据压缩可以减小数据库大小、减少I&#x2F;O并提高吞吐量，但代价是增加CPU利用率。对于具有足够RAM以将频繁使用的数据保留在内存中的系统上的读取密集型应用程序来说，压缩尤其有价值。</p>
<p>使用ROW_FORMAT&#x3D;COMPRESSED创建的InnoDB表可以在磁盘上使用比配置的innodb_page_size值更小的页面大小。较小的页面需要较少的I&#x2F;O来读取和写入磁盘，这对于SSD设备尤其有价值。</p>
<p>压缩页大小通过CREATE TABLE或ALTER TABLEKEY_BLOCK_SIZE参数指定。不同的页大小要求将表放在每个表一个文件的目录中或一般目录中，而不是放在系统目录中，因为系统目录不能存储压缩表。</p>
<p>无论KEY_BLOCK_SIZE值如何，压缩级别都相同。当您为KEY_BLOCK_SIZE指定较小的值时，您将获得越来越小的页面带来的I&#x2F;O好处。但是，如果指定的值太小，则当数据值无法压缩到足以容纳每页中的多行时，重新组织页会产生额外的开销。根据表中每个索引的键列长度，表的KEY_BLOCK_SIZE大小有一个硬性限制。如果指定的值太小，则CREATE TABLE或ALTER TABLE语句将失败。</p>
<p>在缓冲池中，压缩数据保存在小页面中，页面大小基于KEY_BLOCK_SIZE值。为了提取或更新列值，MySQL还在缓冲池中使用未压缩的数据创建未压缩的页面。在缓冲池中，对未压缩页的任何更新也会重新写回等效的压缩页。您可能需要调整缓冲池的大小，以容纳压缩页和未压缩页的额外数据，尽管未压缩页在需要空间时会从缓冲池中清除，然后在下次访问时再次解压缩。</p>
<p>配置innodb_file_per_table选项后，在CREATE TABLE或ALTER TABLE语句中指定ROW_FORMAT&#x3D;COMPRESSED子句或KEY_BLOCK_SIZE子句，或同时指定这两个子句，以在每个表一个文件的格式中创建压缩表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL innodb_file_per_table=1;</span><br><span class="line">CREATE TABLE t1</span><br><span class="line"> (c1 INT PRIMARY KEY)</span><br><span class="line"> ROW_FORMAT=COMPRESSED</span><br><span class="line"> KEY_BLOCK_SIZE=8;</span><br></pre></td></tr></table></figure>

<p>要确定KEY_BLOCK_SIZE的最佳值，通常需要为此子句创建具有不同值的同一表的多个副本，然后测量生成的.ibd文件的大小，并查看每个副本在实际工作负载下的性能。对于一般的表空间，请记住，删除表不会减小一般的.ibd文件的大小，也不会将磁盘空间返回给操作系统。</p>
<h3 id="innoDB恢复"><a href="#innoDB恢复" class="headerlink" title="innoDB恢复"></a>innoDB恢复</h3><p>InnoDB崩溃恢复包括几个步骤：</p>
<ul>
<li>redo log: 重做日志应用程序在初始化期间执行，然后接受任何连接。如果在关机或崩溃时，所有更改都从缓冲池刷新到表空间（ibdata<em>和</em>.ibd文件），则重做日志应用程序将被跳过。InnoDB还跳过重做日志应用程序，如果重做日志文件在启动时丢失。<ul>
<li>当前最大自动递增计数器值在每次值更改时写入重做日志，这使其具有崩溃安全性。在恢复过程中，InnoDB扫描重做日志以收集计数器值更改，并将更改应用于内存中的表对象。</li>
<li>当遇到索引树损坏时，InnoDB将损坏标志写入重做日志，这使得损坏标志崩溃安全。InnoDB还将内存中的损坏标志数据写入每个检查点上的引擎专用系统表。在恢复过程中，InnoDB从两个位置读取损坏标志，并在将内存中的表和索引对象标记为损坏之前合并结果。</li>
<li>不建议通过删除重做日志来加快恢复速度，即使可以接受某些数据丢失。只有在干净关机后才应该考虑删除重做日志，并将innodb_fast_shutdown设置为0或1。</li>
</ul>
</li>
<li>roll back: 未完成事务的回滚,不完整事务是在意外退出或快速关闭时处于活动状态的任何事务。根据服务器负载的不同，回滚未完成事务所需的时间可能是事务中断前活动时间的三倍或四倍。不能取消正在回滚的事务。在极端情况下，当回滚事务预计需要非常长的时间时，使用3或更大的innodb_force_recovery设置启动InnoDB可能会更快。</li>
<li>change buffer: 当索引页被读取到缓冲池时，将更改缓冲区（系统缓存的一部分）中的更改应用于辅助索引的叶页。</li>
<li>purge: 删除对活动事务不再可见的已标记为删除的记录。</li>
</ul>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>基于语句复制的优点：</p>
<ul>
<li>写入日志文件的数据更少。当更新或删除影响许多行时，这会导致日志文件所需的存储空间大大减少。这也意味着可以更快地完成从备份获取和恢复。</li>
<li>日志文件包含进行任何更改的所有语句，因此可用于审核数据库。</li>
</ul>
<p>缺点</p>
<ul>
<li>并非所有修改数据的语句（如UPDATE、UPDATE和REPLACE语句）都可以使用基于语句的复制进行复制。使用基于语句的复制时，任何不确定性行为都很难复制。</li>
<li>insert … select 和基于行的复制相比，SELECT需要更多的行级锁。</li>
<li>与基于行的复制相比，需要表扫描的UPDATE语句（因为在WHERE子句中没有使用索引）必须锁定更多的行。</li>
<li>对于InnoDB：一个使用了AUTO_INCREMENT的INCREMENT语句会阻塞其他不冲突的INCREMENT语句。</li>
<li>对于复杂语句，在更新或插入行之前，必须在副本上计算和执行该语句。对于基于行的复制，副本只需修改受影响的行，而不必执行完整的语句。</li>
<li>如果在对副本进行评估时出现错误，特别是在执行复杂语句时，基于语句的复制可能会随着时间的推移慢慢增加受影响行的误差幅度。</li>
<li>必须在副本上应用确定性函数。</li>
<li>源和副本上的表定义必须（几乎）相同。</li>
</ul>
<p>基于行的复制的优点</p>
<ul>
<li>所有更改都可以复制。这是最安全的复制方式。</li>
<li>对于任何UPDATE、UPDATE或UPDATE语句，副本上所需的行锁较少。</li>
</ul>
<p>缺点</p>
<ul>
<li>要复制DML语句（如UPDATE或DELETE语句），基于语句的复制只将语句写入二进制日志。相比之下，基于行的复制将每个更改的行写入二进制日志。如果语句更改了许多行，则基于行的复制可能会向二进制日志写入更多的数据;即使对于回滚的语句也是如此。这也意味着制作和恢复备份可能需要更多的时间。此外，二进制日志被锁定较长时间以写入数据，这可能会导致并发问题。使用binlog_row_image&#x3D;minimal可以大大减少这个缺点。</li>
<li>与基于语句的复制相比，使用基于行的复制复制生成大BLOB值的确定性NULL函数所需的时间更长。这是因为记录的是BLOB列值，而不是生成数据的语句。</li>
<li>您无法在副本上看到从源接收并执行了哪些语句。但是，您可以使用带有选项–base64-output&#x3D;DECODE-ROWS和–verbose的mysqlbinlog查看更改了哪些数据。</li>
<li>对于使用MyISAM存储引擎的表，将SQL语句作为基于行的事件应用于二进制日志时，其副本上需要比将其作为语句应用时更强的锁。这意味着在使用基于行的复制时，不支持MyISAM表上的并发插入。</li>
</ul>
<p>MySQL使用基于语句的日志记录（SBL），基于行的日志记录（RBL）或混合格式的日志记录。使用的二进制日志类型影响日志记录的大小和效率。因此，基于行的复制（RBR）或基于语句的复制（SBR）之间的选择取决于您的应用程序和环境。</p>
<p>使用基于行的格式或混合格式时，不复制临时表，因为没有必要。此外，由于临时表只能从创建它们的线程读取，因此即使使用基于语句的格式，复制它们也很少有好处。当使用binlog_format&#x3D;ROW时，只要受语句影响的任何非事务性表都是临时表，就允许涉及临时表的非事务性DML语句。</p>
<p>当许多行受到影响时，更改集被拆分为多个事件;当语句提交时，所有这些事件都被写入二进制日志。在副本上执行时，对所有涉及的表都采用表锁，然后以批处理模式应用行。这可能有效，也可能无效，具体取决于用于复制表副本的引擎。</p>
<p>RBL将每一行的更改写入二进制日志，因此其大小可以快速增加。这会显著增加在复制副本上进行与源上的更改相匹配的更改所需的时间。你应该意识到这种延迟在你的应用程序的可能性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/ArrayList%E5%92%8CLinkedList%E8%A7%A3%E6%9E%90.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/ArrayList%E5%92%8CLinkedList%E8%A7%A3%E6%9E%90.html" class="post-title-link" itemprop="url">ArrayList和LinkedList解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-15 10:12:47" itemprop="dateCreated datePublished" datetime="2024-04-15T10:12:47+08:00">2024-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-17 10:21:34" itemprop="dateModified" datetime="2025-02-17T10:21:34+08:00">2025-02-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
            <span id="/ArrayList%E5%92%8CLinkedList%E8%A7%A3%E6%9E%90.html" class="post-meta-item leancloud_visitors" data-flag-title="ArrayList和LinkedList解析" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/ArrayList%E5%92%8CLinkedList%E8%A7%A3%E6%9E%90.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/ArrayList%E5%92%8CLinkedList%E8%A7%A3%E6%9E%90.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="数组数据结构"><a href="#数组数据结构" class="headerlink" title="数组数据结构"></a>数组数据结构</h2><h3 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h3><p>接口就是Interface，也可以是ADT(Abstract Data Tructure), 当定义一个接口的时候，实际上是一种规范，一种约束。</p>
<p>接口定义了一些方法，也就是支持哪些操作。</p>
<p>这里拿Java的List接口举个例子。</p>
<p>List<E></p>
<ul>
<li>add(E element): 表示List接口支持add操作，将一个元素添加到list中，至于如何实现，不重要。</li>
<li>remove(E element): 表示List接口支持remove操作，将一个元素从list中移除，至于如何实现，不重要。</li>
<li>size(): 表示List接口支持size操作，返回list中有多少个元素，如何实现，不重要。</li>
</ul>
<p>接口还可以想象成提出了一些问题，比如说，我现在有List这个接口，我提出了三个问题。</p>
<ul>
<li>我要将一个元素添加到list中，如何实现？</li>
<li>我要将一个元素从list中移除，如何实现?</li>
<li>我要计算list中元素的数量，如何实现？</li>
</ul>
<h3 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h3><p>那么什么是数据结构呢？就是一种接口的具体实现方案。</p>
<p>它是数据实际的表示形式。它有一些方法，或者说使用一些算法，来实现上面接口提出的操作。</p>
<p>同样可以理解为对于上面提出的三个问题的解答。</p>
<p>以Java中ArrayList和LinkedList来举例。</p>
<p>ArrayList: 使用数组实现了List接口</p>
<ul>
<li>add(E element): 表示ArrayList这种数据结构，实现了List接口，支持add操作，使用了适合ArrayList这种数据结构的算法来实现add，解决了上面的第一个问题。</li>
<li>remove(E element): 表示ArrayList这种数据结构，实现了List接口，支持remove操作，使用了适合ArrayList这种数据结构的算法来实现remove，解决了上面的第二个问题。</li>
<li>len(): 表示ArrayList这种数据结构，实现了List接口，支持len操作，使用了适合ArrayList这种数据结构的算法来实现len，解决了上面的第三个问题。</li>
</ul>
<p>LinkedList：使用链表实现了List接口</p>
<ul>
<li>add(E element): 表示LinkedList这种数据结构，实现了List接口，支持add操作，使用了适合LinkedList这种数据结构的算法来实现add，解决了上面的第一个问题。</li>
<li>remove(E element): 表示LinkedList这种数据结构，实现了List接口，支持remove操作，使用了适合LinkedList这种数据结构的算法来实现remove，解决了上面的第二个问题。</li>
<li>len(): 表示LinkedList这种数据结构，实现了List接口，支持len操作，使用了适合LinkedList这种数据结构的算法来实现len，解决了上面的第三个问题。</li>
</ul>
<h2 id="静态数组实现"><a href="#静态数组实现" class="headerlink" title="静态数组实现"></a>静态数组实现</h2><p>静态数组可以实现List的功能吗？当然可以了。那么我们看一下静态数组的实现，有哪些好处和坏处。</p>
<p>我们现在定义一个接口，List，下面是接口支持的操作。</p>
<ul>
<li>build(x): 新建一个List。</li>
<li>len(): 返回数量</li>
<li>get_at(i): 获取i下标的元素</li>
<li>set_at(i, x): 设置i下标的元素为x</li>
<li>insert_at(i, x): 插入某一个位置</li>
<li>delete_at(i): 删除某一个位置的元素</li>
<li>insert_first(x): 将一个元素插入到第一个位置</li>
<li>insert_last(x)：将一个元素插入到最后一个位置</li>
<li>delete_fist()：删除第一个位置的元素</li>
<li>delete_last()：删除最后一个位置的元素</li>
</ul>
<p>通过静态数组来实现这个接口，也就是数组长度一旦确定就不可以改变了。</p>
<p>先看build，可以通过for去构建一个静态数组。其时间复杂度为O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(x)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">Int</span>[x.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; x.length; i++) &#123;</span><br><span class="line">        array[i] = x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录静态数组的长度</span></span><br><span class="line">    len = array.lenght;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为上面在构建的时候已经记录了长度，因此，可以直接返回。len的时间复杂度就是O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">len</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于数组来说，我们知道它是内存中一段连续的空间，因此这个时候，我们的内存里面是这样的。假设x里面是1,2,3,4,5,6</p>
<p><img src="https://thepatterraining.github.io/images/DataStructure/list1.png" alt="list1.png"></p>
<p>我们还知道一个int等于32位，4个字节，因此，假设元素1的地址是0，那么其余的地址如下图所示。</p>
<p><img src="https://thepatterraining.github.io/images/DataStructure/list2.png" alt="list1.png"></p>
<p>因此，<code>get_at(i)</code>这个操作的时间复杂度同样是O(1)，因为可以直接计算出对应位置的地址，计算公式如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第i个元素的地址 = 首地址 + （4 * i）</span><br><span class="line">i = 0的地址 = 0 + 0 = 0</span><br><span class="line">i = 1的地址 = 0 + 4 = 4</span><br></pre></td></tr></table></figure>

<p>伪代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get_at</span><span class="params">(i)</span> &#123;</span><br><span class="line">    <span class="comment">// 因为java语言会自动计算i这个下标对应的地址</span></span><br><span class="line">    <span class="keyword">return</span> array[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>set_at(i,x)</code>这个操作来说，同样的O(1)复杂度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set_at</span><span class="params">(i,x)</span> &#123;</span><br><span class="line">    array[i] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的操作都很快，但是如果我们想插入或者删除一个元素，对于<code>静态数组</code>这个数据结构来说，就很慢了。因为要移动元素。我们看一下操作<code>delete_at(i)</code>的执行过程。</p>
<p>假设delete_at(0)：表示删除第0个元素，也就是首个元素。</p>
<p>第一步，删除，我们可以看到地址0指向的首个元素的内容变成<code>null</code>了</p>
<p><img src="https://thepatterraining.github.io/images/DataStructure/list3.png" alt="list1.png"></p>
<p>第二步，移动后面的元素到前面的位置。</p>
<p><img src="https://thepatterraining.github.io/images/DataStructure/list4.png" alt="list1.png"></p>
<p>删除完成，这个时候肯定有人问了，不对啊，你这最后两个元素一样啊，是的，不用管它。</p>
<p>因为我们的len减少了，而获取的时候需要判断大小，如果获取的下标长度超过len了，应该返回空或错误。这个在上面的伪代码里面省略了。</p>
<blockquote>
<p>完整的代码做为课后作业，希望大家可以自己完成，只有自己实践了，知识才是自己的，你光看我写的内容，过一会就忘了，如果你觉得实现有困难，那么我的内容可以帮助你解决困难，帮助你自己实现它。</p>
</blockquote>
<p>伪代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete_at</span><span class="params">(i)</span> &#123;</span><br><span class="line">    <span class="comment">//第一步 删除 这一步其实可以省略，这里是希望大家明白原理</span></span><br><span class="line">    array[i] = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//第二步，移动后面的元素过来</span></span><br><span class="line">    <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">        array[j - <span class="number">1</span>] = array[j];</span><br><span class="line">    &#125;</span><br><span class="line">    len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>insert_at(i,x)</code>操作来说，和上面的原理几乎一样，分为两个步骤。</p>
<p>第一步，将i元素及后面的元素往后移动一步，把i这个位置腾出来。我们拿<code>insert(0,1)</code>来举例。</p>
<p>可以看到几乎是上方delete操作的一个逆序过程。</p>
<p><img src="https://thepatterraining.github.io/images/DataStructure/list5.png" alt="list1.png"></p>
<p>现在可以看到0的位置已经空出来了，虽然里面还有一个2，但是我们可以覆盖它。</p>
<p>第二步，将1插入0的位置。</p>
<p><img src="https://thepatterraining.github.io/images/DataStructure/list6.png" alt="list6.png"></p>
<p>如此，就完成了整个insert操作。伪代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert_at</span><span class="params">(i,x)</span> &#123;</span><br><span class="line">    <span class="comment">// 第一步 移动元素 注意从后往前移动</span></span><br><span class="line">    <span class="keyword">for</span> (j = len - <span class="number">1</span>; j &gt;= i; j--) &#123;</span><br><span class="line">        array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二步 插入</span></span><br><span class="line">    array[i] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细心的你，一定发现了上面的代码缺少边界检查，这些都留给你的具体实现了，都是比较简单的东西。</p>
<p>那么，对于<code>delete_at(i)</code>和<code>insert_at(i,x)</code>来说，我们的时间复杂度相当于O(n).</p>
<p>而剩下的<code>delete_first()</code>和<code>delete_last()</code>，以及<code>insert_first(x)</code>和<code>insert_last(x)</code>都是上方的一个真子集，所以时间复杂度同样是O(n)。就不再重复演示了。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>Build</th>
<th>Len</th>
<th>Get_at、Set_at</th>
<th>delete_at、insert_at</th>
<th>delete_last、insert_last</th>
<th>delete_first、insert_first</th>
</tr>
</thead>
<tbody><tr>
<td>静态数组的复杂度</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h2 id="链表的实现"><a href="#链表的实现" class="headerlink" title="链表的实现"></a>链表的实现</h2><p>除了直接用一个<code>Array</code>去实现以外，还可以用<code>链表</code>这个数据结构去实现List接口。也就是Java中的<code>LinkedList</code>实现。</p>
<p>我们首先看一下链表是如何实现build的。可以通过for去构建一个链表。其时间复杂度为O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(x)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(x[x.length - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(x[i]);</span><br><span class="line">        current.next = node;</span><br><span class="line">        node = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录链表的长度</span></span><br><span class="line">    len = x.lenght;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为上面在构建的时候已经记录了长度，因此，可以直接返回。len的时间复杂度就是O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">len</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下链表这个数据结构的逻辑形式，如下图所示。一个一个指针把数据连接起来</p>
<ul>
<li>优点：不用连续的空间，长度不固定</li>
<li>缺点：查询慢</li>
</ul>
<p>val代表具体的内容，Next代表下一个节点的指针，内容是下一个节点的地址。最后一个节点的Next指针是null。<br><img src="https://thepatterraining.github.io/images/DataStructure/list7.png" alt="list7.png"></p>
<p>而在实际内存中的表现形式则是下图所示。这里是连续的，仅仅是巧合，也可能是不连续的。在这里我们忽略class头的占用，this指针的占用空间，val占据空间是4个字节，next做为指针是64位，占用8个字节。<br><img src="https://thepatterraining.github.io/images/DataStructure/list8.png" alt="list7.png"></p>
<p>由于链表的地址不连续，所以没办法通过首地址直接计算出每个元素的地址，而需要通过<code>next</code>属性来获取下一个元素的地址。</p>
<p>整个<code>get_at(i)</code>的获取步骤如下</p>
<ol>
<li>获取首个元素的地址</li>
<li>获取该元素的next属性</li>
<li>重复第2步，直到重复了i次</li>
<li>返回该元素内容</li>
</ol>
<p>整个步骤如图所示。假设是<code>get_at(2)</code>，代表获取第三个元素。也就是3这个内容。因为是从0开始。</p>
<p><img src="https://thepatterraining.github.io/images/DataStructure/list9.png" alt="list7.png"></p>
<p>伪代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get_at</span><span class="params">(i)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="literal">null</span> &amp;&amp; i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，因为每次都要从头找，所以时间复杂度是O(n)</p>
<p>再看一下<code>set_at(i, x)</code>。也基本上是同样的步骤，找到这个元素，然后更新它的val属性内容。步骤图和上面是一样的。所以时间复杂度同样是O(n)。直接看一下伪代码吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set_at</span><span class="params">(i, x)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="literal">null</span> &amp;&amp; i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到几乎是一样的。</p>
<p>再来看一下<code>insert_at(i, x)</code>和<code>delete_at(i)</code>。首先看一下<code>delete_at(i)</code>。</p>
<p>比如<code>delete_at(2)</code> 分为两步，第一步查询，和上面的步骤是一样的。</p>
<p><img src="https://thepatterraining.github.io/images/DataStructure/list9.png" alt="list7.png"></p>
<p>第二步是删除。删除分为2步</p>
<ol>
<li>将上一个指针的next指向第i+1个元素。可以看到图里更新成36了</li>
<li>将第i个元素的next指针更新成null</li>
</ol>
<p><img src="https://thepatterraining.github.io/images/DataStructure/list10.png" alt="list7.png"></p>
<p>整个伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete_at</span><span class="params">(i)</span> &#123;</span><br><span class="line">    <span class="comment">// 第一步 找到i-1的元素</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="literal">null</span> &amp;&amp; i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二步删除</span></span><br><span class="line">    <span class="comment">// 2.1 将i-1个元素的next指向i+1</span></span><br><span class="line">    inode = node.next;</span><br><span class="line">    node.next = node.next.next;</span><br><span class="line">    <span class="comment">// 2.2 将第i个元素的next指针更新成null</span></span><br><span class="line">    inode.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家在想一想，如果是<code>delete(x)</code>的话，该如何实现呢？</p>
<blockquote>
<p>提示：仅仅修改获取元素即可，修改成x &#x3D;&#x3D; node.val，就是找到了。可以使用双向链表实现。</p>
</blockquote>
<p>再看一下<code>insert_at(i,x)</code>的执行步骤，分为两步。</p>
<p>第一步是查询，和上面也是一样的。</p>
<p><img src="https://thepatterraining.github.io/images/DataStructure/list9.png" alt="list7.png"></p>
<p>第二步是插入，插入分为两步</p>
<ol>
<li>修改插入节点的next指向当前i节点的next</li>
<li>修改当前i-1节点的next指向插入节点</li>
</ol>
<p>我们以<code>insert_at(2,3)</code>为例。首先找到i&#x3D;0，再找到i&#x3D;1的位置就是要插入的位置，因为要插入的位置是2，所以我们要把i&#x3D;1的元素的next指向插入的节点。所以找到i&#x3D;1的元素就可以停止了。</p>
<p><img src="https://thepatterraining.github.io/images/DataStructure/list11.png" alt="list7.png"></p>
<p>整个伪代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert_at</span><span class="params">(i,x)</span> &#123;</span><br><span class="line">    <span class="comment">// 第一步 找到i-1的元素</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="literal">null</span> &amp;&amp; i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二步插入</span></span><br><span class="line">    <span class="comment">// 2.1 修改插入节点的next指向当前i节点的next</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">insertNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(x);</span><br><span class="line">    insertNode.next = node.next;</span><br><span class="line">    <span class="comment">// 2.2 修改当前i-1节点的next指向插入节点</span></span><br><span class="line">    node.next = insertNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述两个操作对于<code>链表</code>数据结构来说，实现的时间复杂度都是O(n)。</p>
<p>但是链表相对于静态数组来说，其优势再于剩下的操作的实现。</p>
<p>比如<code>insert_first(x)</code>和<code>delete_first()</code>。对于这两个来说，不需要查找，因为删除的是第一个元素。所以省去了查找时间，插入和删除时间仅仅是O(1)。</p>
<p>看一下<code>insert_first(10)</code>。</p>
<ul>
<li>创建插入节点insertNode</li>
<li>修改插入节点的next指向当前head节点的next:insertNode.next &#x3D; head.next;</li>
<li>修改当前head节点的next指向插入节点</li>
</ul>
<p>从伪代码也能看出来，完全就是上面伪代码的第二步插入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert_first</span><span class="params">(x)</span> &#123;</span><br><span class="line">    <span class="comment">// 第二步插入</span></span><br><span class="line">    <span class="comment">// 2.1 修改插入节点的next指向当前i节点的next</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">insertNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(x);</span><br><span class="line">    insertNode.next = head.next;</span><br><span class="line">    <span class="comment">// 2.2 修改当前i-1节点的next指向插入节点</span></span><br><span class="line">    head.next = insertNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>delete_first()</code>来说，是一样的，就是第二步删除。这里是从0开始，head原来是指向元素0，删除元素0，就是指向元素1.</p>
<ol>
<li>将head指针的next指向第1个元素。</li>
<li>将第0个元素的next指针更新成null</li>
</ol>
<p>伪代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete_first</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 第二步删除</span></span><br><span class="line">    <span class="comment">// 2.1 将head指针的next指向第1个元素。</span></span><br><span class="line">    inode = head;</span><br><span class="line">    head = head.next;</span><br><span class="line">    <span class="comment">// 2.2 将第0个元素的next指针更新成null</span></span><br><span class="line">    inode.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们还记录了<code>tail</code>指针来指向链表的尾部，那么<code>delete_last()</code>和<code>insert_last(x)</code>也是O(1)复杂度。</p>
<p>如果没有的话，那么就是O(n)复杂度。这里不再赘述。</p>
<p>整个链表数据结构，也就是常说的<code>LinkedList</code>实现，复杂度表如下。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>Build</th>
<th>Len</th>
<th>Get_at、Set_at</th>
<th>delete_at、insert_at</th>
<th>delete_last、insert_last</th>
<th>delete_first、insert_first</th>
</tr>
</thead>
<tbody><tr>
<td>链表的复杂度</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h2 id="动态数组的实现"><a href="#动态数组的实现" class="headerlink" title="动态数组的实现"></a>动态数组的实现</h2><p>什么是动态数组呢？</p>
<ul>
<li>融合了上面两个的优点</li>
<li>既保证了查询的高效，也保证了插入和删除的高效。</li>
</ul>
<p>如何做到的呢？这也就是JAVA中<code>ArrayList</code>做到的事情。一起来看一下吧。</p>
<p>对于build和len，就不再重复了，可以直接参考静态数组的实现。</p>
<p>这里主要看一下其余的操作。</p>
<p>对于<code>get_at(i)</code>来说，由于使用的是数组，所以同样的O(1)复杂度，ArrayList数据结构也是一块连续的内存空间，可以通过公式直接计算出i元素的内存位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第i个元素的地址 = 首地址 + （4 * i）</span><br><span class="line">i = 0的地址 = 0 + 0 = 0</span><br><span class="line">i = 1的地址 = 0 + 4 = 4</span><br></pre></td></tr></table></figure>

<p>伪代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get_at</span><span class="params">(i)</span> &#123;</span><br><span class="line">    <span class="comment">// 因为java语言会自动计算i这个下标对应的地址</span></span><br><span class="line">    <span class="keyword">return</span> array[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>set_at(i,x)</code>这个操作来说，同样的O(1)复杂度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set_at</span><span class="params">(i,x)</span> &#123;</span><br><span class="line">    array[i] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点在接下来。敲黑板了！！！</p>
<p>对于<code>insert_last(x)</code>和<code>delete_at(i)</code>来说。我们看一下实现。</p>
<p>以<code>insert_last(1)</code>来说吧。由于是动态数组，是可以扩容的。假设当前内存是空.然后我们插入1.</p>
<p><img src="https://thepatterraining.github.io/images/DataStructure/list12.png" alt="list7.png"></p>
<p>在接下来我们要插入2.也就是<code>insert_last(2)</code>。但是这个数组没有空间了，我们需要扩容，比如我们扩容一倍，也就是申请两个内存，现在的内存首地址就不是1了，可能是10-17.</p>
<p>然后再把原来数组的内容复制过去，在插入新的元素2.</p>
<p><img src="https://thepatterraining.github.io/images/DataStructure/list13.png" alt="list7.png"></p>
<p>接下来又插入了元素3.再次扩容，内存地址是20-35。同样把内容复制过去，在插入元素3.</p>
<p><img src="https://thepatterraining.github.io/images/DataStructure/list14.png" alt="list7.png"></p>
<p>至于原来那些不用的数组的内存空间，会被JAVA的内存垃圾回收机制，给回收掉。所以不用管。</p>
<p>接下来计算一下它的时间复杂度吧。</p>
<p>因为我们是每次扩容一倍，所以分别是在1、2、4、8、…、n的时候扩容。<br>因此，当我们插入n个元素的时候，时间复杂度是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(1+2+4+8...+n)</span><br></pre></td></tr></table></figure>

<p>它可以看成是一个级数。i&#x3D;i 到 i&#x3D;n，2的i次方相加。</p>
<p>这个结果，基本上是O(n)的一个复杂度。</p>
<p>这个时候有人说了，这个复杂度不还是O(n)吗，可是我们插入了n个元素，复杂度是O(n)，平均下来，插入1个元素的复杂度就是O(1)了啊。</p>
<p>对于<code>delete_last</code>来说，和上面是一样的。</p>
<p>因此动态数组，<code>ArrayList</code>。的复杂度如下。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>Build</th>
<th>Len</th>
<th>Get_at、Set_at</th>
<th>delete_at、insert_at</th>
<th>delete_last、insert_last</th>
<th>delete_first、insert_first</th>
</tr>
</thead>
<tbody><tr>
<td>动态数组的复杂度</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看到最常用的几个操作里面，ArrayList这个数据结构的复杂度是最低的。</p>
<p>因此，ArrayList几乎一直都比LinkedList好用。</p>
<p>整体的复杂度表格如下。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>Build</th>
<th>Len</th>
<th>Get_at、Set_at</th>
<th>delete_at、insert_at</th>
<th>delete_last、insert_last</th>
<th>delete_first、insert_first</th>
</tr>
</thead>
<tbody><tr>
<td>静态数组的复杂度</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>链表的复杂度</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>动态数组的复杂度</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
</tbody></table>
<p>get_at就是List接口中常用的get()，insert_last就是List接口中常用的add操作，而delete_at就是List接口中常用的remove操作。</p>
<p>来看一下LinkedList和ArrayList的对比吧。可以看到，对于LinkedList来说，get和remove都是O(n)，而ArrayList来说，只有remove是O(n)。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>Build</th>
<th>Len</th>
<th>get</th>
<th>remove</th>
<th>add</th>
</tr>
</thead>
<tbody><tr>
<td>LinkedList的复杂度</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>ArrayList的复杂度</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/java%E6%A0%B8%E5%BF%83.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/java%E6%A0%B8%E5%BF%83.html" class="post-title-link" itemprop="url">算法导论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-15 10:12:47" itemprop="dateCreated datePublished" datetime="2024-04-15T10:12:47+08:00">2024-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
            <span id="/java%E6%A0%B8%E5%BF%83.html" class="post-meta-item leancloud_visitors" data-flag-title="算法导论" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/java%E6%A0%B8%E5%BF%83.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/java%E6%A0%B8%E5%BF%83.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="jvm核心"><a href="#jvm核心" class="headerlink" title="jvm核心"></a>jvm核心</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="jvm基础知识"><a href="#jvm基础知识" class="headerlink" title="jvm基础知识"></a>jvm基础知识</h3><h3 id="java字节码"><a href="#java字节码" class="headerlink" title="java字节码"></a>java字节码</h3><p>Java bytecode由单字节的指令组成，类似汇编，java使用了200多个操作码</p>
<ul>
<li>栈操作指令</li>
<li>程序流程控制指令</li>
<li>对象操作指令</li>
<li>算术运算以及类型转换指令</li>
</ul>
<p>javap可以看到字节码文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -c -verbose ...</span><br></pre></td></tr></table></figure>

<p>astore_1 代表store 本地变量表的slot 1，a代表引用类型<br>istore代表int store</p>
<p>算数操作</p>
<p>类型转换</p>
<p>方法调用指令</p>
<ul>
<li>invokestatic: 调用静态方法</li>
<li>invokespecial: 用来调用构造函数，或同一个类中的private方法，以及超类方法</li>
<li>invokevirtual: 调用公共，受保护和package级的私有方法类似c的虚函数</li>
<li>invokeinterface: 调用接口方法</li>
<li>invokedynamic: lambda实现基础</li>
<li>new 创建对象</li>
<li>getfield: 获取对象的实例字段</li>
<li>putfield: 设置对象的实例字段</li>
</ul>
<p>栈操作指令</p>
<ul>
<li>pop：将栈顶的一个数值弹出（丢弃）。</li>
<li>dup：复制栈顶的一个数值。</li>
<li>swap：交换栈顶的两个数值。</li>
</ul>
<p>条件跳转指令</p>
<ul>
<li>if_icmpeq：如果栈顶两个int值相等，则跳转。</li>
<li>if_icmpne：如果栈顶两个int值不相等，则跳转。</li>
<li>goto：无条件跳转到指定位置。</li>
<li>tableswitch：根据值选择跳转位置，用于switch语句。</li>
</ul>
<p>同步指令</p>
<ul>
<li>monitorenter：进入同步代码块。</li>
<li>monitorexit：退出同步代码块。</li>
</ul>
<h3 id="JVM类加载器"><a href="#JVM类加载器" class="headerlink" title="JVM类加载器"></a>JVM类加载器</h3><p>引导类加载器</p>
<ul>
<li>引导类加载器是最顶层的类加载器，负责加载 Java 核心库中的类（例如 java.lang.* 包中的类）。这些类一般位于 JRE 目录下的 rt.jar 文件中。</li>
<li>它是由 C++ 编写的，直接由操作系统加载，因此没有 Java 类的实现。</li>
<li>它默认从 JRE&#x2F;lib 路径下加载类。</li>
</ul>
<p>扩展类加载器</p>
<ul>
<li>扩展类加载器负责加载 Java 扩展库中的类。这些类通常位于 JRE&#x2F;lib&#x2F;ext 目录下，或者由 java.ext.dirs 系统属性指定的其他路径。</li>
<li>它是由 Java 编写的，属于标准的类加载器。</li>
<li>它默认从 JRE&#x2F;lib&#x2F;ext 目录和 java.ext.dirs 属性指定的路径加载类</li>
</ul>
<p>系统类加载器</p>
<ul>
<li>系统类加载器负责加载应用程序的类，也就是由用户编写的类。它通常从类路径（classpath）中加载类。</li>
<li>它是由 Java 编写的，通常是 ClassLoader 类的一个实例。用户可以指定 classpath 来告诉系统类加载器从哪里加载类。</li>
<li>它根据环境变量 CLASSPATH 或 -cp 命令行参数指定的路径加载类。</li>
</ul>
<p>自定义类加载器</p>
<ul>
<li>Java 还允许程序员创建自定义类加载器，来自定义类加载的行为。自定义类加载器可以扩展 ClassLoader 类并重写其 findClass() 方法，来实现从不同的数据源加载类，比如从数据库、网络等加载类。</li>
<li>自定义类加载器在很多场景中有用，比如在应用服务器中动态加载插件，或者从不常规的源（如数据库、网络等）加载类。</li>
</ul>
<p>类的生命周期</p>
<ul>
<li>加载： 找class文件，类加载器通过 findClass() 方法从指定的位置查找 .class 文件。加载器会将 .class 文件转化为二进制字节流。</li>
<li>验证： 验证格式，依赖。验证阶段确保加载的 .class 文件格式正确，并且不包含任何有可能危害虚拟机安全的代码。</li>
<li>准备： 静态字段，方法表。准备阶段分配内存并为类变量（静态字段）设置默认值（如 0、null 等）。</li>
<li>解析： 符号解析为引用。解析阶段将类中的符号引用（例如字段、方法、类的名字等）解析为实际的内存地址或方法引用。</li>
<li>初始化： 构造器，静态变量赋值，静态代码块。初始化阶段是类加载过程的最后一步，它会执行类的静态初始化块（static 块）和静态字段的初始化。</li>
<li>使用</li>
<li>卸载</li>
</ul>
<p>图片</p>
<p>JVM 中的类加载器采用了父子委托机制（Parent Delegation Model）。当一个类加载器收到加载某个类的请求时，它不会直接去加载类，而是首先将请求委托给父类加载器。如果父类加载器无法加载，则再由当前加载器进行加载。这种机制的好处是可以保证 Java 核心类库不会被用户定义的类覆盖。</p>
<h3 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h3><p>java栈</p>
<ul>
<li>线程私有：存储线程的本地变量信息等</li>
<li>每个线程在执行方法时，都会在栈中创建一个栈帧（stack frame）。栈帧包含方法的局部变量、操作数栈、动态链接、方法返回地址等信息。栈的大小通常由 -Xss 参数进行控制。</li>
<li>局部变量的作用范围仅限于当前方法，存储在栈帧中。</li>
</ul>
<p>本地方法栈</p>
<ul>
<li>用于执行本地方法（即通过 JNI 调用的 C&#x2F;C++ 等语言编写的代码）。和 Java 栈类似，本地方法栈也包含栈帧，但栈帧里存储的是本地方法的相关信息。</li>
<li>每个线程有自己的本地方法栈。</li>
</ul>
<p>java堆</p>
<ul>
<li>共有</li>
<li>存储动态信息，如对象数据，包括对象的成员变量，成员函数，静态变量。因此多线程访问堆中的数据时需要进行同步，以保证数据的一致性和可见性。</li>
<li>堆是垃圾回收的主要区域。</li>
<li>垃圾回收器负责堆内存的管理，通过标记清除、复制回收、分代回收等算法来回收无用对象的内存。</li>
</ul>
<p>方法区</p>
<ul>
<li>方法区用于存储类信息、常量、静态变量、即时编译器（JIT）编译后的代码等数据。在 Java 7 之前，方法区和永久代（PermGen）是一个概念，但在 Java 8 中，永久代被 Metaspace（元空间）替代，Metaspace 位于本地内存中，而非堆中。</li>
<li>方法区是所有线程共享的，因此多线程访问时也需要注意同步。</li>
<li>存储类的元数据（类的结构、常量池等）、静态变量、方法等。</li>
</ul>
<p>运行时常量池</p>
<ul>
<li>运行时常量池是方法区的一部分，用于存储编译期间生成的字面量和符号引用（例如字符串常量和类、方法、字段的引用）。</li>
<li>常量池是所有线程共享的，所有类共享相同的常量池。</li>
</ul>
<p>直接内存</p>
<ul>
<li>直接内存并不是 JVM 内存模型的一部分，但它是通过 java.nio 包提供的 ByteBuffer 类实现的内存区域。直接内存可以绕过 JVM 的堆和垃圾回收机制，直接与操作系统的内存交互，用于提高 I&#x2F;O 性能。</li>
<li>直接内存可以由多个线程共享，但需要开发者手动管理。</li>
</ul>
<p>图片</p>
<p>图片</p>
<p>堆内存图片</p>
<p>堆内存</p>
<ul>
<li>年轻代<ul>
<li>新生代</li>
<li>存活区： 一般有两个</li>
</ul>
</li>
<li>老年代</li>
</ul>
<p>非堆</p>
<ul>
<li>元数据：以前是永久代</li>
<li>CCS: 存放class信息，和元数据有交叉</li>
<li>code cache: 存放JIT编译后的本地机器代码</li>
</ul>
<p>可见性</p>
<ul>
<li>当多个线程访问同一个共享变量时，一个线程对变量的修改可能对其他线程不可见。JMM 规定了变量的可见性，确保一个线程对共享变量的修改能够及时地被其他线程看到。</li>
</ul>
<h3 id="JVM启动参数"><a href="#JVM启动参数" class="headerlink" title="JVM启动参数"></a>JVM启动参数</h3><p>-开头是标准参数，如-server<br>-D设置系统属性，如-Dfile.encoding&#x3D;UTF-8<br>-X开头是非标准参数，基本都传给JVM的，默认JVM实现这些参数的功能。可以jvm -X查看支持的参数。如-Xmx8g<br>-XX开头是非稳定参数，专门控制jvm的行为，根具体的jvm实现有关</p>
<ul>
<li>-XX:+-Flags形式，+-是对布尔值进行开关。+代表开，-代表关。如-XX:_UseG1GC</li>
<li>-XX:key&#x3D;value形式，指定某个选项的值.如-XX:MaxPermSize&#x3D;256m</li>
</ul>
<h3 id="JDK内置工具"><a href="#JDK内置工具" class="headerlink" title="JDK内置工具"></a>JDK内置工具</h3><p>图片</p>
<p>jps&#x2F;jinfo 查看java进程<br>jstat 查看jvm gc信息<br>jmap 查看heap或类占用空间统计<br>jstack 查看线程信息<br>jcmd 执行jvm相关分析命令<br>jrunscript&#x2F;jjs 执行js命令</p>
<p>jstat -gc pid xxx</p>
<p>图片</p>
<p>jmap -heap 查看堆信息</p>
<p>jcmd可以查看所有信息</p>
<p>jconsole</p>
<p>jvisulVM</p>
<p>jMC</p>
<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>分代假设：大部分新生对象很快无用，存活较长时间的对象，可能存活更长时间。</p>
<p>经历了15次GC还存在的就放在老年代</p>
<p>新生代80%，S0,S1各10%<br>新生代到存活区是复制，到老年代是移动<br>-XX: +MaxTenuringThreshold&#x3D;15标记15次后放到老年代</p>
<p>可以做为GC ROOT的对象</p>
<ol>
<li>当前正在执行的方法里的局部变量和输入参数</li>
<li>活动线程</li>
<li>所有类的静态字段</li>
<li>JNI引用</li>
</ol>
<p>需要记录夸代的依赖信息</p>
<h4 id="Serial-GC-x2F-ParNewGC"><a href="#Serial-GC-x2F-ParNewGC" class="headerlink" title="Serial GC&#x2F;ParNewGC"></a>Serial GC&#x2F;ParNewGC</h4><p>-XX: +UseSerialGC开启</p>
<p>对年轻代使用mark-copy算法，对老年代使用mark-sweep-compact算法</p>
<p>串行GC不能并行处理，所以触发全部暂停(STW)</p>
<p>ParNewGC可以配合CMSGC使用</p>
<p>适用场景：</p>
<ul>
<li>单线程应用或资源有限的环境（如嵌入式系统）。</li>
<li>小型应用，不需要频繁的垃圾回收。</li>
</ul>
<h4 id="Parallel-GC"><a href="#Parallel-GC" class="headerlink" title="Parallel GC"></a>Parallel GC</h4><p>目标是最大化应用程序运行时间（吞吐量），最小化 GC 时间。还是会短暂的暂停业务。需要业务能接受短暂的暂停。</p>
<p>-XX: +UseParallelGC<br>-XX: +UseParallelOldGC</p>
<p>年轻代和老年代GC都会触发STW事件。</p>
<p>对年轻代使用mark-copy算法，对老年代使用mark-sweep-compact算法</p>
<p>-XX: ParallelGCThreads&#x3D;N 来指定GC线程数，默认值为CPU核心数。</p>
<p>优点：</p>
<ul>
<li>多线程回收显著提高了回收效率，适合多核环境。</li>
<li>停顿时间较 Serial GC 短。</li>
<li>两次GC之间不消耗系统资源。</li>
</ul>
<p>缺点：</p>
<ul>
<li>GC 停顿仍然是全暂停（STW）。</li>
<li>不适合对延迟要求苛刻的场景。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>需要高吞吐量的大型后台任务（如批处理、数据分析）。</li>
<li>多核 CPU 环境。</li>
</ul>
<h4 id="CMS-GC"><a href="#CMS-GC" class="headerlink" title="CMS GC"></a>CMS GC</h4><p>-XX: +UseConcMarkSweepGC</p>
<p>对年轻代使用STW的mark-copy算法，对老年代主要使用并发的mark-sweep算法</p>
<p>设计目标:专为老年代设计，目标是最小化 GC 停顿时间。</p>
<ol>
<li>不对老年代进行整理，而是使用空闲列表来管理内存空间的回收</li>
<li>在mark-and-sweep的工作和业务线程并发执行。</li>
</ol>
<p>默认并发线程数等于CPU核心数的1&#x2F;4</p>
<p>6个阶段</p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>并发预清理</li>
<li>最终标记</li>
<li>并发清楚</li>
<li>并发重制</li>
</ol>
<p>MaxHeapSize是系统的1&#x2F;4内存<br>MaxNewSize是MaxHeapSize的1&#x2F;3<br>NewSize是系统的1&#x2F;64</p>
<p>优点：</p>
<ul>
<li>只有yongGC暂停业务。GC 停顿时间短，适合延迟敏感的应用。</li>
<li>并发回收利用多核资源减少 STW 时间。</li>
</ul>
<p>缺点：</p>
<ul>
<li>内存碎片化：CMS 不会整理内存，可能导致分配大对象失败（触发 Full GC）。</li>
<li>CPU 开销较高：并发阶段可能与用户线程争抢资源。</li>
<li>容易产生 “Concurrent Mode Failure”：若老年代空间不足，回退到 Serial GC。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>延迟敏感的应用（如 Web 服务、在线交易系统）。</li>
<li>多核环境下的中大型应用。</li>
</ul>
<h4 id="G1-GC"><a href="#G1-GC" class="headerlink" title="G1 GC"></a>G1 GC</h4><p>分区堆内存：将堆划分为若干独立的固定大小的区域（Region），每个 Region 可充当年轻代、老年代或其他用途。混合回收：通过优先回收包含最多垃圾的 Region（Garbage-First）。并行和并发回收：减少 STW 时间。内置碎片整理机制，避免了 CMS 的碎片化问题。</p>
<p>-XX: +UseG1GC -XX: MaxGCPauseMillis&#x3D;50</p>
<p>将STW的时间和分布变成可预期和可配置的，可设置某项特定的性能指标，为了达成可预期的指标，有独特的实现。增量方式，每次处理一部分，称为回收集合，每次处理所有的年轻代和部分老年代。能看到哪个块的垃圾多，优先回收他们</p>
<p>处理步骤</p>
<ol>
<li>年轻代模式转移暂停</li>
<li>并发标记</li>
<li>转移暂停：混合模式</li>
</ol>
<p>G1GC可能退化成串行GC</p>
<ol>
<li>并发模式失败：增加堆大小</li>
<li>晋升失败：</li>
<li>巨型对象分配失败：增加内存或增大Region大小</li>
</ol>
<p>优点：</p>
<ul>
<li>减少内存碎片化。</li>
<li>更好地控制 GC 停顿时间，可通过 -XX:MaxGCPauseMillis 调整。</li>
<li>自动调节年轻代和老年代的大小。</li>
</ul>
<p>缺点：</p>
<ul>
<li>实现复杂，配置选项多。</li>
<li>内存占用较高，CPU 开销大。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>需要低延迟的中大型应用。</li>
<li>堆内存较大的环境（如 &gt;4GB）。</li>
<li>替代 CMS 的推荐选择。</li>
</ul>
<ol>
<li>如果系统考虑吞吐优先，CPU资源用来处理业务，用Parallel GC</li>
<li>如果系统考虑低延迟优先，每次GC时间尽量短，用CMS GC</li>
<li>如果系统内存堆大，平均GC时间可控，使用G1 GC</li>
</ol>
<h4 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h4><p>专注于低延迟，目标是将 GC 停顿时间控制在 10ms 以下。支持非常大的堆内存（TB 级）。使用多线程并发回收，避免长时间的 STW。基于标记-整理算法，避免内存碎片化。使用指针染色（Pointer Coloring）来实现并发标记和引用更新。</p>
<p>-XX: +UnlockExpermentalVMOptions<br>-XX: +UseZGC<br>-XX: -Xmx16g</p>
<p>优点：</p>
<ul>
<li>极低的 GC 停顿时间。</li>
<li>支持超大堆，扩展性好。</li>
<li>减少内存碎片。</li>
<li>与G1相比，应用吞吐量下降不超过15%</li>
</ul>
<p>缺点：</p>
<ul>
<li>内存占用较高：由于需要染色指针和写屏障。</li>
<li>不适合资源紧张的环境。</li>
</ul>
<p>-XX: +UseShenandoahGC</p>
<p>立项比ZGC早，暂停时间与堆大小无关</p>
<p>适用场景：</p>
<ul>
<li>延迟敏感的大型应用（如金融交易、高并发系统）。</li>
<li>超大堆应用（TB 级别内存）。</li>
</ul>
<h4 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h4><p>目标是极低延迟，尽可能减少 STW 时间。采用并发压缩技术（Concurrent Compaction），避免碎片化问题。大部分回收工作与应用线程并发执行。</p>
<p>优点：</p>
<ul>
<li>GC 停顿时间低。</li>
<li>内存整理避免碎片化。</li>
<li>对堆内存的需求比 ZGC 更低。</li>
</ul>
<p>缺点：</p>
<ul>
<li>较新的 GC，生态和调优支持可能不如 G1 和 ZGC。</li>
<li>CPU 开销高。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>延迟敏感的应用。</li>
<li>中大型堆内存的场景。</li>
</ul>
<h4 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h4><h4 id="JVM线程堆栈数据分析"><a href="#JVM线程堆栈数据分析" class="headerlink" title="JVM线程堆栈数据分析"></a>JVM线程堆栈数据分析</h4><p>图片</p>
<p>JVM内部线程</p>
<ul>
<li>VM线程：单例的VMThread对象，负责执行VM操作</li>
<li>定时任务线程：单例的WatcherThread对象，模拟计时器中断。</li>
<li>GC线程：垃圾回收</li>
<li>编译器线程：将字节码编译为本地机器代码</li>
<li>信号分发线程：等待进程指示的信号，并将其分配给java级别的信号处理</li>
</ul>
<p>安全点</p>
<ul>
<li>方法代码中植入检测入口</li>
<li>线程处于安全点状态：线程暂停执行，这个时候线程栈不再发生改变</li>
<li>JVM的安全点状态：所有线程都处于安全点状态</li>
</ul>
<p>fastthread</p>
<h4 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h4><p>Instrumentation.getObjectSize()</p>
<p>JOL可以看到内存布局</p>
<p>64位JVM中对象头占12byte，8字节对齐。Integer占16字节(8+4+对齐)，int占4字节。Long占16字节，long占8字节。</p>
<p>String对象的空间随着内部字符数组的增长而增长。String类的对象有24个字节的额外开销。</p>
<p>jhat</p>
<h4 id="JVM问题分析调优"><a href="#JVM问题分析调优" class="headerlink" title="JVM问题分析调优"></a>JVM问题分析调优</h4><p>分配速率:两次GC之间的年轻代使用量。也就是创建速度，流入速度。</p>
<ul>
<li>正常系统：分配速率较低 &lt; GC速率： 健康</li>
<li>内存溢出: 分配速率 &gt; GC速率： OOM</li>
<li>性能不好：分配速率较高 &lt; GC速率： 亚健康，可能随时导致内存溢出</li>
</ul>
<p>提升速率：从年轻代到老年代的数据量。</p>
<ul>
<li>有一些要被干掉的放到了老年代，老年代GC时间更长。</li>
</ul>
<p>一般来说过早提升的症状表现为以下形式：</p>
<ol>
<li>短时间内频繁的执行full GC</li>
<li>每次full GC后老年代的使用率都很低，在10%-20%或以下。</li>
<li>提升速率接近分配速率</li>
</ol>
<p>解决方案</p>
<ol>
<li>增加年轻代大小。-Xmx1g -XX:NewSize&#x3D;512M，FullGC的次数就会减少</li>
<li>减少每次批处理的数量</li>
</ol>
<p>Arthas工具</p>
<h4 id="GC疑难情况"><a href="#GC疑难情况" class="headerlink" title="GC疑难情况"></a>GC疑难情况</h4><h4 id="JVM常见面试题"><a href="#JVM常见面试题" class="headerlink" title="JVM常见面试题"></a>JVM常见面试题</h4><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><h3 id="java-socket"><a href="#java-socket" class="headerlink" title="java socket"></a>java socket</h3><p>java.net.ServerSocket类</p>
<h3 id="server处理发生了什么"><a href="#server处理发生了什么" class="headerlink" title="server处理发生了什么"></a>server处理发生了什么</h3><h3 id="IO模型和相关概念"><a href="#IO模型和相关概念" class="headerlink" title="IO模型和相关概念"></a>IO模型和相关概念</h3><p>阻塞非阻塞</p>
<p>同步异步</p>
<h3 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h3><p>高性能</p>
<ul>
<li>高并发</li>
<li>低延迟：延迟指服务端运行时间</li>
<li>高吞吐量</li>
</ul>
<h4 id="netty如何实现高性能"><a href="#netty如何实现高性能" class="headerlink" title="netty如何实现高性能"></a>netty如何实现高性能</h4><ul>
<li>异步</li>
<li>事件驱动</li>
<li>基于NIO</li>
</ul>
<p>粘包和拆包，主要通过解码器来解决，比如抄答案的时候两个多选题，答案写的abcd，你不知道是1.ab 2.cd还是1.a 2.bcd还是1.abc 2.d，所以中间需要来个标点符号区分。</p>
<ul>
<li>Fixed：固定长度解码器</li>
<li>LineBased：行分隔符，\n or \r\n</li>
<li>Delimiter: 分隔符解码器，可以自定义分隔符</li>
<li>LengthField: 长度编码解码器，划分为包文头，包文体</li>
<li>Json： JSON解码器</li>
</ul>
<p>网络拥堵和Nagle算法。TCP_NODELAY 可以关掉Nagle算法<br>触发条件，达到下面的条件才会真正向网络发送数据</p>
<ul>
<li>缓冲区满</li>
<li>达到超时</li>
</ul>
<p>优化</p>
<ol>
<li>不要阻塞EventLoop</li>
<li>系统参数优化</li>
<li>缓冲区优化</li>
<li>心跳周期优化</li>
<li>内存和buffer优化</li>
</ol>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>start以后陷入JVM线程，然后OS线程，最后TLAB,准备好了运行以后开始运行状态，run状态。</p>
<p>重要属性</p>
<ul>
<li>线程名称</li>
<li>是否后台执行</li>
<li>任务</li>
<li>start 启动</li>
<li>join 等待执行完成</li>
<li>currentThread 静态方法，获取当前线程信息</li>
<li>sleep 静态方法，线程睡眠并让出时间片</li>
<li>wait 释放锁，等待</li>
<li>notify 唤醒一个</li>
<li>notifyAll 唤醒所有</li>
<li>yield 让出cpu资源</li>
</ul>
<p>原子性<br>可见性<br>有序性</p>
<p>图片</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul>
<li>核心线程数</li>
<li>最大线程数</li>
<li>队列</li>
<li>拒绝策略</li>
</ul>
<p>为什么核心线程数满了以后先放到队列里面？因为要平衡CPU密集型应用和IO密集型应用</p>
<p>拒绝策略</p>
<ul>
<li>丢弃任务抛出异常</li>
<li>丢弃任务不抛出异常</li>
<li>丢弃队列最前面的任务，重新提交被拒绝的任务</li>
<li>由调用线程处理该任务</li>
</ul>
<p>线程池创建</p>
<ul>
<li>Executors.newSingleThreadExecutor : 仅仅创建一个线程的线程池</li>
<li>Executors.newFixedThreadPool：固定大小的</li>
<li>Executors.newCachedThreadPool：可缓存的线程池，如果线程超过了执行任务所需的，60s不执行任务的会被回收，任务增加的时候可以智能增加线程数，线程大小依赖于操作系统</li>
<li>Executors.newScheduledThreadPool：支持定时以及周期性执行</li>
</ul>
<p>核心线程数，如果CPU密集型，可以N+1或者N,如果IO密集型，可以2N或者2N+2</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul>
<li><p>Sync</p>
</li>
<li><p>ReentrantLock</p>
</li>
<li><p>ReadWriteLock</p>
</li>
<li><p>Condition</p>
</li>
<li></li>
<li><p>可重入锁</p>
</li>
<li><p>公平锁</p>
</li>
</ul>
<p>LockSupport 类似Executors</p>
<ul>
<li>park</li>
<li>parkNanos</li>
<li>unpark</li>
</ul>
<p>三个用锁的最佳实践</p>
<ul>
<li>永远只在更新对象的成员变量时加锁</li>
<li>永远只在访问可变的成员变量时加锁</li>
<li>永远不在调用其他对象的方法时加锁</li>
</ul>
<h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>通过volitale和CAS实现</p>
<p>LongAdder对AtomicLong的改进</p>
<h3 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h3><h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>准入数量 信号量</p>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><h4 id="arrayList"><a href="#arrayList" class="headerlink" title="arrayList"></a>arrayList</h4><p>默认大小10，扩容1.5， new &#x3D; old + (old &gt;&gt; 1)</p>
<p>线程不安全</p>
<p>写写冲突<br>读写冲突 iterator</p>
<h4 id="linkedList"><a href="#linkedList" class="headerlink" title="linkedList"></a>linkedList</h4><p>链表实现不需要扩容</p>
<p>线程不安全</p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>写时复制线程安全，写加锁</p>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>加锁的ArrayList</p>
<h4 id="List-asList"><a href="#List-asList" class="headerlink" title="List.asList"></a>List.asList</h4><p>只能set，不能添加删除元素</p>
<h4 id="Collections-SyncList"><a href="#Collections-SyncList" class="headerlink" title="Collections.SyncList"></a>Collections.SyncList</h4><p>加锁的ArrayList</p>
<h4 id="Collections-noModifyList"><a href="#Collections-noModifyList" class="headerlink" title="Collections.noModifyList"></a>Collections.noModifyList</h4><p>不可插入删除set的list</p>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>初始容量16，扩容*2，负载因子0.75, jDK8以后，链表长度8，数组长度64以后，改成红黑树</p>
<ul>
<li>写冲突</li>
<li>读写问题</li>
<li>keys()无序问题</li>
</ul>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>继承HashMap, 增加了双向链表，保证有序</p>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>线程安全 JDK7用的extendible hash 实现，分段</p>
<p>JDK8改成一个大叔组</p>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>线程本地变量<br>不改方法签名静默传参<br>及时进行清理</p>
<h4 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h4><p>static变量<br>Lock<br>Sync</p>
<p>协作</p>
<ul>
<li>Thread#join();</li>
<li>Object#wait&#x2F;notify&#x2F;notifyall</li>
<li>Future&#x2F;Callable</li>
<li>CountdownLatch</li>
<li>CyclicBarrier</li>
</ul>
<p>进程间通信</p>
<h3 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h3><h4 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h4><p>集群：多个相同服务，对等的关系<br>分布式：有角色关系，多个服务处理不一样的东西</p>
<p>服务汇聚到ESB：服务编排，网关</p>
<ol>
<li>暴露调用</li>
<li>增强和中介</li>
<li>统计和监控</li>
</ol>
<p>缺点是中心节点，增加一层</p>
<p>分布式服务化：用配置和注册发现代替ESB单节点，使请求直连</p>
<p>有状态的部分放到配置中心和注册中心，无状态的部分放到应用侧。比如RPC放到应用侧。</p>
<p>配置中心：全局非业务参数<br>注册中心：运行期临时状态<br>元数据中心：核心的业务模型</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>两种消息模式：</p>
<ul>
<li>点对点</li>
<li>发布订阅</li>
</ul>
<p>消息处理的保障</p>
<ul>
<li>At most once,至多一次，只发一次，消息丢失了也不重发</li>
<li>At least once, 至少一次，消息不回丢失，可能会重复</li>
<li>Exactly once, 精确一次，每条消息肯定会被传输一次且仅一次，不丢失不重复</li>
</ul>
<p>消息处理的事务性</p>
<ul>
<li>通过确认机制实现事务性</li>
<li>可以被事务管理器管理，甚至可以支持XA分布式事务</li>
</ul>
<p>有序性</p>
<ul>
<li>同一个Topic或Queue的消息，保障顺序</li>
<li>消息分区，批量预取等可能会无序</li>
</ul>
<p>书籍企业集成模式</p>
<p>消息协议</p>
<ul>
<li>AMQP：规定了序列化，网路传输等</li>
<li>MQTT：遥感常用</li>
<li>JMS：java规定的接口</li>
<li>XMPP： IM用的</li>
</ul>
<p>kafka<br>ack &#x3D; 0 ,不管成功没<br>ack &#x3D; 1, 写到leader就成功<br>ack &#x3D; -1&#x2F;all 写到最小副本数才算成功</p>
<p>顺序保证<br>per.connetion &#x3D; 1<br>send()<br>flush()</p>
<p>消息可靠性</p>
<ul>
<li>消息的事务，发送的时候要么全成功，要么全失败，ack &#x3D; all，idem&#x3D;true打开幂等,transaction.id tx0001设置事务ID,begin开始事务</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA.html" class="post-title-link" itemprop="url">算法导论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-15 10:12:47" itemprop="dateCreated datePublished" datetime="2024-04-15T10:12:47+08:00">2024-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
            <span id="/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA.html" class="post-meta-item leancloud_visitors" data-flag-title="算法导论" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="算法导论"><a href="#算法导论" class="headerlink" title="算法导论"></a>算法导论</h1><p>目标一：解决计算问题，除此之外还有更多。more than that<br>目标二：证明正确性<br>目标三：证明更高效<br>目标四：可以和其他人讲明白为什么正确且高效</p>
<h2 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h2><p>算法就是用来求解问题的，我们想求解一组通用的问题，而不是固定的问题。算法的实现就是一个函数，给定一组输入，得到一个正确的输出。</p>
<p>数学归纳法证明算法的正确性。</p>
<p><code>循环不变式</code>主要用来帮助我们理解算法的正确性。我们必须证明三条性质</p>
<ol>
<li>初始化：循环的第一次迭代之前它为真</li>
<li>保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真</li>
<li>终止：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的</li>
</ol>
<p>通过循环不变式证明插入排序是正确的，下面是插入排序的伪代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">insert_sort(A)</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">2</span> to A.length</span><br><span class="line">        key = A[j]</span><br><span class="line">        i = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> and A[i] &gt; key</span><br><span class="line">            A[i+<span class="number">1</span>] = A[i]</span><br><span class="line">            i--</span><br><span class="line">        A[i+<span class="number">1</span>] = key</span><br></pre></td></tr></table></figure>

<p>循环不变式开始的时候，j &#x3D; 2的时候，A[1]…A[j-1]里面只有一个元素A[1]，当然是已排序的。循环不变式成立<br>保持：证明每次迭代保持循环不变式，非形式化的来看，4-7行将A[j-1],A[j-2]等向右移动，第8行将key插入合适的位置，子数组由原来的A[1]…A[j-1]组成，且已经排好序，下一次迭代增加j将保持循环不变式。</p>
<blockquote>
<p>如果是形式化的处理，还需要证明while循环的循环不变式。我们不愿陷入形式主义的困境，所以只根据非形式化的来看。<br>终止：for 循环的终止条件是 j &gt; A.length, 因为每次循环j+1，所以必然会有j &#x3D; A.length + 1,我们的子数组A[1]…A[j-1]，就变成了A[1]…A[A.length]由原来的A[1]…A[A.length]组成，且已排好序。因此算法正确</p>
</blockquote>
<p>练习1.重新insert_sort，使排序变成降序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">insert_sort(A)</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">2</span> to A.length</span><br><span class="line">        key = A[j]</span><br><span class="line">        i = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> and A[i] &lt; key</span><br><span class="line">            A[i+<span class="number">1</span>] = A[i]</span><br><span class="line">            i--</span><br><span class="line">        A[i+<span class="number">1</span>] = key</span><br></pre></td></tr></table></figure>

<h2 id="数据结构和动态数组"><a href="#数据结构和动态数组" class="headerlink" title="数据结构和动态数组"></a>数据结构和动态数组</h2><ul>
<li>Interface(API&#x2F;ADT): 你想做什么？是一种规范，定义了支持哪些操作。可以理解为问题。</li>
<li>Data Structure: 实际怎么做，数据实际的表示形式。算法对于操作的支持。可以理解为解决方案。</li>
</ul>
<p>接口：</p>
<ul>
<li>Sequence<ul>
<li>Static Sequence Interface: 静态的，数量不可变的。<ul>
<li>build(x): 新建一个Static Sequence。</li>
<li>len(): 返回数量</li>
<li>iter_seq(): 迭代器</li>
<li>get_at(i): 获取i下标的元素</li>
<li>set_at(i, x): 设置i下标的元素为x</li>
<li>get_first()</li>
<li>get_last()</li>
<li>set_first()</li>
<li>set_last()</li>
</ul>
</li>
<li>Dynamic Sequence Interface: 动态的，数量可变的<ul>
<li>支持上面所有</li>
<li>insert_at(i, x): 插入某一个位置</li>
<li>delete_at(i): 删除某一个位置的元素</li>
<li>insert_first()</li>
<li>insert_last()</li>
<li>delete_fist()</li>
<li>delete_last()</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>数据结构：</p>
<ul>
<li>Linked List</li>
</ul>
<h2 id="Set-And-Sorting"><a href="#Set-And-Sorting" class="headerlink" title="Set And Sorting"></a>Set And Sorting</h2><p>接口</p>
<ul>
<li>Set<ul>
<li>Container<ul>
<li>build(A): 根据一个iterable的A,创建</li>
<li>len(): 返回数量</li>
</ul>
</li>
<li>Static <ul>
<li>find(k): 返回一个set中的元素</li>
</ul>
</li>
<li>Dynamic <ul>
<li>insert(k): 插入一个元素到set</li>
<li>delete(k): 从set中删除一个元素</li>
</ul>
</li>
<li>Order <ul>
<li>iter_ord(): 迭代器</li>
<li>find_min(): 获取最小的key</li>
<li>find_max(): 获取最大的key</li>
<li>find_next(k): 获取比k大的下一个key</li>
<li>find_pre(k): 获取比k小的上一个key</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>数据结构</p>
<ul>
<li>Array</li>
<li>Sorted Array</li>
</ul>
<p>排序</p>
<ul>
<li>破坏性：用一个新的排序后的数组B覆盖数组A</li>
<li>原地排序：仅仅用O(1)空间来排序</li>
</ul>
<p>permutation Sort</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0.html" class="post-title-link" itemprop="url">算法导论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-15 10:12:47" itemprop="dateCreated datePublished" datetime="2024-04-15T10:12:47+08:00">2024-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
            <span id="/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0.html" class="post-meta-item leancloud_visitors" data-flag-title="算法导论" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><p>线性代数的基本问题是求解线性方程组</p>
<h2 id="Ax-x3D-b"><a href="#Ax-x3D-b" class="headerlink" title="Ax &#x3D; b"></a>Ax &#x3D; b</h2><p>给定两个方程：<code>2x - y = 0</code> 和 <code>-x + 2y = 3</code>。<br>对于<code>row picture</code> 矩阵是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[2, -1] [x] = [0]</span><br><span class="line">[-1, 2] [y]   [3]</span><br><span class="line">A        X  =  b</span><br></pre></td></tr></table></figure>

<p>画图为</p>
<p>对于<code>column picture</code> 矩阵是下图，矩阵叫做<code>列的线性组合</code>，解出来x &#x3D; 1, y &#x3D; 2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x [2 ]   + y [-1] = [0]</span><br><span class="line">  [-1]       [2 ]   [3]</span><br></pre></td></tr></table></figure>

<p>画图为</p>
<p>矩阵和向量的乘法：</p>
<p>1 2 3<br>4 5 6<br>7 8 9 &#x3D; 1｜5 6｜ - 2 |4 6| + 3 |4 5|<br>         |8 9|    |7 9|       |7 8| &#x3D; 1 * -3 - (2 * -6) + (3 * -3) &#x3D; -3 + 12 - 9 &#x3D; 0</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/JAM%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/JAM%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html" class="post-title-link" itemprop="url">JAM核心技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-22 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-22T00:00:00+08:00">2024-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span id="/JAM%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html" class="post-meta-item leancloud_visitors" data-flag-title="JAM核心技术" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/JAM%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/JAM%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JAM核心技术"><a href="#JAM核心技术" class="headerlink" title="JAM核心技术"></a>JAM核心技术</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/springCloudStream.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/springCloudStream.html" class="post-title-link" itemprop="url">spring Cloud Stream</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-19 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-19T00:00:00+08:00">2024-01-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span id="/springCloudStream.html" class="post-meta-item leancloud_visitors" data-flag-title="spring Cloud Stream" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/springCloudStream.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/springCloudStream.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="springCloudStream"><a href="#springCloudStream" class="headerlink" title="springCloudStream"></a>springCloudStream</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Spring Cloud Stream</code>是一个框架，用于构建与共享消息传递系统连接的高度可扩展的事件驱动微服务。</p>
<p>该框架提供了一个灵活的编程模型，该模型建立在已经建立和熟悉的 Spring 习惯用语和最佳实践之上，包括对持久发布&#x2F;订阅语义、消费者组和有状态分区的支持。</p>
<p>核心模块</p>
<ul>
<li>Destination Binders： 负责提供与外部消息系统集成的组件</li>
<li>Destination Bindings： 外部消息系统和用户程序代码之间的桥梁(生产者-使用者之间的桥梁)</li>
<li>Message：生产者和消费者用于与Destination Binders（以及通过外部消息系统与其他应用程序）通信的规范数据结构。</li>
</ul>
<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>Spring 的数据集成之旅始于 Spring Integration。通过其编程模型，它提供了一致的开发人员体验来构建应用程序，这些应用程序可以采用企业集成模式来连接外部系统，例如数据库、消息代理等。</p>
<p>快进到云时代，微服务在企业环境中变得突出。Spring Boot 改变了开发人员构建应用程序的方式。借助 Spring 的编程模型和 Spring Boot 处理的运行时职责，可以无缝开发独立的、基于 Spring 的生产级微服务。</p>
<p>为了将其扩展到数据集成工作负载，Spring Integration 和 Spring Boot 被放在一个新项目中。Spring Cloud Stream 诞生了。</p>
<h3 id="架构模型"><a href="#架构模型" class="headerlink" title="架构模型"></a>架构模型</h3><p><img src="/../images/spring-stream-01.png" alt="stream"></p>
<p>这张图是spring-stream官网的，里面的<code>Middleware</code>指的就是<code>RabbitMQ</code>或者<code>KafKa</code>这些消息队列。</p>
<p>下图是我们原来和消息队列通信的方式。我们的程序直接发送数据给MQ或者监听到MQ的数据。</p>
<p><img src="/../images/spring-stream-02.png" alt="stream"></p>
<p>通过<code>spring stream</code>来做的话，就增加了<code>Binder</code>层来做统一调度，我们的程序只需要和Binder层通信，不需要关注底层的MQ是<code>RabbitMQ</code>还是<code>Kafka</code>。</p>
<p>目前官方提供了两个<code>Binder</code>，分别是<code>RabbitMQ</code>的和<code>Kafka</code>的，其余队列的有一些第三方维护的。同时我们也可以自己实现<code>Binder</code>。</p>
<p>一开始图中的<code>Input</code>和<code>Output</code>是对于<code>spring stream</code>来说的，input就是输入消息到stream中，output就是输出消息到我们的程序中。</p>
<p>简单介绍一下Binder，其实就是<code>策略模式</code>，统一接口实现，比如MQ1里面发送消息到MQ的方法叫<code>Publish</code>，MQ2里面发送消息到MQ的方法叫<code>Release</code>，但是在Binder接口里面提供了一个方法，就叫做<code>add</code>。也只需要提供一个Message消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Binder</span>&#123;</span><br><span class="line">    function <span class="title function_">add</span><span class="params">(Message msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接MQ1的Binder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Binder1</span> <span class="keyword">implements</span> <span class="title class_">Binder</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> function <span class="title function_">add</span><span class="params">(Message msg)</span>&#123;</span><br><span class="line">        <span class="comment">// 消息处理</span></span><br><span class="line">        <span class="comment">// 发送到MQ1</span></span><br><span class="line">        publish(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接MQ2的Binder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Binder2</span> <span class="keyword">implements</span> <span class="title class_">Binder</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> function <span class="title function_">add</span><span class="params">(Message msg)</span>&#123;</span><br><span class="line">        <span class="comment">// 消息处理</span></span><br><span class="line">        <span class="comment">// 发送到MQ2</span></span><br><span class="line">        release(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们使用的时候只需要自己决定使用哪个Binder就可以了。就是就和连接数据库一样，不需要关心连接的是Mysql还是PostgreSql。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> function <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Binder</span> <span class="variable">binder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Binder1</span>();</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">        binder.add(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Bindings"><a href="#Bindings" class="headerlink" title="Bindings"></a>Bindings</h4><p>Bindings作为一个桥梁，负责连接MQ和用户代码。比如绑定一个代码作为input往某一个Queue里面输入信息，绑定一个代码作为output从某个Queue里面接收信息。然后我们使用Binder来实现推送消息到MQ和消费消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里是官网原文：The application communicates with the outside world by establishing bindings between destinations exposed by the external brokers and input/output arguments in your code. Broker specific details necessary to establish bindings are handled by middleware-specific Binder implementations.</span><br></pre></td></tr></table></figure>

<p>下图为Bindings和Binder的关系</p>
<p><img src="/../images/spring-stream-03.png" alt="stream"></p>
<h4 id="source-和-sink"><a href="#source-和-sink" class="headerlink" title="source 和 sink"></a>source 和 sink</h4><p>source其实就是发送方的发送的Message. sink就是接收方接受的Message</p>
<h2 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注解的实现已经被彻底删除,只有之前低版本的还能使用</span><br></pre></td></tr></table></figure>

<h2 id="函数式编程实现示例"><a href="#函数式编程实现示例" class="headerlink" title="函数式编程实现示例"></a>函数式编程实现示例</h2><h3 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h3><p>将下面的代码加入<code>pom</code>文件，然后使用<code>maven</code>导入相关依赖即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 引入spring cloud stream依赖</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-stream&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">// 引入spring cloud stream的rabbit binder依赖</span><br><span class="line">// 如果是kafka，那么把这个换成kafka的binder</span><br><span class="line">// 在这个binder里面已经引入了 rabbit MQ依赖，所以不需要再单独引入rabbit MQ了</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8801</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span> <span class="comment"># stream的配置</span></span><br><span class="line">      <span class="attr">binders:</span> <span class="comment"># 在此处配置要绑定的rabbitmq的服务信息；</span></span><br><span class="line">        <span class="attr">defaultRabbit:</span> <span class="comment"># 表示定义的名称，用于于binding整合</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment"># 消息组件类型</span></span><br><span class="line">          <span class="attr">environment:</span> <span class="comment"># 设置rabbitmq的相关的环境配置</span></span><br><span class="line">            <span class="attr">spring:</span></span><br><span class="line">              <span class="attr">rabbitmq:</span></span><br><span class="line">                <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">                <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">                <span class="attr">password:</span> <span class="string">guest</span></span><br></pre></td></tr></table></figure>

<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><h5 id="配置文件修改"><a href="#配置文件修改" class="headerlink" title="配置文件修改"></a>配置文件修改</h5><p>对于函数式编程来说，<code>spring cloud stream</code>有一些<code>约定</code>或者说<code>规定</code>。比如我们注册了一个<code>logPub</code>的<code>Bean</code>，那么它对应的<code>bindings</code>配置的名称就是<code>logPub-in-0</code>或者<code>logPub-out-0</code>，前面是我们的方法名，中间表示生产者或消费者，<code>in</code>表示消费者，<code>out</code>表示生产者。这里的in or out是对于我们的代码来说的。后面的0就是一个序号。</p>
<p>写生产者之前我们需要加上对应的<code>bindings</code>配置。如果注册了多个<code>Bean</code>作为生产者或消费者，那么还需要配置哪些<code>Bean</code>是生产者和消费者。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">function:</span> <span class="comment"># 配置哪些Bean是Stream可以用的</span></span><br><span class="line">        <span class="attr">definition:</span> <span class="string">log;logPub;sendLog</span></span><br><span class="line">    <span class="attr">stream:</span> <span class="comment"># stream的配置</span></span><br><span class="line">        <span class="attr">bindings:</span> <span class="comment"># 服务的整合处理</span></span><br><span class="line">            <span class="attr">logPub-out-0:</span></span><br><span class="line">                <span class="attr">destination:</span> <span class="string">log</span> <span class="comment"># 表示要使用的Exchange名称定义,不存在会自动创建</span></span><br><span class="line">                <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为json，文本则设置“text/plain”</span></span><br></pre></td></tr></table></figure>

<h5 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h5><p>随便新建一个类，并标记为<code>@Component</code>，主要是要让spring知道这个类。类名可以随便起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">logProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后开始编写生产者的代码。加入主要的方法<code>log</code>，方法名可以随便起，只需要记得把这个方法注册为一个<code>Bean</code>就可以了。一定要在上面加<code>@Bean</code>注解。</p>
<p>方法的返回值只能是<code>Supplier</code>函数接口类型。不能是其他的。</p>
<p>方法里面可以写生产者的具体代码。会注册一个名为<code>logPub</code>的<code>Bean</code>作为生产者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">logListener</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Supplier&lt;logListener.Person&gt; logPub() &#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">            person.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者:&quot;</span>+person);</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于<code>Supplier</code>，这个是java提供的<code>函数式编程的接口</code>。从java8开始提供的，java8里面的stream功能也用到了函数式编程。</p>
<p>下面是<code>Supplier</code>的注释和定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Represents a supplier of results.</span></span><br><span class="line"><span class="comment">//There is no requirement that a new or distinct result be returned each time the supplier is invoked.</span></span><br><span class="line"><span class="comment">//This is a functional interface whose functional method is get().</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt;</span><br></pre></td></tr></table></figure>
<p>翻译过来大概就是：<code>一个结果的提供者</code>或者<code>一个结果的生产者</code>。正好对应我们的生产者。该接口只有一个方法<code>T get()</code>，没有参数并且仅返回一个结果。</p>
<h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><p>运行的话会发现控制台一直在打印。我们的队列里面也一直在新增。</p>
<p><img src="/../images/spring-stream-03.png" alt="stream"></p>
<h5 id="StreamBridge"><a href="#StreamBridge" class="headerlink" title="StreamBridge"></a>StreamBridge</h5><p>当前的运行方式是当写完生产者以后，<code>spring cloud stream</code>会1&#x2F;s次来调用我们的生产者，但是我们一般是自己来控制生产者的调用。就可以使用下面的方法。</p>
<p>我们可以通过<code>StreamBridge</code>来做到这一点。他有四个<code>send</code>方法。</p>
<ul>
<li>public boolean send(String bindingName, Object data)：第一个参数是bindingName，我们输入的是sendLog,就需要增加sendLog的配置，我们也可以用之前的<code>logPub-out-0</code>。第二个参数是发送的数据。</li>
<li>public boolean send(String bindingName, Object data, MimeType outputContentType)：比上面的多了一个数据类型。</li>
<li>public boolean send(String bindingName, @Nullable String binderName, Object data)：还可以指定Binder的name</li>
<li>public boolean send(String bindingName, @Nullable String binderName, Object data, MimeType outputContentType): 四个参数放在一起了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">logController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StreamBridge streamBridge;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendLog&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendLog</span><span class="params">()</span> &#123;</span><br><span class="line">        logListener.<span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">logListener</span>.Person();</span><br><span class="line">        person.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;生产者发送消息&quot;</span>+person);</span><br><span class="line">        streamBridge.send(<span class="string">&quot;sendLog&quot;</span>, person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>随便新建一个类，并标记为<code>@Component</code>，主要是要让spring知道这个类。类名可以随便起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">logListener</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后开始编写消费者的代码。加入主要的方法<code>log</code>，方法名可以随便起，只需要记得把这个方法注册为一个<code>Bean</code>就可以了。一定要在上面加<code>@Bean</code>注解。</p>
<p>方法的返回值可以是<code>Consumer</code>，也可以是<code>Function</code>。不能是其他的。</p>
<p>方法里面就可以写消费的具体代码了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">logListener</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Consumer&lt;logListener.Person&gt; log() &#123;</span><br><span class="line">        <span class="keyword">return</span> person -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Received: &quot;</span> + person);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于<code>Consumer</code>和<code>Function</code>，这两个是java提供的<code>函数式编程的接口</code>。从java8开始提供的，java8里面的stream功能也用到了函数式编程。</p>
<p>下面是<code>Consumer</code>接口的注释和接口的定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Represents an operation that accepts a single input argument and returns no result. Unlike most other functional interfaces, Consumer is expected to operate via side-effects.</span></span><br><span class="line"><span class="comment">//This is a functional interface whose functional method is accept(Object).</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt;</span><br></pre></td></tr></table></figure>
<p>翻译过来大概就是说Consumer接口<code>仅接收一个参数</code>并且没有返回值，我们的代码里面也可以看到，接收了一个person参数，没有return。</p>
<p>该接口只有一个方法<code>void accept(T t)</code>，T类型就是我们的Person类型。</p>
<p>下面是<code>Function</code>接口的注释和定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Represents a function that accepts one argument and produces a result.</span></span><br><span class="line"><span class="comment">//This is a functional interface whose functional method is apply(Object).</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt;</span><br></pre></td></tr></table></figure>
<p>翻译过来大概就是说<code>Function</code>接口<code>仅接收一个参数</code>并且<code>返回一个结果</code>。该接口只有一个方法<code>R apply(T t)</code>，接收一个T类型的参数，返回一个R类型的结果。</p>
<p><img src="/../images/spring-stream-05.png" alt="stream"></p>
<h5 id="手动ACK"><a href="#手动ACK" class="headerlink" title="手动ACK"></a>手动ACK</h5><p>通过禁止使用死信队列来执行手动的ACK,这个时候如果抛出异常，则会重试。如果开启了死信队列，那么抛出异常以后则会进入死信队列。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log-in-0:</span></span><br><span class="line">    <span class="attr">consumer:</span></span><br><span class="line">        <span class="attr">auto-bind-dlq:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h3><p>上面可以看出来，创建的都是<code>匿名队列</code>，当程序启动的时候自动创建，当程序关闭的时候自动删除。</p>
<p>但是正常开发中，很少使用这种，都会指定一个持久化的队列，不管程序是否运行，队列都存在。</p>
<p>我们可以在<code>bindings</code>的配置里面增加<code>group</code>配置来显式指定哪个队列，我们指定<code>log123</code>队列。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log-in-0:</span></span><br><span class="line">    <span class="attr">destination:</span> <span class="string">log</span></span><br><span class="line">    <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为json，文本则设置“text/plain”</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">log123</span></span><br><span class="line"><span class="attr">sendLog:</span></span><br><span class="line">    <span class="attr">destination:</span> <span class="string">log</span></span><br><span class="line">    <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为json，文本则设置“text/plain”</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">log123</span></span><br></pre></td></tr></table></figure>

<p>再次运行程序，可以看到该队列被创建。接下来停止程序，可以看到队列还存在那里。</p>
<h3 id="bindings重命名"><a href="#bindings重命名" class="headerlink" title="bindings重命名"></a>bindings重命名</h3><p>默认约定的名称为<code>log-in-0</code>这种形式</p>
<p>但是我们也可以将它重命名。通过配置文件可以将<code>log-in-0</code>重命名为<code>input</code>，不过这样的话，所有的log-in-0的bindings配置都需要修改成input，使用上也是。注意官方并不推荐这种做法，他们认为在大多数情况下，这有点矫枉过正。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">stream:</span></span><br><span class="line">            <span class="attr">function:</span></span><br><span class="line">                <span class="attr">bindings:</span></span><br><span class="line">                    <span class="attr">log-in-0:</span> <span class="string">input</span></span><br></pre></td></tr></table></figure>


<h3 id="显式绑定创建"><a href="#显式绑定创建" class="headerlink" title="显式绑定创建"></a>显式绑定创建</h3><p>默认约定的是<code>log-in-0</code>负责输入，<code>log-out-0</code>负责输出，我们也可以显式的创建这些。</p>
<p>通过配置文件</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">stream:</span></span><br><span class="line">            <span class="attr">input-bindings:</span> <span class="string">login;fooin</span></span><br><span class="line">            <span class="attr">output-bindings:</span> <span class="string">logout;fooout</span></span><br></pre></td></tr></table></figure>

<h3 id="轮询配置属性"><a href="#轮询配置属性" class="headerlink" title="轮询配置属性"></a>轮询配置属性</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">integration:</span></span><br><span class="line">        <span class="attr">poller:</span></span><br><span class="line">            <span class="comment"># 全局配置</span></span><br><span class="line">            <span class="attr">fixedDelay:</span> <span class="string">1000L</span> <span class="comment"># 默认轮询器的延迟 单位毫秒，默认1000L </span></span><br><span class="line">            <span class="attr">maxMessagesPerPoll:</span> <span class="string">1L</span> <span class="comment"># 默认轮询器的每个轮询事件的最大消息数。默认 1L</span></span><br><span class="line">            <span class="attr">cron:</span> <span class="string">none</span> <span class="comment"># Cron 触发器的 Cron 表达式值。默认 none</span></span><br><span class="line">            <span class="attr">initialDelay:</span> <span class="number">0</span> <span class="comment"># 周期性触发的初始延迟。 默认0</span></span><br><span class="line">            <span class="attr">timeUnit:</span> <span class="string">MILLISECONDS</span> <span class="comment"># 要应用于延迟值的 TimeUnit。默认 MILLISECONDS</span></span><br></pre></td></tr></table></figure>

<p>也可以单独为某个bindings来配置</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">stream:</span></span><br><span class="line">            <span class="attr">bindings:</span></span><br><span class="line">                <span class="attr">log-out-0:</span></span><br><span class="line">                    <span class="attr">producer:</span></span><br><span class="line">                        <span class="attr">poller:</span></span><br><span class="line">                            <span class="comment"># log-out-0的单独配置</span></span><br><span class="line">                            <span class="attr">fixedDelay:</span> <span class="string">1000L</span> <span class="comment"># 默认轮询器的延迟 单位毫秒，默认1000L </span></span><br><span class="line">                            <span class="attr">maxMessagesPerPoll:</span> <span class="string">1L</span> <span class="comment"># 默认轮询器的每个轮询事件的最大消息数。默认 1L</span></span><br><span class="line">                            <span class="attr">cron:</span> <span class="string">none</span> <span class="comment"># Cron 触发器的 Cron 表达式值。默认 none</span></span><br><span class="line">                            <span class="attr">initialDelay:</span> <span class="number">0</span> <span class="comment"># 周期性触发的初始延迟。 默认0</span></span><br><span class="line">                            <span class="attr">timeUnit:</span> <span class="string">MILLISECONDS</span> <span class="comment"># 要应用于延迟值的 TimeUnit。默认 MILLISECONDS</span></span><br></pre></td></tr></table></figure>

<h3 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h3><p>假设我们有两个处理<code>Bean</code>,<code>enrich</code>负责检查header，如果缺少foo,就添加为foo,bar。然后第二个echo则负责检查是否包含foo这个Header然后输出消息内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Function&lt;Message&lt;String&gt;, Message&lt;String&gt;&gt; <span class="title function_">enrich</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> message -&gt; &#123;</span><br><span class="line">        Assert.isTrue(!message.getHeaders().containsKey(<span class="string">&quot;foo&quot;</span>), <span class="string">&quot;Should NOT contain &#x27;foo&#x27; header&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> MessageBuilder.fromMessage(message).setHeader(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>).build();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Function&lt;Message&lt;String&gt;, Message&lt;String&gt;&gt; <span class="title function_">echo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> message -&gt; &#123;</span><br><span class="line">        Assert.isTrue(message.getHeaders().containsKey(<span class="string">&quot;foo&quot;</span>), <span class="string">&quot;Should contain &#x27;foo&#x27; header&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Incoming message &quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过配置将这两个bean组合起来,组合之后，这个bean名称就编程了<code>enrich|echo</code>,后续的配置都需要这种冗长的名称，所以这里官方推荐使用重命名的方式将它变成简单的名称。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">function:</span></span><br><span class="line">            <span class="attr">definition:</span> <span class="string">enrich|echo</span> <span class="comment"># 函数组合</span></span><br><span class="line">        <span class="attr">stream:</span></span><br><span class="line">            <span class="attr">function:</span> </span><br><span class="line">                <span class="attr">bindings:</span></span><br><span class="line">                    <span class="string">enrich|echo-in-0:</span> <span class="string">input</span> <span class="comment"># 重命名</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html" class="post-title-link" itemprop="url">南京大学操作系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-26 10:12:47" itemprop="dateCreated datePublished" datetime="2023-07-26T10:12:47+08:00">2023-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          
            <span id="/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html" class="post-meta-item leancloud_visitors" data-flag-title="南京大学操作系统" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="南京大学操作系统"><a href="#南京大学操作系统" class="headerlink" title="南京大学操作系统"></a>南京大学操作系统</h1><p>教材是<a target="_blank" rel="noopener" href="https://pages.cs.wisc.edu/~remzi/OSTEP/">OSTEP</a>,课程<a target="_blank" rel="noopener" href="https://jyywiki.cn/OS/2023/">官网</a></p>
<h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><p>这里概述了操作系统做什么，怎么做。</p>
<p>总共有三个大模块，<code>虚拟化</code>，<code>并发</code>,<code>持久化</code>。</p>
<p>操作系统的几个目标：</p>
<ol>
<li>高性能：高效率的运行多个程序。</li>
<li>保护每个程序独立运行：不能让一个程序访问另外一个程序的内存数据</li>
<li>可靠性：操作系统必须一直运行，不能停止，因为一旦停止，所有依赖他的软件程序都会停止。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCacheLab.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCacheLab.html" class="post-title-link" itemprop="url">深入理解计算机系统CacheLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-11 10:12:47" itemprop="dateCreated datePublished" datetime="2023-07-11T10:12:47+08:00">2023-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/csapp/" itemprop="url" rel="index"><span itemprop="name">csapp</span></a>
                </span>
            </span>

          
            <span id="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCacheLab.html" class="post-meta-item leancloud_visitors" data-flag-title="深入理解计算机系统CacheLab" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCacheLab.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCacheLab.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Cache-Lab"><a href="#Cache-Lab" class="headerlink" title="Cache Lab"></a>Cache Lab</h1><p>cache lab 缓存实验</p>
<h3 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h3><p>从CSAPP上面下载对应的lab代码</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/labs.html">http://csapp.cs.cmu.edu/3e/labs.html</a></p>
</blockquote>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>需要安装 <code>valgrind</code>。可以参考文章<a target="_blank" rel="noopener" href="https://blog.csdn.net/frank_good/article/details/104052768">Valgrind centos</a>。</p>
<p>安装好以后执行<code>valgrind --version</code>可以看到版本号。</p>
<h3 id="Cache-simulator"><a href="#Cache-simulator" class="headerlink" title="Cache simulator"></a>Cache simulator</h3><ul>
<li><code>cache simulator not a cache</code>。我们不是实现一个真正的缓存，只是实现一个模拟器。</li>
<li>不存储内容</li>
<li>不使用block offset</li>
<li>只计算命中数，不命中数和驱逐数(hit count, miss count,eviction count)</li>
<li>缓存模拟器需要在不同的s,b,E下运行。</li>
<li>使用LRU替换策略</li>
</ul>
<p>Hints</p>
<ul>
<li>使用二维数组 struct cache_line cache[S][E];</li>
<li>S &#x3D; 2^s</li>
<li>cache_line &#x2F;&#x2F;上面说了不需要block offset，所以可以忽略block的内容<ul>
<li>Valid bit</li>
<li>Tag</li>
<li>LRU counter</li>
</ul>
</li>
<li>通过getopt获取命令行输入<ul>
<li>返回-1表示没有输入了</li>
<li>通常在循环里面接收参数</li>
<li>需要包含#include &lt;unistd.h&gt;,#include &lt;getopt.h&gt;</li>
<li>通常使用switch来处理不同的输入</li>
<li>考虑如何处理无效输入</li>
<li>更多信息 man 3 getopt</li>
</ul>
</li>
<li>fscanf可以指定要读的流(scanf只能读标准输入流)，用来读取trace file<ul>
<li>参数<ul>
<li>一个流的指针</li>
<li>如何解析文件的信息的格式化字符串</li>
<li>其余部分是指向存储解析数据的变量的指针</li>
</ul>
</li>
<li>通常在循环里使用</li>
<li>当命中EOF或者没有匹配到格式化字符串的时候返回-1</li>
<li>更多信息 man fscanf</li>
</ul>
</li>
<li>Malloc&#x2F;free<ul>
<li>malloc分配数据到heap</li>
<li>记得 free 掉malloc的数据</li>
<li>不要 free 你没有分配的内存</li>
</ul>
</li>
</ul>
<p><img src="/../images/csapp/lab4/csapp-lab4-1.png" alt="lab4 getopt"></p>
<p><img src="/../images/csapp/lab4/csapp-lab4-2.png" alt="lab4 fscanf"></p>
<p>要求我们实现<code>csim.c</code>文件，给了一个示例<code>csim-ref</code>文件。</p>
<p>输入<code>./csim-ref -h</code>可以看到我们要实现的东西。</p>
<p><img src="/../images/csapp/lab4/csapp-lab4-3.png" alt="lab4 csim"></p>
<p>首先需要接受参数，参数有</p>
<ul>
<li>-h 输出帮助信息</li>
<li>-v 可选详细标志，根据示例程序来，就是输出 <code>L 10,1 miss</code>这些信息</li>
<li>-s [num] set index bit 数</li>
<li>-E [num] 每个set的行数</li>
<li>-b [num] block offset bit数</li>
<li>-t [file] Trace file文件路径</li>
</ul>
<p>根据上面的提示可以知道，通过<code>getopt</code>函数来接收参数，并通过switch来处理。读取文件则通过<code>fscanf</code>函数，来读取-t传的文件。</p>
<p>下面是<code>./traces/yi.trace</code>文件的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L 10,1</span><br><span class="line">M 20,1</span><br><span class="line">L 22,1</span><br><span class="line">S 18,1</span><br><span class="line">L 110,1</span><br><span class="line">L 210,1</span><br><span class="line">M 12,1</span><br></pre></td></tr></table></figure>

<ul>
<li>L 代表数据载入 </li>
<li>S 代表数据存储</li>
<li>M 代表数据修改，需要一次载入 + 一次存储</li>
<li>后面的10，20，22这些代表地址</li>
<li>最后的1代表操作内存访问的字节数</li>
</ul>
<p>完整代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cachelab.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="type">int</span> valid;</span><br><span class="line">        <span class="type">int</span> tag;</span><br><span class="line">        <span class="type">int</span> time_stamp;</span><br><span class="line">&#125; cache_line;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> timestamp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始匹配到合适的set 找到命中的cache，如果命中返回1,如果没有命中返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find_hit_cache</span><span class="params">(cache_line *cache_line,<span class="type">int</span> E,<span class="type">int</span> tag, <span class="type">int</span>*hits)</span> &#123;</span><br><span class="line">    <span class="type">int</span> isHit = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环set中的cache_line 找到是否有匹配tag &amp;&amp; valid</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache_line[i].valid == <span class="number">1</span> &amp;&amp; cache_line[i].tag == tag ) &#123;</span><br><span class="line">            <span class="comment">//hit</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hit \n&quot;</span>);</span><br><span class="line">            *hits = *hits + <span class="number">1</span>;</span><br><span class="line">            isHit = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//刷新时间</span></span><br><span class="line">            cache_line[i].time_stamp = timestamp;</span><br><span class="line">            <span class="keyword">return</span> isHit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isHit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到一个空的cache line放进去，找到了就返回1，没有找到就返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find_empty_cache</span><span class="params">(cache_line *cache_line,<span class="type">int</span> E,<span class="type">int</span> tag)</span> &#123;</span><br><span class="line">    <span class="type">int</span> have_empty_cache = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt; E; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache_line[i].valid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 空的</span></span><br><span class="line">            <span class="comment">// 把当前内存放入cache</span></span><br><span class="line">            cache_line[i].valid = <span class="number">1</span>;</span><br><span class="line">            cache_line[i].tag = tag;</span><br><span class="line">            cache_line[i].time_stamp = timestamp;</span><br><span class="line">            <span class="comment">// 找到了就不需要替换了</span></span><br><span class="line">            have_empty_cache = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> have_empty_cache;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> have_empty_cache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取要替换的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_eviction_index</span><span class="params">(cache_line *cache_line, <span class="type">int</span> E)</span> &#123;</span><br><span class="line">    <span class="type">int</span> max_time_stamp = timestamp;</span><br><span class="line">    <span class="type">int</span> eviction_index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt; E; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache_line[i].time_stamp &lt; max_time_stamp) &#123;</span><br><span class="line">            <span class="comment">//找到time_stamp最小的那个</span></span><br><span class="line">            max_time_stamp = cache_line[i].time_stamp;</span><br><span class="line">            eviction_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eviction_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LRU替换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LRU</span><span class="params">(cache_line *cache_line, <span class="type">int</span> E,<span class="type">int</span> tag)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取要替换的索引</span></span><br><span class="line">    <span class="type">int</span> eviction_index = get_eviction_index(cache_line, E);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 替换</span></span><br><span class="line">    cache_line[eviction_index].valid = <span class="number">1</span>;</span><br><span class="line">    cache_line[eviction_index].tag = tag;</span><br><span class="line">    cache_line[eviction_index].time_stamp = timestamp; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// L和S操作，M就调用两次这个</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">load_and_store</span><span class="params">(<span class="type">unsigned</span> address,<span class="type">int</span> b,<span class="type">int</span> s,<span class="type">int</span> u_max,<span class="type">int</span> E,cache_line **cache, <span class="type">int</span> *hits,<span class="type">int</span> *misses,<span class="type">int</span> *evications)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取set index block offset tag</span></span><br><span class="line">    <span class="type">int</span> set_index,tag;</span><br><span class="line">    set_index = (address &gt;&gt; b) &amp; u_max;</span><br><span class="line">    tag = (address &gt;&gt; b) &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始匹配到合适的set 找到命中的cache，如果命中返回1,如果没有命中返回0</span></span><br><span class="line">    <span class="type">int</span> isHit = find_hit_cache(cache[set_index], E, tag, hits);</span><br><span class="line">    <span class="keyword">if</span> (isHit == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// miss</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;miss \n&quot;</span>);</span><br><span class="line">        *misses = *misses + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 找到一个空的cache line放进去，找到了就返回1，没有找到就返回0</span></span><br><span class="line">        <span class="type">int</span> have_empty_cache = find_empty_cache(cache[set_index], E, tag);</span><br><span class="line">        <span class="comment">// 如果没有找到空的cache,就需要LRU替换</span></span><br><span class="line">        <span class="keyword">if</span> (have_empty_cache == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;evictions \n&quot;</span>);</span><br><span class="line">            *evications = *evications + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//LRU替换</span></span><br><span class="line">            LRU(cache[set_index], E, tag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新全局时间戳</span></span><br><span class="line">    timestamp++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 接受参数 getopt</span></span><br><span class="line">    <span class="type">int</span> opt,v,s,E,b,S,B;</span><br><span class="line">    <span class="comment">// 文件</span></span><br><span class="line">    FILE        *       pFile;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">-1</span> != (opt = getopt(argc, argv, <span class="string">&quot;h?v?s:E:b:t:&quot;</span>)))&#123;</span><br><span class="line">        <span class="comment">// opt is h,v,s,E,b,t的ASCII码值</span></span><br><span class="line">        <span class="comment">// 通过switch对不同的参数进行不同的处理</span></span><br><span class="line">        <span class="keyword">switch</span>(opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;./csim: Missing required command line argument \n Usage: ./csim-ref [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt; \n Options: \n -h         Print this help message. \n -v         Optional verbose flag. \n -s &lt;num&gt;   Number of set index bits. \n -E &lt;num&gt;   Number of lines per set. \n -b &lt;num&gt;   Number of block offset bits. \n -t &lt;file&gt;  Trace file. \n\n Examples: \n ./csim -s 4 -E 1 -b 4 -t traces/yi.trace \n ./csim -v -s 8 -E 2 -b 4 -t traces/yi.trace \n&quot;</span>);</span><br><span class="line">                <span class="comment">// h参数输出帮助内容</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">                <span class="comment">// v参数输出详细信息</span></span><br><span class="line">                v = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;v:%d \n&quot;</span>,v);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                <span class="comment">// S is set 2^s 的数量</span></span><br><span class="line">                <span class="comment">// s is Number of set index bits</span></span><br><span class="line">                s = atoi(optarg);</span><br><span class="line">                S = <span class="number">1</span> &lt;&lt; s;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;s:%d, S:%d \n&quot;</span>,s,S);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">                <span class="comment">// E is cache line 的数量</span></span><br><span class="line">                <span class="comment">// Number of lines per set</span></span><br><span class="line">                E = atoi(optarg);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;E:%d \n&quot;</span>,E);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                <span class="comment">// B is block data 的字节</span></span><br><span class="line">                <span class="comment">// b is Number of block offset bits</span></span><br><span class="line">                b = atoi(optarg);</span><br><span class="line">                B = <span class="number">1</span> &lt;&lt; b;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;b:%d, B:%d \n&quot;</span>,b,B);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">                <span class="comment">// t is Trace file</span></span><br><span class="line">                <span class="comment">// 读取文件</span></span><br><span class="line">                <span class="comment">//t = atoi(optarg);</span></span><br><span class="line">                pFile   =       fopen(optarg,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;t:%s, file:%p \n&quot;</span>,optarg,pFile);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;非法参数 \n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="number">0</span> || E == <span class="number">0</span> || b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cache存储</span></span><br><span class="line">    cache_line **cache = (cache_line **)<span class="built_in">malloc</span>(S * <span class="keyword">sizeof</span>(cache_line *));</span><br><span class="line">    <span class="keyword">if</span> (cache == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败 \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++) &#123;</span><br><span class="line">        cache[i] = (cache_line *)<span class="built_in">malloc</span>(E * <span class="keyword">sizeof</span>(cache_line));</span><br><span class="line">        <span class="keyword">if</span>(cache[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败，开始回滚 \n&quot;</span>);</span><br><span class="line">                <span class="comment">// 在这里需要释放已分配的内存，然后退出</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="built_in">free</span>(cache[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(cache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> u_max = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        u_max = (u_max &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">    <span class="type">char</span>        identifier;</span><br><span class="line">    <span class="type">unsigned</span>    address;</span><br><span class="line">    <span class="type">int</span>         size;</span><br><span class="line">    <span class="type">int</span> hits,misses,evictions;</span><br><span class="line"><span class="comment">//      Reading lines   like    &quot;       M       20,1&quot;   or      &quot;L      19,3&quot;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(pFile,<span class="string">&quot; %c %x,%d&quot;</span>,&amp;identifier,&amp;address,&amp;size)&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//      Do      stuff</span></span><br><span class="line">        <span class="comment">// 开始计算 hits,misses,evictions, hits:0 misses:0 evictions:0</span></span><br><span class="line">        <span class="comment">//printf(&quot;identifier %c, addr:%x, size:%d \n&quot;,identifier,address,size);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据identifier来判断动作L load S store M = 一次L 一次S</span></span><br><span class="line">        <span class="keyword">if</span> (identifier == <span class="string">&#x27;L&#x27;</span> || identifier == <span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;identifier %c, addr:%x, size:%d \n&quot;</span>,identifier,address,size);</span><br><span class="line">            load_and_store(address,b,s,u_max,E,cache,&amp;hits,&amp;misses,&amp;evictions);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (identifier == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 一次L 一次S</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;identifier %c, addr:%x, size:%d \n&quot;</span>,identifier,address,size);</span><br><span class="line">            load_and_store(address,b,s,u_max,E,cache,&amp;hits,&amp;misses,&amp;evictions);</span><br><span class="line">            load_and_store(address,b,s,u_max,E,cache,&amp;hits,&amp;misses,&amp;evictions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fclose(pFile);  <span class="comment">//remember      to      close   file    when    done</span></span><br><span class="line">    printSummary(hits, misses, evictions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放数组内存</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; S; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(cache[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cache);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Efficient-Matrix-Transpose"><a href="#Efficient-Matrix-Transpose" class="headerlink" title="Efficient    Matrix    Transpose"></a>Efficient    Matrix    Transpose</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FShellLab.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FShellLab.html" class="post-title-link" itemprop="url">深入理解计算机系统CacheLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-11 10:12:47" itemprop="dateCreated datePublished" datetime="2023-07-11T10:12:47+08:00">2023-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/csapp/" itemprop="url" rel="index"><span itemprop="name">csapp</span></a>
                </span>
            </span>

          
            <span id="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FShellLab.html" class="post-meta-item leancloud_visitors" data-flag-title="深入理解计算机系统CacheLab" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FShellLab.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FShellLab.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Shell-Lab"><a href="#Shell-Lab" class="headerlink" title="Shell Lab"></a>Shell Lab</h1><p>shell lab shell实验</p>
<h3 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h3><p>从CSAPP上面下载对应的lab代码</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/labs.html">http://csapp.cs.cmu.edu/3e/labs.html</a></p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Thepatter"
      src="/images/header.jpeg">
  <p class="site-author-name" itemprop="name">Thepatter</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">195</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">82</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Thepatterraining" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Thepatterraining" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ztzhoutao041@163.com" title="E-Mail → mailto:ztzhoutao041@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://blog.csdn.net/Thepatterraining" title="CSDN → http:&#x2F;&#x2F;blog.csdn.net&#x2F;Thepatterraining" rel="noopener" target="_blank"><i class="fa fa-fw fa-CSDN"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Thepatter</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"RWllimOI5okO7WFTUmJ4EeeD-gzGzoHsz","app_key":"hXeefwCw8aDKTJ1Xqye7fLYb","security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'RWllimOI5okO7WFTUmJ4EeeD-gzGzoHsz',
      appKey     : 'hXeefwCw8aDKTJ1Xqye7fLYb',
      placeholder: "给我的文章加点评论吧~",
      avatar     : 'mp',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
