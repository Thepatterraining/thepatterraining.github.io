<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="YwTcBpc08sCpJAE8mKZglCGHjZc1BiK9UUagC8ldlaA">
  <meta name="msvalidate.01" content="true">
  <meta name="yandex-verification" content="true">
  <meta name="baidu-site-verification" content="3PbJKzlOf0">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"thepatterraining.github.io","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="dream">
<meta property="og:url" content="https://thepatterraining.github.io/page/3/index.html">
<meta property="og:site_name" content="dream">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Thepatter">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://thepatterraining.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>dream</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="dream" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dream</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个菜鸟程序员的成长历程</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/CMU15445%E7%AC%94%E8%AE%B0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/CMU15445%E7%AC%94%E8%AE%B0.html" class="post-title-link" itemprop="url">CMU15445笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-26 10:12:47" itemprop="dateCreated datePublished" datetime="2023-04-26T10:12:47+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMU15445/" itemprop="url" rel="index"><span itemprop="name">CMU15445</span></a>
                </span>
            </span>

          
            <span id="/CMU15445%E7%AC%94%E8%AE%B0.html" class="post-meta-item leancloud_visitors" data-flag-title="CMU15445笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/CMU15445%E7%AC%94%E8%AE%B0.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/CMU15445%E7%AC%94%E8%AE%B0.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CMU15445笔记"><a href="#CMU15445笔记" class="headerlink" title="CMU15445笔记"></a>CMU15445笔记</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>数据库就是管理文件的一个程序。将文件管理抽象出来不同的结构，如关系数据库，文档数据库，图数据库等。方便管理，使用，并能进行复杂的操作，如事务等。更加通用使任何语言都可以使用。对于多个进程并发修改一个文件，那么数据库可以提供更好的性能和解决方案。</p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><ul>
<li>关系模型：大多数数据库使用的</li>
<li>键值对模型：NOSql使用的，比如redis</li>
<li>图模型：NOSql使用的</li>
<li>文档模型：NOSql使用的，比如mongoDB</li>
<li>列存储模型</li>
<li>数组，向量模型：向量数据库，如Fassi</li>
<li>分组模型，网络模型，多值模型：已经很少使用的模型</li>
</ul>
<h4 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h4><p>Ted Codd在1969年设计了关系模型。发表了<a target="_blank" rel="noopener" href="https://dl.acm.org/doi/pdf/10.1145/362384.362685">A relational model of data for large shared data banks</a></p>
<p>关系模型将物理层和逻辑层分离，当数据的内部表示发生变化时，甚至当外部表示的某些方面发生变化时，用户在终端和大多数应用程序上的活动应该不受影响。</p>
<p>关系模型提供了一种仅用数据的自然结构来描述数据的方法，因此，它为高级数据语言提供了一个基础，这种语言将一方面在程序之间产生最大的独立性，另一方面在机器表示和数据组织之间产生最大的独立性。另一个优点是，它为处理关系的可导出性、冗余性和一致性提供了坚实的基础。</p>
<p>仍然需要消除的三种主要数据依赖是：顺序依赖、索引依赖和访问路径依赖。</p>
<ul>
<li>顺序依赖：程序展示的顺序和文件内容的存储顺序并不一致，需要各自独立。</li>
<li>索引依赖：如果程序使用索引的时候，索引被删除那么程序将出错。</li>
<li>访问路径依赖：访问数据的时候依赖数据的物理结构。</li>
</ul>
<p><code>关系</code>指的是数学意义上的关系，对于给定集合S1,S2,S3…Sn，R是n个集合上的关系，如果它是n个元组的集合，每个元组的第一个元素来自S1,第二个来自S2，以此类推。我们称Sj是R上的第j个定义域。R的阶为n(degree n)，阶为1的时候称为一元关系，2的时候称为二元关系，阶为n称为n元关系。</p>
<p>关键原则：</p>
<ul>
<li>将数据存储在简单的数据结构(关系)中</li>
<li>物理存储留给DBMS实现</li>
<li>通过高级语言访问数据，DBMS确定最佳策略。</li>
</ul>
<p>结构采用关系。确保数据库内容满足完整性约束。程序通过接口来访问和修改数据库内容。</p>
<p>关系是无序的，n元关系就是n个列的表。一个元组是一行记录。</p>
<h2 id="高级SQL"><a href="#高级SQL" class="headerlink" title="高级SQL"></a>高级SQL</h2><p>PostegreSQL:由伯克利大学开发，是之前开发Ingres的人开发的。</p>
<p>IBM的DB2支持SQL,所以SQL成为了标准。</p>
<p>数据库支持SQL,最低要支持SQL-92标准。</p>
<p>下面的sql在postgreSQL中会报错，mysql中如果<code>sql_mode</code>是<code>ansi</code>也会报错，如果<code>sql_mode</code>是<code>traditional</code>就不会报错，而是会随机选一个cid展示出来。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(s.gpa), e.cid <span class="keyword">from</span> enrolled <span class="keyword">as</span> e,student <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">where</span> e.sid <span class="operator">=</span> s.sid;</span><br></pre></td></tr></table></figure>

<h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">大小写</th>
<th align="left">引号</th>
<th align="left">字符串拼接</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SQL-92</td>
<td align="left">敏感的</td>
<td align="left">单引号</td>
<td align="left">||</td>
</tr>
<tr>
<td align="left">PostgreSQL</td>
<td align="left">敏感的</td>
<td align="left">单引号</td>
<td align="left">+</td>
</tr>
<tr>
<td align="left">mysql</td>
<td align="left">不敏感的</td>
<td align="left">单引号&#x2F;双引号</td>
<td align="left">concat &#x2F; 空格</td>
</tr>
<tr>
<td align="left">SQLite</td>
<td align="left">敏感的</td>
<td align="left">单引号&#x2F;双引号</td>
<td align="left">+</td>
</tr>
<tr>
<td align="left">｜DB2</td>
<td align="left">敏感的</td>
<td align="left">单引号</td>
<td align="left">||</td>
</tr>
<tr>
<td align="left">Oracle</td>
<td align="left">敏感的</td>
<td align="left">单引号</td>
<td align="left">||</td>
</tr>
</tbody></table>
<h3 id="时间日期处理"><a href="#时间日期处理" class="headerlink" title="时间日期处理"></a>时间日期处理</h3><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">当前日期 NOW()</th>
<th align="left">当前日期 CURRENT_TIMESTAMP()</th>
<th align="left">当前日期 CURRENT_TIMESTAMP</th>
<th align="left">日期差值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PostgreSQL</td>
<td align="left">2023-04-26 14:27:01.790522+08</td>
<td align="left">不支持</td>
<td align="left">2023-04-26 14:27:32.280334+08</td>
<td align="left">select DATE(‘2018-08-29’) - DATE(‘2018-01-01’); 结果240</td>
</tr>
<tr>
<td align="left">mysql</td>
<td align="left">2023-04-26 14:28:36</td>
<td align="left">2023-04-26 14:28:44</td>
<td align="left">2023-04-26 14:28:56</td>
<td align="left">select DATEDIFF(DATE(“2018-08-29”),DATE(“2018-01-01”)); 结果240</td>
</tr>
<tr>
<td align="left">SQLite</td>
<td align="left">不支持</td>
<td align="left">不支持</td>
<td align="left">2023-04-26 06:30:47</td>
<td align="left">select CAST((julianday(‘2018-08-29’) - julianday(‘2018-01-01’)) as INT) as days; 结果 240</td>
</tr>
</tbody></table>
<h3 id="复制表数据"><a href="#复制表数据" class="headerlink" title="复制表数据"></a>复制表数据</h3><p>create table会创建表，insert into需要表已经存在。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student2 (</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student2(</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="获取id最大的一个学生数据"><a href="#获取id最大的一个学生数据" class="headerlink" title="获取id最大的一个学生数据"></a>获取id最大的一个学生数据</h3><p>下面的是错误做法，因为不知道id最大的name是谁，会报错，如果sql_mode&#x3D;tranditional，会执行成功，但是name是随机的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">MAX</span>(e.sid),s.name <span class="keyword">from</span> enrolled <span class="keyword">as</span> e,student <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">where</span> e.sid <span class="operator">=</span> s.sid</span><br></pre></td></tr></table></figure>
<p>下面的在postgresql和mysql都可以执行成功，并获取到id最大的name数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sid, name <span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sid <span class="keyword">in</span> (<span class="keyword">select</span> <span class="built_in">max</span>(sid) <span class="keyword">from</span> enrolled)</span><br></pre></td></tr></table></figure>

<p>下面的SQL在postgresql中可以执行成功，结果和上面的一样，而在mysql8中报错<code>This version of MySQL doesn&#39;t yet support &#39;LIMIT &amp; IN/ALL/ANY/SOME subquery&#39;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sid, name <span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sid <span class="keyword">in</span> (<span class="keyword">select</span> sid <span class="keyword">from</span> enrolled <span class="keyword">order</span> <span class="keyword">by</span> sid <span class="keyword">desc</span> limit <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="获取没有学生报名的课程"><a href="#获取没有学生报名的课程" class="headerlink" title="获取没有学生报名的课程"></a>获取没有学生报名的课程</h3><p>下面的sql在postgresql 和 mysql 中都可以得到正确的结果</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> course </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> enrolled <span class="keyword">where</span> course.cid <span class="operator">=</span> enrolled.cid);</span><br></pre></td></tr></table></figure>

<h3 id="window窗口"><a href="#window窗口" class="headerlink" title="window窗口"></a>window窗口</h3><p><code>ROW_NUMBER</code>和<code>RANK</code>都需要和<code>OVER</code>一起使用。</p>
<ul>
<li>ROW_NUMBER(): 显示当前行号</li>
<li>RANK() : 显示排序后的排名，如果没有排序，都是1</li>
<li>OVER()<ul>
<li>PARTITION BY 进行分组</li>
<li>GROUP BY 进行分组</li>
<li>ORDER BY 排序</li>
</ul>
</li>
</ul>
<p><img src="/../images/15445001.png" alt="001"></p>
<p><img src="/../images/15445002.png" alt="002"></p>
<p><img src="/../images/15445003.png" alt="003"></p>
<h4 id="获取每个课程中分数最高的学生信息"><a href="#获取每个课程中分数最高的学生信息" class="headerlink" title="获取每个课程中分数最高的学生信息"></a>获取每个课程中分数最高的学生信息</h4><p>下面的SQL，在postgresql中执行成功，mysql8执行报错。</p>
<p>首先查询所有课程信息，并按照课程分组，按照分数排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line"><span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cid <span class="keyword">ORDER</span> <span class="keyword">BY</span> grade <span class="keyword">ASC</span>)</span><br><span class="line"><span class="keyword">AS</span> rank <span class="keyword">FROM</span> enrolled</span><br></pre></td></tr></table></figure>

<p><img src="/../images/15445004.png" alt="004"></p>
<p>接着搜索上表中分数为1，也就是分数最高的学生。也就是每个课分数最高的学生信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line">    <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cid</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> grade <span class="keyword">ASC</span>)</span><br><span class="line">    <span class="keyword">AS</span> rank <span class="keyword">FROM</span> enrolled) <span class="keyword">AS</span> ranking</span><br><span class="line"><span class="keyword">WHERE</span> ranking.rank <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="/../images/15445005.png" alt="005"></p>
<h3 id="CTE-common-table-expressions"><a href="#CTE-common-table-expressions" class="headerlink" title="CTE(common table expressions)"></a>CTE(common table expressions)</h3><p>使用<code>CTE</code>实现获取每个课程中分数最高的学生信息。</p>
<p>通过<code>WITH</code>语句来声明一个临时表。表名<code>cteSource</code>，表的内容就是最的sid，通过<code>SELECT MAX(sid) FROM enrolled</code>查询出来的结果。字段名叫<code>maxId</code>。</p>
<p>然后在查询语句里面就可以连接<code>cteSource</code>表，然后通过sid &#x3D; cteSource.maxId 来获取到sid最大的用户信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> cteSource (maxId) <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(sid) <span class="keyword">FROM</span> enrolled</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> student, cteSource</span><br><span class="line"><span class="keyword">WHERE</span> student.sid <span class="operator">=</span> cteSource.maxId</span><br></pre></td></tr></table></figure>

<p>还有一些其他的用法，比如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> cte1 (col1) <span class="keyword">AS</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span></span><br><span class="line">),</span><br><span class="line">cte2 (col2) <span class="keyword">AS</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> cte1, cte2;</span><br></pre></td></tr></table></figure>

<h3 id="lateral-join"><a href="#lateral-join" class="headerlink" title="lateral join"></a>lateral join</h3><p>mysql目前还不支持该功能，postgreSQL和Sqlserver等支持。</p>
<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>页的三个概念</p>
<ol>
<li>硬件上的页面(通常是4KB)</li>
<li>操作系统上的页面(4KB,x64 2MB&#x2F;1GB)</li>
<li>数据库页面(512B-32KB)</li>
</ol>
<p>磁盘和内存通信是一页一页的，如果数据都在一页里，后续的访问请求就可以走内存了，要不然还的从磁盘获取。内存中可以获取bit数据。</p>
<p>系统设计目标：给应用程序一个错觉，能提供足够的内存将整个数据库存入内存中。<br>实现：谨慎的最小化每次从磁盘读取内容或运行查询时所带来的影响。<br>流程：</p>
<ul>
<li>查询执行器：向内存中的<code>buffer pool</code>请求查询内容。</li>
<li>buffer pool: 如果数据所在的页已经在buffer pool中，就直接返回。如果数据所在的页不在buffer pool中，就向磁盘中的<code>database file</code>请求。</li>
<li>database file: 有页目录，还有具体的页，数据存在页中，查询页目录找到对应的页返回给<code>buffer pool</code>。</li>
</ul>
<p><img src="/../images/15445006.png" alt="006"></p>
<p>上面的步骤操作系统本身就可以实现，比如使用<code>mmap</code>，但是操作系统是统一的动作，遇到一些问题不知道该如何处理，而DBMS则可以根据不同的情况做不同的处理，进行优化。像主流的<code>mysql</code>,<code>SqlServer</code>,<code>Oracle</code>都没有用<code>mmap</code>。<code>mongoDB</code>早期使用的<code>mmap</code>，后面也是用<code>WiredTiger</code>替换掉了<code>mmap</code>。</p>
<p>DBMS自己实现的话，主要关心的两个问题:</p>
<ol>
<li>如何表示磁盘上文件的数据</li>
<li>如何管理内存以及在硬盘间移动数据</li>
</ol>
<h3 id="如何表示磁盘上文件的数据"><a href="#如何表示磁盘上文件的数据" class="headerlink" title="如何表示磁盘上文件的数据"></a>如何表示磁盘上文件的数据</h3><p>数据库的数据最终以文件的形式放在磁盘中。通过文件读写将数据读写到文件中。文件有特定的格式，具体的内容有数据库进行解析然后展示在数据库中。这就是<code>storage manager</code> or <code>storage engine</code>。</p>
<p><code>storage manager</code>负责文件的读写工作。所有的文件（不管是一个或者多个）以 <code>page</code> 的形式存储，管理多个 <code>page</code> 组成的集合。</p>
<p>一个<code>page</code>就是一个固定大小的数据块。<code>page</code> 可以保存任何东西，<code>tupe</code>, <code>metadata</code>, <code>indexes</code>, <code>log</code>等等。每个<code>page</code>有唯一的ID,是<code>page ID</code>。</p>
<p>有些<code>page</code>要求是独立的，自包含的(self-contained)。比如<code>mysql的InnoDB</code>。因为这样的话一个表的元数据和本身的数据内容在一起，如果发生问题的话，可以找回元数据和数据。如果元数据和数据在不同的<code>page</code>中，如果发生问题导致元数据的<code>page</code>丢失，那么数据则恢复不了了。</p>
<p><code>indirection layer</code>记录page ID的相对位置，方便找到对应的偏移量。这样page目录就能找到对应的page。 </p>
<p>不同的DBMS对于文件在磁盘上的存储方式不一样，有下面几种</p>
<ul>
<li>堆存储</li>
<li>树存储</li>
<li>有序文件存储（ISAM）</li>
<li>hashing文件存储</li>
</ul>
<p>堆存储</p>
<ul>
<li>无序的，保存的顺序和存储的顺序无关。</li>
<li>需要读写page</li>
<li>遍历所有的page</li>
<li>需要元数据记录哪些是空闲的page,哪些是已经使用的page。</li>
<li>使用 <code>page directory</code> 方式来记录文件位置。</li>
</ul>
<p>page directory</p>
<ul>
<li>存储page ID和所在位置的关系</li>
<li>存储page的空闲空间信息</li>
</ul>
<p><img src="/../images/15445010.png" alt="010"></p>
<p>page header</p>
<ul>
<li>page 大小</li>
<li>checksum 校验和</li>
<li>DBMS版本信息</li>
<li>事务可见性</li>
<li>压缩信息</li>
</ul>
<h4 id="page-layout"><a href="#page-layout" class="headerlink" title="page layout"></a>page layout</h4><h5 id="tuple-oriented-storage"><a href="#tuple-oriented-storage" class="headerlink" title="tuple oriented storage"></a>tuple oriented storage</h5><p>一般想法，直接存储，并在后面追加，但是对于可变数据长度很难管理。</p>
<ul>
<li>记录page数，也就是page内部可插入的偏移量</li>
<li>一个一个tupe按照顺序存储</li>
</ul>
<p><img src="/../images/15445007.png" alt="007"></p>
<p>所以，page内部，通常不使用上面那种，而使用的是slotted pages</p>
<ul>
<li>slotted pages<ul>
<li>slot array 存储插槽信息的偏移量，通过他找到对应的tuple</li>
<li>支持可变长度的 tuple</li>
<li>但是会产生一些碎片空间，因为太小，tuple放不下。</li>
<li>压缩可以去除碎片空间，但是压缩的时候这个page就不能读写了。</li>
</ul>
</li>
</ul>
<p><img src="/../images/15445008.png" alt="008"></p>
<p><code>record ID</code>表示一个tuple的物理位置,不同的DBMS有不同的名称，来表示数据的唯一位置，比如<code>postgresql</code>的<code>ctid</code>,<code>oracle</code>的<code>rowid</code>。<code>ctid</code>由<code>page id</code>和<code>slot number</code>组成。</p>
<p><img src="/../images/15445009.png" alt="009"></p>
<p>插入新的tuple的时候</p>
<ol>
<li>检查page direactory,找到一个page里面有空的可用的slot</li>
<li>如果该page不在内存,就从磁盘上获取它，将它加载到内存</li>
<li>在page里面检查slot array，找到一个空的空间，将tuple插入</li>
</ol>
<p>更新tuple的时候</p>
<ol>
<li>检查page direactory,找到tuple对应的page</li>
<li>如果该page不在内存,就从磁盘上获取它，将它加载到内存</li>
<li>在page里面通过slot array获取tuple的偏移量</li>
<li>如果数据空间合适，那么直接覆盖该tuple，否则，将原来的tuple标记为已删除，并将新tuple插入其他page。</li>
</ol>
<p>因此更新的时候有一些问题</p>
<ul>
<li>page会产生碎片空间</li>
<li>更新的时候需要从磁盘获取整个page</li>
<li>更新多条数据的时候，可能多个tuple在多个page中，产生随机IO</li>
</ul>
<p>所以有些DBMS不能更新数据，只能增加数据，比如HDFS等</p>
<h5 id="Log-Structured-Storage"><a href="#Log-Structured-Storage" class="headerlink" title="Log Structured Storage"></a>Log Structured Storage</h5><p>比如HBase,ClickHouse,RocksDB,LevelDB都是这个方式。 </p>
<p>这种方式的一些问题：</p>
<ul>
<li>Write-Amplification:在该tuple的生命周期里面可能写入无数次磁盘，并一直在那里且不被需要。</li>
<li>Compaction is Expensive：</li>
</ul>
<h5 id="Index-Organized-Storage"><a href="#Index-Organized-Storage" class="headerlink" title="Index Organized Storage"></a>Index Organized Storage</h5><p>tuple</p>
<ul>
<li>header</li>
<li>列1</li>
<li>列2</li>
<li>列n</li>
</ul>
<h4 id="tupe-layout"><a href="#tupe-layout" class="headerlink" title="tupe layout"></a>tupe layout</h4><p>tuple就是一堆bit，DBMS解释他们的作用。里面包含</p>
<ul>
<li>header</li>
<li>data</li>
</ul>
<h5 id="data-layout"><a href="#data-layout" class="headerlink" title="data layout"></a>data layout</h5><p>table foo</p>
<ul>
<li>id int primary key</li>
<li>value bigint</li>
</ul>
<p><img src="/../images/15445011.png" alt="011"></p>
<h5 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h5><p>现代CPU是64位对齐，创建表以后，DBMS会自动的将数据进行对齐存储，不过，如果在创建表的时候考虑对齐，可以优化速度和存储空间。</p>
<p><img src="/../images/15445012.png" alt="012"></p>
<h5 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h5><p>可变长度的数据<code>varchar</code>,<code>varbinary</code>,<code>text</code>,<code>blob</code>,他们的长度存在header里面。</p>
<p>日期时间类型存储的是时间戳。</p>
<p>float&#x2F;real&#x2F;double: 是浮点数，cpu支持浮点数运算，优点是速度快，但是会精度缺失<br>decimal: 是定点数，运算速度慢，但是精度高。</p>
<p><img src="/../images/15445013.png" alt="013"></p>
<p>large values，应该避免这样，因为维护overflow page很麻烦。</p>
<ul>
<li>tuple中存储另外一个page页的指针，将具体数据存放到另外一个page页中。</li>
<li>postgresql中叫<code>toast</code>，如果数据大于2KB，就会放到toast中，tuple中只存储指针。</li>
<li>mysql中叫<code>overflow page</code>，如果数据大于1&#x2F;2的page大小，就会放进去，tuple中只存储指针。</li>
</ul>
<p>外部存储</p>
<ul>
<li>tuple中存储指向外部文件的指针或者文件地址。</li>
</ul>
<p>NULL存储</p>
<ul>
<li>行数据库通常是在Header里面增加bit map来判断是否是null</li>
<li>列数据库通常使用占位符来标识NULL</li>
<li>在每个属性前面增加bit来标识是否是NULL，这么做会破坏对齐，或增加存储空间，MySQL曾使用这个方法，后来抛弃了这个方法。</li>
<li>NULL &#x3D;&#x3D; NULL 是 NULL, NULL is NULL 是 true</li>
</ul>
<p>catalogs 用来存储数据库元信息，大多数数据库将这些信息存到一张表里面</p>
<ul>
<li>表，字段，索引，视图等</li>
<li>用户，权限，安全等</li>
<li>内部数据统计等</li>
<li>infomation schemal api 通过这个来获取catalogs信息<ul>
<li>mysql<ul>
<li>show tables 获取所有的表</li>
<li>describe table_name 获取表的信息</li>
</ul>
</li>
<li>postgresql<ul>
<li>\d or \d+ 获取所有的表</li>
<li>\d table_name 获取表信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="DATABASE-WORKLOADS"><a href="#DATABASE-WORKLOADS" class="headerlink" title="DATABASE WORKLOADS"></a>DATABASE WORKLOADS</h3><p>OLTP</p>
<ul>
<li>通常是业务侧使用的传统数据库，比如oracle,postgresql,mysql</li>
<li>小的业务多次执行，比如多个简单的插入，更新，查询</li>
</ul>
<p>OLAP</p>
<ul>
<li>通常是大数据，数据分析来使用，比如Hbase等，支持复杂的数据查询</li>
<li>OLAP位于OLTP的后方</li>
</ul>
<p>HTAP</p>
<ul>
<li>OLTP和OLAP的混合，两个都可以做</li>
</ul>
<p><img src="/../images/15445014.png" alt="014"></p>
<p>N-ary 模型</p>
<ul>
<li>行存储模型</li>
<li>page里面是按行存储的，每个tuple就是一行</li>
</ul>
<p>优点</p>
<ul>
<li>快速的insert,update,delete</li>
<li>查找的优势是数据都在一起</li>
<li>能在集群中使用 <code>index-oriented</code>物理存储方式</li>
</ul>
<p>缺点</p>
<ul>
<li>不适合扫描table中大部分<code>and/or</code>属性的子集</li>
<li>访问的内存局部性糟糕，查找数据的弊端是会加载一个page的时候会加载不需要的行数据</li>
<li>不适合压缩，因为一个page里面有不同的<code>value domains</code></li>
</ul>
<p>Decomposition 模型</p>
<ul>
<li>列存储模型</li>
<li>一个page里面是一列数据</li>
</ul>
<p>优点</p>
<ul>
<li>优势是查找的时候不会加载不需要的数据</li>
<li>更快的查询过程，因为有更好的局部性和<code>cached data</code>重用</li>
<li>更好的数据压缩</li>
</ul>
<p>缺点</p>
<ul>
<li>劣势是查找的数据不在一起，需要去各个page里面找。所以insert update delete也更慢。</li>
</ul>
<p>列存储查询的时候处理where子句以后需要找到对应的其他列在其他page中的位置，有两个方法，通常使用第一个方法，第二个方法并不好</p>
<ul>
<li>固定长度：每个page中的每个列的长度都固定，顺序也一样，这样通过where子句对应列的偏移量，就可以确定其余列的偏移量</li>
<li>内嵌tuple id: 每个值里面都加入对应的tuple id，根据tuple id查询其他列</li>
</ul>
<p>Partition Attributes Across(PAX) Storage 模型</p>
<ul>
<li>将行存储和列存储混合的模型</li>
<li>目标是保留列存储的快速处理和行存储的空间局部性优势（这里空间局部性优势指访问的数据在一起）</li>
<li>比如<a target="_blank" rel="noopener" href="https://orc.apache.org/">Apache ORC</a>,<a target="_blank" rel="noopener" href="https://arrow.apache.org/">Apache Arrow</a>, <a target="_blank" rel="noopener" href="https://parquet.apache.org/">Apache Parquet</a>.</li>
</ul>
<p>PAX 物理数据组织</p>
<ul>
<li>水平划分为<code>row groups</code>，即一些行数据的集合</li>
<li>在<code>row groups</code>里面垂直划分为<code>column chunks</code>，即列的集合，也就是列存储方式</li>
<li>每个<code>column chunks</code>下面可能还会有page</li>
</ul>
<p><img src="/../images/15445015.png" alt="015"></p>
<h3 id="数据库压缩"><a href="#数据库压缩" class="headerlink" title="数据库压缩"></a>数据库压缩</h3><p>目标1：必须产生固定长度的值<br>目标2：在查询期间尽可能推迟解压缩，你不希望先解压缩在查询，这样很占空间且影响速度<br>目标3：必须是无损方案</p>
<p>压缩粒度</p>
<ul>
<li>Block-level: 压缩同一张表的tuple</li>
<li>Tuple-level: 压缩整个tuple的内容（仅限行存储）</li>
<li>Attribute-level：压缩同一个tuple的多个属性或单个属性</li>
<li>Column-level：压缩存储于多个tuple中的一个或多个属性的多个值（仅限列存储）</li>
</ul>
<h4 id="mysql-innodb-压缩"><a href="#mysql-innodb-压缩" class="headerlink" title="mysql innodb 压缩"></a>mysql innodb 压缩</h4><p>innodb 在写入的时候可以不解压，但是读取的时候会先在buffer pool中解压在读取。因此Mysql innodb的压缩的好处是提升空间利用率，减少了磁盘IO,缺点是读取的时候需要解压，因此增加了这部分的时间和CPU功耗以及解压以后会占用更多的内存空间。<br>innodb 默认page 是 16KB,可以压缩到1&#x2F;2&#x2F;4&#x2F;8KB。</p>
<p><img src="/../images/15445016.png" alt="016"></p>
<h4 id="Column-level-压缩算法"><a href="#Column-level-压缩算法" class="headerlink" title="Column-level 压缩算法"></a>Column-level 压缩算法</h4><h5 id="run-length-encoding"><a href="#run-length-encoding" class="headerlink" title="run length encoding"></a>run length encoding</h5><p>将单个column中的相同值压缩成三元组，需要对列进行智能排序，以最大限度地提高压缩机会。</p>
<ul>
<li>属性的值</li>
<li>column segment的起始位置</li>
<li>值的数量</li>
</ul>
<p>比如下面的数据，将压缩成右边的数据，(Y,0,3)，代表值是Y，起始位置0,值的数量有3个。后面的压缩数据是一样的。这种压缩方法可以快速计算count的数量等。</p>
<p>如果你的值类型很少，且有序，那么将大大减少空间占用。</p>
<p><img src="/../images/15445017.png" alt="017"></p>
<h5 id="bit-packing"><a href="#bit-packing" class="headerlink" title="bit packing"></a>bit packing</h5><p>如果字段里面的值都比较小，但是column type很大，可以忽略掉不需要的bit，比如int是32 bit，但是里面的值都很小，用不了这么多，就可以忽略他们。</p>
<p><img src="/../images/15445018.png" alt="018"></p>
<h5 id="bit-map-encoding"><a href="#bit-map-encoding" class="headerlink" title="bit map encoding"></a>bit map encoding</h5><p>使用bit map来标识数据值，仅仅适用于值的类型比较少的。</p>
<p><img src="/../images/15445019.png" alt="019"></p>
<h5 id="delta-encoding"><a href="#delta-encoding" class="headerlink" title="delta encoding"></a>delta encoding</h5><p>找到一个基本的数据，以它为基础，进行压缩，+1，-1这种。再将其按照<code>run length encoding</code>的方式压缩，可以再次节省空间。</p>
<p><img src="/../images/15445020.png" alt="020"></p>
<h5 id="DICTIONARY-COMPRESSION"><a href="#DICTIONARY-COMPRESSION" class="headerlink" title="DICTIONARY COMPRESSION"></a>DICTIONARY COMPRESSION</h5><p>按照字典将数据进行映射，并存储，这样可以节省空间，如果在字典映射的时候还能先排序，那么还可以完成将<code>where like &#39;and%&#39;</code>转成<code>where between 10 and 20</code>。</p>
<p><img src="/../images/15445021.png" alt="021"></p>
<h2 id="buffer-pool-和内存管理"><a href="#buffer-pool-和内存管理" class="headerlink" title="buffer pool 和内存管理"></a>buffer pool 和内存管理</h2><p>时间管理</p>
<ul>
<li>将数据写入磁盘的何处</li>
<li>目标是经常被一起使用的pages放在磁盘中也是一起的地方。</li>
</ul>
<p>空间管理</p>
<ul>
<li>何时将pages读入内存，何时将pages写入磁盘</li>
<li>目标是最小化的解决必须从磁盘读取数据这个事</li>
</ul>
<p>frame</p>
<ul>
<li>buffer pool中的一块内存区域</li>
<li>相当于page里面的slot</li>
</ul>
<p>page table</p>
<ul>
<li>记录pages在当前buffer pool中的位置,通过page table 和 page id可以知道在哪个frame中。</li>
</ul>
<p><img src="/../images/15445022.png" alt="022"></p>
<p>page 里面记录一些元数据</p>
<ul>
<li>dirty flag: 记录是否被修改过，也就是常说的”脏数据标记”</li>
<li>引用计数器： 记录有多少线程在使用这个数据</li>
<li>访问追踪信息</li>
</ul>
<p>lock and latch</p>
<ul>
<li>lock在数据库中指high-level的东西，可以保护数据库，数据表，数据。保护数据库内容不受其他事务影响，在事务持续期间保持，可以回滚。</li>
<li>latch保护内部的东西，数据结构，内存区域。保护内部数据结构不受其他线程的影响，在操作期间保持，不需要可以回滚。</li>
</ul>
<p>buffer pool 使用 mmap的问题：</p>
<ul>
<li>事务安全：操作系统完全控制page的写入，刷新，有可能在一个事务没有完成的时候有些数据就已经写入磁盘了。</li>
<li>IO停顿：DBMS不知道哪些page在内存中，当读取不在内存中的时候触发page fault，操作系统才会从磁盘获取。</li>
<li>错误处理：任何访问都可能触发操作系统的中断信号<code>SIGBUS</code>，而整个DBMS都需要处理它。</li>
<li>性能问题</li>
</ul>
<p>全局策略</p>
<ul>
<li>针对所有的查询或者事务的策略</li>
</ul>
<p>局部策略</p>
<ul>
<li>针对单个查询或者事务的策略</li>
<li>可以对单个优化，虽然对全局可能不好</li>
</ul>
<h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><p>淘汰策略有几种算法</p>
<ul>
<li>LRU</li>
<li>Clock：Linux使用的，把所有的page放成一个圈，每个page有一个标志位，如果为0表示没有被使用过，1被使用过，淘汰的时候淘汰0的，再把1改成0.</li>
<li>LRUK：记录使用的次数k，达到次数才放到缓存里面，淘汰的时候比对两次的时间间隔，间隔长的认为是最近最少使用</li>
<li>PRIORITY HINTS</li>
</ul>
<h4 id="mysql-近似-LRU-k"><a href="#mysql-近似-LRU-k" class="headerlink" title="mysql 近似 LRU-k"></a>mysql 近似 LRU-k</h4><p>相当于K&#x3D;2。有一个LRU List，但是有两个指针，分别表示<code>old list</code>和<code>young list</code>。当数据第一次被访问的时候放到<code>old list</code>中，再次被访问的时候放到<code>young list</code>中。</p>
<p><img src="/../images/15445023.png" alt="023"></p>
<p>当访问 page1 的时候，需要淘汰掉<code>old list</code>中的page8，其实也是整个LRU中的最后一个元素。然后将page1插入<code>old list</code>。</p>
<p><img src="/../images/15445024.png" alt="024"></p>
<p>当再次访问 page1 的时候，将page1 插入<code>young list</code>。这个时候<code>young list</code>最后的元素也就进入了<code>old list</code>.</p>
<p><img src="/../images/15445025.png" alt="025"></p>
<h4 id="PRIORITY-HINTS"><a href="#PRIORITY-HINTS" class="headerlink" title="PRIORITY HINTS"></a>PRIORITY HINTS</h4><p>比如B+树的根节点具有最高的优先级，所以一直放在内存中。</p>
<p><img src="/../images/15445026.png" alt="026"></p>
<p>多buffer pool</p>
<ul>
<li>通过使用多个buffer pool可以根据不同的table放入不同的buffer pool进行不同的优化。也可以通过其他的策略使用多个buffer pool</li>
<li>由于有多个buffer pool,减少了锁争抢和锁等待的时间。</li>
<li>mysql中通过hash确定数据是否在buffer pool，然后通过取余确定在哪个buffer pool</li>
</ul>
<p>预取数据</p>
<ul>
<li>顺序扫描的时候预先把后面的page取到buffer pool中。这一步mmap也可以实现</li>
<li>索引扫描的时候预先把索引中需要用到的后面的page取到buffer pool中。这一步mmap实现不了，这也是数据库自己实现buffer pool的优势。</li>
</ul>
<p>扫描共享</p>
<ul>
<li>共享扫描到的page内容</li>
<li>如果查询1需要扫描page1,page2,page3,page4的内容并且已经扫描到了page3,这个时候page1已经扫描完了被从buffer pool中丢弃了</li>
<li>这时候有一个查询2也需要扫描所有的pages，如果从page1开始扫描，就会把page1再次读入buffer pool，但是这样是低效率的，所以可以先共享查询1的page数据，先扫描page3,然后page4，这时候查询1执行完毕，在回头扫描page1,page2。</li>
<li>mysql不支持</li>
</ul>
<p>buffer pool bypass</p>
<ul>
<li>单独开辟一个本地内存区域来用，而不是使用buffer pool</li>
<li>可以避免操作page table带来的开销（latch锁住的开销）</li>
<li>可以避免污染buffer pool</li>
<li>适合数据量不大的情况</li>
<li>mysql5.7不支持</li>
</ul>
<p>os page cache</p>
<ul>
<li>操作系统的文件缓存，当使用fopen,fread,fwrite的时候会先从操作系统缓存中读取文件内容。</li>
<li>只有postgresql使用了这个。</li>
<li>通过 direct IO可以不使用这个</li>
<li>使用它会导致有两个缓存，buffer pool 和 os page cache。不好控制。</li>
<li>fsync如果失败以后再次调用也不会生效，因为它会将dirty设置为false</li>
</ul>
<p>两种写出方案需要做权衡，取舍</p>
<ul>
<li>如果写出dirty flag的数据然后读取新数据，就会产生2次IO。通常会有一个定时任务线程去将dirty flag的数据写入磁盘，写入之前必须要先将操作日志写入磁盘。</li>
<li>如果直接读取新数据就只有1次IO，但是这样有可能把下次会用到的数据丢弃。</li>
</ul>
<h2 id="hash-table"><a href="#hash-table" class="headerlink" title="hash table"></a>hash table</h2><p>hash function</p>
<ul>
<li>最快的是facebook 的 xxhash</li>
</ul>
<p>hash schema</p>
<ul>
<li>liner probe hashing<ul>
<li>如果要插入的位置有值了，就往下扫描，扫描到空的位置插入</li>
<li>删除的时候可以增加一个<code>墓碑</code>标记，这样就知道这里是有数据的不是空，查找的时候就会继续往下扫描而不会是没找到</li>
<li>删除的时候还可以把后面的数据往前移动，但是这样有的数据就不再原来的位置了，就找不到了。因为只会往下扫描不会往上扫描</li>
</ul>
</li>
<li>robin hood hashing<ul>
<li>记录<code>距离数</code>，表示插入的位置和应该插入的位置的距离。从0开始。</li>
<li>插入的时候判断距离数，进行<code>劫富济贫</code>，如果你向下扫描到距离数为3的地方插入，而在距离数为2的地方的数据x，x的距离数比你小，比如是0，1.那么你就占据这里，你插入距离数为2的地方，而将x插入你下面，x的距离数会+1.</li>
<li>从整体来看，这个方法牺牲了插入的效率，将数据的距离数变得更加平均</li>
</ul>
</li>
<li>cuckoo hashing<ul>
<li>该方法使用两个或多个<code>hash table</code>来记录数据，对A进行两次hash，得出两个hash table中的插入位置，随机选择一个进行插入</li>
<li>如果选择的插入位置已经有数据了，就选择另一个插入</li>
<li>如果两个都有数据了，就占据一个，然后对这个位置上之前的数据B再次hash选择其余位置。</li>
</ul>
</li>
</ul>
<p>动态hash table</p>
<ul>
<li>chained hashing<ul>
<li>把所有相同hash的组成一个bucket链表，然后一直往后面增加</li>
<li>java的hash table默认就是这样的</li>
</ul>
</li>
<li>extendible hashing<ul>
<li>对 chained hashing 的扩展</li>
<li>有一个slot array，在slot array上有一个 counter, 如果counter &#x3D; 2，代表看hash以后的数字的前两个bit,slot array就有4个位置，分别是00,01,10,11</li>
<li>每个slot指向一个bucket</li>
<li>hash以后找到前两位对应的slot指向的bucket，将数据放进去，如果满了，放不下了就进行拆分</li>
<li>将slot array的counter扩容为3，看前3个bit，slot array变成了8个位置</li>
<li>只将这个满了的bucket拆分成2个，其余的不变，重新进行slot的映射</li>
<li>再次hash这个值，看前3个bit找到对应的slot,在找到对应的bucket，然后插入进去</li>
</ul>
</li>
<li>linear hashing<ul>
<li>对 extendible hashing 的扩展</li>
<li>去掉了 conter，因为他每次加1，都会扩容一倍</li>
<li>增加了<code>split point</code>，一开始指向0，然后每次<code>overflow</code>需要拆分的时候就拆分split point指向的那个bucket，然后slot array只扩容一个，这个时候出现第二个hash函数并将split point+1</li>
<li>查询的时候如果slot array的位置小于split point，就使用第二个hash函数，因为被拆分了</li>
<li>如果大于等于split point，就使用第一个hash函数</li>
</ul>
</li>
</ul>
<h2 id="tree-index"><a href="#tree-index" class="headerlink" title="tree index"></a>tree index</h2><ul>
<li>b tree(1971)</li>
<li>b+ tree (1973)</li>
<li>b* tree (1977)</li>
<li>b link tree (1981)</li>
</ul>
<p>b+ tree 删除和插入的复杂度都是<code>O(log n)</code>， b 是 <code>balance (平衡)</code>，paper: <code>the ubiquitous B-tree</code></p>
<p>B+ tree,保证每个节点都必须是半满的，对于存放在节点中的key数量来说，key数量至少为<code>M/2 - 1</code>个，M为树的高度，key的数量必须小于 <code>M - 1</code>,如果当删除数据以后导致key数量小于M&#x2F;2 - 1个，就会进行平衡，使他满足M&#x2F;2 - 1个。</p>
<blockquote>
<p>M&#x2F;2 - 1 ≤ key数量 ≤ M - 1</p>
</blockquote>
<p>如果一个中间节点有k个key,那你就会有k+1个非空孩子节点，也就是k+1个指向下方节点的指针。每个节点的内容是一个<code>指针</code>和一个<code>key</code></p>
<p>叶子节点之间有连接叶子节点的兄弟指针，这个想法来源于b link tree。每个节点的内容是一个<code>数据</code>和一个<code>key</code>，数据可以是一个<code>record id</code> 也可以是一个 <code>tuple</code></p>
<p>叶子节点的内容，通常key和value是分开存储的，因为搜索的时候并不需要加载value数据</p>
<ul>
<li>元数据<ul>
<li>isleaf 是否是叶子节点</li>
<li>slots 有多少空闲的slot</li>
<li>prev 前一个叶子节点的指针</li>
<li>next 后一个叶子节点的指针</li>
</ul>
</li>
<li>key数据</li>
<li>value数据</li>
</ul>
<p>b tree 和 b+ tree 的区别</p>
<ul>
<li>b tree的中间节点也可以存数据，所以key是不重复的</li>
<li>b+ tree的中间节点没有数据，所有数据都在叶子节点，所以key有可能既存在中间节点也存在叶子节点。会重复</li>
<li>b tree的性能在并行处理上更差，因为修改以后需要向上传播也需要向下传播修改，这个时候两边都要增加<code>latch</code></li>
<li>b+ tree的性能更好，因为只修改叶子节点，所以只需要向上传播，只需要增加一个<code>latch</code></li>
</ul>
<p>b+ tree 插入</p>
<ol>
<li>向下扫描，找到对应的叶子节点</li>
<li>如果可以插入就直接插入</li>
<li>如果不可以插入，那么从中间分开，变成两个叶子节点，并将中间的key传递给父节点，插入父节点。</li>
<li>如果父节点可以插入就直接插入并分出一个指针指向新的叶子节点</li>
<li>如果父节点不可以插入重复上述操作3</li>
</ol>
<p>b+ tree 删除</p>
<ol>
<li>向下扫描，找到对应的叶子节点，这个时候就会增加<code>latch</code>，因为不知道需不需要合并，操作以后才会释放</li>
<li>如果可以删除就直接删除</li>
<li>如果删除后导致key数量 &lt; <code>M/2 - 1</code>,那么就会出发合并，因为不满足key数量啦</li>
<li>进行合并的时候删除这个key，然后先查看左右的兄弟节点，是否能直接把数据插入过来，如果可以的话就掠夺一个key过来，然后向上传播</li>
<li>如果不能掠夺，那么就合并到兄弟节点，然后向上传播。</li>
</ol>
<p>b+ tree 标准填充容量大概是67% - 69%，对于一个大小是8kb的page来说，如果高度为4，大约能记录30 0000个键值对。</p>
<p>b+ tree的查找</p>
<ul>
<li>对于&lt;a,b,c&gt;,查找a&#x3D;5 and b&#x3D;3也是可以走索引的，但是hash索引就不行，有些数据库还支持b&#x3D;3的搜索走索引，比如oracle和sql server</li>
</ul>
<p>b+ tree的节点大小，机械硬盘的大小最好在1M,ssd的大小在10KB</p>
<blockquote>
<p>推荐书籍 Modern B-Tree Techniques</p>
</blockquote>
<p>对于非唯一索引</p>
<ul>
<li>重复存储，需要注意两个相同的key存储在不同的page中</li>
<li>value list,key只存储一个，然后所有的value存储成value list</li>
</ul>
<p>节点内部的搜索</p>
<ul>
<li>线性搜索</li>
<li>二分搜索</li>
<li>interpolation<ul>
<li>通过数学计算出线性搜索的起点，提升搜索速度</li>
</ul>
</li>
</ul>
<p>优化方法</p>
<ul>
<li>前缀压缩<ul>
<li>比后缀截断用的更多</li>
<li>存储在page中的key,如果前缀一样的可以提取出来存储一次，然后剩余的数据在存储在key里面</li>
</ul>
</li>
<li>后缀截断<ul>
<li>存储在中间节点的，用来寻路的key，可以只存储前面的部分，如果后面的不需要可以截断</li>
<li>更新的时候需要进行维护</li>
</ul>
</li>
<li>批量插入<ul>
<li>如果已经有数据了再建立索引，这个时候不需要从头开始一个个建立，只需要先排序</li>
<li>然后建立所有的叶子节点</li>
<li>在一层层向上建立中间节点</li>
<li>非常普遍的方法，主流数据库都支持</li>
</ul>
</li>
<li>point willizeing<ul>
<li>将节点固定在内存中</li>
<li>对于page来说，直接存储page指针而不是page id，就不需要请求buffer pool了</li>
</ul>
</li>
</ul>
<p>b+ tree的重复key，通常使用增加<code>record id</code>的方式，这种方式影响更小。</p>
<ul>
<li>增加<code>record id</code>,<code>record id</code>是<code>page id</code> + <code>offset</code>用来确定tuple的位置。</li>
<li>垂直扩展叶子节点，将数据存在里面</li>
</ul>
<p>部分索引</p>
<ul>
<li>在创建索引的时候添加where条件，只有符合条件的才会进入索引。</li>
<li>查询的时候只有符合条件的才会走索引</li>
</ul>
<p>覆盖索引</p>
<ul>
<li>在创建索引的时候添加联合索引</li>
<li>查询的时候所需数据都在索引中，就不需要在找对应的tuple信息了。</li>
</ul>
<p>函数索引</p>
<ul>
<li>创建索引的时候添加函数信息，比如 MONTH(date), 只对月份创建索引</li>
<li>查询的时候 MONTH(date) 就会走索引了，而date就不会走索引了</li>
<li>如果创建的时候只创建 date 索引，那么查询的时候 MONTH(date) 就不会走索引</li>
</ul>
<p>trie index(前缀树)</p>
<ul>
<li>把每个单词建立成树，一层放一个字母</li>
</ul>
<p>radix tree</p>
<ul>
<li>trie index的升级版</li>
<li>对于trie index进行了横向的压缩和纵向的压缩</li>
</ul>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>Bloom filter</p>
<p>Counting Bloom filter</p>
<p>Cuckoo filter</p>
<p>Succinct Range Filter</p>
<h2 id="索引并发控制"><a href="#索引并发控制" class="headerlink" title="索引并发控制"></a>索引并发控制</h2><p>并发控制</p>
<ul>
<li>逻辑正确性<ul>
<li>获取id &#x3D; 5的数据，能正确返回id &#x3D; 5的数据</li>
</ul>
</li>
<li>物理正确性<ul>
<li>保护page指针指向正确的page数据，不会触发 segfualt</li>
</ul>
</li>
</ul>
<p>latch 模式</p>
<ul>
<li>读模式<ul>
<li>可以多个线程读取</li>
</ul>
</li>
<li>写模式<ul>
<li>只有一个线程可以写模式，这个时候其他线程不能读取也不能写入</li>
</ul>
</li>
</ul>
<p>latch</p>
<ul>
<li>blocking os mutex<ul>
<li>std::mutex m;</li>
<li>m.lock();</li>
<li>m.unlock();</li>
</ul>
</li>
<li>test and set spin latch<ul>
<li>std::atomic_flag latch</li>
<li>while(latch.test_and_set()){} &#x2F;&#x2F; 如果获取到锁就跳出循环</li>
</ul>
</li>
<li>read - write latch<ul>
<li>读锁，获取的时候线程数队列，等待队列，如果能获取就进入线程数队列，不能就进入等待队列</li>
<li>写锁，线程数队列，等待队列，如果能获取就进入线程队列，不能就进入等待队列</li>
<li>如果有一个写锁在等待队列，这个时候在获取读锁也放入等待队列，要不然一直读，写锁就获取不到了</li>
</ul>
</li>
</ul>
<p>latch crabbing&#x2F;coupling</p>
<ul>
<li>使用栈保存latchs</li>
<li>每个节点都需要一个latch</li>
<li>如果当前节点是<code>安全</code>的，就可以释放上层的所有latchs</li>
<li><code>安全</code>：指操作的时候不会触发<code>拆分</code>和<code>合并</code>。通常read latch都是安全的，write latch 插入的时候如果有足够的空间就是安全的，删除的时候删除以后不会合并就是安全的</li>
</ul>
<p>乐观锁</p>
<ul>
<li>乐观的认为不需要<code>合并</code>和<code>拆分</code>。</li>
<li>所有的操作都先获取read latch,如果发现需要<code>合并</code>和<code>拆分</code>，再次从头获取write latch来一遍</li>
<li>优点是所有操作都是read latch，可以更好的支持并发</li>
<li>缺点是遇到<code>合并</code>和<code>拆分</code>会再来一遍，而且如果连续的插入都需要合并，就会退化成每个都获取write latch。</li>
</ul>
<p>叶子节点扫描</p>
<ul>
<li>叶子节点的扫描可能会触发<code>死锁</code>，比如两个线程</li>
<li>线程1执行读取，读取到了叶子节点1</li>
<li>线程2执行写入，在叶子节点2处获取了write latch</li>
<li>这个时候线程1在叶子节点1里面没有找到数据，所以要扫描叶子节点2，但是获取read latch的时候卡主了，需要等待</li>
<li>而线程2有可能也需要访问叶子节点1，同样等待，产生死锁</li>
<li>这个时候可以设置等待时间，超过等待时间则<code>自杀</code>，然后重头再来，假如线程1自杀，然后再来一遍，这个时候线程2就可以获取到latch，然后执行下去了</li>
</ul>
<p>overflow处理</p>
<ul>
<li>来源于b link tree的优化</li>
<li>当需要拆分的时候，先拆分叶子节点，这个时候不向<code>父结点</code>传播，因为修改父结点需要从头开始获取write latch。</li>
<li>这个时候标记父结点需要插入一个key</li>
<li>等待下一个修改操作到父结点的时候，获取write latch，然后执行这个插入操作。</li>
</ul>
<h2 id="排序和聚合"><a href="#排序和聚合" class="headerlink" title="排序和聚合"></a>排序和聚合</h2><p>排序的好处</p>
<ul>
<li>有序的数据创建索引的时候可以快速的先创建叶子节点，在创建父结点</li>
<li>有序的数据在<code>order by</code>分组的时候可以更快的分组</li>
<li>有序的数据在<code>distinct</code>去重的时候可以更快的去重</li>
</ul>
<p>排序算法</p>
<ul>
<li>在内存中<ul>
<li>可以使用各种算法</li>
<li>但是有的数据内存放不下，就需要在磁盘上排序</li>
<li>需要先知道<code>可以用内存的大小</code>，这样就知道该内存排序还是磁盘排序</li>
</ul>
</li>
<li>在磁盘上<ul>
<li>快排会产生更多的随机IO,会更慢</li>
<li>使用<code>归并排序</code>更好，分成多个<code>runs</code>,对每个run排序，然后在通过<code>二路归并</code>生成总的排序，这可以减少随机IO</li>
<li>外部归并排序，需要3个<code>buffer pool</code>，2个用来排序run，1个用来二路归并。 </li>
<li>次数：1 + log(n)</li>
<li>总的IO数: 2N * (# of passes)</li>
<li>可以通过<code>预取</code>来优化，当对page排序的时候，另外一个线程先取出下次要排序的page。</li>
</ul>
</li>
</ul>
<p>聚簇索引</p>
<ul>
<li>排序的字段如果建立了聚簇索引，就不需要在排序了，直接可以走聚簇索引拿到排序好的数据</li>
</ul>
<h3 id="top-N-heap-sort"><a href="#top-N-heap-sort" class="headerlink" title="top-N heap sort"></a>top-N heap sort</h3><p>比如下面的sql</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">ASC</span></span><br><span class="line">limit <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>那么首先创建一个大小为2的有序数组或优先级队列之类的。假设我们的数据是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;id:3, name: xxx&#125;, &#123;id:4, name:xxx&#125;, &#123;id:5, name:xxx&#125;, &#123;id:2, name:xxx&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候优先级队列是空的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>然后扫描id为3的数据，放入优先级队列，再扫描id为4的数据，放入优先级队列。这个时候队列数据是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;id:3, name: xxx&#125;, &#123;id:4, name:xxx&#125;</span><br></pre></td></tr></table></figure>

<p>接下来扫描id5的数据，放不进优先级队列，因为id大，最后扫描id2的数据，放入优先级队列，队列就排好序了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;id:2, name:xxx&#125;,&#123;id:3, name: xxx&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/15445027.png" alt="027"></p>
<h3 id="external-merge-sort"><a href="#external-merge-sort" class="headerlink" title="external merge sort"></a>external merge sort</h3><p>当数据太大，无法放在内存中的时候，需要借助外部的文件来进行排序</p>
<ul>
<li>先排序小块的数据，然后写入文件</li>
<li>在将文件的内容合并</li>
</ul>
<p>early materialization</p>
<ul>
<li>将数据放在排序的数据里面，排序以后可以直接返回数据，行数据库一般用这个</li>
</ul>
<p>late materialization</p>
<ul>
<li>排序的数据里存的是tuple id or record id, 排序以后再根据id查询数据返回</li>
</ul>
<p><img src="/../images/15445028.png" alt="028"></p>
<p><img src="/../images/15445029.png" alt="029"></p>
<p>优化方法</p>
<ul>
<li>增加buffer pool在排序中可用的内存，当一个输出page进行写入IO的时候，CPU处理另一个输出page。</li>
<li>多线程，一个线程进行page排序，另外一个线程进行二路归并。</li>
</ul>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>两个实现方法</p>
<ul>
<li>排序</li>
<li>哈希，通常哈希更好，因为都在内存中</li>
</ul>
<blockquote>
<p>group by 和 distinct 本身执行的时候也是需要排序的</p>
</blockquote>
<p>hash</p>
<ol>
<li>分区<ul>
<li>可以顺序扫描每个page</li>
<li>对于每个page的key进行hash，然后分区，hash相同的说明key相同，分到一个区里面</li>
<li>这个时候不管distinct还是group by都可以方便的执行了</li>
</ul>
</li>
<li>重新哈希<ul>
<li>对于分区以后的数据再次进行hash</li>
<li>再次hash的数据放入一个临时的hash table</li>
<li>处理完一个临时的hash table就把结果写入结果集</li>
</ul>
</li>
</ol>
<p>排序的聚合实现，以distinct为例：</p>
<ol>
<li>先执行where条件筛选出符合的<code>tuple</code></li>
<li>再次根据列筛选出符合的列</li>
<li>对于需要排序的列进行排序</li>
<li>顺序扫描排序结果，实现去重，并生成最终结果</li>
</ol>
<p>哈希的聚合实现，以distinct为例：</p>
<ol>
<li>先执行where条件筛选出符合的<code>tuple</code></li>
<li>再次根据列筛选出符合的列</li>
<li>对于需要排序的列进行hash，先分区，再重新哈希。</li>
<li>重新哈希的时候生成最终结果。</li>
</ol>
<p>重新哈希的时候</p>
<ul>
<li>avg的话，需要再临时hash table里面存储key的数量和要求平均数的总数。在生成最终结果的时候进行计算平均数</li>
<li>min的话，临时hash table里面存入最小数，生成最终结果直接取</li>
<li>max同上</li>
<li>sum同上</li>
<li>count同上</li>
</ul>
<h2 id="join算法"><a href="#join算法" class="headerlink" title="join算法"></a>join算法</h2><p>join输出：数据</p>
<ul>
<li>在join的时候把两张表的数据全部输出给下一个处理器，这包括了表的所有字段</li>
<li>好处是，接下来的处理不需要再拿其他字段了，所有字段都有了</li>
<li>坏处是，Join的时候数据量很大，因为有所有字段</li>
<li>可以进行优化，在join的时候只获取需要的字段</li>
</ul>
<p>join输出：record id</p>
<ul>
<li>在join的时候，只获取on的字段和record id，然后需要其他字段的时候在通过 record id去获取，这个很适合列存储数据库</li>
<li>第一个使用的是<code>vertica</code>列存储数据库，不过现在已经不用了</li>
</ul>
<p>如何判断两个join算法的好坏？</p>
<ul>
<li>通过IO来计算</li>
<li>假设左表R有M个page,m个tuple</li>
<li>右表S有N个page,n个tuple</li>
</ul>
<p>join算法</p>
<ul>
<li>Nested Loop Join<ul>
<li>simple&#x2F;stupid</li>
<li>block</li>
<li>index</li>
</ul>
</li>
<li>Sort-Merge Join</li>
<li>Hash Join<ul>
<li>simple</li>
<li>GRACE(Externally partitioned)</li>
<li>Hybird</li>
</ul>
</li>
</ul>
<p><img src="/../images/15445030.png" alt="030"></p>
<h3 id="Simple-Nested-Loop-Join"><a href="#Simple-Nested-Loop-Join" class="headerlink" title="Simple Nested Loop Join"></a>Simple Nested Loop Join</h3><ul>
<li>通过两层for循环，然后符合条件的进行输出</li>
<li>IO计算：因为外层循环要读取 M 个 page,循环的tuple 是 m,内存循环要读取N个page，所以内层循环的IO数是 m * N,总的IO：M + (m * N)</li>
<li>假设 M &#x3D; 1000, m &#x3D; 10 0000, N &#x3D; 500, n &#x3D; 40000, 总的IO &#x3D; 1000 + (10 0000 * 500) &#x3D; 5000 1000</li>
<li>假设 SSD 执行速度 0.1ms 一次IO，大概需要1.3个小时</li>
<li>如果N是左表，那么总IO &#x3D; 500 + (4000 * 1000) &#x3D; 400 0500,大概需要1.1个小时</li>
<li>所以如果左表是小表，性能更好</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Tuple r: R) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Tuple s: S) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.id == r.id) &#123;</span><br><span class="line">            <span class="comment">// 输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested Loop Join"></a>Block Nested Loop Join</h3><ul>
<li>对simple的优化，不在循环tuple，而是循环page，将page打包成block，然后循环block</li>
<li>这样的话对于内层循环来说IO就是 M * N，总的IO就是 M + (M * N)</li>
<li>假设 M &#x3D; 1000, m &#x3D; 10 0000, N &#x3D; 500, n &#x3D; 40000, 总的IO &#x3D; 1000 + (1000 * 500) &#x3D; 50 1000</li>
<li>假设 SSD 执行速度 0.1ms 一次IO，大概需要50s</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个看上去循环多了，不过因为预先读取了两个block才循环，所以循环是在内存中，IO次数少了</span></span><br><span class="line"><span class="keyword">for</span> (Block br: R) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Block bs: S) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Tuple r: br) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Tuple s: bs) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.id == r.id) &#123;</span><br><span class="line">                    <span class="comment">// 输出</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Block-Nested-Loop-Join优化"><a href="#Block-Nested-Loop-Join优化" class="headerlink" title="Block Nested Loop Join优化"></a>Block Nested Loop Join优化</h4><ul>
<li>假设buffer pool容量是B,可以先获取B - 2个左表的Block,剩下2个位置，一个是获取右表的 Block 的，一个是输出的。</li>
<li>这样的话总的IO次数：M + ([M&#x2F;(B-2)] * N), M&#x2F;(B - 2)向上取整</li>
<li>最好的情况是 B &gt; M + 2，代表一次性能获取所有的左表的Block</li>
<li>这样总的IO就变成 M + N</li>
<li>假设 M &#x3D; 1000, m &#x3D; 10 0000, N &#x3D; 500, n &#x3D; 40000, 总的IO &#x3D; 1000  + 500 &#x3D; 1500</li>
<li>假设 SSD 执行速度 0.1ms 一次IO，大概需要0.15s</li>
</ul>
<h3 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested Loop Join"></a>Index Nested Loop Join</h3><p>假设s.id有索引，那么就可以根据索引进行匹配，加快速度.</p>
<ul>
<li>总的成本将是<code>M + (m * C)</code> C是索引需要的时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Tuple r: R) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Tuple s: Index(r = s)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.id == r.id) &#123;</span><br><span class="line">            <span class="comment">// 输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Sort-Merge-Join"><a href="#Sort-Merge-Join" class="headerlink" title="Sort Merge Join"></a>Sort Merge Join</h3><ul>
<li>Sort：先对要join的字段进行排序</li>
<li>Merge: 用两个指针进行匹配，如果数据匹配就输出，因为数据已经排序好了，所以只需要扫描一次就行了</li>
<li>这样的话总IO就是 sort io + merge io, merge io &#x3D; M + N, sort io看具体的排序算法</li>
<li>最好的情况是要join的key本身已经是有序的了，那么只需要merge io &#x3D; M + N,比如有索引，比如查询的时候使用了order by</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sort R,S on join <span class="type">keys</span></span><br><span class="line"><span class="variable">cursorR</span> <span class="operator">=</span> RSorted, cursorS = Ssorted;</span><br><span class="line"><span class="keyword">while</span> (cursorR &amp;&amp; cursorS) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cursorR &gt; cursorS) &#123;</span><br><span class="line">        <span class="comment">// 相当于内层循环指向下一个</span></span><br><span class="line">        cursorS++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cursorR &lt; cursorS) &#123;</span><br><span class="line">        <span class="comment">// 相当于外层循环指向下一个</span></span><br><span class="line">        cursorR++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cursorR == cursorS) &#123;</span><br><span class="line">        <span class="comment">// 输出 &amp;&amp; 内层循环指向下一个</span></span><br><span class="line">        cursorS++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hash-Join"><a href="#Hash-Join" class="headerlink" title="Hash Join"></a>Hash Join</h3><ul>
<li>Build: 先对左表要join的key进行hash，构建一个hash table</li>
<li>probe: 在对右表要join的key进行hash, hash相同的会放入同一个 bucket,也就完成了匹配</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Tuple r: R) &#123;</span><br><span class="line">    insert <span class="title function_">hash</span><span class="params">(r)</span> into hash table ht</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Tuple s: S) &#123;</span><br><span class="line">    insert <span class="title function_">hash</span><span class="params">(s)</span> into hash tbale ht</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Hash Join优化</p>
<ul>
<li>可以添加 <code>布隆过滤器</code> 来优化，这样的话在probe阶段，对右表的key， hash以后先查询布隆过滤器，如果false，就不需要在放入hash table去匹配了</li>
<li>如果true在去hash table里面匹配数据完成输出</li>
</ul>
<p>Grace Hash Join</p>
<ul>
<li>在 hash join中，只构建一个hash table来存储左表数据，右表的hash完成直接匹配</li>
<li>Grace hash join中，构建两个hash table，然后进行 nested loop join</li>
<li>总的IO： 3(M + N),大约0.45s</li>
</ul>
<p>hash 几乎总是好的。<br>排序是好的情况有两种</p>
<ul>
<li>non-uniform数据，排序更好</li>
<li>对于需要排序的数据，比如order by,排序更好</li>
</ul>
<p><img src="/../images/15445031.png" alt="031"></p>
<h2 id="query-exec"><a href="#query-exec" class="headerlink" title="query exec"></a>query exec</h2><p>processing Method</p>
<ul>
<li>Iterator Model: 大多数数据库使用的</li>
<li>Materialization Model：Iterator Model的一个特定版本，用在内存型数据库</li>
<li>Vectorized&#x2F; Batch Model：Iterator Model差不多，要传入一大堆东西， 分析型用的多</li>
</ul>
<p>Iterator Model</p>
<ul>
<li>像java的stream， 流的方式执行</li>
<li>先构建执行树，上层的通过<code>next</code>方法调用下层的方法并接收返回值</li>
</ul>
<p><img src="/../images/15445032.png" alt="032"></p>
<p>Materalization Model</p>
<ul>
<li>去掉了<code>next</code>方法，使用了<code>output</code>方法，一次输出所有数据给上层</li>
</ul>
<p><img src="/../images/15445033.png" alt="033"></p>
<p>Vectorized Model</p>
<ul>
<li>使用<code>next</code>方法，但是一次性返回一堆 tuples, 数量取决于 Buffer pool 大小</li>
<li>使用OLAP，大多数的数仓使用这个</li>
</ul>
<p><img src="/../images/15445034.png" alt="034"></p>
<p>Access Method</p>
<ul>
<li>顺序扫描</li>
<li>索引扫描</li>
<li>多索引扫描</li>
</ul>
<p>顺序扫描的优化</p>
<p><img src="/../images/15445035.png" alt="035"></p>
<p>多索引扫描</p>
<ul>
<li>对多个索引同时扫描</li>
<li>将扫描结果取交集或并集等</li>
<li>例如 <a target="_blank" rel="noopener" href="https://www.ibm.com/docs/en/dspafz/5.1.0?topic=report-multiple-index-scans">DB2 Multi index scan</a>,<a target="_blank" rel="noopener" href="https://www.postgresql.org/message-id/12553.1135634231@sss.pgh.pa.us">PostgreSQL bitmap scan</a>,<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/index-merge-optimization.html">MySQL Index Merge scan</a></li>
</ul>
<p>Zone Maps</p>
<ul>
<li>通过在page上面增加一个元数据，存储min,max,avg,count,sum信息</li>
<li>当查询的时候比如where val &gt; 600,先查询 Zone Maps，如果发现max &lt; 600，那么就不用在扫描这个page了</li>
<li>缺点是插入，更新，删除的时候还需要更新Zone Maps信息，所以适用于 OLAP数据库</li>
</ul>
<p>late materialization</p>
<ul>
<li>已经不需要的字段就不在往上层传了</li>
</ul>
<p>Expression Evaulate</p>
<ul>
<li>先建立where条件的 Expression tree,中间节点是操作符，比如<code>=</code>,<code>&gt;</code>,<code>&lt;</code>,<code>and</code>,<code>or</code>等。子节点是两边的值</li>
<li>对于每个tuple执行这个表达式</li>
<li>好的数据库会对表达式进行优化，比如优化成常量，像where 1 &#x3D; 1优化成 trues</li>
</ul>
<p>Process Models</p>
<ul>
<li>Process per DBMS Worker</li>
<li>Process Model</li>
<li>Thread per DBMS Worker</li>
<li>Embedded DBMS</li>
</ul>
<p>Process per DBMS Worker</p>
<ul>
<li>每个进程是一个worker,负责执行任务</li>
<li>通过<code>共享内存</code>进行buffer pool的通信，要不然每个进程都会有一个buffer pool。</li>
<li>老得数据库大部分使用的这个，因为当时没有统一的线程API,像DB2,oracle,postgraSQL</li>
</ul>
<p>Process Model</p>
<ul>
<li>和 Process per DBMS Worker一样</li>
<li>但是增加了 worker pool，有多个worker进行调度处理</li>
<li>像DB2,postgraSQL（2015）</li>
</ul>
<p>Thread per DBMS Worker</p>
<ul>
<li>一个进程，多个线程执行，由数据库自己控制线程。</li>
<li>现在的数据库几乎都使用这种，像DB2, MSSQL, MySQL, Oracle(2014)</li>
</ul>
<p>scheduling</p>
<ul>
<li>将查询分解为多少个任务？</li>
<li>它使用多少个CPU核心？</li>
<li>哪个CPU执行哪个任务？</li>
<li>任务输出到哪里？</li>
</ul>
<p>Intra query parallelism</p>
<ul>
<li>Intra operator(水平)</li>
<li>Inter operator(垂直)</li>
<li>Bushy(上面两种的组合)</li>
</ul>
<p>Intra operator(水平)</p>
<ul>
<li>通过水平拆分数据，由多个线程执行，比如3个线程，一个线程处理一个page，以此类推</li>
<li>处理完成以后通过<code>exchange operator</code>来进行合并，拆分也是通过它。</li>
</ul>
<p><img src="/../images/15445036.png" alt="036"></p>
<p>Exchange operator</p>
<ul>
<li>Gather:从多个线程的结果合并成一个输出流，PostgreSQL用这个</li>
<li>Repartition: 重新组织多个输入流到多个输出流的数据，像group by，BigQuery用这个</li>
<li>Distribute: 拆分一个输入流到多个输出流</li>
</ul>
<p><img src="/../images/15445037.png" alt="037"></p>
<p>Inter operator(垂直)</p>
<ul>
<li>重叠的操作从一个阶段到下一个阶段的pipeline数据，没有具体化</li>
<li>workers同时执行多个operators从一个查询计划的不同部分</li>
<li>也需要用到exchange operator</li>
<li>Spark,Kafka常用这个</li>
</ul>
<p><img src="/../images/15445038.png" alt="038"></p>
<p>Bushy</p>
<p><img src="/../images/15445039.png" alt="039"></p>
<h2 id="查询计划"><a href="#查询计划" class="headerlink" title="查询计划"></a>查询计划</h2><p>假设有以下sql，其中Emp表有10000个records, 1000个pages, Dept表有500个records, 50个pages</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> ename <span class="keyword">from</span> Emp E <span class="keyword">join</span> Dept D <span class="keyword">on</span> E.did <span class="operator">=</span> D.did <span class="keyword">where</span> D.dname <span class="operator">=</span> <span class="string">&#x27;Toy&#x27;</span></span><br></pre></td></tr></table></figure>

<p>数据库将构建以下关系代数的树</p>
<p><img src="/../images/15445040.png" alt="040"></p>
<p>按照这个关系代数的树来执行的话，总共需要 2M的IO</p>
<p><img src="/../images/15445041.png" alt="041"></p>
<p>接下来将笛卡尔积的代数换成join的代数，就算使用Nested Loop Join，也能获得54K的IO</p>
<p><img src="/../images/15445042.png" alt="042"></p>
<p>如果将Join算法替换成<code>Sort-Merge Join</code>，则可以将IO降低到<code>7159</code></p>
<p><img src="/../images/15445043.png" alt="043"></p>
<p>这个算法是基于<code>Materialization Model</code>的，所以每次还要写入文件，再读取。如果优化成<code>Veectorization Model</code>，减少重复的写入和读取，可以达到3151的IO</p>
<p><img src="/../images/15445044.png" alt="044"></p>
<p>wraning:</p>
<ul>
<li>这非常难！</li>
<li>Andy对这部分知道的是最少得</li>
<li>如果搞好了，很挣钱</li>
</ul>
<p>查询结构</p>
<ul>
<li>SQL rewrite (可选)：重写sql语句，对sql语句进行优化</li>
<li>Parser: 解析SQL查询，构建语法树</li>
<li>Binder: 查询catalog信息，并将表名等信息替换成内部标识，生成<code>逻辑查询计划</code></li>
<li>Tree rewrite (可选)：重写树结构，包括关系代数等</li>
<li>Optimizer: 调用成本模型，预估成本，选择合适的执行计划，生成<code>物理执行计划</code></li>
</ul>
<p><img src="/../images/15445045.png" alt="045"></p>
<blockquote>
<p>生成物理执行计划的时候，可能有多个执行路径，在短时间内可能无法从全部的路径中选出最佳的。</p>
</blockquote>
<h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><blockquote>
<p>查询优化是很难的，有些数据库的查询优化做的很差，DB2曾引入机器学习做查询优化，效果并不好，被吐糟安装DB2要做的第一件事就是关掉这个功能</p>
</blockquote>
<p>查询优化</p>
<ul>
<li>静态规则&#x2F;条件触发<ul>
<li>根据静态的规则，或者触发了某一个条件来重写查询，移除低效率的东西</li>
<li>需要检查catalog查看信息，而不需要去检查数据</li>
</ul>
</li>
<li>成本原则<ul>
<li>使用模型预估查询成本</li>
<li>估计出多个查询计划，选择其中成本最低的一个</li>
</ul>
</li>
</ul>
<h4 id="静态规则-x2F-条件触发"><a href="#静态规则-x2F-条件触发" class="headerlink" title="静态规则&#x2F;条件触发"></a>静态规则&#x2F;条件触发</h4><p>关系代数等价</p>
<ul>
<li>一个查询语句可以用多个关系代数来表示</li>
<li>可以选择其中代价更小的那个关系代数</li>
<li>这个被叫做 <code>query rewriting</code> 属于上面的 <code>Tree rewrite</code>阶段</li>
<li>比如用join代替笛卡尔积</li>
</ul>
<p>predicate pushdown</p>
<ul>
<li>比如select a.name,b.code from a join b where a.name &#x3D; ‘abc’</li>
<li>可以先join在where，也可以先where 再 join</li>
<li>显然先where更好，把where放到join的下层执行</li>
<li>还有可以再where之后只获取需要的列，其余不需要的列就不再往上层传递了</li>
</ul>
<p>projection pushdown</p>
<ul>
<li>比如select a.name,b.code from a join b on a.id &#x3D; b.aid</li>
<li>可以在扫描a表的时候进行投影，获取id和name传到join节点处理，而不是全部字段传过去，b表同样</li>
</ul>
<p><img src="/../images/15445046.png" alt="046"></p>
<p>语句重写</p>
<ul>
<li>比如select * from a where 1 &#x3D; 0; 那么不会返回任何数据。</li>
<li>select * from a where 1 &#x3D; 1 会返回所有数据，重写成select * from a</li>
</ul>
<h4 id="成本原则"><a href="#成本原则" class="headerlink" title="成本原则"></a>成本原则</h4><blockquote>
<p>mongoDB没有使用成本预测模型，而是执行所有的查询计划，哪个最先返回就用哪个</p>
</blockquote>
<p>最初是IBM提出的。枚举不同的查询计划，并估算他们的成本,在检查完所有的计划或者超时后，选择其中成本最低的一个。</p>
<ul>
<li>single relation</li>
<li>multiple relation </li>
<li>nested sub-queries</li>
</ul>
<p>single relation</p>
<ul>
<li>单表是比较简单的，比如根据后面的statistics决定走哪个索引更好</li>
<li>可以顺序扫描 </li>
<li>可以二分搜索</li>
<li>可以走索引</li>
</ul>
<p>对于单表查询来说，一般会使用<code>启发式规则</code>，他来判断哪些where条件能筛掉更多的数据，就先进行哪个where。</p>
<p><code>sargable (search argument able)</code>：他会比较不同的索引，比如这个索引合适，那么就会使用它，比如id&#x3D;1的，那么就会使用主键索引</p>
<p>multiple relation </p>
<ul>
<li>有两种方法，第一种是自底向上</li>
<li>还有是自顶向下</li>
</ul>
<h5 id="system-R-优化"><a href="#system-R-优化" class="headerlink" title="system R 优化"></a>system R 优化</h5><ul>
<li>这是一个自底向上的multiple relation</li>
<li>将查询分成block并为每个block生成逻辑运算</li>
<li>为每个逻辑运算生成物理运算并实现它</li>
<li>组合所有的join算法和访问路径</li>
<li>生成一个left deep的树</li>
</ul>
<p>比如有下面的SQL,ALBUM.NAME 字段有索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ARTIST.NAME</span><br><span class="line"> <span class="keyword">FROM</span> ARTIST, APPEARS, ALBUM</span><br><span class="line"><span class="keyword">WHERE</span> ARTIST.ID<span class="operator">=</span>APPEARS.ARTIST_ID</span><br><span class="line"> <span class="keyword">AND</span> APPEARS.ALBUM_ID<span class="operator">=</span>ALBUM.ID</span><br><span class="line"> <span class="keyword">AND</span> ALBUM.NAME<span class="operator">=</span>&quot;Andy&#x27;s OG Remix&quot;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ARTIST.ID</span><br></pre></td></tr></table></figure>

<p>进行第一步，可以得到三个表的扫描方法</p>
<ul>
<li>ARTIST：顺序扫描</li>
<li>APPEARS：顺序扫描</li>
<li>ALBUM：索引扫描</li>
</ul>
<p>接下来组合不同的join算法，我们可以先连接ARTIST和APPEARS表，也可以先连接APPEARS和ALBUM表，或者ALBUM和ARTIST表，并且可以使用hash join 或者 merge join</p>
<p><img src="/../images/15445047.png" alt="047"></p>
<p>最终为每个可能选择成本最低的join</p>
<p><img src="/../images/15445048.png" alt="048"></p>
<p>接下来为每个可能去join其他表，来完成最终的三个表join，这个时候还是有hash join和merge join,选择最适合的join方法，就会产生三个路径</p>
<p><img src="/../images/15445049.png" alt="049"></p>
<p>在从这三个中选择出成本最低的一个路径作为最终的路径</p>
<p><img src="/../images/15445050.png" alt="050"></p>
<h5 id="自顶向下优化"><a href="#自顶向下优化" class="headerlink" title="自顶向下优化"></a>自顶向下优化</h5><p>首先生成逻辑节点，最底下是三个表，最上面是三个表join并且order by，中间是两个表join</p>
<p><img src="/../images/15445051.png" alt="051"></p>
<p>接下来先生成三个表的一个物理操作，因为需要order by，所以可以认为merge join更好。</p>
<p><img src="/../images/15445052.png" alt="052"></p>
<p>接下来两个表的物理操作，可以选择hash join或这merge join，因为要排序，可以认为merge join更好</p>
<p><img src="/../images/15445053.png" alt="053"></p>
<p>最后在探测其他的路径，比如最上层还可能有hash join，或者先hash join，在排序，但是这些都没有merge join的成本低，所以在探测到以后就可以Pass掉了</p>
<p><img src="/../images/15445054.png" alt="054"></p>
<h5 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h5><ul>
<li>重写去掉and&#x2F;or来把他们变成同一个层级</li>
</ul>
<p>比如以下SQL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> sailors <span class="keyword">AS</span> S</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line"> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> reserves <span class="keyword">AS</span> R</span><br><span class="line"> <span class="keyword">WHERE</span> S.sid <span class="operator">=</span> R.sid</span><br><span class="line"> <span class="keyword">AND</span> R.day <span class="operator">=</span> <span class="string">&#x27;2022-10-25&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>可以被重写为</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"> <span class="keyword">FROM</span> sailors <span class="keyword">AS</span> S, reserves <span class="keyword">AS</span> R</span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="operator">=</span> R.sid</span><br><span class="line"> <span class="keyword">AND</span> R.day <span class="operator">=</span> <span class="string">&#x27;2022-10-25&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>分解子查询并将结果存储在临时表中，比如使用CTE，避免每个tuple都需要执行子查询</li>
</ul>
<p>比如下面的SQL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sid, <span class="built_in">MIN</span>(R.day)</span><br><span class="line"> <span class="keyword">FROM</span> sailors S, reserves R, boats B</span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="operator">=</span> R.sid</span><br><span class="line"> <span class="keyword">AND</span> R.bid <span class="operator">=</span> B.bid</span><br><span class="line"> <span class="keyword">AND</span> B.color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span></span><br><span class="line"> <span class="keyword">AND</span> S.rating <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(S2.rating)</span><br><span class="line"> <span class="keyword">FROM</span> sailors S2)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> S.sid</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>可以将子查询提取出来变成</p>
<p><img src="/../images/15445055.png" alt="055"></p>
<p>catalog会记录一些成本信息，不同的DBMS有不同的更新策略，也可以手动更新,这被叫做<code>statistics</code></p>
<ul>
<li>PostgreSQL&#x2F;SQLite : ANALYZE</li>
<li>Oracle&#x2F; Mysql: ANALYZE TABLE</li>
<li>SQL server: UPDATE STATISTICS</li>
<li>DB2: RUNSTATS</li>
</ul>
<p>statistics: 维护着下面的信息</p>
<ul>
<li>counter: 表中的tuple数量</li>
<li>V(A,R): R表中的A字段的去重数量</li>
<li>SC(A,R): <code>选择基数SC</code> 是 counter &#x2F; V(A,R) 的值</li>
</ul>
<p>选择率：有了上面的数据，就可以计算出要查询的数据的分布比例了。这里就是求概率。</p>
<ul>
<li>比如查询主键 id &#x3D; 1的数据，当前有数据5条，那么counter &#x3D; 5,V(A,R) &#x3D; 5, SC(A,R) &#x3D; 1, 选择率 &#x3D; 1&#x2F;5</li>
<li>比如范围查询 id &gt; 2的数据，当前有数据5条，那么counter &#x3D; 5, V(A,R) &#x3D; 5, SC(A,R) &#x3D; 1, 选择率 &#x3D; (Max - A) &#x2F; (Max - Min) &#x3D; 5-2&#x2F;5-1 &#x3D; 3&#x2F;4,显然这事错误的预测，但是数据库就是这样</li>
<li>比如not查询 id &lt;&gt; 1的数据，当前有数据5条，那么选择率 &#x3D; 1 - (id &#x3D; 1的选择率) &#x3D; 1 - 1&#x2F;5 &#x3D; 4&#x2F;5</li>
<li>比如多个条件 and, 那么取交集，也就是 两个选择率 相乘 &#x3D; sel(AB),这种计算同样不太准确，比如有一个<code>汽车表</code>，有<code>make</code>字段代表生产商，<code>model</code>代表型号，我们知道model &#x3D; “帕萨特”，make 一定是 <code>大众</code>。按照我们的算法 假设make 有10个，选择率就是1&#x2F;10, model 100个，选择率就是 1&#x2F;100,总的选择率就是 1&#x2F;1000,但是帕萨特一定是大众的，所以真实选择率其实是1&#x2F;100。有些数据库可以设置字段关联来解决这个问题，比如oracle等，mysql和postgresql不行。</li>
<li>比如多个条件 or, 那么取并集，也就是两个选择率相加 &#x3D; sel(A) + sel(B) - sel(AB)</li>
</ul>
<p><img src="/../images/15445056.png" alt="056"></p>
<p>直方图的存储，由于存储所有信息的直方图可能很占空间，可以选择稀疏存储，合并一些数据，这样会牺牲一些准确率，但是节省空间。</p>
<p>除了直方图以外，有些数据库还会使用抽样检查，花费一些时间进行抽样，然后根据样本来进行预测选择率。</p>
<h2 id="并发控制原理"><a href="#并发控制原理" class="headerlink" title="并发控制原理"></a>并发控制原理</h2><p>原子性：事务的每个操作都是原子的，要么全成功，要么全失败，通过undo redo log实现<br>一致性：保证事务执行前和执行后是一致的，中间可以临时不一致，但最终要一致。通过raft等共识协议实现<br>隔离性：保证事务的隔离性，每个事务都是独立运行的，并发的时候通过<code>并发控制协议</code>来保证交错执行，通过latch保证正确性。通过并发控制实现<br>持久性：事务提交后数据持久保存了，通过undo redo log实现</p>
<p>当转账的时候，事务被突然的中止，或者断电，该怎么做？</p>
<ul>
<li>Logging</li>
<li>shadow paging</li>
</ul>
<p>Logging</p>
<ul>
<li>记录所有的操作，使得事务中止或者故障后可以undo 操作。</li>
<li>在磁盘和内存中维护 undo records</li>
<li>就像飞机上的黑盒子一样</li>
</ul>
<p>shadow paging</p>
<ul>
<li>将数据复制到一个副本中进行事务更新，如果成功了，将副本作为新的数据库，如果没成功也不影响当前的数据库</li>
<li>起源于System R</li>
<li>CouchDB和LMDB使用这个方法</li>
</ul>
<p>并发控制协议：</p>
<ul>
<li>悲观的：两阶段提交</li>
<li>乐观的：时间戳</li>
</ul>
<p>顺序执行：</p>
<ul>
<li>顺序执行每个事务，保证事务的最终一致性</li>
</ul>
<p>交错执行：</p>
<ul>
<li>如果能达到顺序执行的结果，那么就是正确的执行 schedle</li>
</ul>
<p>假设a,b账户都有1000，那么经过t1事务和t2事务执行以后，总的结果应该不变，对于数据库来说，哪个事务先执行都可以，如果想控制事务执行顺序，应该由应用层控制。</p>
<p><img src="/../images/15445057.png" alt="057"></p>
<p>如果交错执行的结果和顺序执行的结果不一样，就是错误的</p>
<p><img src="/../images/15445058.png" alt="058"></p>
<p>总共会出现三种冲突</p>
<ul>
<li>读写冲突</li>
<li>写读冲突</li>
<li>写写冲突</li>
</ul>
<p>读写冲突（不可重复读）：当读第一次的时候，值被其他事务改变了，再次读的时候，值就和第一次读的时候不一样了</p>
<p><img src="/../images/15445059.png" alt="059"></p>
<p>写读冲突（读未提交或脏读）：A事务读取后，修改了值，B事务读取了修改的值，然后又修改了值，B事务提交后，A事务中止，回滚。</p>
<p><img src="/../images/15445060.png" alt="060"></p>
<p>写写冲突（覆盖数据）：两个事务同时写入一个值，有一个值会被覆盖掉。</p>
<p><img src="/../images/15445061.png" alt="061"></p>
<p>冲突可串行化,大多数数据库使用的，还有个视图可串行化，没数据库实现</p>
<ul>
<li>通过比较两个操作是否冲突，来修改顺序</li>
<li>使用依赖图（优先图）来判断依赖是否出现环</li>
</ul>
<p>假设事务t1写入了A数据，事务t2同时读取A数据，那么事务t2就依赖了事务t1</p>
<p><img src="/../images/15445062.png" alt="062"></p>
<p>假设事务t2又写入了B，事务t1要读取B，那么事务t1就依赖了事务t2，这个时候就产生了循环依赖，就跟死锁一样，所以这个时候需要回滚一个事务</p>
<p><img src="/../images/15445063.png" alt="063"></p>
<h2 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h2><p>事务A先获取锁，事务B等待锁，事务A执行完成以后，释放锁，事务B才能拿到锁。</p>
<p>共享锁，读锁，S-LOCK<br>独享锁，写锁，X-LOCK</p>
<p><img src="/../images/15445064.png" alt="064"></p>
<p>如上图所示，这样还是会出现不可重复读的问题，两阶段锁可以解决这个问题，两阶段锁是第一个正确的<code>并发控制协议</code></p>
<p>两阶段锁,遵循这个方法，使得事务是<code>冲突可串行化</code>的，但是会有级联事务中止（cascading aborts），可以通过强严格两阶段锁解决这个问题。</p>
<ul>
<li>第一阶段Growing:每个事务从lock manager获取锁，事务释放锁以后进入第二阶段shrinking</li>
<li>第二阶段Shrinking:事务释放锁以后不能获取新锁,只能释放锁或者提交事务释放持有的所有锁</li>
</ul>
<p>从生命周期来看，第一阶段是上升，第二阶段只会下降，不会再次上升，下图是正确的生命周期</p>
<p><img src="/../images/15445065.png" alt="065"></p>
<p>下图是错误的生命周期</p>
<p><img src="/../images/15445066.png" alt="066"></p>
<p>cascading aborts，如果事务t1中止回滚了，那么事务t2就发生了<code>脏读</code>，所以也需要回滚重来</p>
<p><img src="/../images/15445067.png" alt="067"></p>
<h3 id="严格两阶段锁"><a href="#严格两阶段锁" class="headerlink" title="严格两阶段锁"></a>严格两阶段锁</h3><p>在提交事务的时候才释放锁。可以解决脏读的问题。</p>
<p>非两阶段锁执行如下：</p>
<p><img src="/../images/15445068.png" alt="067"></p>
<p>两阶段锁执行如下：</p>
<p><img src="/../images/15445069.png" alt="067"></p>
<p>严格两阶段锁执行如下：</p>
<p><img src="/../images/15445070.png" alt="070"></p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁检测：通过使用<code>wait-for</code>图来检测依赖关系，如果有环就是死锁</p>
<p>检测的频率可以通过参数调整，这个需要权衡</p>
<p>victim选择，选择出回滚哪个事务，这也是企业级系统和开源系统的区别</p>
<ul>
<li>可以根据时间戳，选择年龄小的那个，认为刚加入的回滚成本小</li>
<li>根据持有锁的数量，选择持有锁少的那个回滚</li>
<li>根据已完成的工作量，选择查询数量少的那个回滚，可以认为回滚一个查询的成本比几十个查询的成本小</li>
<li>根据剩余的工作量</li>
<li>根据回滚的次数，这个事务老回滚，可能同情它不让它回滚，以避免“饥饿”</li>
</ul>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>根据时间戳来选择</p>
<ul>
<li>wait die: 老的等待新的，如果事务t1先开始，事务t2后开始，t2先获取了锁a, 然后t1要获取锁a，那么就等待，因为老的要等待新的，因为t1是老的，如果t1先获取锁a，t2新的后获取那么t2abort</li>
<li>wound die: 新的等待老的，如果事务t1先开始，事务t2后开始，t2先获取了锁a,然后t1要获取锁a,那么t2就abort，给老的让路，因为老的优先级高，如果t1先获取锁a，t2新的后获取锁a，那么就等待，因为新的等待老的</li>
</ul>
<p><img src="/../images/15445071.png" alt="071"></p>
<p>数据库锁层次</p>
<p><img src="/../images/15445072.png" alt="072"></p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>意向共享锁IS</p>
<ul>
<li>使用共享锁在较低级别锁定，共享锁粒度更细</li>
</ul>
<p>意向排它锁IX</p>
<ul>
<li>使用排它锁在较低级别锁定，排它锁粒度更细</li>
</ul>
<p>共享意向排它锁</p>
<ul>
<li>高级别用共享锁，低级别用排它锁</li>
</ul>
<p><img src="/../images/15445073.png" alt="073"></p>
<p>假设t1事务要查询一个tuple,那么可以在table上一个IS锁，然后在具体的tuple上一个S锁，接下来t2事务要更新一个tuple，发现表上是IS锁，那么根据规则，可以在table上在加一个IX锁，然后在要更新的tuple上一个X锁，如果恰好是同一个tuple，那么就等待S锁释放，如果不是同一个，那么就并发执行成功</p>
<p><img src="/../images/15445074.png" alt="073"></p>
<p>假设t1事务要扫描所有tuple来找到一个tuple去更新，那么table上一个SIX锁，然后扫描到一个tuple，就给一个tuple上X锁，扫描完就释放X锁，接下来t2事务要读取一个tuple，发现表上是SIX锁，那么根据规则，可以在table上一个IS锁，然后在要查询的tuple上S锁，如果刚巧tuple上有X锁，那么就等待t1事务释放。</p>
<p><img src="/../images/15445075.png" alt="073"></p>
<h2 id="时间戳并发控制"><a href="#时间戳并发控制" class="headerlink" title="时间戳并发控制"></a>时间戳并发控制</h2><p>两阶段锁是一种<code>悲观</code>的协议，所有人都会上锁，会争抢，时间戳是一种不依赖锁的<code>乐观</code>的协议。</p>
<p>Ti代表事务i得一个时间戳，Tj是j的，如果Ti &lt; Tj，那么i得事务会在j之前提交。</p>
<p>时间戳的两个特性</p>
<ul>
<li>唯一性，每个时间戳必须是唯一的</li>
<li>单调递增性，时间戳必须是增加的</li>
</ul>
<h3 id="基本时间戳协议"><a href="#基本时间戳协议" class="headerlink" title="基本时间戳协议"></a>基本时间戳协议</h3><p>每个tuple需要维护两个时间戳，一个<code>读时间戳</code>，一个<code>写时间戳</code>。</p>
<h4 id="读"><a href="#读" class="headerlink" title="读"></a>读</h4><p>在读取的时候要保证，当前时间戳 &gt; 写时间戳，也就是读取的是最新的值，未来不会被改变的值。<br>如果 当前时间戳 &lt; 写时间戳，那么重启事务，分配一个新的时间戳，再试一次。<br>如果成功取到tuple，那么需要更新<code>读时间戳</code>，使用自己的时间戳和原来的时间戳中大的那个去更新。</p>
<h4 id="写"><a href="#写" class="headerlink" title="写"></a>写</h4><p>写入的时候要保证，当前时间戳 &gt; 读时间戳 并且 &gt; 写时间戳<br>成功写入的时候要更新写时间戳，使用自己的时间戳和原来的时间戳中大的那个去更新。</p>
<h4 id="托马斯写入优化"><a href="#托马斯写入优化" class="headerlink" title="托马斯写入优化"></a>托马斯写入优化</h4><p>在写入的时候，如果当前时间戳 &lt; 写入时间戳，本来应该<code>中止</code>的事务，可以继续执行，但是写入操作不写入数据库，因为数据库的数据是更新的，而是写入本地副本，方便这个事务后面使用。</p>
<h3 id="乐观并发控制"><a href="#乐观并发控制" class="headerlink" title="乐观并发控制"></a>乐观并发控制</h3><p>另外一个是<code>乐观并发控制</code>。为每一个事务创建一个私有空间，他的所有操作都是先对私有空间的副本操作，最后执行到数据库里面的时候需要对比一下，是否能执行。如果不冲突，就可以执行。</p>
<p>三个阶段</p>
<ul>
<li>read phase(work phase): 执行事务的操作，操作都在私有空间执行。</li>
<li>validation phase: 提交事务的时候验证事务的有效性，是否冲突等，确实是否可以提交。在这个阶段才会分配时间戳。如果在之前需要写入时间戳，先暂时写入无穷大。并检测是否和其他事务的时间戳冲突，其他事务包括以前的所有事务和正在执行的事务</li>
<li>write phase: 如果校验成功，将时间戳写入W-TS列，将修改写入全局工作区，否则abort事务，这是原子的。</li>
</ul>
<p>假设事务t1读取tuple A,将从全局工作区复制A到私有工作区</p>
<p><img src="/../images/15445076.png" alt="076"></p>
<p>接下来事务t2读取tuple A，也将从全局工作区复制A到私有工作区</p>
<p><img src="/../images/15445077.png" alt="077"></p>
<p>接下来事务t2进入validation阶段，然后分配时间戳为1，接下来进入写入阶段，什么也不做</p>
<p><img src="/../images/15445078.png" alt="077"></p>
<p>事务t1修改tuple A，然后再次读取tuple A，可以重复读取，因为读取私有工作区的tuple A</p>
<p><img src="/../images/15445079.png" alt="077"></p>
<p>事务t1进入validation阶段，分配时间戳为2，因为1已经分配给t2事务了，写入阶段将私有工作区的tuple A，更新到全局工作区</p>
<p><img src="/../images/15445080.png" alt="077"></p>
<p>数据库拥有全局视野，在validation phase阶段，是单线程比较事务是否可以执行，会有一个大的latch上锁</p>
<ul>
<li>backward validation: 和并发执行中更早已经提交的事务进行比较</li>
<li>forward validation: 和并发执行中后面没有提交的事务进行比较</li>
</ul>
<h4 id="forward-validation"><a href="#forward-validation" class="headerlink" title="forward validation"></a>forward validation</h4><p>如果事务t1 &lt; t2,t1的写阶段在t2的读阶段之前，则没有任何冲突发生。</p>
<p>如果事务t1 &lt; t2,但是t1的valition阶段在t2的validation阶段之前，则冲突，因为t1已经更改了tuple A ,而t2读取的是W-TS&#x3D;0的tuple A，如果t1事务的W-TS是1，t2是2,那么t2读取的应该是W-TS&#x3D;1的tuple A才对</p>
<p><img src="/../images/15445081.png" alt="081"></p>
<p>如果t2的validation阶段在前就没问题，因为t2分配W-TS&#x3D;1，t1是2</p>
<p><img src="/../images/15445082.png" alt="082"></p>
<p>如果事务t1 &lt; t2 ，t1的validation阶段在t2的前面，但是t1已经写入全局工作区以后，t2在读取这个tuple，就没有问题</p>
<p><img src="/../images/15445083.png" alt="083"></p>
<p>forward validation和没有提交的事务进行比较<br><img src="/../images/15445084.png" alt="084"></p>
<p>backward 和已经提交的事务比较</p>
<p><img src="/../images/15445085.png" alt="085"></p>
<h3 id="partition-based-时间戳协议"><a href="#partition-based-时间戳协议" class="headerlink" title="partition based 时间戳协议"></a>partition based 时间戳协议</h3><p>按照时间戳水平分区，在同一个区里面，按照时间戳顺序执行，就不需要latch了。速度会很快。</p>
<p>在不同区执行的话，就很复杂了。</p>
<p>每个分区都是单线程执行的。这样不需要获取latch。</p>
<h3 id="幻读问题"><a href="#幻读问题" class="headerlink" title="幻读问题"></a>幻读问题</h3><p>假设事务t1读取了table a的count(<em>)是99,事务t2插入了一条数据，事务t1再次读取count(</em>)就变成了100，因为t1只能lock已经存在的数据，要插入的数据没办法lock</p>
<p><img src="/../images/15445086.png" alt="086"></p>
<p>解决幻读的三个方法</p>
<ul>
<li>重新执行扫描：提交后重新执行扫描看结果是否一致，不一致就发生了幻读，少见</li>
<li>predicate locking：System R提出的方案，锁定where语句，进行比较，很难实现，非常少见，duckDB,Hyper等实现了</li>
<li>Index Locking: 索引锁定，常见</li>
</ul>
<h4 id="Index-Locking"><a href="#Index-Locking" class="headerlink" title="Index Locking"></a>Index Locking</h4><ul>
<li>key-value locks</li>
<li>Gap locks (间隙锁)</li>
<li>Key-Range locks</li>
<li>Hierarchical locks</li>
</ul>
<p>key-value locks只能锁定键值，需要一个virtual key来锁定不存在的key</p>
<p><img src="/../images/15445087.png" alt="087"></p>
<p>间隙锁，锁定键值和下一个键值之间的间隙</p>
<p><img src="/../images/15445088.png" alt="088"></p>
<p>key-Range locks，锁定键值以及和下一个键值之间的间隙</p>
<p><img src="/../images/15445089.png" alt="089"></p>
<p>Hierarchical locks使用IX,IS等意向锁</p>
<p>不同隔离级别对应的问题，最受欢迎的隔离级别是读已提交，mysql默认是可重复读</p>
<p><img src="/../images/15445090.png" alt="090"></p>
<h2 id="多版本并发控制（MVCC）"><a href="#多版本并发控制（MVCC）" class="headerlink" title="多版本并发控制（MVCC）"></a>多版本并发控制（MVCC）</h2><p>MVCC(Multiple Version Concurrency Contronl)最早在1978年由一位MIT的Phd学生提出。在1980年被数据库实现。</p>
<p>firefox 最开始叫 phoenix， 但是因为和其他的重名了需要改名字，然后改成了firebird, firebird是个最早开源的数据库，它使用了MVCC,所以火狐还要改名，就成了firefox。</p>
<ul>
<li>Writers don’t block readers</li>
<li>Readers don’t block wirters</li>
</ul>
<p>只读事务读取快照，不需要锁。MVCC天然支持快照隔离，如果没有gc，支持time travel query，就是可以查询很久以前的更改</p>
<p>版本维护有3个元数据</p>
<ul>
<li>version 版本号 从0开始，递增</li>
<li>begin 开始的时间戳</li>
<li>end 结束的时间戳，默认是无穷大，当写入以后要更新上一个版本的end</li>
</ul>
<p><img src="/../images/15445097.png" alt="090"></p>
<p>还要维护一个事务状态表</p>
<ul>
<li>txnid: 比如事务t1,t2标识</li>
<li>timestamp: 时间戳，如OCC那样</li>
<li>status: 活动中，已提交等</li>
</ul>
<p><img src="/../images/15445098.png" alt="090"></p>
<p>假设事务t1读取A0的数据，然后事务t2写入A1数据，然后更新A0的end-ts&#x3D;2，事务t1再次读取的时候还能看到A0</p>
<p><img src="/../images/15445099.png" alt="090"></p>
<p>假设事务t1读取A0的数据，然后写入A1的数据，事务t2读取A0的数据，写入A2的数据，这个时候t2会阻塞，因为t1持有A的锁，当t1事务commit后，释放锁，事务t2才能继续写入A2的数据</p>
<p><img src="/../images/15445100.png" alt="100"></p>
<p>当事务启动的时候，会看到启动时数据库里的一致的快照</p>
<ul>
<li>没有来自未提交的事务的撕裂写入</li>
<li>如果两个事务更新同一个tuple，第一个写入将获胜</li>
</ul>
<p>快照隔离收到写入偏差异常(Write Skew Anomaly)的影响。</p>
<p>写入偏差异常，假设当前有2个黑球，2个白球，事务t1要将白球更新成黑球，事务t2要将黑球更新成白球，这个时候事务t1读取到2个白球，只将这个两个白球更新成黑球了，而事务t2读取了2个黑球，只把这2个黑球更新成白球了，最终结果还是2黑2白</p>
<p><img src="/../images/15445101.png" alt="100"></p>
<p>但是顺序执行的话结果应该是全白或全黑。</p>
<p><img src="/../images/15445102.png" alt="100"></p>
<p>并发控制协议</p>
<ul>
<li>timestamp ordering:分配一个确定顺序的时间戳</li>
<li>OCC:乐观并发控制</li>
<li>两阶段锁</li>
</ul>
<h3 id="版本存储"><a href="#版本存储" class="headerlink" title="版本存储"></a>版本存储</h3><p>版本存储：为每个逻辑tuple创建一个链表，每个事务通过指针遍历链表获取对应的版本。索引指针指向链表的头节点。</p>
<ul>
<li>append only storage: 复制一个tuple,更新数据，放到后面的节点作为tuple的新版本。</li>
<li>time travel storage: master version表中放最新版本的数据，老版本的数据放在 time travel 表中。master version表维护指向time travel表数据的指针。</li>
<li>Delta Storage: 最佳方案，只维护对前一个版本数据的修改，不直接维护所有副本。</li>
</ul>
<h4 id="append-only-storage"><a href="#append-only-storage" class="headerlink" title="append only storage"></a>append only storage</h4><p>要么最新到最旧的连接，要么最旧到最新的连接，全都放在一个工作空间中，然后用指针连一起</p>
<p><img src="/../images/15445091.png" alt="090"></p>
<h4 id="time-travel-storage"><a href="#time-travel-storage" class="headerlink" title="time travel storage"></a>time travel storage</h4><p>这个是两个空间来存储，一个main table存储最新的，一个time travel table存储所有旧的，像Sql server这种最初没有设计MVCC的数据库，为了兼容使用了这种方法。</p>
<p><img src="/../images/15445092.png" alt="090"></p>
<h4 id="Delta-storage"><a href="#Delta-storage" class="headerlink" title="Delta storage"></a>Delta storage</h4><p>也是两个空间存储，不同的是旧空间只存储修改的列的值</p>
<p><img src="/../images/15445093.png" alt="090"></p>
<h3 id="garbage-collection"><a href="#garbage-collection" class="headerlink" title="garbage collection"></a>garbage collection</h3><p>garbage collection(垃圾回收)</p>
<ul>
<li>tuple level：通过比较时间戳来确定哪些版本已经不用了，可以进行回收了。</li>
<li>transaction level：在事务提交的时候进行对比旧版本的数据是否可以删除</li>
</ul>
<h4 id="tuple-level-gc"><a href="#tuple-level-gc" class="headerlink" title="tuple level gc"></a>tuple level gc</h4><h5 id="vacuum"><a href="#vacuum" class="headerlink" title="vacuum"></a>vacuum</h5><p>后台线程的方式运行，每隔一段时间去扫描，还可以通过bit map来提升速度</p>
<p>假设现在正在运行的事务有两个，最低时间戳是12，那么所有end-ts低于12的都可以被gc，数据库基本都用的这个</p>
<p><img src="/../images/15445094.png" alt="090"></p>
<h5 id="cooperative-cleaning"><a href="#cooperative-cleaning" class="headerlink" title="cooperative cleaning"></a>cooperative cleaning</h5><p>当查询某个tuple的时候，进行扫描这个tuple的旧版本，从而gc，缺点是如果这个tuple一直不被访问，那么就一直不gc，很罕见</p>
<p><img src="/../images/15445095.png" alt="090"></p>
<h4 id="transaction-level-gc"><a href="#transaction-level-gc" class="headerlink" title="transaction level gc"></a>transaction level gc</h4><p>在事务提交的时候进行对比旧版本的数据是否可以删除</p>
<p><img src="/../images/15445096.png" alt="090"></p>
<h3 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h3><p>索引管理</p>
<ul>
<li>逻辑指针：通过中间表转化指针和物理地址，二级索引指向主键索引。</li>
<li>物理指针：直接记录指针</li>
</ul>
<h4 id="物理指针"><a href="#物理指针" class="headerlink" title="物理指针"></a>物理指针</h4><p>所有的索引都记录指针，缺点是更新的时候所有索引的指针都要更新</p>
<p><img src="/../images/15445103.png" alt="103"></p>
<h4 id="逻辑指针"><a href="#逻辑指针" class="headerlink" title="逻辑指针"></a>逻辑指针</h4><p>二级索引都记录主键，只有主键索引记录指针，mysql就这样的，这种方式更好</p>
<p><img src="/../images/15445104.png" alt="104"></p>
<h4 id="重复key问题"><a href="#重复key问题" class="headerlink" title="重复key问题"></a>重复key问题</h4><p>如果索引不是唯一索引，可以有多个key的话，假设事务t1读取A1，没问题</p>
<p>假设事务t2更新了A1，又删除了A1，那么数据如图所示A1老版本指向新版本，但是新版本是被删除的<br><img src="/../images/15445105.png" alt="104"></p>
<p>假设事务t3插入了一条A1数据，那么索引就指向两个A1数据</p>
<p><img src="/../images/15445106.png" alt="104"></p>
<p>MySQL使用两阶段锁，版本存储使用Delta Storage，垃圾回收是tuple level Vacuum,索引管理是逻辑指针。Mysql更快。<br>PostgreSQL使用两阶段锁，版本存储使用append only storage, 垃圾回收使用tuple level Vacuum，索引管理是物理指针。</p>
<p>MVCC实现</p>
<p><img src="/../images/15445107.png" alt="104"></p>
<h2 id="Logging-Schemes"><a href="#Logging-Schemes" class="headerlink" title="Logging Schemes"></a>Logging Schemes</h2><p>在数据库运行时，还没有把数据写入磁盘的时候发生故障，这个时候需要恢复数据。</p>
<h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><p>主要是两件事</p>
<ul>
<li>收集日志信息，以方便恢复</li>
<li>根据日志信息进行恢复</li>
</ul>
<p>故障类型</p>
<ul>
<li>事务故障</li>
<li>系统故障</li>
</ul>
<h3 id="UNDO-撤销-and-REDO-重做"><a href="#UNDO-撤销-and-REDO-重做" class="headerlink" title="UNDO(撤销) and REDO(重做)"></a>UNDO(撤销) and REDO(重做)</h3><p>Undo:维护一些信息，可以恢复事务对数据库中某个对象所做的任何修改。<br>Redo: 维护一些信息，可以重新执行某个事务对数据库中的某个对象所做的修改。可以重新执行一个已经提交的事务的修改。</p>
<h3 id="buffer-pool-策略"><a href="#buffer-pool-策略" class="headerlink" title="buffer pool 策略"></a>buffer pool 策略</h3><p>两个策略</p>
<ul>
<li>steal:是否允许一个已提交事务写入磁盘的时候把这个page里面的未提交事务的修改也写入磁盘。</li>
<li>force：提交事务的时候，是否允许事务的所有更新写入磁盘</li>
</ul>
<p>not steal + force</p>
<ul>
<li>优点：不需要恢复，因为只写入磁盘提交的事务更新的内容。磁盘就是已提交内容</li>
<li>缺点：多个事务提交需要写入多次磁盘，写入磁盘麻烦点，因为要复制一个副本出来，副本中是这个事务修改的内容，把这个副本写入磁盘。</li>
</ul>
<p><img src="/../images/15445108.png" alt="104"></p>
<p>shadow paging:</p>
<ul>
<li>有一个db root，记录当前使用的hash table</li>
<li>hash table有一个master table是当前使用的，每个事务会有一个shadow page table，提交以后更新db root指向这个shadow page table，然后回收之前的master table和对应的page文件</li>
</ul>
<p><img src="/../images/15445109.png" alt="104"></p>
<p>wirte ahead log</p>
<ul>
<li>先写入日志，在写入磁盘</li>
<li>日志中包含的信息可以用来undo and redo。</li>
<li>使用的策略是 steal + not force，所以不需要把事务的所有更新都写入磁盘。</li>
</ul>
<p>日志内容</p>
<ul>
<li>事务id</li>
<li>对象id</li>
<li>时间戳</li>
<li>before value(undo)</li>
<li>after value(redo)</li>
<li>写入更快，但是恢复速度慢</li>
</ul>
<p>当事务执行的时候，写入日志到内存中，比如事务t1,将A从1修改到8，当事务提交的时候，先把日志写入磁盘，然后告诉客户端事务成功，如果这个时候发生断电等，可以读取日志来恢复事务，如果写入日志之前断电，那么无需恢复，因为没有告诉客户端成功，事务没有成功如何办是客户端要考虑的。</p>
<p><img src="/../images/15445110.png" alt="104"></p>
<p>group commit</p>
<ul>
<li>有两个log buffer，写满一个以后，写另一个，将满的log buffer写入磁盘</li>
<li>除了满的时候写入磁盘，还有定时，如果知道写入磁盘的时间，可以定时成这个时间，没满的话时间到了也会写入磁盘。</li>
</ul>
<p>满了的写入磁盘可以异步写入，增加速度</p>
<p><img src="/../images/15445111.png" alt="111"></p>
<p>shadow paging 和 WAL 就是一种权衡，是看重运行时速度还是恢复速度，几乎所有的数据库都是用WAL,比如mysql的bin log, WAL运行时速度更快</p>
<p><img src="/../images/15445112.png" alt="111"></p>
<p>logging schemes</p>
<ul>
<li>物理日志：记录底层字节的修改，就像git diff一样能看见，但是修改1万条tuple,就会记录1万条tuple的修改。</li>
<li>逻辑日志：记录高层的事务操作，像update,delete,insert等。比物理日志省空间，但是恢复的时候不知道哪些tuple已经写入了磁盘，所以恢复的时候还会在写入一遍。</li>
<li>混合日志：记录相对底层的修改，但是不像git diff一样那么详细。</li>
</ul>
<p><img src="/../images/15445113.png" alt="111"></p>
<h3 id="check-point"><a href="#check-point" class="headerlink" title="check point"></a>check point</h3><p>WAL的缺点是无限增长，如果崩溃后，则需要重现所有的WAL，增加检查点以后，可以只重现检查点以后的日志。</p>
<p>日志中写入check point，check point之前的都是已经写入磁盘的，所以恢复的时候就不用管了。</p>
<p>假设事务t1在检查点前commit了，则不需要恢复，因为已经提交了，事务t2在检查点后commit，在检查点前开始，则需要redo恢复事务t2，事务t3在检查点前开始，但是还没有commit，所以不需要恢复，直接撤销即可。</p>
<p><img src="/../images/15445114.png" alt="114"></p>
<h2 id="aries-recovery"><a href="#aries-recovery" class="headerlink" title="aries recovery"></a>aries recovery</h2><p>三步</p>
<ul>
<li>预写式日志</li>
<li>Repeating history during redo: 重启并恢复事务到之前的状态</li>
<li>logging changes during undo：再次写入预写式日志</li>
</ul>
<p>日志序列号(LSN)</p>
<ul>
<li>每个日志都要有一个序列号，在一个事务中，可能不是连续的，但是递增的。</li>
<li>flushedLSN:在内存中，记录上一个刷到磁盘中的log的LSN</li>
<li>pageLSN: 在page中，记录page最新的序列号</li>
<li>recLSN: 在page中，记录最老的序列号，这个是不会变的，而pageLSN一直在更新。</li>
<li>lastLSN: 记录事务中最新的一个日志</li>
<li>Master Record: check point最新的LSN</li>
</ul>
<p>如果pageLSN &lt;&#x3D; flushedLSN, 表明这个page的数据都已经写入磁盘了</p>
<p>事务提交的时候，往日志里面写入一个<code>txn end</code>。</p>
<p>当事务commit后写入磁盘，然后更新flushedLSN，接下来添加txn end标识</p>
<p><img src="/../images/15445115.png" alt="114"></p>
<p>CLR:abort算法</p>
<ul>
<li>当事务abort的时候，进行撤销操作，日志里面添加CLR记录，before是对应的之前事务日志的after，CLR的after对应之前的before,undo next指针指向下个需要撤销的日志。</li>
<li>撤销完成以后添加 <code>txn end</code>。</li>
</ul>
<p>写入的时候如同链表一样，除了记录本次的LSN以外，还要记录上一个的LSN,比如本次001，上次是Nil，本次002，上次001，以此找出这一次事务的所有日志，比如事务t1是001-nil,002-001，接下来事务t2是003-nil,004-003,然后事务t1是005-002。</p>
<p>接下来插入CLR日志，CLR可以是026-011,CLR-002代表要撤销的是LSN&#x3D;002的日志，记录了从40恢复到30，最后在插入txn-end标识</p>
<p><img src="/../images/15445116.png" alt="114"></p>
<p>check point写入</p>
<ul>
<li>第一种方式是停止创建新事务，等所有事务完成的时候开始写入<ul>
<li>优点是能完全保证数据一致性</li>
<li>缺点是耗时，执行的时候不能创建新事务</li>
</ul>
</li>
<li>第二种方法暂停更新的事务，只读事务不受影响，需要维护一个active transation table和一个dirty page table<ul>
<li>active transation table包含事务id,lastLSN和状态，状态有运行中，提交中，等待undo</li>
<li>dirty page table 包含所有的dirty page信息</li>
</ul>
</li>
<li>第三种方法最好，叫fuzzy checkpoint，checkpoint的时候允许所有事务运行。<ul>
<li>开始的时候记录checkpoint begin</li>
<li>结束的时候记录checkpoint end,end里面包含了 checkpoint期间的active transation table和dirty page table信息。</li>
</ul>
</li>
</ul>
<p>ATT(Active Transation Table)</p>
<p><img src="/../images/15445117.png" alt="114"></p>
<p>DPT(Dirty Page Table)<br><img src="/../images/15445118.png" alt="114"></p>
<p>第一个check point记录了ATT是T2事务，代表事务t2在check point之前开始，且未提交，而事务t1在check point之前已经提交了，所以不记录，DPT记录了事务t2在check point之前修改的脏页是P22</p>
<p>第二个check point记录了事务T2,T3，因为T2虽然在第二个check point之前提交了，但是没有插入txn-end代表没有提交结束，DPT记录了两个check point之间的脏页P11和P33</p>
<p><img src="/../images/15445119.png" alt="114"></p>
<p>fuzzy check point </p>
<p>因为所有事务都在运行中，所以增加了check point begin 和 end来标识check point的开始和结束，第一个check point end里面记录了事务t2和脏页P22，是因为这些发生在check point begin之前。</p>
<p><img src="/../images/15445120.png" alt="120"></p>
<p>arise recovery</p>
<ul>
<li>分析：根据master record跳到对应的check point的位置，然后开始扫描需要恢复的信息。</li>
<li>redo: 重新执行所有的操作。</li>
<li>undo: 从日志最后开始往上，撤销所有未提交的更改。这个时候已提交的已经写入磁盘，未提交的已经被撤销。</li>
</ul>
<p>分析阶段：从master record的位置开始扫描到最后，找出这之间的所有active transation table和dirty page table信息。</p>
<p>redo: 根据分析出的信息，找到dirty page中最早的一个recLSN, 也就是最早的一个日志，然后从这里开始恢复数据，执行一遍所有的操作。来恢复buffer pool。</p>
<p>undo: 从最后开始往上面扫描，把需要撤销的数据进行撤销。</p>
<h2 id="分布式数据库介绍"><a href="#分布式数据库介绍" class="headerlink" title="分布式数据库介绍"></a>分布式数据库介绍</h2><p>并行数据库</p>
<ul>
<li>离得近的<br>分布式数据库</li>
<li>离得远的</li>
</ul>
<p>系统架构</p>
<ul>
<li>shared everthing</li>
<li>shared memory:常见于高性能计算领域，有多个CPU，共享内存和磁盘</li>
<li>shared disk: 内存也有多个，共享磁盘，这个更常见，例如云数据库<ul>
<li>更新数据的时候需要通知其余的节点</li>
<li>spark,HBase</li>
</ul>
</li>
<li>shared noting: 磁盘也是多个<ul>
<li>有更好的效率，但是很难保证数据一致性和扩容</li>
<li>mongo,ES,Etcd,Zookeeper,ClickHouse</li>
</ul>
</li>
</ul>
<p>shared noting example</p>
<p>首先通过catalog查询应该请求哪个节点</p>
<p><img src="/../images/15445121.png" alt="120"></p>
<p>然后发送查询请求到相应的节点</p>
<p><img src="/../images/15445122.png" alt="120"></p>
<p>如果数据跨节点存储，那么数据会节点间通信，比如获取100和200的数据，node p1会请求p2获取200的数据，然后p1将两个数据返回给客户端</p>
<p><img src="/../images/15445123.png" alt="120"></p>
<p>shared disk example</p>
<p>客户端请求节点获取数据，节点请求disk获取数据，然后返回</p>
<p><img src="/../images/15445124.png" alt="120"></p>
<p>但是更新的时候需要广播给其他节点</p>
<p><img src="/../images/15445125.png" alt="120"></p>
<p>mongo属于shared noting</p>
<ul>
<li>route节点，负责把请求路由到对应的节点上</li>
<li>config节点，route从这里获取请求应该到哪个节点上</li>
<li>db节点</li>
</ul>
<p>数据拆分</p>
<ul>
<li>将不同的数据放到每个shared上面</li>
<li>不同的查询交给不同的shared去做，可以通过exchange operate来并行执行。</li>
<li>最简单的方式是一个表一个分区，mongodb可以这样。</li>
<li>水平分区<ul>
<li>将数据水平分到每个分区中</li>
<li>可以是hash，也可以是一个范围一个范围的分区</li>
<li>hash的话，想增加分区很麻烦，可以使用<code>一致性hash</code>来解决增加分区的问题，而不是取余。</li>
<li>采用一致性hash的有snowflake,memcached,cassandra等</li>
</ul>
</li>
</ul>
<p>SHARED-DISK PARTITIONING<br><img src="/../images/15445126.png" alt="120"></p>
<p>SHARED-NOTHING PARTITIONING<br><img src="/../images/15445127.png" alt="120"></p>
<p>一致性hash</p>
<p>节点分布在环上，数据也分布在环上，顺时针旋转，数据就属于第一个到达的节点。</p>
<p><img src="/../images/15445128.png" alt="120"></p>
<p>增加节点的时候，只需要重新hash其中一个节点的数据就可以，比如增加p4，因为P4节点落在p3节点的范围里面，所以只需要重新hash节点p3的数据，其他节点无影响。</p>
<p><img src="/../images/15445129.png" alt="120"></p>
<p>如果需要复制数据，将数据存储在多个节点上，假设replication&#x3D;3，复制数据到三个节点，则顺时针旋转的3个节点都存储该数据。</p>
<p><img src="/../images/15445130.png" alt="130"></p>
<p>分布式事务</p>
<ul>
<li>通过中心化服务器，来分发lock，然后提交事务的时候通过他来请求每一个分区是否能提交事务，如果都可以，才提交事务</li>
<li>去中心化事务提交</li>
</ul>
<p>spanner</p>
<p>HNSW</p>
<h2 id="分布式OLTP数据库"><a href="#分布式OLTP数据库" class="headerlink" title="分布式OLTP数据库"></a>分布式OLTP数据库</h2><p>假设所有节点是友好的</p>
<p>replication:可以提高可用性</p>
<ul>
<li>分区 vs 非分区</li>
<li>shared noting vs shared disk</li>
<li>设计<ul>
<li>副本配置</li>
<li>传播方案</li>
<li>传播时序</li>
<li>更新方法</li>
</ul>
</li>
</ul>
<p>副本配置</p>
<ul>
<li>primary: 有一个主节点，其他是从节点，大部分都是这样的，主节点负责同步给其他从节点。比如主从复制，读写分离这种</li>
<li>multi-primary: 事务可以在任何一个节点提交，并同步给其他节点，mysql group replication就支持这个。这种方案所有副本都可以读写，冲突的时候通过两阶段提交或者Paxos来觉得写入哪个。Facebook使用了这个。</li>
</ul>
<p>primary，写入主节点，读取可以在从节点</p>
<p><img src="/../images/15445131.png" alt="130"></p>
<p>multi-primary 任何节点都可以读写</p>
<p><img src="/../images/15445132.png" alt="130"></p>
<p>K-safety: 通过监控对象来看有哪些replica是活跃的。至少要有k个replica，如果小于k个，就认为宕机了。</p>
<p>传播方案</p>
<ul>
<li>同步：强一致性，所有从节点都同步以后才返回成功</li>
<li>异步：最终一致性，先返回成功，在同步给其他的从节点</li>
<li>半同步：同步给一些节点后返回成功给客户端</li>
</ul>
<p>传播时序</p>
<ul>
<li>即时：立即传递给其他节点，同时当事务提交或回滚的时候也传递给其他节点</li>
<li>提交：事务提交的时候才传播给其他节点</li>
</ul>
<p>事务提交的顺序由数据库状态决定，原子提交协议也是分布式的共识协议</p>
<p>原子提交协议</p>
<ul>
<li>两阶段提交（1970）</li>
<li>三阶段提交（1983）</li>
<li>Viewstamped Replication (1988)</li>
<li>Paxos（1989）</li>
<li>Raft（2013）</li>
<li>ZAB（2008）</li>
</ul>
<p>两阶段提交</p>
<ul>
<li>第一阶段 prepare, 像所有参与者发送请求，是否能提交事务，只有所有都可以提交，才进入第二阶段，如果有一个节点abort,那么事务就会进入第二阶段abort</li>
<li>第二阶段 commit, 想所有参与者发送请求，进行提交事务。</li>
<li>第二阶段 abort, 返回abort，然后所有参与者abort。</li>
</ul>
<p>假设客户端发送提交事务的请求，有一个协调器和若干个参与者，协调器接收请求以后，向参与者发送第一阶段prepare请求。</p>
<p><img src="/../images/15445133.png" alt="130"></p>
<p>如果所有参与者返回OK,表示全部同意提交，则可以提交。</p>
<p><img src="/../images/15445134.png" alt="130"></p>
<p>接下来协调器发送第二阶段commit请求给所有参与者</p>
<p><img src="/../images/15445135.png" alt="130"></p>
<p>所有参与者返回OK以后，协调器返回提交成功给客户端</p>
<p><img src="/../images/15445136.png" alt="130"></p>
<p>假设有任何一个参与者在第一阶段返回了不同意，则终止事务提交</p>
<p><img src="/../images/15445137.png" alt="130"></p>
<p>协调器向所有节点发送第二阶段abort请求</p>
<p><img src="/../images/15445138.png" alt="130"></p>
<p>等待所有节点返回OK以后，协调器返回abort给客户端</p>
<p><img src="/../images/15445139.png" alt="130"></p>
<p>崩溃恢复</p>
<ul>
<li>如果协调器崩溃了。要么全部abort，要么选出新的协调器继续执行事务。</li>
<li>如果参与者崩溃了，那么协调器会认为参与者返回了abort，从而终止事务。</li>
</ul>
<p>优化</p>
<ul>
<li>early prepare voting: 这个很少，最后一个查询执行的时候，告诉他可以直接进入prepare阶段</li>
<li>early Ack After Prepare: 这个很常见，prepare阶段结束就返回事务执行成功，然后自己再接着commit。</li>
</ul>
<p>early Ack After Prepare：当第一阶段prepare返回成功以后，立即给客户端返回成功。</p>
<p><img src="/../images/15445140.png" alt="140"></p>
<p>返回给客户端以后再发送第二阶段commit请求给其他参与者。</p>
<p><img src="/../images/15445141.png" alt="140"></p>
<p>Paxos，来自分布式计算领域，也被称为<code>共识协议</code>。两阶段提交是Paxos的一个子集。</p>
<ul>
<li>Paxos大部分节点同意提交就可以提交，而两阶段提交需要所有参与者同意，所以Paxos没有容错。</li>
</ul>
<p><img src="/../images/15445142.png" alt="140"></p>
<p>multi-Paxos</p>
<ul>
<li>选举一个leader来进行提案，每隔一段时间重新选举</li>
<li>防止有两个 proposer 来回提交导致的starving问题</li>
</ul>
<p>两阶段提交 vs Paxos vs Raft</p>
<p>两阶段提交</p>
<ul>
<li>如果协调器在发送prepare消息后挂掉，则阻塞直到协调器恢复</li>
</ul>
<p>Paxos</p>
<ul>
<li>如果大多数参与者活着则非阻塞，前提是有足够长的时间不再出现故障</li>
</ul>
<p>Raft</p>
<ul>
<li>与Paxos类似，但节点类型较少。</li>
<li>只有拥有最新日志的节点才能成为领导者</li>
</ul>
<p>CAP理论</p>
<ul>
<li>Consistent: 一致性</li>
<li>Always Available: 始终可用</li>
<li>Network Partition Tolerant:分区容错性</li>
</ul>
<p>Nosql基本都是AP,事务性的基本都是CP</p>
<p>一致性代表从哪个节点获取的数据都是一样的</p>
<p><img src="/../images/15445143.png" alt="140"></p>
<p>可用性代表当节点挂了以后系统还可以使用</p>
<p><img src="/../images/15445144.png" alt="140"></p>
<p>分区容错性最难，容易出现<code>脑裂</code>问题。当网络挂掉以后从节点以为主节点挂了，所以把自己选举为主节点，就产生了两个主节点</p>
<p><img src="/../images/15445145.png" alt="140"></p>
<p>当网络恢复以后，两个节点的数据就不一样了。</p>
<p><img src="/../images/15445146.png" alt="140"></p>
<p>解决方法1：停止系统</p>
<ul>
<li>停止接受没有大多数节点的分区中的更新。</li>
</ul>
<p>解决方案2：允许拆分，协调更改</p>
<ul>
<li>允许分区的每一侧都接收更新</li>
<li>根据时间来确定最后的版本，以最后的版本为准<ul>
<li>服务端：last update wins 用最后的版本为准</li>
<li>客户端：vector clocks（不要这么做）</li>
</ul>
</li>
</ul>
<p>2010年提议对CAP进行扩展</p>
<ul>
<li>Partition Tolerant:分区容忍</li>
<li>Always Available：随时可用</li>
<li>Consistent：一致<ul>
<li>Latency：延迟</li>
<li>Consistency： 一致性</li>
</ul>
</li>
</ul>
<h2 id="分布式OLAP数据库"><a href="#分布式OLAP数据库" class="headerlink" title="分布式OLAP数据库"></a>分布式OLAP数据库</h2><p>OLAP数据库也被称作<code>数据仓库</code>，通过ETL，把数据存入数据仓库。</p>
<ul>
<li>Extract</li>
<li>Transform</li>
<li>Load</li>
</ul>
<p>星形模型</p>
<ul>
<li>一个事实表</li>
<li>几个dim表</li>
</ul>
<p>雪花模型</p>
<ul>
<li>一个事实表</li>
<li>更多的dim表，dim表可以有他的dim表</li>
</ul>
<p>查询执行</p>
<ul>
<li>push: 发送查询到包含数据的节点,返回数据的时候会做过滤和处理，就像<code>条件下推</code>那样</li>
<li>pull: 知道需要的数据在哪些page里面，把page取过来在执行查询。</li>
</ul>
<p>push</p>
<p>pull</p>
<p>查询计划</p>
<ul>
<li>物理操作： 先生成查询计划，然后将对应的需要执行的物理操作直接发送给其余节点，其余节点只负责执行，返回数据。大部分分布式数据库都这样。</li>
<li>sql: 将sql发给每个节点，每个节点生成自己的执行计划。然后执行返回。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/MySQL%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/MySQL%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html" class="post-title-link" itemprop="url">MySQL学习路线</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-26 10:12:47" itemprop="dateCreated datePublished" datetime="2023-04-26T10:12:47+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMU15445/" itemprop="url" rel="index"><span itemprop="name">CMU15445</span></a>
                </span>
            </span>

          
            <span id="/MySQL%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html" class="post-meta-item leancloud_visitors" data-flag-title="MySQL学习路线" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/MySQL%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/MySQL%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL学习路线"><a href="#MySQL学习路线" class="headerlink" title="MySQL学习路线"></a>MySQL学习路线</h1><p>大家好，我是大头，98年，职高毕业，上市公司架构师，大厂资深开发，管理过10人团队，我是如何做到的呢？</p>
<p>这离不开持续学习的能力，而其中最重要的当然是数据库技术了！</p>
<p>对于所有开发来说，都离不开数据库，因为所有的数据都是要存储的。</p>
<p>其他的技能可能会变，比如业务开发、算法开发、基础设施开发，也不管你是用Java、php、golang、C++等等。你都会用到数据库，因此，学好数据库对于我们来说就至关重要了。</p>
<p>接下来大头将分享自己学习数据库的路线以及心得。</p>
<p>后续也会根据这个路线分享所有的学习方法以及实操案例。关注我一起学习！文末有惊喜哦！</p>
<h2 id="如何学好数据库"><a href="#如何学好数据库" class="headerlink" title="如何学好数据库"></a>如何学好数据库</h2><p>如何学好数据库？我相信这是一个老生常谈的问题了，如何学好XXX，这里我觉得最重要的是<code>实践</code>。</p>
<p>相信大家都知道这句话。<code>实践是检验真理的唯一标准</code>。因此，当分享结束以后，大头还会分享完整的实操应用，完全免费分享，放在外面至少价值大几百的实操应用训练营。</p>
<p>在现在这个AI发展迅速的时代，你不用点AI好像就被社会淘汰了一样。所以，我们来看一下AI给出的回答。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">学好数据库需要系统的学习方法和实践相结合，以下是一些建议：</span><br><span class="line">1. 基础知识积累</span><br><span class="line">理解数据库概念：首先明确数据库的定义，它是存储、管理和检索数据的系统。了解其基本功能，如数据存储、查询、更新和删除等。</span><br><span class="line">学习数据库类型：常见的数据库有关系型数据库（如MySQL、Oracle、SQL Server）和非关系型数据库（如MongoDB、Redis）。了解它们的特点和适用场景。</span><br><span class="line">掌握数据库模型：重点学习关系型数据库的表结构、字段类型、主键、外键等概念，以及非关系型数据库的键值存储、文档存储、列存储等模型。</span><br><span class="line">2. 理论学习</span><br><span class="line">学习SQL语言：SQL是数据库的核心语言，用于操作关系型数据库。学习SQL的基本语法，包括数据定义语言（DDL）、数据操纵语言（DML）和数据控制语言（DCL）。</span><br><span class="line">DDL：创建、修改和删除数据库对象（如表、索引）。</span><br><span class="line">DML：插入、更新、删除和查询数据。</span><br><span class="line">DCL：控制用户对数据的访问权限。</span><br><span class="line">理解数据库设计原则：学习如何设计合理的数据库结构，包括范式理论（如第一范式、第二范式、第三范式），以减少数据冗余和提高数据一致性。</span><br><span class="line">学习事务管理：了解事务的ACID特性（原子性、一致性、隔离性、持久性），以及事务的提交和回滚机制。</span><br><span class="line">掌握索引和优化：学习索引的原理和类型（如B树索引、哈希索引），以及如何通过索引优化查询性能。</span><br><span class="line">3. 实践操作</span><br><span class="line">安装和配置数据库：选择一种主流的数据库（如MySQL、SQLite），在本地安装并进行配置。熟悉数据库的启动、停止和基本管理操作。</span><br><span class="line">动手操作SQL：通过实际操作来巩固SQL语言的学习。可以使用在线数据库平台（如SQLFiddle）或本地数据库进行练习，编写和执行SQL语句，完成数据的增删改查操作。</span><br><span class="line">进行数据库设计：尝试设计一个小型的数据库项目，如学生管理系统或图书管理系统。从需求分析开始，设计表结构，确定字段类型和关系，然后实现数据库的创建和数据的插入。</span><br><span class="line">参与项目实践：如果有机会，参与实际的数据库项目开发，或者在开源项目中学习和实践。通过实际项目，了解数据库在真实场景中的应用和优化方法。</span><br><span class="line">4. 进阶学习</span><br><span class="line">学习高级SQL技术：如子查询、连接查询（内连接、外连接）、分组查询、窗口函数等。</span><br><span class="line">了解数据库架构设计：学习如何设计高可用、高性能的数据库架构，包括主从复制、读写分离、分库分表等技术。</span><br><span class="line">掌握数据库安全：学习如何保护数据库的安全，包括用户认证、授权、数据加密、备份和恢复等。</span><br><span class="line">学习数据库性能优化：了解如何分析和优化数据库性能，包括查询优化、存储优化、硬件优化等。</span><br><span class="line">5. 持续学习和拓展</span><br><span class="line">关注新技术：数据库领域不断发展，新的技术和工具不断涌现。关注NoSQL数据库、分布式数据库（如Cassandra、HBase）、云数据库（如AWS RDS、阿里云数据库）等新技术的发展。</span><br><span class="line">阅读经典书籍和文档：推荐一些经典书籍，如《数据库系统概念》《SQL必知必会》《高性能MySQL》等。同时，阅读数据库官方文档，深入了解其特性和最佳实践。</span><br><span class="line">参加培训和认证：如果条件允许，可以参加数据库相关的培训课程或考取相关认证（如Oracle认证、MySQL认证），提升自己的专业水平。</span><br><span class="line">加入技术社区：加入数据库相关的技术社区（如Stack Overflow、CSDN、知乎等），与其他开发者交流经验和问题，拓宽视野。</span><br><span class="line">总之，学好数据库需要理论学习和实践操作相结合，通过不断的学习和实践，逐步提升自己的数据库技能。</span><br></pre></td></tr></table></figure>

<p>可以看到AI给出的回答相当不错了。看起来也是那么回事。</p>
<p>对于学习一种新事物来说，我觉得要分为几个阶段吧，对于所有新事物都适用。</p>
<ol>
<li>新概念学习：逐步了解这个东西的概念，是什么？能做什么？什么时候用？如何使用？</li>
<li>基础学习：学习这个东西的一些基础使用，并实践应用。</li>
<li>实战应用：当了解概念和基础以后，可以自己开始实践了，最好能完整的实践每一个功能。一般来说到这一步就可以说熟练使用这个东西了。</li>
<li>深入学习原理：开始深入学习相关的原理性知识，了解这个东西是如何实现的，它当时为什么要这么做？有没有其他替代的方案呢？我们可以尝试自己去实现这个东西。一般来说这一步完成就可以说精通了。</li>
<li>扩展学习：扩展学习其他同类的产品，了解使用场景，优劣等。</li>
</ol>
<p>那么回到我们的话题上，如何学好数据库？</p>
<ol>
<li>概念学习：数据库是什么？能做什么？什么时候用？如何使用？</li>
<li>基础学习：数据库的基础操作，增删改查，DDL、DCL、DML语言。</li>
<li>实战应用：自己去使用数据库的各个功能，包括增删改查、函数、触发器、存储过程、视图等。</li>
<li>学习原理：深入学习数据库的原理，包括事务的实现、锁的实现、增删改查的实现、索引的实现等。</li>
<li>扩展学习：学习不同类型的数据库，如列式数据库、内存数据库、文档数据库等。</li>
</ol>
<p>那么再详细一些呢？如何学好MySQL数据库？</p>
<ol>
<li>概念学习：MySQL数据库是什么？能做什么？什么时候用？如何使用？</li>
<li>基础学习：MySQL数据库的基础操作，增删改查，DDL、DCL、DML语言。</li>
<li>实战应用：自己去使用MySQL数据库的各个功能，包括增删改查、函数、触发器、存储过程、视图等。</li>
<li>学习原理：深入学习MySQL数据库的原理，包括事务的实现、锁的实现、增删改查的实现、索引的实现等。</li>
<li>扩展学习：学习一些其他的数据库，如PostgreSQL、ES、ClickHouse、MongoDB等。</li>
</ol>
<h2 id="概念学习"><a href="#概念学习" class="headerlink" title="概念学习"></a>概念学习</h2><p>首先，我们应该知道什么是数据库？很多人都会搞混一个概念，那就是数据库和数据库管理系统。</p>
<p>数据库的英文是<code>DataBase</code>。它的概念是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">数据库是一个长期存储在计算机内的、有组织的、可共享的数据集合，它具有以下特点</span><br><span class="line">1. 数据的集合性</span><br><span class="line">2. 数据的共享性</span><br><span class="line">3. 数据的冗余度低</span><br><span class="line">4. 数据的独立性</span><br><span class="line">5. 数据的安全性</span><br><span class="line">6. 数据的完整性</span><br><span class="line">7. 数据的可维护性</span><br></pre></td></tr></table></figure>

<p>而数据库管理系统的英文是<code>DataBase Management System</code>。它的概念是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据库管理软件（Database Management System，简称DBMS）是用于创建、管理、维护和操作数据库的软件系统。它在用户和数据库之间提供了一个接口，使得用户能够方便地存储、检索、更新和管理数据。</span><br></pre></td></tr></table></figure>

<p>因此，我们要明白，<code>MySQL</code>是一个数据库管理系统，而不是一个数据库。</p>
<p>虽然我们老说<code>MySQL数据库</code>，但这个是因为大家已经习惯了，大家都明白MySQL是什么，因此省略了一些。</p>
<p><code>MySQL</code>是用来管理数据库的一个系统。</p>
<p>那么问题来了，<code>SQL</code>又是什么呢？</p>
<p>这里给出基础篇的概念学习路线。大家可以根据这些去了解具体的概念。</p>
<p><img src="/../images/mysql/mysql1-1.png" alt="概念学习"></p>
<p>这一个部分1-2小时就差不多了。</p>
<h2 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h2><p>学会了概念以后，我们就要应用，进行实践。只有这样才能将知识转化成我们自己的。</p>
<p>对于实战来说，首先肯定要进行MySQL的安装，可以直接到官网进行安装，这里给出连接。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.mysql.com/">https://www.mysql.com/</a></p>
</blockquote>
<p>安装完成以后，根据上面学习的概念，首先执行一遍DCL、DML、DDL。</p>
<p>接下来需要学习<code>ER图</code>。如何学习ER图呢？同意的，先了解一下概念，在进行实战应用。自己画一画ER图。</p>
<p>画ER图的工具，这里推荐几个</p>
<ul>
<li>visio，可以自己去网上买一些key，不贵，要注意买key，而不是破解机。</li>
<li><a target="_blank" rel="noopener" href="https://www.processon.com/">processOn</a>，强烈推荐，网页版，使用方便，免费的一般也够用了。</li>
<li><a target="_blank" rel="noopener" href="https://app.diagrams.net/">drwa.io</a>，强烈推荐，同样有网页版，使用方便，免费。</li>
<li><a target="_blank" rel="noopener" href="https://dbdiagram.io/">dbdiagram</a>，不同于自己画图，这个网站可以进行数据库建模，支持导入导出。缺点是需要使用<code>DBML</code>进行建模，需要学习一下。</li>
</ul>
<p>接下来进行一些高级的应用、包括CTE、窗口函数、存储过程、视图、触发器等等。</p>
<p>还可以进行导入导出。</p>
<p>还可以使用你熟悉的语言进行操作。Java的使用可以使用MyBatis Plus。</p>
<p><img src="/../images/mysql/mysql1-2.png" alt="概念学习"></p>
<h2 id="深入学习原理"><a href="#深入学习原理" class="headerlink" title="深入学习原理"></a>深入学习原理</h2><p>MySQL原理性的东西就比较多了。</p>
<p>自顶向下来看，首先有连接器、分析器、优化器、执行器。</p>
<p>连接器可以不用管。</p>
<p>分析器的原理，如何进行语法分析的，这里需要学一下<code>关系代数</code>。数据库是将SQL转化成关系代数，然后在生成执行树的。</p>
<p>优化器的原理，如何选择索引的，成本模型是什么？直方图是什么？MySQL本身实现了哪些优化？谓词下推，索引下推，Index Merge等等。</p>
<p>接下来会生成具体的执行计划，如何查看执行计划的各个字段，如何根据执行计划来优化SQL。</p>
<p>还需要学习MySQL事务，事务的隔离级别，ACID特性，MVCC实现，undo log等等。</p>
<p>还要学习SQL语句如何执行的，Select是怎么查询出数据的，where条件怎么筛选数据，join是怎么进行连表查询的，update是怎么更新的，delete怎么删除的，group by,order by怎么实现的。</p>
<p>接下来最重要的索引部分，学习b+树索引，hash索引，倒排索引等等的实现。</p>
<p>数据存储部分的原理，我们知道数据库只是管理数据的，数据最终存储在磁盘上还是一些文件，那么这些文件是如何存储的呢？文件内容是什么？加载到内存以后，内存布局是什么样的？老说page,page是什么？</p>
<p>还有数据库崩溃恢复怎么实现的，redo log怎么实现崩溃恢复，这个其实也挺重要的，因为我们自己进行一些数据处理，可能也需要理解这个，而且大部分的数据持久化，崩溃恢复机制核心都是一样的。</p>
<p>还需要学习mySQL的锁，表锁，行锁，乐观锁，悲观锁，意向锁，间隙锁等等。</p>
<p><img src="/../images/mysql/mysql1-3.png" alt="概念学习"></p>
<h2 id="架构学习"><a href="#架构学习" class="headerlink" title="架构学习"></a>架构学习</h2><p>你学习完上面的东西以后，可以说对于单机MySQL就已经很了解了。接下来就可以进一步保证数据的高可用、高扩展、高性能了。</p>
<p>也就是去了解一些架构上面的知识，比如经典的主从架构，主从同步，异步同步，bin log,relay log，GTID同步。</p>
<p>还有分库分表的只是，水平拆分、垂直拆分、mySQL自带的partition支持。</p>
<p>再比如MySQL自身的集群组件，group replication。还有分布式数据库的一些实现，分布式事务。</p>
<p>CAP理论等等。</p>
<p><img src="/../images/mysql/mysql1-4.png" alt="概念学习"></p>
<h2 id="扩展学习"><a href="#扩展学习" class="headerlink" title="扩展学习"></a>扩展学习</h2><p>当上面的都学习完成以后，可以扩展学习一些其他的数据库。</p>
<p>比如同类型的PostgreSQL。这个更偏向学术性。</p>
<p>再比如其他的文档数据库mongoDB。</p>
<p>常用的搜索数据库ES。</p>
<p>列式数据库ClickHouse这些。</p>
<h2 id="学习书籍推荐"><a href="#学习书籍推荐" class="headerlink" title="学习书籍推荐"></a>学习书籍推荐</h2><p>在这里也给大家推荐一些相关的书籍，可以看一看。</p>
<ul>
<li>MySQL必知必会</li>
<li>InnoDB技术内幕</li>
<li>数据库系统概念</li>
<li>数据密集型应用系统设计</li>
<li>亿级流量系统架构设计与实战</li>
</ul>
<h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>以上就是整体的MySQL学习路线了。</p>
<p>关注我发送“MySQL知识图谱”领取完整的MySQL学习路线。</p>
<p>发送“电子书”即可领取价值上千的电子书资源。</p>
<p>部分电子书如图所示。</p>
<p><img src="/../images/bottom1.png" alt="概念学习"></p>
<p><img src="/../images/bottom2.png" alt="概念学习"></p>
<p><img src="/../images/bottom3.png" alt="概念学习"></p>
<p><img src="/../images/bottom4.png" alt="概念学习"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9%20copy.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9%20copy.html" class="post-title-link" itemprop="url">MySQL学习路线</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-26 10:12:47" itemprop="dateCreated datePublished" datetime="2023-04-26T10:12:47+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 11:26:16" itemprop="dateModified" datetime="2025-01-26T11:26:16+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMU15445/" itemprop="url" rel="index"><span itemprop="name">CMU15445</span></a>
                </span>
            </span>

          
            <span id="/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9%20copy.html" class="post-meta-item leancloud_visitors" data-flag-title="MySQL学习路线" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9%20copy.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9%20copy.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL索引失效"><a href="#MySQL索引失效" class="headerlink" title="MySQL索引失效"></a>MySQL索引失效</h1><p>大家好，我是大头，98年，职高毕业，上市公司架构师，大厂资深开发，管理过10人团队，我是如何做到的呢？</p>
<p>这离不开持续学习的能力，而其中最重要的当然是数据库技术了！</p>
<p>对于所有开发来说，都离不开数据库，因为所有的数据都是要存储的。</p>
<p>关注我一起学习！文末有惊喜哦！</p>
<h2 id="什么是MySQL索引失效？"><a href="#什么是MySQL索引失效？" class="headerlink" title="什么是MySQL索引失效？"></a>什么是MySQL索引失效？</h2><p>MySQL 索引失效是指尽管表中已经建立了索引，但在某些查询操作中，MySQL 的查询优化器选择不使用这些索引，而是采用全表扫描（Full Table Scan）或其他非索引扫描方式来执行查询。这种情况通常会导致查询性能下降，因为全表扫描需要扫描表中的每一行数据，而不是利用索引快速定位数据。</p>
<p>这里就要介绍一下MySQL的整体架构了。</p>
<p><img src="/../images/mysql/mysql2-1.png" alt="架构"></p>
<ul>
<li>连接器：MySQL连接器（MySQL Connector）是用于连接MySQL数据库的客户端库，它允许应用程序与MySQL数据库进行通信。这些连接器提供了API（应用程序编程接口），使得开发者可以在各种编程语言中轻松地执行SQL语句、管理数据库连接、处理查询结果等。</li>
<li>分析器：MySQL分析器才算真正进入了MySQL里面。它会分析词法和语法，如果你的SQL语句不对，就会看到一些报错，例如语法错误。</li>
<li>优化器：MySQL优化器是本文的重点内容，因为这里涉及了MySQL的一些优化，其中就包括了索引选择，也是导致索引失效的重要原因。在这一步也就确定了查询计划。</li>
<li>执行器：MySQL执行器会根据优化器输出的查询计划来执行这个查询计划，会调用底层的存储引擎进行执行。</li>
<li>存储引擎：MySQL支持多种存储引擎，每个存储引擎有不同的特点。其中InnoDB引擎因为支持事务等优点，现在是MySQL的默认存储引擎。</li>
</ul>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>MySQL连接器（MySQL Connector）是用于连接MySQL数据库的客户端库，它允许应用程序与MySQL数据库进行通信。这些连接器提供了API（应用程序编程接口），使得开发者可以在各种编程语言中轻松地执行SQL语句、管理数据库连接、处理查询结果等。</p>
<p>当我们最开始连接数据库实例的时候，我们要输入用户名密码，这时候连接器会从数据库的用户信息中判断你是否有权限连接数据库进行操作，有哪些权限。</p>
<p>如果你输入的用户名密码错误或者没有权限，那么你会收到下面的报错信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access denied <span class="keyword">for</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>(<span class="keyword">using</span> password: YES)</span><br></pre></td></tr></table></figure>

<p><img src="/../images/mysql/mysql2-2.png" alt="架构"></p>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>连接成功以后。分析器会分析这个语句的词法，语法，语义这些信息。</p>
<p>通俗来讲就是看到select,update这些关键字，知道你要来干啥，看看你是不是来搞破坏的，来捣蛋的。</p>
<p>看看你是查询哪个表啊，有什么条件啊，这些玩意。</p>
<p>最后会输出一个词法树。</p>
<p>当然了这一步还会分析你的语法有没有错误，比如你把select打错试试。打成elect，会出现下面的报错信息</p>
<blockquote>
<p>You have an error in your SQL syntax: check the maual that corresponds to your MySQL server version for the right syntax to use near ‘elect * from users’ at line 1</p>
</blockquote>
<p><img src="/../images/mysql/mysql2-3.png" alt="架构"></p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>优化器负责几个事情</p>
<ul>
<li>优化SQL：比如你写了一个很不友好的SQL，如<code>select * from a where 1 =1</code>,优化器会将1&#x3D;1去掉。还有比如括号的删除，如<code>select * from a where ((a AND b) AND c OR (((a AND b) AND (c AND d))))</code>改写成<code>select * from a where (a AND b AND c) OR (a AND b AND c AND d)</code>。等等。</li>
<li>一些内部的优化器：下面列出的是部分，更多的可以参考<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/optimization.html">MySQL官方文档优化器部分</a><ul>
<li>谓词下推：即where条件下推到扫描表的时候执行，而不是扫描表之后执行。</li>
<li>范围优化：对于BTREE和HASH索引，当使用&#x3D;、&lt;&#x3D;&gt;、IN（）、IS NULL或IS NOT NULL运算符时，键部分与常量值的比较是范围条件。此外，对于BTREE索引，当使用&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，BETWEEN，！&#x3D; 、或&lt;&gt;运算符，或者LIKE比较（如果LIKE的参数是不以小写字符开头的常量字符串）。对于所有索引类型，多个范围条件与OR或AND组合形成范围条件。</li>
<li>index merge优化：index merge就是多个索引并发扫描，再将扫描结果合并。</li>
<li>hash join优化：使用hash join来代替Nested Loop Join算法，能大幅度提升join速度。</li>
<li>Is Null优化：可以对<code>where a is null</code>这种条件进行优化，比如该字段设置了<code>not null</code>，那么这个条件就会被删除。</li>
<li>order by + limit优化：使用<code>Top N</code>排序</li>
<li>group by 优化：优化group by语句。</li>
<li>子查询物化：将子查询的内容物化保存起来。</li>
</ul>
</li>
<li>通过成本模型、直方图等信息生成不同的执行路径。</li>
<li>对比执行路径的内容，如取样等，进行选择最终的执行路径。生成查询计划。</li>
</ul>
<p>这里简单的介绍一些mysql内部的优化器，以了解mysql内部做了哪些优化手段。</p>
<p>最后会介绍mysql的成本模型、直方图信息等。结合实际的例子来给大家展示索引选择的问题。</p>
<h4 id="谓词下推优化"><a href="#谓词下推优化" class="headerlink" title="谓词下推优化"></a>谓词下推优化</h4><p>谓词下推优化（Predicate Pushdown Optimization）是一种查询优化技术，它将查询中的过滤条件（谓词）尽可能地推送到数据访问的早期阶段，以减少数据扫描的范围，从而提高查询性能。<br>在数据库查询中，谓词通常是指WHERE子句中的条件。谓词下推优化的目的是让这些条件在数据被读取或处理的早期阶段就发挥作用，避免不必要的数据处理和传输。</p>
<p>在没有谓词下推优化的情况下，数据库会先读取所有数据，然后在内存中应用过滤条件。这可能导致大量的数据被加载到内存中，增加了I&#x2F;O操作和内存使用。<br>通过谓词下推优化，数据库会在数据读取阶段就应用过滤条件，只加载满足条件的数据，从而减少数据的读取量和处理量。</p>
<p>假设存在<code>table_a</code>表，表里面有10条数据，<code>a = 1</code>的数据有一个，具体什么意思呢，我们来看一个SQL语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,b <span class="keyword">from</span> table_a <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>如果没有谓词下推优化的话，执行树如下。</p>
<p><img src="/../images/mysql/mysql2-4.png" alt="架构"></p>
<p>其执行顺序如下：</p>
<ol>
<li>扫描<code>table_a</code>表的10条数据，将10条数据传递给where过滤节点。</li>
<li>where过滤操作进行过滤，过滤出<code>a = 1</code>条件的1条数据，将这个数据传递给列选择节点。</li>
<li>列选择节点选择这条数据的2列，将结果返回。</li>
</ol>
<p>其内存中要存储10条数据。</p>
<p>而有了谓词下推优化以后，执行树如下。</p>
<p><img src="/../images/mysql/mysql2-5.png" alt="架构"></p>
<p>执行顺序如下：</p>
<ol>
<li>扫描<code>table_a</code>表的10条数据，过滤出符合<code>a = 1</code>条件的这一个数据。将这个数据传给列选择节点。</li>
<li>列选择节点选择这条数据的2列，将结果返回。</li>
</ol>
<h4 id="范围优化"><a href="#范围优化" class="headerlink" title="范围优化"></a>范围优化</h4><p>对于BTREE和HASH索引，当使用&#x3D;、&lt;&#x3D;&gt;、IN（）、IS NULL或IS NOT NULL运算符时，键部分与常量值的比较是范围条件。此外，对于BTREE索引，当使用&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，BETWEEN，！&#x3D; 、或&lt;&gt;运算符，或者LIKE比较（如果LIKE的参数是不以小写字符开头的常量字符串）。对于所有索引类型，多个范围条件与OR或AND组合形成范围条件。</p>
<p>给定数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">key_part1  key_part2  key_part3</span><br><span class="line">  NULL       1          &#x27;abc&#x27;</span><br><span class="line">  NULL       1          &#x27;xyz&#x27;</span><br><span class="line">  NULL       2          &#x27;foo&#x27;</span><br><span class="line">   1         1          &#x27;abc&#x27;</span><br><span class="line">   1         1          &#x27;xyz&#x27;</span><br><span class="line">   1         2          &#x27;abc&#x27;</span><br><span class="line">   2         1          &#x27;aaa&#x27;</span><br></pre></td></tr></table></figure>

<p>执行where key_part1&#x3D; 1，其扫描范围为 1,负无穷，负无穷到 1,正无穷，正无穷</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1,-inf,-inf) &lt;= (key_part1,key_part2,key_part3) &lt; (1,+inf,+inf)</span><br></pre></td></tr></table></figure>
<p>即覆盖了这三行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1         1          &#x27;abc&#x27;</span><br><span class="line">1         1          &#x27;xyz&#x27;</span><br><span class="line">1         2          &#x27;abc&#x27;</span><br></pre></td></tr></table></figure>

<p>index dives，优化器在范围的两端进行dives, 可以帮助优化器更准确的评估扫描的行数，index dives提供了更准确的行估计，但是随着比较值数量的增加，更加耗时，使用统计信息的准确性不如index dives，但允许对大值列表进行更快的行估计。</p>
<p>eq_range_index_dive_limit系统变量使您能够配置优化器从一个行估计策略切换到另一个行估计策略时的值数量。要允许使用索引潜水来比较最多N个相等范围，请将eq_range_index_dive_limit设置为N+ 1。要禁用统计信息并始终使用索引潜水而不管N，请将eq_range_index_dive_limit设置为0。</p>
<p>若要更新表索引统计信息以获得最佳估计值，请使用ANALYZE TABLE。</p>
<p>skip scan,比如有索引(f1,f2)，都知道最左前缀原则，所以一般where f2 &gt; 40是不走索引的，skip scan可以让他走索引，通过构造f1 &#x3D; 1 and f2 &gt; 40，扫描完以后再扫描 f1 &#x3D; 2 and f2 &gt; 40，以此类推，可以通过explain来看extra列是否有skip scan</p>
<p>in优化，in查询可以用如下形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FROM t1 WHERE ( col_1, col_2 ) IN (( &#x27;a&#x27;, &#x27;b&#x27; ), ( &#x27;c&#x27;, &#x27;d&#x27; ));</span><br></pre></td></tr></table></figure>

<p>range_optimizer_max_size_size系统变量可以设置优化器使用的内存</p>
<h4 id="index-merge-优化"><a href="#index-merge-优化" class="headerlink" title="index merge 优化"></a>index merge 优化</h4><p>index merge就是多个索引并发扫描，再将扫描结果合并</p>
<p>索引合并不适用于全文索引。</p>
<p>索引合并访问方法检索具有多个范围扫描的行，并将其结果合并为一个。此访问方法只合并单个表的索引扫描，而不合并多个表的扫描。合并可以产生其底层扫描的并集、交集或交集的并集。</p>
<p>可以使用索引合并的查询示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tbl_name WHERE key1 = 10 OR key2 = 20;</span><br><span class="line"></span><br><span class="line">SELECT * FROM tbl_name</span><br><span class="line">  WHERE (key1 = 10 OR key2 = 20) AND non_key = 30;</span><br><span class="line"></span><br><span class="line">SELECT * FROM t1, t2</span><br><span class="line">  WHERE (t1.key1 IN (1,2) OR t1.key2 LIKE &#x27;value%&#x27;)</span><br><span class="line">  AND t2.key1 = t1.some_col;</span><br><span class="line"></span><br><span class="line">SELECT * FROM t1, t2</span><br><span class="line">  WHERE t1.key1 = 1</span><br><span class="line">  AND (t2.key1 = t1.some_col OR t2.key2 = t1.some_col2);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你的查询有一个带有深度AND&#x2F;OR嵌套的复杂WHERE子句，并且MySQL没有选择最佳计划，请尝试使用以下恒等转换来分发术语：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(x AND y) OR z =&gt; (x OR z) AND (y OR z)</span><br><span class="line">(x OR y) AND z =&gt; (x AND z) OR (y AND z)</span><br></pre></td></tr></table></figure>

<p>在EXPLAIN输出中，Index Merge方法在type列中显示为index_merge。在本例中，key列包含使用的索引列表，key_len包含这些索引的最长键部分列表。</p>
<p>索引合并访问方法有几种算法，它们显示在EXPLAIN输出的Extra字段中：</p>
<ul>
<li>intersect：对多个and条件生效</li>
<li>union：对多个or条件生效</li>
<li>sort_union：sort-union算法和union算法之间的区别在于，sort-union算法必须首先获取所有行的行ID，并在返回任何行之前对其进行排序。</li>
</ul>
<p>索引合并的使用取决于optimizer_switch系统变量的index_merge、index_merge_intersection、index_merge_union和index_merge_sort_union标志的值。默认情况下，所有这些标志都是打开的。</p>
<h4 id="hash-join"><a href="#hash-join" class="headerlink" title="hash join"></a>hash join</h4><p>默认情况下，MySQL尽可能使用哈希连接。可以使用BNL和NO_BNL优化器提示之一来控制是否使用散列连接。</p>
<p>hash join比嵌套join快的多，首先创建hash表，在循环另一个表进行hash，判断是否相等</p>
<p>可以使用join_buffer_size系统变量控制哈希连接的内存使用量;哈希连接使用的内存量不能超过此值。当哈希连接所需的内存超过可用量时，MySQL会使用磁盘上的文件来处理。如果发生这种情况，您应该注意，如果哈希连接无法容纳内存并且它创建的文件比为open_files_limit设置的文件多，则连接可能不会成功。要避免此类问题，请进行以下更改之一：</p>
<ul>
<li>增加join_buffer_size，使哈希连接不会溢出到磁盘。</li>
<li>增加open_files_limit。</li>
</ul>
<h4 id="成本模型"><a href="#成本模型" class="headerlink" title="成本模型"></a>成本模型</h4><p>MySQL成本模型（Cost Model）是MySQL查询优化器（Query Optimizer）用来评估不同查询执行计划的成本（Cost）的一种机制。成本模型通过估算每种执行计划所需的资源（如CPU、I&#x2F;O、内存等）来选择最优的执行计划。</p>
<p>MySQL的成本模型主要考虑以下几个方面：</p>
<ol>
<li>CPU成本：<ul>
<li>评估执行计划中每个操作（如比较、计算、排序等）所需的CPU时间。</li>
<li>例如，WHERE子句中的条件计算、JOIN操作中的匹配等。</li>
</ul>
</li>
<li>I&#x2F;O成本：<ul>
<li>评估执行计划中每个操作所需的磁盘I&#x2F;O操作次数。</li>
<li>例如，全表扫描、索引扫描、数据页的读取等。</li>
<li>I&#x2F;O成本通常是最主要的成本因素之一，因为磁盘I&#x2F;O操作相对较慢。</li>
</ul>
</li>
<li>内存成本：<ul>
<li>评估执行计划中每个操作所需的内存使用量。</li>
<li>例如，排序操作、临时表的创建等。</li>
</ul>
</li>
<li>网络成本：<ul>
<li>评估执行计划中每个操作所需的网络传输量。</li>
<li>例如，分布式查询中跨节点的数据传输。</li>
</ul>
</li>
<li>数据分布：<ul>
<li>评估数据的分布情况，如表的大小、索引的覆盖率等。</li>
<li>数据分布会影响I&#x2F;O操作的次数和效率。</li>
</ul>
</li>
</ol>
<p>其中大部分的成本都是固定的，比如CPU成本、IO成本、内存成本。这个是根据你服务器的配置决定的。</p>
<p>所以，主要关注的是数据分布。</p>
<p>MySQL的数据分布使用<code>直方图</code>来记录。</p>
<h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h4><p><code>column_statistics数据字典表</code>存储有关列值的<code>直方图</code>统计信息，供优化器在构造查询执行计划时使用。要执行直方图管理，请使用<code>ANALYZE TABLE</code>语句。</p>
<ul>
<li>该表包含除几何类型（空间数据）和JSON之外的所有数据类型的列的统计信息。</li>
<li>该表是持久的，因此不必在每次服务器启动时都创建列统计信息。</li>
<li>服务器对表执行更新，用户不执行。</li>
</ul>
<p>用户不能直接访问<code>column_statistics</code>表，因为它是<code>数据字典</code>的一部分。直方图信息可使用 <code>INFORMATION_SCHEMA.COLUMN_STATISTICS</code> 获得，它是作为数据字典表上的视图实现的。<code>COLUMN_STATISTICS</code>包含以下列：</p>
<ul>
<li>SCHEMA_NAME、TABLE_NAME、COLUMN_NAME：应用统计信息的模式、表和列的名称。</li>
<li>HISTORIO：描述列统计信息的JSON值，存储为直方图。</li>
</ul>
<p>直方图实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;buckets&quot;: [</span><br><span class="line">    [</span><br><span class="line">      1,</span><br><span class="line">      0.3333333333333333</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      2,</span><br><span class="line">      0.6666666666666666</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      3,</span><br><span class="line">      1</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  &quot;null-values&quot;: 0,</span><br><span class="line">  &quot;last-updated&quot;: &quot;2017-03-24 13:32:40.000000&quot;,</span><br><span class="line">  &quot;sampling-rate&quot;: 1,</span><br><span class="line">  &quot;histogram-type&quot;: &quot;singleton&quot;,</span><br><span class="line">  &quot;number-of-buckets-specified&quot;: 128,</span><br><span class="line">  &quot;data-type&quot;: &quot;int&quot;,</span><br><span class="line">  &quot;collation-id&quot;: 8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>buckets：直方图桶。桶结构取决于直方图类型。</li>
<li>null-values：一个介于0.0和1.0之间的数字，表示<code>SQL NULL</code>值的列值的分数。如果为0，则该列不包含NULL值。</li>
<li>last-updated：直方图生成时，以 <code>YYYY-MM-DD hh:mm:ss.uuuuuu</code> 格式的UTC值表示。</li>
<li>sampling-rate：0.0到1.0之间的数字，表示为创建直方图而采样的数据比例。值为1表示已读取所有数据（无采样）。</li>
<li>histogram-type：直方图类型：<ul>
<li>singleton：一个bucket表示列中的一个值。当列中的非重复值数量小于或等于生成直方图的<code>ANALYZE TABLE</code>语句中指定的存储桶数量时，将创建此直方图类型。</li>
<li>equi-height：一个桶表示一个值范围。当列中的非重复值数量大于生成直方图的<code>ANALYZE TABLE</code>语句中指定的存储桶数量时，将创建此直方图类型。</li>
</ul>
</li>
<li>number-of-buckets-specified：生成直方图的<code>ANALYZE TABLE</code>语句中指定的<code>桶数</code>。</li>
<li>data-type：此直方图包含的数据类型。在将直方图从持久性存储器阅读和解析到内存中时，这是需要的。该值是int、uint（无符号整数）、double、decimal、datetime或string（包括字符和二进制字符串）之一。</li>
<li>collation-id：直方图数据的归类ID。当数据类型值是字符串时，它最有意义。值对应于信息架构<code>COLLATIONS</code>表中的ID列值。</li>
</ul>
<p>直方图统计信息主要用于非索引列。将索引添加到直方图统计信息适用的列还可以帮助优化器进行行估计。</p>
<p>优化器更喜欢范围优化器的行估计，而不是从直方图统计信息中获得的行估计。如果优化器确定范围优化器适用，则不使用直方图统计信息。</p>
<p>对于已建立索引的列，可以使用索引潜水(index dives)获得行估计值以进行相等比较。</p>
<p>在某些情况下，使用直方图统计信息可能不会改善查询执行（例如，如果统计信息过期）。要检查是否是这种情况，请使用<code>ANALYZE TABLE</code>重新生成直方图统计信息，然后再次运行查询。</p>
<p>这么看这些概念内容，可能很难理解直方图到底是干啥的，下面给出一个例子方便理解。</p>
<h5 id="直方图示例"><a href="#直方图示例" class="headerlink" title="直方图示例"></a>直方图示例</h5><h2 id="虽然直方图的字段很多，但其核心的字段只有几个"><a href="#虽然直方图的字段很多，但其核心的字段只有几个" class="headerlink" title="虽然直方图的字段很多，但其核心的字段只有几个"></a>虽然直方图的字段很多，但其核心的字段只有几个</h2><p>创建一个测试表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_a(id <span class="type">int</span> auto_increment,a <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span>, b <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>, <span class="keyword">primary</span> key(id));</span><br></pre></td></tr></table></figure>

<p>接下来我们插入几个数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_a (a, b) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;A1&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;B2&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;C3&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;D4&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;E5&#x27;</span>),</span><br><span class="line">(<span class="number">6</span>, <span class="string">&#x27;F6&#x27;</span>),</span><br><span class="line">(<span class="number">7</span>, <span class="string">&#x27;G7&#x27;</span>),</span><br><span class="line">(<span class="number">8</span>, <span class="string">&#x27;H8&#x27;</span>),</span><br><span class="line">(<span class="number">9</span>, <span class="string">&#x27;I9&#x27;</span>),</span><br><span class="line">(<span class="number">10</span>, <span class="string">&#x27;J10&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>接下来生成直方图信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE <span class="keyword">TABLE</span> test_a <span class="keyword">update</span>  HISTOGRAM <span class="keyword">ON</span> a <span class="keyword">WITH</span> <span class="number">5</span> BUCKETS;</span><br></pre></td></tr></table></figure>

<p>查询直方图信息。这里的<code>SCHEMA_NAME</code>是数据库的名称，TABLE_NAME是数据表的名称。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.COLUMN_STATISTICS <span class="keyword">where</span> SCHEMA_NAME <span class="operator">=</span> <span class="string">&#x27;test1&#x27;</span> <span class="keyword">and</span> TABLE_NAME <span class="operator">=</span> <span class="string">&#x27;test_a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>查询结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+-------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> SCHEMA_NAME <span class="operator">|</span> TABLE_NAME <span class="operator">|</span> COLUMN_NAME <span class="operator">|</span> HISTOGRAM</span><br><span class="line">                                                                                                                                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+-------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> test1       <span class="operator">|</span> test_a     <span class="operator">|</span> a           <span class="operator">|</span> &#123;&quot;buckets&quot;: [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0.2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">0.4</span>, <span class="number">2</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">0.6</span>, <span class="number">2</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">0.8</span>, <span class="number">2</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">1.0</span>, <span class="number">2</span>]], &quot;data-type&quot;: &quot;int&quot;, &quot;auto-update&quot;: <span class="literal">false</span>, &quot;null-values&quot;: <span class="number">0.0</span>, &quot;collation-id&quot;: <span class="number">8</span>, &quot;last-updated&quot;: &quot;2025-01-25 13:01:57.129967&quot;, &quot;sampling-rate&quot;: <span class="number">1.0</span>, &quot;histogram-type&quot;: &quot;equi-height&quot;, &quot;number-of-buckets-specified&quot;: <span class="number">5</span>&#125; <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+-------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>我们来看一下直方图的信息。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;buckets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">0.4</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">0.6</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">7</span><span class="punctuation">,</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">9</span><span class="punctuation">,</span> <span class="number">10</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;data-type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;int&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;auto-update&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;null-values&quot;</span><span class="punctuation">:</span> <span class="number">0.0</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;collation-id&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;last-updated&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2025-01-25 13:01:57.129967&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;sampling-rate&quot;</span><span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;histogram-type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;equi-height&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;number-of-buckets-specified&quot;</span><span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>buckets：直方图桶。桶结构取决于直方图类型。</li>
<li>null-values：0.0,表示没有null值，这是因为我们使用了<code>not null</code>声明字段。</li>
<li>last-updated：更新时间，没啥好说的。</li>
<li>sampling-rate：1.0 获取了所有数据，因为我们只有10条数据，很少。</li>
<li>histogram-type：直方图类型：equi-height，因为<code>a</code>列有10个值，都不重复，而桶数量我们用的是5，所以生成了这个类型。</li>
<li>number-of-buckets-specified：生成直方图的<code>ANALYZE TABLE</code>语句中指定的<code>桶数</code>。</li>
<li>data-type：列a是int类型</li>
<li>collation-id：直方图数据的归类ID。当数据类型值是字符串时，它最有意义。值对应于信息架构<code>COLLATIONS</code>表中的ID列值。</li>
</ul>
<p>桶里面有4个数据</p>
<ul>
<li>最小值</li>
<li>最大值</li>
<li>密度</li>
<li>高度</li>
</ul>
<p>比如，查询语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_a <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><code>a = 5</code>的数据在第三个桶里面，最小值5，最大值6，密度0.6，高度2.</p>
<p>根据计算公式<code>预估行数 = 密度 * 高度</code>来计算0.6 * 2，预估行数就是1.2，也就是1-2行。</p>
<p><img src="/../images/mysql/mysql2-6.jpg" alt="架构"></p>
<p>可以看到查询计划里面的rows是10行，这是因为类型是全表扫描，但是后面的<code>filtered</code>字段是10，表示的意思是会过滤出来 <code>10 * 10% = 10 * 0.1 = 1</code>行。</p>
<p>也就是最终会查出1行结果。</p>
<p>通常来说，对于没有索引的列，MySQL就是这样来预估行数的，并且通过这个结果来进行选择执行路线。</p>
<h3 id="执行路线选择"><a href="#执行路线选择" class="headerlink" title="执行路线选择"></a>执行路线选择</h3><p>什么叫路线选择呢，还是上面那个表，我们现在有如下SQL语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,b <span class="keyword">from</span> test_a <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> b <span class="operator">=</span> <span class="string">&#x27;A1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>根据表数据，其实我们知道，查出来的结果还是1条。但是对于mysql来说，却有不同的执行方式。</p>
<p>第一种执行方式，先查<code>a=1</code>在查询<code>b=&#39;A1&#39;</code>的数据。执行树如下。</p>
<p><img src="/../images/mysql/mysql2-7.jpg" alt="架构"></p>
<p>第二种执行方式，先查<code>b=&#39;A1&#39;</code>在查询 <code>a=1</code>。执行树如下。</p>
<p><img src="/../images/mysql/mysql2-8.jpg" alt="架构"></p>
<p>目前看着这两种方式都没啥问题。</p>
<p>但是，我们再插入一条数据呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_a (a, b) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">11</span>, <span class="string">&#x27;A1&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这样我们就知道了，方案1， 会直接过滤出1行数据，然后在过滤，这样显然比方案2更好。</p>
<p>因为方案2会先查出2条数据，再次过滤。</p>
<p>这就是不同的执行路线带来的性能区别。当然了，我们这里的例子只是打个比方，实际上<code>谓词下推</code>优化以后，这两个条件都是和扫描表一起执行的。</p>
<p>这个例子只是让你明白不同的路线选择而已。</p>
<p>对于<code>join</code>查询来说，会有更多的选择。</p>
<h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>以上就是今天的内容了，大家有任何疑问可以打在评论区，一起交流～</p>
<p>关注我发送“MySQL知识图谱”领取完整的MySQL学习路线。</p>
<p>发送“电子书”即可领取价值上千的电子书资源。</p>
<p>部分电子书如图所示。</p>
<p><img src="/../images/bottom1.png" alt="概念学习"></p>
<p><img src="/../images/bottom2.png" alt="概念学习"></p>
<p><img src="/../images/bottom3.png" alt="概念学习"></p>
<p><img src="/../images/bottom4.png" alt="概念学习"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9.html" class="post-title-link" itemprop="url">MySQL查询路径选择</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-26 10:12:47" itemprop="dateCreated datePublished" datetime="2023-04-26T10:12:47+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 11:36:22" itemprop="dateModified" datetime="2025-01-26T11:36:22+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span id="/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9.html" class="post-meta-item leancloud_visitors" data-flag-title="MySQL查询路径选择" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL查询路径选择"><a href="#MySQL查询路径选择" class="headerlink" title="MySQL查询路径选择"></a>MySQL查询路径选择</h1><p>大家好，我是大头，98年，职高毕业，上市公司架构师，大厂资深开发，管理过10人团队，我是如何做到的呢？</p>
<p>这离不开持续学习的能力，而其中最重要的当然是数据库技术了！</p>
<p>对于所有开发来说，都离不开数据库，因为所有的数据都是要存储的。</p>
<p>关注我一起学习！文末有惊喜哦！</p>
<h2 id="什么是MySQL查询路径？"><a href="#什么是MySQL查询路径？" class="headerlink" title="什么是MySQL查询路径？"></a>什么是MySQL查询路径？</h2><p>MySQL查询路径是指查询优化器在执行查询时所选择的具体执行步骤和顺序。查询优化器的目标是找到最高效的方式来执行查询，以最小化资源消耗（如CPU、I&#x2F;O、内存等）和查询响应时间。查询路径包括以下几个关键阶段：</p>
<ol>
<li>解析（Parsing）：</li>
</ol>
<ul>
<li>将SQL语句解析成内部的逻辑结构，如语法树（Syntax Tree）。</li>
<li>检查SQL语句的语法是否正确。</li>
</ul>
<ol start="2">
<li>预处理（Preprocessing）：</li>
</ol>
<ul>
<li>检查用户是否有权限执行该查询。</li>
<li>检查表和列是否存在。</li>
<li>重写查询，如展开视图、处理子查询等。</li>
</ul>
<ol start="3">
<li>优化（Optimization）：</li>
</ol>
<ul>
<li>查询优化器评估不同的执行计划，选择最优的执行路径。</li>
<li>优化器会考虑索引、表的大小、数据分布等因素。</li>
<li>生成执行计划，决定如何访问表、如何连接表、如何过滤数据等。</li>
</ul>
<ol start="4">
<li>执行（Execution）：</li>
</ol>
<ul>
<li>按照优化器生成的执行计划，实际执行查询。</li>
<li>包括表扫描、索引扫描、连接操作、过滤操作等。</li>
</ul>
<ol start="5">
<li>结果返回（Result Returning）：</li>
</ol>
<ul>
<li>将查询结果返回给客户端。</li>
</ul>
<h3 id="查询路径的详细分析"><a href="#查询路径的详细分析" class="headerlink" title="查询路径的详细分析"></a>查询路径的详细分析</h3><ol>
<li>解析（Parsing）</li>
</ol>
<p>解析阶段将SQL语句转换为内部的逻辑结构。例如，对于查询SELECT a, b FROM test_a WHERE a &#x3D; 1 AND b &#x3D; ‘A1’;，解析器会将其解析为一个查询树，包含以下信息：</p>
<ul>
<li>查询类型：SELECT</li>
<li>查询的列：a, b</li>
<li>查询的表：test_a</li>
<li>查询的条件：a &#x3D; 1 AND b &#x3D; ‘A1’</li>
</ul>
<ol start="2">
<li>预处理（Preprocessing）</li>
</ol>
<p>预处理阶段会检查用户是否有权限执行该查询，表和列是否存在，以及是否需要重写查询。例如：</p>
<ul>
<li>如果test_a表不存在，查询会失败。</li>
<li>如果用户没有权限访问test_a表，查询会失败。</li>
<li>如果查询中包含子查询或视图，预处理器会将其展开。</li>
</ul>
<ol start="3">
<li>优化（Optimization）</li>
</ol>
<p>优化阶段是查询路径中最关键的部分。查询优化器会评估不同的执行计划，选择最优的执行路径。优化器考虑的因素包括：</p>
<ul>
<li>索引：是否有可用的索引，以及索引是否能有效过滤数据。</li>
<li>表的大小：表的大小会影响全表扫描的成本。</li>
<li>数据分布：数据的分布情况会影响过滤条件的效率。</li>
<li>连接顺序：如果有多个表连接，优化器会决定最佳的连接顺序。</li>
</ul>
<p>优化器会生成一个执行计划，描述如何执行查询。例如，对于查询SELECT a, b FROM test_a WHERE a &#x3D; 1 AND b &#x3D; ‘A1’;，优化器可能会生成以下执行计划：</p>
<ul>
<li>使用a列上的索引idx_a来定位满足条件a &#x3D; 1的行。</li>
<li>在这些行中进一步过滤满足条件b &#x3D; ‘A1’的行。</li>
</ul>
<ol start="4">
<li>执行（Execution）</li>
</ol>
<p>执行阶段按照优化器生成的执行计划，实际执行查询。例如：</p>
<ul>
<li>如果优化器选择使用a列上的索引idx_a，执行器会先扫描索引，找到满足条件a &#x3D; 1的行。</li>
<li>然后在这些行中进一步过滤满足条件b &#x3D; ‘A1’的行。</li>
<li>最终将结果返回给客户端。</li>
</ul>
<ol start="5">
<li>结果返回（Result Returning）</li>
</ol>
<p>执行器将查询结果返回给客户端。客户端可以是MySQL客户端工具、应用程序等。</p>
<h3 id="mysql架构"><a href="#mysql架构" class="headerlink" title="mysql架构"></a>mysql架构</h3><p>这里就要介绍一下MySQL的整体架构了。</p>
<p><img src="/../images/mysql/mysql2-1.png" alt="架构"></p>
<ul>
<li>连接器：MySQL连接器（MySQL Connector）是用于连接MySQL数据库的客户端库，它允许应用程序与MySQL数据库进行通信。这些连接器提供了API（应用程序编程接口），使得开发者可以在各种编程语言中轻松地执行SQL语句、管理数据库连接、处理查询结果等。</li>
<li>分析器：MySQL分析器才算真正进入了MySQL里面。它会分析词法和语法，如果你的SQL语句不对，就会看到一些报错，例如语法错误。</li>
<li>优化器：MySQL优化器是本文的重点内容，因为这里涉及了MySQL的一些优化，其中就包括了索引选择，也是导致索引失效的重要原因。在这一步也就确定了查询计划。</li>
<li>执行器：MySQL执行器会根据优化器输出的查询计划来执行这个查询计划，会调用底层的存储引擎进行执行。</li>
<li>存储引擎：MySQL支持多种存储引擎，每个存储引擎有不同的特点。其中InnoDB引擎因为支持事务等优点，现在是MySQL的默认存储引擎。</li>
</ul>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>MySQL连接器（MySQL Connector）是用于连接MySQL数据库的客户端库，它允许应用程序与MySQL数据库进行通信。这些连接器提供了API（应用程序编程接口），使得开发者可以在各种编程语言中轻松地执行SQL语句、管理数据库连接、处理查询结果等。</p>
<p>当我们最开始连接数据库实例的时候，我们要输入用户名密码，这时候连接器会从数据库的用户信息中判断你是否有权限连接数据库进行操作，有哪些权限。</p>
<p>如果你输入的用户名密码错误或者没有权限，那么你会收到下面的报错信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access denied <span class="keyword">for</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>(<span class="keyword">using</span> password: YES)</span><br></pre></td></tr></table></figure>

<p><img src="/../images/mysql/mysql2-2.png" alt="架构"></p>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>连接成功以后。分析器会分析这个语句的词法，语法，语义这些信息。</p>
<p>通俗来讲就是看到select,update这些关键字，知道你要来干啥，看看你是不是来搞破坏的，来捣蛋的。</p>
<p>看看你是查询哪个表啊，有什么条件啊，这些玩意。</p>
<p>最后会输出一个词法树。</p>
<p>当然了这一步还会分析你的语法有没有错误，比如你把select打错试试。打成elect，会出现下面的报错信息</p>
<blockquote>
<p>You have an error in your SQL syntax: check the maual that corresponds to your MySQL server version for the right syntax to use near ‘elect * from users’ at line 1</p>
</blockquote>
<p><img src="/../images/mysql/mysql2-3.png" alt="架构"></p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>优化器负责几个事情</p>
<ul>
<li>优化SQL：比如你写了一个很不友好的SQL，如<code>select * from a where 1 =1</code>,优化器会将1&#x3D;1去掉。还有比如括号的删除，如<code>select * from a where ((a AND b) AND c OR (((a AND b) AND (c AND d))))</code>改写成<code>select * from a where (a AND b AND c) OR (a AND b AND c AND d)</code>。等等。</li>
<li>一些内部的优化器：下面列出的是部分，更多的可以参考<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/optimization.html">MySQL官方文档优化器部分</a><ul>
<li>谓词下推：即where条件下推到扫描表的时候执行，而不是扫描表之后执行。</li>
<li>范围优化：对于BTREE和HASH索引，当使用&#x3D;、&lt;&#x3D;&gt;、IN（）、IS NULL或IS NOT NULL运算符时，键部分与常量值的比较是范围条件。此外，对于BTREE索引，当使用&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，BETWEEN，！&#x3D; 、或&lt;&gt;运算符，或者LIKE比较（如果LIKE的参数是不以小写字符开头的常量字符串）。对于所有索引类型，多个范围条件与OR或AND组合形成范围条件。</li>
<li>index merge优化：index merge就是多个索引并发扫描，再将扫描结果合并。</li>
<li>hash join优化：使用hash join来代替Nested Loop Join算法，能大幅度提升join速度。</li>
<li>Is Null优化：可以对<code>where a is null</code>这种条件进行优化，比如该字段设置了<code>not null</code>，那么这个条件就会被删除。</li>
<li>order by + limit优化：使用<code>Top N</code>排序</li>
<li>group by 优化：优化group by语句。</li>
<li>子查询物化：将子查询的内容物化保存起来。</li>
</ul>
</li>
<li>通过成本模型、直方图等信息生成不同的执行路径。</li>
<li>对比执行路径的内容，如取样等，进行选择最终的执行路径。生成查询计划。</li>
</ul>
<p>这里简单的介绍一些mysql内部的优化器，以了解mysql内部做了哪些优化手段。</p>
<p>最后会介绍mysql的成本模型、直方图信息等。结合实际的例子来给大家展示索引选择的问题。</p>
<h4 id="谓词下推优化"><a href="#谓词下推优化" class="headerlink" title="谓词下推优化"></a>谓词下推优化</h4><p>谓词下推优化（Predicate Pushdown Optimization）是一种查询优化技术，它将查询中的过滤条件（谓词）尽可能地推送到数据访问的早期阶段，以减少数据扫描的范围，从而提高查询性能。<br>在数据库查询中，谓词通常是指WHERE子句中的条件。谓词下推优化的目的是让这些条件在数据被读取或处理的早期阶段就发挥作用，避免不必要的数据处理和传输。</p>
<p>在没有谓词下推优化的情况下，数据库会先读取所有数据，然后在内存中应用过滤条件。这可能导致大量的数据被加载到内存中，增加了I&#x2F;O操作和内存使用。<br>通过谓词下推优化，数据库会在数据读取阶段就应用过滤条件，只加载满足条件的数据，从而减少数据的读取量和处理量。</p>
<p>假设存在<code>table_a</code>表，表里面有10条数据，<code>a = 1</code>的数据有一个，具体什么意思呢，我们来看一个SQL语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,b <span class="keyword">from</span> table_a <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>如果没有谓词下推优化的话，执行树如下。</p>
<p><img src="/../images/mysql/mysql2-4.png" alt="架构"></p>
<p>其执行顺序如下：</p>
<ol>
<li>扫描<code>table_a</code>表的10条数据，将10条数据传递给where过滤节点。</li>
<li>where过滤操作进行过滤，过滤出<code>a = 1</code>条件的1条数据，将这个数据传递给列选择节点。</li>
<li>列选择节点选择这条数据的2列，将结果返回。</li>
</ol>
<p>其内存中要存储10条数据。</p>
<p>而有了谓词下推优化以后，执行树如下。</p>
<p><img src="/../images/mysql/mysql2-5.png" alt="架构"></p>
<p>执行顺序如下：</p>
<ol>
<li>扫描<code>table_a</code>表的10条数据，过滤出符合<code>a = 1</code>条件的这一个数据。将这个数据传给列选择节点。</li>
<li>列选择节点选择这条数据的2列，将结果返回。</li>
</ol>
<h4 id="范围优化"><a href="#范围优化" class="headerlink" title="范围优化"></a>范围优化</h4><p>对于BTREE和HASH索引，当使用&#x3D;、&lt;&#x3D;&gt;、IN（）、IS NULL或IS NOT NULL运算符时，键部分与常量值的比较是范围条件。此外，对于BTREE索引，当使用&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，BETWEEN，！&#x3D; 、或&lt;&gt;运算符，或者LIKE比较（如果LIKE的参数是不以小写字符开头的常量字符串）。对于所有索引类型，多个范围条件与OR或AND组合形成范围条件。</p>
<p>给定数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">key_part1  key_part2  key_part3</span><br><span class="line">  NULL       1          &#x27;abc&#x27;</span><br><span class="line">  NULL       1          &#x27;xyz&#x27;</span><br><span class="line">  NULL       2          &#x27;foo&#x27;</span><br><span class="line">   1         1          &#x27;abc&#x27;</span><br><span class="line">   1         1          &#x27;xyz&#x27;</span><br><span class="line">   1         2          &#x27;abc&#x27;</span><br><span class="line">   2         1          &#x27;aaa&#x27;</span><br></pre></td></tr></table></figure>

<p>执行where key_part1&#x3D; 1，其扫描范围为 1,负无穷，负无穷到 1,正无穷，正无穷</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1,-inf,-inf) &lt;= (key_part1,key_part2,key_part3) &lt; (1,+inf,+inf)</span><br></pre></td></tr></table></figure>
<p>即覆盖了这三行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1         1          &#x27;abc&#x27;</span><br><span class="line">1         1          &#x27;xyz&#x27;</span><br><span class="line">1         2          &#x27;abc&#x27;</span><br></pre></td></tr></table></figure>

<p>index dives，优化器在范围的两端进行dives, 可以帮助优化器更准确的评估扫描的行数，index dives提供了更准确的行估计，但是随着比较值数量的增加，更加耗时，使用统计信息的准确性不如index dives，但允许对大值列表进行更快的行估计。</p>
<p>eq_range_index_dive_limit系统变量使您能够配置优化器从一个行估计策略切换到另一个行估计策略时的值数量。要允许使用索引潜水来比较最多N个相等范围，请将eq_range_index_dive_limit设置为N+ 1。要禁用统计信息并始终使用索引潜水而不管N，请将eq_range_index_dive_limit设置为0。</p>
<p>若要更新表索引统计信息以获得最佳估计值，请使用ANALYZE TABLE。</p>
<p>skip scan,比如有索引(f1,f2)，都知道最左前缀原则，所以一般where f2 &gt; 40是不走索引的，skip scan可以让他走索引，通过构造f1 &#x3D; 1 and f2 &gt; 40，扫描完以后再扫描 f1 &#x3D; 2 and f2 &gt; 40，以此类推，可以通过explain来看extra列是否有skip scan</p>
<p>in优化，in查询可以用如下形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FROM t1 WHERE ( col_1, col_2 ) IN (( &#x27;a&#x27;, &#x27;b&#x27; ), ( &#x27;c&#x27;, &#x27;d&#x27; ));</span><br></pre></td></tr></table></figure>

<p>range_optimizer_max_size_size系统变量可以设置优化器使用的内存</p>
<h4 id="index-merge-优化"><a href="#index-merge-优化" class="headerlink" title="index merge 优化"></a>index merge 优化</h4><p>index merge就是多个索引并发扫描，再将扫描结果合并</p>
<p>索引合并不适用于全文索引。</p>
<p>索引合并访问方法检索具有多个范围扫描的行，并将其结果合并为一个。此访问方法只合并单个表的索引扫描，而不合并多个表的扫描。合并可以产生其底层扫描的并集、交集或交集的并集。</p>
<p>可以使用索引合并的查询示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tbl_name WHERE key1 = 10 OR key2 = 20;</span><br><span class="line"></span><br><span class="line">SELECT * FROM tbl_name</span><br><span class="line">  WHERE (key1 = 10 OR key2 = 20) AND non_key = 30;</span><br><span class="line"></span><br><span class="line">SELECT * FROM t1, t2</span><br><span class="line">  WHERE (t1.key1 IN (1,2) OR t1.key2 LIKE &#x27;value%&#x27;)</span><br><span class="line">  AND t2.key1 = t1.some_col;</span><br><span class="line"></span><br><span class="line">SELECT * FROM t1, t2</span><br><span class="line">  WHERE t1.key1 = 1</span><br><span class="line">  AND (t2.key1 = t1.some_col OR t2.key2 = t1.some_col2);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你的查询有一个带有深度AND&#x2F;OR嵌套的复杂WHERE子句，并且MySQL没有选择最佳计划，请尝试使用以下恒等转换来分发术语：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(x AND y) OR z =&gt; (x OR z) AND (y OR z)</span><br><span class="line">(x OR y) AND z =&gt; (x AND z) OR (y AND z)</span><br></pre></td></tr></table></figure>

<p>在EXPLAIN输出中，Index Merge方法在type列中显示为index_merge。在本例中，key列包含使用的索引列表，key_len包含这些索引的最长键部分列表。</p>
<p>索引合并访问方法有几种算法，它们显示在EXPLAIN输出的Extra字段中：</p>
<ul>
<li>intersect：对多个and条件生效</li>
<li>union：对多个or条件生效</li>
<li>sort_union：sort-union算法和union算法之间的区别在于，sort-union算法必须首先获取所有行的行ID，并在返回任何行之前对其进行排序。</li>
</ul>
<p>索引合并的使用取决于optimizer_switch系统变量的index_merge、index_merge_intersection、index_merge_union和index_merge_sort_union标志的值。默认情况下，所有这些标志都是打开的。</p>
<h4 id="hash-join"><a href="#hash-join" class="headerlink" title="hash join"></a>hash join</h4><p>默认情况下，MySQL尽可能使用哈希连接。可以使用BNL和NO_BNL优化器提示之一来控制是否使用散列连接。</p>
<p>hash join比嵌套join快的多，首先创建hash表，在循环另一个表进行hash，判断是否相等</p>
<p>可以使用join_buffer_size系统变量控制哈希连接的内存使用量;哈希连接使用的内存量不能超过此值。当哈希连接所需的内存超过可用量时，MySQL会使用磁盘上的文件来处理。如果发生这种情况，您应该注意，如果哈希连接无法容纳内存并且它创建的文件比为open_files_limit设置的文件多，则连接可能不会成功。要避免此类问题，请进行以下更改之一：</p>
<ul>
<li>增加join_buffer_size，使哈希连接不会溢出到磁盘。</li>
<li>增加open_files_limit。</li>
</ul>
<h4 id="成本模型"><a href="#成本模型" class="headerlink" title="成本模型"></a>成本模型</h4><p>MySQL成本模型（Cost Model）是MySQL查询优化器（Query Optimizer）用来评估不同查询执行计划的成本（Cost）的一种机制。成本模型通过估算每种执行计划所需的资源（如CPU、I&#x2F;O、内存等）来选择最优的执行计划。</p>
<p>MySQL的成本模型主要考虑以下几个方面：</p>
<ol>
<li>CPU成本：<ul>
<li>评估执行计划中每个操作（如比较、计算、排序等）所需的CPU时间。</li>
<li>例如，WHERE子句中的条件计算、JOIN操作中的匹配等。</li>
</ul>
</li>
<li>I&#x2F;O成本：<ul>
<li>评估执行计划中每个操作所需的磁盘I&#x2F;O操作次数。</li>
<li>例如，全表扫描、索引扫描、数据页的读取等。</li>
<li>I&#x2F;O成本通常是最主要的成本因素之一，因为磁盘I&#x2F;O操作相对较慢。</li>
</ul>
</li>
<li>内存成本：<ul>
<li>评估执行计划中每个操作所需的内存使用量。</li>
<li>例如，排序操作、临时表的创建等。</li>
</ul>
</li>
<li>网络成本：<ul>
<li>评估执行计划中每个操作所需的网络传输量。</li>
<li>例如，分布式查询中跨节点的数据传输。</li>
</ul>
</li>
<li>数据分布：<ul>
<li>评估数据的分布情况，如表的大小、索引的覆盖率等。</li>
<li>数据分布会影响I&#x2F;O操作的次数和效率。</li>
</ul>
</li>
</ol>
<p>其中大部分的成本都是固定的，比如CPU成本、IO成本、内存成本。这个是根据你服务器的配置决定的。</p>
<p>所以，主要关注的是数据分布。</p>
<p>MySQL的数据分布使用<code>直方图</code>来记录。</p>
<h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h4><p><code>column_statistics数据字典表</code>存储有关列值的<code>直方图</code>统计信息，供优化器在构造查询执行计划时使用。要执行直方图管理，请使用<code>ANALYZE TABLE</code>语句。</p>
<ul>
<li>该表包含除几何类型（空间数据）和JSON之外的所有数据类型的列的统计信息。</li>
<li>该表是持久的，因此不必在每次服务器启动时都创建列统计信息。</li>
<li>服务器对表执行更新，用户不执行。</li>
</ul>
<p>用户不能直接访问<code>column_statistics</code>表，因为它是<code>数据字典</code>的一部分。直方图信息可使用 <code>INFORMATION_SCHEMA.COLUMN_STATISTICS</code> 获得，它是作为数据字典表上的视图实现的。<code>COLUMN_STATISTICS</code>包含以下列：</p>
<ul>
<li>SCHEMA_NAME、TABLE_NAME、COLUMN_NAME：应用统计信息的模式、表和列的名称。</li>
<li>HISTORIO：描述列统计信息的JSON值，存储为直方图。</li>
</ul>
<p>直方图实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;buckets&quot;: [</span><br><span class="line">    [</span><br><span class="line">      1,</span><br><span class="line">      0.3333333333333333</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      2,</span><br><span class="line">      0.6666666666666666</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      3,</span><br><span class="line">      1</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  &quot;null-values&quot;: 0,</span><br><span class="line">  &quot;last-updated&quot;: &quot;2017-03-24 13:32:40.000000&quot;,</span><br><span class="line">  &quot;sampling-rate&quot;: 1,</span><br><span class="line">  &quot;histogram-type&quot;: &quot;singleton&quot;,</span><br><span class="line">  &quot;number-of-buckets-specified&quot;: 128,</span><br><span class="line">  &quot;data-type&quot;: &quot;int&quot;,</span><br><span class="line">  &quot;collation-id&quot;: 8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>buckets：直方图桶。桶结构取决于直方图类型。</li>
<li>null-values：一个介于0.0和1.0之间的数字，表示<code>SQL NULL</code>值的列值的分数。如果为0，则该列不包含NULL值。</li>
<li>last-updated：直方图生成时，以 <code>YYYY-MM-DD hh:mm:ss.uuuuuu</code> 格式的UTC值表示。</li>
<li>sampling-rate：0.0到1.0之间的数字，表示为创建直方图而采样的数据比例。值为1表示已读取所有数据（无采样）。</li>
<li>histogram-type：直方图类型：<ul>
<li>singleton：一个bucket表示列中的一个值。当列中的非重复值数量小于或等于生成直方图的<code>ANALYZE TABLE</code>语句中指定的存储桶数量时，将创建此直方图类型。</li>
<li>equi-height：一个桶表示一个值范围。当列中的非重复值数量大于生成直方图的<code>ANALYZE TABLE</code>语句中指定的存储桶数量时，将创建此直方图类型。</li>
</ul>
</li>
<li>number-of-buckets-specified：生成直方图的<code>ANALYZE TABLE</code>语句中指定的<code>桶数</code>。</li>
<li>data-type：此直方图包含的数据类型。在将直方图从持久性存储器阅读和解析到内存中时，这是需要的。该值是int、uint（无符号整数）、double、decimal、datetime或string（包括字符和二进制字符串）之一。</li>
<li>collation-id：直方图数据的归类ID。当数据类型值是字符串时，它最有意义。值对应于信息架构<code>COLLATIONS</code>表中的ID列值。</li>
</ul>
<p>直方图统计信息主要用于非索引列。将索引添加到直方图统计信息适用的列还可以帮助优化器进行行估计。</p>
<p>优化器更喜欢范围优化器的行估计，而不是从直方图统计信息中获得的行估计。如果优化器确定范围优化器适用，则不使用直方图统计信息。</p>
<p>对于已建立索引的列，可以使用索引潜水(index dives)获得行估计值以进行相等比较。</p>
<p>在某些情况下，使用直方图统计信息可能不会改善查询执行（例如，如果统计信息过期）。要检查是否是这种情况，请使用<code>ANALYZE TABLE</code>重新生成直方图统计信息，然后再次运行查询。</p>
<p>这么看这些概念内容，可能很难理解直方图到底是干啥的，下面给出一个例子方便理解。</p>
<h5 id="直方图示例"><a href="#直方图示例" class="headerlink" title="直方图示例"></a>直方图示例</h5><h2 id="虽然直方图的字段很多，但其核心的字段只有几个"><a href="#虽然直方图的字段很多，但其核心的字段只有几个" class="headerlink" title="虽然直方图的字段很多，但其核心的字段只有几个"></a>虽然直方图的字段很多，但其核心的字段只有几个</h2><p>创建一个测试表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_a(id <span class="type">int</span> auto_increment,a <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span>, b <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>, <span class="keyword">primary</span> key(id));</span><br></pre></td></tr></table></figure>

<p>接下来我们插入几个数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_a (a, b) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;A1&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;B2&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;C3&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;D4&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;E5&#x27;</span>),</span><br><span class="line">(<span class="number">6</span>, <span class="string">&#x27;F6&#x27;</span>),</span><br><span class="line">(<span class="number">7</span>, <span class="string">&#x27;G7&#x27;</span>),</span><br><span class="line">(<span class="number">8</span>, <span class="string">&#x27;H8&#x27;</span>),</span><br><span class="line">(<span class="number">9</span>, <span class="string">&#x27;I9&#x27;</span>),</span><br><span class="line">(<span class="number">10</span>, <span class="string">&#x27;J10&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>接下来生成直方图信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE <span class="keyword">TABLE</span> test_a <span class="keyword">update</span>  HISTOGRAM <span class="keyword">ON</span> a <span class="keyword">WITH</span> <span class="number">5</span> BUCKETS;</span><br></pre></td></tr></table></figure>

<p>查询直方图信息。这里的<code>SCHEMA_NAME</code>是数据库的名称，TABLE_NAME是数据表的名称。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.COLUMN_STATISTICS <span class="keyword">where</span> SCHEMA_NAME <span class="operator">=</span> <span class="string">&#x27;test1&#x27;</span> <span class="keyword">and</span> TABLE_NAME <span class="operator">=</span> <span class="string">&#x27;test_a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>查询结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+-------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> SCHEMA_NAME <span class="operator">|</span> TABLE_NAME <span class="operator">|</span> COLUMN_NAME <span class="operator">|</span> HISTOGRAM</span><br><span class="line">                                                                                                                                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+-------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> test1       <span class="operator">|</span> test_a     <span class="operator">|</span> a           <span class="operator">|</span> &#123;&quot;buckets&quot;: [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0.2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">0.4</span>, <span class="number">2</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">0.6</span>, <span class="number">2</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">0.8</span>, <span class="number">2</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">1.0</span>, <span class="number">2</span>]], &quot;data-type&quot;: &quot;int&quot;, &quot;auto-update&quot;: <span class="literal">false</span>, &quot;null-values&quot;: <span class="number">0.0</span>, &quot;collation-id&quot;: <span class="number">8</span>, &quot;last-updated&quot;: &quot;2025-01-25 13:01:57.129967&quot;, &quot;sampling-rate&quot;: <span class="number">1.0</span>, &quot;histogram-type&quot;: &quot;equi-height&quot;, &quot;number-of-buckets-specified&quot;: <span class="number">5</span>&#125; <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+-------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>我们来看一下直方图的信息。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;buckets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">0.4</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">0.6</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">7</span><span class="punctuation">,</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">9</span><span class="punctuation">,</span> <span class="number">10</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;data-type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;int&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;auto-update&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;null-values&quot;</span><span class="punctuation">:</span> <span class="number">0.0</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;collation-id&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;last-updated&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2025-01-25 13:01:57.129967&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;sampling-rate&quot;</span><span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;histogram-type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;equi-height&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;number-of-buckets-specified&quot;</span><span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>buckets：直方图桶。桶结构取决于直方图类型。</li>
<li>null-values：0.0,表示没有null值，这是因为我们使用了<code>not null</code>声明字段。</li>
<li>last-updated：更新时间，没啥好说的。</li>
<li>sampling-rate：1.0 获取了所有数据，因为我们只有10条数据，很少。</li>
<li>histogram-type：直方图类型：equi-height，因为<code>a</code>列有10个值，都不重复，而桶数量我们用的是5，所以生成了这个类型。</li>
<li>number-of-buckets-specified：生成直方图的<code>ANALYZE TABLE</code>语句中指定的<code>桶数</code>。</li>
<li>data-type：列a是int类型</li>
<li>collation-id：直方图数据的归类ID。当数据类型值是字符串时，它最有意义。值对应于信息架构<code>COLLATIONS</code>表中的ID列值。</li>
</ul>
<p>桶里面有4个数据</p>
<ul>
<li>最小值</li>
<li>最大值</li>
<li>密度</li>
<li>高度</li>
</ul>
<p>比如，查询语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_a <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><code>a = 5</code>的数据在第三个桶里面，最小值5，最大值6，密度0.6，高度2.</p>
<p>根据计算公式<code>预估行数 = 密度 * 高度</code>来计算0.6 * 2，预估行数就是1.2，也就是1-2行。</p>
<p><img src="/../images/mysql/mysql2-6.jpg" alt="架构"></p>
<p>可以看到查询计划里面的rows是10行，这是因为类型是全表扫描，但是后面的<code>filtered</code>字段是10，表示的意思是会过滤出来 <code>10 * 10% = 10 * 0.1 = 1</code>行。</p>
<p>也就是最终会查出1行结果。</p>
<p>通常来说，对于没有索引的列，MySQL就是这样来预估行数的，并且通过这个结果来进行选择执行路线。</p>
<h3 id="执行路线选择"><a href="#执行路线选择" class="headerlink" title="执行路线选择"></a>执行路线选择</h3><p>什么叫路线选择呢，还是上面那个表，我们现在有如下SQL语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,b <span class="keyword">from</span> test_a <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> b <span class="operator">=</span> <span class="string">&#x27;A1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>根据表数据，其实我们知道，查出来的结果还是1条。但是对于mysql来说，却有不同的执行方式。</p>
<p>第一种执行方式，先查<code>a=1</code>在查询<code>b=&#39;A1&#39;</code>的数据。执行树如下。</p>
<p><img src="/../images/mysql/mysql2-7.jpg" alt="架构"></p>
<p>第二种执行方式，先查<code>b=&#39;A1&#39;</code>在查询 <code>a=1</code>。执行树如下。</p>
<p><img src="/../images/mysql/mysql2-8.jpg" alt="架构"></p>
<p>目前看着这两种方式都没啥问题。</p>
<p>但是，我们再插入一条数据呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_a (a, b) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">11</span>, <span class="string">&#x27;A1&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这样我们就知道了，方案1， 会直接过滤出1行数据，然后在过滤，这样显然比方案2更好。</p>
<p>因为方案2会先查出2条数据，再次过滤。</p>
<p>这就是不同的执行路线带来的性能区别。当然了，我们这里的例子只是打个比方，实际上<code>谓词下推</code>优化以后，这两个条件都是和扫描表一起执行的。</p>
<p>这个例子只是让你明白不同的路线选择而已。</p>
<p>对于<code>join</code>查询来说，会有更多的选择。</p>
<h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>以上就是今天的内容了，大家有任何疑问可以打在评论区，一起交流～</p>
<p>关注我发送“MySQL知识图谱”领取完整的MySQL学习路线。</p>
<p>发送“电子书”即可领取价值上千的电子书资源。</p>
<p>部分电子书如图所示。</p>
<p><img src="/../images/bottom1.png" alt="概念学习"></p>
<p><img src="/../images/bottom2.png" alt="概念学习"></p>
<p><img src="/../images/bottom3.png" alt="概念学习"></p>
<p><img src="/../images/bottom4.png" alt="概念学习"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQLDML%E7%AF%87.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQLDML%E7%AF%87.html" class="post-title-link" itemprop="url">MySQL零基础教程基础篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-26 10:12:47" itemprop="dateCreated datePublished" datetime="2023-04-26T10:12:47+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-08 10:49:59" itemprop="dateModified" datetime="2025-02-08T10:49:59+08:00">2025-02-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMU15445/" itemprop="url" rel="index"><span itemprop="name">CMU15445</span></a>
                </span>
            </span>

          
            <span id="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQLDML%E7%AF%87.html" class="post-meta-item leancloud_visitors" data-flag-title="MySQL零基础教程基础篇" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQLDML%E7%AF%87.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQLDML%E7%AF%87.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL零基础教程基础篇"><a href="#MySQL零基础教程基础篇" class="headerlink" title="MySQL零基础教程基础篇"></a>MySQL零基础教程基础篇</h1><p>大家好，我是大头，98年，职高毕业，上市公司架构师，大厂资深开发，管理过10人团队，我是如何做到的呢？</p>
<p>这离不开持续学习的能力，而其中最重要的当然是数据库技术了！</p>
<p>对于所有开发来说，都离不开数据库，因为所有的数据都是要存储的。</p>
<p>关注我一起学习！文末有惊喜哦！</p>
<p>基础篇的内容大致如下图所示。</p>
<p><img src="/../images/mysql/mysql1-1.png" alt="概念学习"></p>
<h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><p>介绍完概念以后，我们可以来看看SQL语句了。SQL语句通常由三类组成。</p>
<p>数据定义 DDL</p>
<ul>
<li>CREATE 创建数据库或数据库对象</li>
<li>ALTER 对数据库或数据库对象进行修改</li>
<li>DROP 删除数据库或数据库对象<br>数据操纵 DML</li>
<li>SELECT 从表或视图中检索数据</li>
<li>INSERT 将数据插入到表或视图中</li>
<li>UPDATE 修改表或视图中的数据</li>
<li>DELETE 从表或视图中删除数据<br>数据控制 DCL</li>
<li>GRANT 用于授予权限</li>
<li>REVOKE 用于收回权限</li>
</ul>
<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p>MySQL 中的 DML（数据操纵语言，Data Manipulation Language） 语句用于对数据库中的数据进行操作，主要包括数据的插入、更新、删除和查询。DML 语句是数据库操作中最常用的语句类型。</p>
<h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><p>插入数据使用<code>insert</code>指令，可以往创建好的一张表里面插入数据，支持多种插入方式。</p>
<p>最常用的方式是<code>insert  values</code>，这种方式也支持批量插入数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name[(col_name)] <span class="keyword">values</span> ();</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (id, name, department, salary)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;John Doe&#x27;</span>, <span class="string">&#x27;IT&#x27;</span>, <span class="number">50000</span>);</span><br></pre></td></tr></table></figure>

<p>还有一种方式是 <code>insert  set</code>。这种方式不支持批量插入。这种方式以键值对的形式插入数据，适用于插入单行数据。这种方式在插入单行数据时更加直观，尤其是当列名较多时。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name</span><br><span class="line"><span class="keyword">set</span> col_name <span class="operator">=</span> <span class="string">&#x27;值&#x27;</span>, col_name <span class="operator">=</span> <span class="string">&#x27;值&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>还是刚才的插入示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (id, name, department, salary)</span><br><span class="line"><span class="keyword">set</span> id <span class="operator">=</span> <span class="number">1</span>，name <span class="operator">=</span> <span class="string">&#x27;John Doe&#x27;</span>，department<span class="operator">=</span><span class="string">&#x27;IT&#x27;</span>，salary<span class="operator">=</span><span class="number">50000</span>；</span><br></pre></td></tr></table></figure>

<p>还有一种方式是<code>insert  select</code>方式，这种方式适合快速复制表数据，将查询出来的数据插入到另外一个表里面。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure>

<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>可以使用<code>delete from</code>指令来删除已经插入的数据。如果不加where条件的话，就是删除全表数据。</p>
<p>删除数据操作一定要慎重！！！</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>示例：删除刚才插入到表<code>employees</code>的<code>ID=1</code>的数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> employees <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>除了使用delete指令以外，还可以使用<code>TRUNCATE</code>指令，这个指令可以删除全表的数据，并且新的数据id自增从1开始。删除全表数据的话，该指令通常更快速。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">TABLE</span> table_name</span><br></pre></td></tr></table></figure>

<h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><p>当插入的数据内容需要修改或者说更新的时候，则可以使用<code>update set</code>指令进行修改。修改操作可以使用where条件来选择要修改的数据，不加where条件则会更新所有数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> table_name <span class="keyword">set</span> col_name <span class="operator">=</span> <span class="string">&#x27;值&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>示例：将刚才插入的数据部门修改一下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> employees <span class="keyword">set</span> department <span class="operator">=</span> <span class="string">&#x27;Market&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h4><p>数据查询语句是最复杂的语句，这里只是介绍，想要完全用明白，需要大量的实践。</p>
<h5 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h5><p>select用于查询数据表里面插入的数据。</p>
<p><code>*</code>代表查询所有字段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>

<h5 id="列的选择与指定"><a href="#列的选择与指定" class="headerlink" title="列的选择与指定"></a>列的选择与指定</h5><p>如果查询指定字段，则使用字段名称代替<code>*</code>。</p>
<p>实际开发中不推荐查询所有字段，推荐查询需要的字段，可以提升查询速度。</p>
<ul>
<li>如果查询的字段正好是索引，那么可以触发覆盖索引</li>
<li>如果查询的字段过多，会增加网络传输消耗</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name1,col_name2... <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>

<h5 id="定义别名"><a href="#定义别名" class="headerlink" title="定义别名"></a>定义别名</h5><p>可以给字段和表定义别名，通过<code>as</code>指令实现。别名可以解决一些字段名冲突或者字段名过长的问题。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name <span class="keyword">as</span> alias <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>

<p>示例：department字段给一个别名是depart</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id，department <span class="keyword">as</span> depart <span class="keyword">from</span> employees</span><br></pre></td></tr></table></figure>

<h5 id="where条件"><a href="#where条件" class="headerlink" title="where条件"></a>where条件</h5><p>通过where关键字来进行条件筛选，可以选择出符合条件的数据。</p>
<p>比如当前用户表user有数据如下：以下数据均为随机生成，非真实数据。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#122;&#x68;&#97;&#x6e;&#103;&#115;&#x61;&#x6e;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#x6d;">&#122;&#x68;&#97;&#x6e;&#103;&#115;&#x61;&#x6e;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#x6c;&#105;&#x73;&#105;&#x40;&#x65;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;">&#x6c;&#105;&#x73;&#105;&#x40;&#x65;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>003</td>
<td>王五</td>
<td>男</td>
<td>13700009012</td>
<td><a href="mailto:&#119;&#97;&#x6e;&#103;&#x77;&#117;&#64;&#101;&#120;&#x61;&#109;&#x70;&#108;&#101;&#46;&#99;&#111;&#x6d;">&#119;&#97;&#x6e;&#103;&#x77;&#117;&#64;&#101;&#120;&#x61;&#109;&#x70;&#108;&#101;&#46;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>004</td>
<td>赵六</td>
<td>女</td>
<td>13600003456</td>
<td><a href="mailto:&#x7a;&#104;&#x61;&#x6f;&#x6c;&#x69;&#x75;&#64;&#101;&#120;&#97;&#109;&#112;&#x6c;&#x65;&#46;&#x63;&#111;&#x6d;">&#x7a;&#104;&#x61;&#x6f;&#x6c;&#x69;&#x75;&#64;&#101;&#120;&#97;&#109;&#112;&#x6c;&#x65;&#46;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>005</td>
<td>孙七</td>
<td>男</td>
<td>13500007890</td>
<td><a href="mailto:&#x73;&#117;&#x6e;&#x71;&#105;&#64;&#101;&#120;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#x73;&#117;&#x6e;&#x71;&#105;&#64;&#101;&#120;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>006</td>
<td>周八</td>
<td>女</td>
<td>13400001234</td>
<td><a href="mailto:&#122;&#104;&#111;&#x75;&#x62;&#x61;&#x40;&#x65;&#x78;&#x61;&#109;&#112;&#108;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#122;&#104;&#111;&#x75;&#x62;&#x61;&#x40;&#x65;&#x78;&#x61;&#109;&#112;&#108;&#101;&#x2e;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>007</td>
<td>吴九</td>
<td>男</td>
<td>13300005678</td>
<td><a href="mailto:&#x77;&#x75;&#106;&#105;&#117;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#111;&#109;">&#x77;&#x75;&#106;&#105;&#117;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>008</td>
<td>郑十</td>
<td>女</td>
<td>13200009012</td>
<td><a href="mailto:&#122;&#x68;&#x65;&#x6e;&#103;&#x73;&#104;&#105;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;">&#122;&#x68;&#x65;&#x6e;&#103;&#x73;&#104;&#105;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>009</td>
<td>钱伯</td>
<td>男</td>
<td>13100003456</td>
<td><a href="mailto:&#113;&#x69;&#x61;&#110;&#98;&#x6f;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;">&#113;&#x69;&#x61;&#110;&#98;&#x6f;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>010</td>
<td>孔仲</td>
<td>女</td>
<td>13000007890</td>
<td><a href="mailto:&#x6b;&#x6f;&#x6e;&#x67;&#x7a;&#x68;&#111;&#x6e;&#x67;&#64;&#101;&#120;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;">&#x6b;&#x6f;&#x6e;&#x67;&#x7a;&#x68;&#111;&#x6e;&#x67;&#64;&#101;&#120;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;</a></td>
</tr>
</tbody></table>
<p>这个时候我们需要查询出张三的用户信息，而不是将这10个数据都查询出来到程序里在筛选出张三的数据。</p>
<p>可以使用如下sql完成。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>; </span><br></pre></td></tr></table></figure>

<p>这个sql会把name字段中等于‘张三’的数据查询出来。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#104;&#x61;&#x6e;&#103;&#x73;&#x61;&#x6e;&#64;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#111;&#109;">&#x7a;&#104;&#x61;&#x6e;&#103;&#x73;&#x61;&#x6e;&#64;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#111;&#109;</a></td>
</tr>
</tbody></table>
<p>where条件支持的类型如下：</p>
<ul>
<li>比较操作符</li>
</ul>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td>等于</td>
</tr>
<tr>
<td><code>&lt;&gt;</code></td>
<td>不等于（也可用<code>!=</code>）</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
</tr>
</tbody></table>
<ul>
<li><p>逻辑操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>AND</code></td>
<td>逻辑与（两个条件都满足）</td>
</tr>
<tr>
<td><code>OR</code></td>
<td>逻辑或（至少一个条件满足）</td>
</tr>
<tr>
<td><code>NOT</code></td>
<td>逻辑非（对条件取反）</td>
</tr>
</tbody></table>
</li>
<li><p>范围操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>BETWEEN...AND...</code></td>
<td>在指定范围内（包括边界值）</td>
</tr>
<tr>
<td><code>NOT BETWEEN</code></td>
<td>不在指定范围内</td>
</tr>
</tbody></table>
</li>
<li><p>列表操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>IN</code></td>
<td>在指定的列表中</td>
</tr>
<tr>
<td><code>NOT IN</code></td>
<td>不在指定的列表中</td>
</tr>
</tbody></table>
</li>
<li><p>模糊匹配操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>LIKE</code></td>
<td>模糊匹配（使用<code>%</code>和<code>_</code>作为通配符）</td>
</tr>
<tr>
<td><code>NOT LIKE</code></td>
<td>不匹配指定模式</td>
</tr>
</tbody></table>
</li>
<li><p>空值操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>IS NULL</code></td>
<td>判断是否为<code>NULL</code></td>
</tr>
<tr>
<td><code>IS NOT NULL</code></td>
<td>判断是否不为<code>NULL</code></td>
</tr>
</tbody></table>
</li>
<li><p>其他操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>EXISTS</code></td>
<td>检查子查询是否存在结果</td>
</tr>
<tr>
<td><code>NOT EXISTS</code></td>
<td>检查子查询是否不存在结果</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="替换查询结果集中的数据"><a href="#替换查询结果集中的数据" class="headerlink" title="替换查询结果集中的数据"></a>替换查询结果集中的数据</h5><p>可以使用if条件来进行结果的判定，比如性别，数据库里面存的可能是1代表男，2代表女。如果要查询出来男和女的话，就可以直接通过sql处理。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> </span><br><span class="line"><span class="keyword">when</span> 条件<span class="number">1</span> <span class="keyword">then</span> 表达式<span class="number">1</span></span><br><span class="line"><span class="keyword">when</span> 条件<span class="number">2</span> <span class="keyword">then</span> 表达式<span class="number">2</span></span><br><span class="line"><span class="keyword">else</span> 表达式</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">as</span> alias</span><br></pre></td></tr></table></figure>

<p>示例：性别转换。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="keyword">CASE</span> </span><br><span class="line">        <span class="keyword">WHEN</span> gender <span class="operator">=</span> <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">&#x27;男&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> gender <span class="operator">=</span> <span class="number">2</span> <span class="keyword">THEN</span> <span class="string">&#x27;女&#x27;</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">&#x27;未知&#x27;</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> 性别</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<h4 id="计算列值"><a href="#计算列值" class="headerlink" title="计算列值"></a>计算列值</h4><p>可以直接计算将字段的值进行加减乘除运算。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name <span class="operator">+</span> <span class="number">100</span> <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>

<h4 id="from-子句与多表连接查询"><a href="#from-子句与多表连接查询" class="headerlink" title="from 子句与多表连接查询"></a>from 子句与多表连接查询</h4><h5 id="交叉连接，笛卡尔积"><a href="#交叉连接，笛卡尔积" class="headerlink" title="交叉连接，笛卡尔积"></a>交叉连接，笛卡尔积</h5><p>交叉连接可以连接两个表，产生两个表的笛卡尔积作为结果。</p>
<p>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_namme1 <span class="keyword">cross</span> <span class="keyword">join</span> table_name2</span><br></pre></td></tr></table></figure>
<p>可以直接简写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name1,table_name2;</span><br></pre></td></tr></table></figure>

<p>示例：获取两个表的交叉连接。</p>
<p>假设有表user如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#x68;&#97;&#x6e;&#x67;&#115;&#97;&#110;&#64;&#x65;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#99;&#111;&#109;">&#x7a;&#x68;&#97;&#x6e;&#x67;&#115;&#97;&#110;&#64;&#x65;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#99;&#111;&#109;</a></td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#105;&#115;&#x69;&#x40;&#x65;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;">&#108;&#105;&#115;&#x69;&#x40;&#x65;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;</a></td>
</tr>
</tbody></table>
<p>还有表user_account存储用户的账户余额信息如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
</tbody></table>
<p>使用如下sql语句获取交叉连接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>,user_account;</span><br></pre></td></tr></table></figure>

<p>结果如下：也就是用户表数据001和用户账户001产生一条数据，和用户账户002产生一条数据，用户数据002同样。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
<th>ID2</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#104;&#97;&#x6e;&#103;&#115;&#97;&#110;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#x65;&#46;&#x63;&#111;&#x6d;">&#x7a;&#104;&#97;&#x6e;&#103;&#115;&#97;&#110;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#x65;&#46;&#x63;&#111;&#x6d;</a></td>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#x68;&#97;&#x6e;&#103;&#115;&#97;&#x6e;&#64;&#x65;&#120;&#x61;&#109;&#x70;&#108;&#101;&#x2e;&#x63;&#111;&#109;">&#x7a;&#x68;&#97;&#x6e;&#103;&#115;&#97;&#x6e;&#64;&#x65;&#120;&#x61;&#109;&#x70;&#108;&#101;&#x2e;&#x63;&#111;&#109;</a></td>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#x6c;&#x69;&#115;&#x69;&#64;&#101;&#120;&#x61;&#109;&#112;&#108;&#x65;&#46;&#x63;&#111;&#109;">&#x6c;&#x69;&#115;&#x69;&#64;&#101;&#120;&#x61;&#109;&#112;&#108;&#x65;&#46;&#x63;&#111;&#109;</a></td>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#105;&#x73;&#x69;&#64;&#x65;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;">&#108;&#105;&#x73;&#x69;&#64;&#x65;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;</a></td>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
</tbody></table>
<h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>内连接返回两个表中匹配的记录。只有当两个表中的记录满足连接条件时，才会出现在结果集中。可以理解为两个表的交集。</p>
<p>连接的时候，<code>on</code>就类似于where条件，只不过仅仅在连接表数据的时候生效。内连接返回两个表都满足这个条件的交集。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name <span class="keyword">from</span> table_name <span class="keyword">inner</span> <span class="keyword">join</span> table_name2 <span class="keyword">on</span> table_name.id <span class="operator">=</span> table_name2.t_id;</span><br></pre></td></tr></table></figure>

<p>示例：获取用户数据和用户账户数据的内连接。</p>
<p>假设有表user如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#104;&#97;&#110;&#103;&#x73;&#x61;&#110;&#64;&#x65;&#120;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#109;">&#x7a;&#104;&#97;&#110;&#103;&#x73;&#x61;&#110;&#64;&#x65;&#120;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#105;&#115;&#x69;&#64;&#x65;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#x2e;&#99;&#111;&#x6d;">&#108;&#105;&#115;&#x69;&#64;&#x65;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>003</td>
<td>王五</td>
<td>男</td>
<td>13700009012</td>
<td><a href="mailto:&#119;&#97;&#x6e;&#x67;&#119;&#x75;&#x40;&#x65;&#x78;&#x61;&#x6d;&#112;&#108;&#x65;&#x2e;&#x63;&#111;&#109;">&#119;&#97;&#x6e;&#x67;&#119;&#x75;&#x40;&#x65;&#x78;&#x61;&#x6d;&#112;&#108;&#x65;&#x2e;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>004</td>
<td>赵六</td>
<td>女</td>
<td>13600003456</td>
<td><a href="mailto:&#x7a;&#104;&#x61;&#x6f;&#x6c;&#105;&#117;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;">&#x7a;&#104;&#x61;&#x6f;&#x6c;&#105;&#117;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>005</td>
<td>孙七</td>
<td>男</td>
<td>13500007890</td>
<td><a href="mailto:&#x73;&#x75;&#110;&#x71;&#x69;&#x40;&#101;&#x78;&#97;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;">&#x73;&#x75;&#110;&#x71;&#x69;&#x40;&#101;&#x78;&#97;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>006</td>
<td>周八</td>
<td>女</td>
<td>13400001234</td>
<td><a href="mailto:&#122;&#104;&#111;&#x75;&#98;&#97;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#x65;&#x2e;&#99;&#111;&#109;">&#122;&#104;&#111;&#x75;&#98;&#97;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#x65;&#x2e;&#99;&#111;&#109;</a></td>
</tr>
<tr>
<td>007</td>
<td>吴九</td>
<td>男</td>
<td>13300005678</td>
<td><a href="mailto:&#x77;&#x75;&#x6a;&#105;&#117;&#64;&#101;&#120;&#x61;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#x6d;">&#x77;&#x75;&#x6a;&#105;&#117;&#64;&#101;&#120;&#x61;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>008</td>
<td>郑十</td>
<td>女</td>
<td>13200009012</td>
<td><a href="mailto:&#x7a;&#104;&#x65;&#110;&#103;&#x73;&#x68;&#x69;&#x40;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#x2e;&#99;&#111;&#x6d;">&#x7a;&#104;&#x65;&#110;&#103;&#x73;&#x68;&#x69;&#x40;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>009</td>
<td>钱伯</td>
<td>男</td>
<td>13100003456</td>
<td><a href="mailto:&#113;&#x69;&#97;&#x6e;&#98;&#x6f;&#64;&#x65;&#120;&#x61;&#x6d;&#x70;&#x6c;&#101;&#x2e;&#x63;&#111;&#109;">&#113;&#x69;&#97;&#x6e;&#98;&#x6f;&#64;&#x65;&#120;&#x61;&#x6d;&#x70;&#x6c;&#101;&#x2e;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>010</td>
<td>孔仲</td>
<td>女</td>
<td>13000007890</td>
<td><a href="mailto:&#107;&#111;&#110;&#x67;&#x7a;&#x68;&#x6f;&#x6e;&#x67;&#x40;&#x65;&#x78;&#x61;&#109;&#112;&#108;&#101;&#x2e;&#x63;&#111;&#109;">&#107;&#111;&#110;&#x67;&#x7a;&#x68;&#x6f;&#x6e;&#x67;&#x40;&#x65;&#x78;&#x61;&#109;&#112;&#108;&#101;&#x2e;&#x63;&#111;&#109;</a></td>
</tr>
</tbody></table>
<p>还有表user_account存储用户的账户余额信息如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>003</td>
<td>011</td>
<td>20</td>
</tr>
</tbody></table>
<p>可以看到这两个表的交集就只有两条数据，也就是001和002，</p>
<p>使用如下sql语句获取交叉连接：</p>
<p><code>on user.id = user_account.user_id</code>这个条件代表只有当user表的id字段和user_account表的user_id字段相等的时候，才会有结果;</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">inner</span> <span class="keyword">join</span> user_account <span class="keyword">on</span> user.id <span class="operator">=</span> user_account.user_id;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
<th>ID2</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#122;&#x68;&#x61;&#x6e;&#x67;&#115;&#x61;&#110;&#x40;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#x65;&#46;&#99;&#x6f;&#x6d;">&#122;&#x68;&#x61;&#x6e;&#x67;&#115;&#x61;&#110;&#x40;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#x65;&#46;&#99;&#x6f;&#x6d;</a></td>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#x69;&#x73;&#105;&#x40;&#101;&#120;&#x61;&#109;&#112;&#108;&#x65;&#x2e;&#99;&#x6f;&#x6d;">&#108;&#x69;&#x73;&#105;&#x40;&#101;&#120;&#x61;&#109;&#112;&#108;&#x65;&#x2e;&#99;&#x6f;&#x6d;</a></td>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
</tbody></table>
<h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>外连接分为左连接和右连接，左连接返回内连接的结果+左表剩余的数据，右连接返回内连接的结果+右表剩余的数据。</p>
<p>左表就是 <code>join</code>左边的表，右表就是<code>join</code>右边的表。</p>
<p>左连接使用<code>left join</code>指令。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name <span class="keyword">from</span> table_name <span class="keyword">left</span> <span class="keyword">join</span> table_name2 <span class="keyword">on</span> table_name.id <span class="operator">=</span> table_name2.t_id;</span><br></pre></td></tr></table></figure>

<p>示例：获取用户表和用户账户表的左连接结果。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#122;&#104;&#97;&#110;&#x67;&#x73;&#97;&#x6e;&#x40;&#x65;&#120;&#97;&#109;&#112;&#x6c;&#x65;&#46;&#x63;&#x6f;&#109;">&#122;&#104;&#97;&#110;&#x67;&#x73;&#97;&#x6e;&#x40;&#x65;&#120;&#97;&#109;&#112;&#x6c;&#x65;&#46;&#x63;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#x69;&#115;&#x69;&#64;&#101;&#120;&#97;&#x6d;&#112;&#108;&#101;&#x2e;&#x63;&#111;&#109;">&#108;&#x69;&#115;&#x69;&#64;&#101;&#120;&#97;&#x6d;&#112;&#108;&#101;&#x2e;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>003</td>
<td>王五</td>
<td>男</td>
<td>13700009012</td>
<td><a href="mailto:&#119;&#x61;&#110;&#x67;&#119;&#117;&#64;&#101;&#120;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#x63;&#x6f;&#x6d;">&#119;&#x61;&#110;&#x67;&#119;&#117;&#64;&#101;&#120;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#x63;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>004</td>
<td>赵六</td>
<td>女</td>
<td>13600003456</td>
<td><a href="mailto:&#122;&#104;&#97;&#111;&#x6c;&#x69;&#x75;&#64;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;">&#122;&#104;&#97;&#111;&#x6c;&#x69;&#x75;&#64;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>005</td>
<td>孙七</td>
<td>男</td>
<td>13500007890</td>
<td><a href="mailto:&#115;&#117;&#x6e;&#x71;&#x69;&#x40;&#x65;&#x78;&#97;&#x6d;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;">&#115;&#117;&#x6e;&#x71;&#x69;&#x40;&#x65;&#x78;&#97;&#x6d;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>006</td>
<td>周八</td>
<td>女</td>
<td>13400001234</td>
<td><a href="mailto:&#122;&#x68;&#x6f;&#x75;&#x62;&#97;&#x40;&#101;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#x6d;">&#122;&#x68;&#x6f;&#x75;&#x62;&#97;&#x40;&#101;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>007</td>
<td>吴九</td>
<td>男</td>
<td>13300005678</td>
<td><a href="mailto:&#119;&#117;&#x6a;&#105;&#117;&#x40;&#x65;&#x78;&#97;&#x6d;&#112;&#108;&#x65;&#46;&#x63;&#111;&#x6d;">&#119;&#117;&#x6a;&#105;&#117;&#x40;&#x65;&#x78;&#97;&#x6d;&#112;&#108;&#x65;&#46;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>008</td>
<td>郑十</td>
<td>女</td>
<td>13200009012</td>
<td><a href="mailto:&#x7a;&#104;&#x65;&#110;&#x67;&#x73;&#104;&#x69;&#x40;&#x65;&#120;&#97;&#x6d;&#112;&#108;&#x65;&#x2e;&#x63;&#111;&#109;">&#x7a;&#104;&#x65;&#110;&#x67;&#x73;&#104;&#x69;&#x40;&#x65;&#120;&#97;&#x6d;&#112;&#108;&#x65;&#x2e;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>009</td>
<td>钱伯</td>
<td>男</td>
<td>13100003456</td>
<td><a href="mailto:&#113;&#x69;&#97;&#110;&#x62;&#111;&#64;&#x65;&#120;&#97;&#109;&#112;&#108;&#x65;&#46;&#x63;&#111;&#x6d;">&#113;&#x69;&#97;&#110;&#x62;&#111;&#64;&#x65;&#120;&#97;&#109;&#112;&#108;&#x65;&#46;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>010</td>
<td>孔仲</td>
<td>女</td>
<td>13000007890</td>
<td><a href="mailto:&#x6b;&#x6f;&#x6e;&#103;&#x7a;&#x68;&#111;&#110;&#103;&#x40;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#46;&#x63;&#111;&#109;">&#x6b;&#x6f;&#x6e;&#103;&#x7a;&#x68;&#111;&#110;&#103;&#x40;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#46;&#x63;&#111;&#109;</a></td>
</tr>
</tbody></table>
<p>还有表user_account存储用户的账户余额信息如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>003</td>
<td>011</td>
<td>20</td>
</tr>
</tbody></table>
<p>使用如下sql语句，可以看到，仅仅是<code>inner join</code>换成了<code>left join</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">left</span> <span class="keyword">join</span> user_account <span class="keyword">on</span> user.id <span class="operator">=</span> user_account.user_id;</span><br></pre></td></tr></table></figure>

<p>结果如下：在内连接的结果基础上，增加了<code>左表user表</code>剩下的8条数据，右表的字段内容则是<code>null</code>，代表没有对应字段的数据。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
<th>ID2</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#122;&#x68;&#x61;&#x6e;&#103;&#x73;&#97;&#x6e;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#x65;&#46;&#99;&#111;&#x6d;">&#122;&#x68;&#x61;&#x6e;&#103;&#x73;&#97;&#x6e;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#x65;&#46;&#99;&#111;&#x6d;</a></td>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#x69;&#x73;&#105;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;">&#108;&#x69;&#x73;&#105;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;</a></td>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>003</td>
<td>王五</td>
<td>男</td>
<td>13700009012</td>
<td><a href="mailto:&#119;&#97;&#x6e;&#x67;&#119;&#x75;&#64;&#101;&#x78;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#x6f;&#109;">&#119;&#97;&#x6e;&#x67;&#119;&#x75;&#64;&#101;&#x78;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#x6f;&#109;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>004</td>
<td>赵六</td>
<td>女</td>
<td>13600003456</td>
<td><a href="mailto:&#122;&#104;&#97;&#x6f;&#x6c;&#105;&#x75;&#x40;&#x65;&#x78;&#97;&#109;&#x70;&#108;&#101;&#x2e;&#x63;&#111;&#x6d;">&#122;&#104;&#97;&#x6f;&#x6c;&#105;&#x75;&#x40;&#x65;&#x78;&#97;&#109;&#x70;&#108;&#101;&#x2e;&#x63;&#111;&#x6d;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>005</td>
<td>孙七</td>
<td>男</td>
<td>13500007890</td>
<td><a href="mailto:&#115;&#117;&#110;&#x71;&#105;&#64;&#x65;&#120;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#x63;&#x6f;&#109;">&#115;&#117;&#110;&#x71;&#105;&#64;&#x65;&#120;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#x63;&#x6f;&#109;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>006</td>
<td>周八</td>
<td>女</td>
<td>13400001234</td>
<td><a href="mailto:&#x7a;&#104;&#x6f;&#x75;&#98;&#97;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#46;&#99;&#111;&#109;">&#x7a;&#104;&#x6f;&#x75;&#98;&#97;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#46;&#99;&#111;&#109;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>007</td>
<td>吴九</td>
<td>男</td>
<td>13300005678</td>
<td><a href="mailto:&#x77;&#117;&#106;&#105;&#117;&#64;&#101;&#x78;&#97;&#109;&#x70;&#x6c;&#101;&#46;&#99;&#x6f;&#109;">&#x77;&#117;&#106;&#105;&#117;&#64;&#101;&#x78;&#97;&#109;&#x70;&#x6c;&#101;&#46;&#99;&#x6f;&#109;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>008</td>
<td>郑十</td>
<td>女</td>
<td>13200009012</td>
<td><a href="mailto:&#122;&#104;&#101;&#x6e;&#x67;&#115;&#104;&#x69;&#x40;&#101;&#x78;&#x61;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;">&#122;&#104;&#101;&#x6e;&#x67;&#115;&#104;&#x69;&#x40;&#101;&#x78;&#x61;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>009</td>
<td>钱伯</td>
<td>男</td>
<td>13100003456</td>
<td><a href="mailto:&#113;&#x69;&#x61;&#x6e;&#x62;&#111;&#x40;&#x65;&#120;&#97;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;">&#113;&#x69;&#x61;&#x6e;&#x62;&#111;&#x40;&#x65;&#120;&#97;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>010</td>
<td>孔仲</td>
<td>女</td>
<td>13000007890</td>
<td><a href="mailto:&#x6b;&#x6f;&#110;&#x67;&#x7a;&#x68;&#x6f;&#x6e;&#103;&#x40;&#x65;&#x78;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#99;&#x6f;&#x6d;">&#x6b;&#x6f;&#110;&#x67;&#x7a;&#x68;&#x6f;&#x6e;&#103;&#x40;&#x65;&#x78;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#99;&#x6f;&#x6d;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
</tbody></table>
<p>右连接使用<code>right join</code>指令。<br>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name <span class="keyword">from</span> table_name <span class="keyword">right</span> <span class="keyword">join</span> table_name2 <span class="keyword">on</span> table_name.id <span class="operator">=</span> table_name2.t_id;</span><br></pre></td></tr></table></figure>

<p>示例：获取用户表和用户账户表的右连接结果。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#x68;&#97;&#110;&#x67;&#115;&#x61;&#x6e;&#x40;&#101;&#120;&#x61;&#x6d;&#x70;&#108;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">&#x7a;&#x68;&#97;&#110;&#x67;&#115;&#x61;&#x6e;&#x40;&#101;&#120;&#x61;&#x6d;&#x70;&#108;&#x65;&#x2e;&#x63;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#x6c;&#x69;&#x73;&#x69;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#101;&#x2e;&#x63;&#111;&#x6d;">&#x6c;&#x69;&#x73;&#x69;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#101;&#x2e;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>003</td>
<td>王五</td>
<td>男</td>
<td>13700009012</td>
<td><a href="mailto:&#x77;&#x61;&#x6e;&#x67;&#119;&#117;&#64;&#101;&#120;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#x63;&#111;&#109;">&#x77;&#x61;&#x6e;&#x67;&#119;&#117;&#64;&#101;&#120;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>004</td>
<td>赵六</td>
<td>女</td>
<td>13600003456</td>
<td><a href="mailto:&#122;&#104;&#97;&#111;&#x6c;&#105;&#x75;&#x40;&#x65;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#109;">&#122;&#104;&#97;&#111;&#x6c;&#105;&#x75;&#x40;&#x65;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>005</td>
<td>孙七</td>
<td>男</td>
<td>13500007890</td>
<td><a href="mailto:&#115;&#x75;&#x6e;&#113;&#x69;&#64;&#101;&#120;&#x61;&#x6d;&#x70;&#108;&#x65;&#46;&#99;&#x6f;&#109;">&#115;&#x75;&#x6e;&#113;&#x69;&#64;&#101;&#120;&#x61;&#x6d;&#x70;&#108;&#x65;&#46;&#99;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>006</td>
<td>周八</td>
<td>女</td>
<td>13400001234</td>
<td><a href="mailto:&#x7a;&#x68;&#x6f;&#x75;&#98;&#x61;&#x40;&#101;&#x78;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;">&#x7a;&#x68;&#x6f;&#x75;&#98;&#x61;&#x40;&#101;&#x78;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>007</td>
<td>吴九</td>
<td>男</td>
<td>13300005678</td>
<td><a href="mailto:&#119;&#x75;&#x6a;&#x69;&#117;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#111;&#x6d;">&#119;&#x75;&#x6a;&#x69;&#117;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>008</td>
<td>郑十</td>
<td>女</td>
<td>13200009012</td>
<td><a href="mailto:&#122;&#x68;&#101;&#x6e;&#x67;&#x73;&#x68;&#105;&#x40;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;">&#122;&#x68;&#101;&#x6e;&#x67;&#x73;&#x68;&#105;&#x40;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>009</td>
<td>钱伯</td>
<td>男</td>
<td>13100003456</td>
<td><a href="mailto:&#x71;&#x69;&#x61;&#110;&#x62;&#111;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#x6d;">&#x71;&#x69;&#x61;&#110;&#x62;&#111;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>010</td>
<td>孔仲</td>
<td>女</td>
<td>13000007890</td>
<td><a href="mailto:&#107;&#x6f;&#110;&#103;&#x7a;&#104;&#111;&#110;&#x67;&#64;&#x65;&#120;&#x61;&#109;&#112;&#108;&#101;&#46;&#x63;&#111;&#x6d;">&#107;&#x6f;&#110;&#103;&#x7a;&#104;&#111;&#110;&#x67;&#64;&#x65;&#120;&#x61;&#109;&#112;&#108;&#101;&#46;&#x63;&#111;&#x6d;</a></td>
</tr>
</tbody></table>
<p>还有表user_account存储用户的账户余额信息如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>003</td>
<td>011</td>
<td>20</td>
</tr>
</tbody></table>
<p>使用如下sql语句，可以看到，仅仅是<code>left join</code>换成了<code>right join</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">right</span> <span class="keyword">join</span> user_account <span class="keyword">on</span> user.id <span class="operator">=</span> user_account.user_id;</span><br></pre></td></tr></table></figure>

<p>结果如下：在内连接的结果基础上，增加了<code>右表user_account表</code>剩下的1条数据，左表的字段内容则是<code>null</code>，代表没有对应字段的数据。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
<th>ID2</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#122;&#104;&#97;&#110;&#103;&#x73;&#97;&#x6e;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#108;&#101;&#x2e;&#99;&#111;&#x6d;">&#122;&#104;&#97;&#110;&#103;&#x73;&#97;&#x6e;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#108;&#101;&#x2e;&#99;&#111;&#x6d;</a></td>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#105;&#115;&#105;&#64;&#101;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#101;&#46;&#99;&#111;&#x6d;">&#108;&#105;&#115;&#105;&#64;&#101;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#101;&#46;&#99;&#111;&#x6d;</a></td>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>003</td>
<td>011</td>
<td>20</td>
</tr>
</tbody></table>
<h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><p>在MySQL中，子查询是一种强大的功能，允许在一个查询中嵌套另一个查询。根据子查询返回的结果类型，可以将其分为以下几种：</p>
<ul>
<li>表子查询</li>
<li>行子查询</li>
<li>列子查询</li>
<li>标量子查询</li>
</ul>
<blockquote>
<p>注意：所有的子查询应该慎重使用，因为子查询会导致查询速度降低。</p>
</blockquote>
<table>
<thead>
<tr>
<th>子查询类型</th>
<th>定义</th>
<th>特点</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>表子查询</strong></td>
<td>返回一个完整的表（多行多列）</td>
<td>通常用于<code>FROM</code>子句或<code>JOIN</code>操作中，结果是一个表结构</td>
<td><code>sql &lt;br&gt;SELECT * FROM (SELECT id, name FROM users) AS subquery;&lt;br&gt; </code></td>
</tr>
<tr>
<td><strong>行子查询</strong></td>
<td>返回一行数据（多列）</td>
<td>通常用于<code>WHERE</code>子句中，结果是一行数据，可以与多列比较</td>
<td><code>sql &lt;br&gt;SELECT * FROM users WHERE (id, name) = (SELECT id, name FROM users WHERE age = 25);&lt;br&gt;</code></td>
</tr>
<tr>
<td><strong>列子查询</strong></td>
<td>返回一列数据（多行）</td>
<td>通常用于<code>WHERE</code>子句中，结果是一列数据，可以与<code>IN</code>、<code>ANY</code>、<code>ALL</code>等操作符配合使用</td>
<td><code>sql&lt;br&gt;SELECT * FROM users WHERE id IN (SELECT id FROM orders);&lt;br&gt;</code></td>
</tr>
<tr>
<td><strong>标量子查询</strong></td>
<td>返回单个值（一行一列）</td>
<td>通常用于<code>WHERE</code>子句中，结果是一个单一值，可以与比较操作符配合使用</td>
<td><code>sql&lt;br&gt;SELECT * FROM users WHERE age = (SELECT MAX(age) FROM users);&lt;br&gt;</code></td>
</tr>
</tbody></table>
<h6 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h6><ul>
<li>定义：返回一个完整的表（多行多列）。</li>
<li>特点：可以作为虚拟表使用，通常用于FROM子句或JOIN操作中。</li>
<li>示例：SELECT id, name FROM users 这就是一个子查询，该子查询返回的结果是一张表的数据，将该子查询的结果作为一张表，供外部的查询使用。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> users) <span class="keyword">AS</span> subquery;</span><br></pre></td></tr></table></figure>

<h6 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h6><ul>
<li>定义：返回一行数据（多列）。</li>
<li>特点：结果是一行数据，可以与多列比较，通常用于WHERE子句中。</li>
<li>示例：SELECT id, name FROM users WHERE mobile &#x3D; “13012345678” 是一个子查询，该子查询返回了mobile字段等于13012345678的一行数据，并且只查询了id和name字段。将这两个字段作为外部查询的where条件。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> (id, name) <span class="operator">=</span> (<span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> mobile <span class="operator">=</span> &quot;13012345678&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h6><ul>
<li>定义：返回一列数据（多行）。</li>
<li>特点：结果是一列数据，可以与IN、ANY、ALL等操作符配合使用，通常用于WHERE子句中。</li>
<li>示例：SELECT user_id FROM orders 是一个子查询，该子查询返回了orders表的所有用户id信息，并将这些用户id作为外部查询的where条件。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> user_id <span class="keyword">FROM</span> orders);</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h6><ul>
<li>定义：返回单个值（一行一列）。</li>
<li>特点：结果是一个单一值，可以与比较操作符配合使用，通常用于WHERE子句中。</li>
<li>示例：SELECT MAX(age) FROM users 是一个子查询，该子查询返回了users表的最大的年龄信息，并将最大的用户年龄作为外部查询的where条件。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> age <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(age) <span class="keyword">FROM</span> users);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h5><ul>
<li>group语句可以实现分组的效果，什么是分组？</li>
</ul>
<p>假设该数据表中存储了10条订单信息，有3条是张三的，3条是李四的，剩下4条是王五的。</p>
<p>group分组以后就可以分成3组，一组是张三的3条数据，一组是李四的3条数据，一组是王五的4条数据。</p>
<ul>
<li>分组能干什么？</li>
</ul>
<p>分组以后可以统计每个分组中的订单数量、订单总额、订单平均金额等。</p>
<p>语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> col_name</span><br></pre></td></tr></table></figure>

<p>支持的聚合函数：</p>
<ul>
<li>count(col_name): 计算每个分组中该字段的数量，比如订单数量</li>
<li>sum(col_name): 计算每个分组中该字段的总额，比如订单总金额</li>
<li>avg(col_name): 计算每个分组中该字段的平均值，比如订单平均金额</li>
<li>min(col_name): 获取每个分组中该字段的最小值</li>
<li>max(col_name): 获取每个分组中该字段的最大值</li>
</ul>
<p>有人要问了？那我不使用<code>group by</code>的情况下，可以使用上面的聚合函数吗？</p>
<p>当然可以了，没有分组，其实相当于所有数据是一个大分组，所以计算的是所有数据数量、总额等。</p>
<p>示例：下表是订单表，记录了3个用户的订单信息，现在需要查询这3个用户的订单数量、订单总金额、订单平均金额、最小金额以及最大金额。</p>
<table>
<thead>
<tr>
<th>OrderID</th>
<th>UserID</th>
<th>OrderDate</th>
<th>OrderAmount</th>
<th>OrderStatus</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>1</td>
<td>2025-02-01</td>
<td>120.00</td>
<td>Completed</td>
</tr>
<tr>
<td>1002</td>
<td>1</td>
<td>2025-02-02</td>
<td>85.00</td>
<td>Pending</td>
</tr>
<tr>
<td>1003</td>
<td>1</td>
<td>2025-02-03</td>
<td>230.00</td>
<td>Shipped</td>
</tr>
<tr>
<td>1004</td>
<td>2</td>
<td>2025-02-04</td>
<td>150.00</td>
<td>Completed</td>
</tr>
<tr>
<td>1005</td>
<td>2</td>
<td>2025-02-05</td>
<td>90.25</td>
<td>Pending</td>
</tr>
<tr>
<td>1006</td>
<td>2</td>
<td>2025-02-06</td>
<td>110.00</td>
<td>Shipped</td>
</tr>
<tr>
<td>1007</td>
<td>3</td>
<td>2025-02-07</td>
<td>100.00</td>
<td>Completed</td>
</tr>
<tr>
<td>1008</td>
<td>3</td>
<td>2025-02-08</td>
<td>200.00</td>
<td>Pending</td>
</tr>
<tr>
<td>1009</td>
<td>3</td>
<td>2025-02-09</td>
<td>130.75</td>
<td>Shipped</td>
</tr>
<tr>
<td>1010</td>
<td>3</td>
<td>2025-02-10</td>
<td>160.00</td>
<td>Completed</td>
</tr>
</tbody></table>
<p>使用如下sql：对userID进行分组，就可以分成三组数据了，在对每个分组使用聚合函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, <span class="built_in">count</span>(OrderID), <span class="built_in">sum</span>(OrderAmount), <span class="built_in">avg</span>(OrderAmount), <span class="built_in">min</span>(OrderAmount), <span class="built_in">max</span>(OrderAmount)</span><br><span class="line"><span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> UserID</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<table>
<thead>
<tr>
<th>UserID</th>
<th>count(OrderID)</th>
<th>sum(OrderAmount)</th>
<th>avg(OrderAmount)</th>
<th>min(OrderAmount)</th>
<th>max(OrderAmount)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>3</td>
<td>435.00</td>
<td>145.00</td>
<td>85.00</td>
<td>230.00</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>350.25</td>
<td>116.75</td>
<td>90.25</td>
<td>150.00</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>590.75</td>
<td>147.68</td>
<td>100.00</td>
<td>200.00</td>
</tr>
</tbody></table>
<h5 id="having"><a href="#having" class="headerlink" title="having"></a>having</h5><p><code>having</code>语句用来过滤<code>group by</code>分组以后的数据。</p>
<p>简单点说，就是相当于where条件，只不过<code>where条件</code>的执行顺序在<code>group by</code>之前，having条件的执行顺序在group by之后。</p>
<p>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> col_name [<span class="keyword">having</span> col_name <span class="operator">=</span> 任何数]</span><br></pre></td></tr></table></figure>

<p>示例：还是上面group by的表，这次我们只需要总金额大于400的数据，从上面的结果来看，我们知道，只需要userId为1和3的数据。</p>
<p>但是注意，<code>where条件</code>是在<code>group by</code>之前执行，这个时候还没有总金额这个字段呢。所以，就需要使用<code>having</code>了。</p>
<p>使用的sql如下：可以看到，仅仅是在后面增加了<code>having sum(OrderAmount) &gt; 400</code>这一条。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, <span class="built_in">count</span>(OrderID), <span class="built_in">sum</span>(OrderAmount), <span class="built_in">avg</span>(OrderAmount), <span class="built_in">min</span>(OrderAmount), <span class="built_in">max</span>(OrderAmount)</span><br><span class="line"><span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> UserID <span class="keyword">having</span> <span class="built_in">sum</span>(OrderAmount) <span class="operator">&gt;</span> <span class="number">400</span></span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<table>
<thead>
<tr>
<th>UserID</th>
<th>count(OrderID)</th>
<th>sum(OrderAmount)</th>
<th>avg(OrderAmount)</th>
<th>min(OrderAmount)</th>
<th>max(OrderAmount)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>3</td>
<td>435.00</td>
<td>145.00</td>
<td>85.00</td>
<td>230.00</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>590.75</td>
<td>147.68</td>
<td>100.00</td>
<td>200.00</td>
</tr>
</tbody></table>
<h5 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h5><p>如果想对查询出来的结果集进行排序，可以使用<code>order by</code>语句。</p>
<p>语法如下：asc代表升序，即1，2，3这种排序，desc代表降序，即3，2，1这种。默认是asc。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> col_name [<span class="keyword">asc</span>｜<span class="keyword">desc</span>]</span><br></pre></td></tr></table></figure>

<p>order by排序作用在group by分组之后，这意味着可以使用分组之后的聚合函数的结果进行排序，同时也意味着可以影响group by之后的数据。</p>
<p>示例：对上面group by之后的数据按照总金额进行降序排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, <span class="built_in">count</span>(OrderID), <span class="built_in">sum</span>(OrderAmount), <span class="built_in">avg</span>(OrderAmount), <span class="built_in">min</span>(OrderAmount), <span class="built_in">max</span>(OrderAmount)</span><br><span class="line"><span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> UserID <span class="keyword">having</span> <span class="built_in">sum</span>(OrderAmount) <span class="operator">&gt;</span> <span class="number">400</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">sum</span>(OrderAmount) <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<table>
<thead>
<tr>
<th>UserID</th>
<th>count(OrderID)</th>
<th>sum(OrderAmount)</th>
<th>avg(OrderAmount)</th>
<th>min(OrderAmount)</th>
<th>max(OrderAmount)</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>4</td>
<td>590.75</td>
<td>147.68</td>
<td>100.00</td>
<td>200.00</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>435.00</td>
<td>145.00</td>
<td>85.00</td>
<td>230.00</td>
</tr>
</tbody></table>
<h5 id="group-和-order的差别"><a href="#group-和-order的差别" class="headerlink" title="group 和 order的差别"></a>group 和 order的差别</h5><table>
<thead>
<tr>
<th align="left">group</th>
<th align="left">order</th>
</tr>
</thead>
<tbody><tr>
<td align="left">分组行，但输出可能不是分组的排序</td>
<td align="left">排序产生的输出</td>
</tr>
<tr>
<td align="left">只能使用选择列或表达式列</td>
<td align="left">任意列都可以使用</td>
</tr>
<tr>
<td align="left">若与聚合函数一起使用列或表达式, 则必须使用group</td>
<td align="left">不一定需要</td>
</tr>
</tbody></table>
<h5 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h5><p>如果不想每次都查询数据表的全部数据，只想获取几条数据呢？比如分页功能，一页10条数据这种，就可以使用<code>limit</code>命令来实现。</p>
<p>语法如下：start代表开始的位置，end代表结束的位置。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> orders </span><br><span class="line">limit [<span class="keyword">start</span>, <span class="keyword">end</span>]</span><br></pre></td></tr></table></figure>

<p>比如表中有100条数据。获取1-10条数据就是<code>limit 1,10</code>，获取11-20条数据就是<code>limit 11,20</code>。</p>
<p>limit最好是配合order by使用。性能更佳，另外，如果只获取1条数据，也建议使用<code>limit 1</code>代表获取1条数据。</p>
<p>具体的原因在后面原理篇会讲到。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQL%E7%AF%87.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQL%E7%AF%87.html" class="post-title-link" itemprop="url">MySQL零基础教程基础篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-26 10:12:47" itemprop="dateCreated datePublished" datetime="2023-04-26T10:12:47+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-06 16:19:27" itemprop="dateModified" datetime="2025-02-06T16:19:27+08:00">2025-02-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMU15445/" itemprop="url" rel="index"><span itemprop="name">CMU15445</span></a>
                </span>
            </span>

          
            <span id="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQL%E7%AF%87.html" class="post-meta-item leancloud_visitors" data-flag-title="MySQL零基础教程基础篇" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQL%E7%AF%87.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQL%E7%AF%87.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL零基础教程基础篇"><a href="#MySQL零基础教程基础篇" class="headerlink" title="MySQL零基础教程基础篇"></a>MySQL零基础教程基础篇</h1><p>大家好，我是大头，98年，职高毕业，做过上市公司架构师，做过大厂资深开发，管理过10人团队，我是如何做到的呢？</p>
<p>这离不开持续学习的能力，而其中最重要的当然是数据库技术了！</p>
<p>对于所有开发来说，都离不开数据库，因为所有的数据都是要存储的。</p>
<p>关注我一起学习！可获得系统性的学习教程、转码经验、技术交流、大厂内推等～</p>
<p>文末有惊喜哦！</p>
<p>基础篇的内容大致如下图所示。</p>
<p><img src="/../images/mysql/mysql1-1.png" alt="概念学习"></p>
<h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><p>介绍完概念以后，我们可以来看看SQL语句了。SQL语句通常由三类组成。</p>
<p>数据定义 DDL</p>
<ul>
<li>CREATE 创建数据库或数据库对象</li>
<li>ALTER 对数据库或数据库对象进行修改</li>
<li>DROP 删除数据库或数据库对象<br>数据操纵 DML</li>
<li>SELECT 从表或视图中检索数据</li>
<li>INSERT 将数据插入到表或视图中</li>
<li>UPDATE 修改表或视图中的数据</li>
<li>DELETE 从表或视图中删除数据<br>数据控制 DCL</li>
<li>GRANT 用于授予权限</li>
<li>REVOKE 用于收回权限</li>
</ul>
<h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p>DCL（Data Control Language）语句用于控制对数据库的访问权限，包括用户权限的授予和撤销。DCL语句主要涉及用户和角色的权限管理，确保数据库的安全性和数据的完整性。</p>
<ul>
<li>授予权限（GRANT）</li>
<li>撤销权限（REVOKE）</li>
<li>设置用户密码（SET PASSWORD）</li>
<li>查看用户权限（SHOW GRANTS）</li>
</ul>
<h4 id="GRANT"><a href="#GRANT" class="headerlink" title="GRANT"></a>GRANT</h4><ul>
<li>GRANT语句用于授予用户或角色特定的权限。</li>
<li>权限可以包括对表、视图、存储过程等的访问和操作权限。</li>
</ul>
<p>语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> privilege_type <span class="keyword">ON</span> object_name <span class="keyword">TO</span> user_or_role;</span><br></pre></td></tr></table></figure>

<p>示例：授予用户zhangsan对employees表的SELECT和INSERT权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> employees <span class="keyword">TO</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="REVOKE"><a href="#REVOKE" class="headerlink" title="REVOKE"></a>REVOKE</h4><ul>
<li>REVOKE语句用于撤销用户或角色的特定权限。</li>
<li>撤销的权限可以是之前授予的任何权限。</li>
</ul>
<p>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> privilege_type <span class="keyword">ON</span> object_name <span class="keyword">FROM</span> user_or_role;</span><br></pre></td></tr></table></figure>

<p>示例：撤销用户zhangsan对employees表的INSERT权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> employees <span class="keyword">FROM</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="SET-PASSWORD"><a href="#SET-PASSWORD" class="headerlink" title="SET PASSWORD"></a>SET PASSWORD</h4><ul>
<li>SET PASSWORD语句用于设置或更改用户的密码。</li>
</ul>
<p>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> <span class="keyword">user</span> <span class="operator">=</span> <span class="string">&#x27;new_password&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>示例：设置用户zhangsan的新密码为new_password。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;new_password&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="SHOW-GRANTS"><a href="#SHOW-GRANTS" class="headerlink" title="SHOW GRANTS"></a>SHOW GRANTS</h4><ul>
<li>SHOW GRANTS语句用于查看用户的权限。</li>
</ul>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p>示例如下：查看用户zhangsan的权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>DCL主要是对于权限的控制，希望大家可以自己创建一个数据库a，在创建一个用户a,授予a用户a数据库的权限。进行练习。</p>
<h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><p>DDL（Data Definition Language，数据定义语言）是SQL语言的一部分，用于定义和修改数据库的结构。DDL语句主要涉及数据库、表、索引、视图等的创建、修改和删除操作。这些语句直接影响数据库的结构，但不会直接操作数据本身。</p>
<h4 id="数据库模式定义"><a href="#数据库模式定义" class="headerlink" title="数据库模式定义"></a>数据库模式定义</h4><h5 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h5><p>使用 <code>CREATE DATABASE</code> 语句，<code>IF NOT EXISTS</code>代表没有这个数据库，才会进行创建。如果已经有了，则不会再创建了。</p>
<p><code>CHARACTER SET</code>是设置字符集，推荐设置为utf8mb4字符集，<code>COLLATE</code>则使用默认的就可以了。</p>
<p>这里说一下<code>utf8</code>和<code>utf8mb4</code>这两个字符集的区别。</p>
<ul>
<li>utf8字符集：在MySQL中实际上是一个有限的字符集，它只支持最多3字节的UTF-8字符。这意味着它不能存储所有可能的Unicode字符，特别是那些需要4字节表示的字符（如某些表情符号）。utf8字符集支持的Unicode范围是U+0000到U+FFFF，即基本多语言平面（BMP）。</li>
<li>utf8mb4字符集支持完整的UTF-8字符集，包括4字节的字符。这意味着它可以存储所有可能的Unicode字符，包括表情符号和一些罕见的字符。utf8mb4字符集支持的Unicode范围是U+0000到U+10FFFF，即整个Unicode范围。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> &#123;DATABASE&#125; [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] db_name</span><br><span class="line">[<span class="keyword">DEFAULT</span>] <span class="type">CHARACTER</span> <span class="keyword">SET</span>[<span class="operator">=</span>]charset_name</span><br><span class="line"><span class="operator">|</span> [<span class="keyword">DEFAULT</span>] <span class="keyword">COLLATE</span>[<span class="operator">=</span>]collation_name</span><br></pre></td></tr></table></figure>

<p>创建一个测试数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database test;</span><br></pre></td></tr></table></figure>

<h5 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h5><p>使用<code>show databases</code>命令可以查看所有的数据库。也包括一些MySQL自带的数据库。这些数据库存储了MySQL的元数据，具体的等到原理篇会讲到。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> &#123;DATABASES&#125;</span><br><span class="line">[<span class="keyword">LIKE</span> <span class="keyword">pattern</span> <span class="operator">|</span> <span class="keyword">WHERE</span> expr] </span><br></pre></td></tr></table></figure>

<h5 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h5><p>使用<code>use</code>指令➕数据库名称可以选择数据库，或者说进入数据库。只有先进入一个数据库，才能操作这个数据库里面的数据表等等。</p>
<p>除此之外，也可以在操作数据表的前面加上数据库名称，但是那样比较麻烦。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use db_name</span><br></pre></td></tr></table></figure>

<h5 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h5><p>使用<code>ALTER DATABASE</code>指令可以修改数据库。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE db_name</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> gb2312</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> gb2312_chinese_ci;</span><br></pre></td></tr></table></figure>

<h5 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h5><p>当这个数据库不再使用的时候，可以通过<code>DROP DATABSE</code>指令来删除掉这个数据库。</p>
<p><code>IF EXISTS</code>代表存在则删除，不存在就不会删除。和创建的时候那个指令正好相反。都是可选指令。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> &#123;DATABASE&#125; [IF <span class="keyword">EXISTS</span>] db_name;</span><br></pre></td></tr></table></figure>


<h4 id="表定义"><a href="#表定义" class="headerlink" title="表定义"></a>表定义</h4><p>数据表被定义为字段的集合<br>按 <code>行</code> 和<code>列</code>的格式存储<br>每一行代表一条记录<br>每一列代表记录中一个字段的取值</p>
<h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><p>使用<code>create table</code>指令可以创建数据表，后面跟的是表名称和字段。</p>
<p><code>temporary</code>表示临时表，临时表存放在内存中。</p>
<p>字段类型常用的如下：</p>
<ul>
<li>int类型，占11位，也可以设置为int(5)等，但是这个只影响展示，并不影响实际的存储。</li>
<li>varchar&#x2F;char类型，相当于字符串类型，varchar是可变长度的字符串，char是不可变长度的字符串。</li>
<li>text类型，很不推荐使用该类型，会导致查询速度变慢，尽量使用varchar代替。</li>
<li>timestamp时间戳类型，不推荐使用，因为该类型表示1970年到现在的秒数，最大只能到2038-01-19号，而现在已经2025年了。</li>
<li>datetime类型，推荐使用这个代替时间戳，直接存储时间类型，并且表里的updated_time字段可以使用<code>DEFAULT CURRENT_TIMESTAMP</code>作为默认值，还可以使用<code>ON UPDATE CURRENT_TIMESTAMP</code>来实现自动更新。</li>
<li>decimal类型,用来存储小数，使用定点小数来存储，可以防止精度丢失。请避免使用<code>float</code>和<code>double</code>来存储小数。</li>
<li>json类型，可以存储json字符串。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [temporary] <span class="keyword">table</span> [if <span class="keyword">not</span> <span class="keyword">exists</span>] tbl_name</span><br><span class="line">(</span><br><span class="line">    字段名<span class="number">1</span> 数据类型 [列完整性约束条件] [默认值]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h5><p>对于创建的表结构不满意，可以通过<code>ALTER TABLE</code>指令来修改表结构。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br></pre></td></tr></table></figure>

<p>下面介绍一些子句，配合alter table命令来执行。</p>
<ul>
<li>ADD [COLUMN] 子句：给表结构增加字段。</li>
<li>change [COLUMN] 子句：修改表结构的字段类型、字段名称等。<ul>
<li>CHANGE COLUMN name new_name VARCHAR(200);</li>
</ul>
</li>
<li>alter [column] 子句 修改或删除表中指定列的默认值。<ul>
<li>alter colum city set default ‘bj’</li>
</ul>
</li>
<li>modify [column] 子句 只修改指定列的数据类型，不会干涉它的列名<ul>
<li>modify column city char(50);</li>
</ul>
</li>
<li>drop [column] 子句 删除指定列<ul>
<li>drop column city;</li>
</ul>
</li>
<li>rename [to] 子句 修改表名<ul>
<li>rename table table_name to new_table_name</li>
</ul>
</li>
<li>add index index_name(column_name) 创建索引</li>
<li>drop index index_name</li>
</ul>
<h5 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h5><p>当一个表不再使用的时候，也可以使用<code>drop table</code>将它删除。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> [temporary] <span class="keyword">table</span> [if <span class="keyword">exists</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h5><p>可以通过<code>SHOW CREATE TABLE</code>来查看表结构。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename;</span><br></pre></td></tr></table></figure>

<h4 id="索引定义"><a href="#索引定义" class="headerlink" title="索引定义"></a>索引定义</h4><p>索引是提高数据文件访问效率的有效方法，比如MySQL中的B+树索引、hash索引、全文索引等。</p>
<p>缺点</p>
<ul>
<li>索引是以文件的形式存储的，如果有大量的索引，索引文件可能比数据文件更快达到最大的文件尺寸</li>
<li>索引在提高查询速度的同时，会降低更新表的速度</li>
</ul>
<h5 id="索引物理结构"><a href="#索引物理结构" class="headerlink" title="索引物理结构"></a>索引物理结构</h5><ul>
<li>b+树索引</li>
<li>hash索引</li>
<li>倒排索引</li>
</ul>
<h5 id="索引逻辑结构"><a href="#索引逻辑结构" class="headerlink" title="索引逻辑结构"></a>索引逻辑结构</h5><ul>
<li>index 或 key： 普通索引</li>
<li>unique ：唯一性索引 候选码</li>
<li>primary key： 主键</li>
</ul>
<h5 id="索引逻辑概念"><a href="#索引逻辑概念" class="headerlink" title="索引逻辑概念"></a>索引逻辑概念</h5><ul>
<li>聚簇索引：比如主键索引，也就是b树的叶子节点存储数据的索引。</li>
<li>联合索引：由多个字段共同组成的索引。</li>
<li>覆盖索引：查询的字段和索引的字段一致，从而避免了再次去主键索引获取数据。</li>
</ul>
<p>关于索引的具体讲解将放在原理篇讲解，这里以介绍DDL语句为主，有个概念就可以了。</p>
<h5 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h5><p>想要创建一个索引可以使用<code>create index</code>命令，<code>unique</code>表示创建唯一索引。</p>
<p><code>index_col_name</code>表示要将索引创建在哪个字段上面，也可以是多个字段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>] index index_name</span><br><span class="line"><span class="keyword">on</span> table_name(index_col_name)</span><br></pre></td></tr></table></figure>

<p>示例，在user表上的<code>email</code>字段上创建一个索引，索引名称是<code>email_idx</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index email_idx</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">user</span>(email);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>索引并不是越多越好，太多的索引会导致维护成本升高，尽量少且有用即可。尤其是后续增加索引的时候，如果数据表中数据过多，建立索引的过程会较慢，会对业务产生影响，这个时候需要慎重。</p>
</blockquote>
<h5 id="索引删除"><a href="#索引删除" class="headerlink" title="索引删除"></a>索引删除</h5><p>当索引不再使用的时候，可以删除索引，使用命令<code>drop index</code>可以删除索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> [<span class="keyword">unique</span>] index index_name</span><br><span class="line"><span class="keyword">on</span> table_name</span><br></pre></td></tr></table></figure>

<p>示例：删除刚才建立的<code>email_idx</code>索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index email_idx</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<h4 id="视图定义"><a href="#视图定义" class="headerlink" title="视图定义"></a>视图定义</h4><p>什么是视图</p>
<ul>
<li>视图是一个对象，他是数据库提供给用户的以多种角度观察数据库中数据的一种重要机制</li>
<li>视图不是数据库中真实的表，而是一张虚拟表，其自身并不存储数据</li>
</ul>
<p>视图的优点</p>
<ul>
<li>集中分散数据</li>
<li>简化查询语句</li>
<li>重用SQL语句</li>
<li>保护数据安全</li>
<li>共享所需数据</li>
<li>更改数据格式</li>
</ul>
<h5 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h5><p>想要创建视图，可以使用<code>create view</code>指令。</p>
<p><code>or replace</code> 防止报错，存在替换，不存在创建。<br><code>with check option</code> 增删改查的时候检查视图条件。<br><code>select_statement</code> 是一段select查询语句。视图的本质就是这一段select查询语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">view</span> view_name [(col_list)]</span><br><span class="line"><span class="keyword">as</span> select_statement</span><br><span class="line">[<span class="keyword">with</span> <span class="keyword">check</span> option]</span><br></pre></td></tr></table></figure>

<p>示例：创建一个<code>zhangsan</code>用户的登录记录的视图。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> zhangsan</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> login_log <span class="keyword">where</span> <span class="keyword">user</span> <span class="operator">=</span> ‘zhangsan’</span><br></pre></td></tr></table></figure>

<h5 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h5><p>想要修改视图，可以使用<code>alter view</code>指令。</p>
<p>修改视图其实就是修改这个查询语句。当然了，也可以修改其他的属性等。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> view_name [(col_list)]</span><br><span class="line"><span class="keyword">as</span> select_statement</span><br><span class="line">[<span class="keyword">with</span> <span class="keyword">check</span> option]</span><br></pre></td></tr></table></figure>

<h5 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h5><p>当视图不需要了，可以使用<code>drop view</code>指令删除视图。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [IF <span class="keyword">EXISTS</span>] view_name</span><br></pre></td></tr></table></figure>

<p>示例：删除刚才创建的视图zhangsan</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">view</span> zhangsan</span><br></pre></td></tr></table></figure>

<h5 id="查看视图定义"><a href="#查看视图定义" class="headerlink" title="查看视图定义"></a>查看视图定义</h5><p>和上面说的查看表的定义一样，也可以查看视图的定义。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> view_name</span><br></pre></td></tr></table></figure>

<h4 id="存储过程定义"><a href="#存储过程定义" class="headerlink" title="存储过程定义"></a>存储过程定义</h4><p><code>存储过程</code> 是一组为了完成某项特定功能的 <code>SQL语句集</code></p>
<ul>
<li>可增强SQL语言的功能和灵活性</li>
<li>良好的封装性</li>
<li>高性能</li>
<li>可减少网络流量</li>
<li>可作为一种安全机制来确保数据库的安全性和数据的完整性<br>其实质就是一段存储在数据库中的 <code>代码</code><br>它可以由声明式的sql语句和过程式sql语句组成</li>
</ul>
<h5 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h5><p><code>DELIMITER $$</code>是用户定义的MYSQL 结束符</p>
<p>参数：in|out|inout 参数名 参数类型</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> sp_name(参数)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">body <span class="operator">/</span><span class="operator">/</span>存储过程代码</span><br><span class="line"><span class="keyword">END</span> $$</span><br></pre></td></tr></table></figure>

<p>示例：查询员工表的名称、部门和薪资。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> get_employee_details(<span class="keyword">IN</span> emp_id <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> name, department, salary</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> id <span class="operator">=</span> emp_id;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h5 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h5><p>调用需要使用<code>call</code>指令来调用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> sp_name(参数)</span><br></pre></td></tr></table></figure>

<p>示例：调用刚才的存储过程。 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> get_employee_details(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h5 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h5><p>如果存储过程不再需要了，则可以通过<code>drop procedure</code>指令来删除它。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> sp_name</span><br></pre></td></tr></table></figure>

<p>示例：删除刚才的存储过程。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> get_employee_details;</span><br></pre></td></tr></table></figure>

<h4 id="存储函数定义"><a href="#存储函数定义" class="headerlink" title="存储函数定义"></a>存储函数定义</h4><p>存储函数由SQL语句和过程式语句组成。</p>
<h5 id="创建存储函数"><a href="#创建存储函数" class="headerlink" title="创建存储函数"></a>创建存储函数</h5><p>使用 <code>create function</code>指令可以创建一个存储函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> sp_name(参数)</span><br><span class="line">    <span class="keyword">returns</span> type</span><br><span class="line">    routine_body <span class="operator">/</span><span class="operator">/</span>主体</span><br></pre></td></tr></table></figure>

<p>示例：给定id号返回性别。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">use test; <span class="operator">/</span><span class="operator">/</span>进入数据库test</span><br><span class="line">delimiter $$ <span class="operator">/</span><span class="operator">/</span>声明结束符号</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> fn_search(cid <span class="type">int</span>) <span class="operator">/</span><span class="operator">/</span>创建函数fn <span class="keyword">search</span>，参数为cid，<span class="type">int</span>类型</span><br><span class="line">    <span class="keyword">returns</span> <span class="type">char</span>(<span class="number">20</span>) <span class="operator">/</span><span class="operator">/</span>声明返回值类型char20</span><br><span class="line">    <span class="keyword">deterministic</span></span><br><span class="line"><span class="keyword">begin</span> <span class="operator">/</span><span class="operator">/</span>开始</span><br><span class="line">    <span class="keyword">declare</span> sex <span class="type">char</span>(<span class="number">20</span>) <span class="operator">/</span><span class="operator">/</span>声明一个变量sex 类型char20</span><br><span class="line">    <span class="keyword">select</span> cust_sex <span class="keyword">into</span> sex <span class="keyword">from</span> customers <span class="keyword">where</span> id <span class="operator">=</span> cid; <span class="operator">/</span><span class="operator">/</span><span class="keyword">select</span>语句，把查询出来的cust_sex字段内容放入变量sex中</span><br><span class="line">    if sex <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="operator">/</span><span class="operator">/</span>if判断，如果sex变量是<span class="keyword">null</span>，则返回<span class="string">&#x27;没有该客户&#x27;</span></span><br><span class="line">        <span class="keyword">return</span>(<span class="keyword">select</span> <span class="string">&#x27;没有该客户&#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="operator">/</span><span class="operator">/</span>如果sex变量不是<span class="keyword">null</span></span><br><span class="line">        if sex <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">then</span> <span class="operator">/</span><span class="operator">/</span>则判断是F的话，返回<span class="string">&#x27;女&#x27;</span></span><br><span class="line">            <span class="keyword">return</span>(<span class="keyword">select</span> <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="operator">/</span><span class="operator">/</span> 不然的话就返回<span class="string">&#x27;男&#x27;</span></span><br><span class="line">            <span class="keyword">return</span>(<span class="keyword">select</span> <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        <span class="keyword">end</span> if;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span> $$</span><br></pre></td></tr></table></figure>

<h5 id="调用存储函数"><a href="#调用存储函数" class="headerlink" title="调用存储函数"></a>调用存储函数</h5><p>使用 select 调用存储函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sp_name(参数)；</span><br></pre></td></tr></table></figure>

<p>示例：调用刚才的存储函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> fn_search(<span class="number">1</span>)$$</span><br></pre></td></tr></table></figure>

<h5 id="删除存储函数"><a href="#删除存储函数" class="headerlink" title="删除存储函数"></a>删除存储函数</h5><p>当存储函数不再使用的时候，可以使用<code>drop function</code>将它删除。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">function</span> fun_name</span><br></pre></td></tr></table></figure>

<p>示例：删除刚才的存储函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">function</span> fn_search</span><br></pre></td></tr></table></figure>

<h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>以上就是整体的MySQL学习路线了。</p>
<p>关注我发送“MySQL知识图谱”领取完整的MySQL学习路线。</p>
<p>发送“电子书”即可领取价值上千的电子书资源。</p>
<p>部分电子书如图所示。</p>
<p><img src="/../images/bottom1.png" alt="概念学习"></p>
<p><img src="/../images/bottom2.png" alt="概念学习"></p>
<p><img src="/../images/bottom3.png" alt="概念学习"></p>
<p><img src="/../images/bottom4.png" alt="概念学习"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87.html" class="post-title-link" itemprop="url">MySQL零基础教程基础篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-26 10:12:47" itemprop="dateCreated datePublished" datetime="2023-04-26T10:12:47+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-05 10:06:54" itemprop="dateModified" datetime="2025-02-05T10:06:54+08:00">2025-02-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMU15445/" itemprop="url" rel="index"><span itemprop="name">CMU15445</span></a>
                </span>
            </span>

          
            <span id="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87.html" class="post-meta-item leancloud_visitors" data-flag-title="MySQL零基础教程基础篇" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL零基础教程基础篇"><a href="#MySQL零基础教程基础篇" class="headerlink" title="MySQL零基础教程基础篇"></a>MySQL零基础教程基础篇</h1><p>大家好，我是大头，98年，职高毕业，上市公司架构师，大厂资深开发，管理过10人团队，我是如何做到的呢？</p>
<p>这离不开持续学习的能力，而其中最重要的当然是数据库技术了！</p>
<p>对于所有开发来说，都离不开数据库，因为所有的数据都是要存储的。</p>
<p>关注我一起学习！文末有惊喜哦！</p>
<p>基础篇的内容大致如下图所示。</p>
<p><img src="/../images/mysql/mysql1-1.png" alt="概念学习"></p>
<h2 id="概念学习"><a href="#概念学习" class="headerlink" title="概念学习"></a>概念学习</h2><p>首先，我们应该知道什么是数据库？很多人都会搞混一个概念，那就是数据库和数据库管理系统。</p>
<p>数据库的英文是<code>DataBase</code>。它的概念是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">数据库是一个长期存储在计算机内的、有组织的、可共享的数据集合，它具有以下特点</span><br><span class="line">1. 数据的集合性</span><br><span class="line">2. 数据的共享性</span><br><span class="line">3. 数据的冗余度低</span><br><span class="line">4. 数据的独立性</span><br><span class="line">5. 数据的安全性</span><br><span class="line">6. 数据的完整性</span><br><span class="line">7. 数据的可维护性</span><br></pre></td></tr></table></figure>

<p>而数据库管理系统的英文是<code>DataBase Management System</code>。它的概念是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据库管理系统（Database Management System，简称DBMS）是用于创建、管理、维护和操作数据库的软件系统。它在用户和数据库之间提供了一个接口，使得用户能够方便地存储、检索、更新和管理数据。</span><br></pre></td></tr></table></figure>

<p>因此，我们要明白，<code>MySQL</code>是一个数据库管理系统，而不是一个数据库。</p>
<p>虽然我们老说<code>MySQL数据库</code>，但这个是因为大家已经习惯了，大家都明白MySQL是什么，因此省略了一些。</p>
<p><code>MySQL</code>是用来管理数据库的一个系统。</p>
<p>那么问题来了，<code>SQL</code>又是什么呢？</p>
<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>SQL（Structured Query Language，结构化查询语言）是一种用于管理和操作关系数据库的标准编程语言。它允许用户定义、查询、更新和管理数据库中的数据。SQL 是关系数据库管理系统（RDBMS）的核心语言，广泛应用于各种数据库系统。</p>
<p>这里又出现了一个新的概念，就是<code>关系数据库管理系统（RDBMS）</code>。</p>
<p>上面已经介绍了<code>数据库管理系统</code>。那什么是关系数据库管理系统呢？</p>
<h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3><p>这里就需要先说明一下什么是<code>关系数据库</code>。</p>
<p>关系数据库（Relational Database）<br>关系数据库是一种基于关系模型的数据库管理系统（DBMS），它使用表格（表）来组织和存储数据。每个表由行（记录）和列（字段）组成，每一行代表一个数据记录，每一列代表一个数据属性。关系数据库的核心概念是关系模型，它由数学家埃德加·弗兰克·科德（E.F. Codd）在1970年提出。</p>
<h4 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h4><p>Ted Codd在1969年设计了关系模型。发表了<a target="_blank" rel="noopener" href="https://dl.acm.org/doi/pdf/10.1145/362384.362685">A relational model of data for large shared data banks</a> </p>
<p>关系模型将物理层和逻辑层分离，当数据的内部表示发生变化时，甚至当外部表示的某些方面发生变化时，用户在终端和大多数应用程序上的活动应该不受影响。</p>
<p>关系模型提供了一种仅用数据的自然结构来描述数据的方法，因此，它为高级数据语言提供了一个基础，这种语言将一方面在程序之间产生最大的独立性，另一方面在机器表示和数据组织之间产生最大的独立性。另一个优点是，它为处理关系的可导出性、冗余性和一致性提供了坚实的基础。</p>
<p>仍然需要消除的三种主要数据依赖是：顺序依赖、索引依赖和访问路径依赖。</p>
<ul>
<li>顺序依赖：程序展示的顺序和文件内容的存储顺序并不一致，需要各自独立。</li>
<li>索引依赖：如果程序使用索引的时候，索引被删除那么程序将出错。</li>
<li>访问路径依赖：访问数据的时候依赖数据的物理结构。</li>
</ul>
<p><code>关系</code>指的是数学意义上的关系，对于给定集合S1,S2,S3…Sn，R是n个集合上的关系，如果它是n个元组的集合，每个元组的第一个元素来自S1,第二个来自S2，以此类推。我们称Sj是R上的第j个定义域。R的阶为n(degree n)，阶为1的时候称为一元关系，2的时候称为二元关系，阶为n称为n元关系。</p>
<p>关键原则：</p>
<ul>
<li>将数据存储在简单的数据结构(关系)中</li>
<li>物理存储留给DBMS实现</li>
<li>通过高级语言访问数据，DBMS确定最佳策略。</li>
</ul>
<p>结构采用关系。确保数据库内容满足完整性约束。程序通过接口来访问和修改数据库内容。</p>
<p>关系是无序的，n元关系就是n个列的表。一个元组是一行记录。</p>
<p>关系数据库就是基于<code>关系模型</code>的数据库。</p>
<p>其具体的体现形式就是我们通常说的<code>表</code>。</p>
<p>建表语句如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    department <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    salary <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>除此之外，还有一些<code>关系完整性约束</code>。以确保数据的准确性和一致性。常见的完整性约束包括：</p>
<ul>
<li>主键约束（Primary Key）：确保表中每一行的唯一性。</li>
<li>外键约束（Foreign Key）：确保表之间的关系完整性。</li>
<li>唯一约束（Unique）：确保某一列或一组列的值是唯一的。</li>
<li>非空约束（NOT NULL）：确保某一列的值不能为空。</li>
<li>检查约束（CHECK）：确保某一列的值满足特定条件。</li>
</ul>
<p>这里面主键约束是必须的。<code>外键约束</code>通常不使用，因为保证这些约束，会降低数据库的性能。因此外键约束通常由代码层实现。</p>
<p>唯一约束有的时候是可以使用的，来限制唯一性，同样也可以通过代码层实现。</p>
<p>非空约束也是推荐使用的，因为<code>NULL</code>在数据库里面处理起来也有一些麻烦，也会影响性能。</p>
<p>检查约束实际上也基本不使用。</p>
<p>支持SQL标准，实现了SQL标准，最低要求实现SQL92标准。</p>
<p>关系数据库支持事务（Transaction），事务是一组操作的集合，要么全部成功，要么全部失败。事务的四个基本特性（ACID）包括：</p>
<ul>
<li>原子性（Atomicity）：事务中的所有操作要么全部成功，要么全部失败。</li>
<li>一致性（Consistency）：事务执行前后，数据库的状态保持一致。</li>
<li>隔离性（Isolation）：并发事务之间相互隔离，不会相互干扰。</li>
<li>持久性（Durability）：事务一旦提交，其结果是永久性的，即使系统故障也不会丢失。</li>
</ul>
<h3 id="SQL标准"><a href="#SQL标准" class="headerlink" title="SQL标准"></a>SQL标准</h3><p>SQL标准是一系列由国际标准化组织（ISO）和美国国家标准协会（ANSI）制定的规范，旨在确保SQL语言的统一性和兼容性。这些标准定义了SQL语言的语法、语义和行为，使得不同的数据库管理系统（DBMS）能够以一致的方式实现和使用SQL。</p>
<p>主要的SQL标准：</p>
<ol>
<li>SQL-86（1986年）：</li>
</ol>
<ul>
<li>第一个SQL标准，奠定了SQL语言的基础。</li>
<li>定义了基本的SQL语法和功能，包括数据定义语言（DDL）和数据操纵语言（DML）。</li>
</ul>
<ol start="2">
<li>SQL-89（1989年）：</li>
</ol>
<ul>
<li>对SQL-86的修订和扩展，增加了对嵌套查询和子查询的支持。</li>
<li>也称为SQL1，是第一个广泛接受的SQL标准。</li>
</ul>
<ol start="3">
<li>SQL-92（1992年）：</li>
</ol>
<ul>
<li>也称为SQL2，是SQL标准的重大更新。</li>
<li>引入了大量新功能，包括：<ul>
<li>外键约束（Foreign Key Constraints）</li>
<li>多表连接（JOIN）</li>
<li>嵌套查询（Subqueries）</li>
<li>集合操作（Set Operations）</li>
<li>视图（Views）</li>
<li>完整性约束（Integrity Constraints）</li>
</ul>
</li>
<li>SQL-92 是目前大多数数据库系统支持的基础标准。</li>
</ul>
<ol start="4">
<li>SQL:1999（1999年）：</li>
</ol>
<ul>
<li>引入了对大型对象（LOBs）、窗口函数（Window Functions）、递归查询（Recursive Queries）等的支持。</li>
<li>也称为SQL3，是SQL标准的进一步扩展。</li>
</ul>
<ol start="5">
<li>SQL:2003（2003年）：</li>
</ol>
<ul>
<li>引入了对XML数据类型和操作的支持。</li>
<li>增加了对存储过程、触发器、用户定义类型（UDTs）等的支持。</li>
</ul>
<ol start="6">
<li>SQL:2006（2006年）：</li>
</ol>
<ul>
<li>主要关注XML数据的处理和查询。</li>
<li>引入了对XQuery的支持。</li>
</ul>
<ol start="7">
<li>SQL:2008（2008年）：</li>
</ol>
<ul>
<li>引入了对时间数据类型和操作的支持。</li>
<li>增加了对分区表、数据加密等的支持。</li>
</ul>
<ol start="8">
<li>SQL:2011（2011年）：</li>
</ol>
<ul>
<li>引入了对多版本并发控制（MVCC）的支持。</li>
<li>增加了对分区表的进一步扩展。</li>
</ul>
<ol start="9">
<li>SQL:2016（2016年）：</li>
</ol>
<ul>
<li>引入了对JSON数据类型和操作的支持。</li>
<li>增加了对窗口函数的进一步扩展。</li>
</ul>
<ol start="10">
<li>SQL:2019（2019年）：</li>
</ol>
<ul>
<li>引入了对机器学习和数据分析的支持。</li>
<li>增加了对时间序列数据、地理空间数据等的支持。</li>
</ul>
<p>尽管SQL标准提供了统一的规范，但不同的数据库系统在实现上存在差异。主要的数据库系统（如MySQL、PostgreSQL、Oracle、SQL Server等）都支持SQL标准的核心功能，但在某些高级功能和扩展上可能有所不同。例如：</p>
<ul>
<li>MySQL：支持SQL:2003标准，但在某些高级功能（如窗口函数）上支持较晚。</li>
<li>PostgreSQL：支持SQL:2011标准，对SQL标准的兼容性较好。</li>
<li>Oracle：支持SQL:2011标准，但在某些功能上有自己的扩展。</li>
<li>SQL Server：支持SQL:2008标准，但在某些功能上有自己的扩展。</li>
</ul>
<p>SQL标准是一系列由ISO和ANSI制定的规范，旨在确保SQL语言的统一性和兼容性。不同的数据库系统在实现上存在差异，但都支持SQL标准的核心功能。了解数据库系统对SQL标准的支持情况，可以帮助开发者更好地编写跨数据库的SQL代码，提高代码的可移植性和兼容性。</p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><ul>
<li>关系模型：大多数数据库使用的</li>
<li>键值对模型：NOSql使用的，比如redis</li>
<li>图模型：NOSql使用的</li>
<li>文档模型：NOSql使用的，比如mongoDB</li>
<li>列存储模型</li>
<li>数组，向量模型：向量数据库，如Fassi</li>
<li>分组模型，网络模型，多值模型：已经很少使用的模型</li>
</ul>
<h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>设R为任一给定关系，如果对于R中属性X的每一个值，R中的属性Y只有唯一值与之对应，则称X函数决定Y或称Y函数依赖于X，记作X-&gt;Y.其中X称为<code>决定因素</code></p>
<p>分类：</p>
<ul>
<li>完全函数依赖</li>
<li>部分函数依赖</li>
<li>传递函数依赖</li>
</ul>
<p> 完全函数依赖：<br> 设R为任一给定关系，X,Y为其属性集，若X-&gt;Y，且对X中的任何真子集X’，都有X’不依赖Y,则称Y完全函数依赖于X</p>
<p> 部分函数依赖：<br> 设R为任一给定关系，X,Y为其属性集，若X-&gt;Y,且X中存在一个真子集X’,都有X’-&gt;Y，则称Y部分依赖于X</p>
<p> 传递函数依赖：<br> 设R为任一给定关系，X,Y,Z为其不同属性子集，若X-&gt;Y,Y不决定X,Y-&gt;Z,则有X-&gt;Z，称为Z传递函数依赖于X。</p>
<h3 id="设计范式"><a href="#设计范式" class="headerlink" title="设计范式"></a>设计范式</h3><p>一个低一级范式的关系模式通过<code>模式分解</code>可以转换为若干个高一级范式的关系模式的集合，这种过程就叫<code>规范化</code></p>
<p>第一范式1NF:<br>设R为任一给定关系，如果R中每个列与行的交点处的取值都是不可再分的基本元素，则R为第一范式</p>
<p>第二范式2NF:<br>设R为任一给定关系，若R为1NF<br>且其所有非主属性都完全函数依赖于候选关键字，则R为第二范式。</p>
<p>候选关键字：能唯一表示一行数据的就是候选关键字，比如主键，比如唯一索引等。</p>
<p>第三范式3NF:<br>设R为任一给定关系，若R为2NF<br>且其每一个非主属性都不传递函数依赖于候选关键字，则R为第三范式。</p>
<p>第三范式的改进形式BCNF:<br>设R为任意给定关系，X,Y为其属性集，F为其函数依赖集，若R为3NF<br>且其F中所有函数依赖X-&gt;Y(Y不属于X)中的X比包含候选关键字，则R为BCNF</p>
<p>有部分函数依赖就是1NF，没有就是2NF，没有传递函数依赖就是3NF</p>
<p>1NF-&gt;2NF<br>找到候选关键字，看其余的属性是否完全函数依赖候选关键字<br>是的，与候选关键字一同抄下来形成一个表格<br>不是的，抄下来，形成第二个表格，并且将候选关键字里能够唯一决定表格2的属性组抄在第一列</p>
<p>2NF-&gt;3NF<br>找到表格中的传递函数依赖关系的三个属性组，设为X,Y,Z<br>将这三个属性组拆成两个表格<br>第一个表格为X,Y<br>第二个表格为Y,Z</p>
<p>3NF-&gt;BCNF<br>列出表格中的所有函数依赖关系<br>每个关系拆出一个表格</p>
<h3 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h3><p>ER图是一种图形化的表示方法，用于描述数据库中的实体、实体之间的关系以及实体的属性。它是一种强大的工具，广泛应用于数据库设计和概念建模阶段，帮助开发者和分析师理解数据结构和数据之间的关系。</p>
<p>ER图的主要组成部分</p>
<ul>
<li>实体（Entity）：<ul>
<li>实体是数据库中具有相同属性集合的对象。例如，学生、课程、教师等。</li>
<li>在ER图中，实体通常用矩形表示，矩形内写上实体的名称。</li>
</ul>
</li>
<li>属性（Attribute）：<ul>
<li>属性是实体的特征或性质。例如，学生的属性可以包括学号、姓名、年龄等。</li>
<li>在ER图中，属性通常用椭圆表示，椭圆内写上属性的名称，并用线连接到对应的实体。</li>
</ul>
</li>
</ul>
<p>下图就是一个<code>ER图</code>，<code>实体</code>是<code>管理员用户</code>。<code>属性</code>有头像、密码、登录名、ID、邮箱、手机号。</p>
<p><img src="/../images/mysql/mysql3-1.png" alt="概念学习"></p>
<ul>
<li>关系（Relationship）：<ul>
<li>关系描述了实体之间的联系。例如，学生和课程之间的关系可以是选修。</li>
<li>在ER图中，关系通常用菱形表示，菱形内写上关系的名称，并用线连接到相关的实体。</li>
</ul>
</li>
<li>关系的类型：<ul>
<li>一对一关系（1:1）：一个实体与另一个实体之间存在一对一的联系。例如，一个学生对应一个学号。</li>
<li>一对多关系（1:N）：一个实体与多个实体之间存在联系。例如，一个教师可以教授多个课程。</li>
<li>多对多关系（M:N）：多个实体与多个实体之间存在联系。例如，一个学生可以选修多个课程，一个课程也可以被多个学生选修。</li>
</ul>
</li>
</ul>
<p>下图就是一个ER图，<code>实体</code>是管理员用户和角色两个。<code>关系</code>是<code>拥有</code>，表示管理员用户拥有角色的关系。关系的类型用<code>m和n</code>表示<code>多对多关系</code>。意思是一个管理员用户可以拥有多个角色，一个角色也可以被多个管理员用户拥有。</p>
<p><img src="/../images/mysql/mysql3-2.png" alt="概念学习"></p>
<p>画ER图可以使用<a target="_blank" rel="noopener" href="https://www.processon.com/i/637308dd762131535d6884f7?full_name=osgpjw20iEaJn-L">processOn</a></p>
<h3 id="OLTP"><a href="#OLTP" class="headerlink" title="OLTP"></a>OLTP</h3><p>OLTP（Online Transaction Processing，联机事务处理）数据库是一种用于支持日常事务处理和业务操作的数据库系统。它旨在快速处理大量的在线事务，确保数据的完整性和一致性。OLTP数据库广泛应用于各种需要实时数据处理的场景，如银行系统、电子商务平台、企业资源规划（ERP）系统等。</p>
<p>OLTP数据库</p>
<ul>
<li>通常是业务侧使用的传统数据库，比如oracle,postgresql,mysql</li>
<li>小的业务多次执行，比如多个简单的插入，更新，查询</li>
</ul>
<h4 id="OLTP数据库的主要特点"><a href="#OLTP数据库的主要特点" class="headerlink" title="OLTP数据库的主要特点"></a>OLTP数据库的主要特点</h4><p>事务性：</p>
<ul>
<li>OLTP数据库的核心是事务处理。事务是一组操作的集合，要么全部成功，要么全部失败。OLTP系统支持ACID（原子性、一致性、隔离性、持久性）特性，确保事务的可靠性。</li>
<li>原子性（Atomicity）：事务中的所有操作要么全部成功，要么全部失败。</li>
<li>一致性（Consistency）：事务执行前后，数据库的状态保持一致。</li>
<li>隔离性（Isolation）：并发事务之间相互隔离，不会相互干扰。</li>
<li>持久性（Durability）：事务一旦提交，其结果是永久性的，即使系统故障也不会丢失。</li>
</ul>
<p>高性能：</p>
<ul>
<li>OLTP数据库设计用于快速处理大量的在线事务。它们通常具有高效的索引、优化的查询计划和低延迟的响应时间。</li>
<li>例如，银行系统需要在几毫秒内完成交易，OLTP数据库能够满足这种高性能要求。</li>
</ul>
<p>数据完整性：</p>
<ul>
<li>OLTP数据库通过各种完整性约束（如主键、外键、唯一约束、非空约束等）确保数据的准确性和一致性。</li>
<li>例如，一个订单表中的订单号必须是唯一的，客户表中的客户ID必须存在。</li>
</ul>
<p>并发处理：</p>
<ul>
<li>OLTP数据库支持高并发访问，允许多个用户同时进行事务操作。它们通过锁机制和事务隔离级别来管理并发事务，确保数据的一致性和完整性。</li>
<li>例如，多个用户可以同时在电子商务平台上下单，OLTP数据库能够处理这些并发请求。</li>
</ul>
<p>实时性：</p>
<ul>
<li>OLTP数据库提供实时数据处理，用户可以即时看到事务的结果。这使得OLTP系统适用于需要即时反馈的业务场景，如在线支付、库存管理等。</li>
<li>例如，用户在电子商务平台上下单后，系统立即更新库存信息并生成订单。</li>
</ul>
<h4 id="OLTP数据库的常见应用场景"><a href="#OLTP数据库的常见应用场景" class="headerlink" title="OLTP数据库的常见应用场景"></a>OLTP数据库的常见应用场景</h4><p>银行系统：</p>
<ul>
<li>用于处理日常的银行交易，如存款、取款、转账等。这些交易需要快速、准确地完成，确保数据的一致性和完整性。<br>电子商务平台：</li>
<li>用于处理用户的订单、支付、库存管理等。这些系统需要支持高并发访问，确保用户能够实时看到订单状态和库存信息。<br>企业资源规划（ERP）系统：</li>
<li>用于管理企业的各种资源，如人力资源、财务资源、生产资源等。这些系统需要处理大量的事务，确保数据的准确性和一致性。<br>客户关系管理（CRM）系统：</li>
<li>用于管理客户信息、销售机会、客户服务等。这些系统需要支持实时数据处理，确保客户信息的准确性和及时性。</li>
</ul>
<p>OLTP数据库是一种用于支持日常事务处理和业务操作的数据库系统。它具有事务性、高性能、数据完整性、并发处理和实时性等特点，广泛应用于银行系统、电子商务平台、企业资源规划（ERP）系统等。常见的OLTP数据库管理系统包括MySQL、PostgreSQL、Oracle Database、Microsoft SQL Server和SQLite。</p>
<h3 id="OLAP"><a href="#OLAP" class="headerlink" title="OLAP"></a>OLAP</h3><p>OLAP（Online Analytical Processing，联机分析处理）数据库是一种用于支持复杂的数据分析和报告的数据库系统。它旨在快速处理大量的数据，提供多维度的数据分析能力，帮助用户从不同角度理解数据。OLAP数据库广泛应用于数据仓库、商业智能（BI）和决策支持系统。</p>
<p>OLAP数据库</p>
<ul>
<li>通常是大数据，数据分析来使用，比如Hbase等，支持复杂的数据查询</li>
<li>OLAP位于OLTP的后方</li>
</ul>
<h4 id="OLAP数据库的主要特点"><a href="#OLAP数据库的主要特点" class="headerlink" title="OLAP数据库的主要特点"></a>OLAP数据库的主要特点</h4><p>多维数据分析：</p>
<ul>
<li>OLAP数据库支持多维数据分析，允许用户从不同角度（如时间、地区、产品等）查看数据。这种多维视图有助于用户发现数据中的模式和趋势。</li>
<li>例如，用户可以按季度、地区和产品类别分析销售数据。</li>
</ul>
<p>高性能查询：</p>
<ul>
<li>OLAP数据库优化了对大量数据的读取操作，能够快速响应复杂的查询请求。它们通常使用预计算的聚合数据和索引技术来提高查询性能。</li>
<li>例如，数据仓库中的销售数据可以按季度、地区和产品类别预计算，以便快速生成报告。</li>
</ul>
<p>数据聚合：</p>
<ul>
<li>OLAP数据库支持数据的聚合操作，如求和、平均、最大值、最小值等。这些聚合操作通常在数据加载时预先计算，以便快速生成报告。</li>
<li>例如，销售数据可以按季度、地区和产品类别进行汇总，以便快速生成销售报告。</li>
</ul>
<p>数据立方体（Data Cube）：</p>
<ul>
<li>OLAP数据库使用数据立方体（Data Cube）来组织数据。数据立方体是一个多维数据结构，允许用户从不同维度查看数据。</li>
<li>例如，一个销售数据立方体可以包含时间维度（年、季度、月）、地区维度（国家、城市）和产品维度（类别、品牌）。</li>
</ul>
<p>数据更新：</p>
<ul>
<li>OLAP数据库通常不需要实时更新，数据通常在定期的时间间隔内批量加载。这使得OLAP数据库能够优化读取操作，提高查询性能。</li>
<li>例如，销售数据可以在每天晚上批量加载到数据仓库中。</li>
</ul>
<h4 id="OLAP数据库的常见应用场景"><a href="#OLAP数据库的常见应用场景" class="headerlink" title="OLAP数据库的常见应用场景"></a>OLAP数据库的常见应用场景</h4><p>数据仓库：</p>
<ul>
<li>用于存储和管理企业的历史数据，支持复杂的查询和报告。数据仓库通常从多个数据源（如事务处理系统）提取数据，进行清洗和转换，然后加载到数据仓库中。</li>
<li>例如，企业可以使用数据仓库来分析销售趋势、客户行为等。</li>
</ul>
<p>商业智能（BI）：</p>
<ul>
<li>用于支持企业的决策支持系统，提供数据驱动的决策支持。商业智能工具通常与OLAP数据库集成，提供交互式的报告和分析功能。</li>
<li>例如，企业可以使用商业智能工具生成销售报告、市场分析报告等。</li>
</ul>
<p>决策支持系统（DSS）：</p>
<ul>
<li>用于支持企业的决策过程，提供数据驱动的决策支持。决策支持系统通常使用OLAP数据库来存储和分析数据。</li>
<li>例如，企业可以使用决策支持系统来优化生产计划、资源分配等。</li>
</ul>
<p>OLAP数据库是一种用于支持复杂的数据分析和报告的数据库系统。它具有多维数据分析、高性能查询、数据聚合、数据立方体和数据更新等特点，广泛应用于数据仓库、商业智能（BI）和决策支持系统。常见的OLAP数据库管理系统包括HBase,ClickHouse等。</p>
<h3 id="高级概念"><a href="#高级概念" class="headerlink" title="高级概念"></a>高级概念</h3><p>接下来在介绍一下MySQL中会用到的高级概念，这些能更好的帮助大家理解除了正常的表以外的其他东西。</p>
<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>在MySQL中，<strong>视图（View）</strong>是一种虚拟表，其内容由SQL查询定义。视图并不存储实际的数据，而是根据定义的查询动态生成数据。视图可以简化复杂的SQL操作，提供数据的逻辑抽象，并且可以限制对某些数据的访问，从而增强数据的安全性。</p>
<p>MySQL中的视图是虚拟视图，说白了就是一条SQL语句，当查询视图的时候执行SQL语句而已。</p>
<p>除此之外，还有一个东西叫做<code>物化视图</code>，MySQL并没有实现这个东西，物化视图就是一张真的表，而不是一个SQL语句，因此查询效率更好。</p>
<h5 id="视图的主要特点"><a href="#视图的主要特点" class="headerlink" title="视图的主要特点"></a>视图的主要特点</h5><p>虚拟表：</p>
<ul>
<li>视图是一个虚拟表，其内容由SQL查询定义。视图本身并不存储数据，而是根据定义的查询动态生成数据。</li>
</ul>
<p>简化复杂查询：</p>
<ul>
<li>视图可以简化复杂的SQL操作，将复杂的查询逻辑封装起来，使用户可以像查询普通表一样查询视图。</li>
</ul>
<p>数据抽象：</p>
<ul>
<li>视图提供数据的逻辑抽象，隐藏了底层表的复杂性，使用户可以更直观地访问数据。</li>
</ul>
<p>安全性：</p>
<ul>
<li>视图可以限制对某些数据的访问，增强数据的安全性。通过视图，用户只能访问视图定义的特定数据，而不能访问底层表的全部数据。</li>
</ul>
<p>更新限制：</p>
<ul>
<li>视图可以是可更新的，也可以是不可更新的。可更新视图允许用户通过视图插入、更新或删除数据，但需要满足一定的条件。不可更新视图则不允许用户通过视图修改数据。</li>
</ul>
<p>创建一个视图。下面的语句，创建一个视图，视图名称是<code>sales_employees</code>，内容就是后面的Select语句的结果。当原始表<code>employees</code>变化以后，视图的内容也会跟着变化。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> sales_employees <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;Sales&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><p>在MySQL中，<strong>触发器（Trigger）</strong>是一种特殊的存储过程，它在特定的数据库操作（如INSERT、UPDATE、DELETE）发生时自动执行。触发器可以用于实现复杂的业务逻辑，确保数据的完整性和一致性，以及自动维护数据的同步。</p>
<h5 id="触发器的主要特点"><a href="#触发器的主要特点" class="headerlink" title="触发器的主要特点"></a>触发器的主要特点</h5><p>自动执行：</p>
<ul>
<li>触发器在特定的数据库操作发生时自动执行，无需显式调用。这使得触发器可以用于实现自动化的数据处理和维护。</li>
</ul>
<p>数据完整性：</p>
<ul>
<li>触发器可以用于确保数据的完整性和一致性。例如，可以在插入或更新数据时自动检查数据的有效性，或者在删除数据时自动清理相关数据。</li>
</ul>
<p>业务逻辑：</p>
<ul>
<li>触发器可以用于实现复杂的业务逻辑。例如，可以在插入或更新数据时自动计算某些字段的值，或者在删除数据时自动更新相关表的数据。</li>
</ul>
<p>数据同步：</p>
<ul>
<li>触发器可以用于自动维护数据的同步。例如，可以在插入或更新数据时自动更新相关表的数据，或者在删除数据时自动清理相关表的数据。</li>
</ul>
<h5 id="触发器的类型"><a href="#触发器的类型" class="headerlink" title="触发器的类型"></a>触发器的类型</h5><ul>
<li>BEFORE INSERT：<ul>
<li>在插入数据之前执行触发器逻辑。</li>
</ul>
</li>
<li>AFTER INSERT：<ul>
<li>在插入数据之后执行触发器逻辑。</li>
</ul>
</li>
<li>BEFORE UPDATE：<ul>
<li>在更新数据之前执行触发器逻辑。</li>
</ul>
</li>
<li>AFTER UPDATE：<ul>
<li>在更新数据之后执行触发器逻辑。</li>
</ul>
</li>
<li>BEFORE DELETE：<ul>
<li>在删除数据之前执行触发器逻辑。</li>
</ul>
</li>
<li>AFTER DELETE：<ul>
<li>在删除数据之后执行触发器逻辑。</li>
</ul>
</li>
</ul>
<h5 id="触发器的限制"><a href="#触发器的限制" class="headerlink" title="触发器的限制"></a>触发器的限制</h5><p>性能影响：</p>
<ul>
<li>触发器的执行会增加数据库操作的开销，可能会影响性能。因此，应谨慎使用触发器，避免在高频操作的表上定义过多的触发器。<br>复杂性：</li>
<li>触发器的逻辑可以非常复杂，但过多的复杂逻辑可能导致触发器难以维护和调试。因此，应尽量保持触发器的逻辑简单明了。<br>调试困难：</li>
<li>触发器的调试相对困难，因为它们在特定的操作发生时自动执行，难以直接观察和调试。因此，建议在开发和测试阶段充分测试触发器的逻辑。</li>
</ul>
<p>因此，实际开发中基本不使用触发器。</p>
<h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><p>在MySQL中，<strong>存储过程（Stored Procedure）</strong>是一种预编译的SQL语句集合，它存储在数据库中，可以通过调用其名称并传递参数来执行。存储过程可以包含复杂的逻辑和多个SQL语句，用于完成特定的任务。它们类似于其他编程语言中的函数或方法。</p>
<p>可以把存储过程想成一个函数。只不过是在MySQL中的函数，这个函数可以实现各种功能。可以实现一些复杂的SQL处理，这样可以简化调用。</p>
<h5 id="存储过程的主要特点"><a href="#存储过程的主要特点" class="headerlink" title="存储过程的主要特点"></a>存储过程的主要特点</h5><p>预编译：</p>
<ul>
<li>存储过程在创建时被预编译并存储在数据库中，这使得它们的执行速度比单独的SQL语句更快。<br>代码重用：</li>
<li>存储过程可以被多次调用，减少了代码重复，提高了开发效率。<br>减少网络流量：</li>
<li>存储过程在服务器端执行，减少了客户端和服务器之间的网络流量，因为只需要发送存储过程的名称和参数，而不是大量的SQL语句。<br>安全性：</li>
<li>存储过程可以限制用户对底层数据的直接访问，只允许通过存储过程进行数据操作，从而增强数据的安全性。<br>事务管理：</li>
<li>存储过程可以包含事务控制语句，如COMMIT和ROLLBACK，确保数据操作的完整性和一致性。</li>
</ul>
<p>创建一个存储过程get_employee_details，用于根据员工ID获取员工的详细信息：</p>
<p>DELIMITER用来设置结束符，比如正常的句子结束符是句号。代码结束符是分号；</p>
<p>IN代表输入参数，也就是这个函数有一个输入参数emp_id，是int类型。<br>还有out代表输出参数，用于返回结果。<br>INOUT代表既可以输入参数也可以是输出参数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> get_employee_details(<span class="keyword">IN</span> emp_id <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> name, department, salary</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> id <span class="operator">=</span> emp_id;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>上面这个存储过程的函数体，就是一段select查询语句。</p>
<h5 id="存储过程的限制"><a href="#存储过程的限制" class="headerlink" title="存储过程的限制"></a>存储过程的限制</h5><p>性能影响：</p>
<ul>
<li>存储过程的执行会增加数据库操作的开销，可能会影响性能。因此，应谨慎使用存储过程，避免在高频操作的表上定义过多的存储过程。<br>复杂性：</li>
<li>存储过程的逻辑可以非常复杂，但过多的复杂逻辑可能导致存储过程难以维护和调试。因此，应尽量保持存储过程的逻辑简单明了。<br>调试困难：</li>
<li>存储过程的调试相对困难，因为它们在服务器端执行，难以直接观察和调试。因此，建议在开发和测试阶段充分测试存储过程的逻辑。</li>
</ul>
<h4 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h4><p>在MySQL中，<strong>存储函数（Stored Function）</strong>是一种预编译的SQL语句集合，类似于存储过程，但它返回一个值。存储函数可以被SQL语句直接调用，就像调用普通的函数一样。存储函数通常用于封装复杂的逻辑，并在查询中重用这些逻辑。</p>
<p>存储函数同样是一个函数，和上面的存储过程差不多。</p>
<h5 id="存储过程和存储函数的区别"><a href="#存储过程和存储函数的区别" class="headerlink" title="存储过程和存储函数的区别"></a>存储过程和存储函数的区别</h5><p>返回值的区别</p>
<ul>
<li>存储过程<ul>
<li>存储过程可以返回多个值，这些值通过OUT或INOUT参数返回。</li>
<li>存储过程可以执行多个SQL语句，但不直接返回一个单一的值。</li>
</ul>
</li>
<li>存储函数<ul>
<li>存储函数必须返回一个单一的值。</li>
<li>存储函数可以被SQL语句直接调用，就像调用普通的函数一样。</li>
</ul>
</li>
</ul>
<p>调用方式的区别</p>
<ul>
<li>存储过程<ul>
<li>存储过程通过CALL语句调用。</li>
<li>存储过程可以执行复杂的逻辑，包括多个SQL语句和事务控制。</li>
</ul>
</li>
<li>存储函数<ul>
<li>存储函数可以直接在SQL语句中调用，就像调用普通的函数一样。</li>
<li>存储函数通常用于封装复杂的逻辑，并在查询中重用这些逻辑。</li>
</ul>
</li>
</ul>
<h5 id="存储函数的主要特点"><a href="#存储函数的主要特点" class="headerlink" title="存储函数的主要特点"></a>存储函数的主要特点</h5><p>返回值：</p>
<ul>
<li>存储函数必须返回一个值，这使得它们可以被SQL语句直接调用。<br>代码重用：</li>
<li>存储函数可以被多次调用，减少了代码重复，提高了开发效率。<br>减少网络流量：</li>
<li>存储函数在服务器端执行，减少了客户端和服务器之间的网络流量，因为只需要发送函数的名称和参数，而不是大量的SQL语句。<br>安全性：</li>
<li>存储函数可以限制用户对底层数据的直接访问，只允许通过函数进行数据操作，从而增强数据的安全性。<br>事务管理：</li>
<li>存储函数可以包含事务控制语句，如COMMIT和ROLLBACK，确保数据操作的完整性和一致性。</li>
</ul>
<p>创建一个存储函数get_employee_salary，用于根据员工ID获取员工的薪资：</p>
<p>可以看到和上面存储过程的区别，声明了一个返回值，类型是DECIMAL,最后通过return返回了，并且声明了一个变量。参数也没有IN、OUT这种了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> get_employee_salary(emp_id <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> emp_salary <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> emp_salary</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> id <span class="operator">=</span> emp_id;</span><br><span class="line">    <span class="keyword">RETURN</span> emp_salary;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h4 id="window窗口函数"><a href="#window窗口函数" class="headerlink" title="window窗口函数"></a>window窗口函数</h4><p>窗口函数（Window Function）是SQL标准中的一种功能强大的工具，它允许在查询中对一组行进行计算，而不会像聚合函数那样消除行的个数。窗口函数在MySQL 8.0及更高版本中得到了支持，它们可以用于计算移动平均值、累积和、排名等复杂的分析任务。</p>
<h5 id="窗口函数的主要特点"><a href="#窗口函数的主要特点" class="headerlink" title="窗口函数的主要特点"></a>窗口函数的主要特点</h5><p>行级计算：</p>
<ul>
<li>窗口函数在每一行上执行计算，同时可以访问同一组中的其他行。</li>
<li>这与聚合函数不同，聚合函数会将多行数据合并为一行。<br>分区和排序：</li>
<li>窗口函数可以使用PARTITION BY子句将数据分成多个分区，每个分区独立计算。</li>
<li>可以使用ORDER BY子句在每个分区内对数据进行排序。<br>灵活的范围定义：</li>
<li>窗口函数可以定义计算的范围，如当前行的前几行或后几行。</li>
<li>使用ROWS或RANGE子句可以指定计算的范围。<br>多种功能：</li>
<li>窗口函数提供了多种功能，如ROW_NUMBER()、RANK()、DENSE_RANK()、NTILE()、SUM()、AVG()、LEAD()、LAG()等。</li>
</ul>
<p><code>ROW_NUMBER</code>和<code>RANK</code>都需要和<code>OVER</code>一起使用。</p>
<ul>
<li>ROW_NUMBER(): 显示当前行号</li>
<li>RANK() : 显示排序后的排名，如果没有排序，都是1</li>
<li>OVER()<ul>
<li>PARTITION BY 进行分组</li>
<li>GROUP BY 进行分组</li>
<li>ORDER BY 排序</li>
</ul>
</li>
</ul>
<p><img src="/../images/15445001.png" alt="001"></p>
<p><img src="/../images/15445002.png" alt="002"></p>
<p><img src="/../images/15445003.png" alt="003"></p>
<h4 id="获取每个课程中分数最高的学生信息"><a href="#获取每个课程中分数最高的学生信息" class="headerlink" title="获取每个课程中分数最高的学生信息"></a>获取每个课程中分数最高的学生信息</h4><p>下面的SQL，在postgresql中执行成功，mysql8执行报错。</p>
<p>首先查询所有课程信息，并按照课程分组，按照分数排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line"><span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cid <span class="keyword">ORDER</span> <span class="keyword">BY</span> grade <span class="keyword">ASC</span>)</span><br><span class="line"><span class="keyword">AS</span> rank <span class="keyword">FROM</span> enrolled</span><br></pre></td></tr></table></figure>

<p><img src="/../images/15445004.png" alt="004"></p>
<p>接着搜索上表中分数为1，也就是分数最高的学生。也就是每个课分数最高的学生信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line">    <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cid</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> grade <span class="keyword">ASC</span>)</span><br><span class="line">    <span class="keyword">AS</span> rank <span class="keyword">FROM</span> enrolled) <span class="keyword">AS</span> ranking</span><br><span class="line"><span class="keyword">WHERE</span> ranking.rank <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="/../images/15445005.png" alt="005"></p>
<h4 id="CTE-common-table-expressions"><a href="#CTE-common-table-expressions" class="headerlink" title="CTE(common table expressions)"></a>CTE(common table expressions)</h4><p>在MySQL中，<strong>CTE（Common Table Expressions，公共表表达式）</strong>是一种临时的结果集，可以在查询中被引用。CTE通常用于简化复杂的查询，使查询更易于理解和维护。CTE在MySQL 8.0及更高版本中得到了支持。</p>
<h5 id="CTE的主要特点"><a href="#CTE的主要特点" class="headerlink" title="CTE的主要特点"></a>CTE的主要特点</h5><p>临时结果集：</p>
<ul>
<li>CTE是一个临时的结果集，可以在查询中被引用。它类似于子查询，但更易于阅读和维护。<br>简化复杂查询：</li>
<li>CTE可以将复杂的查询分解为多个简单的部分，使查询更易于理解和维护。<br>可重用性：</li>
<li>CTE可以被多次引用，减少了代码重复，提高了开发效率。<br>递归查询：</li>
<li>CTE支持递归查询，可以用于处理层次结构或递归数据。</li>
</ul>
<p>使用<code>CTE</code>实现获取每个课程中分数最高的学生信息。</p>
<p>通过<code>WITH</code>语句来声明一个临时表。表名<code>cteSource</code>，表的内容就是最的sid，通过<code>SELECT MAX(sid) FROM enrolled</code>查询出来的结果。字段名叫<code>maxId</code>。</p>
<p>然后在查询语句里面就可以连接<code>cteSource</code>表，然后通过sid &#x3D; cteSource.maxId 来获取到sid最大的用户信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> cteSource (maxId) <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(sid) <span class="keyword">FROM</span> enrolled</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> student, cteSource</span><br><span class="line"><span class="keyword">WHERE</span> student.sid <span class="operator">=</span> cteSource.maxId</span><br></pre></td></tr></table></figure>

<p>还有一些其他的用法，比如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> cte1 (col1) <span class="keyword">AS</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span></span><br><span class="line">),</span><br><span class="line">cte2 (col2) <span class="keyword">AS</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> cte1, cte2;</span><br></pre></td></tr></table></figure>

<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>介绍了上面的概念，我们现在明白了MySQL数据库是什么了吧。</p>
<p>MySQL数据库是</p>
<ul>
<li>OLTP数据库</li>
<li>基于关系模型的关系数据库管理系统</li>
<li>实现了SQL标准，可以使用SQL进行控制，并扩展了自己的东西。</li>
<li>可以使用ER图来设计关系模型</li>
<li>具有一些高级特性</li>
</ul>
<h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>以上就是整体的MySQL学习路线了。</p>
<p>关注我发送“MySQL知识图谱”领取完整的MySQL学习路线。</p>
<p>发送“电子书”即可领取价值上千的电子书资源。</p>
<p>部分电子书如图所示。</p>
<p><img src="/../images/bottom1.png" alt="概念学习"></p>
<p><img src="/../images/bottom2.png" alt="概念学习"></p>
<p><img src="/../images/bottom3.png" alt="概念学习"></p>
<p><img src="/../images/bottom4.png" alt="概念学习"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/JAVA%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/JAVA%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html" class="post-title-link" itemprop="url">JAVA中的函数式编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-06 10:12:47" itemprop="dateCreated datePublished" datetime="2023-03-06T10:12:47+08:00">2023-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span id="/JAVA%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html" class="post-meta-item leancloud_visitors" data-flag-title="JAVA中的函数式编程" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/JAVA%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/JAVA%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JAVA中的函数式编程"><a href="#JAVA中的函数式编程" class="headerlink" title="JAVA中的函数式编程"></a>JAVA中的函数式编程</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/JAVA-optional%E5%B9%B6%E9%9D%9E%E9%93%B6%E5%BC%B9.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/JAVA-optional%E5%B9%B6%E9%9D%9E%E9%93%B6%E5%BC%B9.html" class="post-title-link" itemprop="url">JAVA-optional并非银弹</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-02 10:12:47" itemprop="dateCreated datePublished" datetime="2023-03-02T10:12:47+08:00">2023-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span id="/JAVA-optional%E5%B9%B6%E9%9D%9E%E9%93%B6%E5%BC%B9.html" class="post-meta-item leancloud_visitors" data-flag-title="JAVA-optional并非银弹" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/JAVA-optional%E5%B9%B6%E9%9D%9E%E9%93%B6%E5%BC%B9.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/JAVA-optional%E5%B9%B6%E9%9D%9E%E9%93%B6%E5%BC%B9.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="optional并非银弹"><a href="#optional并非银弹" class="headerlink" title="optional并非银弹"></a>optional并非银弹</h1><p>首先，我们都知道，<code>optional</code>类型要更加安全，如果使用的好，不会出现空指针异常，因为它不会返回null。</p>
<p>但是注意，这里的前提是<code>使用的好</code>。</p>
<p>比如 下面这两段代码。这里的 optionalInt.get().toString() 并不会比 num.toString() 安全，如果optionInt.get()返回的是一个null，还是会触发空指针异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; optionalInt = Optional.of(<span class="number">12</span>);</span><br><span class="line">optionalInt.get().toString();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">num.toString();</span><br></pre></td></tr></table></figure>

<p>所以，optional并不是处理空指针的银弹，而是需要正确的使用它。</p>
<h3 id="如果正确的使用optional"><a href="#如果正确的使用optional" class="headerlink" title="如果正确的使用optional"></a>如果正确的使用optional</h3><p><code>isPresent</code>和<code>ifPresent</code>这两个方法。</p>
<ul>
<li>isPresent 是一个判断，类似于 num !&#x3D; null</li>
<li>ifPresent 接受一个 lambda 表达式或者方法，如果存在的话就调用该方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; optionalInt = Optional.of(<span class="number">12</span>);</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">optionalInt.ifPresent(i -&gt; &#123;</span><br><span class="line">    num = i;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (optionalInt.isPresent()) &#123;</span><br><span class="line">    num = optionalInt.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里更推荐的是使用 ifPresent 方法，更加安全方便。</p>
<p>为什么呢？因为你只是为了判断这么一下的话，完全可以使用 <code>num != null</code> 来代替 <code>optionalInt.isPresent</code>。毕竟这样还省去了包装optional的步骤，效果则是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (optionalInt.isPresent()) &#123;</span><br><span class="line">    num = optionalInt.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">    num = a * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是 <code>ifPresent</code> 方法只负责处理，并不返回任何值。</p>
<p>如果你想要返回值的话，可以使用<code>map</code>方法代替。他返回一个bool值，被封装到optional中的true或者false(根据optionalInt是否存在)，也可能是个空值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Boolean&gt; res = optionalInt.map(i -&gt; &#123;</span><br><span class="line">    num = i;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>那么在日常使用中，还会有默认值的情况，比如，如果int值存在我就赋值给num，不存在我就赋值0。这个时候就可以使用下面这三个方法</p>
<ul>
<li>orElse        如果有值，返回值，如果没有值，返回你给的默认值。</li>
<li>orElseGet     和上面的效果一样，只是可以传一个lambda表达式</li>
<li>orElseThrow   和上面的效果一样，没有值的时候返回一个异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; optionalInt = Optional.of(<span class="number">12</span>);</span><br><span class="line">num = optionalInt.orElse(<span class="number">0</span>); <span class="comment">//这里有值，所以返回12</span></span><br><span class="line"></span><br><span class="line">Optional&lt;Integer&gt; optionalInt = Optional.empty();</span><br><span class="line">num = optionalInt.orElse(<span class="number">0</span>); <span class="comment">//这里没有值，所以返回默认值0</span></span><br><span class="line"></span><br><span class="line">Optional&lt;Integer&gt; optionalInt = Optional.empty();</span><br><span class="line"><span class="comment">// 传一个默认值方法</span></span><br><span class="line">num = optionalInt.orElseGet(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Optional&lt;Integer&gt; optionalInt = Optional.empty();</span><br><span class="line"><span class="comment">// 如果没有值，返回一个异常</span></span><br><span class="line"><span class="keyword">return</span> optionalInt.orElseThrow(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;异常了&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>通过<code>faltMap</code>方法实现optional链式操作。首先通过of方法创建一个<code>Optional&lt;Integer&gt;</code>类型的12。然后通过flatMap方法把这个Integer的12传递给doubleInt方法。doubleInt方法处理完以后返回一个<code>Optional&lt;Integer&gt;</code>类型的24。</p>
<p>因为返回的还是一个<code>Optional</code>。所以还可以继续调用flatMap方法。将24传给intToStr方法。将24转换成String类型。然后返回一个<code>Optional&lt;String&gt;</code>类型的24.</p>
<p><code>ofNullable</code>方法的作用是如果你给的值存在就调用<code>of</code>方法创建一个<code>Optional</code>。如果不存在就调用<code>empty</code>方法创建一个空的<code>Optional</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">optionalMap</span><span class="params">()</span> &#123;</span><br><span class="line">    Optional&lt;String&gt; res = Optional.of(<span class="number">12</span>).flatMap(<span class="built_in">this</span>::doubleInt).flatMap(<span class="built_in">this</span>::intToStr);</span><br><span class="line">    <span class="keyword">return</span> res.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一个数转换成string</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title function_">intToStr</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(String.valueOf(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一个数 * 2</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;Integer&gt; <span class="title function_">doubleInt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(x &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/JAVA-%E8%BD%AC%E8%AF%AD%E8%A8%80%E8%80%85%E9%80%9F%E5%AD%A6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/JAVA-%E8%BD%AC%E8%AF%AD%E8%A8%80%E8%80%85%E9%80%9F%E5%AD%A6.html" class="post-title-link" itemprop="url">转语言者速学java</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-02 10:12:47" itemprop="dateCreated datePublished" datetime="2023-03-02T10:12:47+08:00">2023-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span id="/JAVA-%E8%BD%AC%E8%AF%AD%E8%A8%80%E8%80%85%E9%80%9F%E5%AD%A6.html" class="post-meta-item leancloud_visitors" data-flag-title="转语言者速学java" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/JAVA-%E8%BD%AC%E8%AF%AD%E8%A8%80%E8%80%85%E9%80%9F%E5%AD%A6.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/JAVA-%E8%BD%AC%E8%AF%AD%E8%A8%80%E8%80%85%E9%80%9F%E5%AD%A6.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="转语言者速学java"><a href="#转语言者速学java" class="headerlink" title="转语言者速学java"></a>转语言者速学java</h1><h3 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a>接口的默认方法</h3><p>java的接口里面可以写方法体，这样的话，所有实现了该接口的，都自动具有了该方法而不用实现方法内容。当然了，也可以重写方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IGuideService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> Integer <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuideService</span> <span class="keyword">implements</span> <span class="title class_">IGuideService</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span> &#123;</span><br><span class="line">        <span class="type">IGuideService</span> <span class="variable">guideService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuideService</span>;</span><br><span class="line">        System.out.println(guideService.getNum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>但是java可以实现多个接口，所以就可能会有<code>二义性</code>的问题，C++解决问题的方法是<code>虚基类</code>，java则是简单粗暴的。</p>
<ul>
<li>如果是父类中和接口中的方法冲突了。那么选择父类中的方法。</li>
<li>如果是多个接口中的方法冲突了，那么你必须通过覆盖该方法来手动解决冲突。</li>
</ul>
<p>看一下如果父类中也有<code>getNum</code>方法。创建一个父类返回2.再次执行以后会发现返回2了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseGuideService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuideService</span> <span class="keyword">extends</span> <span class="title class_">BaseGuideService</span> <span class="keyword">implements</span> <span class="title class_">IGuideService</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来不用父类，然后创建两个接口试试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IGuideNewService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> Integer <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现两个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuideService</span> <span class="keyword">implements</span> <span class="title class_">IGuideService</span>,IGuideNewService &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候编译就会报错了。</p>
<blockquote>
<p>GuideService 从 IGuideService 和 IGuideNewService 中继承了getNum() 的不相关默认值</p>
</blockquote>
<p>那如果这两个接口是父子接口呢？这个时候就不会报错了，因为相当于子接口重写了这个方法。所以只存在一个<code>getNum</code>方法了。</p>
<p>我们来看如果是单独的两个接口，那么需要我们手动来解决冲突。重写一下这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现两个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuideService</span> <span class="keyword">implements</span> <span class="title class_">IGuideService</span>, IGuideNewService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在重写的时候也可以选择使用两个接口的某一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现两个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuideService</span> <span class="keyword">implements</span> <span class="title class_">IGuideService</span>, IGuideNewService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> IGuideService.<span class="built_in">super</span>.getNum();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//或者使用另一个</span></span><br><span class="line">        <span class="comment">//return IGuideNewService.super.getNum();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="日期时间"><a href="#日期时间" class="headerlink" title="日期时间"></a>日期时间</h3><p>在java中的时间，有几个概念</p>
<ul>
<li>某一个具体的时间点：Instant</li>
<li>持续时间，两个时间点之间的时间：Duration</li>
<li>本地时间，没有时区信息的：LocalDate,LocalTime,LocalDateTime</li>
<li>带时区的时间：ZonedDateTime</li>
<li>处理时区信息时，时间段使用 Period 而不是 Duration</li>
<li>时间格式化处理： DateTimeFormatter</li>
<li>日历计算，比如查找月份的第一天，第二天，第一周，第二周的星期二：TemporalAdjuster</li>
</ul>
<p>获取当前的一个时间点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Instant.now();</span><br></pre></td></tr></table></figure>

<p>获取一段时间，可以用来求运行速度。start是处理开始的时间点。end是处理完成的时间点。再通过Duration来求出一段时间.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">start</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"><span class="comment">//处理逻辑</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">end</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"></span><br><span class="line"><span class="type">Duration</span> <span class="variable">time</span> <span class="operator">=</span> Duration.between(start,end);</span><br><span class="line"><span class="type">long</span> <span class="variable">mills</span> <span class="operator">=</span> time.toMills();</span><br></pre></td></tr></table></figure>

<p>获取本地当前时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now();</span><br></pre></td></tr></table></figure>

<p>时间格式化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">time.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>获取带时区的当前时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">time</span> <span class="operator">=</span> ZonedDateTime.now();</span><br></pre></td></tr></table></figure>

<p>想看更多时间处理的，可以参考 <a href="https://thepatterraining.github.io/JAVA-spring%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93.html#valine-comments">LocalDateTime源码解析</a></p>
<h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h3><p>stream可以帮我们处理很多东西。比如</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">map</td>
<td align="left">循环。可以简单理解为foreach</td>
</tr>
<tr>
<td align="left">flatMap</td>
<td align="left">将二维数据展开成一维</td>
</tr>
<tr>
<td align="left">filter</td>
<td align="left">过滤数据</td>
</tr>
<tr>
<td align="left">distinct</td>
<td align="left">去重</td>
</tr>
<tr>
<td align="left">sorted</td>
<td align="left">排序</td>
</tr>
<tr>
<td align="left">limit</td>
<td align="left">限制只取n个元素</td>
</tr>
<tr>
<td align="left">skip</td>
<td align="left">跳过n个元素</td>
</tr>
</tbody></table>
<p>除了这些还可以实现比如把list转换成逗号分隔的字符串。把list经过处理以后转换成set或者map。</p>
<p>还可以变成指定值为key,指定值为value的map。比如id为key，name为值或者map为值的map。</p>
<p>具体的可以参考下面三个文章。</p>
<ul>
<li><a href="">stream数据结构和原理</a></li>
<li><a href="">stream的map,filter,sorted等使用和源码</a></li>
<li><a href="">stream的collect,foreach等使用和源码</a></li>
</ul>
<h3 id="optional"><a href="#optional" class="headerlink" title="optional"></a>optional</h3><p>java中的optional可以帮助你避免<code>空指针异常</code>.</p>
<p>具体的可以参考<a href="https://thepatterraining.github.io/JAVA-optional%E5%B9%B6%E9%9D%9E%E9%93%B6%E5%BC%B9.html">optional并非银弹</a></p>
<h3 id="函数式编程和lambda"><a href="#函数式编程和lambda" class="headerlink" title="函数式编程和lambda"></a>函数式编程和lambda</h3><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul>
<li>@Autowired  Spring提供的，基于类型注入的，可以放在setter方法上，变量上，构造函数上</li>
<li>@Inject     同@Autowired</li>
<li>@Qualifier  Spring提供的，基于名称注入的，一般和@Autowired配合使用来通过value参数指定名称</li>
<li>@Name       同@Qualifier，给@Inject配合使用</li>
<li>@Primary</li>
<li>@Resource   Java提供的，可以基于类型或名称注入的,可以通过name参数来指定名称，可以放在setter方法上</li>
<li>@RequiredArgsConstructor  lombok提供的，基于类型注入，通过增加一个构造函数来注入。</li>
<li>@Value      Spring提供的，注入基本类型的注解，一般用来从配置文件取值。</li>
<li>@Component 单纯的说我是一个<code>bean</code></li>
<li>@Service 和上面的一样，不过一般用在service类中，更加语义化</li>
<li>@Controller 和上面的一样，一般用在controller类中</li>
<li>@Repository 我也是一个<code>bean</code>，一般用在dao数据访问层</li>
<li>@Bean 我也是一个bean，导入第三方包里面的注解</li>
<li>@Import 导入组件</li>
<li>@ImportSelector 返回需要导入的组件的全类名数组</li>
<li>@ImportBeanDefinitionRegistrar 手动注册Bean到容器</li>
<li>@JsonIgnore  json的时候忽略属性</li>
<li>@Bean(initMethod&#x3D;”init”,destoryMethod&#x3D;”destory”) 设置初始化和销毁方法</li>
<li>@PostConstruct：初始化方法</li>
<li>@PreDestory：销毁方法</li>
<li>BeanPostProcessor：bean的后置处理器，在bean初始化前后进行一些处理工作</li>
<li>@Configuration 声明为配置类</li>
<li>@ComponentScan 扫描Component</li>
<li>@Aspect 声明一个切面</li>
<li>@After 在方法执行之后执行（方法上）</li>
<li>@Before 在方法执行之前执行（方法上）</li>
<li>@Around 在方法执行之前与之后执行（方法上）</li>
<li>@PointCut 声明切点</li>
<li>@EnableAspectJAutoProxy 启Spring对AspectJ代理的支持</li>
<li>@Profile 指定组件在哪个环境的情况下才能被注册到容器中，不指定，任何环境下都能注册这个组件。</li>
<li>@Conditional 通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。</li>
<li>@EnableAsync 配置类中通过此注解开启对异步任务的支持</li>
<li>@Async  在实际执行的bean方法使用该注解来声明其是一个异步任务</li>
<li>@EnableScheduling  在配置类上使用，开启计划任务的支持</li>
<li>@Scheduled  来申明这是一个任务，包括cron,fixDelay,fixRate等类型</li>
<li>@EnableConfigurationProperties：开启对@ConfigurationProperties注解配置Bean的支持；</li>
<li>@EnableJpaRepositories：开启对SpringData JPA Repository的支持；</li>
<li>@EnableTransactionManagement：开启注解式事务的支持；</li>
<li>@EnableCaching：开启注解式的缓存支持；</li>
<li>@EnableAspectAutoProxy：开启对AspectJ自动代理的支持；</li>
<li>@EnableWebMvc   在配置类中开启Web MVC的配置支持。</li>
<li>@RequestMapping   用于映射web请求，包括访问路径和参数。</li>
<li>@ResponseBody    支持将返回值放到response内，而不是一个页面，通常用户返回json数据。</li>
<li>@RequestBody           允许request的参数在request体中，而不是在直接连接的地址后面。</li>
<li>@PathVariable         用于接收路径参数，比如@RequestMapping(“&#x2F;hello&#x2F;{name}”)声明的路径，将注解放在参数前，即可获取该值，通常作为Restful的接口实现方法。</li>
<li>@RestController       该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。</li>
<li>@ControllerAdvice     全局异常处理 全局数据绑定 全局数据预处理</li>
<li>@ExceptionHandler     用于全局处理控制器里的异常。</li>
<li>@InitBinder           用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。</li>
<li>@ModelAttribute       </li>
<li>@Transactional <ul>
<li>name 当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。</li>
<li>propagation 事务的传播行为，默认值为 REQUIRED。<ul>
<li>REQUIRED  如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。( 也就是说如果A方法和B方法都添加了注解，在默认传播模式下，A方法内部调用B方法，会把两个方法的事务合并为一个事务 ）</li>
<li>SUPPORTS  如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。</li>
<li>MANDATORY 如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</li>
<li>REQUIRES_NEW  重新创建一个新的事务，如果当前存在事务，暂停当前的事务。</li>
<li>NOT_SUPPORTED 以非事务的方式运行，如果当前存在事务，暂停当前的事务。</li>
<li>NEVER         以非事务的方式运行，如果当前存在事务，则抛出异常。</li>
<li>NESTED        和 REQUIRED 效果一样。</li>
</ul>
</li>
<li>isolation 事务的隔离度，默认值采用 DEFAULT</li>
<li>timeout   事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</li>
<li>read-only 指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</li>
<li>rollback-for  用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。</li>
<li>no-rollback- for  抛出 no-rollback-for 指定的异常类型，不回滚事务。</li>
</ul>
</li>
<li>@Schema   表示此类对应的数据库表对应的schema。</li>
<li>@JsonFormat   可以方便的把Date类型直接转化为我们想要的模式</li>
<li>@Transient    如果一个属性并非数据库表的字段映射，就务必将其标示为@Transient</li>
<li>@JsonProperty 可以指定某个属性和json映射的名称</li>
<li>@Scope设置类型包括：</li>
</ul>
<p>设置Spring容器如何新建Bean实例（方法上，得有@Bean）</p>
<p>① Singleton</p>
<p>（单例,一个Spring容器中只有一个bean实例，默认模式）,</p>
<p>② Protetype</p>
<p>（每次调用新建一个bean）,</p>
<p>③ Request</p>
<p>（web项目中，给每个http request新建一个bean）,</p>
<p>④ Session</p>
<p>（web项目中，给每个http session新建一个bean）,</p>
<p>⑤ GlobalSession</p>
<p>（给每一个 global http session新建一个Bean实例）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Thepatter"
      src="/images/header.jpeg">
  <p class="site-author-name" itemprop="name">Thepatter</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">180</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">78</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Thepatterraining" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Thepatterraining" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ztzhoutao041@163.com" title="E-Mail → mailto:ztzhoutao041@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://blog.csdn.net/Thepatterraining" title="CSDN → http:&#x2F;&#x2F;blog.csdn.net&#x2F;Thepatterraining" rel="noopener" target="_blank"><i class="fa fa-fw fa-CSDN"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Thepatter</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"RWllimOI5okO7WFTUmJ4EeeD-gzGzoHsz","app_key":"hXeefwCw8aDKTJ1Xqye7fLYb","security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'RWllimOI5okO7WFTUmJ4EeeD-gzGzoHsz',
      appKey     : 'hXeefwCw8aDKTJ1Xqye7fLYb',
      placeholder: "给我的文章加点评论吧~",
      avatar     : 'mp',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
