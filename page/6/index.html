<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="YwTcBpc08sCpJAE8mKZglCGHjZc1BiK9UUagC8ldlaA">
  <meta name="msvalidate.01" content="true">
  <meta name="yandex-verification" content="true">
  <meta name="baidu-site-verification" content="3PbJKzlOf0">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"thepatterraining.github.io","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="dream">
<meta property="og:url" content="https://thepatterraining.github.io/page/6/index.html">
<meta property="og:site_name" content="dream">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Thepatter">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://thepatterraining.github.io/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>dream</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="dream" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dream</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个菜鸟程序员的成长历程</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9.html" class="post-title-link" itemprop="url">MySQL查询路径选择</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-26 10:12:47" itemprop="dateCreated datePublished" datetime="2023-04-26T10:12:47+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-11 16:34:45" itemprop="dateModified" datetime="2025-02-11T16:34:45+08:00">2025-02-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span id="/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9.html" class="post-meta-item leancloud_visitors" data-flag-title="MySQL查询路径选择" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL查询路径选择"><a href="#MySQL查询路径选择" class="headerlink" title="MySQL查询路径选择"></a>MySQL查询路径选择</h1><p>大家好，我是大头，98年，职高毕业，上市公司架构师，大厂资深开发，管理过10人团队，我是如何做到的呢？</p>
<p>这离不开持续学习的能力，而其中最重要的当然是数据库技术了！</p>
<p>对于所有开发来说，都离不开数据库，因为所有的数据都是要存储的。</p>
<p>关注我一起学习！文末有惊喜哦！</p>
<h2 id="什么是MySQL查询路径？"><a href="#什么是MySQL查询路径？" class="headerlink" title="什么是MySQL查询路径？"></a>什么是MySQL查询路径？</h2><p>MySQL查询路径是指查询优化器在执行查询时所选择的具体执行步骤和顺序。查询优化器的目标是找到最高效的方式来执行查询，以最小化资源消耗（如CPU、I&#x2F;O、内存等）和查询响应时间。查询路径包括以下几个关键阶段：</p>
<ol>
<li>解析（Parsing）：</li>
</ol>
<ul>
<li>将SQL语句解析成内部的逻辑结构，如语法树（Syntax Tree）。</li>
<li>检查SQL语句的语法是否正确。</li>
</ul>
<ol start="2">
<li>预处理（Preprocessing）：</li>
</ol>
<ul>
<li>检查用户是否有权限执行该查询。</li>
<li>检查表和列是否存在。</li>
<li>重写查询，如展开视图、处理子查询等。</li>
</ul>
<ol start="3">
<li>优化（Optimization）：</li>
</ol>
<ul>
<li>查询优化器评估不同的执行计划，选择最优的执行路径。</li>
<li>优化器会考虑索引、表的大小、数据分布等因素。</li>
<li>生成执行计划，决定如何访问表、如何连接表、如何过滤数据等。</li>
</ul>
<ol start="4">
<li>执行（Execution）：</li>
</ol>
<ul>
<li>按照优化器生成的执行计划，实际执行查询。</li>
<li>包括表扫描、索引扫描、连接操作、过滤操作等。</li>
</ul>
<ol start="5">
<li>结果返回（Result Returning）：</li>
</ol>
<ul>
<li>将查询结果返回给客户端。</li>
</ul>
<h3 id="查询路径的详细分析"><a href="#查询路径的详细分析" class="headerlink" title="查询路径的详细分析"></a>查询路径的详细分析</h3><ol>
<li>解析（Parsing）</li>
</ol>
<p>解析阶段将SQL语句转换为内部的逻辑结构。例如，对于查询SELECT a, b FROM test_a WHERE a &#x3D; 1 AND b &#x3D; ‘A1’;，解析器会将其解析为一个查询树，包含以下信息：</p>
<ul>
<li>查询类型：SELECT</li>
<li>查询的列：a, b</li>
<li>查询的表：test_a</li>
<li>查询的条件：a &#x3D; 1 AND b &#x3D; ‘A1’</li>
</ul>
<ol start="2">
<li>预处理（Preprocessing）</li>
</ol>
<p>预处理阶段会检查用户是否有权限执行该查询，表和列是否存在，以及是否需要重写查询。例如：</p>
<ul>
<li>如果test_a表不存在，查询会失败。</li>
<li>如果用户没有权限访问test_a表，查询会失败。</li>
<li>如果查询中包含子查询或视图，预处理器会将其展开。</li>
</ul>
<ol start="3">
<li>优化（Optimization）</li>
</ol>
<p>优化阶段是查询路径中最关键的部分。查询优化器会评估不同的执行计划，选择最优的执行路径。优化器考虑的因素包括：</p>
<ul>
<li>索引：是否有可用的索引，以及索引是否能有效过滤数据。</li>
<li>表的大小：表的大小会影响全表扫描的成本。</li>
<li>数据分布：数据的分布情况会影响过滤条件的效率。</li>
<li>连接顺序：如果有多个表连接，优化器会决定最佳的连接顺序。</li>
</ul>
<p>优化器会生成一个执行计划，描述如何执行查询。例如，对于查询SELECT a, b FROM test_a WHERE a &#x3D; 1 AND b &#x3D; ‘A1’;，优化器可能会生成以下执行计划：</p>
<ul>
<li>使用a列上的索引idx_a来定位满足条件a &#x3D; 1的行。</li>
<li>在这些行中进一步过滤满足条件b &#x3D; ‘A1’的行。</li>
</ul>
<ol start="4">
<li>执行（Execution）</li>
</ol>
<p>执行阶段按照优化器生成的执行计划，实际执行查询。例如：</p>
<ul>
<li>如果优化器选择使用a列上的索引idx_a，执行器会先扫描索引，找到满足条件a &#x3D; 1的行。</li>
<li>然后在这些行中进一步过滤满足条件b &#x3D; ‘A1’的行。</li>
<li>最终将结果返回给客户端。</li>
</ul>
<ol start="5">
<li>结果返回（Result Returning）</li>
</ol>
<p>执行器将查询结果返回给客户端。客户端可以是MySQL客户端工具、应用程序等。</p>
<h3 id="mysql架构"><a href="#mysql架构" class="headerlink" title="mysql架构"></a>mysql架构</h3><p>这里就要介绍一下MySQL的整体架构了。</p>
<p><img src="https://thepatterraining.github.io/images/mysql/mysql2-1.png" alt="架构"></p>
<ul>
<li>连接器：MySQL连接器（MySQL Connector）是用于连接MySQL数据库的客户端库，它允许应用程序与MySQL数据库进行通信。这些连接器提供了API（应用程序编程接口），使得开发者可以在各种编程语言中轻松地执行SQL语句、管理数据库连接、处理查询结果等。</li>
<li>分析器：MySQL分析器才算真正进入了MySQL里面。它会分析词法和语法，如果你的SQL语句不对，就会看到一些报错，例如语法错误。</li>
<li>优化器：MySQL优化器是本文的重点内容，因为这里涉及了MySQL的一些优化，其中就包括了索引选择，也是导致索引失效的重要原因。在这一步也就确定了查询计划。</li>
<li>执行器：MySQL执行器会根据优化器输出的查询计划来执行这个查询计划，会调用底层的存储引擎进行执行。</li>
<li>存储引擎：MySQL支持多种存储引擎，每个存储引擎有不同的特点。其中InnoDB引擎因为支持事务等优点，现在是MySQL的默认存储引擎。</li>
</ul>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>MySQL连接器（MySQL Connector）是用于连接MySQL数据库的客户端库，它允许应用程序与MySQL数据库进行通信。这些连接器提供了API（应用程序编程接口），使得开发者可以在各种编程语言中轻松地执行SQL语句、管理数据库连接、处理查询结果等。</p>
<p>当我们最开始连接数据库实例的时候，我们要输入用户名密码，这时候连接器会从数据库的用户信息中判断你是否有权限连接数据库进行操作，有哪些权限。</p>
<p>如果你输入的用户名密码错误或者没有权限，那么你会收到下面的报错信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access denied <span class="keyword">for</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>(<span class="keyword">using</span> password: YES)</span><br></pre></td></tr></table></figure>

<p><img src="https://thepatterraining.github.io/images/mysql/mysql2-2.png" alt="架构"></p>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>连接成功以后。分析器会分析这个语句的词法，语法，语义这些信息。</p>
<p>通俗来讲就是看到select,update这些关键字，知道你要来干啥，看看你是不是来搞破坏的，来捣蛋的。</p>
<p>看看你是查询哪个表啊，有什么条件啊，这些玩意。</p>
<p>最后会输出一个词法树。</p>
<p>当然了这一步还会分析你的语法有没有错误，比如你把select打错试试。打成elect，会出现下面的报错信息</p>
<blockquote>
<p>You have an error in your SQL syntax: check the maual that corresponds to your MySQL server version for the right syntax to use near ‘elect * from users’ at line 1</p>
</blockquote>
<p><img src="https://thepatterraining.github.io/images/mysql/mysql2-3.png" alt="架构"></p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>优化器负责几个事情</p>
<ul>
<li>优化SQL：比如你写了一个很不友好的SQL，如<code>select * from a where 1 =1</code>,优化器会将1&#x3D;1去掉。还有比如括号的删除，如<code>select * from a where ((a AND b) AND c OR (((a AND b) AND (c AND d))))</code>改写成<code>select * from a where (a AND b AND c) OR (a AND b AND c AND d)</code>。等等。</li>
<li>一些内部的优化器：下面列出的是部分，更多的可以参考<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/optimization.html">MySQL官方文档优化器部分</a><ul>
<li>谓词下推：即where条件下推到扫描表的时候执行，而不是扫描表之后执行。</li>
<li>范围优化：对于BTREE和HASH索引，当使用&#x3D;、&lt;&#x3D;&gt;、IN（）、IS NULL或IS NOT NULL运算符时，键部分与常量值的比较是范围条件。此外，对于BTREE索引，当使用&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，BETWEEN，！&#x3D; 、或&lt;&gt;运算符，或者LIKE比较（如果LIKE的参数是不以小写字符开头的常量字符串）。对于所有索引类型，多个范围条件与OR或AND组合形成范围条件。</li>
<li>index merge优化：index merge就是多个索引并发扫描，再将扫描结果合并。</li>
<li>hash join优化：使用hash join来代替Nested Loop Join算法，能大幅度提升join速度。</li>
<li>Is Null优化：可以对<code>where a is null</code>这种条件进行优化，比如该字段设置了<code>not null</code>，那么这个条件就会被删除。</li>
<li>order by + limit优化：使用<code>Top N</code>排序</li>
<li>group by 优化：优化group by语句。</li>
<li>子查询物化：将子查询的内容物化保存起来。</li>
</ul>
</li>
<li>通过成本模型、直方图等信息生成不同的执行路径。</li>
<li>对比执行路径的内容，如取样等，进行选择最终的执行路径。生成查询计划。</li>
</ul>
<p>这里简单的介绍一些mysql内部的优化器，以了解mysql内部做了哪些优化手段。</p>
<p>最后会介绍mysql的成本模型、直方图信息等。结合实际的例子来给大家展示索引选择的问题。</p>
<h4 id="谓词下推优化"><a href="#谓词下推优化" class="headerlink" title="谓词下推优化"></a>谓词下推优化</h4><p>谓词下推优化（Predicate Pushdown Optimization）是一种查询优化技术，它将查询中的过滤条件（谓词）尽可能地推送到数据访问的早期阶段，以减少数据扫描的范围，从而提高查询性能。<br>在数据库查询中，谓词通常是指WHERE子句中的条件。谓词下推优化的目的是让这些条件在数据被读取或处理的早期阶段就发挥作用，避免不必要的数据处理和传输。</p>
<p>在没有谓词下推优化的情况下，数据库会先读取所有数据，然后在内存中应用过滤条件。这可能导致大量的数据被加载到内存中，增加了I&#x2F;O操作和内存使用。<br>通过谓词下推优化，数据库会在数据读取阶段就应用过滤条件，只加载满足条件的数据，从而减少数据的读取量和处理量。</p>
<p>假设存在<code>table_a</code>表，表里面有10条数据，<code>a = 1</code>的数据有一个，具体什么意思呢，我们来看一个SQL语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,b <span class="keyword">from</span> table_a <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>如果没有谓词下推优化的话，执行树如下。</p>
<p><img src="https://thepatterraining.github.io/images/mysql/mysql2-4.png" alt="架构"></p>
<p>其执行顺序如下：</p>
<ol>
<li>扫描<code>table_a</code>表的10条数据，将10条数据传递给where过滤节点。</li>
<li>where过滤操作进行过滤，过滤出<code>a = 1</code>条件的1条数据，将这个数据传递给列选择节点。</li>
<li>列选择节点选择这条数据的2列，将结果返回。</li>
</ol>
<p>其内存中要存储10条数据。</p>
<p>而有了谓词下推优化以后，执行树如下。</p>
<p><img src="https://thepatterraining.github.io/images/mysql/mysql2-5.png" alt="架构"></p>
<p>执行顺序如下：</p>
<ol>
<li>扫描<code>table_a</code>表的10条数据，过滤出符合<code>a = 1</code>条件的这一个数据。将这个数据传给列选择节点。</li>
<li>列选择节点选择这条数据的2列，将结果返回。</li>
</ol>
<h4 id="范围优化"><a href="#范围优化" class="headerlink" title="范围优化"></a>范围优化</h4><p>对于BTREE和HASH索引，当使用&#x3D;、&lt;&#x3D;&gt;、IN（）、IS NULL或IS NOT NULL运算符时，键部分与常量值的比较是范围条件。此外，对于BTREE索引，当使用&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，BETWEEN，！&#x3D; 、或&lt;&gt;运算符，或者LIKE比较（如果LIKE的参数是不以小写字符开头的常量字符串）。对于所有索引类型，多个范围条件与OR或AND组合形成范围条件。</p>
<p>给定数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">key_part1  key_part2  key_part3</span><br><span class="line">  NULL       1          &#x27;abc&#x27;</span><br><span class="line">  NULL       1          &#x27;xyz&#x27;</span><br><span class="line">  NULL       2          &#x27;foo&#x27;</span><br><span class="line">   1         1          &#x27;abc&#x27;</span><br><span class="line">   1         1          &#x27;xyz&#x27;</span><br><span class="line">   1         2          &#x27;abc&#x27;</span><br><span class="line">   2         1          &#x27;aaa&#x27;</span><br></pre></td></tr></table></figure>

<p>执行where key_part1&#x3D; 1，其扫描范围为 1,负无穷，负无穷到 1,正无穷，正无穷</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1,-inf,-inf) &lt;= (key_part1,key_part2,key_part3) &lt; (1,+inf,+inf)</span><br></pre></td></tr></table></figure>
<p>即覆盖了这三行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1         1          &#x27;abc&#x27;</span><br><span class="line">1         1          &#x27;xyz&#x27;</span><br><span class="line">1         2          &#x27;abc&#x27;</span><br></pre></td></tr></table></figure>

<p>index dives，优化器在范围的两端进行dives, 可以帮助优化器更准确的评估扫描的行数，index dives提供了更准确的行估计，但是随着比较值数量的增加，更加耗时，使用统计信息的准确性不如index dives，但允许对大值列表进行更快的行估计。</p>
<p>eq_range_index_dive_limit系统变量使您能够配置优化器从一个行估计策略切换到另一个行估计策略时的值数量。要允许使用索引潜水来比较最多N个相等范围，请将eq_range_index_dive_limit设置为N+ 1。要禁用统计信息并始终使用索引潜水而不管N，请将eq_range_index_dive_limit设置为0。</p>
<p>若要更新表索引统计信息以获得最佳估计值，请使用ANALYZE TABLE。</p>
<p>skip scan,比如有索引(f1,f2)，都知道最左前缀原则，所以一般where f2 &gt; 40是不走索引的，skip scan可以让他走索引，通过构造f1 &#x3D; 1 and f2 &gt; 40，扫描完以后再扫描 f1 &#x3D; 2 and f2 &gt; 40，以此类推，可以通过explain来看extra列是否有skip scan</p>
<p>in优化，in查询可以用如下形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FROM t1 WHERE ( col_1, col_2 ) IN (( &#x27;a&#x27;, &#x27;b&#x27; ), ( &#x27;c&#x27;, &#x27;d&#x27; ));</span><br></pre></td></tr></table></figure>

<p>range_optimizer_max_size_size系统变量可以设置优化器使用的内存</p>
<h4 id="index-merge-优化"><a href="#index-merge-优化" class="headerlink" title="index merge 优化"></a>index merge 优化</h4><p>index merge就是多个索引并发扫描，再将扫描结果合并</p>
<p>索引合并不适用于全文索引。</p>
<p>索引合并访问方法检索具有多个范围扫描的行，并将其结果合并为一个。此访问方法只合并单个表的索引扫描，而不合并多个表的扫描。合并可以产生其底层扫描的并集、交集或交集的并集。</p>
<p>可以使用索引合并的查询示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tbl_name WHERE key1 = 10 OR key2 = 20;</span><br><span class="line"></span><br><span class="line">SELECT * FROM tbl_name</span><br><span class="line">  WHERE (key1 = 10 OR key2 = 20) AND non_key = 30;</span><br><span class="line"></span><br><span class="line">SELECT * FROM t1, t2</span><br><span class="line">  WHERE (t1.key1 IN (1,2) OR t1.key2 LIKE &#x27;value%&#x27;)</span><br><span class="line">  AND t2.key1 = t1.some_col;</span><br><span class="line"></span><br><span class="line">SELECT * FROM t1, t2</span><br><span class="line">  WHERE t1.key1 = 1</span><br><span class="line">  AND (t2.key1 = t1.some_col OR t2.key2 = t1.some_col2);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你的查询有一个带有深度AND&#x2F;OR嵌套的复杂WHERE子句，并且MySQL没有选择最佳计划，请尝试使用以下恒等转换来分发术语：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(x AND y) OR z =&gt; (x OR z) AND (y OR z)</span><br><span class="line">(x OR y) AND z =&gt; (x AND z) OR (y AND z)</span><br></pre></td></tr></table></figure>

<p>在EXPLAIN输出中，Index Merge方法在type列中显示为index_merge。在本例中，key列包含使用的索引列表，key_len包含这些索引的最长键部分列表。</p>
<p>索引合并访问方法有几种算法，它们显示在EXPLAIN输出的Extra字段中：</p>
<ul>
<li>intersect：对多个and条件生效</li>
<li>union：对多个or条件生效</li>
<li>sort_union：sort-union算法和union算法之间的区别在于，sort-union算法必须首先获取所有行的行ID，并在返回任何行之前对其进行排序。</li>
</ul>
<p>索引合并的使用取决于optimizer_switch系统变量的index_merge、index_merge_intersection、index_merge_union和index_merge_sort_union标志的值。默认情况下，所有这些标志都是打开的。</p>
<h4 id="hash-join"><a href="#hash-join" class="headerlink" title="hash join"></a>hash join</h4><p>默认情况下，MySQL尽可能使用哈希连接。可以使用BNL和NO_BNL优化器提示之一来控制是否使用散列连接。</p>
<p>hash join比嵌套join快的多，首先创建hash表，在循环另一个表进行hash，判断是否相等</p>
<p>可以使用join_buffer_size系统变量控制哈希连接的内存使用量;哈希连接使用的内存量不能超过此值。当哈希连接所需的内存超过可用量时，MySQL会使用磁盘上的文件来处理。如果发生这种情况，您应该注意，如果哈希连接无法容纳内存并且它创建的文件比为open_files_limit设置的文件多，则连接可能不会成功。要避免此类问题，请进行以下更改之一：</p>
<ul>
<li>增加join_buffer_size，使哈希连接不会溢出到磁盘。</li>
<li>增加open_files_limit。</li>
</ul>
<h4 id="成本模型"><a href="#成本模型" class="headerlink" title="成本模型"></a>成本模型</h4><p>MySQL成本模型（Cost Model）是MySQL查询优化器（Query Optimizer）用来评估不同查询执行计划的成本（Cost）的一种机制。成本模型通过估算每种执行计划所需的资源（如CPU、I&#x2F;O、内存等）来选择最优的执行计划。</p>
<p>MySQL的成本模型主要考虑以下几个方面：</p>
<ol>
<li>CPU成本：<ul>
<li>评估执行计划中每个操作（如比较、计算、排序等）所需的CPU时间。</li>
<li>例如，WHERE子句中的条件计算、JOIN操作中的匹配等。</li>
</ul>
</li>
<li>I&#x2F;O成本：<ul>
<li>评估执行计划中每个操作所需的磁盘I&#x2F;O操作次数。</li>
<li>例如，全表扫描、索引扫描、数据页的读取等。</li>
<li>I&#x2F;O成本通常是最主要的成本因素之一，因为磁盘I&#x2F;O操作相对较慢。</li>
</ul>
</li>
<li>内存成本：<ul>
<li>评估执行计划中每个操作所需的内存使用量。</li>
<li>例如，排序操作、临时表的创建等。</li>
</ul>
</li>
<li>网络成本：<ul>
<li>评估执行计划中每个操作所需的网络传输量。</li>
<li>例如，分布式查询中跨节点的数据传输。</li>
</ul>
</li>
<li>数据分布：<ul>
<li>评估数据的分布情况，如表的大小、索引的覆盖率等。</li>
<li>数据分布会影响I&#x2F;O操作的次数和效率。</li>
</ul>
</li>
</ol>
<p>其中大部分的成本都是固定的，比如CPU成本、IO成本、内存成本。这个是根据你服务器的配置决定的。</p>
<p>所以，主要关注的是数据分布。</p>
<p>MySQL的数据分布使用<code>直方图</code>来记录。</p>
<h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h4><p><code>column_statistics数据字典表</code>存储有关列值的<code>直方图</code>统计信息，供优化器在构造查询执行计划时使用。要执行直方图管理，请使用<code>ANALYZE TABLE</code>语句。</p>
<ul>
<li>该表包含除几何类型（空间数据）和JSON之外的所有数据类型的列的统计信息。</li>
<li>该表是持久的，因此不必在每次服务器启动时都创建列统计信息。</li>
<li>服务器对表执行更新，用户不执行。</li>
</ul>
<p>用户不能直接访问<code>column_statistics</code>表，因为它是<code>数据字典</code>的一部分。直方图信息可使用 <code>INFORMATION_SCHEMA.COLUMN_STATISTICS</code> 获得，它是作为数据字典表上的视图实现的。<code>COLUMN_STATISTICS</code>包含以下列：</p>
<ul>
<li>SCHEMA_NAME、TABLE_NAME、COLUMN_NAME：应用统计信息的模式、表和列的名称。</li>
<li>HISTORIO：描述列统计信息的JSON值，存储为直方图。</li>
</ul>
<p>直方图实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;buckets&quot;: [</span><br><span class="line">    [</span><br><span class="line">      1,</span><br><span class="line">      0.3333333333333333</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      2,</span><br><span class="line">      0.6666666666666666</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      3,</span><br><span class="line">      1</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  &quot;null-values&quot;: 0,</span><br><span class="line">  &quot;last-updated&quot;: &quot;2017-03-24 13:32:40.000000&quot;,</span><br><span class="line">  &quot;sampling-rate&quot;: 1,</span><br><span class="line">  &quot;histogram-type&quot;: &quot;singleton&quot;,</span><br><span class="line">  &quot;number-of-buckets-specified&quot;: 128,</span><br><span class="line">  &quot;data-type&quot;: &quot;int&quot;,</span><br><span class="line">  &quot;collation-id&quot;: 8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>buckets：直方图桶。桶结构取决于直方图类型。</li>
<li>null-values：一个介于0.0和1.0之间的数字，表示<code>SQL NULL</code>值的列值的分数。如果为0，则该列不包含NULL值。</li>
<li>last-updated：直方图生成时，以 <code>YYYY-MM-DD hh:mm:ss.uuuuuu</code> 格式的UTC值表示。</li>
<li>sampling-rate：0.0到1.0之间的数字，表示为创建直方图而采样的数据比例。值为1表示已读取所有数据（无采样）。</li>
<li>histogram-type：直方图类型：<ul>
<li>singleton：一个bucket表示列中的一个值。当列中的非重复值数量小于或等于生成直方图的<code>ANALYZE TABLE</code>语句中指定的存储桶数量时，将创建此直方图类型。</li>
<li>equi-height：一个桶表示一个值范围。当列中的非重复值数量大于生成直方图的<code>ANALYZE TABLE</code>语句中指定的存储桶数量时，将创建此直方图类型。</li>
</ul>
</li>
<li>number-of-buckets-specified：生成直方图的<code>ANALYZE TABLE</code>语句中指定的<code>桶数</code>。</li>
<li>data-type：此直方图包含的数据类型。在将直方图从持久性存储器阅读和解析到内存中时，这是需要的。该值是int、uint（无符号整数）、double、decimal、datetime或string（包括字符和二进制字符串）之一。</li>
<li>collation-id：直方图数据的归类ID。当数据类型值是字符串时，它最有意义。值对应于信息架构<code>COLLATIONS</code>表中的ID列值。</li>
</ul>
<p>直方图统计信息主要用于非索引列。将索引添加到直方图统计信息适用的列还可以帮助优化器进行行估计。</p>
<p>优化器更喜欢范围优化器的行估计，而不是从直方图统计信息中获得的行估计。如果优化器确定范围优化器适用，则不使用直方图统计信息。</p>
<p>对于已建立索引的列，可以使用索引潜水(index dives)获得行估计值以进行相等比较。</p>
<p>在某些情况下，使用直方图统计信息可能不会改善查询执行（例如，如果统计信息过期）。要检查是否是这种情况，请使用<code>ANALYZE TABLE</code>重新生成直方图统计信息，然后再次运行查询。</p>
<p>这么看这些概念内容，可能很难理解直方图到底是干啥的，下面给出一个例子方便理解。</p>
<h5 id="直方图示例"><a href="#直方图示例" class="headerlink" title="直方图示例"></a>直方图示例</h5><h2 id="虽然直方图的字段很多，但其核心的字段只有几个"><a href="#虽然直方图的字段很多，但其核心的字段只有几个" class="headerlink" title="虽然直方图的字段很多，但其核心的字段只有几个"></a>虽然直方图的字段很多，但其核心的字段只有几个</h2><p>创建一个测试表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_a(id <span class="type">int</span> auto_increment,a <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span>, b <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>, <span class="keyword">primary</span> key(id));</span><br></pre></td></tr></table></figure>

<p>接下来我们插入几个数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_a (a, b) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;A1&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;B2&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;C3&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;D4&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;E5&#x27;</span>),</span><br><span class="line">(<span class="number">6</span>, <span class="string">&#x27;F6&#x27;</span>),</span><br><span class="line">(<span class="number">7</span>, <span class="string">&#x27;G7&#x27;</span>),</span><br><span class="line">(<span class="number">8</span>, <span class="string">&#x27;H8&#x27;</span>),</span><br><span class="line">(<span class="number">9</span>, <span class="string">&#x27;I9&#x27;</span>),</span><br><span class="line">(<span class="number">10</span>, <span class="string">&#x27;J10&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>接下来生成直方图信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE <span class="keyword">TABLE</span> test_a <span class="keyword">update</span>  HISTOGRAM <span class="keyword">ON</span> a <span class="keyword">WITH</span> <span class="number">5</span> BUCKETS;</span><br></pre></td></tr></table></figure>

<p>查询直方图信息。这里的<code>SCHEMA_NAME</code>是数据库的名称，TABLE_NAME是数据表的名称。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.COLUMN_STATISTICS <span class="keyword">where</span> SCHEMA_NAME <span class="operator">=</span> <span class="string">&#x27;test1&#x27;</span> <span class="keyword">and</span> TABLE_NAME <span class="operator">=</span> <span class="string">&#x27;test_a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>查询结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+-------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> SCHEMA_NAME <span class="operator">|</span> TABLE_NAME <span class="operator">|</span> COLUMN_NAME <span class="operator">|</span> HISTOGRAM</span><br><span class="line">                                                                                                                                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+-------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> test1       <span class="operator">|</span> test_a     <span class="operator">|</span> a           <span class="operator">|</span> &#123;&quot;buckets&quot;: [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0.2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">0.4</span>, <span class="number">2</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">0.6</span>, <span class="number">2</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">0.8</span>, <span class="number">2</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">1.0</span>, <span class="number">2</span>]], &quot;data-type&quot;: &quot;int&quot;, &quot;auto-update&quot;: <span class="literal">false</span>, &quot;null-values&quot;: <span class="number">0.0</span>, &quot;collation-id&quot;: <span class="number">8</span>, &quot;last-updated&quot;: &quot;2025-01-25 13:01:57.129967&quot;, &quot;sampling-rate&quot;: <span class="number">1.0</span>, &quot;histogram-type&quot;: &quot;equi-height&quot;, &quot;number-of-buckets-specified&quot;: <span class="number">5</span>&#125; <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+-------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>我们来看一下直方图的信息。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;buckets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">0.4</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">0.6</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">7</span><span class="punctuation">,</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">9</span><span class="punctuation">,</span> <span class="number">10</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;data-type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;int&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;auto-update&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;null-values&quot;</span><span class="punctuation">:</span> <span class="number">0.0</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;collation-id&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;last-updated&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2025-01-25 13:01:57.129967&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;sampling-rate&quot;</span><span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;histogram-type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;equi-height&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;number-of-buckets-specified&quot;</span><span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>buckets：直方图桶。桶结构取决于直方图类型。</li>
<li>null-values：0.0,表示没有null值，这是因为我们使用了<code>not null</code>声明字段。</li>
<li>last-updated：更新时间，没啥好说的。</li>
<li>sampling-rate：1.0 获取了所有数据，因为我们只有10条数据，很少。</li>
<li>histogram-type：直方图类型：equi-height，因为<code>a</code>列有10个值，都不重复，而桶数量我们用的是5，所以生成了这个类型。</li>
<li>number-of-buckets-specified：生成直方图的<code>ANALYZE TABLE</code>语句中指定的<code>桶数</code>。</li>
<li>data-type：列a是int类型</li>
<li>collation-id：直方图数据的归类ID。当数据类型值是字符串时，它最有意义。值对应于信息架构<code>COLLATIONS</code>表中的ID列值。</li>
</ul>
<p>桶里面有4个数据</p>
<ul>
<li>最小值</li>
<li>最大值</li>
<li>密度</li>
<li>高度</li>
</ul>
<p>比如，查询语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_a <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><code>a = 5</code>的数据在第三个桶里面，最小值5，最大值6，密度0.6，高度2.</p>
<p>根据计算公式<code>预估行数 = 密度 * 高度</code>来计算0.6 * 2，预估行数就是1.2，也就是1-2行。</p>
<p><img src="https://thepatterraining.github.io/images/mysql/mysql2-6.jpg" alt="架构"></p>
<p>可以看到查询计划里面的rows是10行，这是因为类型是全表扫描，但是后面的<code>filtered</code>字段是10，表示的意思是会过滤出来 <code>10 * 10% = 10 * 0.1 = 1</code>行。</p>
<p>也就是最终会查出1行结果。</p>
<p>通常来说，对于没有索引的列，MySQL就是这样来预估行数的，并且通过这个结果来进行选择执行路线。</p>
<h3 id="执行路线选择"><a href="#执行路线选择" class="headerlink" title="执行路线选择"></a>执行路线选择</h3><p>什么叫路线选择呢，还是上面那个表，我们现在有如下SQL语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,b <span class="keyword">from</span> test_a <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> b <span class="operator">=</span> <span class="string">&#x27;A1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>根据表数据，其实我们知道，查出来的结果还是1条。但是对于mysql来说，却有不同的执行方式。</p>
<p>第一种执行方式，先查<code>a=1</code>在查询<code>b=&#39;A1&#39;</code>的数据。执行树如下。</p>
<p><img src="https://thepatterraining.github.io/images/mysql/mysql2-7.jpg" alt="架构"></p>
<p>第二种执行方式，先查<code>b=&#39;A1&#39;</code>在查询 <code>a=1</code>。执行树如下。</p>
<p><img src="https://thepatterraining.github.io/images/mysql/mysql2-8.jpg" alt="架构"></p>
<p>目前看着这两种方式都没啥问题。</p>
<p>但是，我们再插入一条数据呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_a (a, b) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">11</span>, <span class="string">&#x27;A1&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这样我们就知道了，方案1， 会直接过滤出1行数据，然后在过滤，这样显然比方案2更好。</p>
<p>因为方案2会先查出2条数据，再次过滤。</p>
<p>这就是不同的执行路线带来的性能区别。当然了，我们这里的例子只是打个比方，实际上<code>谓词下推</code>优化以后，这两个条件都是和扫描表一起执行的。</p>
<p>这个例子只是让你明白不同的路线选择而已。</p>
<p>对于<code>join</code>查询来说，会有更多的选择。</p>
<h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>以上就是今天的内容了，大家有任何疑问可以打在评论区，一起交流～</p>
<p>关注我发送“MySQL知识图谱”领取完整的MySQL学习路线。</p>
<p>发送“电子书”即可领取价值上千的电子书资源。</p>
<p>部分电子书如图所示。</p>
<p><img src="https://thepatterraining.github.io/images/bottom1.png" alt="概念学习"></p>
<p><img src="https://thepatterraining.github.io/images/bottom2.png" alt="概念学习"></p>
<p><img src="https://thepatterraining.github.io/images/bottom3.png" alt="概念学习"></p>
<p><img src="https://thepatterraining.github.io/images/bottom4.png" alt="概念学习"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQLDML%E7%AF%87.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQLDML%E7%AF%87.html" class="post-title-link" itemprop="url">MySQL零基础教程基础篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-26 10:12:47" itemprop="dateCreated datePublished" datetime="2023-04-26T10:12:47+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-27 15:52:17" itemprop="dateModified" datetime="2025-02-27T15:52:17+08:00">2025-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMU15445/" itemprop="url" rel="index"><span itemprop="name">CMU15445</span></a>
                </span>
            </span>

          
            <span id="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQLDML%E7%AF%87.html" class="post-meta-item leancloud_visitors" data-flag-title="MySQL零基础教程基础篇" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQLDML%E7%AF%87.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQLDML%E7%AF%87.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL零基础教程基础篇"><a href="#MySQL零基础教程基础篇" class="headerlink" title="MySQL零基础教程基础篇"></a>MySQL零基础教程基础篇</h1><p>大家好，我是大头，98年，职高毕业，上市公司架构师，大厂资深开发，管理过10人团队，我是如何做到的呢？</p>
<p>这离不开持续学习的能力，而其中最重要的当然是数据库技术了！</p>
<p>对于所有开发来说，都离不开数据库，因为所有的数据都是要存储的。</p>
<p>关注我一起学习！文末有惊喜哦！</p>
<p>基础篇的内容大致如下图所示。</p>
<p><img src="https://thepatterraining.github.io/images/mysql/mysql1-1.png" alt="概念学习"></p>
<h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><p>介绍完概念以后，我们可以来看看SQL语句了。SQL语句通常由三类组成。</p>
<p>数据定义 DDL</p>
<ul>
<li>CREATE 创建数据库或数据库对象</li>
<li>ALTER 对数据库或数据库对象进行修改</li>
<li>DROP 删除数据库或数据库对象<br>数据操纵 DML</li>
<li>SELECT 从表或视图中检索数据</li>
<li>INSERT 将数据插入到表或视图中</li>
<li>UPDATE 修改表或视图中的数据</li>
<li>DELETE 从表或视图中删除数据<br>数据控制 DCL</li>
<li>GRANT 用于授予权限</li>
<li>REVOKE 用于收回权限</li>
</ul>
<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p>MySQL 中的 DML（数据操纵语言，Data Manipulation Language） 语句用于对数据库中的数据进行操作，主要包括数据的插入、更新、删除和查询。DML 语句是数据库操作中最常用的语句类型。</p>
<h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><p>插入数据使用<code>insert</code>指令，可以往创建好的一张表里面插入数据，支持多种插入方式。</p>
<p>最常用的方式是<code>insert  values</code>，这种方式也支持批量插入数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name[(col_name)] <span class="keyword">values</span> ();</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (id, name, department, salary)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;John Doe&#x27;</span>, <span class="string">&#x27;IT&#x27;</span>, <span class="number">50000</span>);</span><br></pre></td></tr></table></figure>

<p>还有一种方式是 <code>insert  set</code>。这种方式不支持批量插入。这种方式以键值对的形式插入数据，适用于插入单行数据。这种方式在插入单行数据时更加直观，尤其是当列名较多时。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name</span><br><span class="line"><span class="keyword">set</span> col_name <span class="operator">=</span> <span class="string">&#x27;值&#x27;</span>, col_name <span class="operator">=</span> <span class="string">&#x27;值&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>还是刚才的插入示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (id, name, department, salary)</span><br><span class="line"><span class="keyword">set</span> id <span class="operator">=</span> <span class="number">1</span>，name <span class="operator">=</span> <span class="string">&#x27;John Doe&#x27;</span>，department<span class="operator">=</span><span class="string">&#x27;IT&#x27;</span>，salary<span class="operator">=</span><span class="number">50000</span>；</span><br></pre></td></tr></table></figure>

<p>还有一种方式是<code>insert  select</code>方式，这种方式适合快速复制表数据，将查询出来的数据插入到另外一个表里面。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure>

<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>可以使用<code>delete from</code>指令来删除已经插入的数据。如果不加where条件的话，就是删除全表数据。</p>
<p>删除数据操作一定要慎重！！！</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>示例：删除刚才插入到表<code>employees</code>的<code>ID=1</code>的数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> employees <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>除了使用delete指令以外，还可以使用<code>TRUNCATE</code>指令，这个指令可以删除全表的数据，并且新的数据id自增从1开始。删除全表数据的话，该指令通常更快速。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">TABLE</span> table_name</span><br></pre></td></tr></table></figure>

<h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><p>当插入的数据内容需要修改或者说更新的时候，则可以使用<code>update set</code>指令进行修改。修改操作可以使用where条件来选择要修改的数据，不加where条件则会更新所有数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> table_name <span class="keyword">set</span> col_name <span class="operator">=</span> <span class="string">&#x27;值&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>示例：将刚才插入的数据部门修改一下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> employees <span class="keyword">set</span> department <span class="operator">=</span> <span class="string">&#x27;Market&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h4><p>数据查询语句是最复杂的语句，这里只是介绍，想要完全用明白，需要大量的实践。</p>
<h5 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h5><p>select用于查询数据表里面插入的数据。</p>
<p><code>*</code>代表查询所有字段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>

<h5 id="列的选择与指定"><a href="#列的选择与指定" class="headerlink" title="列的选择与指定"></a>列的选择与指定</h5><p>如果查询指定字段，则使用字段名称代替<code>*</code>。</p>
<p>实际开发中不推荐查询所有字段，推荐查询需要的字段，可以提升查询速度。</p>
<ul>
<li>如果查询的字段正好是索引，那么可以触发覆盖索引</li>
<li>如果查询的字段过多，会增加网络传输消耗</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name1,col_name2... <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>

<h5 id="定义别名"><a href="#定义别名" class="headerlink" title="定义别名"></a>定义别名</h5><p>可以给字段和表定义别名，通过<code>as</code>指令实现。别名可以解决一些字段名冲突或者字段名过长的问题。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name <span class="keyword">as</span> alias <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>

<p>示例：department字段给一个别名是depart</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id，department <span class="keyword">as</span> depart <span class="keyword">from</span> employees</span><br></pre></td></tr></table></figure>

<h5 id="where条件"><a href="#where条件" class="headerlink" title="where条件"></a>where条件</h5><p>通过where关键字来进行条件筛选，可以选择出符合条件的数据。</p>
<p>比如当前用户表user有数据如下：以下数据均为随机生成，非真实数据。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#104;&#x61;&#x6e;&#x67;&#x73;&#97;&#x6e;&#64;&#x65;&#x78;&#x61;&#x6d;&#112;&#108;&#x65;&#46;&#99;&#111;&#109;">&#x7a;&#104;&#x61;&#x6e;&#x67;&#x73;&#97;&#x6e;&#64;&#x65;&#x78;&#x61;&#x6d;&#112;&#108;&#x65;&#46;&#99;&#111;&#109;</a></td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#x6c;&#x69;&#x73;&#x69;&#x40;&#101;&#120;&#97;&#109;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#x6d;">&#x6c;&#x69;&#x73;&#x69;&#x40;&#101;&#120;&#97;&#109;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>003</td>
<td>王五</td>
<td>男</td>
<td>13700009012</td>
<td><a href="mailto:&#119;&#97;&#x6e;&#103;&#x77;&#x75;&#64;&#x65;&#x78;&#97;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#x63;&#111;&#x6d;">&#119;&#97;&#x6e;&#103;&#x77;&#x75;&#64;&#x65;&#x78;&#97;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>004</td>
<td>赵六</td>
<td>女</td>
<td>13600003456</td>
<td><a href="mailto:&#122;&#104;&#x61;&#111;&#108;&#105;&#117;&#64;&#x65;&#x78;&#97;&#x6d;&#x70;&#108;&#x65;&#x2e;&#99;&#x6f;&#x6d;">&#122;&#104;&#x61;&#111;&#108;&#105;&#117;&#64;&#x65;&#x78;&#97;&#x6d;&#x70;&#108;&#x65;&#x2e;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>005</td>
<td>孙七</td>
<td>男</td>
<td>13500007890</td>
<td><a href="mailto:&#115;&#117;&#x6e;&#113;&#x69;&#x40;&#101;&#120;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#x6f;&#109;">&#115;&#117;&#x6e;&#113;&#x69;&#x40;&#101;&#120;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>006</td>
<td>周八</td>
<td>女</td>
<td>13400001234</td>
<td><a href="mailto:&#x7a;&#x68;&#x6f;&#117;&#98;&#97;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#x65;&#46;&#99;&#x6f;&#109;">&#x7a;&#x68;&#x6f;&#117;&#98;&#97;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#x65;&#46;&#99;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>007</td>
<td>吴九</td>
<td>男</td>
<td>13300005678</td>
<td><a href="mailto:&#x77;&#117;&#106;&#x69;&#117;&#x40;&#x65;&#120;&#x61;&#x6d;&#x70;&#108;&#101;&#x2e;&#99;&#x6f;&#109;">&#x77;&#117;&#106;&#x69;&#117;&#x40;&#x65;&#120;&#x61;&#x6d;&#x70;&#108;&#101;&#x2e;&#99;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>008</td>
<td>郑十</td>
<td>女</td>
<td>13200009012</td>
<td><a href="mailto:&#122;&#104;&#x65;&#x6e;&#x67;&#115;&#104;&#x69;&#64;&#101;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;">&#122;&#104;&#x65;&#x6e;&#x67;&#115;&#104;&#x69;&#64;&#101;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>009</td>
<td>钱伯</td>
<td>男</td>
<td>13100003456</td>
<td><a href="mailto:&#113;&#105;&#x61;&#110;&#98;&#x6f;&#64;&#x65;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;">&#113;&#105;&#x61;&#110;&#98;&#x6f;&#64;&#x65;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>010</td>
<td>孔仲</td>
<td>女</td>
<td>13000007890</td>
<td><a href="mailto:&#107;&#111;&#x6e;&#103;&#x7a;&#104;&#111;&#x6e;&#x67;&#64;&#x65;&#120;&#97;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;">&#107;&#111;&#x6e;&#103;&#x7a;&#104;&#111;&#x6e;&#x67;&#64;&#x65;&#120;&#97;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;</a></td>
</tr>
</tbody></table>
<p>这个时候我们需要查询出张三的用户信息，而不是将这10个数据都查询出来到程序里在筛选出张三的数据。</p>
<p>可以使用如下sql完成。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>; </span><br></pre></td></tr></table></figure>

<p>这个sql会把name字段中等于‘张三’的数据查询出来。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#x68;&#x61;&#110;&#x67;&#x73;&#97;&#x6e;&#x40;&#101;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;">&#x7a;&#x68;&#x61;&#110;&#x67;&#x73;&#97;&#x6e;&#x40;&#101;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;</a></td>
</tr>
</tbody></table>
<p>where条件支持的类型如下：</p>
<ul>
<li>比较操作符</li>
</ul>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td>等于</td>
</tr>
<tr>
<td><code>&lt;&gt;</code></td>
<td>不等于（也可用<code>!=</code>）</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
</tr>
</tbody></table>
<ul>
<li><p>逻辑操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>AND</code></td>
<td>逻辑与（两个条件都满足）</td>
</tr>
<tr>
<td><code>OR</code></td>
<td>逻辑或（至少一个条件满足）</td>
</tr>
<tr>
<td><code>NOT</code></td>
<td>逻辑非（对条件取反）</td>
</tr>
</tbody></table>
</li>
<li><p>范围操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>BETWEEN...AND...</code></td>
<td>在指定范围内（包括边界值）</td>
</tr>
<tr>
<td><code>NOT BETWEEN</code></td>
<td>不在指定范围内</td>
</tr>
</tbody></table>
</li>
<li><p>列表操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>IN</code></td>
<td>在指定的列表中</td>
</tr>
<tr>
<td><code>NOT IN</code></td>
<td>不在指定的列表中</td>
</tr>
</tbody></table>
</li>
<li><p>模糊匹配操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>LIKE</code></td>
<td>模糊匹配（使用<code>%</code>和<code>_</code>作为通配符）</td>
</tr>
<tr>
<td><code>NOT LIKE</code></td>
<td>不匹配指定模式</td>
</tr>
</tbody></table>
</li>
<li><p>空值操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>IS NULL</code></td>
<td>判断是否为<code>NULL</code></td>
</tr>
<tr>
<td><code>IS NOT NULL</code></td>
<td>判断是否不为<code>NULL</code></td>
</tr>
</tbody></table>
</li>
<li><p>其他操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>EXISTS</code></td>
<td>检查子查询是否存在结果</td>
</tr>
<tr>
<td><code>NOT EXISTS</code></td>
<td>检查子查询是否不存在结果</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="替换查询结果集中的数据"><a href="#替换查询结果集中的数据" class="headerlink" title="替换查询结果集中的数据"></a>替换查询结果集中的数据</h5><p>可以使用if条件来进行结果的判定，比如性别，数据库里面存的可能是1代表男，2代表女。如果要查询出来男和女的话，就可以直接通过sql处理。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> </span><br><span class="line"><span class="keyword">when</span> 条件<span class="number">1</span> <span class="keyword">then</span> 表达式<span class="number">1</span></span><br><span class="line"><span class="keyword">when</span> 条件<span class="number">2</span> <span class="keyword">then</span> 表达式<span class="number">2</span></span><br><span class="line"><span class="keyword">else</span> 表达式</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">as</span> alias</span><br></pre></td></tr></table></figure>

<p>示例：性别转换。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="keyword">CASE</span> </span><br><span class="line">        <span class="keyword">WHEN</span> gender <span class="operator">=</span> <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">&#x27;男&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> gender <span class="operator">=</span> <span class="number">2</span> <span class="keyword">THEN</span> <span class="string">&#x27;女&#x27;</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">&#x27;未知&#x27;</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> 性别</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<h4 id="计算列值"><a href="#计算列值" class="headerlink" title="计算列值"></a>计算列值</h4><p>可以直接计算将字段的值进行加减乘除运算。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name <span class="operator">+</span> <span class="number">100</span> <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>

<h4 id="from-子句与多表连接查询"><a href="#from-子句与多表连接查询" class="headerlink" title="from 子句与多表连接查询"></a>from 子句与多表连接查询</h4><h5 id="交叉连接，笛卡尔积"><a href="#交叉连接，笛卡尔积" class="headerlink" title="交叉连接，笛卡尔积"></a>交叉连接，笛卡尔积</h5><p>交叉连接可以连接两个表，产生两个表的笛卡尔积作为结果。</p>
<p>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_namme1 <span class="keyword">cross</span> <span class="keyword">join</span> table_name2</span><br></pre></td></tr></table></figure>
<p>可以直接简写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name1,table_name2;</span><br></pre></td></tr></table></figure>

<p>示例：获取两个表的交叉连接。</p>
<p>假设有表user如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#x68;&#x61;&#110;&#x67;&#x73;&#97;&#110;&#x40;&#101;&#x78;&#97;&#109;&#x70;&#108;&#101;&#x2e;&#99;&#111;&#109;">&#x7a;&#x68;&#x61;&#110;&#x67;&#x73;&#97;&#110;&#x40;&#101;&#x78;&#97;&#109;&#x70;&#108;&#101;&#x2e;&#99;&#111;&#109;</a></td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#x69;&#x73;&#105;&#x40;&#x65;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;">&#108;&#x69;&#x73;&#105;&#x40;&#x65;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;</a></td>
</tr>
</tbody></table>
<p>还有表user_account存储用户的账户余额信息如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
</tbody></table>
<p>使用如下sql语句获取交叉连接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>,user_account;</span><br></pre></td></tr></table></figure>

<p>结果如下：也就是用户表数据001和用户账户001产生一条数据，和用户账户002产生一条数据，用户数据002同样。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
<th>ID2</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#x68;&#97;&#x6e;&#x67;&#x73;&#x61;&#110;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;">&#x7a;&#x68;&#97;&#x6e;&#x67;&#x73;&#x61;&#110;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;</a></td>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#122;&#104;&#x61;&#x6e;&#x67;&#115;&#97;&#x6e;&#64;&#x65;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#x6f;&#109;">&#122;&#104;&#x61;&#x6e;&#x67;&#115;&#97;&#x6e;&#64;&#x65;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#x6f;&#109;</a></td>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#105;&#x73;&#105;&#x40;&#101;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#109;">&#108;&#105;&#x73;&#105;&#x40;&#101;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#109;</a></td>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#105;&#115;&#105;&#64;&#101;&#x78;&#x61;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#111;&#x6d;">&#108;&#105;&#115;&#105;&#64;&#101;&#x78;&#x61;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#111;&#x6d;</a></td>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
</tbody></table>
<h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>内连接返回两个表中匹配的记录。只有当两个表中的记录满足连接条件时，才会出现在结果集中。可以理解为两个表的交集。</p>
<p>连接的时候，<code>on</code>就类似于where条件，只不过仅仅在连接表数据的时候生效。内连接返回两个表都满足这个条件的交集。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name <span class="keyword">from</span> table_name <span class="keyword">inner</span> <span class="keyword">join</span> table_name2 <span class="keyword">on</span> table_name.id <span class="operator">=</span> table_name2.t_id;</span><br></pre></td></tr></table></figure>

<p>示例：获取用户数据和用户账户数据的内连接。</p>
<p>假设有表user如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#104;&#x61;&#x6e;&#103;&#115;&#x61;&#110;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#108;&#101;&#46;&#99;&#x6f;&#x6d;">&#x7a;&#104;&#x61;&#x6e;&#103;&#115;&#x61;&#110;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#108;&#101;&#46;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#x6c;&#x69;&#x73;&#105;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#101;&#46;&#x63;&#x6f;&#x6d;">&#x6c;&#x69;&#x73;&#105;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#101;&#46;&#x63;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>003</td>
<td>王五</td>
<td>男</td>
<td>13700009012</td>
<td><a href="mailto:&#119;&#x61;&#110;&#103;&#119;&#x75;&#x40;&#x65;&#x78;&#x61;&#x6d;&#112;&#108;&#101;&#x2e;&#x63;&#x6f;&#x6d;">&#119;&#x61;&#110;&#103;&#119;&#x75;&#x40;&#x65;&#x78;&#x61;&#x6d;&#112;&#108;&#101;&#x2e;&#x63;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>004</td>
<td>赵六</td>
<td>女</td>
<td>13600003456</td>
<td><a href="mailto:&#122;&#x68;&#97;&#x6f;&#x6c;&#x69;&#117;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#109;">&#122;&#x68;&#97;&#x6f;&#x6c;&#x69;&#117;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>005</td>
<td>孙七</td>
<td>男</td>
<td>13500007890</td>
<td><a href="mailto:&#x73;&#117;&#x6e;&#x71;&#x69;&#64;&#101;&#120;&#97;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#109;">&#x73;&#117;&#x6e;&#x71;&#x69;&#64;&#101;&#120;&#97;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#109;</a></td>
</tr>
<tr>
<td>006</td>
<td>周八</td>
<td>女</td>
<td>13400001234</td>
<td><a href="mailto:&#x7a;&#x68;&#x6f;&#117;&#x62;&#97;&#64;&#x65;&#120;&#x61;&#109;&#112;&#x6c;&#x65;&#46;&#99;&#111;&#109;">&#x7a;&#x68;&#x6f;&#117;&#x62;&#97;&#64;&#x65;&#120;&#x61;&#109;&#112;&#x6c;&#x65;&#46;&#99;&#111;&#109;</a></td>
</tr>
<tr>
<td>007</td>
<td>吴九</td>
<td>男</td>
<td>13300005678</td>
<td><a href="mailto:&#119;&#117;&#106;&#105;&#x75;&#64;&#101;&#x78;&#97;&#109;&#112;&#108;&#x65;&#x2e;&#99;&#x6f;&#109;">&#119;&#117;&#106;&#105;&#x75;&#64;&#101;&#x78;&#97;&#109;&#112;&#108;&#x65;&#x2e;&#99;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>008</td>
<td>郑十</td>
<td>女</td>
<td>13200009012</td>
<td><a href="mailto:&#x7a;&#x68;&#x65;&#x6e;&#103;&#115;&#x68;&#x69;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#111;&#x6d;">&#x7a;&#x68;&#x65;&#x6e;&#103;&#115;&#x68;&#x69;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>009</td>
<td>钱伯</td>
<td>男</td>
<td>13100003456</td>
<td><a href="mailto:&#x71;&#105;&#x61;&#110;&#98;&#x6f;&#64;&#101;&#120;&#x61;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#x6d;">&#x71;&#105;&#x61;&#110;&#98;&#x6f;&#64;&#101;&#120;&#x61;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>010</td>
<td>孔仲</td>
<td>女</td>
<td>13000007890</td>
<td><a href="mailto:&#107;&#x6f;&#x6e;&#x67;&#x7a;&#x68;&#x6f;&#110;&#x67;&#64;&#101;&#120;&#x61;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#109;">&#107;&#x6f;&#x6e;&#x67;&#x7a;&#x68;&#x6f;&#110;&#x67;&#64;&#101;&#120;&#x61;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#109;</a></td>
</tr>
</tbody></table>
<p>还有表user_account存储用户的账户余额信息如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>003</td>
<td>011</td>
<td>20</td>
</tr>
</tbody></table>
<p>可以看到这两个表的交集就只有两条数据，也就是001和002，</p>
<p>使用如下sql语句获取交叉连接：</p>
<p><code>on user.id = user_account.user_id</code>这个条件代表只有当user表的id字段和user_account表的user_id字段相等的时候，才会有结果;</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">inner</span> <span class="keyword">join</span> user_account <span class="keyword">on</span> user.id <span class="operator">=</span> user_account.user_id;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
<th>ID2</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#122;&#x68;&#x61;&#110;&#103;&#x73;&#x61;&#110;&#64;&#101;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;">&#122;&#x68;&#x61;&#110;&#103;&#x73;&#x61;&#110;&#64;&#101;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;</a></td>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#x69;&#x73;&#x69;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#101;&#46;&#99;&#111;&#109;">&#108;&#x69;&#x73;&#x69;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#101;&#46;&#99;&#111;&#109;</a></td>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
</tbody></table>
<h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>外连接分为左连接和右连接，左连接返回内连接的结果+左表剩余的数据，右连接返回内连接的结果+右表剩余的数据。</p>
<p>左表就是 <code>join</code>左边的表，右表就是<code>join</code>右边的表。</p>
<p>左连接使用<code>left join</code>指令。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name <span class="keyword">from</span> table_name <span class="keyword">left</span> <span class="keyword">join</span> table_name2 <span class="keyword">on</span> table_name.id <span class="operator">=</span> table_name2.t_id;</span><br></pre></td></tr></table></figure>

<p>示例：获取用户表和用户账户表的左连接结果。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#122;&#x68;&#97;&#110;&#x67;&#115;&#97;&#110;&#64;&#x65;&#120;&#97;&#109;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#x6d;">&#122;&#x68;&#97;&#110;&#x67;&#115;&#97;&#110;&#64;&#x65;&#120;&#97;&#109;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#x6c;&#105;&#115;&#105;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#46;&#99;&#111;&#109;">&#x6c;&#105;&#115;&#105;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#46;&#99;&#111;&#109;</a></td>
</tr>
<tr>
<td>003</td>
<td>王五</td>
<td>男</td>
<td>13700009012</td>
<td><a href="mailto:&#119;&#x61;&#110;&#x67;&#119;&#x75;&#x40;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#119;&#x61;&#110;&#x67;&#119;&#x75;&#x40;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#101;&#x2e;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>004</td>
<td>赵六</td>
<td>女</td>
<td>13600003456</td>
<td><a href="mailto:&#122;&#x68;&#x61;&#111;&#x6c;&#105;&#x75;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;">&#122;&#x68;&#x61;&#111;&#x6c;&#105;&#x75;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>005</td>
<td>孙七</td>
<td>男</td>
<td>13500007890</td>
<td><a href="mailto:&#x73;&#x75;&#110;&#113;&#105;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#111;&#109;">&#x73;&#x75;&#110;&#113;&#105;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>006</td>
<td>周八</td>
<td>女</td>
<td>13400001234</td>
<td><a href="mailto:&#x7a;&#104;&#111;&#x75;&#x62;&#x61;&#64;&#101;&#120;&#97;&#109;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;">&#x7a;&#104;&#111;&#x75;&#x62;&#x61;&#64;&#101;&#120;&#97;&#109;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>007</td>
<td>吴九</td>
<td>男</td>
<td>13300005678</td>
<td><a href="mailto:&#x77;&#x75;&#x6a;&#105;&#x75;&#64;&#101;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#x6f;&#x6d;">&#x77;&#x75;&#x6a;&#105;&#x75;&#64;&#101;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>008</td>
<td>郑十</td>
<td>女</td>
<td>13200009012</td>
<td><a href="mailto:&#x7a;&#x68;&#x65;&#x6e;&#x67;&#115;&#x68;&#105;&#x40;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#109;">&#x7a;&#x68;&#x65;&#x6e;&#x67;&#115;&#x68;&#105;&#x40;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>009</td>
<td>钱伯</td>
<td>男</td>
<td>13100003456</td>
<td><a href="mailto:&#113;&#105;&#97;&#x6e;&#98;&#x6f;&#x40;&#101;&#120;&#x61;&#109;&#112;&#x6c;&#x65;&#x2e;&#x63;&#111;&#x6d;">&#113;&#105;&#97;&#x6e;&#98;&#x6f;&#x40;&#101;&#120;&#x61;&#109;&#112;&#x6c;&#x65;&#x2e;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>010</td>
<td>孔仲</td>
<td>女</td>
<td>13000007890</td>
<td><a href="mailto:&#107;&#x6f;&#x6e;&#x67;&#x7a;&#104;&#x6f;&#110;&#103;&#x40;&#x65;&#120;&#97;&#109;&#112;&#108;&#101;&#x2e;&#99;&#111;&#x6d;">&#107;&#x6f;&#x6e;&#x67;&#x7a;&#104;&#x6f;&#110;&#103;&#x40;&#x65;&#120;&#97;&#109;&#112;&#108;&#101;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
</tbody></table>
<p>还有表user_account存储用户的账户余额信息如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>003</td>
<td>011</td>
<td>20</td>
</tr>
</tbody></table>
<p>使用如下sql语句，可以看到，仅仅是<code>inner join</code>换成了<code>left join</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">left</span> <span class="keyword">join</span> user_account <span class="keyword">on</span> user.id <span class="operator">=</span> user_account.user_id;</span><br></pre></td></tr></table></figure>

<p>结果如下：在内连接的结果基础上，增加了<code>左表user表</code>剩下的8条数据，右表的字段内容则是<code>null</code>，代表没有对应字段的数据。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
<th>ID2</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#104;&#x61;&#110;&#103;&#x73;&#x61;&#110;&#64;&#x65;&#x78;&#97;&#x6d;&#112;&#108;&#x65;&#46;&#99;&#111;&#109;">&#x7a;&#104;&#x61;&#110;&#103;&#x73;&#x61;&#110;&#64;&#x65;&#x78;&#97;&#x6d;&#112;&#108;&#x65;&#46;&#99;&#111;&#109;</a></td>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#x6c;&#x69;&#x73;&#105;&#64;&#101;&#120;&#97;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">&#x6c;&#x69;&#x73;&#105;&#64;&#101;&#120;&#97;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#x6d;</a></td>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>003</td>
<td>王五</td>
<td>男</td>
<td>13700009012</td>
<td><a href="mailto:&#x77;&#97;&#110;&#103;&#x77;&#117;&#64;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#109;">&#x77;&#97;&#110;&#103;&#x77;&#117;&#64;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#109;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>004</td>
<td>赵六</td>
<td>女</td>
<td>13600003456</td>
<td><a href="mailto:&#122;&#104;&#x61;&#x6f;&#x6c;&#x69;&#117;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#x65;&#x2e;&#99;&#x6f;&#x6d;">&#122;&#104;&#x61;&#x6f;&#x6c;&#x69;&#117;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#x65;&#x2e;&#99;&#x6f;&#x6d;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>005</td>
<td>孙七</td>
<td>男</td>
<td>13500007890</td>
<td><a href="mailto:&#115;&#117;&#110;&#113;&#x69;&#64;&#101;&#x78;&#97;&#109;&#x70;&#108;&#101;&#46;&#99;&#111;&#x6d;">&#115;&#117;&#110;&#113;&#x69;&#64;&#101;&#x78;&#97;&#109;&#x70;&#108;&#101;&#46;&#99;&#111;&#x6d;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>006</td>
<td>周八</td>
<td>女</td>
<td>13400001234</td>
<td><a href="mailto:&#122;&#104;&#111;&#x75;&#98;&#97;&#x40;&#101;&#x78;&#97;&#109;&#112;&#x6c;&#101;&#46;&#99;&#111;&#109;">&#122;&#104;&#111;&#x75;&#98;&#97;&#x40;&#101;&#x78;&#97;&#109;&#112;&#x6c;&#101;&#46;&#99;&#111;&#109;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>007</td>
<td>吴九</td>
<td>男</td>
<td>13300005678</td>
<td><a href="mailto:&#x77;&#117;&#106;&#105;&#117;&#64;&#x65;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#x6d;">&#x77;&#117;&#106;&#105;&#117;&#64;&#x65;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#x6d;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>008</td>
<td>郑十</td>
<td>女</td>
<td>13200009012</td>
<td><a href="mailto:&#x7a;&#x68;&#x65;&#x6e;&#x67;&#115;&#x68;&#105;&#x40;&#x65;&#120;&#x61;&#109;&#112;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">&#x7a;&#x68;&#x65;&#x6e;&#x67;&#115;&#x68;&#105;&#x40;&#x65;&#120;&#x61;&#109;&#112;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#x6d;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>009</td>
<td>钱伯</td>
<td>男</td>
<td>13100003456</td>
<td><a href="mailto:&#113;&#x69;&#97;&#110;&#x62;&#x6f;&#64;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#46;&#x63;&#111;&#x6d;">&#113;&#x69;&#97;&#110;&#x62;&#x6f;&#64;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#46;&#x63;&#111;&#x6d;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>010</td>
<td>孔仲</td>
<td>女</td>
<td>13000007890</td>
<td><a href="mailto:&#x6b;&#x6f;&#110;&#103;&#122;&#104;&#x6f;&#x6e;&#x67;&#x40;&#x65;&#120;&#x61;&#109;&#x70;&#108;&#101;&#46;&#99;&#x6f;&#x6d;">&#x6b;&#x6f;&#110;&#103;&#122;&#104;&#x6f;&#x6e;&#x67;&#x40;&#x65;&#120;&#x61;&#109;&#x70;&#108;&#101;&#46;&#99;&#x6f;&#x6d;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
</tbody></table>
<p>右连接使用<code>right join</code>指令。<br>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name <span class="keyword">from</span> table_name <span class="keyword">right</span> <span class="keyword">join</span> table_name2 <span class="keyword">on</span> table_name.id <span class="operator">=</span> table_name2.t_id;</span><br></pre></td></tr></table></figure>

<p>示例：获取用户表和用户账户表的右连接结果。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#x68;&#97;&#110;&#x67;&#115;&#97;&#x6e;&#x40;&#x65;&#120;&#x61;&#109;&#112;&#108;&#x65;&#46;&#x63;&#111;&#109;">&#x7a;&#x68;&#97;&#110;&#x67;&#115;&#97;&#x6e;&#x40;&#x65;&#120;&#x61;&#109;&#112;&#108;&#x65;&#46;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#x69;&#x73;&#105;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#109;">&#108;&#x69;&#x73;&#105;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>003</td>
<td>王五</td>
<td>男</td>
<td>13700009012</td>
<td><a href="mailto:&#x77;&#x61;&#110;&#x67;&#x77;&#117;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#46;&#x63;&#111;&#x6d;">&#x77;&#x61;&#110;&#x67;&#x77;&#117;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#46;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>004</td>
<td>赵六</td>
<td>女</td>
<td>13600003456</td>
<td><a href="mailto:&#122;&#x68;&#97;&#111;&#x6c;&#x69;&#117;&#64;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#x65;&#x2e;&#x63;&#111;&#x6d;">&#122;&#x68;&#97;&#111;&#x6c;&#x69;&#117;&#64;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#x65;&#x2e;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>005</td>
<td>孙七</td>
<td>男</td>
<td>13500007890</td>
<td><a href="mailto:&#115;&#117;&#110;&#113;&#x69;&#64;&#x65;&#x78;&#x61;&#109;&#112;&#108;&#x65;&#46;&#x63;&#111;&#109;">&#115;&#117;&#110;&#113;&#x69;&#64;&#x65;&#x78;&#x61;&#109;&#112;&#108;&#x65;&#46;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>006</td>
<td>周八</td>
<td>女</td>
<td>13400001234</td>
<td><a href="mailto:&#x7a;&#104;&#111;&#x75;&#x62;&#97;&#x40;&#x65;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#111;&#109;">&#x7a;&#104;&#111;&#x75;&#x62;&#97;&#x40;&#x65;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>007</td>
<td>吴九</td>
<td>男</td>
<td>13300005678</td>
<td><a href="mailto:&#119;&#x75;&#x6a;&#105;&#x75;&#64;&#101;&#120;&#97;&#x6d;&#112;&#108;&#101;&#46;&#x63;&#x6f;&#109;">&#119;&#x75;&#x6a;&#105;&#x75;&#64;&#101;&#120;&#97;&#x6d;&#112;&#108;&#101;&#46;&#x63;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>008</td>
<td>郑十</td>
<td>女</td>
<td>13200009012</td>
<td><a href="mailto:&#x7a;&#104;&#101;&#110;&#103;&#115;&#x68;&#105;&#64;&#101;&#x78;&#x61;&#x6d;&#112;&#108;&#101;&#x2e;&#99;&#111;&#x6d;">&#x7a;&#104;&#101;&#110;&#103;&#115;&#x68;&#105;&#64;&#101;&#x78;&#x61;&#x6d;&#112;&#108;&#101;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>009</td>
<td>钱伯</td>
<td>男</td>
<td>13100003456</td>
<td><a href="mailto:&#113;&#105;&#97;&#x6e;&#98;&#111;&#64;&#x65;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#101;&#46;&#99;&#111;&#x6d;">&#113;&#105;&#97;&#x6e;&#98;&#111;&#64;&#x65;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#101;&#46;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>010</td>
<td>孔仲</td>
<td>女</td>
<td>13000007890</td>
<td><a href="mailto:&#107;&#111;&#110;&#103;&#x7a;&#x68;&#111;&#110;&#103;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;">&#107;&#111;&#110;&#103;&#x7a;&#x68;&#111;&#110;&#103;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
</tbody></table>
<p>还有表user_account存储用户的账户余额信息如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>003</td>
<td>011</td>
<td>20</td>
</tr>
</tbody></table>
<p>使用如下sql语句，可以看到，仅仅是<code>left join</code>换成了<code>right join</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">right</span> <span class="keyword">join</span> user_account <span class="keyword">on</span> user.id <span class="operator">=</span> user_account.user_id;</span><br></pre></td></tr></table></figure>

<p>结果如下：在内连接的结果基础上，增加了<code>右表user_account表</code>剩下的1条数据，左表的字段内容则是<code>null</code>，代表没有对应字段的数据。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
<th>ID2</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#x68;&#97;&#x6e;&#103;&#115;&#97;&#x6e;&#x40;&#101;&#x78;&#x61;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;">&#x7a;&#x68;&#97;&#x6e;&#103;&#115;&#97;&#x6e;&#x40;&#101;&#x78;&#x61;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;</a></td>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#x69;&#115;&#105;&#64;&#x65;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#x6d;">&#108;&#x69;&#115;&#105;&#64;&#x65;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#x6d;</a></td>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>003</td>
<td>011</td>
<td>20</td>
</tr>
</tbody></table>
<h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><p>在MySQL中，子查询是一种强大的功能，允许在一个查询中嵌套另一个查询。根据子查询返回的结果类型，可以将其分为以下几种：</p>
<ul>
<li>表子查询</li>
<li>行子查询</li>
<li>列子查询</li>
<li>标量子查询</li>
</ul>
<blockquote>
<p>注意：所有的子查询应该慎重使用，因为子查询会导致查询速度降低。</p>
</blockquote>
<table>
<thead>
<tr>
<th>子查询类型</th>
<th>定义</th>
<th>特点</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>表子查询</strong></td>
<td>返回一个完整的表（多行多列）</td>
<td>通常用于<code>FROM</code>子句或<code>JOIN</code>操作中，结果是一个表结构</td>
<td><code>sql &lt;br&gt;SELECT * FROM (SELECT id, name FROM users) AS subquery;&lt;br&gt; </code></td>
</tr>
<tr>
<td><strong>行子查询</strong></td>
<td>返回一行数据（多列）</td>
<td>通常用于<code>WHERE</code>子句中，结果是一行数据，可以与多列比较</td>
<td><code>sql &lt;br&gt;SELECT * FROM users WHERE (id, name) = (SELECT id, name FROM users WHERE age = 25);&lt;br&gt;</code></td>
</tr>
<tr>
<td><strong>列子查询</strong></td>
<td>返回一列数据（多行）</td>
<td>通常用于<code>WHERE</code>子句中，结果是一列数据，可以与<code>IN</code>、<code>ANY</code>、<code>ALL</code>等操作符配合使用</td>
<td><code>sql&lt;br&gt;SELECT * FROM users WHERE id IN (SELECT id FROM orders);&lt;br&gt;</code></td>
</tr>
<tr>
<td><strong>标量子查询</strong></td>
<td>返回单个值（一行一列）</td>
<td>通常用于<code>WHERE</code>子句中，结果是一个单一值，可以与比较操作符配合使用</td>
<td><code>sql&lt;br&gt;SELECT * FROM users WHERE age = (SELECT MAX(age) FROM users);&lt;br&gt;</code></td>
</tr>
</tbody></table>
<h6 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h6><ul>
<li>定义：返回一个完整的表（多行多列）。</li>
<li>特点：可以作为虚拟表使用，通常用于FROM子句或JOIN操作中。</li>
<li>示例：SELECT id, name FROM users 这就是一个子查询，该子查询返回的结果是一张表的数据，将该子查询的结果作为一张表，供外部的查询使用。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> users) <span class="keyword">AS</span> subquery;</span><br></pre></td></tr></table></figure>

<h6 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h6><ul>
<li>定义：返回一行数据（多列）。</li>
<li>特点：结果是一行数据，可以与多列比较，通常用于WHERE子句中。</li>
<li>示例：SELECT id, name FROM users WHERE mobile &#x3D; “13012345678” 是一个子查询，该子查询返回了mobile字段等于13012345678的一行数据，并且只查询了id和name字段。将这两个字段作为外部查询的where条件。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> (id, name) <span class="operator">=</span> (<span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> mobile <span class="operator">=</span> &quot;13012345678&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h6><ul>
<li>定义：返回一列数据（多行）。</li>
<li>特点：结果是一列数据，可以与IN、ANY、ALL等操作符配合使用，通常用于WHERE子句中。</li>
<li>示例：SELECT user_id FROM orders 是一个子查询，该子查询返回了orders表的所有用户id信息，并将这些用户id作为外部查询的where条件。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> user_id <span class="keyword">FROM</span> orders);</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h6><ul>
<li>定义：返回单个值（一行一列）。</li>
<li>特点：结果是一个单一值，可以与比较操作符配合使用，通常用于WHERE子句中。</li>
<li>示例：SELECT MAX(age) FROM users 是一个子查询，该子查询返回了users表的最大的年龄信息，并将最大的用户年龄作为外部查询的where条件。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> age <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(age) <span class="keyword">FROM</span> users);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h5><ul>
<li>group语句可以实现分组的效果，什么是分组？</li>
</ul>
<p>假设该数据表中存储了10条订单信息，有3条是张三的，3条是李四的，剩下4条是王五的。</p>
<p>group分组以后就可以分成3组，一组是张三的3条数据，一组是李四的3条数据，一组是王五的4条数据。</p>
<ul>
<li>分组能干什么？</li>
</ul>
<p>分组以后可以统计每个分组中的订单数量、订单总额、订单平均金额等。</p>
<p>语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> col_name</span><br></pre></td></tr></table></figure>

<p>支持的聚合函数：</p>
<ul>
<li>count(col_name): 计算每个分组中该字段的数量，比如订单数量</li>
<li>sum(col_name): 计算每个分组中该字段的总额，比如订单总金额</li>
<li>avg(col_name): 计算每个分组中该字段的平均值，比如订单平均金额</li>
<li>min(col_name): 获取每个分组中该字段的最小值</li>
<li>max(col_name): 获取每个分组中该字段的最大值</li>
</ul>
<p>有人要问了？那我不使用<code>group by</code>的情况下，可以使用上面的聚合函数吗？</p>
<p>当然可以了，没有分组，其实相当于所有数据是一个大分组，所以计算的是所有数据数量、总额等。</p>
<p>示例：下表是订单表，记录了3个用户的订单信息，现在需要查询这3个用户的订单数量、订单总金额、订单平均金额、最小金额以及最大金额。</p>
<table>
<thead>
<tr>
<th>OrderID</th>
<th>UserID</th>
<th>OrderDate</th>
<th>OrderAmount</th>
<th>OrderStatus</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>1</td>
<td>2025-02-01</td>
<td>120.00</td>
<td>Completed</td>
</tr>
<tr>
<td>1002</td>
<td>1</td>
<td>2025-02-02</td>
<td>85.00</td>
<td>Pending</td>
</tr>
<tr>
<td>1003</td>
<td>1</td>
<td>2025-02-03</td>
<td>230.00</td>
<td>Shipped</td>
</tr>
<tr>
<td>1004</td>
<td>2</td>
<td>2025-02-04</td>
<td>150.00</td>
<td>Completed</td>
</tr>
<tr>
<td>1005</td>
<td>2</td>
<td>2025-02-05</td>
<td>90.25</td>
<td>Pending</td>
</tr>
<tr>
<td>1006</td>
<td>2</td>
<td>2025-02-06</td>
<td>110.00</td>
<td>Shipped</td>
</tr>
<tr>
<td>1007</td>
<td>3</td>
<td>2025-02-07</td>
<td>100.00</td>
<td>Completed</td>
</tr>
<tr>
<td>1008</td>
<td>3</td>
<td>2025-02-08</td>
<td>200.00</td>
<td>Pending</td>
</tr>
<tr>
<td>1009</td>
<td>3</td>
<td>2025-02-09</td>
<td>130.75</td>
<td>Shipped</td>
</tr>
<tr>
<td>1010</td>
<td>3</td>
<td>2025-02-10</td>
<td>160.00</td>
<td>Completed</td>
</tr>
</tbody></table>
<p>使用如下sql：对userID进行分组，就可以分成三组数据了，在对每个分组使用聚合函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, <span class="built_in">count</span>(OrderID), <span class="built_in">sum</span>(OrderAmount), <span class="built_in">avg</span>(OrderAmount), <span class="built_in">min</span>(OrderAmount), <span class="built_in">max</span>(OrderAmount)</span><br><span class="line"><span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> UserID</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<table>
<thead>
<tr>
<th>UserID</th>
<th>count(OrderID)</th>
<th>sum(OrderAmount)</th>
<th>avg(OrderAmount)</th>
<th>min(OrderAmount)</th>
<th>max(OrderAmount)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>3</td>
<td>435.00</td>
<td>145.00</td>
<td>85.00</td>
<td>230.00</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>350.25</td>
<td>116.75</td>
<td>90.25</td>
<td>150.00</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>590.75</td>
<td>147.68</td>
<td>100.00</td>
<td>200.00</td>
</tr>
</tbody></table>
<h5 id="having"><a href="#having" class="headerlink" title="having"></a>having</h5><p><code>having</code>语句用来过滤<code>group by</code>分组以后的数据。</p>
<p>简单点说，就是相当于where条件，只不过<code>where条件</code>的执行顺序在<code>group by</code>之前，having条件的执行顺序在group by之后。</p>
<p>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> col_name [<span class="keyword">having</span> col_name <span class="operator">=</span> 任何数]</span><br></pre></td></tr></table></figure>

<p>示例：还是上面group by的表，这次我们只需要总金额大于400的数据，从上面的结果来看，我们知道，只需要userId为1和3的数据。</p>
<p>但是注意，<code>where条件</code>是在<code>group by</code>之前执行，这个时候还没有总金额这个字段呢。所以，就需要使用<code>having</code>了。</p>
<p>使用的sql如下：可以看到，仅仅是在后面增加了<code>having sum(OrderAmount) &gt; 400</code>这一条。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, <span class="built_in">count</span>(OrderID), <span class="built_in">sum</span>(OrderAmount), <span class="built_in">avg</span>(OrderAmount), <span class="built_in">min</span>(OrderAmount), <span class="built_in">max</span>(OrderAmount)</span><br><span class="line"><span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> UserID <span class="keyword">having</span> <span class="built_in">sum</span>(OrderAmount) <span class="operator">&gt;</span> <span class="number">400</span></span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<table>
<thead>
<tr>
<th>UserID</th>
<th>count(OrderID)</th>
<th>sum(OrderAmount)</th>
<th>avg(OrderAmount)</th>
<th>min(OrderAmount)</th>
<th>max(OrderAmount)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>3</td>
<td>435.00</td>
<td>145.00</td>
<td>85.00</td>
<td>230.00</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>590.75</td>
<td>147.68</td>
<td>100.00</td>
<td>200.00</td>
</tr>
</tbody></table>
<h5 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h5><p>如果想对查询出来的结果集进行排序，可以使用<code>order by</code>语句。</p>
<p>语法如下：asc代表升序，即1，2，3这种排序，desc代表降序，即3，2，1这种。默认是asc。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> col_name [<span class="keyword">asc</span>｜<span class="keyword">desc</span>]</span><br></pre></td></tr></table></figure>

<p>order by排序作用在group by分组之后，这意味着可以使用分组之后的聚合函数的结果进行排序，同时也意味着可以影响group by之后的数据。</p>
<p>示例：对上面group by之后的数据按照总金额进行降序排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, <span class="built_in">count</span>(OrderID), <span class="built_in">sum</span>(OrderAmount), <span class="built_in">avg</span>(OrderAmount), <span class="built_in">min</span>(OrderAmount), <span class="built_in">max</span>(OrderAmount)</span><br><span class="line"><span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> UserID <span class="keyword">having</span> <span class="built_in">sum</span>(OrderAmount) <span class="operator">&gt;</span> <span class="number">400</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">sum</span>(OrderAmount) <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<table>
<thead>
<tr>
<th>UserID</th>
<th>count(OrderID)</th>
<th>sum(OrderAmount)</th>
<th>avg(OrderAmount)</th>
<th>min(OrderAmount)</th>
<th>max(OrderAmount)</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>4</td>
<td>590.75</td>
<td>147.68</td>
<td>100.00</td>
<td>200.00</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>435.00</td>
<td>145.00</td>
<td>85.00</td>
<td>230.00</td>
</tr>
</tbody></table>
<h5 id="group-和-order的差别"><a href="#group-和-order的差别" class="headerlink" title="group 和 order的差别"></a>group 和 order的差别</h5><table>
<thead>
<tr>
<th align="left">group</th>
<th align="left">order</th>
</tr>
</thead>
<tbody><tr>
<td align="left">分组行，但输出可能不是分组的排序</td>
<td align="left">排序产生的输出</td>
</tr>
<tr>
<td align="left">只能使用选择列或表达式列</td>
<td align="left">任意列都可以使用</td>
</tr>
<tr>
<td align="left">若与聚合函数一起使用列或表达式, 则必须使用group</td>
<td align="left">不一定需要</td>
</tr>
</tbody></table>
<h5 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h5><p>如果不想每次都查询数据表的全部数据，只想获取几条数据呢？比如分页功能，一页10条数据这种，就可以使用<code>limit</code>命令来实现。</p>
<p>语法如下：start代表开始的位置，end代表结束的位置。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> orders </span><br><span class="line">limit [<span class="keyword">start</span>, <span class="keyword">end</span>]</span><br></pre></td></tr></table></figure>

<p>比如表中有100条数据。获取1-10条数据就是<code>limit 1,10</code>，获取11-20条数据就是<code>limit 11,20</code>。</p>
<p>limit最好是配合order by使用。性能更佳，另外，如果只获取1条数据，也建议使用<code>limit 1</code>代表获取1条数据。</p>
<p>具体的原因在后面原理篇会讲到。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQL%E7%AF%87.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQL%E7%AF%87.html" class="post-title-link" itemprop="url">MySQL零基础教程基础篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-26 10:12:47" itemprop="dateCreated datePublished" datetime="2023-04-26T10:12:47+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-11 16:34:49" itemprop="dateModified" datetime="2025-02-11T16:34:49+08:00">2025-02-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMU15445/" itemprop="url" rel="index"><span itemprop="name">CMU15445</span></a>
                </span>
            </span>

          
            <span id="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQL%E7%AF%87.html" class="post-meta-item leancloud_visitors" data-flag-title="MySQL零基础教程基础篇" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQL%E7%AF%87.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQL%E7%AF%87.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL零基础教程基础篇"><a href="#MySQL零基础教程基础篇" class="headerlink" title="MySQL零基础教程基础篇"></a>MySQL零基础教程基础篇</h1><p>大家好，我是大头，98年，职高毕业，做过上市公司架构师，做过大厂资深开发，管理过10人团队，我是如何做到的呢？</p>
<p>这离不开持续学习的能力，而其中最重要的当然是数据库技术了！</p>
<p>对于所有开发来说，都离不开数据库，因为所有的数据都是要存储的。</p>
<p>关注我一起学习！可获得系统性的学习教程、转码经验、技术交流、大厂内推等～</p>
<p>文末有惊喜哦！</p>
<p>基础篇的内容大致如下图所示。</p>
<p><img src="https://thepatterraining.github.io/images/mysql/mysql1-1.png" alt="概念学习"></p>
<h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><p>介绍完概念以后，我们可以来看看SQL语句了。SQL语句通常由三类组成。</p>
<p>数据定义 DDL</p>
<ul>
<li>CREATE 创建数据库或数据库对象</li>
<li>ALTER 对数据库或数据库对象进行修改</li>
<li>DROP 删除数据库或数据库对象<br>数据操纵 DML</li>
<li>SELECT 从表或视图中检索数据</li>
<li>INSERT 将数据插入到表或视图中</li>
<li>UPDATE 修改表或视图中的数据</li>
<li>DELETE 从表或视图中删除数据<br>数据控制 DCL</li>
<li>GRANT 用于授予权限</li>
<li>REVOKE 用于收回权限</li>
</ul>
<h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p>DCL（Data Control Language）语句用于控制对数据库的访问权限，包括用户权限的授予和撤销。DCL语句主要涉及用户和角色的权限管理，确保数据库的安全性和数据的完整性。</p>
<ul>
<li>授予权限（GRANT）</li>
<li>撤销权限（REVOKE）</li>
<li>设置用户密码（SET PASSWORD）</li>
<li>查看用户权限（SHOW GRANTS）</li>
</ul>
<h4 id="GRANT"><a href="#GRANT" class="headerlink" title="GRANT"></a>GRANT</h4><ul>
<li>GRANT语句用于授予用户或角色特定的权限。</li>
<li>权限可以包括对表、视图、存储过程等的访问和操作权限。</li>
</ul>
<p>语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> privilege_type <span class="keyword">ON</span> object_name <span class="keyword">TO</span> user_or_role;</span><br></pre></td></tr></table></figure>

<p>示例：授予用户zhangsan对employees表的SELECT和INSERT权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> employees <span class="keyword">TO</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="REVOKE"><a href="#REVOKE" class="headerlink" title="REVOKE"></a>REVOKE</h4><ul>
<li>REVOKE语句用于撤销用户或角色的特定权限。</li>
<li>撤销的权限可以是之前授予的任何权限。</li>
</ul>
<p>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> privilege_type <span class="keyword">ON</span> object_name <span class="keyword">FROM</span> user_or_role;</span><br></pre></td></tr></table></figure>

<p>示例：撤销用户zhangsan对employees表的INSERT权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> employees <span class="keyword">FROM</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="SET-PASSWORD"><a href="#SET-PASSWORD" class="headerlink" title="SET PASSWORD"></a>SET PASSWORD</h4><ul>
<li>SET PASSWORD语句用于设置或更改用户的密码。</li>
</ul>
<p>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> <span class="keyword">user</span> <span class="operator">=</span> <span class="string">&#x27;new_password&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>示例：设置用户zhangsan的新密码为new_password。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;new_password&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="SHOW-GRANTS"><a href="#SHOW-GRANTS" class="headerlink" title="SHOW GRANTS"></a>SHOW GRANTS</h4><ul>
<li>SHOW GRANTS语句用于查看用户的权限。</li>
</ul>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p>示例如下：查看用户zhangsan的权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>DCL主要是对于权限的控制，希望大家可以自己创建一个数据库a，在创建一个用户a,授予a用户a数据库的权限。进行练习。</p>
<h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><p>DDL（Data Definition Language，数据定义语言）是SQL语言的一部分，用于定义和修改数据库的结构。DDL语句主要涉及数据库、表、索引、视图等的创建、修改和删除操作。这些语句直接影响数据库的结构，但不会直接操作数据本身。</p>
<h4 id="数据库模式定义"><a href="#数据库模式定义" class="headerlink" title="数据库模式定义"></a>数据库模式定义</h4><h5 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h5><p>使用 <code>CREATE DATABASE</code> 语句，<code>IF NOT EXISTS</code>代表没有这个数据库，才会进行创建。如果已经有了，则不会再创建了。</p>
<p><code>CHARACTER SET</code>是设置字符集，推荐设置为utf8mb4字符集，<code>COLLATE</code>则使用默认的就可以了。</p>
<p>这里说一下<code>utf8</code>和<code>utf8mb4</code>这两个字符集的区别。</p>
<ul>
<li>utf8字符集：在MySQL中实际上是一个有限的字符集，它只支持最多3字节的UTF-8字符。这意味着它不能存储所有可能的Unicode字符，特别是那些需要4字节表示的字符（如某些表情符号）。utf8字符集支持的Unicode范围是U+0000到U+FFFF，即基本多语言平面（BMP）。</li>
<li>utf8mb4字符集支持完整的UTF-8字符集，包括4字节的字符。这意味着它可以存储所有可能的Unicode字符，包括表情符号和一些罕见的字符。utf8mb4字符集支持的Unicode范围是U+0000到U+10FFFF，即整个Unicode范围。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> &#123;DATABASE&#125; [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] db_name</span><br><span class="line">[<span class="keyword">DEFAULT</span>] <span class="type">CHARACTER</span> <span class="keyword">SET</span>[<span class="operator">=</span>]charset_name</span><br><span class="line"><span class="operator">|</span> [<span class="keyword">DEFAULT</span>] <span class="keyword">COLLATE</span>[<span class="operator">=</span>]collation_name</span><br></pre></td></tr></table></figure>

<p>创建一个测试数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database test;</span><br></pre></td></tr></table></figure>

<h5 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h5><p>使用<code>show databases</code>命令可以查看所有的数据库。也包括一些MySQL自带的数据库。这些数据库存储了MySQL的元数据，具体的等到原理篇会讲到。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> &#123;DATABASES&#125;</span><br><span class="line">[<span class="keyword">LIKE</span> <span class="keyword">pattern</span> <span class="operator">|</span> <span class="keyword">WHERE</span> expr] </span><br></pre></td></tr></table></figure>

<h5 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h5><p>使用<code>use</code>指令➕数据库名称可以选择数据库，或者说进入数据库。只有先进入一个数据库，才能操作这个数据库里面的数据表等等。</p>
<p>除此之外，也可以在操作数据表的前面加上数据库名称，但是那样比较麻烦。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use db_name</span><br></pre></td></tr></table></figure>

<h5 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h5><p>使用<code>ALTER DATABASE</code>指令可以修改数据库。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE db_name</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> gb2312</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> gb2312_chinese_ci;</span><br></pre></td></tr></table></figure>

<h5 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h5><p>当这个数据库不再使用的时候，可以通过<code>DROP DATABSE</code>指令来删除掉这个数据库。</p>
<p><code>IF EXISTS</code>代表存在则删除，不存在就不会删除。和创建的时候那个指令正好相反。都是可选指令。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> &#123;DATABASE&#125; [IF <span class="keyword">EXISTS</span>] db_name;</span><br></pre></td></tr></table></figure>


<h4 id="表定义"><a href="#表定义" class="headerlink" title="表定义"></a>表定义</h4><p>数据表被定义为字段的集合<br>按 <code>行</code> 和<code>列</code>的格式存储<br>每一行代表一条记录<br>每一列代表记录中一个字段的取值</p>
<h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><p>使用<code>create table</code>指令可以创建数据表，后面跟的是表名称和字段。</p>
<p><code>temporary</code>表示临时表，临时表存放在内存中。</p>
<p>字段类型常用的如下：</p>
<ul>
<li>int类型，占11位，也可以设置为int(5)等，但是这个只影响展示，并不影响实际的存储。</li>
<li>varchar&#x2F;char类型，相当于字符串类型，varchar是可变长度的字符串，char是不可变长度的字符串。</li>
<li>text类型，很不推荐使用该类型，会导致查询速度变慢，尽量使用varchar代替。</li>
<li>timestamp时间戳类型，不推荐使用，因为该类型表示1970年到现在的秒数，最大只能到2038-01-19号，而现在已经2025年了。</li>
<li>datetime类型，推荐使用这个代替时间戳，直接存储时间类型，并且表里的updated_time字段可以使用<code>DEFAULT CURRENT_TIMESTAMP</code>作为默认值，还可以使用<code>ON UPDATE CURRENT_TIMESTAMP</code>来实现自动更新。</li>
<li>decimal类型,用来存储小数，使用定点小数来存储，可以防止精度丢失。请避免使用<code>float</code>和<code>double</code>来存储小数。</li>
<li>json类型，可以存储json字符串。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [temporary] <span class="keyword">table</span> [if <span class="keyword">not</span> <span class="keyword">exists</span>] tbl_name</span><br><span class="line">(</span><br><span class="line">    字段名<span class="number">1</span> 数据类型 [列完整性约束条件] [默认值]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h5><p>对于创建的表结构不满意，可以通过<code>ALTER TABLE</code>指令来修改表结构。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br></pre></td></tr></table></figure>

<p>下面介绍一些子句，配合alter table命令来执行。</p>
<ul>
<li>ADD [COLUMN] 子句：给表结构增加字段。</li>
<li>change [COLUMN] 子句：修改表结构的字段类型、字段名称等。<ul>
<li>CHANGE COLUMN name new_name VARCHAR(200);</li>
</ul>
</li>
<li>alter [column] 子句 修改或删除表中指定列的默认值。<ul>
<li>alter colum city set default ‘bj’</li>
</ul>
</li>
<li>modify [column] 子句 只修改指定列的数据类型，不会干涉它的列名<ul>
<li>modify column city char(50);</li>
</ul>
</li>
<li>drop [column] 子句 删除指定列<ul>
<li>drop column city;</li>
</ul>
</li>
<li>rename [to] 子句 修改表名<ul>
<li>rename table table_name to new_table_name</li>
</ul>
</li>
<li>add index index_name(column_name) 创建索引</li>
<li>drop index index_name</li>
</ul>
<h5 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h5><p>当一个表不再使用的时候，也可以使用<code>drop table</code>将它删除。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> [temporary] <span class="keyword">table</span> [if <span class="keyword">exists</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h5><p>可以通过<code>SHOW CREATE TABLE</code>来查看表结构。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename;</span><br></pre></td></tr></table></figure>

<h4 id="索引定义"><a href="#索引定义" class="headerlink" title="索引定义"></a>索引定义</h4><p>索引是提高数据文件访问效率的有效方法，比如MySQL中的B+树索引、hash索引、全文索引等。</p>
<p>缺点</p>
<ul>
<li>索引是以文件的形式存储的，如果有大量的索引，索引文件可能比数据文件更快达到最大的文件尺寸</li>
<li>索引在提高查询速度的同时，会降低更新表的速度</li>
</ul>
<h5 id="索引物理结构"><a href="#索引物理结构" class="headerlink" title="索引物理结构"></a>索引物理结构</h5><ul>
<li>b+树索引</li>
<li>hash索引</li>
<li>倒排索引</li>
</ul>
<h5 id="索引逻辑结构"><a href="#索引逻辑结构" class="headerlink" title="索引逻辑结构"></a>索引逻辑结构</h5><ul>
<li>index 或 key： 普通索引</li>
<li>unique ：唯一性索引 候选码</li>
<li>primary key： 主键</li>
</ul>
<h5 id="索引逻辑概念"><a href="#索引逻辑概念" class="headerlink" title="索引逻辑概念"></a>索引逻辑概念</h5><ul>
<li>聚簇索引：比如主键索引，也就是b树的叶子节点存储数据的索引。</li>
<li>联合索引：由多个字段共同组成的索引。</li>
<li>覆盖索引：查询的字段和索引的字段一致，从而避免了再次去主键索引获取数据。</li>
</ul>
<p>关于索引的具体讲解将放在原理篇讲解，这里以介绍DDL语句为主，有个概念就可以了。</p>
<h5 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h5><p>想要创建一个索引可以使用<code>create index</code>命令，<code>unique</code>表示创建唯一索引。</p>
<p><code>index_col_name</code>表示要将索引创建在哪个字段上面，也可以是多个字段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>] index index_name</span><br><span class="line"><span class="keyword">on</span> table_name(index_col_name)</span><br></pre></td></tr></table></figure>

<p>示例，在user表上的<code>email</code>字段上创建一个索引，索引名称是<code>email_idx</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index email_idx</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">user</span>(email);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>索引并不是越多越好，太多的索引会导致维护成本升高，尽量少且有用即可。尤其是后续增加索引的时候，如果数据表中数据过多，建立索引的过程会较慢，会对业务产生影响，这个时候需要慎重。</p>
</blockquote>
<h5 id="索引删除"><a href="#索引删除" class="headerlink" title="索引删除"></a>索引删除</h5><p>当索引不再使用的时候，可以删除索引，使用命令<code>drop index</code>可以删除索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> [<span class="keyword">unique</span>] index index_name</span><br><span class="line"><span class="keyword">on</span> table_name</span><br></pre></td></tr></table></figure>

<p>示例：删除刚才建立的<code>email_idx</code>索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index email_idx</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<h4 id="视图定义"><a href="#视图定义" class="headerlink" title="视图定义"></a>视图定义</h4><p>什么是视图</p>
<ul>
<li>视图是一个对象，他是数据库提供给用户的以多种角度观察数据库中数据的一种重要机制</li>
<li>视图不是数据库中真实的表，而是一张虚拟表，其自身并不存储数据</li>
</ul>
<p>视图的优点</p>
<ul>
<li>集中分散数据</li>
<li>简化查询语句</li>
<li>重用SQL语句</li>
<li>保护数据安全</li>
<li>共享所需数据</li>
<li>更改数据格式</li>
</ul>
<h5 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h5><p>想要创建视图，可以使用<code>create view</code>指令。</p>
<p><code>or replace</code> 防止报错，存在替换，不存在创建。<br><code>with check option</code> 增删改查的时候检查视图条件。<br><code>select_statement</code> 是一段select查询语句。视图的本质就是这一段select查询语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">view</span> view_name [(col_list)]</span><br><span class="line"><span class="keyword">as</span> select_statement</span><br><span class="line">[<span class="keyword">with</span> <span class="keyword">check</span> option]</span><br></pre></td></tr></table></figure>

<p>示例：创建一个<code>zhangsan</code>用户的登录记录的视图。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> zhangsan</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> login_log <span class="keyword">where</span> <span class="keyword">user</span> <span class="operator">=</span> ‘zhangsan’</span><br></pre></td></tr></table></figure>

<h5 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h5><p>想要修改视图，可以使用<code>alter view</code>指令。</p>
<p>修改视图其实就是修改这个查询语句。当然了，也可以修改其他的属性等。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> view_name [(col_list)]</span><br><span class="line"><span class="keyword">as</span> select_statement</span><br><span class="line">[<span class="keyword">with</span> <span class="keyword">check</span> option]</span><br></pre></td></tr></table></figure>

<h5 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h5><p>当视图不需要了，可以使用<code>drop view</code>指令删除视图。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [IF <span class="keyword">EXISTS</span>] view_name</span><br></pre></td></tr></table></figure>

<p>示例：删除刚才创建的视图zhangsan</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">view</span> zhangsan</span><br></pre></td></tr></table></figure>

<h5 id="查看视图定义"><a href="#查看视图定义" class="headerlink" title="查看视图定义"></a>查看视图定义</h5><p>和上面说的查看表的定义一样，也可以查看视图的定义。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> view_name</span><br></pre></td></tr></table></figure>

<h4 id="存储过程定义"><a href="#存储过程定义" class="headerlink" title="存储过程定义"></a>存储过程定义</h4><p><code>存储过程</code> 是一组为了完成某项特定功能的 <code>SQL语句集</code></p>
<ul>
<li>可增强SQL语言的功能和灵活性</li>
<li>良好的封装性</li>
<li>高性能</li>
<li>可减少网络流量</li>
<li>可作为一种安全机制来确保数据库的安全性和数据的完整性<br>其实质就是一段存储在数据库中的 <code>代码</code><br>它可以由声明式的sql语句和过程式sql语句组成</li>
</ul>
<h5 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h5><p><code>DELIMITER $$</code>是用户定义的MYSQL 结束符</p>
<p>参数：in|out|inout 参数名 参数类型</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> sp_name(参数)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">body <span class="operator">/</span><span class="operator">/</span>存储过程代码</span><br><span class="line"><span class="keyword">END</span> $$</span><br></pre></td></tr></table></figure>

<p>示例：查询员工表的名称、部门和薪资。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> get_employee_details(<span class="keyword">IN</span> emp_id <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> name, department, salary</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> id <span class="operator">=</span> emp_id;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h5 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h5><p>调用需要使用<code>call</code>指令来调用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> sp_name(参数)</span><br></pre></td></tr></table></figure>

<p>示例：调用刚才的存储过程。 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> get_employee_details(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h5 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h5><p>如果存储过程不再需要了，则可以通过<code>drop procedure</code>指令来删除它。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> sp_name</span><br></pre></td></tr></table></figure>

<p>示例：删除刚才的存储过程。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> get_employee_details;</span><br></pre></td></tr></table></figure>

<h4 id="存储函数定义"><a href="#存储函数定义" class="headerlink" title="存储函数定义"></a>存储函数定义</h4><p>存储函数由SQL语句和过程式语句组成。</p>
<h5 id="创建存储函数"><a href="#创建存储函数" class="headerlink" title="创建存储函数"></a>创建存储函数</h5><p>使用 <code>create function</code>指令可以创建一个存储函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> sp_name(参数)</span><br><span class="line">    <span class="keyword">returns</span> type</span><br><span class="line">    routine_body <span class="operator">/</span><span class="operator">/</span>主体</span><br></pre></td></tr></table></figure>

<p>示例：给定id号返回性别。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">use test; <span class="operator">/</span><span class="operator">/</span>进入数据库test</span><br><span class="line">delimiter $$ <span class="operator">/</span><span class="operator">/</span>声明结束符号</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> fn_search(cid <span class="type">int</span>) <span class="operator">/</span><span class="operator">/</span>创建函数fn <span class="keyword">search</span>，参数为cid，<span class="type">int</span>类型</span><br><span class="line">    <span class="keyword">returns</span> <span class="type">char</span>(<span class="number">20</span>) <span class="operator">/</span><span class="operator">/</span>声明返回值类型char20</span><br><span class="line">    <span class="keyword">deterministic</span></span><br><span class="line"><span class="keyword">begin</span> <span class="operator">/</span><span class="operator">/</span>开始</span><br><span class="line">    <span class="keyword">declare</span> sex <span class="type">char</span>(<span class="number">20</span>) <span class="operator">/</span><span class="operator">/</span>声明一个变量sex 类型char20</span><br><span class="line">    <span class="keyword">select</span> cust_sex <span class="keyword">into</span> sex <span class="keyword">from</span> customers <span class="keyword">where</span> id <span class="operator">=</span> cid; <span class="operator">/</span><span class="operator">/</span><span class="keyword">select</span>语句，把查询出来的cust_sex字段内容放入变量sex中</span><br><span class="line">    if sex <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="operator">/</span><span class="operator">/</span>if判断，如果sex变量是<span class="keyword">null</span>，则返回<span class="string">&#x27;没有该客户&#x27;</span></span><br><span class="line">        <span class="keyword">return</span>(<span class="keyword">select</span> <span class="string">&#x27;没有该客户&#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="operator">/</span><span class="operator">/</span>如果sex变量不是<span class="keyword">null</span></span><br><span class="line">        if sex <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">then</span> <span class="operator">/</span><span class="operator">/</span>则判断是F的话，返回<span class="string">&#x27;女&#x27;</span></span><br><span class="line">            <span class="keyword">return</span>(<span class="keyword">select</span> <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="operator">/</span><span class="operator">/</span> 不然的话就返回<span class="string">&#x27;男&#x27;</span></span><br><span class="line">            <span class="keyword">return</span>(<span class="keyword">select</span> <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        <span class="keyword">end</span> if;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span> $$</span><br></pre></td></tr></table></figure>

<h5 id="调用存储函数"><a href="#调用存储函数" class="headerlink" title="调用存储函数"></a>调用存储函数</h5><p>使用 select 调用存储函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sp_name(参数)；</span><br></pre></td></tr></table></figure>

<p>示例：调用刚才的存储函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> fn_search(<span class="number">1</span>)$$</span><br></pre></td></tr></table></figure>

<h5 id="删除存储函数"><a href="#删除存储函数" class="headerlink" title="删除存储函数"></a>删除存储函数</h5><p>当存储函数不再使用的时候，可以使用<code>drop function</code>将它删除。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">function</span> fun_name</span><br></pre></td></tr></table></figure>

<p>示例：删除刚才的存储函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">function</span> fn_search</span><br></pre></td></tr></table></figure>

<h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>以上就是整体的MySQL学习路线了。</p>
<p>关注我发送“MySQL知识图谱”领取完整的MySQL学习路线。</p>
<p>发送“电子书”即可领取价值上千的电子书资源。</p>
<p>部分电子书如图所示。</p>
<p><img src="https://thepatterraining.github.io/images/bottom1.png" alt="概念学习"></p>
<p><img src="https://thepatterraining.github.io/images/bottom2.png" alt="概念学习"></p>
<p><img src="https://thepatterraining.github.io/images/bottom3.png" alt="概念学习"></p>
<p><img src="https://thepatterraining.github.io/images/bottom4.png" alt="概念学习"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87.html" class="post-title-link" itemprop="url">MySQL零基础教程基础篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-26 10:12:47" itemprop="dateCreated datePublished" datetime="2023-04-26T10:12:47+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-05 10:06:54" itemprop="dateModified" datetime="2025-02-05T10:06:54+08:00">2025-02-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMU15445/" itemprop="url" rel="index"><span itemprop="name">CMU15445</span></a>
                </span>
            </span>

          
            <span id="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87.html" class="post-meta-item leancloud_visitors" data-flag-title="MySQL零基础教程基础篇" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL零基础教程基础篇"><a href="#MySQL零基础教程基础篇" class="headerlink" title="MySQL零基础教程基础篇"></a>MySQL零基础教程基础篇</h1><p>大家好，我是大头，98年，职高毕业，上市公司架构师，大厂资深开发，管理过10人团队，我是如何做到的呢？</p>
<p>这离不开持续学习的能力，而其中最重要的当然是数据库技术了！</p>
<p>对于所有开发来说，都离不开数据库，因为所有的数据都是要存储的。</p>
<p>关注我一起学习！文末有惊喜哦！</p>
<p>基础篇的内容大致如下图所示。</p>
<p><img src="/../images/mysql/mysql1-1.png" alt="概念学习"></p>
<h2 id="概念学习"><a href="#概念学习" class="headerlink" title="概念学习"></a>概念学习</h2><p>首先，我们应该知道什么是数据库？很多人都会搞混一个概念，那就是数据库和数据库管理系统。</p>
<p>数据库的英文是<code>DataBase</code>。它的概念是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">数据库是一个长期存储在计算机内的、有组织的、可共享的数据集合，它具有以下特点</span><br><span class="line">1. 数据的集合性</span><br><span class="line">2. 数据的共享性</span><br><span class="line">3. 数据的冗余度低</span><br><span class="line">4. 数据的独立性</span><br><span class="line">5. 数据的安全性</span><br><span class="line">6. 数据的完整性</span><br><span class="line">7. 数据的可维护性</span><br></pre></td></tr></table></figure>

<p>而数据库管理系统的英文是<code>DataBase Management System</code>。它的概念是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据库管理系统（Database Management System，简称DBMS）是用于创建、管理、维护和操作数据库的软件系统。它在用户和数据库之间提供了一个接口，使得用户能够方便地存储、检索、更新和管理数据。</span><br></pre></td></tr></table></figure>

<p>因此，我们要明白，<code>MySQL</code>是一个数据库管理系统，而不是一个数据库。</p>
<p>虽然我们老说<code>MySQL数据库</code>，但这个是因为大家已经习惯了，大家都明白MySQL是什么，因此省略了一些。</p>
<p><code>MySQL</code>是用来管理数据库的一个系统。</p>
<p>那么问题来了，<code>SQL</code>又是什么呢？</p>
<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>SQL（Structured Query Language，结构化查询语言）是一种用于管理和操作关系数据库的标准编程语言。它允许用户定义、查询、更新和管理数据库中的数据。SQL 是关系数据库管理系统（RDBMS）的核心语言，广泛应用于各种数据库系统。</p>
<p>这里又出现了一个新的概念，就是<code>关系数据库管理系统（RDBMS）</code>。</p>
<p>上面已经介绍了<code>数据库管理系统</code>。那什么是关系数据库管理系统呢？</p>
<h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3><p>这里就需要先说明一下什么是<code>关系数据库</code>。</p>
<p>关系数据库（Relational Database）<br>关系数据库是一种基于关系模型的数据库管理系统（DBMS），它使用表格（表）来组织和存储数据。每个表由行（记录）和列（字段）组成，每一行代表一个数据记录，每一列代表一个数据属性。关系数据库的核心概念是关系模型，它由数学家埃德加·弗兰克·科德（E.F. Codd）在1970年提出。</p>
<h4 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h4><p>Ted Codd在1969年设计了关系模型。发表了<a target="_blank" rel="noopener" href="https://dl.acm.org/doi/pdf/10.1145/362384.362685">A relational model of data for large shared data banks</a> </p>
<p>关系模型将物理层和逻辑层分离，当数据的内部表示发生变化时，甚至当外部表示的某些方面发生变化时，用户在终端和大多数应用程序上的活动应该不受影响。</p>
<p>关系模型提供了一种仅用数据的自然结构来描述数据的方法，因此，它为高级数据语言提供了一个基础，这种语言将一方面在程序之间产生最大的独立性，另一方面在机器表示和数据组织之间产生最大的独立性。另一个优点是，它为处理关系的可导出性、冗余性和一致性提供了坚实的基础。</p>
<p>仍然需要消除的三种主要数据依赖是：顺序依赖、索引依赖和访问路径依赖。</p>
<ul>
<li>顺序依赖：程序展示的顺序和文件内容的存储顺序并不一致，需要各自独立。</li>
<li>索引依赖：如果程序使用索引的时候，索引被删除那么程序将出错。</li>
<li>访问路径依赖：访问数据的时候依赖数据的物理结构。</li>
</ul>
<p><code>关系</code>指的是数学意义上的关系，对于给定集合S1,S2,S3…Sn，R是n个集合上的关系，如果它是n个元组的集合，每个元组的第一个元素来自S1,第二个来自S2，以此类推。我们称Sj是R上的第j个定义域。R的阶为n(degree n)，阶为1的时候称为一元关系，2的时候称为二元关系，阶为n称为n元关系。</p>
<p>关键原则：</p>
<ul>
<li>将数据存储在简单的数据结构(关系)中</li>
<li>物理存储留给DBMS实现</li>
<li>通过高级语言访问数据，DBMS确定最佳策略。</li>
</ul>
<p>结构采用关系。确保数据库内容满足完整性约束。程序通过接口来访问和修改数据库内容。</p>
<p>关系是无序的，n元关系就是n个列的表。一个元组是一行记录。</p>
<p>关系数据库就是基于<code>关系模型</code>的数据库。</p>
<p>其具体的体现形式就是我们通常说的<code>表</code>。</p>
<p>建表语句如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    department <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    salary <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>除此之外，还有一些<code>关系完整性约束</code>。以确保数据的准确性和一致性。常见的完整性约束包括：</p>
<ul>
<li>主键约束（Primary Key）：确保表中每一行的唯一性。</li>
<li>外键约束（Foreign Key）：确保表之间的关系完整性。</li>
<li>唯一约束（Unique）：确保某一列或一组列的值是唯一的。</li>
<li>非空约束（NOT NULL）：确保某一列的值不能为空。</li>
<li>检查约束（CHECK）：确保某一列的值满足特定条件。</li>
</ul>
<p>这里面主键约束是必须的。<code>外键约束</code>通常不使用，因为保证这些约束，会降低数据库的性能。因此外键约束通常由代码层实现。</p>
<p>唯一约束有的时候是可以使用的，来限制唯一性，同样也可以通过代码层实现。</p>
<p>非空约束也是推荐使用的，因为<code>NULL</code>在数据库里面处理起来也有一些麻烦，也会影响性能。</p>
<p>检查约束实际上也基本不使用。</p>
<p>支持SQL标准，实现了SQL标准，最低要求实现SQL92标准。</p>
<p>关系数据库支持事务（Transaction），事务是一组操作的集合，要么全部成功，要么全部失败。事务的四个基本特性（ACID）包括：</p>
<ul>
<li>原子性（Atomicity）：事务中的所有操作要么全部成功，要么全部失败。</li>
<li>一致性（Consistency）：事务执行前后，数据库的状态保持一致。</li>
<li>隔离性（Isolation）：并发事务之间相互隔离，不会相互干扰。</li>
<li>持久性（Durability）：事务一旦提交，其结果是永久性的，即使系统故障也不会丢失。</li>
</ul>
<h3 id="SQL标准"><a href="#SQL标准" class="headerlink" title="SQL标准"></a>SQL标准</h3><p>SQL标准是一系列由国际标准化组织（ISO）和美国国家标准协会（ANSI）制定的规范，旨在确保SQL语言的统一性和兼容性。这些标准定义了SQL语言的语法、语义和行为，使得不同的数据库管理系统（DBMS）能够以一致的方式实现和使用SQL。</p>
<p>主要的SQL标准：</p>
<ol>
<li>SQL-86（1986年）：</li>
</ol>
<ul>
<li>第一个SQL标准，奠定了SQL语言的基础。</li>
<li>定义了基本的SQL语法和功能，包括数据定义语言（DDL）和数据操纵语言（DML）。</li>
</ul>
<ol start="2">
<li>SQL-89（1989年）：</li>
</ol>
<ul>
<li>对SQL-86的修订和扩展，增加了对嵌套查询和子查询的支持。</li>
<li>也称为SQL1，是第一个广泛接受的SQL标准。</li>
</ul>
<ol start="3">
<li>SQL-92（1992年）：</li>
</ol>
<ul>
<li>也称为SQL2，是SQL标准的重大更新。</li>
<li>引入了大量新功能，包括：<ul>
<li>外键约束（Foreign Key Constraints）</li>
<li>多表连接（JOIN）</li>
<li>嵌套查询（Subqueries）</li>
<li>集合操作（Set Operations）</li>
<li>视图（Views）</li>
<li>完整性约束（Integrity Constraints）</li>
</ul>
</li>
<li>SQL-92 是目前大多数数据库系统支持的基础标准。</li>
</ul>
<ol start="4">
<li>SQL:1999（1999年）：</li>
</ol>
<ul>
<li>引入了对大型对象（LOBs）、窗口函数（Window Functions）、递归查询（Recursive Queries）等的支持。</li>
<li>也称为SQL3，是SQL标准的进一步扩展。</li>
</ul>
<ol start="5">
<li>SQL:2003（2003年）：</li>
</ol>
<ul>
<li>引入了对XML数据类型和操作的支持。</li>
<li>增加了对存储过程、触发器、用户定义类型（UDTs）等的支持。</li>
</ul>
<ol start="6">
<li>SQL:2006（2006年）：</li>
</ol>
<ul>
<li>主要关注XML数据的处理和查询。</li>
<li>引入了对XQuery的支持。</li>
</ul>
<ol start="7">
<li>SQL:2008（2008年）：</li>
</ol>
<ul>
<li>引入了对时间数据类型和操作的支持。</li>
<li>增加了对分区表、数据加密等的支持。</li>
</ul>
<ol start="8">
<li>SQL:2011（2011年）：</li>
</ol>
<ul>
<li>引入了对多版本并发控制（MVCC）的支持。</li>
<li>增加了对分区表的进一步扩展。</li>
</ul>
<ol start="9">
<li>SQL:2016（2016年）：</li>
</ol>
<ul>
<li>引入了对JSON数据类型和操作的支持。</li>
<li>增加了对窗口函数的进一步扩展。</li>
</ul>
<ol start="10">
<li>SQL:2019（2019年）：</li>
</ol>
<ul>
<li>引入了对机器学习和数据分析的支持。</li>
<li>增加了对时间序列数据、地理空间数据等的支持。</li>
</ul>
<p>尽管SQL标准提供了统一的规范，但不同的数据库系统在实现上存在差异。主要的数据库系统（如MySQL、PostgreSQL、Oracle、SQL Server等）都支持SQL标准的核心功能，但在某些高级功能和扩展上可能有所不同。例如：</p>
<ul>
<li>MySQL：支持SQL:2003标准，但在某些高级功能（如窗口函数）上支持较晚。</li>
<li>PostgreSQL：支持SQL:2011标准，对SQL标准的兼容性较好。</li>
<li>Oracle：支持SQL:2011标准，但在某些功能上有自己的扩展。</li>
<li>SQL Server：支持SQL:2008标准，但在某些功能上有自己的扩展。</li>
</ul>
<p>SQL标准是一系列由ISO和ANSI制定的规范，旨在确保SQL语言的统一性和兼容性。不同的数据库系统在实现上存在差异，但都支持SQL标准的核心功能。了解数据库系统对SQL标准的支持情况，可以帮助开发者更好地编写跨数据库的SQL代码，提高代码的可移植性和兼容性。</p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><ul>
<li>关系模型：大多数数据库使用的</li>
<li>键值对模型：NOSql使用的，比如redis</li>
<li>图模型：NOSql使用的</li>
<li>文档模型：NOSql使用的，比如mongoDB</li>
<li>列存储模型</li>
<li>数组，向量模型：向量数据库，如Fassi</li>
<li>分组模型，网络模型，多值模型：已经很少使用的模型</li>
</ul>
<h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>设R为任一给定关系，如果对于R中属性X的每一个值，R中的属性Y只有唯一值与之对应，则称X函数决定Y或称Y函数依赖于X，记作X-&gt;Y.其中X称为<code>决定因素</code></p>
<p>分类：</p>
<ul>
<li>完全函数依赖</li>
<li>部分函数依赖</li>
<li>传递函数依赖</li>
</ul>
<p> 完全函数依赖：<br> 设R为任一给定关系，X,Y为其属性集，若X-&gt;Y，且对X中的任何真子集X’，都有X’不依赖Y,则称Y完全函数依赖于X</p>
<p> 部分函数依赖：<br> 设R为任一给定关系，X,Y为其属性集，若X-&gt;Y,且X中存在一个真子集X’,都有X’-&gt;Y，则称Y部分依赖于X</p>
<p> 传递函数依赖：<br> 设R为任一给定关系，X,Y,Z为其不同属性子集，若X-&gt;Y,Y不决定X,Y-&gt;Z,则有X-&gt;Z，称为Z传递函数依赖于X。</p>
<h3 id="设计范式"><a href="#设计范式" class="headerlink" title="设计范式"></a>设计范式</h3><p>一个低一级范式的关系模式通过<code>模式分解</code>可以转换为若干个高一级范式的关系模式的集合，这种过程就叫<code>规范化</code></p>
<p>第一范式1NF:<br>设R为任一给定关系，如果R中每个列与行的交点处的取值都是不可再分的基本元素，则R为第一范式</p>
<p>第二范式2NF:<br>设R为任一给定关系，若R为1NF<br>且其所有非主属性都完全函数依赖于候选关键字，则R为第二范式。</p>
<p>候选关键字：能唯一表示一行数据的就是候选关键字，比如主键，比如唯一索引等。</p>
<p>第三范式3NF:<br>设R为任一给定关系，若R为2NF<br>且其每一个非主属性都不传递函数依赖于候选关键字，则R为第三范式。</p>
<p>第三范式的改进形式BCNF:<br>设R为任意给定关系，X,Y为其属性集，F为其函数依赖集，若R为3NF<br>且其F中所有函数依赖X-&gt;Y(Y不属于X)中的X比包含候选关键字，则R为BCNF</p>
<p>有部分函数依赖就是1NF，没有就是2NF，没有传递函数依赖就是3NF</p>
<p>1NF-&gt;2NF<br>找到候选关键字，看其余的属性是否完全函数依赖候选关键字<br>是的，与候选关键字一同抄下来形成一个表格<br>不是的，抄下来，形成第二个表格，并且将候选关键字里能够唯一决定表格2的属性组抄在第一列</p>
<p>2NF-&gt;3NF<br>找到表格中的传递函数依赖关系的三个属性组，设为X,Y,Z<br>将这三个属性组拆成两个表格<br>第一个表格为X,Y<br>第二个表格为Y,Z</p>
<p>3NF-&gt;BCNF<br>列出表格中的所有函数依赖关系<br>每个关系拆出一个表格</p>
<h3 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h3><p>ER图是一种图形化的表示方法，用于描述数据库中的实体、实体之间的关系以及实体的属性。它是一种强大的工具，广泛应用于数据库设计和概念建模阶段，帮助开发者和分析师理解数据结构和数据之间的关系。</p>
<p>ER图的主要组成部分</p>
<ul>
<li>实体（Entity）：<ul>
<li>实体是数据库中具有相同属性集合的对象。例如，学生、课程、教师等。</li>
<li>在ER图中，实体通常用矩形表示，矩形内写上实体的名称。</li>
</ul>
</li>
<li>属性（Attribute）：<ul>
<li>属性是实体的特征或性质。例如，学生的属性可以包括学号、姓名、年龄等。</li>
<li>在ER图中，属性通常用椭圆表示，椭圆内写上属性的名称，并用线连接到对应的实体。</li>
</ul>
</li>
</ul>
<p>下图就是一个<code>ER图</code>，<code>实体</code>是<code>管理员用户</code>。<code>属性</code>有头像、密码、登录名、ID、邮箱、手机号。</p>
<p><img src="/../images/mysql/mysql3-1.png" alt="概念学习"></p>
<ul>
<li>关系（Relationship）：<ul>
<li>关系描述了实体之间的联系。例如，学生和课程之间的关系可以是选修。</li>
<li>在ER图中，关系通常用菱形表示，菱形内写上关系的名称，并用线连接到相关的实体。</li>
</ul>
</li>
<li>关系的类型：<ul>
<li>一对一关系（1:1）：一个实体与另一个实体之间存在一对一的联系。例如，一个学生对应一个学号。</li>
<li>一对多关系（1:N）：一个实体与多个实体之间存在联系。例如，一个教师可以教授多个课程。</li>
<li>多对多关系（M:N）：多个实体与多个实体之间存在联系。例如，一个学生可以选修多个课程，一个课程也可以被多个学生选修。</li>
</ul>
</li>
</ul>
<p>下图就是一个ER图，<code>实体</code>是管理员用户和角色两个。<code>关系</code>是<code>拥有</code>，表示管理员用户拥有角色的关系。关系的类型用<code>m和n</code>表示<code>多对多关系</code>。意思是一个管理员用户可以拥有多个角色，一个角色也可以被多个管理员用户拥有。</p>
<p><img src="/../images/mysql/mysql3-2.png" alt="概念学习"></p>
<p>画ER图可以使用<a target="_blank" rel="noopener" href="https://www.processon.com/i/637308dd762131535d6884f7?full_name=osgpjw20iEaJn-L">processOn</a></p>
<h3 id="OLTP"><a href="#OLTP" class="headerlink" title="OLTP"></a>OLTP</h3><p>OLTP（Online Transaction Processing，联机事务处理）数据库是一种用于支持日常事务处理和业务操作的数据库系统。它旨在快速处理大量的在线事务，确保数据的完整性和一致性。OLTP数据库广泛应用于各种需要实时数据处理的场景，如银行系统、电子商务平台、企业资源规划（ERP）系统等。</p>
<p>OLTP数据库</p>
<ul>
<li>通常是业务侧使用的传统数据库，比如oracle,postgresql,mysql</li>
<li>小的业务多次执行，比如多个简单的插入，更新，查询</li>
</ul>
<h4 id="OLTP数据库的主要特点"><a href="#OLTP数据库的主要特点" class="headerlink" title="OLTP数据库的主要特点"></a>OLTP数据库的主要特点</h4><p>事务性：</p>
<ul>
<li>OLTP数据库的核心是事务处理。事务是一组操作的集合，要么全部成功，要么全部失败。OLTP系统支持ACID（原子性、一致性、隔离性、持久性）特性，确保事务的可靠性。</li>
<li>原子性（Atomicity）：事务中的所有操作要么全部成功，要么全部失败。</li>
<li>一致性（Consistency）：事务执行前后，数据库的状态保持一致。</li>
<li>隔离性（Isolation）：并发事务之间相互隔离，不会相互干扰。</li>
<li>持久性（Durability）：事务一旦提交，其结果是永久性的，即使系统故障也不会丢失。</li>
</ul>
<p>高性能：</p>
<ul>
<li>OLTP数据库设计用于快速处理大量的在线事务。它们通常具有高效的索引、优化的查询计划和低延迟的响应时间。</li>
<li>例如，银行系统需要在几毫秒内完成交易，OLTP数据库能够满足这种高性能要求。</li>
</ul>
<p>数据完整性：</p>
<ul>
<li>OLTP数据库通过各种完整性约束（如主键、外键、唯一约束、非空约束等）确保数据的准确性和一致性。</li>
<li>例如，一个订单表中的订单号必须是唯一的，客户表中的客户ID必须存在。</li>
</ul>
<p>并发处理：</p>
<ul>
<li>OLTP数据库支持高并发访问，允许多个用户同时进行事务操作。它们通过锁机制和事务隔离级别来管理并发事务，确保数据的一致性和完整性。</li>
<li>例如，多个用户可以同时在电子商务平台上下单，OLTP数据库能够处理这些并发请求。</li>
</ul>
<p>实时性：</p>
<ul>
<li>OLTP数据库提供实时数据处理，用户可以即时看到事务的结果。这使得OLTP系统适用于需要即时反馈的业务场景，如在线支付、库存管理等。</li>
<li>例如，用户在电子商务平台上下单后，系统立即更新库存信息并生成订单。</li>
</ul>
<h4 id="OLTP数据库的常见应用场景"><a href="#OLTP数据库的常见应用场景" class="headerlink" title="OLTP数据库的常见应用场景"></a>OLTP数据库的常见应用场景</h4><p>银行系统：</p>
<ul>
<li>用于处理日常的银行交易，如存款、取款、转账等。这些交易需要快速、准确地完成，确保数据的一致性和完整性。<br>电子商务平台：</li>
<li>用于处理用户的订单、支付、库存管理等。这些系统需要支持高并发访问，确保用户能够实时看到订单状态和库存信息。<br>企业资源规划（ERP）系统：</li>
<li>用于管理企业的各种资源，如人力资源、财务资源、生产资源等。这些系统需要处理大量的事务，确保数据的准确性和一致性。<br>客户关系管理（CRM）系统：</li>
<li>用于管理客户信息、销售机会、客户服务等。这些系统需要支持实时数据处理，确保客户信息的准确性和及时性。</li>
</ul>
<p>OLTP数据库是一种用于支持日常事务处理和业务操作的数据库系统。它具有事务性、高性能、数据完整性、并发处理和实时性等特点，广泛应用于银行系统、电子商务平台、企业资源规划（ERP）系统等。常见的OLTP数据库管理系统包括MySQL、PostgreSQL、Oracle Database、Microsoft SQL Server和SQLite。</p>
<h3 id="OLAP"><a href="#OLAP" class="headerlink" title="OLAP"></a>OLAP</h3><p>OLAP（Online Analytical Processing，联机分析处理）数据库是一种用于支持复杂的数据分析和报告的数据库系统。它旨在快速处理大量的数据，提供多维度的数据分析能力，帮助用户从不同角度理解数据。OLAP数据库广泛应用于数据仓库、商业智能（BI）和决策支持系统。</p>
<p>OLAP数据库</p>
<ul>
<li>通常是大数据，数据分析来使用，比如Hbase等，支持复杂的数据查询</li>
<li>OLAP位于OLTP的后方</li>
</ul>
<h4 id="OLAP数据库的主要特点"><a href="#OLAP数据库的主要特点" class="headerlink" title="OLAP数据库的主要特点"></a>OLAP数据库的主要特点</h4><p>多维数据分析：</p>
<ul>
<li>OLAP数据库支持多维数据分析，允许用户从不同角度（如时间、地区、产品等）查看数据。这种多维视图有助于用户发现数据中的模式和趋势。</li>
<li>例如，用户可以按季度、地区和产品类别分析销售数据。</li>
</ul>
<p>高性能查询：</p>
<ul>
<li>OLAP数据库优化了对大量数据的读取操作，能够快速响应复杂的查询请求。它们通常使用预计算的聚合数据和索引技术来提高查询性能。</li>
<li>例如，数据仓库中的销售数据可以按季度、地区和产品类别预计算，以便快速生成报告。</li>
</ul>
<p>数据聚合：</p>
<ul>
<li>OLAP数据库支持数据的聚合操作，如求和、平均、最大值、最小值等。这些聚合操作通常在数据加载时预先计算，以便快速生成报告。</li>
<li>例如，销售数据可以按季度、地区和产品类别进行汇总，以便快速生成销售报告。</li>
</ul>
<p>数据立方体（Data Cube）：</p>
<ul>
<li>OLAP数据库使用数据立方体（Data Cube）来组织数据。数据立方体是一个多维数据结构，允许用户从不同维度查看数据。</li>
<li>例如，一个销售数据立方体可以包含时间维度（年、季度、月）、地区维度（国家、城市）和产品维度（类别、品牌）。</li>
</ul>
<p>数据更新：</p>
<ul>
<li>OLAP数据库通常不需要实时更新，数据通常在定期的时间间隔内批量加载。这使得OLAP数据库能够优化读取操作，提高查询性能。</li>
<li>例如，销售数据可以在每天晚上批量加载到数据仓库中。</li>
</ul>
<h4 id="OLAP数据库的常见应用场景"><a href="#OLAP数据库的常见应用场景" class="headerlink" title="OLAP数据库的常见应用场景"></a>OLAP数据库的常见应用场景</h4><p>数据仓库：</p>
<ul>
<li>用于存储和管理企业的历史数据，支持复杂的查询和报告。数据仓库通常从多个数据源（如事务处理系统）提取数据，进行清洗和转换，然后加载到数据仓库中。</li>
<li>例如，企业可以使用数据仓库来分析销售趋势、客户行为等。</li>
</ul>
<p>商业智能（BI）：</p>
<ul>
<li>用于支持企业的决策支持系统，提供数据驱动的决策支持。商业智能工具通常与OLAP数据库集成，提供交互式的报告和分析功能。</li>
<li>例如，企业可以使用商业智能工具生成销售报告、市场分析报告等。</li>
</ul>
<p>决策支持系统（DSS）：</p>
<ul>
<li>用于支持企业的决策过程，提供数据驱动的决策支持。决策支持系统通常使用OLAP数据库来存储和分析数据。</li>
<li>例如，企业可以使用决策支持系统来优化生产计划、资源分配等。</li>
</ul>
<p>OLAP数据库是一种用于支持复杂的数据分析和报告的数据库系统。它具有多维数据分析、高性能查询、数据聚合、数据立方体和数据更新等特点，广泛应用于数据仓库、商业智能（BI）和决策支持系统。常见的OLAP数据库管理系统包括HBase,ClickHouse等。</p>
<h3 id="高级概念"><a href="#高级概念" class="headerlink" title="高级概念"></a>高级概念</h3><p>接下来在介绍一下MySQL中会用到的高级概念，这些能更好的帮助大家理解除了正常的表以外的其他东西。</p>
<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>在MySQL中，<strong>视图（View）</strong>是一种虚拟表，其内容由SQL查询定义。视图并不存储实际的数据，而是根据定义的查询动态生成数据。视图可以简化复杂的SQL操作，提供数据的逻辑抽象，并且可以限制对某些数据的访问，从而增强数据的安全性。</p>
<p>MySQL中的视图是虚拟视图，说白了就是一条SQL语句，当查询视图的时候执行SQL语句而已。</p>
<p>除此之外，还有一个东西叫做<code>物化视图</code>，MySQL并没有实现这个东西，物化视图就是一张真的表，而不是一个SQL语句，因此查询效率更好。</p>
<h5 id="视图的主要特点"><a href="#视图的主要特点" class="headerlink" title="视图的主要特点"></a>视图的主要特点</h5><p>虚拟表：</p>
<ul>
<li>视图是一个虚拟表，其内容由SQL查询定义。视图本身并不存储数据，而是根据定义的查询动态生成数据。</li>
</ul>
<p>简化复杂查询：</p>
<ul>
<li>视图可以简化复杂的SQL操作，将复杂的查询逻辑封装起来，使用户可以像查询普通表一样查询视图。</li>
</ul>
<p>数据抽象：</p>
<ul>
<li>视图提供数据的逻辑抽象，隐藏了底层表的复杂性，使用户可以更直观地访问数据。</li>
</ul>
<p>安全性：</p>
<ul>
<li>视图可以限制对某些数据的访问，增强数据的安全性。通过视图，用户只能访问视图定义的特定数据，而不能访问底层表的全部数据。</li>
</ul>
<p>更新限制：</p>
<ul>
<li>视图可以是可更新的，也可以是不可更新的。可更新视图允许用户通过视图插入、更新或删除数据，但需要满足一定的条件。不可更新视图则不允许用户通过视图修改数据。</li>
</ul>
<p>创建一个视图。下面的语句，创建一个视图，视图名称是<code>sales_employees</code>，内容就是后面的Select语句的结果。当原始表<code>employees</code>变化以后，视图的内容也会跟着变化。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> sales_employees <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;Sales&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><p>在MySQL中，<strong>触发器（Trigger）</strong>是一种特殊的存储过程，它在特定的数据库操作（如INSERT、UPDATE、DELETE）发生时自动执行。触发器可以用于实现复杂的业务逻辑，确保数据的完整性和一致性，以及自动维护数据的同步。</p>
<h5 id="触发器的主要特点"><a href="#触发器的主要特点" class="headerlink" title="触发器的主要特点"></a>触发器的主要特点</h5><p>自动执行：</p>
<ul>
<li>触发器在特定的数据库操作发生时自动执行，无需显式调用。这使得触发器可以用于实现自动化的数据处理和维护。</li>
</ul>
<p>数据完整性：</p>
<ul>
<li>触发器可以用于确保数据的完整性和一致性。例如，可以在插入或更新数据时自动检查数据的有效性，或者在删除数据时自动清理相关数据。</li>
</ul>
<p>业务逻辑：</p>
<ul>
<li>触发器可以用于实现复杂的业务逻辑。例如，可以在插入或更新数据时自动计算某些字段的值，或者在删除数据时自动更新相关表的数据。</li>
</ul>
<p>数据同步：</p>
<ul>
<li>触发器可以用于自动维护数据的同步。例如，可以在插入或更新数据时自动更新相关表的数据，或者在删除数据时自动清理相关表的数据。</li>
</ul>
<h5 id="触发器的类型"><a href="#触发器的类型" class="headerlink" title="触发器的类型"></a>触发器的类型</h5><ul>
<li>BEFORE INSERT：<ul>
<li>在插入数据之前执行触发器逻辑。</li>
</ul>
</li>
<li>AFTER INSERT：<ul>
<li>在插入数据之后执行触发器逻辑。</li>
</ul>
</li>
<li>BEFORE UPDATE：<ul>
<li>在更新数据之前执行触发器逻辑。</li>
</ul>
</li>
<li>AFTER UPDATE：<ul>
<li>在更新数据之后执行触发器逻辑。</li>
</ul>
</li>
<li>BEFORE DELETE：<ul>
<li>在删除数据之前执行触发器逻辑。</li>
</ul>
</li>
<li>AFTER DELETE：<ul>
<li>在删除数据之后执行触发器逻辑。</li>
</ul>
</li>
</ul>
<h5 id="触发器的限制"><a href="#触发器的限制" class="headerlink" title="触发器的限制"></a>触发器的限制</h5><p>性能影响：</p>
<ul>
<li>触发器的执行会增加数据库操作的开销，可能会影响性能。因此，应谨慎使用触发器，避免在高频操作的表上定义过多的触发器。<br>复杂性：</li>
<li>触发器的逻辑可以非常复杂，但过多的复杂逻辑可能导致触发器难以维护和调试。因此，应尽量保持触发器的逻辑简单明了。<br>调试困难：</li>
<li>触发器的调试相对困难，因为它们在特定的操作发生时自动执行，难以直接观察和调试。因此，建议在开发和测试阶段充分测试触发器的逻辑。</li>
</ul>
<p>因此，实际开发中基本不使用触发器。</p>
<h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><p>在MySQL中，<strong>存储过程（Stored Procedure）</strong>是一种预编译的SQL语句集合，它存储在数据库中，可以通过调用其名称并传递参数来执行。存储过程可以包含复杂的逻辑和多个SQL语句，用于完成特定的任务。它们类似于其他编程语言中的函数或方法。</p>
<p>可以把存储过程想成一个函数。只不过是在MySQL中的函数，这个函数可以实现各种功能。可以实现一些复杂的SQL处理，这样可以简化调用。</p>
<h5 id="存储过程的主要特点"><a href="#存储过程的主要特点" class="headerlink" title="存储过程的主要特点"></a>存储过程的主要特点</h5><p>预编译：</p>
<ul>
<li>存储过程在创建时被预编译并存储在数据库中，这使得它们的执行速度比单独的SQL语句更快。<br>代码重用：</li>
<li>存储过程可以被多次调用，减少了代码重复，提高了开发效率。<br>减少网络流量：</li>
<li>存储过程在服务器端执行，减少了客户端和服务器之间的网络流量，因为只需要发送存储过程的名称和参数，而不是大量的SQL语句。<br>安全性：</li>
<li>存储过程可以限制用户对底层数据的直接访问，只允许通过存储过程进行数据操作，从而增强数据的安全性。<br>事务管理：</li>
<li>存储过程可以包含事务控制语句，如COMMIT和ROLLBACK，确保数据操作的完整性和一致性。</li>
</ul>
<p>创建一个存储过程get_employee_details，用于根据员工ID获取员工的详细信息：</p>
<p>DELIMITER用来设置结束符，比如正常的句子结束符是句号。代码结束符是分号；</p>
<p>IN代表输入参数，也就是这个函数有一个输入参数emp_id，是int类型。<br>还有out代表输出参数，用于返回结果。<br>INOUT代表既可以输入参数也可以是输出参数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> get_employee_details(<span class="keyword">IN</span> emp_id <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> name, department, salary</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> id <span class="operator">=</span> emp_id;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>上面这个存储过程的函数体，就是一段select查询语句。</p>
<h5 id="存储过程的限制"><a href="#存储过程的限制" class="headerlink" title="存储过程的限制"></a>存储过程的限制</h5><p>性能影响：</p>
<ul>
<li>存储过程的执行会增加数据库操作的开销，可能会影响性能。因此，应谨慎使用存储过程，避免在高频操作的表上定义过多的存储过程。<br>复杂性：</li>
<li>存储过程的逻辑可以非常复杂，但过多的复杂逻辑可能导致存储过程难以维护和调试。因此，应尽量保持存储过程的逻辑简单明了。<br>调试困难：</li>
<li>存储过程的调试相对困难，因为它们在服务器端执行，难以直接观察和调试。因此，建议在开发和测试阶段充分测试存储过程的逻辑。</li>
</ul>
<h4 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h4><p>在MySQL中，<strong>存储函数（Stored Function）</strong>是一种预编译的SQL语句集合，类似于存储过程，但它返回一个值。存储函数可以被SQL语句直接调用，就像调用普通的函数一样。存储函数通常用于封装复杂的逻辑，并在查询中重用这些逻辑。</p>
<p>存储函数同样是一个函数，和上面的存储过程差不多。</p>
<h5 id="存储过程和存储函数的区别"><a href="#存储过程和存储函数的区别" class="headerlink" title="存储过程和存储函数的区别"></a>存储过程和存储函数的区别</h5><p>返回值的区别</p>
<ul>
<li>存储过程<ul>
<li>存储过程可以返回多个值，这些值通过OUT或INOUT参数返回。</li>
<li>存储过程可以执行多个SQL语句，但不直接返回一个单一的值。</li>
</ul>
</li>
<li>存储函数<ul>
<li>存储函数必须返回一个单一的值。</li>
<li>存储函数可以被SQL语句直接调用，就像调用普通的函数一样。</li>
</ul>
</li>
</ul>
<p>调用方式的区别</p>
<ul>
<li>存储过程<ul>
<li>存储过程通过CALL语句调用。</li>
<li>存储过程可以执行复杂的逻辑，包括多个SQL语句和事务控制。</li>
</ul>
</li>
<li>存储函数<ul>
<li>存储函数可以直接在SQL语句中调用，就像调用普通的函数一样。</li>
<li>存储函数通常用于封装复杂的逻辑，并在查询中重用这些逻辑。</li>
</ul>
</li>
</ul>
<h5 id="存储函数的主要特点"><a href="#存储函数的主要特点" class="headerlink" title="存储函数的主要特点"></a>存储函数的主要特点</h5><p>返回值：</p>
<ul>
<li>存储函数必须返回一个值，这使得它们可以被SQL语句直接调用。<br>代码重用：</li>
<li>存储函数可以被多次调用，减少了代码重复，提高了开发效率。<br>减少网络流量：</li>
<li>存储函数在服务器端执行，减少了客户端和服务器之间的网络流量，因为只需要发送函数的名称和参数，而不是大量的SQL语句。<br>安全性：</li>
<li>存储函数可以限制用户对底层数据的直接访问，只允许通过函数进行数据操作，从而增强数据的安全性。<br>事务管理：</li>
<li>存储函数可以包含事务控制语句，如COMMIT和ROLLBACK，确保数据操作的完整性和一致性。</li>
</ul>
<p>创建一个存储函数get_employee_salary，用于根据员工ID获取员工的薪资：</p>
<p>可以看到和上面存储过程的区别，声明了一个返回值，类型是DECIMAL,最后通过return返回了，并且声明了一个变量。参数也没有IN、OUT这种了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> get_employee_salary(emp_id <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> emp_salary <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> emp_salary</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> id <span class="operator">=</span> emp_id;</span><br><span class="line">    <span class="keyword">RETURN</span> emp_salary;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h4 id="window窗口函数"><a href="#window窗口函数" class="headerlink" title="window窗口函数"></a>window窗口函数</h4><p>窗口函数（Window Function）是SQL标准中的一种功能强大的工具，它允许在查询中对一组行进行计算，而不会像聚合函数那样消除行的个数。窗口函数在MySQL 8.0及更高版本中得到了支持，它们可以用于计算移动平均值、累积和、排名等复杂的分析任务。</p>
<h5 id="窗口函数的主要特点"><a href="#窗口函数的主要特点" class="headerlink" title="窗口函数的主要特点"></a>窗口函数的主要特点</h5><p>行级计算：</p>
<ul>
<li>窗口函数在每一行上执行计算，同时可以访问同一组中的其他行。</li>
<li>这与聚合函数不同，聚合函数会将多行数据合并为一行。<br>分区和排序：</li>
<li>窗口函数可以使用PARTITION BY子句将数据分成多个分区，每个分区独立计算。</li>
<li>可以使用ORDER BY子句在每个分区内对数据进行排序。<br>灵活的范围定义：</li>
<li>窗口函数可以定义计算的范围，如当前行的前几行或后几行。</li>
<li>使用ROWS或RANGE子句可以指定计算的范围。<br>多种功能：</li>
<li>窗口函数提供了多种功能，如ROW_NUMBER()、RANK()、DENSE_RANK()、NTILE()、SUM()、AVG()、LEAD()、LAG()等。</li>
</ul>
<p><code>ROW_NUMBER</code>和<code>RANK</code>都需要和<code>OVER</code>一起使用。</p>
<ul>
<li>ROW_NUMBER(): 显示当前行号</li>
<li>RANK() : 显示排序后的排名，如果没有排序，都是1</li>
<li>OVER()<ul>
<li>PARTITION BY 进行分组</li>
<li>GROUP BY 进行分组</li>
<li>ORDER BY 排序</li>
</ul>
</li>
</ul>
<p><img src="/../images/15445001.png" alt="001"></p>
<p><img src="/../images/15445002.png" alt="002"></p>
<p><img src="/../images/15445003.png" alt="003"></p>
<h4 id="获取每个课程中分数最高的学生信息"><a href="#获取每个课程中分数最高的学生信息" class="headerlink" title="获取每个课程中分数最高的学生信息"></a>获取每个课程中分数最高的学生信息</h4><p>下面的SQL，在postgresql中执行成功，mysql8执行报错。</p>
<p>首先查询所有课程信息，并按照课程分组，按照分数排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line"><span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cid <span class="keyword">ORDER</span> <span class="keyword">BY</span> grade <span class="keyword">ASC</span>)</span><br><span class="line"><span class="keyword">AS</span> rank <span class="keyword">FROM</span> enrolled</span><br></pre></td></tr></table></figure>

<p><img src="/../images/15445004.png" alt="004"></p>
<p>接着搜索上表中分数为1，也就是分数最高的学生。也就是每个课分数最高的学生信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line">    <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cid</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> grade <span class="keyword">ASC</span>)</span><br><span class="line">    <span class="keyword">AS</span> rank <span class="keyword">FROM</span> enrolled) <span class="keyword">AS</span> ranking</span><br><span class="line"><span class="keyword">WHERE</span> ranking.rank <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="/../images/15445005.png" alt="005"></p>
<h4 id="CTE-common-table-expressions"><a href="#CTE-common-table-expressions" class="headerlink" title="CTE(common table expressions)"></a>CTE(common table expressions)</h4><p>在MySQL中，<strong>CTE（Common Table Expressions，公共表表达式）</strong>是一种临时的结果集，可以在查询中被引用。CTE通常用于简化复杂的查询，使查询更易于理解和维护。CTE在MySQL 8.0及更高版本中得到了支持。</p>
<h5 id="CTE的主要特点"><a href="#CTE的主要特点" class="headerlink" title="CTE的主要特点"></a>CTE的主要特点</h5><p>临时结果集：</p>
<ul>
<li>CTE是一个临时的结果集，可以在查询中被引用。它类似于子查询，但更易于阅读和维护。<br>简化复杂查询：</li>
<li>CTE可以将复杂的查询分解为多个简单的部分，使查询更易于理解和维护。<br>可重用性：</li>
<li>CTE可以被多次引用，减少了代码重复，提高了开发效率。<br>递归查询：</li>
<li>CTE支持递归查询，可以用于处理层次结构或递归数据。</li>
</ul>
<p>使用<code>CTE</code>实现获取每个课程中分数最高的学生信息。</p>
<p>通过<code>WITH</code>语句来声明一个临时表。表名<code>cteSource</code>，表的内容就是最的sid，通过<code>SELECT MAX(sid) FROM enrolled</code>查询出来的结果。字段名叫<code>maxId</code>。</p>
<p>然后在查询语句里面就可以连接<code>cteSource</code>表，然后通过sid &#x3D; cteSource.maxId 来获取到sid最大的用户信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> cteSource (maxId) <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(sid) <span class="keyword">FROM</span> enrolled</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> student, cteSource</span><br><span class="line"><span class="keyword">WHERE</span> student.sid <span class="operator">=</span> cteSource.maxId</span><br></pre></td></tr></table></figure>

<p>还有一些其他的用法，比如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> cte1 (col1) <span class="keyword">AS</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span></span><br><span class="line">),</span><br><span class="line">cte2 (col2) <span class="keyword">AS</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> cte1, cte2;</span><br></pre></td></tr></table></figure>

<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>介绍了上面的概念，我们现在明白了MySQL数据库是什么了吧。</p>
<p>MySQL数据库是</p>
<ul>
<li>OLTP数据库</li>
<li>基于关系模型的关系数据库管理系统</li>
<li>实现了SQL标准，可以使用SQL进行控制，并扩展了自己的东西。</li>
<li>可以使用ER图来设计关系模型</li>
<li>具有一些高级特性</li>
</ul>
<h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>以上就是整体的MySQL学习路线了。</p>
<p>关注我发送“MySQL知识图谱”领取完整的MySQL学习路线。</p>
<p>发送“电子书”即可领取价值上千的电子书资源。</p>
<p>部分电子书如图所示。</p>
<p><img src="/../images/bottom1.png" alt="概念学习"></p>
<p><img src="/../images/bottom2.png" alt="概念学习"></p>
<p><img src="/../images/bottom3.png" alt="概念学习"></p>
<p><img src="/../images/bottom4.png" alt="概念学习"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/JAVA%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/JAVA%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html" class="post-title-link" itemprop="url">JAVA中的函数式编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-06 10:12:47" itemprop="dateCreated datePublished" datetime="2023-03-06T10:12:47+08:00">2023-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span id="/JAVA%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html" class="post-meta-item leancloud_visitors" data-flag-title="JAVA中的函数式编程" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/JAVA%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/JAVA%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JAVA中的函数式编程"><a href="#JAVA中的函数式编程" class="headerlink" title="JAVA中的函数式编程"></a>JAVA中的函数式编程</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/JAVA-optional%E5%B9%B6%E9%9D%9E%E9%93%B6%E5%BC%B9.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/JAVA-optional%E5%B9%B6%E9%9D%9E%E9%93%B6%E5%BC%B9.html" class="post-title-link" itemprop="url">JAVA-optional并非银弹</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-02 10:12:47" itemprop="dateCreated datePublished" datetime="2023-03-02T10:12:47+08:00">2023-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span id="/JAVA-optional%E5%B9%B6%E9%9D%9E%E9%93%B6%E5%BC%B9.html" class="post-meta-item leancloud_visitors" data-flag-title="JAVA-optional并非银弹" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/JAVA-optional%E5%B9%B6%E9%9D%9E%E9%93%B6%E5%BC%B9.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/JAVA-optional%E5%B9%B6%E9%9D%9E%E9%93%B6%E5%BC%B9.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="optional并非银弹"><a href="#optional并非银弹" class="headerlink" title="optional并非银弹"></a>optional并非银弹</h1><p>首先，我们都知道，<code>optional</code>类型要更加安全，如果使用的好，不会出现空指针异常，因为它不会返回null。</p>
<p>但是注意，这里的前提是<code>使用的好</code>。</p>
<p>比如 下面这两段代码。这里的 optionalInt.get().toString() 并不会比 num.toString() 安全，如果optionInt.get()返回的是一个null，还是会触发空指针异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; optionalInt = Optional.of(<span class="number">12</span>);</span><br><span class="line">optionalInt.get().toString();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">num.toString();</span><br></pre></td></tr></table></figure>

<p>所以，optional并不是处理空指针的银弹，而是需要正确的使用它。</p>
<h3 id="如果正确的使用optional"><a href="#如果正确的使用optional" class="headerlink" title="如果正确的使用optional"></a>如果正确的使用optional</h3><p><code>isPresent</code>和<code>ifPresent</code>这两个方法。</p>
<ul>
<li>isPresent 是一个判断，类似于 num !&#x3D; null</li>
<li>ifPresent 接受一个 lambda 表达式或者方法，如果存在的话就调用该方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; optionalInt = Optional.of(<span class="number">12</span>);</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">optionalInt.ifPresent(i -&gt; &#123;</span><br><span class="line">    num = i;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (optionalInt.isPresent()) &#123;</span><br><span class="line">    num = optionalInt.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里更推荐的是使用 ifPresent 方法，更加安全方便。</p>
<p>为什么呢？因为你只是为了判断这么一下的话，完全可以使用 <code>num != null</code> 来代替 <code>optionalInt.isPresent</code>。毕竟这样还省去了包装optional的步骤，效果则是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (optionalInt.isPresent()) &#123;</span><br><span class="line">    num = optionalInt.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">    num = a * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是 <code>ifPresent</code> 方法只负责处理，并不返回任何值。</p>
<p>如果你想要返回值的话，可以使用<code>map</code>方法代替。他返回一个bool值，被封装到optional中的true或者false(根据optionalInt是否存在)，也可能是个空值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Boolean&gt; res = optionalInt.map(i -&gt; &#123;</span><br><span class="line">    num = i;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>那么在日常使用中，还会有默认值的情况，比如，如果int值存在我就赋值给num，不存在我就赋值0。这个时候就可以使用下面这三个方法</p>
<ul>
<li>orElse        如果有值，返回值，如果没有值，返回你给的默认值。</li>
<li>orElseGet     和上面的效果一样，只是可以传一个lambda表达式</li>
<li>orElseThrow   和上面的效果一样，没有值的时候返回一个异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; optionalInt = Optional.of(<span class="number">12</span>);</span><br><span class="line">num = optionalInt.orElse(<span class="number">0</span>); <span class="comment">//这里有值，所以返回12</span></span><br><span class="line"></span><br><span class="line">Optional&lt;Integer&gt; optionalInt = Optional.empty();</span><br><span class="line">num = optionalInt.orElse(<span class="number">0</span>); <span class="comment">//这里没有值，所以返回默认值0</span></span><br><span class="line"></span><br><span class="line">Optional&lt;Integer&gt; optionalInt = Optional.empty();</span><br><span class="line"><span class="comment">// 传一个默认值方法</span></span><br><span class="line">num = optionalInt.orElseGet(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Optional&lt;Integer&gt; optionalInt = Optional.empty();</span><br><span class="line"><span class="comment">// 如果没有值，返回一个异常</span></span><br><span class="line"><span class="keyword">return</span> optionalInt.orElseThrow(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;异常了&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>通过<code>faltMap</code>方法实现optional链式操作。首先通过of方法创建一个<code>Optional&lt;Integer&gt;</code>类型的12。然后通过flatMap方法把这个Integer的12传递给doubleInt方法。doubleInt方法处理完以后返回一个<code>Optional&lt;Integer&gt;</code>类型的24。</p>
<p>因为返回的还是一个<code>Optional</code>。所以还可以继续调用flatMap方法。将24传给intToStr方法。将24转换成String类型。然后返回一个<code>Optional&lt;String&gt;</code>类型的24.</p>
<p><code>ofNullable</code>方法的作用是如果你给的值存在就调用<code>of</code>方法创建一个<code>Optional</code>。如果不存在就调用<code>empty</code>方法创建一个空的<code>Optional</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">optionalMap</span><span class="params">()</span> &#123;</span><br><span class="line">    Optional&lt;String&gt; res = Optional.of(<span class="number">12</span>).flatMap(<span class="built_in">this</span>::doubleInt).flatMap(<span class="built_in">this</span>::intToStr);</span><br><span class="line">    <span class="keyword">return</span> res.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一个数转换成string</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title function_">intToStr</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(String.valueOf(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一个数 * 2</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;Integer&gt; <span class="title function_">doubleInt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(x &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/JAVA-%E8%BD%AC%E8%AF%AD%E8%A8%80%E8%80%85%E9%80%9F%E5%AD%A6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/JAVA-%E8%BD%AC%E8%AF%AD%E8%A8%80%E8%80%85%E9%80%9F%E5%AD%A6.html" class="post-title-link" itemprop="url">转语言者速学java</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-02 10:12:47" itemprop="dateCreated datePublished" datetime="2023-03-02T10:12:47+08:00">2023-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span id="/JAVA-%E8%BD%AC%E8%AF%AD%E8%A8%80%E8%80%85%E9%80%9F%E5%AD%A6.html" class="post-meta-item leancloud_visitors" data-flag-title="转语言者速学java" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/JAVA-%E8%BD%AC%E8%AF%AD%E8%A8%80%E8%80%85%E9%80%9F%E5%AD%A6.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/JAVA-%E8%BD%AC%E8%AF%AD%E8%A8%80%E8%80%85%E9%80%9F%E5%AD%A6.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="转语言者速学java"><a href="#转语言者速学java" class="headerlink" title="转语言者速学java"></a>转语言者速学java</h1><h3 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a>接口的默认方法</h3><p>java的接口里面可以写方法体，这样的话，所有实现了该接口的，都自动具有了该方法而不用实现方法内容。当然了，也可以重写方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IGuideService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> Integer <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuideService</span> <span class="keyword">implements</span> <span class="title class_">IGuideService</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span> &#123;</span><br><span class="line">        <span class="type">IGuideService</span> <span class="variable">guideService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuideService</span>;</span><br><span class="line">        System.out.println(guideService.getNum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>但是java可以实现多个接口，所以就可能会有<code>二义性</code>的问题，C++解决问题的方法是<code>虚基类</code>，java则是简单粗暴的。</p>
<ul>
<li>如果是父类中和接口中的方法冲突了。那么选择父类中的方法。</li>
<li>如果是多个接口中的方法冲突了，那么你必须通过覆盖该方法来手动解决冲突。</li>
</ul>
<p>看一下如果父类中也有<code>getNum</code>方法。创建一个父类返回2.再次执行以后会发现返回2了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseGuideService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuideService</span> <span class="keyword">extends</span> <span class="title class_">BaseGuideService</span> <span class="keyword">implements</span> <span class="title class_">IGuideService</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来不用父类，然后创建两个接口试试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IGuideNewService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> Integer <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现两个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuideService</span> <span class="keyword">implements</span> <span class="title class_">IGuideService</span>,IGuideNewService &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候编译就会报错了。</p>
<blockquote>
<p>GuideService 从 IGuideService 和 IGuideNewService 中继承了getNum() 的不相关默认值</p>
</blockquote>
<p>那如果这两个接口是父子接口呢？这个时候就不会报错了，因为相当于子接口重写了这个方法。所以只存在一个<code>getNum</code>方法了。</p>
<p>我们来看如果是单独的两个接口，那么需要我们手动来解决冲突。重写一下这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现两个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuideService</span> <span class="keyword">implements</span> <span class="title class_">IGuideService</span>, IGuideNewService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在重写的时候也可以选择使用两个接口的某一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现两个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuideService</span> <span class="keyword">implements</span> <span class="title class_">IGuideService</span>, IGuideNewService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> IGuideService.<span class="built_in">super</span>.getNum();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//或者使用另一个</span></span><br><span class="line">        <span class="comment">//return IGuideNewService.super.getNum();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="日期时间"><a href="#日期时间" class="headerlink" title="日期时间"></a>日期时间</h3><p>在java中的时间，有几个概念</p>
<ul>
<li>某一个具体的时间点：Instant</li>
<li>持续时间，两个时间点之间的时间：Duration</li>
<li>本地时间，没有时区信息的：LocalDate,LocalTime,LocalDateTime</li>
<li>带时区的时间：ZonedDateTime</li>
<li>处理时区信息时，时间段使用 Period 而不是 Duration</li>
<li>时间格式化处理： DateTimeFormatter</li>
<li>日历计算，比如查找月份的第一天，第二天，第一周，第二周的星期二：TemporalAdjuster</li>
</ul>
<p>获取当前的一个时间点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Instant.now();</span><br></pre></td></tr></table></figure>

<p>获取一段时间，可以用来求运行速度。start是处理开始的时间点。end是处理完成的时间点。再通过Duration来求出一段时间.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">start</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"><span class="comment">//处理逻辑</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">end</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"></span><br><span class="line"><span class="type">Duration</span> <span class="variable">time</span> <span class="operator">=</span> Duration.between(start,end);</span><br><span class="line"><span class="type">long</span> <span class="variable">mills</span> <span class="operator">=</span> time.toMills();</span><br></pre></td></tr></table></figure>

<p>获取本地当前时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now();</span><br></pre></td></tr></table></figure>

<p>时间格式化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">time.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>获取带时区的当前时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">time</span> <span class="operator">=</span> ZonedDateTime.now();</span><br></pre></td></tr></table></figure>

<p>想看更多时间处理的，可以参考 <a href="https://thepatterraining.github.io/JAVA-spring%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93.html#valine-comments">LocalDateTime源码解析</a></p>
<h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h3><p>stream可以帮我们处理很多东西。比如</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">map</td>
<td align="left">循环。可以简单理解为foreach</td>
</tr>
<tr>
<td align="left">flatMap</td>
<td align="left">将二维数据展开成一维</td>
</tr>
<tr>
<td align="left">filter</td>
<td align="left">过滤数据</td>
</tr>
<tr>
<td align="left">distinct</td>
<td align="left">去重</td>
</tr>
<tr>
<td align="left">sorted</td>
<td align="left">排序</td>
</tr>
<tr>
<td align="left">limit</td>
<td align="left">限制只取n个元素</td>
</tr>
<tr>
<td align="left">skip</td>
<td align="left">跳过n个元素</td>
</tr>
</tbody></table>
<p>除了这些还可以实现比如把list转换成逗号分隔的字符串。把list经过处理以后转换成set或者map。</p>
<p>还可以变成指定值为key,指定值为value的map。比如id为key，name为值或者map为值的map。</p>
<p>具体的可以参考下面三个文章。</p>
<ul>
<li><a href="">stream数据结构和原理</a></li>
<li><a href="">stream的map,filter,sorted等使用和源码</a></li>
<li><a href="">stream的collect,foreach等使用和源码</a></li>
</ul>
<h3 id="optional"><a href="#optional" class="headerlink" title="optional"></a>optional</h3><p>java中的optional可以帮助你避免<code>空指针异常</code>.</p>
<p>具体的可以参考<a href="https://thepatterraining.github.io/JAVA-optional%E5%B9%B6%E9%9D%9E%E9%93%B6%E5%BC%B9.html">optional并非银弹</a></p>
<h3 id="函数式编程和lambda"><a href="#函数式编程和lambda" class="headerlink" title="函数式编程和lambda"></a>函数式编程和lambda</h3><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul>
<li>@Autowired  Spring提供的，基于类型注入的，可以放在setter方法上，变量上，构造函数上</li>
<li>@Inject     同@Autowired</li>
<li>@Qualifier  Spring提供的，基于名称注入的，一般和@Autowired配合使用来通过value参数指定名称</li>
<li>@Name       同@Qualifier，给@Inject配合使用</li>
<li>@Primary</li>
<li>@Resource   Java提供的，可以基于类型或名称注入的,可以通过name参数来指定名称，可以放在setter方法上</li>
<li>@RequiredArgsConstructor  lombok提供的，基于类型注入，通过增加一个构造函数来注入。</li>
<li>@Value      Spring提供的，注入基本类型的注解，一般用来从配置文件取值。</li>
<li>@Component 单纯的说我是一个<code>bean</code></li>
<li>@Service 和上面的一样，不过一般用在service类中，更加语义化</li>
<li>@Controller 和上面的一样，一般用在controller类中</li>
<li>@Repository 我也是一个<code>bean</code>，一般用在dao数据访问层</li>
<li>@Bean 我也是一个bean，导入第三方包里面的注解</li>
<li>@Import 导入组件</li>
<li>@ImportSelector 返回需要导入的组件的全类名数组</li>
<li>@ImportBeanDefinitionRegistrar 手动注册Bean到容器</li>
<li>@JsonIgnore  json的时候忽略属性</li>
<li>@Bean(initMethod&#x3D;”init”,destoryMethod&#x3D;”destory”) 设置初始化和销毁方法</li>
<li>@PostConstruct：初始化方法</li>
<li>@PreDestory：销毁方法</li>
<li>BeanPostProcessor：bean的后置处理器，在bean初始化前后进行一些处理工作</li>
<li>@Configuration 声明为配置类</li>
<li>@ComponentScan 扫描Component</li>
<li>@Aspect 声明一个切面</li>
<li>@After 在方法执行之后执行（方法上）</li>
<li>@Before 在方法执行之前执行（方法上）</li>
<li>@Around 在方法执行之前与之后执行（方法上）</li>
<li>@PointCut 声明切点</li>
<li>@EnableAspectJAutoProxy 启Spring对AspectJ代理的支持</li>
<li>@Profile 指定组件在哪个环境的情况下才能被注册到容器中，不指定，任何环境下都能注册这个组件。</li>
<li>@Conditional 通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。</li>
<li>@EnableAsync 配置类中通过此注解开启对异步任务的支持</li>
<li>@Async  在实际执行的bean方法使用该注解来声明其是一个异步任务</li>
<li>@EnableScheduling  在配置类上使用，开启计划任务的支持</li>
<li>@Scheduled  来申明这是一个任务，包括cron,fixDelay,fixRate等类型</li>
<li>@EnableConfigurationProperties：开启对@ConfigurationProperties注解配置Bean的支持；</li>
<li>@EnableJpaRepositories：开启对SpringData JPA Repository的支持；</li>
<li>@EnableTransactionManagement：开启注解式事务的支持；</li>
<li>@EnableCaching：开启注解式的缓存支持；</li>
<li>@EnableAspectAutoProxy：开启对AspectJ自动代理的支持；</li>
<li>@EnableWebMvc   在配置类中开启Web MVC的配置支持。</li>
<li>@RequestMapping   用于映射web请求，包括访问路径和参数。</li>
<li>@ResponseBody    支持将返回值放到response内，而不是一个页面，通常用户返回json数据。</li>
<li>@RequestBody           允许request的参数在request体中，而不是在直接连接的地址后面。</li>
<li>@PathVariable         用于接收路径参数，比如@RequestMapping(“&#x2F;hello&#x2F;{name}”)声明的路径，将注解放在参数前，即可获取该值，通常作为Restful的接口实现方法。</li>
<li>@RestController       该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。</li>
<li>@ControllerAdvice     全局异常处理 全局数据绑定 全局数据预处理</li>
<li>@ExceptionHandler     用于全局处理控制器里的异常。</li>
<li>@InitBinder           用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。</li>
<li>@ModelAttribute       </li>
<li>@Transactional <ul>
<li>name 当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。</li>
<li>propagation 事务的传播行为，默认值为 REQUIRED。<ul>
<li>REQUIRED  如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。( 也就是说如果A方法和B方法都添加了注解，在默认传播模式下，A方法内部调用B方法，会把两个方法的事务合并为一个事务 ）</li>
<li>SUPPORTS  如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。</li>
<li>MANDATORY 如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</li>
<li>REQUIRES_NEW  重新创建一个新的事务，如果当前存在事务，暂停当前的事务。</li>
<li>NOT_SUPPORTED 以非事务的方式运行，如果当前存在事务，暂停当前的事务。</li>
<li>NEVER         以非事务的方式运行，如果当前存在事务，则抛出异常。</li>
<li>NESTED        和 REQUIRED 效果一样。</li>
</ul>
</li>
<li>isolation 事务的隔离度，默认值采用 DEFAULT</li>
<li>timeout   事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</li>
<li>read-only 指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</li>
<li>rollback-for  用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。</li>
<li>no-rollback- for  抛出 no-rollback-for 指定的异常类型，不回滚事务。</li>
</ul>
</li>
<li>@Schema   表示此类对应的数据库表对应的schema。</li>
<li>@JsonFormat   可以方便的把Date类型直接转化为我们想要的模式</li>
<li>@Transient    如果一个属性并非数据库表的字段映射，就务必将其标示为@Transient</li>
<li>@JsonProperty 可以指定某个属性和json映射的名称</li>
<li>@Scope设置类型包括：</li>
</ul>
<p>设置Spring容器如何新建Bean实例（方法上，得有@Bean）</p>
<p>① Singleton</p>
<p>（单例,一个Spring容器中只有一个bean实例，默认模式）,</p>
<p>② Protetype</p>
<p>（每次调用新建一个bean）,</p>
<p>③ Request</p>
<p>（web项目中，给每个http request新建一个bean）,</p>
<p>④ Session</p>
<p>（web项目中，给每个http session新建一个bean）,</p>
<p>⑤ GlobalSession</p>
<p>（给每一个 global http session新建一个Bean实例）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/JAVA-stream%E4%B8%AD%E9%97%B4%E6%80%81%E5%8E%9F%E7%90%86.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/JAVA-stream%E4%B8%AD%E9%97%B4%E6%80%81%E5%8E%9F%E7%90%86.html" class="post-title-link" itemprop="url">JAVA-stream中间态原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-17 10:12:47" itemprop="dateCreated datePublished" datetime="2023-02-17T10:12:47+08:00">2023-02-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span id="/JAVA-stream%E4%B8%AD%E9%97%B4%E6%80%81%E5%8E%9F%E7%90%86.html" class="post-meta-item leancloud_visitors" data-flag-title="JAVA-stream中间态原理" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/JAVA-stream%E4%B8%AD%E9%97%B4%E6%80%81%E5%8E%9F%E7%90%86.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/JAVA-stream%E4%B8%AD%E9%97%B4%E6%80%81%E5%8E%9F%E7%90%86.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h1><h3 id="stream的中间态"><a href="#stream的中间态" class="headerlink" title="stream的中间态"></a>stream的中间态</h3><p>中间态的主要作用是构建双向链表的中间节点。一个操作对应一个节点。比如map，就会创建一个节点。其中pre指针指向前一个节点也就是头节点。而头节点的next指针指向map节点。</p>
<p>filter操作的时候同样创建一个节点，pre指针指向上一个操作也就是map节点。map节点的next指针指向filter节点。</p>
<p>每个中间态节点中都存储了操作，也就是中间态的时候传入的函数。而数据则全部在头节点中。</p>
<p>比如下面这样：</p>
<p><img src="/../images/stream4.png" alt="strem"></p>
<p>每个中间态节点其实又分成两种</p>
<ul>
<li>有状态节点</li>
<li>无状态节点</li>
</ul>
<p>类图如下：</p>
<p><img src="/../images/stream12.png" alt="stream12"></p>
<p>中间态节点的几个操作如下：</p>
<p><img src="/../images/stream13.png" alt="stream13"></p>
<p>我们目前的代码中使用了两个中间态的方法。</p>
<ul>
<li>map</li>
<li>filter</li>
</ul>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>我们调用的是<code>ReferencePipeline</code>类的<code>map</code>方法。作为中间态方法，需要链式操作，所以返回值当然是一个stream了。接受一个函数作为入参，可以是一个写好的函数，也可以是一个lambda表达式的函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> P_OUT, ? extends R&gt; mapper)</span> &#123;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="comment">//创建一个无状态的对象</span></span><br><span class="line">    <span class="comment">//第一个参数是this，也就是刚才初始化好的只有一个头节点的双向链表。</span></span><br><span class="line">    <span class="comment">//第二个参数是一个常量 REFERENCE</span></span><br><span class="line">    <span class="comment">//第三个参数是 8 &amp; 2 = 1000 &amp; 0010 = 1010 = 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StatelessOp</span>&lt;P_OUT, R&gt;(<span class="built_in">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                    StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//增加了opWrapSink方法，第一个参数是标志 = 95，第二个是sink节点</span></span><br><span class="line">        <span class="comment">//这个方法会在结果态的时候调用</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        Sink&lt;P_OUT&gt; <span class="title function_">opWrapSink</span><span class="params">(<span class="type">int</span> flags, Sink&lt;R&gt; sink)</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个 Sink.ChainedReference类的对象并返回。具体的放在结果态里面讲。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sink</span>.ChainedReference&lt;P_OUT, R&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(P_OUT u)</span> &#123;</span><br><span class="line">                    downstream.accept(mapper.apply(u));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无状态节点的构造方法</span></span><br><span class="line"><span class="comment">//第一个参数是this，也就是刚才初始化好的只有一个头节点的双向链表。</span></span><br><span class="line"><span class="comment">//第二个参数是一个常量 REFERENCE</span></span><br><span class="line"><span class="comment">//第三个参数是 8 &amp; 2 = 1000 &amp; 0010 = 1010 = 10</span></span><br><span class="line">StatelessOp(AbstractPipeline&lt;?, E_IN, ?&gt; upstream,</span><br><span class="line">            StreamShape inputShape,</span><br><span class="line">            <span class="type">int</span> opFlags) &#123;</span><br><span class="line">    <span class="comment">//调用父类的构造函数</span></span><br><span class="line">    <span class="built_in">super</span>(upstream, opFlags);</span><br><span class="line">    <span class="comment">// upstream.getOutputShape() 返回的就是 REFERENCE， inputShape = REFERENCE，</span></span><br><span class="line">    <span class="comment">// 所以返回true</span></span><br><span class="line">    <span class="keyword">assert</span> upstream.getOutputShape() == inputShape;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//巧了，他的父类也是ReferencePipeline，所以又来到了它的构造方法，不过和上次那个不是同一个了。</span></span><br><span class="line"><span class="comment">//这个作用是构造一个中间态的节点，加入到双向链表也就是加入到流中。</span></span><br><span class="line"><span class="comment">//第一个参数是 双向链表</span></span><br><span class="line"><span class="comment">//第二个是 10</span></span><br><span class="line">ReferencePipeline(AbstractPipeline&lt;?, P_IN, ?&gt; upstream, <span class="type">int</span> opFlags) &#123;</span><br><span class="line">    <span class="comment">//再次调用父类的构造方法</span></span><br><span class="line">    <span class="built_in">super</span>(upstream, opFlags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里同样来到了AbstractPipeline的构造方法。</span></span><br><span class="line"><span class="comment">//这个方法的作用是构造一个中间态的节点。</span></span><br><span class="line"><span class="comment">//第一个参数是上一个节点，这里上一个就是头节点。</span></span><br><span class="line"><span class="comment">//第二个参数是10</span></span><br><span class="line">AbstractPipeline(AbstractPipeline&lt;?, E_IN, ?&gt; previousStage, <span class="type">int</span> opFlags) &#123;</span><br><span class="line">    <span class="comment">//判断上一个节点是否连接了消费者，如果连接了就报错。</span></span><br><span class="line">    <span class="keyword">if</span> (previousStage.linkedOrConsumed)</span><br><span class="line">        <span class="comment">//抛出非法状态异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(MSG_STREAM_LINKED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把上一个节点的是否连接消费者 = 1</span></span><br><span class="line">    previousStage.linkedOrConsumed = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//上一个节点的 next 指针指向当前节点。</span></span><br><span class="line">    previousStage.nextStage = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的头指针指向上一个节点</span></span><br><span class="line">    <span class="built_in">this</span>.previousStage = previousStage;</span><br><span class="line">    <span class="comment">//10 &amp; 16777407 = 10</span></span><br><span class="line">    <span class="built_in">this</span>.sourceOrOpFlags = opFlags &amp; StreamOpFlag.OP_MASK;</span><br><span class="line">    <span class="comment">//组合当前节点的标志和上一个节点的标志生成新的标志 生成的新标志 = 90</span></span><br><span class="line">    <span class="built_in">this</span>.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);</span><br><span class="line">    <span class="comment">//当前节点的数据 = 上一个节点的数据 = list</span></span><br><span class="line">    <span class="built_in">this</span>.sourceStage = previousStage.sourceStage;</span><br><span class="line">    <span class="comment">//当前节点是否是有状态的节点，这里是false</span></span><br><span class="line">    <span class="keyword">if</span> (opIsStateful())</span><br><span class="line">        sourceStage.sourceAnyStateful = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//深度+1 = 1</span></span><br><span class="line">    <span class="built_in">this</span>.depth = previousStage.depth + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组合当前节点的标志和上一个节点的标志生成新的标志</span></span><br><span class="line"><span class="comment">//第一个参数10</span></span><br><span class="line"><span class="comment">//第二个参数95</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">combineOpFlags</span><span class="params">(<span class="type">int</span> newStreamOrOpFlags, <span class="type">int</span> prevCombOpFlags)</span> &#123;</span><br><span class="line">    <span class="comment">// 0x01 or 0x10 nibbles are transformed to 0x11</span></span><br><span class="line">    <span class="comment">// 0x00 nibbles remain unchanged</span></span><br><span class="line">    <span class="comment">// Then all the bits are flipped</span></span><br><span class="line">    <span class="comment">// Then the result is logically or&#x27;ed with the operation flags.</span></span><br><span class="line">    <span class="comment">// 95 &amp; -16 ｜ 10 = 90</span></span><br><span class="line">    <span class="keyword">return</span> (prevCombOpFlags &amp; StreamOpFlag.getMask(newStreamOrOpFlags)) | newStreamOrOpFlags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> StreamShape <span class="title function_">getOutputShape</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> StreamShape.REFERENCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>到这里<code>map</code>方法就执行结束了。可以看到这里依然没有真正的执行map方法。只是封装成了一个中间态的节点并加入了双向链表。并将数据list和操作mapper都存入了节点。如下。</p>
<p><img src="/../images/stream3.png" alt="stream3.png"></p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter和map一样，作为中间态的方法。来看一下它的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样需要返回一个stream对象。</span></span><br><span class="line"><span class="comment">// 同样接受一个方法或lambda表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> P_OUT&gt; predicate)</span> &#123;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    Objects.requireNonNull(predicate);</span><br><span class="line">    <span class="comment">//同样创建一个无状态的节点并返回</span></span><br><span class="line">    <span class="comment">//第一个参数是this，是包含了头节点和map节点的链表。</span></span><br><span class="line">    <span class="comment">//第二个参数是一个常量 REFERENCE</span></span><br><span class="line">    <span class="comment">//第三个参数是 128</span></span><br><span class="line">    <span class="comment">//具体的代码和map的执行是一样的创建。并没有区别。不再赘述。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StatelessOp</span>&lt;P_OUT, P_OUT&gt;(<span class="built_in">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                    StreamOpFlag.NOT_SIZED) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//增加了opWrapSink方法，第一个参数是标志 = 90，第二个是sink节点</span></span><br><span class="line">        <span class="comment">//这个方法会在结果态的时候调用</span></span><br><span class="line">        Sink&lt;P_OUT&gt; <span class="title function_">opWrapSink</span><span class="params">(<span class="type">int</span> flags, Sink&lt;P_OUT&gt; sink)</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个 Sink.ChainedReference类的对象并返回。具体的放在结果态里面讲。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sink</span>.ChainedReference&lt;P_OUT, P_OUT&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">                    downstream.begin(-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(P_OUT u)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (predicate.test(u))</span><br><span class="line">                        downstream.accept(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当filter完成以后，可以得到下面的数据结构。</p>
<p><img src="/../images/stream4.png" alt="stream4.png"></p>
<h3 id="其他的中间态方法"><a href="#其他的中间态方法" class="headerlink" title="其他的中间态方法"></a>其他的中间态方法</h3><p>总共有9个中间态方法，除了上面的两个还有</p>
<ul>
<li>无状态<ul>
<li>flatMap</li>
<li>unordered</li>
<li>peek</li>
</ul>
</li>
<li>有状态<ul>
<li>distinct</li>
<li>sorted</li>
<li>limit</li>
<li>skip</li>
</ul>
</li>
</ul>
<h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><p>先来看<code>flatMap</code>这个。他的作用是把给定的二维数组，转化成一维数组。比如</p>
<ul>
<li>给定输入：[[1],[2],[3],[4,5]]</li>
<li>要求输出：[1,2,3,4,5]</li>
</ul>
<p>来看应用层代码。首先构建一个二维数组，然后调用flatMap方法，传入<code>Collection::stream</code>方法进行处理元素，最后通过<code>collect</code>变成一个一维的list。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先初始化输入列表</span></span><br><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String &gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list1.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">list2.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">list3.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">list4.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">list4.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(list1);</span><br><span class="line">list.add(list2);</span><br><span class="line">list.add(list3);</span><br><span class="line">list.add(list4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始执行操作</span></span><br><span class="line">List&lt;String&gt; listT = list.stream().flatMap(Collection::stream).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> listT;</span><br></pre></td></tr></table></figure>

<p>看一下具体的执行流程。橙色的是stream的通用执行流程，不管你中间态用哪个方法，这里是不变的，蓝色的是<code>ArrayListSpliterator</code>分割器。红色的执行流程是flatMap的执行流程。</p>
<p><img src="/../images/stream14.png" alt="stream14.png"></p>
<p>可以看到<code>ArrayListSpliterator</code>先取出第一个元素<code>[1]</code>这个一维数组传递给<code>flatMap</code>，然后flatMap执行了我们传入的<code>Collection::stream</code>方法，该方法我们之前说过是初始化一个stream头节点。也就是再生成了一个stream</p>
<p>重点就是这里了。再次把[1]这个一维数组放入了新的stream里面。然后把结果态节点<code>ReduceOps</code>传递给了新的stream作为新的stream的结果态节点。</p>
<p>这个时候新的stream开始执行<code>ArrayListSpliterator</code>。从而把[1]一维数组进行for循环，取出了其中的<code>1</code>这个元素，然后把1传入了同一个<code>ReduceOps</code>进行处理从而组成了一个结果list-&gt;[1]。</p>
<p>把步骤总结如下：</p>
<ol>
<li>取出二维数组的第一个一维数组</li>
<li>把一维数组和结果态节点重新创建一个stream</li>
<li>执行stream把一维数组的元素循环放入结果态的list</li>
</ol>
<p>循环二维数组，不断重复上述步骤，就可以把二维数组展开成一维数组了。</p>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>来看方法的源码，可以看到接受一个方法，返回一个stream，标准的中间态处理。</p>
<p>可以看到参数校验以后就创建了一个无状态节点，节点的具体创建上面说过了。是一样的，不同的就是<code>accpet</code>这个方法。</p>
<p>这个处理逻辑，接受一个参数，这个参数就是上面传入的一维数组，第一次是[1]，第二次是[2]，第三次是[3]，第四次是[4,5]。因为我们传入的方法是 Collection.stream方法，所以会生成一个新的stream并返回给result。</p>
<p>这个时候的result就是一个只有一个头节点的stream。头节点中包含了一维数组[1]。然后判断stream不为空，则调用stream顺序流进行处理，并把collect结果态节点传入。</p>
<p>当<code>forEach</code>处理完以后，该<code>accept</code>方法处理完成。回到当前流也就是二维数组的流中。然后取出下一个一维数组[2]再次进入<code>accept</code>方法执行。直到当前二维数组的流处理完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; Stream&lt;R&gt; <span class="title function_">flatMap</span><span class="params">(Function&lt;? <span class="built_in">super</span> P_OUT, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span> &#123;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="comment">// We can do better than this, by polling cancellationRequested when stream is infinite</span></span><br><span class="line">    <span class="comment">// 创建无状态节点并返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StatelessOp</span>&lt;P_OUT, R&gt;(<span class="built_in">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                    StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        Sink&lt;P_OUT&gt; <span class="title function_">opWrapSink</span><span class="params">(<span class="type">int</span> flags, Sink&lt;R&gt; sink)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sink</span>.ChainedReference&lt;P_OUT, R&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="comment">// 初始化数据</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">                    downstream.begin(-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="comment">// 执行逻辑处理</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(P_OUT u)</span> &#123;</span><br><span class="line">                    <span class="comment">// 调用传入的方法进行处理元素 u ，u可能是 [1] [2] [3] [4,5]</span></span><br><span class="line">                    <span class="comment">// 并将执行结果新的stream赋值给 result</span></span><br><span class="line">                    <span class="keyword">try</span> (Stream&lt;? <span class="keyword">extends</span> <span class="title class_">R</span>&gt; result = mapper.apply(u)) &#123;</span><br><span class="line">                        <span class="comment">// We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it</span></span><br><span class="line">                        <span class="comment">// 如果执行成功 返回了一个有效的 stream，则调用stream顺序流循环处理 downstream</span></span><br><span class="line">                        <span class="comment">// 这里的 downstream就是 结果态节点 ReduceOp 也就是 collect 收集方法</span></span><br><span class="line">                        <span class="keyword">if</span> (result != <span class="literal">null</span>)</span><br><span class="line">                            result.sequential().forEach(downstream);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看一下<code>forEach</code>方法，这个方法很简单。如果不是并行流，那么调用<code>ArrayListSpliterator</code>的<code>forEachRemaining</code>进行处理，传入结果态节点collect。</p>
<p>而<code>forEachRemaining</code>这个方法我们很熟悉了，无非就是循环流中的元素并传入sink链处理。要注意的是这个时候的流是上面新创建的流，这个流里面的元素是[1]这个一维数组。而这个流里面是没有中间态节点的，只有一个传入的collect结果态节点组成的sink链。所以这个流处理完以后就会把[1]里面的<code>1</code>这个元素收集到collect结果态节点中。</p>
<p>当这个forEach处理完这个一维数组以后，返回到上面的accept方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E_OUT&gt; action)</span> &#123;</span><br><span class="line">    <span class="comment">//判断不是并行流</span></span><br><span class="line">    <span class="keyword">if</span> (!isParallel()) &#123;</span><br><span class="line">        <span class="comment">//使用ArrayListSpliterator的forEachRemaining方法，传入结果态节点进行处理。</span></span><br><span class="line">        sourceStageSpliterator().forEachRemaining(action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.forEach(action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="unordered"><a href="#unordered" class="headerlink" title="unordered"></a>unordered</h4><p>这个方法很少使用。主要是不保证流有序，而不是主动打乱流的顺序。直接看当前类中的方法源码吧。</p>
<p>如果有序，直接返回了，如果无序的话会返回一个无状态节点。而这里面并没有accept操作，而是直接返回了传入的sink节点。</p>
<p>比如传入 <code>reduceOp</code> 这个结果态的sink，那就返回这个。如果传入 <code>map</code> 的 sink 就返回这个sink。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Stream&lt;P_OUT&gt; <span class="title function_">unordered</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//判断是否有序，如果无序，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!isOrdered())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果有序，创建一个无状态节点，sink链直接返回。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StatelessOp</span>&lt;P_OUT, P_OUT&gt;(<span class="built_in">this</span>, StreamShape.REFERENCE, StreamOpFlag.NOT_ORDERED) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        Sink&lt;P_OUT&gt; <span class="title function_">opWrapSink</span><span class="params">(<span class="type">int</span> flags, Sink&lt;P_OUT&gt; sink)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sink;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否有有序的标志</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOrdered</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//判断标志位里面是否有ordered这个标志位</span></span><br><span class="line">    <span class="keyword">return</span> StreamOpFlag.ORDERED.isKnown(combinedFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h4><p>这个方法很少使用。主要是调试的时候使用来查看元素是否经过流，当然了也有其他的用法，如果你能保证它不出错的情况下。</p>
<p>来看一个debug的例子。他将打印每一个流经<code>peek</code>方法的元素，在当前场景下，所有元素都会执行打印操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先初始化输入列表</span></span><br><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String &gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list1.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">list2.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">list3.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">list4.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">list4.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(list1);</span><br><span class="line">list.add(list2);</span><br><span class="line">list.add(list3);</span><br><span class="line">list.add(list4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始执行操作</span></span><br><span class="line">List&lt;String&gt; listT = list.stream().flatMap(Collection::stream).peek(e -&gt; System.out.println(e)).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> listT;</span><br></pre></td></tr></table></figure>

<p>但是如果我们修改一下，比如增加<code>filter</code>方法。这个时候，第二个peek方法，就只有&gt;2的元素会流经了，从而只会打印出&gt;2的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始执行操作</span></span><br><span class="line">List&lt;String&gt; listT = list.stream().flatMap(Collection::stream).peek(e -&gt; System.out.println(e)).filter(x -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">2</span>;</span><br><span class="line">&#125;).peek(e -&gt; System.out.println(e)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>来看一下peek的执行时序图。可以看到第一个元素1执行完filter由于不满足条件所以后面的peek和collect都没有再执行。</p>
<p>而第二个元素3执行完filter以后又执行了peek和collect。所以这就是为什么一般又来debug的原因，因为他不一定执行。</p>
<p><img src="/../images/stream15.png" alt="stream15"></p>
<p>接下来看一下它的源码.接受一个方法进行处理，返回一个stream。</p>
<p>而真正处理的时候，只是把流中的元素作为参数调用了peek的这个方法，然后不管结果，再次流动。相当于在流中间插入了一个方法。</p>
<p>所以理论上，你可以插入任何方法。但是要小心，如果因为某些原因导致流中的元素没有走到你的peek方法中，可能会产生印象不到的问题。</p>
<p>所以官方也更推荐用来debug。</p>
<blockquote>
<p>This method exists mainly to support debugging, where you want to see the elements as they flow past a certain point in a pipeline</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title function_">peek</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> P_OUT&gt; action)</span> &#123;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="comment">//创建一个无状态节点并返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StatelessOp</span>&lt;P_OUT, P_OUT&gt;(<span class="built_in">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                    <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        Sink&lt;P_OUT&gt; <span class="title function_">opWrapSink</span><span class="params">(<span class="type">int</span> flags, Sink&lt;P_OUT&gt; sink)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sink</span>.ChainedReference&lt;P_OUT, P_OUT&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(P_OUT u)</span> &#123;</span><br><span class="line">                    <span class="comment">//接受到流中的一个元素</span></span><br><span class="line">                    <span class="comment">//使用该元素作为参数调用peek传入的方法</span></span><br><span class="line">                    action.accept(u);</span><br><span class="line">                    <span class="comment">//调用完以后不管结果如何 继续流动下去</span></span><br><span class="line">                    downstream.accept(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p><code>distinct</code>的作用很明显了，是去重</p>
<p>看一下应用层代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先初始化输入列表</span></span><br><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String &gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list1.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">list2.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">list3.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">list4.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">list4.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(list1);</span><br><span class="line">list.add(list2);</span><br><span class="line">list.add(list3);</span><br><span class="line">list.add(list4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始执行操作</span></span><br><span class="line">List&lt;String&gt; listT = list.stream().flatMap(Collection::stream).peek(e -&gt; System.out.println(e)).distinct().collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> listT;</span><br></pre></td></tr></table></figure>

<p>接下来看源码。直接返回<code>DistinctOps</code>节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title function_">distinct</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> DistinctOps.makeRef(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下<code>makeRef</code>这个方法。</p>
<p>他首先是创建了一个有状态节点<code>stateFulOps</code>对象。接下来分为三种情况</p>
<ul>
<li>已经是去重的了，不再去重</li>
<li>有序去重</li>
<li>无序去重</li>
</ul>
<p>先看无序去重，在这个对象的<code>begin</code>初始化中，创建了一个<code>hashSet</code>对象。 </p>
<p><code>accept</code>执行方法中。首先判断了流中的这个元素是否存在<code>hashSet</code>中，如果存在了就不继续沿着sink链执行了。如果不存在，将元素放入<code>hashSet</code>中并继续执行sink链。</p>
<p>通过<code>hashSet</code>来达到去重的一个效果。这将输出1,3,5,4</p>
<p>再来看有序去重，在这个对象的<code>begin</code>初始化中，创建了<code>seenNull</code>和<code>lastSeen</code>属性。</p>
<ul>
<li>seenNull: 当前元素是否为null</li>
<li>lastSeen: 上一个元素</li>
</ul>
<p>在<code>accept</code>方法中。判断当前元素是null并且seenNull &#x3D; false，那么设置seenNull &#x3D; true 且 lastSeen &#x3D; null 并执行下一个操作。</p>
<p>否则，判断 lastSeen 是null也就是代表当前元素是<code>第一个元素</code>，或者 <code>当前元素</code>不等于<code>上一个元素</code>，那么自然是不重复的，所以执行下一个操作。</p>
<p>如果都不满足说明重复。那么不执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; ReferencePipeline&lt;T, T&gt; <span class="title function_">makeRef</span><span class="params">(AbstractPipeline&lt;?, T, ?&gt; upstream)</span> &#123;</span><br><span class="line">    <span class="comment">//生成有状态节点。传入stream，标志位传入IS_DISTINCT也就是要去重。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReferencePipeline</span>.StatefulOp&lt;T, T&gt;(upstream, StreamShape.REFERENCE,</span><br><span class="line">                                                    StreamOpFlag.IS_DISTINCT | StreamOpFlag.NOT_SIZED) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        Sink&lt;T&gt; <span class="title function_">opWrapSink</span><span class="params">(<span class="type">int</span> flags, Sink&lt;T&gt; sink)</span> &#123;</span><br><span class="line">            <span class="comment">//参数校验</span></span><br><span class="line">            Objects.requireNonNull(sink);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断标志位是否有DISTINCT标志</span></span><br><span class="line">            <span class="comment">//注意这里的flags是上一个节点的标志位，以我们的代码为例，这个是peek的标志位。所以这里返回false</span></span><br><span class="line">            <span class="comment">//这里的判断相当于如果你已经去重了，就不需要在去重了。比如distinct().distinct()。只会去重一次。</span></span><br><span class="line">            <span class="keyword">if</span> (StreamOpFlag.DISTINCT.isKnown(flags)) &#123;</span><br><span class="line">                <span class="keyword">return</span> sink;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StreamOpFlag.SORTED.isKnown(flags)) &#123;</span><br><span class="line">                <span class="comment">//判断是否有序的标志位，也就是判断前面是否已经有序 这里是无序，所以不走这里。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sink</span>.ChainedReference&lt;T, T&gt;(sink) &#123;</span><br><span class="line">                    <span class="type">boolean</span> seenNull;</span><br><span class="line">                    T lastSeen;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">                        seenNull = <span class="literal">false</span>;</span><br><span class="line">                        lastSeen = <span class="literal">null</span>;</span><br><span class="line">                        downstream.begin(-<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">                        seenNull = <span class="literal">false</span>;</span><br><span class="line">                        lastSeen = <span class="literal">null</span>;</span><br><span class="line">                        downstream.end();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span> &#123;</span><br><span class="line">                        <span class="comment">//有序的去重比无序简单很多</span></span><br><span class="line">                        <span class="comment">//因为有序，如果重复那么必然是形如 a a a 这种重复，也就是重复的一定在一起。</span></span><br><span class="line">                        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!seenNull) &#123;</span><br><span class="line">                                seenNull = <span class="literal">true</span>;</span><br><span class="line">                                downstream.accept(lastSeen = <span class="literal">null</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastSeen == <span class="literal">null</span> || !t.equals(lastSeen)) &#123;</span><br><span class="line">                            <span class="comment">//所以这里只需要判断lastSeen也就是上一个出现的这个元素是null</span></span><br><span class="line">                            <span class="comment">//或者当前元素不等于上一个出现的元素那么就是不重复的</span></span><br><span class="line">                            <span class="comment">//比如 2 1 1，当前元素是第一个1，上一个元素是2，不等于，所以流动下去</span></span><br><span class="line">                            <span class="comment">//当前元素是第二个1，上一个元素也是1,等于，所以重复，不走这里</span></span><br><span class="line">                            downstream.accept(lastSeen = t);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果上一个节点没有 DISTINCT 也没有 SORTED 标志，那么走这里。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sink</span>.ChainedReference&lt;T, T&gt;(sink) &#123;</span><br><span class="line">                    Set&lt;T&gt; seen;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">                        <span class="comment">//初始化 hashSet</span></span><br><span class="line">                        seen = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">                        downstream.begin(-<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">                        seen = <span class="literal">null</span>;</span><br><span class="line">                        downstream.end();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span> &#123;</span><br><span class="line">                        <span class="comment">// 这里的处理就是创建一个hashSet然后判断这个元素是否在hashSet中存在。</span></span><br><span class="line">                        <span class="keyword">if</span> (!seen.contains(t)) &#123;</span><br><span class="line">                            <span class="comment">//如果不存在就不重复，放入hashSet</span></span><br><span class="line">                            seen.add(t);</span><br><span class="line">                            <span class="comment">//继续执行</span></span><br><span class="line">                            downstream.accept(t);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看一下执行的时序图。</p>
<p><img src="/../images/stream16.png" alt="stream16"></p>
<h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><p><code>sorted</code>作用是按照给定的方法进行排序。其实底层就是调用的<code>List.sort</code>方法或<code>Arrays.sort</code>方法。</p>
<p>如果不传排序方法，将按照自然排序的方法来排序。</p>
<p>看一下应用层代码。</p>
<ul>
<li>输入 1 3 3 5 4</li>
<li>输出 1 3 3 4 5</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先初始化输入列表</span></span><br><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list1.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">list2.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">list3.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">list4.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">list4.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(list1);</span><br><span class="line">list.add(list2);</span><br><span class="line">list.add(list3);</span><br><span class="line">list.add(list4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始执行操作</span></span><br><span class="line">List&lt;String&gt; listT = list.stream().flatMap(Collection::stream).sorted(String::compareTo).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> listT;</span><br></pre></td></tr></table></figure>

<p>接下来看源码。有两个方法，一个是传入给定的排序方法，一个是不传。他们都会通过<code>SortedOps.makeRef</code>创建<code>OfRef</code>对象，这个是<code>StateFulOp</code>的子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title function_">sorted</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> P_OUT&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SortedOps.makeRef(<span class="built_in">this</span>, comparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title function_">sorted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SortedOps.makeRef(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下SortedOps,就是直接创建<code>OfRef</code>对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">makeRef</span><span class="params">(AbstractPipeline&lt;?, T, ?&gt; upstream)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OfRef</span>&lt;&gt;(upstream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">makeRef</span><span class="params">(AbstractPipeline&lt;?, T, ?&gt; upstream,</span></span><br><span class="line"><span class="params">                            Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OfRef</span>&lt;&gt;(upstream, comparator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看这个类。有两个属性。最终根据是否有<code>SIZED</code>标志位，来决定使用array处理排序，还是array list处理排序。</p>
<ul>
<li>isNaturalSort 是否自然有序</li>
<li>comparator 排序比较方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">OfRef</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ReferencePipeline</span>.StatefulOp&lt;T, T&gt; &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Comparator used for sorting</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> isNaturalSort;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> T&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Sort using natural order of &#123;<span class="doctag">@literal</span> &lt;T&gt;&#125; which must be</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> Comparable&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">OfRef(AbstractPipeline&lt;?, T, ?&gt; upstream) &#123;</span><br><span class="line">    <span class="built_in">super</span>(upstream, StreamShape.REFERENCE,</span><br><span class="line">            StreamOpFlag.IS_ORDERED | StreamOpFlag.IS_SORTED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为自然有序</span></span><br><span class="line">    <span class="built_in">this</span>.isNaturalSort = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// Will throw CCE when we try to sort if T is not Comparable</span></span><br><span class="line">    <span class="comment">//设置排序方法为自然排序，如果是个不可排序的类型，将抛出异常</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> T&gt; comp = (Comparator&lt;? <span class="built_in">super</span> T&gt;) Comparator.naturalOrder();</span><br><span class="line">    <span class="built_in">this</span>.comparator = comp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Sort using the provided comparator.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> comparator The comparator to be used to evaluate ordering.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">OfRef(AbstractPipeline&lt;?, T, ?&gt; upstream, Comparator&lt;? <span class="built_in">super</span> T&gt; comparator) &#123;</span><br><span class="line">    <span class="built_in">super</span>(upstream, StreamShape.REFERENCE,</span><br><span class="line">            StreamOpFlag.IS_ORDERED | StreamOpFlag.NOT_SORTED);</span><br><span class="line">    <span class="comment">// 非自然排序</span></span><br><span class="line">    <span class="built_in">this</span>.isNaturalSort = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 将传入的排序方法赋值给排序方法</span></span><br><span class="line">    <span class="built_in">this</span>.comparator = Objects.requireNonNull(comparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Sink&lt;T&gt; <span class="title function_">opWrapSink</span><span class="params">(<span class="type">int</span> flags, Sink&lt;T&gt; sink)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(sink);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the input is already naturally sorted and this operation</span></span><br><span class="line">    <span class="comment">// also naturally sorted then this is a no-op</span></span><br><span class="line">    <span class="comment">// 如果已经是有序的并且是自然排序的，就直接返回sink节点</span></span><br><span class="line">    <span class="keyword">if</span> (StreamOpFlag.SORTED.isKnown(flags) &amp;&amp; isNaturalSort)</span><br><span class="line">        <span class="keyword">return</span> sink;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (StreamOpFlag.SIZED.isKnown(flags))</span><br><span class="line">    <span class="comment">// 如果标志位有 StreamOpFlag.SIZED，返回 SizedRefSortingSink 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SizedRefSortingSink</span>&lt;&gt;(sink, comparator);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果没有，返回 RefSortingSink 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RefSortingSink</span>&lt;&gt;(sink, comparator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下array流的sink节点。<br>有两个属性</p>
<ul>
<li>array 数据</li>
<li>offset 大小</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SizedRefSortingSink</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">AbstractRefSortingSink</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> offset;</span><br><span class="line"></span><br><span class="line">    SizedRefSortingSink(Sink&lt;? <span class="built_in">super</span> T&gt; sink, Comparator&lt;? <span class="built_in">super</span> T&gt; comparator) &#123;</span><br><span class="line">        <span class="comment">// 调用父类的构造器，创建一个 sink 节点</span></span><br><span class="line">        <span class="built_in">super</span>(sink, comparator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">        <span class="comment">// 在流开始的时候处理 如果流太大，就抛出异常，因为这里只处理有限流</span></span><br><span class="line">        <span class="keyword">if</span> (size &gt;= Nodes.MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(Nodes.BAD_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个Object的数组。</span></span><br><span class="line">        array = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[(<span class="type">int</span>) size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 当流结束的时候，就是所有元素都流动完成了</span></span><br><span class="line">        <span class="comment">// 使用给定的比较器对数组进行排序</span></span><br><span class="line">        Arrays.sort(array, <span class="number">0</span>, offset, comparator);</span><br><span class="line">        <span class="comment">// 这个时候流就是有序的流了，接下来在顺着donstream流动</span></span><br><span class="line">        downstream.begin(offset);</span><br><span class="line">        <span class="comment">// 如果cancellationWasRequested == false</span></span><br><span class="line">        <span class="keyword">if</span> (!cancellationWasRequested) &#123;</span><br><span class="line">            <span class="comment">// 每个元素调用 downstream 进行流动处理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; offset; i++)</span><br><span class="line">                downstream.accept(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果cancellationWasRequested == true</span></span><br><span class="line">            <span class="comment">// 先调用 downstream.cancellationRequested() 返回 false</span></span><br><span class="line">            <span class="comment">// 再执行元素调用 downstream 处理，</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; offset &amp;&amp; !downstream.cancellationRequested(); i++)</span><br><span class="line">                downstream.accept(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        downstream.end();</span><br><span class="line">        array = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="comment">// 当流元素经过的时候，存储到数组中，且offset++</span></span><br><span class="line">        array[offset++] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类 包含一个比较器，继承自 Sink.ChainedReference</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractRefSortingSink</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Sink</span>.ChainedReference&lt;T, T&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> T&gt; comparator;</span><br><span class="line">    <span class="comment">// @@@ could be a lazy final value, if/when support is added</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> cancellationWasRequested;</span><br><span class="line"></span><br><span class="line">    AbstractRefSortingSink(Sink&lt;? <span class="built_in">super</span> T&gt; downstream, Comparator&lt;? <span class="built_in">super</span> T&gt; comparator) &#123;</span><br><span class="line">        <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">        <span class="built_in">super</span>(downstream);</span><br><span class="line">        <span class="comment">// 比较器赋值</span></span><br><span class="line">        <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">cancellationRequested</span><span class="params">()</span> &#123;</span><br><span class="line">        cancellationWasRequested = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下array list的sink节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RefSortingSink</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">AbstractRefSortingSink</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;T&gt; list;</span><br><span class="line"></span><br><span class="line">    RefSortingSink(Sink&lt;? <span class="built_in">super</span> T&gt; sink, Comparator&lt;? <span class="built_in">super</span> T&gt; comparator) &#123;</span><br><span class="line">        <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">        <span class="built_in">super</span>(sink, comparator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果流太大就抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (size &gt;= Nodes.MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(Nodes.BAD_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 array list存储数据</span></span><br><span class="line">        list = (size &gt;= <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;((<span class="type">int</span>) size) : <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//对array listp排序</span></span><br><span class="line">        list.sort(comparator);</span><br><span class="line">        <span class="comment">//往下流动</span></span><br><span class="line">        downstream.begin(list.size());</span><br><span class="line">        <span class="comment">// 如果cancellationWasRequested == false</span></span><br><span class="line">        <span class="keyword">if</span> (!cancellationWasRequested) &#123;</span><br><span class="line">            <span class="comment">//循环每个元素进行流动</span></span><br><span class="line">            list.forEach(downstream::accept);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果cancellationWasRequested == true</span></span><br><span class="line">            <span class="comment">// 先调用 downstream.cancellationRequested() 返回 false</span></span><br><span class="line">            <span class="comment">// 再执行元素调用 downstream 处理，</span></span><br><span class="line">            <span class="keyword">for</span> (T t : list) &#123;</span><br><span class="line">                <span class="keyword">if</span> (downstream.cancellationRequested()) <span class="keyword">break</span>;</span><br><span class="line">                downstream.accept(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        downstream.end();</span><br><span class="line">        list = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="comment">// 把数据存入 array list</span></span><br><span class="line">        list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后看一下时序图。</p>
<p><img src="/../images/stream17.png" alt="steam17"></p>
<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p><code>limit</code>的作用是选取多少个元素。常常用在截取流的一部分。</p>
<p>还是以上面的排序代码为例，排序后只取前3个元素，就可以使用limit(3).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;String&gt; listT = list.stream().flatMap(Collection::stream).sorted(String::compareTo).limit(<span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单看一下源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果元素个数小于0，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (maxSize &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(Long.toString(maxSize));</span><br><span class="line">    <span class="comment">// 通过 SliceOps 创建一个 有状态节点</span></span><br><span class="line">    <span class="keyword">return</span> SliceOps.makeRef(<span class="built_in">this</span>, <span class="number">0</span>, maxSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下创建的节点。这个节点里面包含了一个sink节点。</p>
<p>sink节点中有两个属性</p>
<ul>
<li>n 也就是skip 跳过哪些，这里是0</li>
<li>m 也就是limit 取哪些，我们这里是3</li>
</ul>
<p>首先在初始化的时候限制了接下里节点初始化的大小。</p>
<p>真正处理的时候，如果有跳过的，先进行跳过，没有跳过的，就进行流动，当流动的元素数量达到limit个数量以后，不再流动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">makeRef</span><span class="params">(AbstractPipeline&lt;?, T, ?&gt; upstream,</span></span><br><span class="line"><span class="params">                                    <span class="type">long</span> skip, <span class="type">long</span> limit)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里 skip 是0，检查如果小于0就抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (skip &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Skip must be non-negative: &quot;</span> + skip);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有状态节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReferencePipeline</span>.StatefulOp&lt;T, T&gt;(upstream, StreamShape.REFERENCE,</span><br><span class="line">                                                    flags(limit)) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        Sink&lt;T&gt; <span class="title function_">opWrapSink</span><span class="params">(<span class="type">int</span> flags, Sink&lt;T&gt; sink)</span> &#123;</span><br><span class="line">            <span class="comment">// 返回sink节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sink</span>.ChainedReference&lt;T, T&gt;(sink) &#123;</span><br><span class="line">                <span class="comment">//两个属性</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> skip;</span><br><span class="line">                <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> limit &gt;= <span class="number">0</span> ? limit : Long.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">                    <span class="comment">// 流的初始化 计算大小</span></span><br><span class="line">                    <span class="comment">// 这里size是流的大小，我们这里是5,skip是0，m是3 calcSize 返回的是 3</span></span><br><span class="line">                    <span class="comment">// 代表经过limit以后元素只有3个了，所以接下来节点的初始化只需要按3的大小来初始化就行了</span></span><br><span class="line">                    downstream.begin(calcSize(size, skip, m));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果跳过0个</span></span><br><span class="line">                    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 要取的元素 &gt; 0个</span></span><br><span class="line">                        <span class="keyword">if</span> (m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 按照顺序把每个元素流动</span></span><br><span class="line">                            <span class="comment">// m--，当3个元素流动完成以后，m == 0，就不再流动了。</span></span><br><span class="line">                            m--;</span><br><span class="line">                            downstream.accept(t);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果有要跳过的元素，n--，一直跳过，当全部跳过以后 n == 0 ，就不再跳过了</span></span><br><span class="line">                        n--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancellationRequested</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="type">return</span> <span class="variable">m</span> <span class="operator">=</span>= <span class="number">0</span> || downstream.cancellationRequested();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">flags</span><span class="params">(<span class="type">long</span> limit)</span> &#123;</span><br><span class="line">    <span class="comment">// 返回 NOT_SIZED 标志位 和 IS_SHORT_CIRCUIT 标志位</span></span><br><span class="line">    <span class="keyword">return</span> StreamOpFlag.NOT_SIZED | ((limit != -<span class="number">1</span>) ? StreamOpFlag.IS_SHORT_CIRCUIT : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">calcSize</span><span class="params">(<span class="type">long</span> size, <span class="type">long</span> skip, <span class="type">long</span> limit)</span> &#123;</span><br><span class="line">    <span class="comment">// size &gt;=0就 先取 size - skip 和 limit中最小的</span></span><br><span class="line">    <span class="comment">// 我们这里 5-0 = 5,和3比，最小的是3，这里的意思就是如果流的大小比limit小，就返回全部流</span></span><br><span class="line">    <span class="comment">// 然后 -1 和 5比，取大的，返回5</span></span><br><span class="line">    <span class="keyword">return</span> size &gt;= <span class="number">0</span> ? Math.max(-<span class="number">1</span>, Math.min(size - skip, limit)) : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p><code>skip</code>就是跳过多少个元素。可以和<code>limit</code>结合起来一起截取流。</p>
<p>还是以上面的代码为例.skip 1 , limit 3就代表取第2个元素到第4个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; listT = list.stream().flatMap(Collection::stream).sorted(String::compareTo).skip(<span class="number">1</span>).limit(<span class="number">3</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>简单看一下源码。如果skip小于0就抛出异常，如果&#x3D;&#x3D;0就直接返回，相当于不跳过。</p>
<p>创建节点的时候用的和上面<code>limit</code>的是一样的方法。只是参数变成了传skip，不传limit.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(Long.toString(n));</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//和limit一样</span></span><br><span class="line">        <span class="keyword">return</span> SliceOps.makeRef(<span class="built_in">this</span>, n, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>好了，到这里为止，就分析完了<code>stream</code>所有的<code>中间操作</code>。</p>
<p>从源码的角度分析了他们是如何运行的，都有什么作用。</p>
<p>总结一下。这些操作主要分为两大类</p>
<ul>
<li>有状态</li>
<li>无状态</li>
</ul>
<p>作为中间操作，他们的返回类型全部是 stream。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/JAVA-stream%E5%8E%9F%E7%90%86%E5%88%9B%E5%BB%BA%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/JAVA-stream%E5%8E%9F%E7%90%86%E5%88%9B%E5%BB%BA%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C.html" class="post-title-link" itemprop="url">JAVA-stream创建原理和数据结构操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-16 10:12:47" itemprop="dateCreated datePublished" datetime="2023-02-16T10:12:47+08:00">2023-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span id="/JAVA-stream%E5%8E%9F%E7%90%86%E5%88%9B%E5%BB%BA%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C.html" class="post-meta-item leancloud_visitors" data-flag-title="JAVA-stream创建原理和数据结构操作" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/JAVA-stream%E5%8E%9F%E7%90%86%E5%88%9B%E5%BB%BA%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/JAVA-stream%E5%8E%9F%E7%90%86%E5%88%9B%E5%BB%BA%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h1><p>stream是java8新增的非常重要的一个特性。并且非常的常用。它实现了<code>函数式编程</code>。具体函数式编程的概念已经很久了，比如js中的<code>箭头函数</code>。java中也通过stream做出了支持。想深入理解的可以参考cmu的课程<a target="_blank" rel="noopener" href="http://www.cs.cmu.edu/~./15150/index.html">15-150</a>或者stanford的<a href="">CS 95SI</a>。</p>
<p>它可以帮助我们方便的处理很多东西。处理分为两种，中间态和结果态。</p>
<p><img src="/../images/stream1.png" alt="streamImg"></p>
<p>下面是一些中间态操作。他们位于链式操作的中间，当调用他们的时候并没有真正执行。只有当调用结果态的方法的时候才会真正的执行操作，也就是所谓的<code>延迟执行</code>。</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">map</td>
<td align="left">循环。可以简单理解为foreach</td>
</tr>
<tr>
<td align="left">flatMap</td>
<td align="left">将二维数据展开成一维</td>
</tr>
<tr>
<td align="left">filter</td>
<td align="left">过滤数据</td>
</tr>
<tr>
<td align="left">distinct</td>
<td align="left">去重</td>
</tr>
<tr>
<td align="left">sorted</td>
<td align="left">排序</td>
</tr>
<tr>
<td align="left">limit</td>
<td align="left">限制只取n个元素</td>
</tr>
<tr>
<td align="left">skip</td>
<td align="left">跳过n个元素</td>
</tr>
</tbody></table>
<h3 id="stream的初始化"><a href="#stream的初始化" class="headerlink" title="stream的初始化"></a>stream的初始化</h3><p>看一个例子，假设我们有一个需求。输出大于5的所有数。</p>
<ul>
<li>期望输入：2，5，7，1，3，2，8</li>
<li>期望输出：7，8</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先初始化输入列表</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始执行操作</span></span><br><span class="line">List&lt;Integer&gt; list2 = list.stream().map(Integer::valueOf).filter(x -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> x &gt; <span class="number">5</span>;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">System.out.println(list2);</span><br></pre></td></tr></table></figure>

<p>接下来看一下stream是如何执行的。下面是stream的一个类图。可以看到初始化需要使用到一个接口和6个类。主要分为三大类。</p>
<p><img src="/../images/stream8.png" alt="stream8.png"></p>
<h4 id="类介绍"><a href="#类介绍" class="headerlink" title="类介绍"></a>类介绍</h4><p>第一类是<code>ArrayList</code>类和<code>ArrayListSpliterator</code>类。这两个类是核心类。毕竟我们输入类型是ArrayList，这个就不用说了。</p>
<p>主要在于<code>ArrayListSpliterator</code>这个类，这个类是ArrayList的一个内部类。最主要的操作方法和数据都在里面。看一下几个属性</p>
<ul>
<li>list 我们要进行stream操作的list</li>
<li>fence 大小</li>
<li>expectedModCount 期望的处理数量</li>
<li>index</li>
</ul>
<p>最主要的循环处理方法同样在这个类里面。处理逻辑全部在<code>forEachRemaining</code>这个方法中。</p>
<p>第二大类是<code>StreamSupport</code>流的支持类，算是一个单独的类，提供了对stream的一些操作方法，比如初始化一个stream。</p>
<p>第三大类是<code>AbstractPipeline</code>抽象类为主的3个类，还有两个是继承自<code>AbstractPipeline</code>的<code>ReferencePipeline</code>类，主要负责处理引用类的流。和继承<code>ReferencePipeline</code>的<code>Head</code>类，实现了双向链表的头节点。他们的主要功能就是构造为流的双向链表数据结构。</p>
<p><img src="/../images/stream9.png" alt="stream9.png"></p>
<h4 id="执行流程介绍"><a href="#执行流程介绍" class="headerlink" title="执行流程介绍"></a>执行流程介绍</h4><p>这几个类的执行时序图如下。</p>
<p><img src="/../images/stream7.png" alt="stream7.png"></p>
<p>可以清晰的看到，通过<code>Collection</code>类的stream方法调用到了<code>ArrayList</code>的方法然后调用到了<code>ArrayListSpliterator</code>的方法，来初始化了<code>ArrayListSpliterator</code>对象，并存储到流中。</p>
<p>接下来<code>Collection</code>类将初始化好的<code>ArrayListSpliterator</code>对象传递给了<code>StreamSupport</code>类用来初始化stream。</p>
<p>StreamSupport将会创建一个双向链表的头节点。并将<code>ArrayListSpliterator</code>对象放入头节点。初始化以后的流如下图所示：</p>
<p><img src="/../images/stream2.png" alt="stream2.png"></p>
<h4 id="流介绍"><a href="#流介绍" class="headerlink" title="流介绍"></a>流介绍</h4><p>流分为两种，顺序流和并行流。</p>
<h5 id="顺序流"><a href="#顺序流" class="headerlink" title="顺序流"></a>顺序流</h5><p>顺序流顾名思义就是按照顺序执行。可以直接的类比为for循环。如下图，如果1，2，3三个元素，进入流以后，依然是1,2,3三个元素。</p>
<p><img src="/../images/stream10.png" alt="stream10.png"></p>
<h5 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h5><p>并行流是充分的利用现代多核计算机的性能而出的。它可以把流分散到各个进程&#x2F;线程中去执行。来达到并行执行的效果。如下图，1，2，3三个元素，可能会进入2个流中。</p>
<p><img src="/../images/stream11.png" alt="stream11.png"></p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>list的stream方法调用的是Collection类的stream方法。所以首先来看这个方法，该方法返回一个顺序流，顺序流中包含了list中的所有元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法返回一个顺序流，顺序流中包含了list中的所有元素。</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//调用了StreamSupport.stream方法，传入了一个分割迭代器，第二个参数false代表是顺序流，true是平行流。</span></span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成一个分割迭代器，该方法是ArrayList类中的方法。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//返回一个ArrayListSpliterator类的实例。</span></span><br><span class="line">    <span class="comment">//实例中包含4个属性</span></span><br><span class="line">    <span class="comment">//list = list</span></span><br><span class="line">    <span class="comment">//index = 0</span></span><br><span class="line">    <span class="comment">//fence = -1</span></span><br><span class="line">    <span class="comment">//expectedModCount = 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayListSpliterator</span>&lt;&gt;(<span class="built_in">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来来到StreamSupport类的stream方法。通过spliterator来创建一个顺序流。只有当结果态操作开始后，spliterator才会真正开始运行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  通过spliterator来创建一个顺序流或者并行流，如果parallel=1就是并行流</span></span><br><span class="line"><span class="comment">*  只有当结果态操作开始后，spliterator才会真正开始运行</span></span><br><span class="line"><span class="comment">*  spliterator需要具有不可变性，并发性或延迟绑定性。</span></span><br><span class="line"><span class="comment">*  当前的spliterator就是上面生成的ArrayListSpliterator对象。且包含上面说的4个属性。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">stream</span><span class="params">(Spliterator&lt;T&gt; spliterator, <span class="type">boolean</span> parallel)</span> &#123;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    Objects.requireNonNull(spliterator);</span><br><span class="line">    <span class="comment">//返回一个ReferencePipeline.Head类型的头节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReferencePipeline</span>.Head&lt;&gt;(spliterator,</span><br><span class="line">                                        StreamOpFlag.fromCharacteristics(spliterator),</span><br><span class="line">                                        parallel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在生成Head对象的时候，第二个参数调用了<code>StreamOpFlag</code>类的<code>fromCharacteristics</code>方法。来看一下这个方法。<br>可以看到有一个判断是否是自然排序的，如果不是自然排序就会走到if里面，也就是不会将spliterator标记为已排序状态。<br>最终返回结果为80</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将spliterator的characteristic bit转换为stream flags</span></span><br><span class="line"><span class="comment">//当前的spliterator就是上面生成的 ArrayListSpliterator 对象。且包含上面说的4个属性。</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fromCharacteristics</span><span class="params">(Spliterator&lt;?&gt; spliterator)</span> &#123;</span><br><span class="line">    <span class="comment">//调用spliterator对象的characteristics方法。具体看下面 返回的characteristics = 16464</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">characteristics</span> <span class="operator">=</span> spliterator.characteristics();</span><br><span class="line">    <span class="comment">// 16464和4做按位与，即两个都是1才是1，100 0000 0101 0000 &amp; 100 = 000 0000 0000 0000 = 0说明不满足第一个条件，触发短路，走else</span></span><br><span class="line">    <span class="keyword">if</span> ((characteristics &amp; Spliterator.SORTED) != <span class="number">0</span> &amp;&amp; spliterator.getComparator() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Do not propagate the SORTED characteristic if it does not correspond</span></span><br><span class="line">        <span class="comment">// to a natural sort order</span></span><br><span class="line">        <span class="comment">// 如果不是自然排序的，则不传播有序状态。</span></span><br><span class="line">        <span class="keyword">return</span> characteristics &amp; SPLITERATOR_CHARACTERISTICS_MASK &amp; ~Spliterator.SORTED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//将16464和85做按位与，100 0000 0101 0000 &amp; 0101 0101 = 000 0000 0101 0000 = 80</span></span><br><span class="line">        <span class="comment">//返回80</span></span><br><span class="line">        <span class="keyword">return</span> characteristics &amp; SPLITERATOR_CHARACTERISTICS_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ArrayListSpliterator类的characteristics方法。</span></span><br><span class="line"><span class="comment">//三个数做按位或，即有1就是1，结果是 100 0000 0101 0000 = 16464</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">characteristics</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//Spliterator.ORDERED = 16 = 1 0000</span></span><br><span class="line">    <span class="comment">//Spliterator.SIZED = 64 = 100 0000</span></span><br><span class="line">    <span class="comment">//Spliterator.SUBSIZED = 16384 = 100 0000 0000 0000</span></span><br><span class="line">    <span class="keyword">return</span> Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来看<code>Head</code>类，它是<code>ReferencePipeline</code>类的一个内部类。主要作用是头节点的一些属性和操作。包括生成头节点等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Head</span>&lt;E_IN, E_OUT&gt; <span class="keyword">extends</span> <span class="title class_">ReferencePipeline</span>&lt;E_IN, E_OUT&gt; &#123;</span><br><span class="line">    <span class="comment">//这个是双向链表的头节点。也就是把最先创建的初始流作为头节点。</span></span><br><span class="line">    <span class="comment">//三个参数，第一个参数source = ArrayListSpliterator对象</span></span><br><span class="line">    <span class="comment">//第二个参数是流的标志，80</span></span><br><span class="line">    <span class="comment">//第三个参数是否并行流 0</span></span><br><span class="line">    Head(Spliterator&lt;?&gt; source,</span><br><span class="line">            <span class="type">int</span> sourceFlags, <span class="type">boolean</span> parallel) &#123;</span><br><span class="line">        <span class="comment">//调用了父类的构造函数，就是ReferencePipeline的构造方法。在下面。</span></span><br><span class="line">        <span class="built_in">super</span>(source, sourceFlags, parallel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ReferencePipeline的构造方法。参数同上，不再描述。</span></span><br><span class="line">ReferencePipeline(Spliterator&lt;?&gt; source,</span><br><span class="line">                    <span class="type">int</span> sourceFlags, <span class="type">boolean</span> parallel) &#123;</span><br><span class="line">    <span class="comment">//再次调用了父类的构造方法。ReferencePipeline的父类是AbstractPipeline类，放在下面了。</span></span><br><span class="line">    <span class="built_in">super</span>(source, sourceFlags, parallel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractPipeline类的构造方法。构造一个stream的头节点。</span></span><br><span class="line">AbstractPipeline(Spliterator&lt;?&gt; source,</span><br><span class="line">                     <span class="type">int</span> sourceFlags, <span class="type">boolean</span> parallel) &#123;</span><br><span class="line">    <span class="comment">//头节点的头指针为空。</span></span><br><span class="line">    <span class="built_in">this</span>.previousStage = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//数据 = ArrayListSpliterator对象</span></span><br><span class="line">    <span class="built_in">this</span>.sourceSpliterator = source;</span><br><span class="line">    <span class="comment">//头节点的数据 指向自己。</span></span><br><span class="line">    <span class="built_in">this</span>.sourceStage = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">//标志位 = 80 &amp; 85 = 80 二进制 0101 0000 &amp; 0101 0101 = 0101 0000 = 80</span></span><br><span class="line">    <span class="built_in">this</span>.sourceOrOpFlags = sourceFlags &amp; StreamOpFlag.STREAM_MASK;</span><br><span class="line">    <span class="comment">// The following is an optimization of:</span></span><br><span class="line">    <span class="comment">// StreamOpFlag.combineOpFlags(sourceOrOpFlags, StreamOpFlag.INITIAL_OPS_VALUE);</span></span><br><span class="line">    <span class="comment">//sourceOrOpFlags &lt;&lt; 1 = 160  左移一位就是 * 2</span></span><br><span class="line">    <span class="comment">//～160 = -161  按位去反</span></span><br><span class="line">    <span class="comment">// -161 &amp; 255 = 95</span></span><br><span class="line">    <span class="comment">// combinedFlags = 95</span></span><br><span class="line">    <span class="built_in">this</span>.combinedFlags = (~(sourceOrOpFlags &lt;&lt; <span class="number">1</span>)) &amp; StreamOpFlag.INITIAL_OPS_VALUE;</span><br><span class="line">    <span class="comment">// 双向链表深度 = 0 ，因为现在只有头节点。</span></span><br><span class="line">    <span class="built_in">this</span>.depth = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 是否并行流 = 0 不是</span></span><br><span class="line">    <span class="built_in">this</span>.parallel = parallel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>list.stream()函数的源码就完了。主要调用了构造函数，构造了一个含有list数据的头节点，头指针指向空，next指针指向自己。完成了流的初始化。当前数据结构如下。</p>
<p><img src="/../images/stream2.png" alt="stream2.png"></p>
<h3 id="stream的中间态"><a href="#stream的中间态" class="headerlink" title="stream的中间态"></a>stream的中间态</h3><p>中间态的具体源码和流程在后面介绍，这里只介绍中间态的作用。</p>
<p>中间态的主要作用是构建双向链表的中间节点。一个操作对应一个节点。比如map，就会创建一个节点。其中pre指针指向前一个节点也就是头节点。而头节点的next指针指向map节点。</p>
<p>filter操作的时候同样创建一个节点，pre指针指向上一个操作也就是map节点。map节点的next指针指向filter节点。</p>
<p>每个中间态节点中都存储了操作，也就是中间态的时候传入的函数。而数据则全部在头节点中。</p>
<p>比如下面这样：</p>
<p><img src="/../images/stream4.png" alt="strem"></p>
<p>每个中间态节点其实又分成两种</p>
<ul>
<li>有状态节点</li>
<li>无状态节点</li>
</ul>
<p>类图如下：</p>
<p><img src="/../images/stream12.png" alt="stream12"></p>
<h3 id="stream的结果态"><a href="#stream的结果态" class="headerlink" title="stream的结果态"></a>stream的结果态</h3><p>结果态的具体源码和流程在后面介绍，这里只介绍结果态的作用。</p>
<p>结果态的主要作用有三个</p>
<ol>
<li>构造结果态节点</li>
<li>构造sink链表</li>
<li>执行流。</li>
</ol>
<p>先说第一个，结果态节点是<code>ReduceOp</code>对象。这个结果态节点中包含了一个<code>makeSink</code>方法，用来构建结果态的sink节点。结果态的sink节点是一个<code>ReducingSink</code>对象。</p>
<p>第二个，当结果态节点和结果态的sink节点构造完成以后。接下来会根据之前构建好的双向链表来生成对应的sink链表。</p>
<p>一开始的双向链表我们知道是这样的</p>
<p><img src="/../images/stream4.png" alt="strem"></p>
<p>而sink链表则是反过来了，根据双向链表从后向前通过pre指针不断向前，把每个节点包裹在sink节点中并通过<code>downstream</code>指针来指向下个节点。这里因为在第一步的时候把源数据取出来了，所以sink中不包含头节点。创建完后如图所示：</p>
<p><img src="/../images/stream6.png" alt="strem"></p>
<p>第三步才是真正的执行流。根据sink链表来执行，每次把元素传递给第一个sink也就是map操作，当第一个sink节点处理完以后通过downstream流动到下一个sink节点执行。不断通过downsteram流动，直到最后到结果态的sink执行完以后。再次把第二个元素进行流动执行。直至所有元素执行完毕。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>因为是通过自顶向下的方式来了解stream。所以这里主要介绍了stream的执行流程和初始化的源码分析。中间态和结果态的源码分析放在了后面。</p>
<p>在执行流程中可以看到。首先创建了一个双向链表，然后在根据双向链表创建了sink链表。最后通过sink链表进行执行流的操作。也可以看出来确实是流动，传播，充满了stream的味道。</p>
<p>从这里也能看出来为何一开始是双向链表而不是单向的，因为要通过pre指针构造sink链表。</p>
<p>但是这里就有一个问题了，为什么不直接用一开始的双向链表，而要在创建一个sink链表呢？</p>
<p>我个人觉得有几个原因：</p>
<ol>
<li>因为当前处于结果态节点，想从头流动执行，需要当前指针先指向头节点，所以必须遍历一遍。</li>
<li>重新构建一个纯净的sink链表，来达到<code>不变性</code>的性质。保持之前的数据和节点等不可变。</li>
<li>双向链表只负责存储数据和操作。真正的执行通过sink链表来执行，达到<code>单一职责</code>和<code>分层清晰</code>。</li>
<li>其中或许还有并行流并发的问题。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/JAVA-spring%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/JAVA-spring%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93.html" class="post-title-link" itemprop="url">JAVA-LocalDateTime时间格式化，转换时间戳和源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-30 00:00:00" itemprop="dateCreated datePublished" datetime="2022-11-30T00:00:00+08:00">2022-11-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span id="/JAVA-spring%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93.html" class="post-meta-item leancloud_visitors" data-flag-title="JAVA-LocalDateTime时间格式化，转换时间戳和源码分析" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/JAVA-spring%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/JAVA-spring%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JAVA-LocalDateTime时间格式化，转换时间戳和源码分析"><a href="#JAVA-LocalDateTime时间格式化，转换时间戳和源码分析" class="headerlink" title="JAVA-LocalDateTime时间格式化，转换时间戳和源码分析"></a>JAVA-LocalDateTime时间格式化，转换时间戳和源码分析</h1><h2 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h2><p><code>LocalDateTime</code>作为java8新加的时间类型，也是后面开发中常用的时间类型。</p>
<p>作为时间类型，最关注的点无非是这几个</p>
<ul>
<li>获取当前时间</li>
<li>获取指定时间</li>
<li>时间格式化</li>
<li>时间转时间戳</li>
<li>时间戳转时间</li>
<li>时间比较</li>
<li>时间加减</li>
</ul>
<p>这些点通过<code>LocalDateTime</code>来操作，都会比较简单</p>
<h3 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h3><p>只需要now一下就可以获取到当前的时间，还是很方便的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now();</span><br></pre></td></tr></table></figure>

<p>再看一下之前的<code>Date</code>类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure>

<h3 id="获取指定时间"><a href="#获取指定时间" class="headerlink" title="获取指定时间"></a>获取指定时间</h3><p>这个有比较多的方式</p>
<ul>
<li>通过原来的<code>date</code>和<code>dateTime</code>类型来生成</li>
<li>通过传年月日时分秒生成</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2022</span>,<span class="number">11</span>,<span class="number">30</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>原来<code>Date</code>类的方式。比较奇怪，他的年份会+1900，所以2022年就得是122，月份也会+1,所以11月就是10.但是这个方法呢后面会被删除，已经被标记为弃用了，使用<code>Calendar</code>代替。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">122</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>看一下<code>Calendar</code>的使用。这个年份就正常了，是2022，但是月份还是会+1.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">calendar.set(<span class="number">2022</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<h3 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h3><p>时间格式化都是通过<code>format</code>函数,需要传一个<code>DateTimeFormatter</code>对象进去，我们可以通过<code>DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)</code>来生成自己想要的格式。</p>
<p>DateTimeFormatter类里面也有一些定义好的格式可以直接用,除了下面列出的还有一些其他的，感兴趣可以看一下，不过我觉得都没啥用。</p>
<ul>
<li>ISO_DATE_TIME         2011-12-03T10:15:30</li>
<li>ISO_OFFSET_DATE_TIME  2011-12-03T10:15:30+01:00</li>
<li>ISO_LOCAL_DATE_TIME   2011-12-03T10:15:30</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>看一下<code>Date</code>的格式化。这个需要借用<code>SimpleDateFormat</code>类来完成格式化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">format.format(date);</span><br></pre></td></tr></table></figure>

<h3 id="时间转时间戳"><a href="#时间转时间戳" class="headerlink" title="时间转时间戳"></a>时间转时间戳</h3><p>时间转时间戳分为两种，一种是当你已经有一个<code>LocalDateTime</code>类型的时间了，需要转换成秒或者毫秒的时间戳。</p>
<h4 id="时间转换秒级时间戳"><a href="#时间转换秒级时间戳" class="headerlink" title="时间转换秒级时间戳"></a>时间转换秒级时间戳</h4><p>只需要直接用<code>toEpochSecond</code>方法就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">time.toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>));</span><br></pre></td></tr></table></figure>

<p><code>Date</code>类型没有办法直接获取秒级时间戳，只能获取毫秒级再转秒。</p>
<h4 id="时间转换毫秒级时间戳"><a href="#时间转换毫秒级时间戳" class="headerlink" title="时间转换毫秒级时间戳"></a>时间转换毫秒级时间戳</h4><p>转换毫秒需要先转换成<code>instant</code>对象，然后才能转换成毫秒级时间戳。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">time.toInstant(ZoneOffset.ofHours(<span class="number">8</span>)).toEpochMilli();</span><br></pre></td></tr></table></figure>

<p><code>Date</code>获取毫秒就很简单了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">date.getTime();</span><br></pre></td></tr></table></figure>

<h3 id="字符串转换成时间戳"><a href="#字符串转换成时间戳" class="headerlink" title="字符串转换成时间戳"></a>字符串转换成时间戳</h3><p>时间转时间戳分为两种，除了上面的，还有一种是有一个格式化好的字符串，比如<code>2022-12-18 10:00:00</code>这种，但是这个是字符串并不是时间类型。所以要先转换成<code>LocalDateTime</code>类型，然后就可以转换成时间戳了。</p>
<p>其实就是上面格式化的一种反向操作。使用<code>parse</code>方法就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime.parse(<span class="string">&quot;2022-12-18 10:00:00&quot;</span>, DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">LocalDateTime.parse(<span class="string">&quot;2022-12-18&quot;</span>, DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><code>Date</code>类型的字符串转时间戳也是通过<code>SimpleDateFormat</code>类来完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> format.parse(<span class="string">&quot;2022-12-18 10:00:00&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="时间戳转时间"><a href="#时间戳转时间" class="headerlink" title="时间戳转时间"></a>时间戳转时间</h3><p>那如果我们现在转换成时间戳以后又想转换成时间呢？也可以通过<code>instant</code>对象来做到。</p>
<h4 id="毫秒时间戳转时间"><a href="#毫秒时间戳转时间" class="headerlink" title="毫秒时间戳转时间"></a>毫秒时间戳转时间</h4><p><code>Instant.ofEpochSecond(1671365543834)</code>是将一个毫秒时间戳转换成一个instant对象。在通过<code>ofInstant</code>方法就可以将instant对象转换成LocalDateTime对象了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime.ofInstant(Instant.ofEpochSecond(<span class="number">1671365543834</span>), ZoneOffset.ofHours(<span class="number">8</span>));</span><br></pre></td></tr></table></figure>

<p><code>Date</code>类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1669759566000L</span>);</span><br></pre></td></tr></table></figure>

<h4 id="秒时间戳转时间"><a href="#秒时间戳转时间" class="headerlink" title="秒时间戳转时间"></a>秒时间戳转时间</h4><p><code>Instant.ofEpochMilli(1671365543)</code>是将一个秒时间戳转换成<code>instant</code>对象。和上面的区别就是使用的是<code>ofEpochMilli</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime.ofInstant(Instant.ofEpochMilli(<span class="number">1671365543</span>), ZoneOffset.ofHours(<span class="number">8</span>));</span><br></pre></td></tr></table></figure>

<p><code>Date</code>类不支持秒，只能把秒转成毫秒在转时间戳。</p>
<h3 id="时间比较"><a href="#时间比较" class="headerlink" title="时间比较"></a>时间比较</h3><p>通过<code>compareTo</code>方法可以进行时间的一个比较大小。如果大于会返回1，小于返回-1.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">time.compareTo(LocalDateTime.now());</span><br></pre></td></tr></table></figure>

<p><code>Date</code>也是通过<code>compareTo</code>方法进行比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1669759566000L</span>);</span><br><span class="line">date.compareTo(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure>

<h3 id="时间加减"><a href="#时间加减" class="headerlink" title="时间加减"></a>时间加减</h3><p>如果加上几天，就是<code>plusDays</code>。加几个小时就是<code>plusHours</code>。当然也可以使用<code>plus</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">time.plusDays(<span class="number">1</span>);</span><br><span class="line">time.plusHours(<span class="number">1</span>);</span><br><span class="line">time.plus(Period.ofDays(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>如果减去几天就是<code>minusDays</code>.减去几个小时就是<code>minusHours</code>。当然也可以使用<code>minus</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">time.minusDays(<span class="number">1</span>);</span><br><span class="line">time.minusHours(<span class="number">1</span>);</span><br><span class="line">time.minus(Period.ofDays(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p><code>Date</code>类不支持时间加减，只能通过<code>Calendar</code>类实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">calendar.setTime(date);</span><br><span class="line">calendar.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//减去</span></span><br><span class="line">calendar.add(Calendar.DAY_OF_MONTH, -<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="时间格式在入参出参中的使用"><a href="#时间格式在入参出参中的使用" class="headerlink" title="时间格式在入参出参中的使用"></a>时间格式在入参出参中的使用</h3><p>入参的时候需要通过<code>JsonFormat</code>注解来指定需要的是字符串类型和对应的时间格式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(shape = JsonFormat.Shape.STRING, pattern=&quot;yyyy-MM-dd&quot;)</span></span><br><span class="line"><span class="keyword">private</span> LocalDate date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonFormat(shape = JsonFormat.Shape.STRING, pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime time;</span><br></pre></td></tr></table></figure>

<p>出参的时候就很简单了，因为只是返回了一个字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String time;</span><br></pre></td></tr></table></figure>

<h3 id="格式化时间源码分析"><a href="#格式化时间源码分析" class="headerlink" title="格式化时间源码分析"></a>格式化时间源码分析</h3><p>格式化的时候这两个年是不一样的，具体的可以看一下源码。我们来找一下。</p>
<p>首先点进去是LocalDateTime这个类里面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  <span class="comment">// override for Javadoc and performance</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">format</span><span class="params">(DateTimeFormatter formatter)</span> &#123;</span><br><span class="line">    <span class="comment">//判断参数是否空</span></span><br><span class="line">    Objects.requireNonNull(formatter, <span class="string">&quot;formatter&quot;</span>);</span><br><span class="line">    <span class="comment">//真正的执行格式化</span></span><br><span class="line">    <span class="keyword">return</span> formatter.format(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来点进去，看一下怎么执行的，可以看到又调用了<code>formatTo</code>这个函数，说明主要的格式化代码都在这里面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">format</span><span class="params">(TemporalAccessor temporal)</span> &#123;</span><br><span class="line">       <span class="comment">//创建了一个32长度的字符串构建器</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">32</span>);</span><br><span class="line">        <span class="comment">//格式化主要代码</span></span><br><span class="line">        formatTo(temporal, buf);</span><br><span class="line">        <span class="comment">//转成字符串</span></span><br><span class="line">        <span class="keyword">return</span> buf.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看一下<code>formatTo</code>函数，可以发现主要是调用<code>printerParser</code>这个对象的<code>format</code>方法，那我们这个对象是哪来的呢，是在一开始指定格式化类型的时候来的。不同的格式化类型对应不同的解析器，也就会执行不同的<code>format</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">formatTo</span><span class="params">(TemporalAccessor temporal, Appendable appendable)</span> &#123;</span><br><span class="line">        <span class="comment">//判断参数，这里不用管</span></span><br><span class="line">        Objects.requireNonNull(temporal, <span class="string">&quot;temporal&quot;</span>);</span><br><span class="line">        Objects.requireNonNull(appendable, <span class="string">&quot;appendable&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个DateTimePrintContext对象</span></span><br><span class="line">            <span class="type">DateTimePrintContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateTimePrintContext</span>(temporal, <span class="built_in">this</span>);</span><br><span class="line">            <span class="comment">//判断，显然我们之前传过来的就是一个StringBuilder</span></span><br><span class="line">            <span class="keyword">if</span> (appendable <span class="keyword">instanceof</span> StringBuilder) &#123;</span><br><span class="line">                <span class="comment">//主要看这个怎么处理  这里有个 printerParser 对象，这个对象是怎么来的呢，其实是上面DateTimeFormatter.ofPattern的时候给创建的。</span></span><br><span class="line">                printerParser.format(context, (StringBuilder) appendable);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//这里其实就是如果传的不是个StringBuilder，就在创建一个然后执行</span></span><br><span class="line">                <span class="comment">// buffer output to avoid writing to appendable in case of error</span></span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">32</span>);</span><br><span class="line">                printerParser.format(context, buf);</span><br><span class="line">                appendable.append(buf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DateTimeException</span>(ex.getMessage(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看一下<code>ofPattern</code>这个方法里面是怎样的吧。这里是创建了一个 时间格式化的建造者，然后把我们这个字符串添加进去了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的字符串就是我们传的 yyyy-MM-dd HH:mm:ss</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DateTimeFormatter <span class="title function_">ofPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DateTimeFormatterBuilder</span>().appendPattern(pattern).toFormatter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下<code>appendPattern</code>里面是怎么把字符串加进去的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title function_">appendPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">    <span class="comment">//忽略</span></span><br><span class="line">    Objects.requireNonNull(pattern, <span class="string">&quot;pattern&quot;</span>);</span><br><span class="line">    <span class="comment">//主要的解析逻辑</span></span><br><span class="line">    parsePattern(pattern);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续追踪到<code>parsePattern</code>方法里面。这个方法代码比较多，这里只关注我们想知道的。其余的有兴趣的可以看一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parsePattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">    <span class="comment">//这里给字符串做循环，注意 pattern = yyyy-MM-dd HH:mm:ss 这个字符串。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>; pos &lt; pattern.length(); pos++) &#123;</span><br><span class="line">        <span class="comment">//取出字符 比如第一个就是 y 对应的ASCII码就是121</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">cur</span> <span class="operator">=</span> pattern.charAt(pos);</span><br><span class="line">        <span class="comment">//这里就是判断是否是大小写字母了，也就是A-Z或者a-z</span></span><br><span class="line">        <span class="keyword">if</span> ((cur &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; cur &lt;= <span class="string">&#x27;Z&#x27;</span>) || (cur &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; cur &lt;= <span class="string">&#x27;z&#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">//初始化变量 start = 0 pos = 1</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> pos++;</span><br><span class="line">            <span class="comment">//这里做一个循环，目的其实就是找出相同的字符有几个，比如y有4个，pos就会变成4</span></span><br><span class="line">            <span class="keyword">for</span> ( ; pos &lt; pattern.length() &amp;&amp; pattern.charAt(pos) == cur; pos++);  <span class="comment">// short loop</span></span><br><span class="line">            <span class="comment">//这里就是算出具体的数量 4 - 0 = 4</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> pos - start;</span><br><span class="line">            <span class="comment">// padding  这里忽略 我们这里面没有这个字符</span></span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="string">&#x27;p&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">pad</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (pos &lt; pattern.length()) &#123;</span><br><span class="line">                    cur = pattern.charAt(pos);</span><br><span class="line">                    <span class="keyword">if</span> ((cur &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; cur &lt;= <span class="string">&#x27;Z&#x27;</span>) || (cur &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; cur &lt;= <span class="string">&#x27;z&#x27;</span>)) &#123;</span><br><span class="line">                        pad = count;</span><br><span class="line">                        start = pos++;</span><br><span class="line">                        <span class="keyword">for</span> ( ; pos &lt; pattern.length() &amp;&amp; pattern.charAt(pos) == cur; pos++);  <span class="comment">// short loop</span></span><br><span class="line">                        count = pos - start;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pad == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                            <span class="string">&quot;Pad letter &#x27;p&#x27; must be followed by valid pad pattern: &quot;</span> + pattern);</span><br><span class="line">                &#125;</span><br><span class="line">                padNext(pad); <span class="comment">// pad and continue parsing</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//接下来是主要逻辑。</span></span><br><span class="line">            <span class="comment">// main rules</span></span><br><span class="line">            <span class="comment">//从hashMap里面取出对应的值，这个map放在下面了。y取出来就是 YEAR_OF_ERA</span></span><br><span class="line">            <span class="type">TemporalField</span> <span class="variable">field</span> <span class="operator">=</span> FIELD_MAP.get(cur);</span><br><span class="line">            <span class="comment">//判断map里面取出来的是否为空，如果不为空就直接解析，如果为空就接着往下走，看是不是 zvZOXxWwY 这几个，如果都不是就会报错了</span></span><br><span class="line">            <span class="keyword">if</span> (field != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//我们y是能取出来的，直接解析这里 cur = y, count = 4, field = YEAR_OF_ERA</span></span><br><span class="line">                parseField(cur, count, field);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">4</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">4</span>) &#123;</span><br><span class="line">                    appendZoneText(TextStyle.FULL);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    appendZoneText(TextStyle.SHORT);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;V&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count != <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Pattern letter count must be 2: &quot;</span> + cur);</span><br><span class="line">                &#125;</span><br><span class="line">                appendZoneId();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count &lt; <span class="number">4</span>) &#123;</span><br><span class="line">                    appendOffset(<span class="string">&quot;+HHMM&quot;</span>, <span class="string">&quot;+0000&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">4</span>) &#123;</span><br><span class="line">                    appendLocalizedOffset(TextStyle.FULL);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">5</span>) &#123;</span><br><span class="line">                    appendOffset(<span class="string">&quot;+HH:MM:ss&quot;</span>,<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                    appendLocalizedOffset(TextStyle.SHORT);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">4</span>) &#123;</span><br><span class="line">                    appendLocalizedOffset(TextStyle.FULL);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Pattern letter count must be 1 or 4: &quot;</span> + cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">                &#125;</span><br><span class="line">                appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count == <span class="number">1</span> ? <span class="number">0</span> : <span class="number">1</span>)], <span class="string">&quot;Z&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">zero</span> <span class="operator">=</span> (count == <span class="number">1</span> ? <span class="string">&quot;+00&quot;</span> : (count % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">&quot;+0000&quot;</span> : <span class="string">&quot;+00:00&quot;</span>));</span><br><span class="line">                appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count == <span class="number">1</span> ? <span class="number">0</span> : <span class="number">1</span>)], zero);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// Fields defined by Locale</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">                &#125;</span><br><span class="line">                appendInternal(<span class="keyword">new</span> <span class="title class_">WeekBasedFieldPrinterParser</span>(cur, count));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;w&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// Fields defined by Locale</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">                &#125;</span><br><span class="line">                appendInternal(<span class="keyword">new</span> <span class="title class_">WeekBasedFieldPrinterParser</span>(cur, count));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;Y&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// Fields defined by Locale</span></span><br><span class="line">                appendInternal(<span class="keyword">new</span> <span class="title class_">WeekBasedFieldPrinterParser</span>(cur, count));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown pattern letter: &quot;</span> + cur);</span><br><span class="line">            &#125;</span><br><span class="line">            pos--;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// parse literals</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> pos++;</span><br><span class="line">            <span class="keyword">for</span> ( ; pos &lt; pattern.length(); pos++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pattern.charAt(pos) == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pos + <span class="number">1</span> &lt; pattern.length() &amp;&amp; pattern.charAt(pos + <span class="number">1</span>) == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">                        pos++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;  <span class="comment">// end of literal</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pos &gt;= pattern.length()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Pattern ends with an incomplete string literal: &quot;</span> + pattern);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> pattern.substring(start + <span class="number">1</span>, pos);</span><br><span class="line">            <span class="keyword">if</span> (str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                appendLiteral(<span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                appendLiteral(str.replace(<span class="string">&quot;&#x27;&#x27;&quot;</span>, <span class="string">&quot;&#x27;&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            optionalStart();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (active.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Pattern invalid as it contains ] without previous [&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            optionalEnd();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;&#123;&#x27;</span> || cur == <span class="string">&#x27;&#125;&#x27;</span> || cur == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Pattern includes reserved character: &#x27;&quot;</span> + cur + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// - : 这两个符号就会走到这里了</span></span><br><span class="line">            appendLiteral(cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下通过不同的key取值的map</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时代</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;G&#x27;</span>, ChronoField.ERA);                       <span class="comment">// SDF, LDML (different to both for 1/2 chars)</span></span><br><span class="line"><span class="comment">//这个时代的年份，也就是我们常用的年份yyyy</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;y&#x27;</span>, ChronoField.YEAR_OF_ERA);               <span class="comment">// SDF, LDML</span></span><br><span class="line"><span class="comment">//单纯的年份</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;u&#x27;</span>, ChronoField.YEAR);                      <span class="comment">// LDML (different in SDF)</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;Q&#x27;</span>, IsoFields.QUARTER_OF_YEAR);             <span class="comment">// LDML (removed quarter from 310)</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;q&#x27;</span>, IsoFields.QUARTER_OF_YEAR);             <span class="comment">// LDML (stand-alone)</span></span><br><span class="line"><span class="comment">//一年里面的月份，也是我们常用的月份 MM</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;M&#x27;</span>, ChronoField.MONTH_OF_YEAR);             <span class="comment">// SDF, LDML</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;L&#x27;</span>, ChronoField.MONTH_OF_YEAR);             <span class="comment">// SDF, LDML (stand-alone)</span></span><br><span class="line"><span class="comment">//一年里面的天，我们基本不用这个作为日子</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;D&#x27;</span>, ChronoField.DAY_OF_YEAR);               <span class="comment">// SDF, LDML</span></span><br><span class="line"><span class="comment">//一个月里面的天，我们常用这个获取多少号</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;d&#x27;</span>, ChronoField.DAY_OF_MONTH);              <span class="comment">// SDF, LDML</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;F&#x27;</span>, ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH);  <span class="comment">// SDF, LDML</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;E&#x27;</span>, ChronoField.DAY_OF_WEEK);               <span class="comment">// SDF, LDML (different to both for 1/2 chars)</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;c&#x27;</span>, ChronoField.DAY_OF_WEEK);               <span class="comment">// LDML (stand-alone)</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;e&#x27;</span>, ChronoField.DAY_OF_WEEK);               <span class="comment">// LDML (needs localized week number)</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;a&#x27;</span>, ChronoField.AMPM_OF_DAY);               <span class="comment">// SDF, LDML</span></span><br><span class="line"><span class="comment">//一天里面的小时，常用的小时 HH</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;H&#x27;</span>, ChronoField.HOUR_OF_DAY);               <span class="comment">// SDF, LDML</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;k&#x27;</span>, ChronoField.CLOCK_HOUR_OF_DAY);         <span class="comment">// SDF, LDML</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;K&#x27;</span>, ChronoField.HOUR_OF_AMPM);              <span class="comment">// SDF, LDML</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;h&#x27;</span>, ChronoField.CLOCK_HOUR_OF_AMPM);        <span class="comment">// SDF, LDML</span></span><br><span class="line"><span class="comment">//一个小时里面的分钟，常用的分钟 mm</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;m&#x27;</span>, ChronoField.MINUTE_OF_HOUR);            <span class="comment">// SDF, LDML</span></span><br><span class="line"><span class="comment">//一分钟里面的秒数，常用的秒数 ss</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;s&#x27;</span>, ChronoField.SECOND_OF_MINUTE);          <span class="comment">// SDF, LDML</span></span><br><span class="line"><span class="comment">//这个大S基本不用，这是秒里面的纳秒</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;S&#x27;</span>, ChronoField.NANO_OF_SECOND);            <span class="comment">// LDML (SDF uses milli-of-second number)</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;A&#x27;</span>, ChronoField.MILLI_OF_DAY);              <span class="comment">// LDML</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;n&#x27;</span>, ChronoField.NANO_OF_SECOND);            <span class="comment">// 310 (proposed for LDML)</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;N&#x27;</span>, ChronoField.NANO_OF_DAY);               <span class="comment">// 310 (proposed for LDML)</span></span><br></pre></td></tr></table></figure>

<p>继续深入，直接解析y的方法<code>parseField</code>。可以看到这个是根据我们格式化的字母执行不同的代码，比如u,y都执行到一个代码块。4个y走到了<code>appendValue</code>方法里面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseField</span><span class="params">(<span class="type">char</span> cur, <span class="type">int</span> count, TemporalField field)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">standalone</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">switch</span> (cur) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">            <span class="comment">//判断数量</span></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">//yy走这里</span></span><br><span class="line">                appendValueReduced(field, <span class="number">2</span>, <span class="number">2</span>, ReducedPrinterParser.BASE_DATE);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &lt; <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="comment">//y or yyy走这里</span></span><br><span class="line">                appendValue(field, count, <span class="number">19</span>, SignStyle.NORMAL);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// yyyy走这里 field = YEAR_OF_ERA count = 4</span></span><br><span class="line">                appendValue(field, count, <span class="number">19</span>, SignStyle.EXCEEDS_PAD);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid pattern \&quot;cc\&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*fallthrough*/</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">            standalone = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">/*fallthrough*/</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            <span class="keyword">switch</span> (count) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="comment">//两个MM输出月份走到这里</span></span><br><span class="line">                    <span class="keyword">if</span> (cur == <span class="string">&#x27;c&#x27;</span> || cur == <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">                        appendInternal(<span class="keyword">new</span> <span class="title class_">WeekBasedFieldPrinterParser</span>(cur, count));</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">                        appendText(field, TextStyle.SHORT);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                            appendValue(field);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//经过判断走到这里</span></span><br><span class="line">                            appendValue(field, <span class="number">2</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    appendText(field, standalone ? TextStyle.SHORT_STANDALONE : TextStyle.SHORT);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    appendText(field, standalone ? TextStyle.FULL_STANDALONE : TextStyle.FULL);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                    appendText(field, standalone ? TextStyle.NARROW_STANDALONE : TextStyle.NARROW);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                appendText(field, TextStyle.SHORT);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:</span><br><span class="line">            <span class="keyword">switch</span> (count) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    appendText(field, TextStyle.SHORT);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    appendText(field, TextStyle.FULL);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                    appendText(field, TextStyle.NARROW);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">            appendFraction(NANO_OF_SECOND, count, count, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                appendValue(field);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;K&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                appendValue(field);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">//可以看到dd HH mm ss也是走到这里，最终也是通过NumberPrinterParser这个对象来格式化</span></span><br><span class="line">                appendValue(field, count);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                appendValue(field);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">                appendValue(field, count);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                appendValue(field);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                appendValue(field, count);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下<code>appendValue</code>方法。field &#x3D; YEAR_OF_ERA,minWidth &#x3D; 4, maxWidth &#x3D; 19, signStyle &#x3D; SignStyle.EXCEEDS_PAD。前面是一些判断，重点是创建了一个<code>NumberPrinterParser</code>的对象。最后转换的时候其实就是通过这个对象来转换的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title function_">appendValue</span><span class="params">(</span></span><br><span class="line"><span class="params">    TemporalField field, <span class="type">int</span> minWidth, <span class="type">int</span> maxWidth, SignStyle signStyle)</span> &#123;</span><br><span class="line">    <span class="comment">//这里不执行 忽略</span></span><br><span class="line">    <span class="keyword">if</span> (minWidth == maxWidth &amp;&amp; signStyle == SignStyle.NOT_NEGATIVE) &#123;</span><br><span class="line">        <span class="keyword">return</span> appendValue(field, maxWidth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    Objects.requireNonNull(field, <span class="string">&quot;field&quot;</span>);</span><br><span class="line">    Objects.requireNonNull(signStyle, <span class="string">&quot;signStyle&quot;</span>);</span><br><span class="line">    <span class="comment">//一些校验规则</span></span><br><span class="line">    <span class="keyword">if</span> (minWidth &lt; <span class="number">1</span> || minWidth &gt; <span class="number">19</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;The minimum width must be from 1 to 19 inclusive but was &quot;</span> + minWidth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxWidth &lt; <span class="number">1</span> || maxWidth &gt; <span class="number">19</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;The maximum width must be from 1 to 19 inclusive but was &quot;</span> + maxWidth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxWidth &lt; minWidth) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;The maximum width must exceed or equal the minimum width but &quot;</span> +</span><br><span class="line">                maxWidth + <span class="string">&quot; &lt; &quot;</span> + minWidth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重点是这里，创建了一个 NumberPrinterParser的对象，把参数传进去了。</span></span><br><span class="line">    <span class="type">NumberPrinterParser</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberPrinterParser</span>(field, minWidth, maxWidth, signStyle);</span><br><span class="line">    appendValue(pp);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下<code>NumberPrinterParser</code>类。还记得最开始格式化的时候那一段代码<code>printerParser.format(context, (StringBuilder) appendable);</code>吗，实际调用的就是这里。？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//构造方法赋值</span></span><br><span class="line">NumberPrinterParser(TemporalField field, <span class="type">int</span> minWidth, <span class="type">int</span> maxWidth, SignStyle signStyle) &#123;</span><br><span class="line">    <span class="comment">// validated by caller</span></span><br><span class="line">    <span class="built_in">this</span>.field = field;</span><br><span class="line">    <span class="built_in">this</span>.minWidth = minWidth;</span><br><span class="line">    <span class="built_in">this</span>.maxWidth = maxWidth;</span><br><span class="line">    <span class="built_in">this</span>.signStyle = signStyle;</span><br><span class="line">    <span class="built_in">this</span>.subsequentWidth = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//格式化方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">format</span><span class="params">(DateTimePrintContext context, StringBuilder buf)</span> &#123;</span><br><span class="line">    <span class="comment">//从context上下文中获取字段 field = YEAR_OF_ERA  context实际包含了真正的时间 2022-12-01T00:00:00</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">valueLong</span> <span class="operator">=</span> context.getValue(field);</span><br><span class="line">    <span class="keyword">if</span> (valueLong == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取到以后 value = 2022</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> getValue(context, valueLong);</span><br><span class="line">    <span class="type">DecimalStyle</span> <span class="variable">decimalStyle</span> <span class="operator">=</span> context.getDecimalStyle();</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (value == Long.MIN_VALUE ? <span class="string">&quot;9223372036854775808&quot;</span> : Long.toString(Math.abs(value)));</span><br><span class="line">    <span class="keyword">if</span> (str.length() &gt; maxWidth) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DateTimeException</span>(<span class="string">&quot;Field &quot;</span> + field +</span><br><span class="line">            <span class="string">&quot; cannot be printed as the value &quot;</span> + value +</span><br><span class="line">            <span class="string">&quot; exceeds the maximum print width of &quot;</span> + maxWidth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转换一个格式类型</span></span><br><span class="line">    str = decimalStyle.convertNumberToI18N(str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这些条件都不满足，忽略</span></span><br><span class="line">    <span class="keyword">if</span> (value &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (signStyle) &#123;</span><br><span class="line">            <span class="keyword">case</span> EXCEEDS_PAD:</span><br><span class="line">                <span class="keyword">if</span> (minWidth &lt; <span class="number">19</span> &amp;&amp; value &gt;= EXCEED_POINTS[minWidth]) &#123;</span><br><span class="line">                    buf.append(decimalStyle.getPositiveSign());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ALWAYS:</span><br><span class="line">                buf.append(decimalStyle.getPositiveSign());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (signStyle) &#123;</span><br><span class="line">            <span class="keyword">case</span> NORMAL:</span><br><span class="line">            <span class="keyword">case</span> EXCEEDS_PAD:</span><br><span class="line">            <span class="keyword">case</span> ALWAYS:</span><br><span class="line">                buf.append(decimalStyle.getNegativeSign());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NOT_NEGATIVE:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DateTimeException</span>(<span class="string">&quot;Field &quot;</span> + field +</span><br><span class="line">                    <span class="string">&quot; cannot be printed as the value &quot;</span> + value +</span><br><span class="line">                    <span class="string">&quot; cannot be negative according to the SignStyle&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//填充0 也就是yyyy minWidth = 4就会填充0 MM minWidth = 2如果 1月就会填充01，一个M就不会走到循环填充0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; minWidth - str.length(); i++) &#123;</span><br><span class="line">        buf.append(decimalStyle.getZeroDigit());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出到buf中</span></span><br><span class="line">    buf.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上面的代码，但是<code>NumberPrinterParser</code>其实只是解析了<code>yMdHms</code>这些格式的。也可以再看一下<code>M</code>的确认一下。</p>
<p>首先是<code>appendValue</code>这个方法。大差不差，除了传到解析器的参数不一样，没啥区别，其实dd这些也都一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title function_">appendValue</span><span class="params">(TemporalField field, <span class="type">int</span> width)</span> &#123;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    Objects.requireNonNull(field, <span class="string">&quot;field&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (width &lt; <span class="number">1</span> || width &gt; <span class="number">19</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;The width must be from 1 to 19 inclusive but was &quot;</span> + width);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以发现MM也是用的yyyy这个解析器格式化的，但是后面三个参数不一样</span></span><br><span class="line">    <span class="type">NumberPrinterParser</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberPrinterParser</span>(field, width, width, SignStyle.NOT_NEGATIVE);</span><br><span class="line">    appendValue(pp);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们<code>-</code>,<code>:</code>这些格式化符号的输出呢？是通过另外一个解析器，它先是取到<code>char</code>类型的一个字符来判断的时候会走到else里面然后走<code>appendLiteral(cur);</code>这个方法。看一下这个方法里面。这里可以看到主要使用的是 CharLiteralPrinterParser 这个解析器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title function_">appendLiteral</span><span class="params">(<span class="type">char</span> literal)</span> &#123;</span><br><span class="line">    <span class="comment">//这里可以看到主要使用的是 CharLiteralPrinterParser 这个解析器</span></span><br><span class="line">    appendInternal(<span class="keyword">new</span> <span class="title class_">CharLiteralPrinterParser</span>(literal));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下 CharLiteralPrinterParser 这个解析器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">CharLiteralPrinterParser(<span class="type">char</span> literal) &#123;</span><br><span class="line">    <span class="built_in">this</span>.literal = literal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">format</span><span class="params">(DateTimePrintContext context, StringBuilder buf)</span> &#123;</span><br><span class="line">    <span class="comment">//简单粗暴 直接把 - : 这种符号添加到字符串里面</span></span><br><span class="line">    buf.append(literal);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看一下为啥我们刚才上面说的，y代表 YEAR_OF_ERA，为啥就能从<code>2022-12-01</code>里面取到<code>2022</code>呢？这个可以看到我们<code>NumberPrinterParser</code>这个解析器里面主要调用了一个<code>context.getValue(field)</code>方法。</p>
<p>主要是<code>temporal.getLong(field)</code>方法，其实temporal就是我们的日期时间，在我们一开始创建上下文的时候过来的。回忆一下上面的创建。这里的temporal可以再往上一层传过来的，传的其实就是<code>LocalDateTime的对象</code>。</p>
<blockquote>
<p>new DateTimePrintContext(temporal, this)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Long <span class="title function_">getValue</span><span class="params">(TemporalField field)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//主要是这里，其实temporal就是我们的日期时间，在我们一开始创建上下文的时候过来的。</span></span><br><span class="line">        <span class="keyword">return</span> temporal.getLong(field);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DateTimeException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (optional &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们再看一下<code>getLong</code>方法。可以看到有一个类型判断，<code>yMdHms</code>这几个类型就会走到if里面，如果是时间的 Hms这几个调用time.getLong方法，yMd日期的调用日期的getLong方法。Y的话就会走到 <code>getFrom</code> 这个方法。而且是通过<code>field</code>调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLong</span><span class="params">(TemporalField field)</span> &#123;</span><br><span class="line">    <span class="comment">//类型判断 yMdHms这几个走的这里面</span></span><br><span class="line">    <span class="keyword">if</span> (field <span class="keyword">instanceof</span> ChronoField) &#123;</span><br><span class="line">        <span class="type">ChronoField</span> <span class="variable">f</span> <span class="operator">=</span> (ChronoField) field;</span><br><span class="line">        <span class="comment">//如果是时间的 Hms这几个调用time.getLong方法，yMd日期的调用日期的getLong方法</span></span><br><span class="line">        <span class="keyword">return</span> (f.isTimeBased() ? time.getLong(field) : date.getLong(field));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Y走这个方法</span></span><br><span class="line">    <span class="keyword">return</span> field.getFrom(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下<code>getFrom</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getFrom</span><span class="params">(TemporalAccessor temporal)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rangeUnit == WEEKS) &#123;  <span class="comment">// day-of-week</span></span><br><span class="line">        <span class="keyword">return</span> localizedDayOfWeek(temporal);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rangeUnit == MONTHS) &#123;  <span class="comment">// week-of-month</span></span><br><span class="line">        <span class="keyword">return</span> localizedWeekOfMonth(temporal);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rangeUnit == YEARS) &#123;  <span class="comment">// week-of-year</span></span><br><span class="line">        <span class="keyword">return</span> localizedWeekOfYear(temporal);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rangeUnit == WEEK_BASED_YEARS) &#123;</span><br><span class="line">        <span class="keyword">return</span> localizedWeekOfWeekBasedYear(temporal);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rangeUnit == FOREVER) &#123;</span><br><span class="line">        <span class="comment">// YYYY 大写的Y走的是这里</span></span><br><span class="line">        <span class="keyword">return</span> localizedWeekBasedYear(temporal);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;unreachable, rangeUnit: &quot;</span> + rangeUnit + <span class="string">&quot;, this: &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果大写的<code>Y</code>格式化就会走下面的函数，主要就是取出年份以后计算周数，如果周数&#x3D;0就认为是上一年的，年份-1，如果周数大于等于下一年的周数就年份+1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">localizedWeekBasedYear</span><span class="params">(TemporalAccessor temporal)</span> &#123;</span><br><span class="line">    <span class="comment">//获取到这周的第几天 第5天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dow</span> <span class="operator">=</span> localizedDayOfWeek(temporal);</span><br><span class="line">    <span class="comment">//获取日期中的年份 2021</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> temporal.get(YEAR);</span><br><span class="line">    <span class="comment">//获取今年的第几天 2021-12-30 是 364天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">doy</span> <span class="operator">=</span> temporal.get(DAY_OF_YEAR);</span><br><span class="line">    <span class="comment">//这周开始的偏移量 5</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> startOfWeekOffset(doy, dow);</span><br><span class="line">    <span class="comment">//今年的第几周 53周</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">week</span> <span class="operator">=</span> computeWeek(offset, doy);</span><br><span class="line">    <span class="comment">//如果这周是0周，就是上一年的，年份就-1</span></span><br><span class="line">    <span class="keyword">if</span> (week == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Day is in end of week of previous year; return the previous year</span></span><br><span class="line">        <span class="keyword">return</span> year - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果接近年底，使用更高精度的逻辑</span></span><br><span class="line">        <span class="comment">//检查 如果年份的日期包含在下一年的部分的星期里面了</span></span><br><span class="line">        <span class="comment">// If getting close to end of year, use higher precision logic</span></span><br><span class="line">        <span class="comment">// Check if date of year is in partial week associated with next year</span></span><br><span class="line">        <span class="comment">//获取一年里面的天数 对象里面包含 最小1天 - 最大365天</span></span><br><span class="line">        <span class="type">ValueRange</span> <span class="variable">dayRange</span> <span class="operator">=</span> temporal.range(DAY_OF_YEAR);</span><br><span class="line">        <span class="comment">//获取到年份的长度，也就是365</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">yearLen</span> <span class="operator">=</span> (<span class="type">int</span>)dayRange.getMaximum();</span><br><span class="line">        <span class="comment">//下一年的周数 根据下面的计算公式得出 (7 + 5 + 366 - 1) / 7 = 53</span></span><br><span class="line">        <span class="comment">//这里为啥是366呢，因为yearLen是今年的天数也就是365 + 1，其实也就是到下一年去了。为的是计算下一年的第一周</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newYearWeek</span> <span class="operator">=</span> computeWeek(offset, yearLen + weekDef.getMinimalDaysInFirstWeek());</span><br><span class="line">        <span class="comment">//比较如果今年的这周大于等于下一年的周 就年份 +1 所以这里格式化就会出错了。</span></span><br><span class="line">        <span class="keyword">if</span> (week &gt;= newYearWeek) &#123;</span><br><span class="line">            <span class="keyword">return</span> year + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> year;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么是怎么计算今年的第几周的呢，看一下<code>computeWeek</code>方法。其实就是一个计算公式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//offset = 5 , day = 今年的第几天 364 天</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">computeWeek</span><span class="params">(<span class="type">int</span> offset, <span class="type">int</span> day)</span> &#123;</span><br><span class="line">    <span class="comment">//计算公式 ( 7 + 5 + （364 - 1）) / 7</span></span><br><span class="line">    <span class="keyword">return</span> ((<span class="number">7</span> + offset + (day - <span class="number">1</span>)) / <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个问题，就是我们用到了一个周的偏移量，这个偏移量怎么计算的呢，看一下这个方法<code>startOfWeekOffset</code>。以<code>2021-12-30</code>为例，day &#x3D; 364,dow &#x3D; 5</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">startOfWeekOffset</span><span class="params">(<span class="type">int</span> day, <span class="type">int</span> dow)</span> &#123;</span><br><span class="line">    <span class="comment">// offset of first day corresponding to the day of week in first 7 days (zero origin)</span></span><br><span class="line">    <span class="comment">//算出上一周 (364 - 5) % 7 = 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">weekStart</span> <span class="operator">=</span> Math.floorMod(day - dow, <span class="number">7</span>);</span><br><span class="line">    <span class="comment">// offset = -2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> -weekStart;</span><br><span class="line">    <span class="comment">//这里 2 + 1  &gt; 1会走进去</span></span><br><span class="line">    <span class="keyword">if</span> (weekStart + <span class="number">1</span> &gt; weekDef.getMinimalDaysInFirstWeek()) &#123;</span><br><span class="line">        <span class="comment">// The previous week has the minimum days in the current month to be a &#x27;week&#x27;</span></span><br><span class="line">        <span class="comment">//这里 7 - 2 = 5 返回的就是5</span></span><br><span class="line">        offset = <span class="number">7</span> - weekStart;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面看完了大写的<code>Y</code>，再来看一下小写的<code>y</code>。走的<code>getLong</code>方法。</p>
<p>日期的<code>getLong</code>方法。经过判断后主要看<code>get0</code>这个方法。可以看到这个命名就很随意了。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLong</span><span class="params">(TemporalField field)</span> &#123;</span><br><span class="line">    <span class="comment">//这个判断也会走进来</span></span><br><span class="line">    <span class="keyword">if</span> (field <span class="keyword">instanceof</span> ChronoField) &#123;</span><br><span class="line">        <span class="comment">//这两个判断忽略</span></span><br><span class="line">        <span class="keyword">if</span> (field == EPOCH_DAY) &#123;</span><br><span class="line">            <span class="keyword">return</span> toEpochDay();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (field == PROLEPTIC_MONTH) &#123;</span><br><span class="line">            <span class="keyword">return</span> getProlepticMonth();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这里</span></span><br><span class="line">        <span class="keyword">return</span> get0(field);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> field.getFrom(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下日期的<code>get0</code>方法。可以发现了，这里主要处理了这几种类型。我们常用的</p>
<ul>
<li>y也就是YEAR_OF_ERA 处理很简单，判断了一下year &gt;&#x3D; 1就返回 year。</li>
<li>M也就是MONTH_OF_YEAR 处理很简单，返回日期的month.</li>
<li>d也就是DAY_OF_MONTH 返回日期的day.</li>
</ul>
<p>从这里也可以看出我们格式化成<code>YEAR</code>和<code>ERA</code>作为年其实也是可以的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">get0</span><span class="params">(TemporalField field)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> ((ChronoField) field) &#123;</span><br><span class="line">        <span class="keyword">case</span> DAY_OF_WEEK: <span class="keyword">return</span> getDayOfWeek().getValue();</span><br><span class="line">        <span class="keyword">case</span> ALIGNED_DAY_OF_WEEK_IN_MONTH: <span class="keyword">return</span> ((day - <span class="number">1</span>) % <span class="number">7</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> ALIGNED_DAY_OF_WEEK_IN_YEAR: <span class="keyword">return</span> ((getDayOfYear() - <span class="number">1</span>) % <span class="number">7</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> DAY_OF_MONTH: <span class="keyword">return</span> day;</span><br><span class="line">        <span class="keyword">case</span> DAY_OF_YEAR: <span class="keyword">return</span> getDayOfYear();</span><br><span class="line">        <span class="keyword">case</span> EPOCH_DAY: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedTemporalTypeException</span>(<span class="string">&quot;Invalid field &#x27;EpochDay&#x27; for get() method, use getLong() instead&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> ALIGNED_WEEK_OF_MONTH: <span class="keyword">return</span> ((day - <span class="number">1</span>) / <span class="number">7</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> ALIGNED_WEEK_OF_YEAR: <span class="keyword">return</span> ((getDayOfYear() - <span class="number">1</span>) / <span class="number">7</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> MONTH_OF_YEAR: <span class="keyword">return</span> month;</span><br><span class="line">        <span class="keyword">case</span> PROLEPTIC_MONTH: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedTemporalTypeException</span>(<span class="string">&quot;Invalid field &#x27;ProlepticMonth&#x27; for get() method, use getLong() instead&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> YEAR_OF_ERA: <span class="keyword">return</span> (year &gt;= <span class="number">1</span> ? year : <span class="number">1</span> - year);</span><br><span class="line">        <span class="keyword">case</span> YEAR: <span class="keyword">return</span> year;</span><br><span class="line">        <span class="keyword">case</span> ERA: <span class="keyword">return</span> (year &gt;= <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedTemporalTypeException</span>(<span class="string">&quot;Unsupported field: &quot;</span> + field);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完了日期的处理再看一下时间的吧，其实大同小异了。</p>
<p>时间的<code>getLong</code>方法。同样的经过判断走到<code>get0</code>里面，注意这是时间的<code>getLong</code>和<code>get0</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLong</span><span class="params">(TemporalField field)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (field <span class="keyword">instanceof</span> ChronoField) &#123;</span><br><span class="line">        <span class="keyword">if</span> (field == NANO_OF_DAY) &#123;</span><br><span class="line">            <span class="keyword">return</span> toNanoOfDay();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (field == MICRO_OF_DAY) &#123;</span><br><span class="line">            <span class="keyword">return</span> toNanoOfDay() / <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> get0(field);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> field.getFrom(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间的<code>get0</code>方法。处理的就是这些类型了。主要看我们关注的几个</p>
<ul>
<li>H 也就是 HOUR_OF_DAY, 直接返回时间的 hour</li>
<li>m 也就是MINUTE_OF_HOUR，直接返回时间的 minute</li>
<li>s 也就是 SECOND_OF_MINUTE, 直接返回时间的 second</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">get0</span><span class="params">(TemporalField field)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> ((ChronoField) field) &#123;</span><br><span class="line">        <span class="keyword">case</span> NANO_OF_SECOND: <span class="keyword">return</span> nano;</span><br><span class="line">        <span class="keyword">case</span> NANO_OF_DAY: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedTemporalTypeException</span>(<span class="string">&quot;Invalid field &#x27;NanoOfDay&#x27; for get() method, use getLong() instead&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> MICRO_OF_SECOND: <span class="keyword">return</span> nano / <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">case</span> MICRO_OF_DAY: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedTemporalTypeException</span>(<span class="string">&quot;Invalid field &#x27;MicroOfDay&#x27; for get() method, use getLong() instead&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> MILLI_OF_SECOND: <span class="keyword">return</span> nano / <span class="number">1000_000</span>;</span><br><span class="line">        <span class="keyword">case</span> MILLI_OF_DAY: <span class="keyword">return</span> (<span class="type">int</span>) (toNanoOfDay() / <span class="number">1000_000</span>);</span><br><span class="line">        <span class="keyword">case</span> SECOND_OF_MINUTE: <span class="keyword">return</span> second;</span><br><span class="line">        <span class="keyword">case</span> SECOND_OF_DAY: <span class="keyword">return</span> toSecondOfDay();</span><br><span class="line">        <span class="keyword">case</span> MINUTE_OF_HOUR: <span class="keyword">return</span> minute;</span><br><span class="line">        <span class="keyword">case</span> MINUTE_OF_DAY: <span class="keyword">return</span> hour * <span class="number">60</span> + minute;</span><br><span class="line">        <span class="keyword">case</span> HOUR_OF_AMPM: <span class="keyword">return</span> hour % <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">case</span> CLOCK_HOUR_OF_AMPM: <span class="type">int</span> <span class="variable">ham</span> <span class="operator">=</span> hour % <span class="number">12</span>; <span class="keyword">return</span> (ham % <span class="number">12</span> == <span class="number">0</span> ? <span class="number">12</span> : ham);</span><br><span class="line">        <span class="keyword">case</span> HOUR_OF_DAY: <span class="keyword">return</span> hour;</span><br><span class="line">        <span class="keyword">case</span> CLOCK_HOUR_OF_DAY: <span class="keyword">return</span> (hour == <span class="number">0</span> ? <span class="number">24</span> : hour);</span><br><span class="line">        <span class="keyword">case</span> AMPM_OF_DAY: <span class="keyword">return</span> hour / <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedTemporalTypeException</span>(<span class="string">&quot;Unsupported field: &quot;</span> + field);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，到这里我们知道了时间格式的各种使用方法和格式化的源码。</p>
<p>对于不同格式化的区别。总结一下。</p>
<ul>
<li><code>y</code> 处理简单，只是判断了year &gt; 1 就返回了year。</li>
<li><code>Y</code> 处理较复杂，还判断了周，根据情况对年份+1和-1。某些年份的某些日期会有坑。<strong>一定要注意！！！</strong></li>
<li><code>Md Hms</code>处理非常简单，直接返回了日期时间上面对应的数。</li>
<li><code>-: </code>一些特殊字符，格式化的时候是直接增加到字符串里面的。</li>
</ul>
<p>下面总结一下源码对应文件和方法的追踪链。感兴趣的可以自己在多翻翻源码。</p>
<p>ofPattern指定格式的调用链</p>
<ul>
<li>DateTimeFormatter.java -&gt; public static DateTimeFormatter ofPattern(String pattern)<ul>
<li>DateTimeFormatterBuilder.java -&gt; public DateTimeFormatterBuilder appendPattern(String pattern)</li>
<li>DateTimeFormatterBuilder.java -&gt; private void parsePattern(String pattern)</li>
<li>DateTimeFormatterBuilder.java -&gt; private void parseField(char cur, int count, TemporalField field)</li>
<li>DateTimeFormatterBuilder.java -&gt; public DateTimeFormatterBuilder appendValue(TemporalField field, int width)</li>
<li>在这里创建的解析器</li>
<li>DateTimeFormatterBuilder.java -&gt; <code>static class NumberPrinterParser implements DateTimePrinterParser</code></li>
<li>DateTimeFormatterBuilder.java -&gt; <code>static final class CharLiteralPrinterParser implements DateTimePrinterParser</code></li>
</ul>
</li>
</ul>
<p>format方法调用链</p>
<ul>
<li>LocalDateTime.java -&gt; public String format(DateTimeFormatter formatter)<ul>
<li>DateTimeFormatter.java -&gt; public String format(TemporalAccessor temporal)</li>
<li>DateTimeFormatter.java -&gt; public void formatTo(TemporalAccessor temporal, Appendable appendable)<ul>
<li>接下来根据不同的处理解析器进行处理，主要有两个解析器</li>
<li>DateTimeFormatterBuilder.java -&gt; <code>static class NumberPrinterParser implements DateTimePrinterParser</code></li>
<li>DateTimeFormatterBuilder.java -&gt; <code>static final class CharLiteralPrinterParser implements DateTimePrinterParser</code><ul>
<li>DateTimePrintContext.java -&gt; Long getValue(TemporalField field)<ul>
<li>LocalDateTime.java -&gt; public long getLong(TemporalField field)<ul>
<li>这里日期调日期的 LocalDate.java -&gt; public long getLong(TemporalField field)</li>
<li>LocalDate.java -&gt; private int get0(TemporalField field) </li>
<li>时间调时间的 LocalTime.java -&gt; public long getLong(TemporalField field)</li>
<li>LocalTime.java -&gt; private int get0(TemporalField field)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Thepatter"
      src="/images/header.jpeg">
  <p class="site-author-name" itemprop="name">Thepatter</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">208</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">83</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Thepatterraining" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Thepatterraining" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ztzhoutao041@163.com" title="E-Mail → mailto:ztzhoutao041@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://blog.csdn.net/Thepatterraining" title="CSDN → http:&#x2F;&#x2F;blog.csdn.net&#x2F;Thepatterraining" rel="noopener" target="_blank"><i class="fa fa-fw fa-CSDN"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Thepatter</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"RWllimOI5okO7WFTUmJ4EeeD-gzGzoHsz","app_key":"hXeefwCw8aDKTJ1Xqye7fLYb","security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'RWllimOI5okO7WFTUmJ4EeeD-gzGzoHsz',
      appKey     : 'hXeefwCw8aDKTJ1Xqye7fLYb',
      placeholder: "给我的文章加点评论吧~",
      avatar     : 'mp',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
