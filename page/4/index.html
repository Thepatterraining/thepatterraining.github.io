<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="YwTcBpc08sCpJAE8mKZglCGHjZc1BiK9UUagC8ldlaA">
  <meta name="msvalidate.01" content="true">
  <meta name="yandex-verification" content="true">
  <meta name="baidu-site-verification" content="3PbJKzlOf0">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"thepatterraining.github.io","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="dream">
<meta property="og:url" content="https://thepatterraining.github.io/page/4/index.html">
<meta property="og:site_name" content="dream">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Thepatter">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://thepatterraining.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>dream</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="dream" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dream</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个菜鸟程序员的成长历程</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FDataLab.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FDataLab.html" class="post-title-link" itemprop="url">深入理解计算机系统DataLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-21 10:12:47" itemprop="dateCreated datePublished" datetime="2023-06-21T10:12:47+08:00">2023-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/csapp/" itemprop="url" rel="index"><span itemprop="name">csapp</span></a>
                </span>
            </span>

          
            <span id="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FDataLab.html" class="post-meta-item leancloud_visitors" data-flag-title="深入理解计算机系统DataLab" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FDataLab.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FDataLab.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Data-Lab"><a href="#Data-Lab" class="headerlink" title="Data Lab"></a>Data Lab</h1><p>data lab 数据实验</p>
<p>这个数据实验请在linux机器上面运行，实测mac m1本跑不起来。windows没试过。</p>
<p>centos上需要安装好gcc运行环境。</p>
<p>如果跑不起来记得安装下面这个东西：</p>
<blockquote>
<p>yum -y install glibc-devel.i686</p>
</blockquote>
<p>运行<code>make btest</code>的时候可能会有<code>warning</code>提示，不用管，这个时候其实已经创建完<code>btest</code>了，可以直接运行<code>btest</code>。</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-1.png" alt="lab准备"></p>
<h3 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h3><p>第一个函数是实现<code>位</code>的<code>异或</code>。</p>
<p>看一下异或的要求，相同为0，不同为1，这个函数里面只能使用<code>按位与&amp;</code>和<code>按位取反~</code>。</p>
<p>最大操作符号数：14</p>
<table>
<thead>
<tr>
<th align="left">x</th>
<th align="left">y</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
</tbody></table>
<p>假设我们有4 &#x3D; 100, 5 &#x3D; 101，异或的结果为1 &#x3D; 001.</p>
<p>先看按位与的结果。100 &amp; 101 &#x3D; 100 这个时候能得到 0 0 0这个正确的组合</p>
<table>
<thead>
<tr>
<th align="left">x</th>
<th align="left">y</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>100再取反就是011，就可以得到 1 1 0 这个正确的组合。</p>
<table>
<thead>
<tr>
<th align="left">x</th>
<th align="left">y</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
</tbody></table>
<p>先看按位或的结果。100 | 101 &#x3D; 101 这个时候能得到 0 1 1 和 1 0 1这个正确的组合</p>
<table>
<thead>
<tr>
<th align="left">x</th>
<th align="left">y</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>可以看到 ~(x &amp; y) &amp; (x | y) 就可以得出结果了，但是我们不能用 | ，所以我们需要通过 &amp;，～来实现 |。</p>
<p>可以通过 <del>(</del>x &amp; ~y) 来实现 ｜ ,4 &#x3D; 100 取反 &#x3D; 011， 5 &#x3D; 101 取反 &#x3D; 010, 011 &amp; 010 &#x3D; 010,取反 &#x3D; 101. 100 | 101 &#x3D; 101。</p>
<p>所以 异或就是 <del>(x &amp; y) &amp; (</del>(~x &amp; ~y))</p>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~(x &amp; y) &amp; ~(~x &amp; ~y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>btest 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-2.png" alt="lab1 btest"></p>
<p>dlc 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-3.png" alt="lab1 dlc"></p>
<p>bdd check 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-4.png" alt="lab1 dlc"></p>
<h3 id="Tmin"><a href="#Tmin" class="headerlink" title="Tmin"></a>Tmin</h3><p>Tmin是<code>1000 0000</code>，也就是最小的有符号数，那当然是符号位是1，剩下全0了。</p>
<p>可以使用操作符：! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
<p>最大操作符号数量：4</p>
<p>分数：1</p>
<p>返回 1000 0000就可以了。正常的int Tmin就是1后面31个0，也就是1左移动31位</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>btest 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-5.png" alt="lab1 btest"></p>
<p>dlc 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-6.png" alt="lab1 dlc"></p>
<p>bdd check 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-7.png" alt="lab1 dlc"></p>
<h3 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h3><p>Tmax是<code>0111</code></p>
<p>可以使用操作符: ! ~ &amp; ^ | +<br>最大操作符号数量: 10</p>
<p>4位的话，Tmax就是7，看一下7的一些操作结果,可以发现，7+1 &#x3D; ~7</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">7 = 0111</span><br><span class="line">7 + 1 = 1000 = -8</span><br><span class="line">~7 = 1000 = -8</span><br><span class="line">1000 ^ 0000 = 1000 !1000 = 0000</span><br></pre></td></tr></table></figure>

<p>但是 -1 + 1 也等于 ~-1,所以我们需要排除-1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-1 = 1111</span><br><span class="line">-1 + 1 = 0000</span><br><span class="line">~-1 = 0000</span><br><span class="line">0000 ^ 0000 = 0000 !0000 = 0001</span><br></pre></td></tr></table></figure>

<p>可以看到4的话，4 + 1 不等于~4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 = 100</span><br><span class="line">4 + 1 = 0101</span><br><span class="line">~4 = 1011</span><br><span class="line">101 ^ 000 = 101 !101 = 000</span><br></pre></td></tr></table></figure>

<p>怎么排除-1呢，观察发现-1+1 &#x3D; 0，而0^0 &#x3D; 0,但是tmax ^ 0 不等于0</p>
<p>所以tmax需要满足两个条件</p>
<ol>
<li>x + 1 &#x3D;&#x3D; ~x</li>
<li>x + 1 !&#x3D; 0</li>
</ol>
<p>可以用<code>^</code>操作来实现<code>==</code>。如果相等，那么x+1 ^ ~x 就会等于0，!0 &#x3D;&#x3D; 1，所以第一个条件就是</p>
<blockquote>
<p>!((x+1) ^ ~x)</p>
</blockquote>
<p>第二个条件同样通过<code>^</code>来实现。</p>
<blockquote>
<p>!!((x+1) ^ 0)</p>
</blockquote>
<p>只要这两个都满足就是Tmax了，都满足可以通过<code>&amp;</code>来实现，如果都是1，那么<code>&amp;</code>以后就是1，有一个不满足<code>&amp;</code>以后就是0.</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> xPlus = x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> !(xPlus ^ ~x) &amp; !!(xPlus ^ <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>btest 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-8.png" alt="lab1 btest"></p>
<p>dlc 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-9.png" alt="lab1 dlc"></p>
<p>bdd check 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-10.png" alt="lab1 dlc"></p>
<h3 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h3><p>如果所有的奇数位都是1就返回1，否则返回0</p>
<p>可以使用的操作符: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>最大数量: 12<br>分数: 2</p>
<p>比如 <code>1010 1010</code>就是奇数位上全1.</p>
<p>所以只要和 <code>1010 1010</code> 做 <code>&amp;</code> 操作，只要做完以后还是 <code>1010 1010</code>的话，那么就返回1，不然就是0.</p>
<p>因为假设 x 奇数位上有一个是0，比如 <code>1010 1000</code>，那么结果就会是 <code>1010 1000</code>，所以只有奇数位上全1，<code>&amp;</code>以后一定是<code>1010 1010</code>。</p>
<p>所以需要满足条件</p>
<ol>
<li>x &amp; 1010 1010 &#x3D;&#x3D; 1010 1010</li>
</ol>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> odd = <span class="number">0xAA</span>; <span class="comment">//1010 1010</span></span><br><span class="line">  <span class="type">int</span> halfOdd = (odd &lt;&lt; <span class="number">8</span>) + odd; <span class="comment">// 1010 1010 0000 0000 + 1010 1010 = 1010 1010 1010 1010</span></span><br><span class="line">  <span class="type">int</span> allOdd = (halfOdd &lt;&lt; <span class="number">16</span>) + halfOdd;</span><br><span class="line">  <span class="keyword">return</span> !((allOdd &amp; x)  ^ allOdd );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>btest 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-11.png" alt="lab1 btest"></p>
<p>dlc 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-12.png" alt="lab1 dlc"></p>
<p>bdd check 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-13.png" alt="lab1 dlc"></p>
<h3 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h3><p>返回-x<br>可以使用的操作符: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>最大数量: 5<br>分数: 2</p>
<p>这里要分成三部</p>
<ul>
<li>正数，比如 7 &#x3D; 0111</li>
<li>0， 0 &#x3D; 0000</li>
<li>负数，-1 &#x3D; 1111</li>
</ul>
<p>如果使用按位取反</p>
<ul>
<li>7 &#x3D; 0111，～7 &#x3D; 1000 &#x3D; -8</li>
<li>0 &#x3D; 0000， ～0 &#x3D; 1111 &#x3D; -1</li>
<li>-1 &#x3D; 1111， ～-1 &#x3D; 0000 &#x3D; 0</li>
<li>-8 &#x3D; 1000， ～-8 &#x3D; 0111 &#x3D; 7</li>
</ul>
<p>取反以后的值 + 1就是对应的负数了，-8 + 1 &#x3D; -7, -1 + 1 &#x3D; 0, 0 + 1 &#x3D; 1, 7 + 1 &#x3D; 8</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>btest 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-14.png" alt="lab1 btest"></p>
<p>dlc 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-15.png" alt="lab1 dlc"></p>
<p>bdd check 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-16.png" alt="lab1 dlc"></p>
<h3 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h3><p>如果 0x30 &lt;&#x3D; x &lt;&#x3D; 0x39，返回1，否则0<br>可以使用的操作符: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>最大数量: 15<br>分数: 3</p>
<p>0x30 &#x3D; 0011 0000, 0x39 &#x3D; 0011 1001。<br>根据题目，也就是判断 0011 0000 &lt;&#x3D; x &lt;&#x3D; 0011 1001</p>
<p>首先高位要等于 0011，如果不等于0011，那么肯定不在这个范围。可以通过 &gt;&gt; 4位然后 ^ 0011，如果结果为0，那么高位就是满足的。</p>
<p>低位在0000 到 1001之间,当首位是0的时候，后面是啥都行，首位是1，那么后面两位必须是00，也就是前三位是100.</p>
<p>判断首位是0可以通过 &amp; 0x8 然后 ^ 0来判断，如果结果是0首位就是0，不然首位是1</p>
<p>判断低4位的前3位，先 &amp; 0xE来获取前3位，然后 ^ 0x8来判断是不是 100</p>
<p>所以需要满足条件1并且满足条件2或者3</p>
<ol>
<li>x &gt;&gt; 4 ^ 0011 &#x3D;&#x3D; 0</li>
<li>(x &amp; 0x8) ^ 0 &#x3D;&#x3D; 0 </li>
<li>(x &amp; 0xE) ^ 0x8 &#x3D;&#x3D; 0</li>
</ol>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> xh = x &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> a3 = <span class="number">0x3</span>;</span><br><span class="line">    <span class="type">int</span> xlh = x &amp; <span class="number">0x8</span>;</span><br><span class="line">    <span class="type">int</span> xorxlh = xlh^<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> xorxl = (x &amp; <span class="number">0xE</span>) ^ <span class="number">0x8</span>;</span><br><span class="line">    <span class="keyword">return</span> (!(xh ^ a3 ^ <span class="number">0</span>)) &amp; (!xorxlh | !xorxl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>btest 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-17.png" alt="lab1 btest"></p>
<p>dlc 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-18.png" alt="lab1 dlc"></p>
<p>bdd check 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-19.png" alt="lab1 dlc"></p>
<h3 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h3><p>实现三元运算 x ? y : z<br>可以使用的操作符: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>最大数量: 16<br>分数: 3</p>
<p>x 为真代表 x &amp; 1 &#x3D;&#x3D; 1,x 为假代表 x &amp; 1 &#x3D;&#x3D; 0。<br>需要满足条件</p>
<ol>
<li>x &amp; 1 &#x3D;&#x3D; 1时，返回y,所以z需要置为0并且和y一起返回。<code>!(x &amp; 1) &amp; z</code>就可以把z置为0，所以应该返回 <code>(!(x &amp; 1) &amp; z) | y</code></li>
<li>x &amp; 1 &#x3D;&#x3D; 0时，返回z,所以y需要置为0并且和z一起返回。<code>x &amp; 1 &amp; y</code>就可以把y置为0。所以应该返回 <code>(x &amp; 1 &amp; y) | z</code></li>
</ol>
<p>把上面的2个条件合并起来。</p>
<blockquote>
<p>(!(x &amp; 1) &amp; z) ｜ (x &amp; 1 &amp; y)</p>
</blockquote>
<p>但是发现这样并不行，所以重新思考，发现 x &amp; 1 &#x3D;&#x3D; 1时候是没错，但是我们应该让 x &#x3D; 0xFF才行。</p>
<p>所以改进一下子</p>
<ul>
<li>先对x取反。!x &#x3D; 1,说明x &#x3D; 0,这个时候应该返回 z,所以需要<code>(0 &amp; y) | z</code></li>
<li>!x &#x3D; 0,说明x &#x3D; 1，应该返回y,所以需要 <code>(0 &amp; z) | y</code></li>
</ul>
<p>这里把 !x 在按位取反 + 1就可以得到当 x &#x3D; 0时候，condition &#x3D; 1111 1111。这个时候返回z。</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">  <span class="type">int</span> xn = !x;</span><br><span class="line">  <span class="type">int</span> condition = ~xn + <span class="number">1</span>; <span class="comment">//x = 0,condition = 1111 1111, x = 1, condition = 0000 0000</span></span><br><span class="line">  <span class="keyword">return</span> (condition &amp; z) | (~condition &amp; y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>btest 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-20.png" alt="lab1 btest"></p>
<p>dlc 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-21.png" alt="lab1 dlc"></p>
<p>bdd check 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-22.png" alt="lab1 dlc"></p>
<h3 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h3><p>如果x &lt;&#x3D; y，返回1，否则0<br>可以使用的操作符: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>最大数量: 24<br>分数: 3</p>
<p>等于可以通过<code>异或</code>来做。</p>
<blockquote>
<p>!(x ^ y) </p>
</blockquote>
<p>在看小于，如果一个正数和一个负数，那么负数一定小于正数，负数的符号位1，正数的符号位0.</p>
<p>取出符号位，通过右移动31位来获取符号位，但是负数会补1，所以在和1与一下，就可以得到符号位了。</p>
<blockquote>
<p>(x &gt;&gt; 31) &amp; 1</p>
</blockquote>
<p>可以<code>|</code>一下，如果是 <code>1 | 0</code>就返回1了。</p>
<blockquote>
<p>((x &gt;&gt; 31) &amp; 1 ) | ((y &gt;&gt; 31) &amp; 1)</p>
</blockquote>
<p>如果两个都是正数或者负数，那么符号位相同。</p>
<ul>
<li>对较小的数进行按位取反，在加上大的数的话，会产生溢出。也就是 x &lt; y, ~x + y 会溢出，所以首位是0</li>
<li>如果两个数相等或者较大的数取反了在加上小的数，不会溢出。x &gt;&#x3D; y, ~x + y 不会溢出，所以首位是1</li>
<li>所以对于等于的情况还需要处理，如果两个数相等，那么 ~x + y &#x3D; -1，也就是所有位都是1，让这个值+1就是0了，就和小于保持一致了</li>
</ul>
<p>如果两个数的符号位不同，那么x是1,y是0的话，就返回1，否则0</p>
<ul>
<li>对x的符号位取反，如果x符号位是1，那么取反0,y的符号位是0，那么就返回1</li>
<li>如果x符号位是0，取反1，y是1，那么返回0</li>
</ul>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="comment">// 取首位</span></span><br><span class="line">  <span class="type">int</span> signalX = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> signalY = (y &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// !(signalX ^ signalY)是符号位相同的情况</span></span><br><span class="line">  <span class="comment">// !(((~x + y + 1) &gt;&gt; 31) &amp; 1) 是符号位相同时候小于等于的情况</span></span><br><span class="line">  <span class="type">int</span> lessEq = !(signalX ^ signalY) &amp; !(((~x + y + <span class="number">1</span>) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 如果符号位不同的情况</span></span><br><span class="line">  <span class="type">int</span> neq = (!signalY) &amp; signalX;</span><br><span class="line">  <span class="comment">// 两个情况做|，满足任一个情况则返回1</span></span><br><span class="line">  <span class="keyword">return</span> (lessEq | neq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>btest 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-23.png" alt="lab1 btest"></p>
<p>dlc 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-24.png" alt="lab1 dlc"></p>
<p>bdd check 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-25.png" alt="lab1 dlc"></p>
<h3 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h3><p>对x取反，实现!操作<br>可以使用的操作符: ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>最大数量: 12<br>分数: 4</p>
<p>两种情况</p>
<ul>
<li>0，(~0 + 1) | 0 的首位是0</li>
<li>其他数， (~x + 1) | x的首位是1</li>
</ul>
<p>0要返回1，1要返回0，可以异或1</p>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ((((~x + <span class="number">1</span>) | x) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>) ^ <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>btest 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-26.png" alt="lab1 btest"></p>
<p>dlc 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-27.png" alt="lab1 dlc"></p>
<p>bdd check 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-28.png" alt="lab1 dlc"></p>
<h3 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h3><p>输出最少需要的位数来表示int x<br>可以使用的操作符: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>最大数量: 90<br>分数: 4</p>
<p>例子：</p>
<ul>
<li>howManyBits(12) &#x3D; 5 &#x3D; 10010</li>
<li>howManyBits(298) &#x3D; 10 &#x3D; 10 1001 1000</li>
<li>howManyBits(-5) &#x3D; 4 &#x3D; 1011</li>
<li>howManyBits(0)  &#x3D; 1 &#x3D; 0</li>
<li>howManyBits(-1) &#x3D; 1 &#x3D; 1</li>
<li>howManyBits(0x80000000) &#x3D; 32 &#x3D; 1000….</li>
</ul>
<p>三种情况</p>
<ul>
<li>正数的首位都是1，遇到1的话，找到1是哪位就可以了</li>
<li>负数的首位是符号位都是1，所以需要找到第二个1，如果把负数的符号位变成0，就可以按照正数处理了</li>
<li>0，直接返回0，也可以使用正数的方法找1，找不到自然返回0了</li>
</ul>
<p>有没有1，可以通过!!来判断，如果是!!0，就是0，如果是其他数!!x就是1了。</p>
<p>这道题的代码是从网上抄的。</p>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> signal = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> b1,b2,b3,b4,b5,h16,h8,h4,h2,h1;</span><br><span class="line">  x =  (signal &amp; ~x) | (~signal &amp; x);</span><br><span class="line">  <span class="comment">// 查看高16位是否有1</span></span><br><span class="line">  h16 = !!(x &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  <span class="comment">// 如果高16位有1，那么肯定需要16位来表示，记住这16位</span></span><br><span class="line">  <span class="comment">// 因为高 16bit 有1，那么h16就是1，所以1 &lt;&lt; 4 就是16，代表最低需要16位表示</span></span><br><span class="line">  <span class="comment">// 如果高 16bit 没有1，那么h16就是0，所以 0&lt;&lt; 4就是0，代表最低需要0位表示</span></span><br><span class="line">  b1 = h16 &lt;&lt; <span class="number">4</span>;</span><br><span class="line">  <span class="comment">// 如果高位有1，那么x &gt;&gt; 16位，这样的原来的高位变成了低位</span></span><br><span class="line">  <span class="comment">// 如果高位没有1，那么x &gt;&gt; 0位，这样低16位还是低16位</span></span><br><span class="line">  x = x &gt;&gt; b1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里分为两种情况，如果高16位有1，需要继续看高8位是否有1，如果高16位没有1，需要看低16位的高8位是否有1</span></span><br><span class="line">  <span class="comment">// 因为上面对于高16位有1的时候，将高16位变成了低16位，所以都只需要看低16位的高8位就可以了</span></span><br><span class="line">   h8 = !!(x &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  <span class="comment">// 和上面同理，如果现在16位的高8位有1，那么b2代表 1 &lt;&lt; 3就是8，如果没有，那么就是0</span></span><br><span class="line">   b2 = h8 &lt;&lt; <span class="number">3</span></span><br><span class="line">  <span class="comment">// 同样处理，如果有，那么高8位变低8位</span></span><br><span class="line">  x = x &gt;&gt; b2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//处理8位的高4位</span></span><br><span class="line">   h4 = !!(x &gt;&gt; <span class="number">4</span>);</span><br><span class="line">   b3 = h4 &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  x = x &gt;&gt; b3;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理4位的高2位</span></span><br><span class="line">   h2 = !!(x &gt;&gt; <span class="number">2</span>);</span><br><span class="line">   b4 = h2 &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  x = x &gt;&gt; b4;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理最后2位是否有1</span></span><br><span class="line">   h1 = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">   b5 = h1;</span><br><span class="line">  x = x &gt;&gt; b5;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有结果相加 最后+1，因为高16位有1，那么需要17位表示</span></span><br><span class="line">  <span class="keyword">return</span> b1 + b2 + b3 + b4 + b5 + x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>btest 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-29.png" alt="lab1 btest"></p>
<p>dlc 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-30.png" alt="lab1 dlc"></p>
<p>bdd check 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-31.png" alt="lab1 dlc"></p>
<h3 id="float-twice"><a href="#float-twice" class="headerlink" title="float_twice"></a>float_twice</h3><p>传入一个无符号数uf,返回uf * 2的小数的bit表示<br>可以使用的操作符: 任何整数的操作，包||,&amp;&amp;,if,while<br>最大数量: 30<br>分数: 4</p>
<p>在复习一下，IEEE浮点标准用<code>V = (-1)的s次方 * M * 2的E次方</code>来表示。<br>单精度尾数是23位，exp是8位，符号位1位</p>
<p>取符号位<br>int s &#x3D; (uf &gt;&gt; 31) &amp; 1;</p>
<p>取exp<br>int exp &#x3D; (uf &lt;&lt; 1) &gt;&gt; 24</p>
<p>当阶码exp不等于全0或不等于全1的时候，就表示规格化的浮点数。<br>E的计算方式</p>
<ul>
<li>E &#x3D; 阶码 - Bias</li>
<li>Bias &#x3D; 单精度是127</li>
<li>单精度下，假设阶码为 0000 0001, 那么E &#x3D; 1 - 127 &#x3D; -126<br>E &#x3D; exp - Bias</li>
</ul>
<p>M的计算方式</p>
<ul>
<li>M &#x3D; 1.XXXXXX</li>
<li>尾数就是 XXXXXX</li>
<li>假设 尾数为 0000 0000 0000 0000 0000 001，那么M &#x3D; 1.00000000000000000000001</li>
</ul>
<p>-1^s * 1.尾数 * 2^E</p>
<p>当阶码等于全0的时候，就表示非规格化的浮点数。<br>exp ^ 0是0就代表全0，非规格化<br>E的计算方式，他跟阶码没关系了，因为阶码永远是0</p>
<ul>
<li>E &#x3D; 1 - Bias</li>
<li>Bias &#x3D; 单精度是127</li>
<li>阶码永远为 0000 0000, E &#x3D; 1 - 127 &#x3D; -126<br>E &#x3D; 1 - 127</li>
</ul>
<p>M的计算方式</p>
<ul>
<li>M &#x3D; 0.XXXXXX</li>
<li>尾数就是 XXXXXX</li>
<li>假设 尾数为 0000 0000 0000 0000 0000 001，那么M &#x3D; 0.00000000000000000000001</li>
</ul>
<p>-1^s * 0.尾数 * 2^E</p>
<p>当阶码等于全1的时候，就表示特殊的浮点数。<br>~exp ^ 0是0就代表全1，特殊浮点数 当尾数不为全0的时候，就是NaN，返回参数。</p>
<p>小数乘法</p>
<ul>
<li>符号位s1 ^ s2</li>
<li>M &#x3D; M1 * M2</li>
<li>E &#x3D; E1 + E2</li>
</ul>
<p>对于规格化的数，<em>2，自然是e+1，因为2的E次方，E+1，那就等于多乘了个2<br>对于非规格化的数，E是固定的-126，没法改变，所以尾数</em>2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">float_twice</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化s符号位，exp阶码，fre尾数</span></span><br><span class="line">  <span class="type">int</span> s,<span class="built_in">exp</span>,fre;</span><br><span class="line">  s = (uf &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">exp</span> = (uf &amp; <span class="number">0x7F800000</span>) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">  fre = uf &amp; <span class="number">0x7FFFFF</span>;</span><br><span class="line">  <span class="comment">// 如果exp == 0，代表非规格化的数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 非规格化</span></span><br><span class="line">    <span class="comment">// 尾数 * 2</span></span><br><span class="line">    fre = fre &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (s &lt;&lt; <span class="number">31</span>) | (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | fre;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xFF</span>) &#123;</span><br><span class="line">    <span class="comment">// 特殊</span></span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 规格化 exp + 1</span></span><br><span class="line">    <span class="built_in">exp</span> = <span class="built_in">exp</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// +1以后有可能是全1，那么就是无穷大，也就是特殊值，无穷大需要把尾数变成全0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>) &#123;</span><br><span class="line">        fre = <span class="number">0x0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (s &lt;&lt; <span class="number">31</span>) | (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | fre;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>btest 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-32.png" alt="lab1 btest"></p>
<p>dlc 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-33.png" alt="lab1 dlc"></p>
<p>bdd check 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-34.png" alt="lab1 dlc"></p>
<h3 id="float-i2f"><a href="#float-i2f" class="headerlink" title="float_i2f"></a>float_i2f</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89.html" class="post-title-link" itemprop="url">深入理解计算机系统（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-21 10:12:47" itemprop="dateCreated datePublished" datetime="2023-06-21T10:12:47+08:00">2023-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-05 13:41:33" itemprop="dateModified" datetime="2025-03-05T13:41:33+08:00">2025-03-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/csapp/" itemprop="url" rel="index"><span itemprop="name">csapp</span></a>
                </span>
            </span>

          
            <span id="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89.html" class="post-meta-item leancloud_visitors" data-flag-title="深入理解计算机系统（一）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机系统漫游"><a href="#计算机系统漫游" class="headerlink" title="计算机系统漫游"></a>计算机系统漫游</h1><p>计算机系统是由硬件和系统软件组成的，它们共同工作来运行应用程序。。虽然系统的 具体实现方式随着时间不断变化，但是系统内在的概念却没有改变。所有计算机系统都有 相似的硬件和软件组件，它们又执行着相似的功能。</p>
<h2 id="第一个c程序"><a href="#第一个c程序" class="headerlink" title="第一个c程序"></a>第一个c程序</h2><p>一般第一个程序都是输出<code>hello world</code>，这里我们使用c语言输出一个<code>hello world</code>。后面在来讲这里面都发生了什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="信息的表示和处理"><a href="#信息的表示和处理" class="headerlink" title="信息的表示和处理"></a>信息的表示和处理</h1><p>无符号整型和有符号整型的二进制表示</p>
<p><img src="/../images/csapp/csapp1-1.png" alt="无符号整型和有符号整型的二进制表示"></p>
<h2 id="bit"><a href="#bit" class="headerlink" title="bit"></a>bit</h2><p>可以用bit来表示集合，并用位操作来表示集合的操作。</p>
<p>p &amp;&amp; *p可以避免空指针</p>
<p>左移1位等于乘2</p>
<p>右移1位等于除2，且向下取整</p>
<p>逻辑右移：右移后补0，java中 -3 &gt;&gt; 1 &#x3D; -2<br>算术右移：右移后补符号位,java中 -3 &gt;&gt;&gt; 1 &#x3D; 2147483646</p>
<h2 id="大端表示和小端表示"><a href="#大端表示和小端表示" class="headerlink" title="大端表示和小端表示"></a>大端表示和小端表示</h2><ul>
<li>最高有效字节在最前面的方式，称为大端表示。</li>
<li>低有效字节在最前面的方式，称为小端表示。</li>
</ul>
<p><img src="/../images/csapp/csapp1-2.png" alt="大端表示和小端表示"></p>
<p>可以通过下面的代码来测试自己的机器是大端还是小端的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> *pointer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_bytes</span><span class="params">(pointer start, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">	<span class="type">size_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%p\t0x%.2x\n&quot;</span>, start+i, start[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">15213</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int a = 15213;\n&quot;</span>);</span><br><span class="line">    show_bytes((pointer) &amp;a, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><p>101.11表示5又3&#x2F;4，也就是23&#x2F;4。前面的101表示5，小数点后面的11表示3&#x2F;4,小数点后面第1个1表示1&#x2F;2，第二个1表示1&#x2F;4，所以相加就是3&#x2F;4</p>
<p><img src="/../images/csapp/csapp1-3.png" alt="float"></p>
<p>浮点数表示由<code>IEEE</code>制定。</p>
<p>IEEE浮点标准用<code>V = (-1)的s次方 * M * 2的E次方</code>来表示。</p>
<p>所以存储就有了3部分</p>
<ul>
<li>符号位，1位，0表示正数，1表示负数，表示s</li>
<li>尾数significand，尾数通常是1-2之间或0-1之间。encodes M，但不等于M</li>
<li>阶码exponent，encodes E，但不等于E</li>
</ul>
<p><img src="/../images/csapp/csapp1-4.png" alt="IEEE float"></p>
<h3 id="表示方式"><a href="#表示方式" class="headerlink" title="表示方式"></a>表示方式</h3><h4 id="规格化表示-Normalized"><a href="#规格化表示-Normalized" class="headerlink" title="规格化表示(Normalized)"></a>规格化表示(Normalized)</h4><p>当阶码不等于全0或不等于全1的时候，就表示规格化的浮点数。</p>
<p>E的计算方式</p>
<ul>
<li>E &#x3D; 阶码 - Bias</li>
<li>Bias &#x3D; 2的k-1次方 - 1，单精度是127，双精度是1023</li>
<li>单精度下，假设阶码为 0000 0001, 那么E &#x3D; 1 - 127 &#x3D; -126</li>
</ul>
<p>M的计算方式</p>
<ul>
<li>M &#x3D; 1.XXXXXX</li>
<li>尾数就是 XXXXXX</li>
<li>假设 尾数为 0000 0000 0000 0000 0000 001，那么M &#x3D; 1.00000000000000000000001</li>
</ul>
<p>假设符号为0表示正数，那么这个浮点数为 V &#x3D; 1 * M * 2的E次方<br>&#x3D; 1 * 1.00000000000000000000001 * 2的-126次方<br>&#x3D; 1.00000000000000000000001 * 2的-126次方<br>&#x3D; 0.000…00100000000000000000000001 （小数点左移126位）<br>这等于非常非常小的一个浮点数了</p>
<p>如何表示15213.0呢。首先符号位为0，然后计算尾数和阶码。</p>
<ul>
<li>15213.0 换成二进制表示为 11 1011 0110 1101.0</li>
<li>接下里移动小数点为 1.1101 1011 0110 1 * 2的13次方，因为小数点左移动了13位。</li>
<li>所以尾数为 1101 1011 0110 1000 0000 000</li>
<li>E &#x3D; 13，所以阶码 &#x3D; E + Bias &#x3D; 13 + 127 &#x3D; 140.</li>
<li>所以阶码为 140，二进制表示为 1000 1100</li>
</ul>
<p>15213.0的浮点数表示为：</p>
<p>0 1000 1100 1101 1011 0110 1000 0000 000</p>
<h4 id="非规格化表示-Denormalized"><a href="#非规格化表示-Denormalized" class="headerlink" title="非规格化表示(Denormalized)"></a>非规格化表示(Denormalized)</h4><p>当阶码等于全0的时候，就表示非规格化的浮点数。</p>
<p>E的计算方式，他跟阶码没关系了，因为阶码永远是0</p>
<ul>
<li>E &#x3D; 1 - Bias</li>
<li>Bias &#x3D; 2的k-1次方 - 1，单精度是127，双精度是1023</li>
<li>阶码永远为 0000 0000, E &#x3D; 1 - 127 &#x3D; -126</li>
</ul>
<p>M的计算方式</p>
<ul>
<li>M &#x3D; 0.XXXXXX</li>
<li>尾数就是 XXXXXX</li>
<li>假设 尾数为 0000 0000 0000 0000 0000 001，那么M &#x3D; 0.00000000000000000000001</li>
</ul>
<p>假设符号为0表示正数，那么这个浮点数为 V &#x3D; 1 * M * 2的E次方<br>&#x3D; 1 * 0.00000000000000000000001 * 2的-126次方<br>&#x3D; 0.00000000000000000000001 * 2的-126次方<br>&#x3D; 0.000…00000000000000000000000001 （小数点左移126位）<br>这等于非常非常小的一个浮点数了，比上一个规格化的更小</p>
<p>如果尾数也等于全0，那么就表示浮点数0</p>
<h4 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h4><p>当阶码等于全1的时候，就表示特殊的浮点数。</p>
<ul>
<li>当尾数全0，就表示无穷大</li>
<li>当尾数为其他值的时候，就表示 NaN(Not a Number)</li>
</ul>
<p>用数轴表示如下：</p>
<p><img src="/../images/csapp/csapp1-5.png" alt="IEEE float 表示"></p>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p> 习题2.54 假定变量x,f和d的类型分别是int、float 和cioubile。除了f和d都 不 能 等 于 十∞ 、 、 一 ∞ 或 者 N a N ， 它 们 的 值 是 任 意 的 。 对 于 下 面 每 个 C 表 达 式， 证 明 它 总 是 为 真 ( 也 就 是 求 值 为 1 )， 或 者 给 出 一 个 使 表 达 式 不 为 真 的 值 ( 也 就 是 求 值 为 0 )。</p>
<p> 类型中long &gt; double &gt; int &gt; float</p>
<ol>
<li>x &#x3D;&#x3D; (int) (double) x &#x2F;&#x2F; true</li>
<li>x &#x3D;&#x3D; (int) (float) x &#x2F;&#x2F; false</li>
<li>d &#x3D;&#x3D; (double) (float) d &#x2F;&#x2F; false</li>
<li>f &#x3D;&#x3D; ( float ) ( double ) f &#x2F;&#x2F; true</li>
<li>f &#x3D;&#x3D; -(-f) &#x2F;&#x2F;true 只改变了符号位</li>
<li>1.0&#x2F;2 &#x3D;&#x3D; 1&#x2F;2.0 &#x2F;&#x2F;true</li>
<li>d*d &gt;&#x3D; 0.0 &#x2F;&#x2F; true</li>
<li>( f + d ) - f &#x3D;&#x3D; d &#x2F;&#x2F;false浮点数不满足结合律</li>
</ol>
<h1 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h1><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>从最早的16位处理器8086到现在的64位处理器x86-64</p>
<ul>
<li>8086(1978年 ， 29 K个晶体管 )。 是 第 一代单芯片、16 位微处理器之一。8088是8086的一个变种，在8086上增加了一个8位外部总线，构成最初的IBM个人计算机的心脏。 BM与当时还不强大的微软签订合同，开发MS DOS 操作系统。最初的机器型号有32768 字节的内存和两个软驱 (没有硬盘驱动器)。 从体系结构上来说，这些机器只有655360字节的地址间 – 地址只有20位长(可寻址范围为1048576字节)，而操作系统保留了393216字节自用。1980年 ，Intel提出了8087浮点协处理器 (45 K个晶体管)，它与一个8086或8088处理器一同运行，执行浮点指令。8087 建立了x86 系列的浮点模型，通常被称为 “x87”</li>
<li>80286(1982 年，134K个晶体管)。增加了更多的寻址模式(现在已经废弃了)，构成了IBM PC- AT个人计算机的基础，这种计算机是 MS Windows 最初的使用平台。</li>
<li>i386 (1985 年，275K 个晶体管) 。将体系结构扩展到32位。增加了平坦寻址模式(flat addressingmodel)，Linux 和最近版本的Windows 操作系统都是使用的这种模式。这是 Intel 系列中第 一台全面支持Unix操作系统的机器。</li>
<li>i486(1989 年，1.2M个晶体管)。改善了性能，同时将浮点单元集成到了处理器芯片上，但是指令集没有明显的改变。</li>
<li>Pentium(1993 年，3.1M个晶体管)。改善了性能，不过只对指令集进行了小的扩展</li>
<li>PentiumPro( 1995 年，5.5M个晶体管)。引人全新的处理器设计，在内部被称为P6 微体系结构。指令集中增加了一类“ 条件传送(conditional move)” 指令</li>
<li>Pentium&#x2F; MMX ( 1997年，4.5M个晶体管 )。 在 Pentium处理器中增加了一类新的处理整数向量的指令。每个数据大小可以是1、2或4字节。每个向量总长64位</li>
<li>Pentium II ( 1997 年 ，7M 个晶体管 )。 P6微体系结构的延伸</li>
<li>Pentium III (1999年，8.2M个晶体管)。引人了SSE，这是一类处理整数或浮点数向 量的指令。每个数据可以是1、2或4个字节，打包成128位的向量。由于芯片上包括了 二 级高速绥存，这种芯片后来的版本最多使用 了24M 个晶体管</li>
<li>Pentium4 ( 2000年 ， 42M个晶体管 )。 SSE 扩展到了 SSE2，增加了新的数据类型 (包括双精度浮点数)，以及针对这些格式的 144 条新指令。有了这些扩展，编译器可以使用 SSE 指令(而不是x87 指令)，来编译浮点代码</li>
<li>Pentium 4E(2004年，125M个晶体管)。增加了超线程(hyperthreading)，这种技术 可以在一个处理器上同时运行两个程序;还增加 了EM64T ，它是 Intel 对 AMD 提出的对 IA32的64 位扩展的实现，我们称之为x86-64。</li>
<li>Core2( 2006年 ， 291M 个晶体管 )。 回归到类似于 P6 的微体系结构 。Intel的第一个多核微处理器，即多处理器实现在一个芯片上。但不支持超线程。</li>
<li>Core i7，Nehalem(2008年，781M个晶体管)。既支持超线程，也有多核，最初的版 本支持每个核上执行两个程序，每个芯片上最多四个核</li>
<li>Core i7, Sandy Bridge(2011年，1.17G 个晶体管)。引入了AVX，这是对SSE 的扩 展，支持把数据封装进 256 位的向量。</li>
<li>Corei7, Haswel(2013年，1.4G个晶体管)。将AVX扩展至AVX2，增加了更多的指令和指令格式.</li>
</ul>
<h2 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h2><h1 id="程序优化性能"><a href="#程序优化性能" class="headerlink" title="程序优化性能"></a>程序优化性能</h1><p>要写出编译器友好的程序来提升程序性能，比如下面两个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> *yp)</span> &#123;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> *yp)</span> &#123;</span><br><span class="line">    *xp += <span class="number">2</span> * *yp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于test1来说，要执行读取xp,读取yp,写xp，再次读取xp,读取yp，写xp，总共4次读取，2次写入。</p>
<p>对于test2来说，要执行读取xp,读取yp，写xp，只需要2次读取，1次写入，当然性能更好。</p>
<p>而且考虑一种情况，就是<code>*xp</code>和<code>*yp</code>指向同一个内存，如果这样的话，那么test1就变成了 xp &#x3D; 4 * xp，test2就变成了 xp &#x3D; 3 * xp，意思就不一样了，所以编译器没有办法把test1优化成test2的形式，这种叫做<code>内存别名</code></p>
<p>在看一个指针的问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1000</span>;y = <span class="number">3000</span>;</span><br><span class="line">*q = y;</span><br><span class="line">*p = x;</span><br><span class="line">t1 = *q; <span class="comment">// 1000 or 3000</span></span><br></pre></td></tr></table></figure>

<p>如果<code>*q</code>和<code>*p</code>是指向两个内存，那么t1就是3000,如果指向同一个内存，那么t1就是1000，因此编译器无法对这种代码进行优化。</p>
<h3 id="消除循环的低效率"><a href="#消除循环的低效率" class="headerlink" title="消除循环的低效率"></a>消除循环的低效率</h3><p>可以把循环中的多次计算或者过程调用等重复执行的，结果确定的，提取出来，只执行一次。</p>
<p>比如下面的代码，这个时候strlen这个函数会执行n次，A-a也会执行n次，他们的结果每次都是一样的，可以都提取出来。A-a由于是常数减法，编译器应该会优化，但是strlen是一个函数，函数的结果是不确定的，编译器会保守的保留它不进行优化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lower</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">size_t</span> i;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line"> <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line"> s[i] -= (<span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>优化后的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lower</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">size_t</span> i;</span><br><span class="line"> <span class="type">size_t</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"> <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line"> s[i] -= (<span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="减少过程调用"><a href="#减少过程调用" class="headerlink" title="减少过程调用"></a>减少过程调用</h3><p>有一些函数中会有一些不必要的操作，可以减少他们，比如数组函数，里面也许会有边界检查之类的，防止越界，但是如果我们的外部代码已经很明显的做了检查，或者说肯定不会越界，那么我们就可以省掉调用函数里面的这部分开销。</p>
<p>get_vec_element这个函数获取数组中的值，并且做了边界检查。这样会做n次边界检查，我们可以优化它。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine2</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    *dest = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">        <span class="type">data_t</span> val;</span><br><span class="line">        get_vec_element (v, i, &amp;val);</span><br><span class="line">        *dest = *dest OP val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化之后的代码，省了每次的边界检查。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine3</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">data_t</span> *data =get_vec_start(v);</span><br><span class="line">    *dest = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">        *dest = *dest OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消除不必要的内存引用"><a href="#消除不必要的内存引用" class="headerlink" title="消除不必要的内存引用"></a>消除不必要的内存引用</h3><p>上面的代码还是有些问题，因为对于dest来说，每次都要经历load,计算,store的过程，这个过程要重复n次，可以通过增加局部变量来减少load和store的次数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine4</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">data_t</span> *data =get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h3><p>for循环每次循环都会进行if条件判断，计算机执行条件判断的时候是比较费时的，现在有了<code>分支预测</code>功能，但是预测失败的话，也会影响性能。可以通过循环展开来优化这里，来减少for循环的消耗。这样改造的程序，已经极为接近线性代码的功耗了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine5</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span> *data =get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc = IDENT;</span><br><span class="line">    <span class="comment">// 循环次数减半</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;limit; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        acc = acc OP data[i] OP data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环不一定是2的倍数，这里处理剩下的元素</span></span><br><span class="line">    <span class="keyword">for</span>(;i&lt;length; i++) &#123;</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结合律"><a href="#结合律" class="headerlink" title="结合律"></a>结合律</h3><p>对于满足结合律的运算，可以通过结合律来优化。对于上面的combine5函数来说，他的执行流程是这样的。因为每次乘的时候都要等上一个的结果，所以是线性的。</p>
<p><img src="/../images/csapp/csapp5-1.png" alt="结合律1"></p>
<p>使用结合律优化以后，执行路程是下面这样的，为啥它能并行呢，因为在执行左边<code>acc * (i * i+1)</code>结果的时候，就已经可以计算<code>i+2 * i+3</code>的结果了。这两个乘法并行了，所以缩短了执行时间。上面无法并行的原因是先计算了<code>acc * i</code>，当计算下一个<code>acc * i</code>的时候需要依赖上一次acc的结果。</p>
<p><img src="/../images/csapp/csapp5-2.png" alt="结合律2"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine6</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span> *data =get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc = IDENT;</span><br><span class="line">    <span class="comment">// 循环次数减半</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;limit; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 唯一的区别的就是这里加了括号</span></span><br><span class="line">        acc = acc OP (data[i] OP data[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环不一定是2的倍数，这里处理剩下的元素</span></span><br><span class="line">    <span class="keyword">for</span>(;i&lt;length; i++) &#123;</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多个累积变量"><a href="#多个累积变量" class="headerlink" title="多个累积变量"></a>多个累积变量</h3><p>还可以通过先求出所有i为偶数的结果，和i为奇数的结果，在把两个结果结合到一起。这样的话先计算奇数和偶数，这两个是互不干涉的，也可以达到上面结合律的效果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine7</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span> *data =get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc0 = IDENT;</span><br><span class="line">    <span class="type">data_t</span> acc1 = IDENT;</span><br><span class="line">    <span class="comment">// 循环次数减半</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;limit; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算偶数和奇数</span></span><br><span class="line">        acc0 = acc0 OP data[i]；</span><br><span class="line">        acc1 = acc1 OP data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环不一定是2的倍数，这里处理剩下的元素</span></span><br><span class="line">    <span class="keyword">for</span>(;i&lt;length; i++) &#123;</span><br><span class="line">        acc0 = acc0 OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = acc0 OP acc1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h1><h2 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h2><p>存储技术分为<code>易失存储</code>和<code>非易失存储</code>。</p>
<ul>
<li>易失存储：DRAM 也就是一般所说的电脑内存,SRAM 也就是一般的cpu缓存，CPU的L1缓存，L2,L3这些</li>
<li>非易失存储：机械硬盘，固态硬盘</li>
</ul>
<h3 id="机械硬盘"><a href="#机械硬盘" class="headerlink" title="机械硬盘"></a>机械硬盘</h3><p><img src="/../images/csapp/csapp6-1.png" alt="机械硬盘"></p>
<p>最便宜的存储，存储容量也很大。由下面的部分组成</p>
<ul>
<li>主轴：盘片放在主轴上</li>
<li>盘片：一个盘片有两个面可以进行存储</li>
<li>磁道：每个盘面上有多个磁道</li>
<li>扇区：每个磁道被划分为一组扇区</li>
<li>磁头：通过磁头进行读写扇区上的数据</li>
</ul>
<p><img src="/../images/csapp/csapp6-2.png" alt="机械硬盘"></p>
<p>所以在次盘上读写的时候，需要移动<code>磁头</code>，让磁头找到对应的盘面，在找到磁道和扇区，然后才能读写数据，所以<code>顺序读写</code>比<code>随机读写</code>快的多。因为顺序的话磁头只需要移动一点点距离，而随机需要移动很长的距离。</p>
<h3 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h3><p>固态硬盘是基于<code>闪存</code>的存储技术，价格比机械硬盘贵一些。因为是闪存，所以顺序读写和随机读写都比机械硬盘快。虽然固态的顺序读写和随机读写的差距缩小了，但是顺序读写依旧比随机读写快。</p>
<ul>
<li>块：整个闪存分成一个个块,一个块有32-128个页，块的大小为16KB-512KB</li>
<li>页：一个块有多个页组成，每次读写都是一个页，页的大小是512字节-4KB</li>
<li>闪存翻译层：连接IO总线和闪存数据，将数据放到IO总线里面，也将IO总线的数据放到闪存里面。</li>
</ul>
<p>固态每次写入需要先擦除一个页里面原来的内容，在写入新的，因此，擦除次数多了以后，这个页就会坏掉。为了提升固态的使用寿命，一般也会控制每次擦除寿命更高的页。</p>
<h3 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h3><p><img src="/../images/csapp/csapp6-3.png" alt="DRAM"></p>
<p>DRAM 也就是电脑内存，由下面几部分组成，价格比固态和机械硬盘贵的多，容量也小的多，现在大多数是16G内存。</p>
<ul>
<li>n * n的存储单元：真正存储数据的地方</li>
<li>行缓冲区：每次先将一行的数据取到缓冲区里面，在取对应的存储单元里面的数据。</li>
<li>addr引脚：发送行号和列号给DRAM，发送行号以后，将这一行数据取到行缓冲区里面，再发送列号以后，返回对应的数据</li>
<li>data引脚：传递数据</li>
</ul>
<p>DRAM的发展历史，RAS:发送行号，CAS:发送列号</p>
<ul>
<li>快页模式DRAM(Fast Page Mode DRAM, FPMDRAM)。传统的DRAM将存储单元的一整行复制到它的内部行缓冲区中， 使用一个 ，然后丢弃剩余的。FPM DRAM允许对同一行连续地访问可以直接从行缓冲区得到服务，从而改进了这一 点。例如，要从一个传统的DRAM的行i中读4个存储单元，内存控制器必须发送4 个RAS&#x2F;CAS请求，即使是行地址i在每个情况中都是一样的。要从一个FPM DRAM的同一行中读取存储单元，内存控制器发送第一个RAS&#x2F;CAS请求，后面跟三个CAS请求。初始的RAS&#x2F; CAS请求将行i复制到行缓冲区，并返回CAS寻址的那个存储单元。接下来三个存储单元直接从行缓冲区获得，因此返回得更快。</li>
<li>扩展数据输出 DRAM( Extended Data Out DRAM, EDO DRAM) . FPM DRAM 的一个增强的形式 ，它允许各个 CAS 信号在时间上靠得更紧密一点。</li>
<li>同步DRAM(Synchronous DRAM，SDRAM)。就它们与内存控制器通信使用一组显式的控制信号来说，常规的FPM 和EDO DRAM 都是异步的。SDRAM用与驱动内存控制器相同的外部时钟信号的上升沿来代替许多这样的控制信号。我们不会深人讨论细节， 最终效果就是SDRAM 能够比那些异步的存储器更快地输出它的超单元的内容。</li>
<li>双倍数据速率同步DRAM(Double Data-Rate SynchronousDRAM, DDR SDRAM)。 DDR SDRAM 是 对 SDRAM 的一种增强 ，它通过使用两个时钟沿作为控制信号，从而使DRAM的速度翻倍。不同类型的DDR SDRAM 是用提高有效带宽的很小的预取绥冲区的大小来划分的 : DDR (2位)、 DDR2 (4位)和 DDR (8位)。</li>
</ul>
<p>现在一般的DDR5，DDR4，其实就是DDR DRAM内存。</p>
<h3 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h3><p>SRAM 也就是电脑CPU的L1,L2,L3三级缓存使用的，价格比DRAM更贵，容量更小。通常是多少KB或MB。</p>
<p>SRAM将每个位存储在一个双稳态的(bistable)存储器单元里。每个单元是用一个六晶体管电路来实现的。这个电路有这样一个属性，它可以无限期地保持在两个不同的电压 配置(configuration )或状态(state) 之一。其他任何状态都是不稳定的一一从不稳定状态开始，电路会迅速地转移到两个稳定状态中的一个。</p>
<p><img src="/../images/csapp/csapp6-4.png" alt="SRAM"></p>
<h2 id="局部性-locality"><a href="#局部性-locality" class="headerlink" title="局部性(locality)"></a>局部性(locality)</h2><p>局部性分为<code>空间局部性(spatial locality)</code>和<code>时间局部性(temporal locality)</code>。</p>
<p>从上面也能看出，DRAM一次加载一行到行缓冲区，如果我们要的数据都在这一行，取的时候就会很快。这就是<code>空间局部性</code>。</p>
<p>比如数组的顺序访问。这个时候一个个接着访问的，就具有空间局部性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">100</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,...&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ai:%d&quot;</span>,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二维数组是一样的，需要按照行来访问。而不能按照列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">100</span>][<span class="number">100</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,...&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,...&#125;,...&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;aij:%d&quot;</span>,a[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照列访问，不具有局部性，应该使用上面那种方式</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;aij:%d&quot;</span>,a[j][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三维数组,也应该使用行访问。<br>{<br>    {<br>        {0,0,0,…}, &#x2F;&#x2F; 000, 001, 002, 003<br>        {0,0,0,…}, &#x2F;&#x2F; 010, 011, 012, 013<br>        {0,0,0,…},<br>        {0,0,0,…}<br>    },<br>    {<br>        {0,0,0,…}, &#x2F;&#x2F; 100, 101, 102, 103<br>        {0,0,0,…}, &#x2F;&#x2F; 110, 111, 112, 113<br>        {0,0,0,…},<br>        {0,0,0,…}<br>    },<br>    {<br>        {0,0,0,…},<br>        {0,0,0,…},<br>        {0,0,0,…},<br>        {0,0,0,…}<br>    },…<br>} </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">100</span>][<span class="number">100</span>] = &#123;&#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,...&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,...&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,...&#125;,...&#125;,&#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,...&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,...&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,...&#125;,...&#125;,...&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">100</span>; k++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;aijk:%d&quot;</span>,a[i][j][k]);</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用最近使用过的数据，就是<code>时间局部性</code>。这是因为缓存的原因，比如最近使用过的数据还在L1缓存中，就会比再去DRAM中取数据要快。</p>
<p>sum就有 时间局部性，一直在使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">100</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,...&#125; </span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    sum += a[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ai:%d&quot;</span>,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="存储器层次结构-1"><a href="#存储器层次结构-1" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h2><p><img src="/../images/csapp/csapp6-5.png" alt="存储器层次结构"></p>
<p>通常，高层的可以作为低层的缓存，比如L1缓存L2的数据，L2缓存L3的，L3缓存内存的。数据以块为大小传输。</p>
<ul>
<li>缓存命中(cache hit)：要查找的内容就在L1缓存中，就不需要去L2查找了</li>
<li>缓存不命中(cache miss): 要查找的内容不在L1中，而在L2中，需要从L2传输到L1中。<ul>
<li>强制性不命中(compulsory miss): 在第一次访问缓存的时候，缓存中肯定是空的。这个时候肯定不会命中。</li>
<li>冲突不命中(conflict miss): 缓存已经满了以后需要进行替换，比如LRU算法，比如取余算法，这个时候有可能你需要的缓存被替换出去了，因为这个原因不命中的，就是冲突不命中。</li>
<li>容量不命中(capacity miss): 因为缓存不够大而没有命中的。</li>
</ul>
</li>
</ul>
<h2 id="高速缓存存储器"><a href="#高速缓存存储器" class="headerlink" title="高速缓存存储器"></a>高速缓存存储器</h2><p>像L1,L2这种SRAM，就是<code>高速缓存存储器</code>。</p>
<p>假设每个存储器地址有m位，形成$M &#x3D; 2^m$个不同的地址。它由 $S &#x3D; 2^s$ 个set组成。每个set里面有 $E &#x3D; 2^e $ 个缓存行。每个行有 $B &#x3D; 2^b$字节的数据块组成。高速缓存的大小$C &#x3D; S * E * B$(不包括Tag和Valid)</p>
<p><img src="/../images/csapp/csapp6-6.png" alt="高速缓存存储器"></p>
<p>每个数据块有</p>
<ul>
<li>Valid: 1bit，0表示无效缓存，1表示有效缓存</li>
<li>Tag: t个bit，一些标记 t &#x3D; m - (b + s)</li>
<li>Data: 真正的数据，有$B &#x3D; 2^b$字节</li>
</ul>
<p><img src="/../images/csapp/csapp6-7.png" alt="高速缓存存储器 block"></p>
<p>m个地址位的组成：</p>
<ul>
<li>t个bit:Tag，用来匹配高速缓存中的Tag，如果匹配上了说明缓存命中。</li>
<li>s个bit:set index,用来找到对应的数据在哪个set里面。</li>
<li>b个bit:block offset,用来找到具体数据在block的哪个位置里面。</li>
</ul>
<p><img src="/../images/csapp/csapp6-8.png" alt="高速缓存存储器 addr"></p>
<h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>假设 m &#x3D; 6,s &#x3D; 2,t &#x3D; 1, b &#x3D; 3, e &#x3D; 1, 则 S &#x3D; 4个set,E &#x3D; 2个行，B &#x3D; 8字节。大小C &#x3D;4 * 2 * 8 &#x3D; 64。</p>
<p>假设 当前m &#x3D; 000001, 那么 tag &#x3D; 0, bit set &#x3D; 00, block offset &#x3D; 001。</p>
<p>缓存命中的情况。总共4个set，找到第0个set，然后找到其中tag是0并且valid是1的一个block，找到以后，找 001位置的数据，然后返回就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    valid   tag     data</span><br><span class="line">00   1       0      ...    // 首先找到set 00 的这个set,有两行，这一行</span><br><span class="line">00   0       0      ...    // 还有这一行</span><br><span class="line">01   0       0      ...</span><br><span class="line">01   0       0      ...</span><br><span class="line">10   1       0      ...</span><br><span class="line">10   1       0      ...</span><br><span class="line">11   0       0      ...</span><br><span class="line">11   0       0      ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../images/csapp/csapp6-9.png" alt="高速缓存存储器 addr"></p>
<p>缓存不命中的情况。总共4个set，找到第2个set，然后找到其中tag是0并且valid是1的，这个时候发现没有匹配的，那么触发miss，开始去下一层获取数据，获取到数据以后，通过替换算法替换掉一个行，将tag修改为0并且valid修改为1，然后把数据写入block data。再返回001位置的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    valid   tag     data</span><br><span class="line">00   1       0      ...    </span><br><span class="line">00   0       0      ...    </span><br><span class="line">01   0       0      ...    // 首先找到set 01 的这个set,有两行，这一行</span><br><span class="line">01   0       0      ...    // 还有这一行</span><br><span class="line">10   1       0      ...</span><br><span class="line">10   1       0      ...</span><br><span class="line">11   0       0      ...</span><br><span class="line">11   0       0      ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>冲突不命中，比如计算两个数组的点积。这个时候a[0] * b[0],会先把数组a加载到L1缓存，然后再把b加载到L1缓存，这个时候b会把a覆盖，然后a[1] * b[1]的时候，a就会冲突不命中，然后用a把b覆盖，一直重复这个动作。这个时候可以增加E,比如一个set里面有多个block，这样就不会覆盖了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">dotProd</span><span class="params">(<span class="type">float</span> a[<span class="number">100</span>], <span class="type">float</span> b[<span class="number">100</span>])</span> &#123;</span><br><span class="line">    <span class="type">float</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        sum += a[i] * b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>在写入的时候有两种情况，缓存命中和不命中，通常的搭配是<code>write through + no write allocate</code>和<code>write back + write allocate</code></p>
<ul>
<li>缓存命中<ul>
<li>wirte through: 这个时候直接写入缓存。并且修改下一层的数据。相当于同步修改。</li>
<li>write back: 直接写入缓存，并且标记dirty, 尽可能的推迟更新下一层的数据，只有当替换算法执行的时候才更新。相当于异步修改。</li>
</ul>
</li>
<li>缓存不命中<ul>
<li>write allocate: 先把数据从下一层加载到缓存，然后更新缓存数据。</li>
<li>no write allocate: 直接写入下一层数据。</li>
</ul>
</li>
</ul>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>c文件变成可执行文件的过程</p>
<ul>
<li>c预处理器cpp生成ASCII码的.i文件, cpp main.c main.i</li>
<li>c编译器cc1生成ASCII汇编语言.s文件, cc1 main.i -Og -o main.s</li>
<li>汇编器as生成可重定位目标文件.o文件， as -o main.o main.s </li>
<li>链接器ld生成可执行文件, ld -o main main.o</li>
</ul>
<p>为了构造可执行文件，链接器必须完成两个主要任务</p>
<ol>
<li>符号解析。目标文件定义和引用符号，每个符号对应于一个函数 、一个全局变量或一个静态变量 (即C语言中任何以 static 属性声明的变量)。 符号解析的目的是将每个符号引用正好和一个符号定义关联起来</li>
<li>重定位。编译器和汇编器生成从地址。开始的代码和数据节。链接器通 过把每个符号定义与 一个内存位置关联起来，从而重定位这些节，然后修改所有对 这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条 目(relocation entry)的详细指令，不加甄别地执行这样的重定位。</li>
</ol>
<p>目标文件有三种形式</p>
<ul>
<li>可重定位目标文件。包含二进制和代码数据，可与其他重定位目标文件合并起来变成可执行目标文件。</li>
<li>可执行目标文件。包含二进制和代码数据，可被直接复制到内存并执行。</li>
<li>共享目标文件。一种特殊类型的可重定位目标文件，可在加载或运行时被动态的加载进内存并链接。</li>
</ul>
<p><code>ELF(x86-64的Linux系统的文件)可重定位目标文件</code>的格式</p>
<ul>
<li>ELF头。</li>
<li>.text。已编译程序机器代码</li>
<li>.rodata。只读数据，比如printf语句中的格式串</li>
<li>.data。已初始化的全局和静态变量。</li>
<li>.bss。未初始化的全局和静态变量，以及所有初始化为0的全局和静态变量。不占据实际空间，仅仅是一个占位符。</li>
<li>.symtab。一个符号表，用来存放 在程序中定义和引用的函数和全局变量的信息。</li>
<li>.rel.text。一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修 改。另 一方面，调用本地函数的指令则不需要修改</li>
<li>.rel.data。被模块引用或定义的所有全局变量的重定位信息。</li>
<li>.debug。一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定 义和引用的全局变量，以及原始的C源文件。只有以 -g选项调用编译器驱动程序时，才会得到这个表</li>
<li>.line。原始C源程序中的行号和.text 节中机器指令之间的映射。只有以-g选项调 用编译器驱动程序时，才会得到这张表</li>
<li>.strtab。一个字符串表，包括.symtab和.debug中的符号表，以及节头 部中的节名字。字符串表就是以nu 11 结尾的字符串的序列。</li>
</ul>
<p>每个可重定位目标模块m都有一个符号表，它包含m定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号:</p>
<ul>
<li>由模块m定义的并能被其他模块引用的全局符号。对应非静态的C函数和全局变量。</li>
<li>由其他模块定义的并被m引用的全局符号。对应其他模块的非静态的C函数和全局变量。</li>
<li>由模块m定义和引用的局部符号。对应于静态的C函数和全局变量。</li>
</ul>
<p>C++ 和Java 都允许重载方法，这些方法在源代码中有相同的名字，却有不同的参数 列表。那么链接器是如何区别这些不同的重载函数之间的差异呢?C++ 和Java 中能使用 重载函数，是因为编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一 的名字。这种编码过程叫做重整(mangling)，而相反的过程叫做恢复(demangling)。 幸运的是，C++ 和Java使用兼容的重整策略。一个被重整的类名字是由名字中字符 的整数数量，后面跟原始名字组成的。比如，类Foo 被编码成3Foo。方法被编码为原始方法名， 后面加上 __ ， 加上被重整的类名， 再加上每个参数的单字母编码。 比如，Foo::bar (int, long)被编码为bar__3Fooil。重整全局变量和模板名字的策略是相似的。</p>
<p>链接器对多个文件中同名变量或函数的处理。编译器会先分<code>强符号</code>和<code>弱符号</code>,强符号指函数和已初始化的全局变量，弱符号指未初始化的全局变量。</p>
<ol>
<li>不允许有多个同名的强符号</li>
<li>如果有一个强符号和多个弱符号同名，那么选择强符号。</li>
<li>如果有多个弱符号同名，那么从这些弱符号中任意选择一个。</li>
</ol>
<p>上面说的链接器接受一组<code>可重定位文件</code>，并生成一个<code>可执行文件</code>，所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为<code>静态库</code>。它也可以用作链接器的输入。当构造可执行文件的时候，直接复制静态库里面被应用程序引用的目标模块。静态库是<code>.a</code>文件。</p>
<p><code>可执行目标文件</code>的格式</p>
<ul>
<li>ELF头。</li>
<li><code>段头部表</code></li>
<li><code>.init</code>。定义了一个函_init，程序的初始化代码会调用它</li>
<li>.text。已编译程序机器代码</li>
<li>.rodata。只读数据，比如printf语句中的格式串</li>
<li>.data。已初始化的全局和静态变量。</li>
<li>.bss。未初始化的全局和静态变量，以及所有初始化为0的全局和静态变量。不占据实际空间，仅仅是一个占位符。</li>
<li>.symtab。一个符号表，用来存放 在程序中定义和引用的函数和全局变量的信息。</li>
<li>.debug。一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定 义和引用的全局变量，以及原始的C源文件。只有以 -g选项调用编译器驱动程序时，才会得到这个表</li>
<li>.line。原始C源程序中的行号和.text 节中机器指令之间的映射。只有以-g选项调 用编译器驱动程序时，才会得到这张表</li>
<li>.strtab。一个字符串表，包括.symtab和.debug中的符号表，以及节头 部中的节名字。字符串表就是以nu 11 结尾的字符串的序列。</li>
</ul>
<p><code>动态库</code>也叫<code>共享库</code>是致力于解决静态库缺陷的一个现代创新产物。共享库是一个 目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。在linux中常用<code>.so</code>后缀来表示。 微软的操作系统大量地使用了共享库，它们称为DLL(动态链接库)</p>
<p>共享库是以两种不同的方式来<code>共享</code>的。首先，在任何给定的文件系统中 ，对于一个库只有一个 <code>.so</code> 文件 。 所有引用该库的可执行目标文件共享这个.so文 件中的代码和数据 ，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行的文件中</p>
<p> <code>共享库和Java本地接口</code> Java定义了一个标准调用规则，叫做Java本地接口(Java Native Interface, JNI)，它允许Java程序调用“本地的” C和C++ 函数。JNI的基本思想是将本地C函数(如Foo)编译 到一个共享库中 (如 Foo.so )。 当一个正在运行的Java 程序试图调用函数 Foo 时 ，Java解释器 利用dlopen 接口 (或者与其类似的接口)动态链接和加载 Foo.so，然后再调用Foo。</p>
<p>在 Linux 系统中有大量可用的工具可以帮助你理解和处理目标文件。特别地，GNU binutils 包尤其有帮助，而且可以运行在每个Linux 平台上。</p>
<ul>
<li>AR:创建静态库，插人、删除、列出和提取成员。</li>
<li>STRINGS:列出一个目标文件中所有可打印的字符串。</li>
<li>STRIP:从目标文件中删除符号表信息。</li>
<li>NM:列出一个目标文件的符号表中定义的符号。</li>
<li>SIZE:列出目标文件中节的名字和大小。</li>
<li>READELF:显示 一个目标文件的完整结构，包括ELF 头中编码的所有信息。包含 SIZE 和NM的功能。</li>
<li>OBJDUMP:所有二进制工具之母。能够显示 一个目标文件中所有的信息。它最大的作用是反汇编.text节中的二进制指令。</li>
</ul>
<p>Linux 系统为操作共享库还提供了LDD程序:</p>
<ul>
<li>LDD:列出一个可执行文件在运行时所需要的共享库。</li>
</ul>
<h1 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h1><p><code>异常控制流（ExceptionalControlFlow, ECF）</code>使程序能进行跳转，正常的程序执行都是PC里面一条条指令顺序执行的。ECF使PC里面的下一条指令变成别的指令，从而完成别的功能。ECF在系统的各个层次，比如进程切换，操作系统调用，网络请求处理，IO请求处理，是计算机中实现并发的基本机制。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常是异常控制流的一种形式，它 一部分由硬件实现，一部分由操作系统实现。</p>
<p>假设当前程序正在运行，出现了<code>缺页异常</code>，也就是数据在内存中不存在，需要进行IO请求将数据加载到内存中。执行图如下，异常处理程序有很多，每个异常都有对应的处理程序，当异常发生以后，系统切换到异常处理程序中执行。异常处理完成以后返回用户程序继续执行。</p>
<p><img src="/../images/csapp/csapp8-1.png" alt="异常"></p>
<p>根据异常的不同，返回会发生三种情况：</p>
<ul>
<li>异常处理程序将控制返回给当前用户程序正在执行的指令</li>
<li>异常处理程序将控制返回给当前用户程序的下一个指令</li>
<li>异常处理程序终止当前用户程序</li>
</ul>
<blockquote>
<p>这里说的都是<code>硬件异常</code>，和Java中try catch的<code>软件异常</code>是不一样的。</p>
</blockquote>
<p>系统中可能的每种类型的异常都分配了一个唯 一的非负整数的<code>异常号</code>。有的异常号是处理器的设计者分配的，有的是操作系统的设计者分配的。前者包括被零除，缺页，断点，算术运算溢出，后者包括系统调用和外部IO设备的信号。</p>
<p>在系统启动时，操作系统会分配一个<code>异常表</code>。异常表的key就是异常号，value是异常处理程序的地址。当发生异常的时候，通过异常号找到异常处理地址，然后进行处理。异常表的首地址则放在<code>异常表基址寄存器</code>里面。硬件触发异常以后，就由<code>异常处理程序</code>软件进行执行了，执行在内核模式下。</p>
<p>异常可以分为4类，中断(interrupt),陷阱(trap)，故障(fault)和终止(abort)</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">原因</th>
<th align="left">异步&#x2F;同步</th>
<th align="left">返回</th>
</tr>
</thead>
<tbody><tr>
<td align="left">中断</td>
<td align="left">来自I&#x2F;O 设备的信号</td>
<td align="left">异步</td>
<td align="left">总是返回到下一条指令</td>
</tr>
<tr>
<td align="left">陷阱</td>
<td align="left">有意的异常</td>
<td align="left">同步</td>
<td align="left">总是返回到下一条指令</td>
</tr>
<tr>
<td align="left">故障</td>
<td align="left">潜在可恢复的错误</td>
<td align="left">同步</td>
<td align="left">可能返回到当前指令</td>
</tr>
<tr>
<td align="left">终止</td>
<td align="left">不 可恢复的错误</td>
<td align="left">同步</td>
<td align="left">不返回，直接终止程序</td>
</tr>
</tbody></table>
<p>中断是异步发生的，中断发生的时候拉起中断引脚。处理器发现中断引脚被拉起，就从系统总线读取异常号，然后执行对应的异常处理程序。执行完成以后继续返回执行下一条指令。</p>
<p>陷阱是有意的异常，最重要的作用是触发<code>系统调用</code>，正常用户程序都是运行在<code>用户模式</code>下，可以执行的功能有限，如果需要读取文件，创建进程等操作，就需要切换到<code>内核模式</code>下，由操作系统内核来进行处理。通过系统调用就可以切换到内核执行。</p>
<p>故障由错误情况引起，它可能能够被故障处理程序修正。比如<code>缺页异常</code>就是一个故障。当发生以后，故障处理程序进行处理，从磁盘加载数据，加载以后重新执行当前指令，就会成功了。如果故障没有被修正，那么就会转为abort，终止当前程序。</p>
<p>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误。</p>
<p>x86-64系统定义了多达256种不同的异常类型，0-31号是由Inter架构师定义的，因此所有x86-64系统的电脑都是一样的。32-255对应的是操作系统定义的中断和陷阱。</p>
<p>下面是一些系统调用：</p>
<p><img src="/../images/csapp/csapp8-2.png" alt="系统调用"></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><code>进程</code>的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个<code>进程的上下文</code>(context)中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合.</p>
<p>进程提供给应用程序的关键抽象</p>
<ul>
<li>一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占处理器</li>
<li>一个私有地址空间，它提供一个假象，好像我们的程序独占内存</li>
</ul>
<p>&#x2F;proc文件系统将许多内核数据结构的内容输出为 一个用户程序可以读的文 本文件的层次结构。比如，你可以使用&#x2F;proc 文件系统找出一般的系统属性，比如CPU类型 (&#x2F;proc&#x2F;cpuinfo)，或者某个特 的进程使用的内存段(&#x2F;proc&#x2F;<process-id>&#x2F;maps)。2.6 版本的Linux内核引人&#x2F;sys 文件系统，它输出关于系统总线和设备的额外的低层信息</p>
<p>操作系统内核使用一种称为上下文切换(context switch)的较高层形式的异常控制流来实现多任务。上下文包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。</p>
<p>在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程。</p>
<p>上下文切换</p>
<ul>
<li>保存当前进程的上下文</li>
<li>恢复要执行的进程的上下文</li>
<li>将控制传递给这个新恢复的进程</li>
</ul>
<p>当Unix 系统级函数遇到错误时，它们通常会返回一1，并设置全局整数变量errno 来表示什么出错了.比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// strerror函数返回一个文本串，描述了和某个errno值相关联的错误</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork error: %s \n&quot;</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一些进程控制的系统调用C函数</p>
<ul>
<li>getpid(), 获取当前进程的pid</li>
<li>getppid(), 获取当前进程的父进程的pid</li>
<li>waitpid(), 等待子进程终止</li>
<li>sleep(), 让程序休眠，时间到啦返回0，时间没到被其他信号中断则返回剩余秒数</li>
<li>pause(), 让程序休眠直到收到信号</li>
<li>execve(), 在当前进程的上下文中加载并运行一个新程序</li>
<li>getpgrp(), 返回当前进程的进程组id</li>
<li>signal(), 设置信号处理函数</li>
</ul>
<p>从程序员的角度，可以认为进程总是处于下面三个状态之一</p>
<ul>
<li>运行：进程正在CPU上执行</li>
<li>阻塞：进程被挂起，比如读取磁盘的时候</li>
<li>终止：进程结束了，收到终止信号，主程序执行完，调用exit函数</li>
</ul>
<p>当一个子进程终止时，内核并不会立即清除它，进程会被保持为一种<code>已终止</code>的状态中，直到被父进程回收。这时候的子进程被称为<code>僵尸进程</code>。当父进程回收子进程后，内核将子进程的退出状态传递给父进程，然后清除子进程，这个时候子进程就不存在了。</p>
<p>如果一个父进程终止。它的子进程就被称为<code>孤儿进程</code>，内核会安排<code>init进程</code>成为它的孤儿进程的养父，init进程的pid为1，是在系统启动时由内核创建的，它是所有进程的祖先进程。如果父进程没有回收僵尸进程就死了，init进程会回收僵尸进程，不过长时间运行的程序比如shell或者服务器，总是应该回收它们的僵尸子进程，即使僵尸子进程没有运行，他们仍然消耗系统的内存资源。</p>
<p>一个进程可以通过<code>waitpid</code>函数来等待它的子进程终止或者停止。如果子进程已经终止，那么立即返回，如果子进程没有终止，挂起当前进程，等待子进程终止后返回，返回值为子进程的pid。此时，子进程已经被回收，内核会删除掉它的所有痕迹。</p>
<p>进程的执行顺序和回收顺序都是由操作系统内核通过异常控制流切换执行的，所以我们不能假设他们的执行顺序和回收顺序。</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p><code>Linux信号</code>允许进程和内核中断其他进程。一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。每个信号类型都对应一个系统事件，底层的硬件异常由内核异常处理程序处理的，正常情况下，对用户进程是不可见的。</p>
<p>下图是一些信号</p>
<p><img src="/../images/csapp/csapp8-3.png" alt="系统调用"></p>
<p>传送信号分为两部分</p>
<ol>
<li>发送信号。内核通过更新进程上下文中的某个状态，发送一个信号，可能有下面的原因<ul>
<li>内核检测到一个系统事件，比如除0或者子程序终止</li>
<li>一个进程调用了kill函数，显式的发送一个信号</li>
</ul>
</li>
<li>接收信号。当进程被内核强迫以某种方式对信号作出反应时，就接收了信号。进程可以忽略这个信号，终止或者通过执行<code>信号处理程序</code>来处理信号。</li>
<li>一个发出但没有被接收的信号叫做待处理信号。在任何时刻，一种类型至多只有一个待处理信号。</li>
</ol>
<p>发送信号的几种方式</p>
<ul>
<li>kill程序，kill -9 pid</li>
<li>kill函数，kill(pid, sig)</li>
<li>alarm函数，给自己发送SIGALRM信号</li>
<li>键盘，ctrl+c会发送SIGINT信号，默认终止前台作业，ctrl+z会发送SIGTSTP信号，默认挂起前台作业。</li>
</ul>
<p>前台作业和后台作业，系统只能有一个前台作业，但是可以有多个后台作业，前台作业就是通过waitpid等待程序在前台完成的，后台作业是运行在后台的，一般在命令最后面加上<code>&amp;</code>就可以让程序后台运行。</p>
<p>接收信号的几种处理</p>
<ol>
<li>忽略该信号</li>
<li>进程终止</li>
<li>用户程序捕获信号并处理</li>
</ol>
<p>可以通过<code>signal</code>函数来捕获信号并处理，第一个参数是信号，第二个参数是处理函数，如果处理函数是<code>SIG_IGN</code>，则忽略该信号，如果是<code>SIG_DFL</code>，则采用信号的默认行为处理，如果是一个函数，则执行他进行处理。</p>
<p><code>待处理的信号只能有一个</code>。再过来一个同类型的信号就会被丢弃，实际上处理方式是有一个<code>Pending</code>的位，如果有6个信号，Pending就有6位，一个信号对应一位，当有一个待处理信号的时候，相应的位就变成1，所以最多只有一个待处理，剩下的会被丢弃。所以我们不能假设所有的信号都能被接收并且处理。</p>
<p>为了解决上面的问题，就出现了<code>阻塞信号</code>。通过阻塞信号可以暂时阻塞住信号，不接收它，等我们把待处理信号处理了再<code>解除阻塞</code>然后接受它，这样的话就可以接收到每一个信号并处理了，同样的阻塞信号是通过<code>Blocked</code>位来实现的，有6个信号那么Blocked就有6位，阻塞一个信号，对应的位就变成1.</p>
<p>可以通过<code>sigprocmask</code>函数来设置Blocked位，他有三个参数，第一个参数决定了行为，第二个参数是一个set变量用来设置Blocked位，第三个参数是返回一个oldset变量来存储以前的Blocked位，当解除阻塞以后用来恢复Bloked位的。</p>
<p>第一个参数值</p>
<ul>
<li>SIG_BLOCK: 把set中的位添加到Bloked中，相当于Blocked &#x3D; Blokced | set</li>
<li>SIG_UNBLOCK: 从Blocked中删除set中的位，相当于 Blocked &#x3D; Blocked &amp; ~set</li>
<li>SIG_SETMASK: Blocked &#x3D; set</li>
</ul>
<p>使用下面的函数可以操作set变量中的位。</p>
<ul>
<li>sigemptyset。初始化set为空集合</li>
<li>sigfillset. 把每个信号都添加到set中</li>
<li>sigaddset. 添加某个信号到set中</li>
<li>sigdelset. 从set中删除某个信号</li>
<li>sigismember. 判断某个信号是否在set中。</li>
</ul>
<p>信号处理程序的编写很麻烦，因为它和其他信号处理程序以及主程序都是并发执行的。为了保证安全，要尽可能的保守，以下是一些基本原则。</p>
<ul>
<li>处理程序要尽可能简单。避免麻烦的最好方法是保持处理程序尽可能小和简 单。例如，处理程序可能只是简单地设置全局标志并立即返回;所有与接收信号相 关的处理都由主程序执行，它周期性地检查(并重置)这个标志</li>
<li>在处理程序中只调用异步信号安全的函数。所谓异步信号安全的函数(或简称安全的函 数)能够被信号处理程序安全地调用，原因有二:要么它是可重入的， 要么它不能被信号处理程序中断.</li>
<li>信号处理程序中产生输出唯一安全的方法是使用 write 函数</li>
<li>保存和恢复errno。许多Linux异步信号安全的函数都会在出错返回时设置 errno 。</li>
<li>阻塞所有的信号，保护对共享全局数据结构的访问</li>
<li>用 volatile 声明全局变量 。 </li>
<li>用 <code>sig_atomic_t</code> 声明标志。在常见的处理程序设计中，处理程序会写全局标 志来记录收到了信号。主程序周期性地读这个标志，响应信号，再清除该标志。对于通过这种方式来共享的标志 ， C 提供一种整型数据类型 sig_atomic_t， 对它的读和写保证会是原子的(不可中断的)，因为可以用一条指令来实现它们</li>
</ul>
<h2 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h2><p>当程序返回的时候一般都是通过调用栈一层层返回，有的时候会很麻烦，为了避免这种情况，出现了<code>非本地跳转</code>，它通过<code>setjmp</code>和<code>longjmp</code>来进行直接跳转，避免了一层层返回。</p>
<p>setjmp保存当前的运行环境，longjmp可以跳回setjmp的地方。</p>
<p>C++和Java 提供的异常机制是较高层次的，是C语言的setjmp和longjmp 函数的更加结构化的版本。你可以把try语句中的catch 子句看做类似于setjmp函数。相似地，throw语句就类似于longjmp 函数。</p>
<h1 id="系统级IO"><a href="#系统级IO" class="headerlink" title="系统级IO"></a>系统级IO</h1><p>在Linux中，<code>所有的一切都是文件</code>。所以文件读取可以控制一切，包括磁盘读写，网络编程都是通过文件IO来控制的。一个Linux文件就是一个m个字节的序列。</p>
<p>Unix IO接口提供了对文件的控制</p>
<ul>
<li>打开文件。返回一个<code>文件描述符</code></li>
<li>读取文件。读操作就是将文件内容复制到内存中。</li>
<li>写文件。写操作就是将内存中的内容写入到文件中。</li>
<li>改变当前的文件读写指针位置。打开文件的时候，初始为0.</li>
<li>关闭文件。关闭这个文件。</li>
</ul>
<p>Linux shell创建的每个进程开始时都有三个打开的文件:标准输入(描述符为0)、标准输出(描述符为1)和标准错误(描述符为2)</p>
<p>每个文件都有一个类型</p>
<ul>
<li>普通文件：包含任意数据，操作系统并不区分文本文件和二进制文件，在更高层的级别有的会区分<ul>
<li>文本文件： 只含有ASCII和 Unicode 字符的普通文件。</li>
<li>二进制文件： 所有其他的普通文件，对于内核来说，二进制和文本文件没有区别。</li>
</ul>
</li>
<li>目录：包含一组链接的文件，其中每个链接都将一个文件名映射到一个文件，这个文件也可能是另一个目录，每个目录至少含有两个条目<ul>
<li>.是该目录自身的链接</li>
<li>..是父目录的链接</li>
</ul>
</li>
<li>socket：是用来与另一个进程进行跨网络通信的文件</li>
</ul>
<p>Linux将所有文件都组织成一个目录结构，最上面是<code>/</code>根目录，其他所有目录都是它的子级。</p>
<p><img src="/../images/csapp/csapp10-1.png" alt="目录结构"></p>
<p>打开文件以后返回的文件描述符总是在进程中当前没有打开的最小描述符。通过系统的<code>limit</code>命令可以看到当前系统可以同时打开的文件数量。</p>
<p>Unix对文件的读取和写入操作可能会遇到<code>不足值(short count)</code>的问题。比如你要读取一个文件的前100个字节，但是这个文件每行50个字节，所以51个字节就是<code>换行符EOL</code>，换行符在Linux&#x2F;mac里面是<code>LF</code>,在win里面是<code>CRLF</code>。当遇到换行的时候只会读入换行前的50个字节，然后读取换行的时候会读取0个字节，再之后才能读取下一行。下面是几种会遇到不足值的情况。</p>
<ul>
<li>读的时候遇到换行</li>
<li>从终端读文本。从终端读取的话，read一次读取一行</li>
<li>读写socket</li>
</ul>
<h3 id="RIO包"><a href="#RIO包" class="headerlink" title="RIO包"></a>RIO包</h3><p>RIO包解决了不足值的问题，它提供了两类函数</p>
<ul>
<li>无缓冲输入输出：没有应用级缓冲，对二进制数据读写到网络和从网络读写二进制数据尤其有用</li>
<li>有缓冲输入输出：先读取或写入到缓冲区里面，在调用系统的read&#x2F;write来读写。效率更高，开销小，RIO还是线程安全的。</li>
</ul>
<p>无缓冲输入输出</p>
<ul>
<li>rio_readn(int fd, void * usrbuf, size_t n):从fd文件描述符中读取n个字节到内存usrbuf中</li>
<li>rio_writen(int fd, void * usrbuf, size_t n):从内存usrbuf中写入n个字节到fd中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usbuf, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;</span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line">    <span class="type">char</span> *bufp =usrbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没读取够需要的n个字节就一直循环读取</span></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 从fd中读取nleft个字节到内存bufp中 </span></span><br><span class="line">        <span class="keyword">if</span> ((nread = read(fd, bufp, nleft)) ‹ <span class="number">0</span>)  &#123;</span><br><span class="line">            <span class="comment">// 如果读取失败 判断失败类型如果是被信号打断则再次读取，如果是其他失败，则返回失败</span></span><br><span class="line">            <span class="keyword">if</span> (errno = EINTR) <span class="comment">/* Interrupted by sig handler return */</span></span><br><span class="line">                nread =<span class="number">0</span>; <span class="comment">/*andcall read()again*/</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* errno set by read() */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread = <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果是读取到0个，则是读取到换行符，继续读取</span></span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* EOF */</span></span><br><span class="line">        <span class="comment">// 读取的字节数变少，bufp增加</span></span><br><span class="line">        nleft -= nread;</span><br><span class="line">        bufp += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回读取到的字节数</span></span><br><span class="line">    <span class="keyword">return</span> n - nleft; <span class="comment">/* Return &gt;= 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft =n;</span><br><span class="line">    <span class="type">ssize_t</span> nwritten;</span><br><span class="line">    <span class="type">char</span> *bufp =usrbuf;</span><br><span class="line">    <span class="keyword">while</span> (nleft &gt;<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((nwritten =write(fd, bufp, nleft)) « <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (errno = EINTR) <span class="comment">/* Interrupted by sig handler return */</span> </span><br><span class="line">                written = <span class="number">0</span>; <span class="comment">/* and call write() again */</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* errno set by write() */</span></span><br><span class="line">        &#125;</span><br><span class="line">        nleft -= nwritten;</span><br><span class="line">        bufp += nwritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有缓冲输入输出</p>
<ul>
<li>rio_readinitb(rio_t *rp, int fd): 初始化一个读取的缓冲区rp，读取的时候会先从fd文件中读取数据到rp缓冲区里面，然后在从缓冲区读取</li>
<li>rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen): 从缓冲区rp中读取一个文本行到内存usrbuf中，最多maxlen-1个字节，最后以NULL结尾。如果一行不足maxlen-1，则读取一整行，如果超过maxlen-1，就截断他</li>
<li>rio_readnb(rio_t *rp, void *usrbuf, size_t n): 对于既包含文本行也包含二进制数据的读取可以使用这个函数，它是rio_readn带缓冲区的版本。</li>
</ul>
<p>下面是缓冲区<code>rio_t</code>结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> rio_fd; <span class="comment">/* 文件描述符fd */</span> </span><br><span class="line">    <span class="type">int</span> rio_cnt; <span class="comment">/* 缓冲区未读取的字节数 */</span> </span><br><span class="line">    <span class="type">char</span> *rio_bufptr; <span class="comment">/* 下一个要读取的指针 */</span> </span><br><span class="line">    <span class="type">char</span> rio_buf [RIO_BUFSIZE]; <span class="comment">/* 缓冲区 */</span></span><br><span class="line">&#125; <span class="type">rio_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rio_readinitb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    rp-&gt;rio_fd =fd;</span><br><span class="line">    rp-&gt;rio_cnt = <span class="number">0</span>;</span><br><span class="line">    rp-&gt;rio_bufptr = rp-&gt;rio_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/csapp/csapp10-2.png" alt="缓冲区rio_t结构体"></p>
<p>读取最核心的是<code>rio_read</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">rio_read</span><span class="params">(<span class="type">rio_t</span> *rp , <span class="type">char</span> *usrbuf, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始读取数据到缓冲区rp</span></span><br><span class="line">    <span class="keyword">while</span> (rp-&gt;rio_cnt &lt;= <span class="number">0</span>) &#123; <span class="comment">/* Refill if buf is empty */</span></span><br><span class="line">        <span class="comment">// 调用 read读取</span></span><br><span class="line">        rp-&gt;rio_cnt = read(rp-&gt;rio_fd, rp-&gt;rio_buf, <span class="keyword">sizeof</span>(rp-&gt;rio_buf));</span><br><span class="line">        <span class="comment">// 判断是否读取失败</span></span><br><span class="line">        <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果不是被信号打断，就是真的失败，返回-1 如果是被打断的话回到while继续读取</span></span><br><span class="line">            <span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rp-&gt;rio_cnt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取到换行符，继续读取</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 读取成功 缓冲区指针指向缓冲区开头</span></span><br><span class="line">            rp-&gt;rio_bufptr = rp-&gt;rio_buf; <span class="comment">/* Reset buffer ptr */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始冲缓冲区读取数据到usrbuf</span></span><br><span class="line">    <span class="comment">/* Copy min(n, rp-›rio_cnt) bytes from internal buf to user buf */</span></span><br><span class="line">    <span class="comment">// 默认读取n个字节，如果缓冲区不足n个，就读取整个缓冲区</span></span><br><span class="line">    cnt = n;</span><br><span class="line">    <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; n) &#123;</span><br><span class="line">        cnt = rp-&gt;rio_cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从缓冲区读取到usrbuf</span></span><br><span class="line">    <span class="built_in">memcpy</span>(usrbuf, rp-&gt;rio_bufptr, cnt);</span><br><span class="line">    <span class="comment">// 修改缓冲区指针</span></span><br><span class="line">    rp-&gt;rio_bufptr += cnt;</span><br><span class="line">    <span class="comment">// 修改缓冲区未读字节数量</span></span><br><span class="line">    rp-&gt;rio_cnt -= cnt;</span><br><span class="line">    <span class="comment">// 返回读取的字节数</span></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rio_readlineb和rio_readnb都是用了rio_read函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readlineb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> maxlen)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n,rc;</span><br><span class="line">    <span class="type">char</span> c, *bufp = usrbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环从缓冲区读取</span></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++) &#123;</span><br><span class="line">        <span class="comment">// 从缓冲区读取1个字节到c里面 如果rc == 1则读取成功</span></span><br><span class="line">        <span class="keyword">if</span> ((rc = rio_read(rp, &amp;c, <span class="number">1</span>)) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取成功把读取到的字节放到bufp指向的usrbuf位置 然后bufp指向下一个usrbuf字节</span></span><br><span class="line">            *bufp++ = c;</span><br><span class="line">            <span class="comment">// 如果读取到的是换行 n++再次读取</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                n++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取EOF</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 出错，返回-1表示错误</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取结束以后重制bufp指针</span></span><br><span class="line">    *bufp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 返回 读取字节数</span></span><br><span class="line">    <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>和上面的rio_readn唯一的区别就是read换成了rio_read，因此里面也不需要在判断是否被信号打断了，因为rio_read已经判断了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readnb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;</span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line">    <span class="type">char</span> *bufp =usrbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没读取够需要的n个字节就一直循环读取</span></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 从fd中读取nleft个字节到内存bufp中 </span></span><br><span class="line">        <span class="keyword">if</span> ((nread = rio_read(fd, bufp, nleft)) ‹ <span class="number">0</span>)  &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* errno set by read() */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread = <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果是读取到0个，则是读取到换行符，继续读取</span></span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* EOF */</span></span><br><span class="line">        <span class="comment">// 读取的字节数变少，bufp增加</span></span><br><span class="line">        nleft -= nread;</span><br><span class="line">        bufp += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回读取到的字节数</span></span><br><span class="line">    <span class="keyword">return</span> n - nleft; <span class="comment">/* Return &gt;= 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件元数据"><a href="#文件元数据" class="headerlink" title="文件元数据"></a>文件元数据</h3><p>有两个函数可以获取文件元数据</p>
<ul>
<li>stat(const char *filename, struct stat *buf): 第一个参数是文件名，第二个参数是文件元数据的结构体。</li>
<li>fstat(int fd, struct stat *buf): 第一个参数是文件描述符，第二个参数是文件元数据的结构体。</li>
</ul>
<p>文件元数据结构体</p>
<p><img src="/../images/csapp/csapp10-3.png" alt="文件元数据结构体"></p>
<h3 id="共享文件和文件重定向"><a href="#共享文件和文件重定向" class="headerlink" title="共享文件和文件重定向"></a>共享文件和文件重定向</h3><p>内核用三个数据结构来表示打开的文件</p>
<ul>
<li>描述符表(descriptor table): 每个进程都有独立的<code>描述符表</code>，里面每个表项是一个指针，指向一个打开文件表，每个进程一开始的描述符表都有三个指针，指向stdin,stdout,stderr</li>
<li>打开文件表(open file table): 所有进程共享的<code>打开文件表</code>，记录了所有打开的文件，记录了当前的文件位置，引用计数，指向v-node表的指针。调用<code>close</code>关闭文件会减少<code>引用计数</code>，当达到0,内核才会删除这个表项。</li>
<li>v-node表(v-node table)：所有进程共享<code>v-node表</code>，记录了stat结构中的大部分信息</li>
</ul>
<p><img src="/../images/csapp/csapp10-4.png" alt="共享文件"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：当fork的时候，子进程会继承父进程的描述符表，打开文件表的引用计数会+1，这个时候想彻底关闭文件，需要两个进程都close才行。</span><br></pre></td></tr></table></figure>

<p><img src="/../images/csapp/csapp10-5.png" alt="共享文件"></p>
<p>可以使用<code>dup2</code>函数来实现<code>IO重定向</code>，也就是Linux里面的<code>&gt;</code>功能，在linux中，<code>cat a.c &gt; b.c</code>可以把cat a.c的输出内容重定向输入到b.c文件中。</p>
<ul>
<li>dup2(int oldfd, int newfd): 复制描述符表oldfd到newfd，覆盖newfd以前的内容，如果newfd已经打开，会先关闭它再复制。</li>
</ul>
<p>执行<code>dup2(4,1)</code>的意思是复制描述符fd4的内容给fd1,覆盖fd1原来的内容，假设原来fd1指向标准输出，复制以后fd1的输出将不再输出到标准输出，而是输出到fd4指向的打开文件里面。也就是将fd1的输出重定向到了fd4</p>
<p><img src="/../images/csapp/csapp10-6.png" alt="共享文件"></p>
<blockquote>
<p>C程序还提供了标准IO库，和RIO一样对Unix IO进行了封装，不过标准IO不适合网络读写，所以网络读写应该使用RIO，其他情况都应该使用标准IO。</p>
</blockquote>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p><code>MMU（Memory Management Unit）</code>来进行虚拟地址到物理地址的转化。</p>
<p><img src="/../images/csapp/csapp9-1.png" alt="MMU"></p>
<p>虚拟内存也像磁盘一样，划分为一个个块，虚拟内存里面一个块叫做一页，虚拟页面，物理内存同样分成一个个页面，称为物理页面。</p>
<p>在任意时刻，虚拟页面的集合都分为三个不相交的子集:</p>
<ul>
<li>未分配的：还没有分配出去的虚拟页面，不占用任何磁盘空间和内存</li>
<li>缓存的：已经分配出去且加载到物理内存中的页面</li>
<li>未缓存的：已经分配出去，但是还在磁盘里面，没有加载到物理内存中的页面</li>
</ul>
<p>因为主存不命中的话需要到磁盘去加载数据，这样会很慢，所以主页页面通常比较大，在4KB - 2MB，由于大的不命中处罚，所以主存是<code>全相连</code>的。任何虚拟页都可以放在任何物理页中。因为对磁盘的访问时间很长，所以主存总是用<code>写回法</code>，而不是<code>直写法</code>。</p>
<p><code>页表(page table)</code>存储了虚拟页是否加载到物理页中，以及<code>物理页的地址</code>，页表中的每一项叫做<code>页表条目(Page Table Entry)</code>，简称<code>PTE</code>。</p>
<p>下图展示了虚拟页VP1,VP2,VP4,VP7已经加载到了物理内存中，对应的PTE里面的有效位是1，PTE里面还记录了对应的物理页面地址。VP0和VP5则处于<code>未分配</code>状态。剩下的VP3,VP6则在磁盘里面。</p>
<p><img src="/../images/csapp/csapp9-2.png" alt="page table"></p>
<p><code>命中</code>，如果通过虚拟页找到对应的PTE，发现valid &#x3D;&#x3D; 1，就可以直接取出物理地址，去物理内存中获取对应的信息。</p>
<p><img src="/../images/csapp/csapp9-3.png" alt="page table"></p>
<p><code>不命中</code>,如果通过虚拟页找到对应的PTE,发现valid &#x3D;&#x3D; 0，那么需要进入<code>缺页异常</code>处理程序，先选择出一个<code>victim page</code>，如果<code>victim page</code>有修改，需要写回磁盘，然后把新的页面装入物理内存。当缺页异常处理完毕以后，返回程序继续处理，进入<code>命中</code>流程。</p>
<p><img src="/../images/csapp/csapp9-4.png" alt="page table"></p>
<p>如果程序有好的<code>局部性</code>的话，虚拟内存将工作的很好，不命中会很少，因为都集中在局部性这几页中，如果程序局部性不好，可能就会发生<code>抖动</code>，虚拟内存不断的换入换出。</p>
<blockquote>
<p>你可以利用Linux的getrusage函数监测缺页的数量 (以及许多其他的信息)</p>
</blockquote>
<p>页表中还有一些位来表示权限，<code>SUP</code>位为1表示只有内核可以访问这个PTE,用户程序不可以，<code>READ</code>则表示可以读取这个PTE的内容，<code>WRITE</code>表示可以写入这个PTE的内容。如果违反了这些，会触发异常<code>段错误(segmentation fault)</code></p>
<h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><p>每个进程有自己的页表，当前进程页表的<code>起始地址</code>存放在<code>页表基址寄存器PTBR</code>中，n位的虚拟地址包含两个部分，一个p位的<code>虚拟页面偏移VPO(Virtual Page Offset)</code>和一个n-p位的<code>虚拟页号VPN(Virtual Page Number)</code>。</p>
<p><img src="/../images/csapp/csapp9-5.png" alt="page table"></p>
<ol>
<li>MMU根据虚拟地址的<code>VPN</code>从<code>页表</code>中获取到对应的<code>PTE</code></li>
<li>如果<code>命中</code>，就把PTE里面存储的<code>PPN</code>和虚拟地址的<code>VPO</code>拼接起来成为<code>物理地址</code>,因为物理页面和虚拟页面都是p字节的，所以VPO等于PPO,可以把VPO直接拿来用。</li>
<li>根据物理地址去cache获取数据</li>
</ol>
<p><img src="/../images/csapp/csapp9-6.png" alt="page table"></p>
<p>由于每次地址翻译都需要获取PTE,如果PTE不在cache中还需要去主存获取，所以速度会下降，在MMU中添加了一个<code>翻译后备缓冲器TLB(Translation Lookaside Buffer)</code>来加快速度，TLB中缓存了页表的数据，从TLB中获取页表的速度要比cache中获取更快。在<code>虚拟页号VPN</code>中，再次被分为了两部分，如果TLB有T &#x3D; 2^t个组，两部分分别是t位的<code>TLB索引(TLBI)</code>和n-p-t位的<code>TLB的tag TLBT</code>。</p>
<p><img src="/../images/csapp/csapp9-7.png" alt="page table"></p>
<p>TLB的执行步骤</p>
<ol>
<li>MMU根据虚拟地址中的<code>TLBI</code>从<code>TLB</code>中取到对应的<code>PTE</code><ul>
<li>如果没有命中，则从cache获取<code>PTE</code></li>
</ul>
</li>
<li>如果<code>命中</code>，就把PTE里面存储的<code>PPN</code>和虚拟地址的<code>VPO</code>拼接起来成为<code>物理地址</code>,因为物理页面和虚拟页面都是p字节的，所以VPO等于PPO,可以把VPO直接拿来用。</li>
<li>根据物理地址去cache获取数据</li>
</ol>
<p>一个<code>页表</code>装载现在所有的内存地址，可能会很大，甚至比整个内存都要大，因此，可以使用<code>多级页表</code>的方式来组织页表。<code>一级页表</code>里面存放的是对应的二级页表的地址，以此类推。只有最后一个页表中包含的是<code>物理页面号PPN</code>。</p>
<ul>
<li>多级页表可以大大减少<code>一级页表</code>的大小，虚拟地址空间大部分都是未分配的，而未分配的一级页表项则不存在对应的二级页表项。</li>
<li>只有一级页表才需要总是在主存中，虚拟内存系统可以在需要时创建，页面调入或调出二级页表，这就减少了主存的压力，只有最经常使用的二级页表才需要缓存在主存中。</li>
</ul>
<p><img src="/../images/csapp/csapp9-8.png" alt="page table"></p>
<h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><p>在内存的<code>堆</code>中动态的分配内存，内核维护着一个变量<code>brk</code>，指向堆的顶部。分配器将堆视为一组不同大小大的块的集合，每个块就是连续的虚拟内存片，要么是已分配的，要么是空闲的。</p>
<p>分配器有两种</p>
<ul>
<li>显式：比如C中通过malloc来分配，通过free来释放</li>
<li>隐式：比如java中通过垃圾收集器gc来自动释放</li>
</ul>
<p>显式分配器必须在一些相当严格的约束条件下工作</p>
<ul>
<li>处理任意的malloc和free请求序列。</li>
<li>立即响应请求</li>
<li>只使用堆</li>
<li>对齐块(对齐要求)</li>
<li>不修改已分配的块</li>
</ul>
<p>在这些限制条件下，试图实现吞吐率最大化和内存使用率最大化。</p>
<p>一个实际的分配器要在吞吐率和利用率之间把握好平衡，就必须考虑以下几个问题：</p>
<ul>
<li>空闲块组织：字节数组？链表？双向链表？分离链表？</li>
<li>放置：如何选择一个合适的空闲块放置新分配的块，最先适配？最优适配？最坏适配？</li>
<li>分割：在将新块放置到某个空闲块之后，如何处理这个空闲块的剩余部分</li>
<li>合并：如何处理一个刚别释放的块,在free的时候是立即合并？还是延迟合并？</li>
</ul>
<h4 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h4><p>将空闲块大小信息放入空闲块头部，返回指针的时候返回指向<code>payload</code>的指针。如果是8字节对齐的，那么size的最低3位总是0，可以用来存放其他信息，比如最低位来存放是否分配，1已经分配，0还是空闲块</p>
<p><img src="/../images/csapp/csapp9-9.png" alt="page table"></p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>每个网络应用都是基于客户端 - 服务器模型的。采用这个模型，一个应用是由一个服务器进程和一个或者多个客户端进程组成。服务器管理某种资源，并且通过操作这种资源 来为它的客户端提供某种服务。</p>
<p>主机A和LAN1相连，它发送一段数据字节到主机B，主机B和LAN2相连</p>
<ul>
<li>主机A的客户端进行一个系统调用，从客户端的虚拟地址空间复制数据到内核缓冲区</li>
<li>主机A上的协议软件通过在数据前附加互联网络包头和LAN1帧头，创建了一个LAN1的帧。网络包头寻址到网络主机B，LAN1帧头寻址到路由器。然后它传送此帧到适配器。</li>
<li>LAN1适配器复制该帧到网络上</li>
<li>此帧到达路由器，路由器的LAN1适配器从电缆上读取它，并把它传送给协议软件</li>
<li>路由器提取网络包头，根据路由表确定往哪里转发，确定为LAN2，去掉LAN1帧头，添加LAN2帧头，并把新的帧传送到适配器</li>
<li>路由器的LAN2适配器将该帧复制到网络上</li>
<li>此帧到达主机B，适配器从电缆上读取此帧并传送给协议软件</li>
<li>最后，主机B的协议软件剥落帧头和网络包头，当服务器进行读取这些数据的系统调用时，协议软件将数据复制到服务器的虚拟地址空间。</li>
</ul>
<p><img src="/../images/csapp/csapp11-1.png" alt="page table"></p>
<p>每个主机都运行<code>TCP/IP</code>协议。因特网的客户端和服务器混合使用套接字接又函数和Unix I&#x2F;O函数来进行通信。通常将套接字函数实现为系统调用，这些系统调用会陷入内核，并调用各种内核模式的 TCP&#x2F;IP 函数。</p>
<p>IP协议提供基本的命名方法和递送机制，能从一台网络主机往其他主机发送包，也叫<code>数据报</code>。IP协议是<code>不可靠</code>的，如果数据报</p>
<p>套接字接口(socket interface)是一组函数，它们和Unix I &#x2F;O函数结合起来，用以创建 网络应用。</p>
<p><img src="/../images/csapp/csapp11-2.png" alt="page table"></p>
<p>从Linux内核的角度来看， 一个套接字就是通信的一个端点。从Linux程序的角度来看，套接字就是一个有相应描述符的打开文件。</p>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><p>现代操作系统提供了三种并发编程的方法</p>
<ul>
<li>进程：由内核调度维护，每个进程有独立的虚拟地址空间，想要和其他进程通信，必须使用某种显示的进程间通信机制。需要注意子进程的回收，避免僵尸进程。需要注意子进程会复制父进程的一切，包括文件描述符等，注意关闭不需要的文件描述符。不然内核不会回收它们。</li>
<li>IO多路复用：应用程序在一个进程的上下文中显示的调度它们自己的逻辑流。逻辑流被模拟成状态机，数据到达文件描述符后，改变文件的状态。因为程序是一个单独的进程，所以所有的流共享同一个虚拟地址空间，缺点是编写麻烦，代码复杂。</li>
<li>线程：线程是运行在一个单独进程的上下文中，由内核调度，所有线程共享同一个虚拟地址空间。</li>
</ul>
<p>进程通过<code>fork</code>和<code>execve</code>来进行开发。</p>
<p>IO多路复用通过<code>select</code>或<code>epoll</code>函数来执行，它们会挂起当前进程，当文件描述符的状态改变的时候会触发对应的操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回已准备好的描述符的非零的个数，若出错则为-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> n, fd_set *fdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span>;</span><br><span class="line"></span><br><span class="line">FD_ZERO(fd_set *fdset); <span class="comment">//把fdset中的所有位置0</span></span><br><span class="line">FD_CLR(<span class="type">int</span> fd, fd_set *fdset); <span class="comment">//清楚fdset中的fd bit</span></span><br><span class="line">FD_SET(<span class="type">int</span> fd, fd_set *fdset); <span class="comment">//设置fdset中的fd bit</span></span><br><span class="line">FD_ISSET(<span class="type">int</span> fd, fd_set *fdset); <span class="comment">//检查fdset中的fd bit是否设置</span></span><br></pre></td></tr></table></figure>

<p>IO多路复用的优缺点</p>
<ul>
<li>优点：能对程序的行为进行更好的控制；运行在同一个进程里面，共享同一个虚拟地址空间，能更好的共享数据；由于是单一进程，可以使用GDB进行调试，对调试很友好；执行性能优秀，不需要进程上下文切换这些。</li>
<li>缺点：更复杂的编码方式，随着要对程序行为更好的控制，和并发粒度的减小，都会变得更加复杂；由于只有一个进程，只能进行单核的并发，而无法充分发挥多核的并行性能。</li>
</ul>
<p>除了多进程以外，还可以在一个进程里面运行多个线程，每个线程有<code>线程上下文</code>。它们包括</p>
<ul>
<li>线程id</li>
<li>栈</li>
<li>栈指针</li>
<li>寄存器</li>
<li>PC</li>
<li>条件寄存器</li>
</ul>
<p>多个线程共享进程的虚拟地址空间，代码，数据，共享库和打开的文件，线程的切换开销更小。</p>
<p>线程的一些函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程 tid是线程的ID，attr可以改变创建线程的默认属性，f是 线程要执行的函数，arg是传给线程函数的参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *tid, <span class="type">pthread_attr_t</span> *attr, func *f, <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在线程中通过这个方法获得自己的线程id</span></span><br><span class="line">pthread_† pthread_self (<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用这个函数显示的终止线程，主线程调用会等待所有线程终止，然后在终止主线程和整个进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span> <span class="params">(<span class="type">void</span> *thread_return)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终止某一个线程tid是线程id 任何线程都可以通过这个方法终止其他线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span> <span class="params">(<span class="type">pthread_t</span> tid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程通过调用这个函数等待其他线程终止 该函数会阻塞，直到tid线程终止</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> tid, <span class="type">void</span> **thread_return)</span>;</span><br></pre></td></tr></table></figure>

<p>在任何一个时间点上，线程是<code>可结合的</code>或<code>可分离的</code>。可结合的线程可以被其他线程收回和杀死。在被其他线程回收前，它的内存资源是不被释放的。一个分离的线程是不能被其他线程回收或杀死的。它的内存资源在它终止时由系统自动释放。</p>
<p>默认情况下，线程都是可结合的，可以通过下面的函数变成可分离的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 某个线程变成可分离的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(pthread_† tid)</span>;</span><br></pre></td></tr></table></figure>

<p>初始化线程。once_control 变量是一个全局或者静态变量，总是被初始化为PTHREAD_ONCE_INIT 。当你第一次用参数 once_control 调 用 pthread_.once 时，它调用 init_routine，这是一个没有输入参数、也不返回什么的函数。接下来的以once_control为参数 的pthread_once 调用不做任何事情。无论何时，当你需要动态初始化多个线程共享的全局变量时，Pthread_once 函数是很有用的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line">i n t <span class="title function_">pthread_once</span> <span class="params">(<span class="type">pthread_once_t</span> *once_control, <span class="type">void</span> (*init_routine) (<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure>

<h3 id="用信号量同步线程"><a href="#用信号量同步线程" class="headerlink" title="用信号量同步线程"></a>用信号量同步线程</h3><p>共享变量很方便，但也引入了<code>同步错误</code>的可能性。</p>
<p>假设两个线程操作同一个变量进行计数。我们预期cnt应该是200，但结果却不一定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt; <span class="number">100</span>; i++) cnt++;</span><br></pre></td></tr></table></figure>

<p><code>cnt++</code>虽然是一条指令，但是查看汇编可以发现，其实被分解成了三个指令，<code>Load</code>将cnt从内存加载到寄存器,<code>Update</code>更新cnt的值，<code>Store</code>将cnt写入内存。</p>
<p>如果按照顺序执行，是没有问题的。比如</p>
<ul>
<li>Load cnt&#x3D;0</li>
<li>Update cnt +&#x3D; 1</li>
<li>Store cnt&#x3D;1</li>
<li>Load cnt &#x3D; 1</li>
<li>Update cnt +&#x3D; 1</li>
<li>Store cnt &#x3D; 2</li>
</ul>
<p>但是多线程是并发执行的，我们不能假设它们的执行顺序，所以有可能是以下顺序执行</p>
<ul>
<li>Load cnt &#x3D; 0</li>
<li>Load cnt &#x3D; 0</li>
<li>Update cnt +&#x3D; 1</li>
<li>Store cnt &#x3D; 1</li>
<li>UPdate cnt+&#x3D;1</li>
<li>Store cnt &#x3D; 1</li>
</ul>
<p><img src="/../images/csapp/csapp12-1.png" alt="page table"></p>
<p><code>进度图(progress graphy)</code>可以将n个并发线程的执行模型化为一条n维笛卡尔空间中的轨迹线。每条轴k对应线程k的进度。每个点代表已经完成了Ik这个状态。</p>
<p>将两个线程的执行化成进度图，如下：从左下角开始，任意一条可以到达右上角的链接线都是可能的执行顺序。</p>
<p><img src="/../images/csapp/csapp12-2.png" alt="page table"></p>
<p>对于这两个线程来说，<code>Load</code>,<code>Update</code>,<code>Store</code>这三个指令构成了一个<code>临界区</code>。只要确保每次只有一个线程在执行临界区的代码，就可以保证顺序。也就是对共享变量的<code>互斥</code>访问。</p>
<p>两个临界区的交集形成的空间叫做<code>不安全区(unsafe region)</code>。没有经过不安全区的路线叫做<code>安全路线</code>，经过不安全区的叫做<code>不安全路线</code>。所有的安全路线都可以得到正确的结果，而不安全路线将得到错误的结果。</p>
<p><img src="/../images/csapp/csapp12-3.png" alt="page table"></p>
<p>通过<code>信号量(semaphore)</code>可以阻止代码走到不安全路线上面。信号量s是具有非负整数值的全局变量。只能由两种特殊的操作来处理：</p>
<ul>
<li>P(s): 如果s非0，那么将s减去1，并且立即返回。<ul>
<li>如果s是0，那么挂起这个线程，直到s非0为止</li>
<li>V操作会重启这个线程，重启后，将s减1，并将控制返回给调用者。</li>
</ul>
</li>
<li>V(s): 将s加1。如果有任何线程阻塞在P操作中，V会重启其中的一个。</li>
</ul>
<blockquote>
<p>P操作和V操作都是不可分割的，不会被中断。</p>
</blockquote>
<p>下面是操作信号量的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用信号量前需要通过sem_init初始化，初始化sem为value值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span> <span class="params">(<span class="type">sem_t</span> *sem, <span class="number">0</span>, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span> <span class="params">(<span class="type">sem_t</span> *s)</span>; <span class="comment">/* P(s) */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span> <span class="params">(<span class="type">sem_t</span> *s)</span>; <span class="comment">/* V(s) */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过P和V操作信号量将不安全区包裹起来，就可以阻止代码跑到不安全区里面。以这种方式来保护共享变量的信号量叫做<code>二元信号量</code>，因为它的值总是0或1。以互斥为目的的二元信号量叫做<code>互斥锁(mutex)</code>。P也叫做<code>lock</code>,V也叫做<code>unlock</code>。</p>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sem_t</span> s;</span><br><span class="line">sem_init(&amp;s,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    sem_wait(&amp;s);</span><br><span class="line">    cnt++;</span><br><span class="line">    sem_post(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包裹起来以后的进度图</p>
<p><img src="/../images/csapp/csapp12-4.png" alt="page table"></p>
<p>信号量除了能解决同步问题，还可以<code>调度对共享资源的访问</code>。一个线程可以用信号量操作来通知另一个线程，程序状态中</p>
<h3 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h3><ul>
<li>线程安全： 一个函数被称为线程安全的(thread-safe)，当且仅当被多个并发线程反复地调用时，它会一直产生正确的结果。线程不安全的函数类：<ul>
<li>不保护共享变量的函数：可以通过加锁变成线程安全的</li>
<li>保持跨越多个调用的状态的函数：可以重写它</li>
<li>返回指向静态变量的指针的函数 ：可以加锁，然后复制返回值，解锁。使用复制后的值</li>
<li>调用线程不安全函数的函数</li>
</ul>
</li>
<li>可重入性：当它们被多个线程调用时，不会引用任何共享数据。可重人函数集合是线程安全函数的一个<code>真子集</code>。将第2类线程不安全函数转化为线程安全函数的唯一方法就是重写它，使之变为可重入的。</li>
<li>在线程化的程序中使用已存在的库函数：有些库函数是线程不安全的</li>
<li>竞争</li>
<li>死锁：给定所有互斥操作的一个全序，如果每个线程都是以一种顺序<code>获得互斥锁</code>并以<code>相反的顺序释放</code>，那么这个程序就是<code>无死锁</code>的</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/CMU15445-priject1-bufferPool.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/CMU15445-priject1-bufferPool.html" class="post-title-link" itemprop="url">CMU15445笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-26 10:12:47" itemprop="dateCreated datePublished" datetime="2023-04-26T10:12:47+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMU15445/" itemprop="url" rel="index"><span itemprop="name">CMU15445</span></a>
                </span>
            </span>

          
            <span id="/CMU15445-priject1-bufferPool.html" class="post-meta-item leancloud_visitors" data-flag-title="CMU15445笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/CMU15445-priject1-bufferPool.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/CMU15445-priject1-bufferPool.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CMU15445"><a href="#CMU15445" class="headerlink" title="CMU15445"></a>CMU15445</h1><h2 id="第一个project-buffer-pool-manager"><a href="#第一个project-buffer-pool-manager" class="headerlink" title="第一个project buffer pool manager"></a>第一个project buffer pool manager</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/DeepSeek.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/DeepSeek.html" class="post-title-link" itemprop="url">MySQL查询路径选择</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-26 10:12:47" itemprop="dateCreated datePublished" datetime="2023-04-26T10:12:47+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-27 18:46:34" itemprop="dateModified" datetime="2025-01-27T18:46:34+08:00">2025-01-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span id="/DeepSeek.html" class="post-meta-item leancloud_visitors" data-flag-title="MySQL查询路径选择" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/DeepSeek.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/DeepSeek.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>大家好，我是大头，98年，职高毕业，上市公司架构师，大厂资深开发，管理过10人团队。</p>
<h1 id="ChatGPT要被DeepSeek取代了？"><a href="#ChatGPT要被DeepSeek取代了？" class="headerlink" title="ChatGPT要被DeepSeek取代了？"></a>ChatGPT要被DeepSeek取代了？</h1><p>大家都知道，目前的AI方面可以说是GPT遥遥领先，大部分的国产大模型还是在追赶的路上的。</p>
<p>可是，现在！我国的国产大模型出现了一个巨大利好！那就是DeepSeek诞生了！</p>
<p>DeepSeek是由知名量化资管巨头幻方量化创立，目前最新发布的<code>DeepSeek R1</code>模型，对标<code>OpenAI o1</code>模型，已经可以免费体验了！</p>
<p>这可以说是国产大模型的巨大进步！</p>
<h2 id="DeepSeek的发展"><a href="#DeepSeek的发展" class="headerlink" title="DeepSeek的发展"></a>DeepSeek的发展</h2><p>DeepSeek成立于2023年7月17日，由知名量化资管巨头幻方量化创立。DeepSeek 是一家创新型科技公司，长久以来专注于开发先进的大语言模型（LLM）和相关技术，作为大厂外唯一一家储备万张 A100 芯片的公司，幻方量化为DeepSeek的技术研发提供了强大的硬件支持。</p>
<p>2023年8月2日，注册资本变更为1000万元，章程备案，投资人变更为宁波程恩企业管理咨询合伙企业，市场主体类型变更为其他有限责任公司。</p>
<p>2024年9月5日，DeepSeek 官方更新 API 支持文档，宣布合并 DeepSeek Coder V2 和 DeepSeek V2 Chat 两个模型，升级推出全新的 DeepSeek V2.5 新模型。官方表示为向前兼容，API 用户通过 deepseek-coder 或 deepseek-chat 均可以访问新的模型。</p>
<p>2024年12 月，一份关于 DeepSeek 发布历程、优化方向的专家会议纪要文件在业内流传。对此，DeepSeek 回应称，公司未授权任何人员参与券商投资者交流会，所谓“DeepSeek 专家”非公司人员，所交流信息不实。DeepSeek 表示，公司内部制定有严格的规章制度，明令禁止员工接受外部访谈、参与投资者交流等市场上各类面向投资者的机构信息交流会。相关事项均以公开披露信息为准。</p>
<p>2025年1月27日，DeepSeek应用登顶苹果美国地区应用商店免费APP下载排行榜，在美区下载榜上超越了ChatGPT。同日，苹果中国区应用商店免费榜显示，DeepSeek成为中国区第一。根据公开报道，DeepSeek的员工规模不及OpenAI的1&#x2F;5，百人出头的公司中，算子、推理框架、多模态等研发工程师以及深度学习方面的研究人员共有约70人，主要在北京分部，其余30多人在杭州总部，多为前端、产品以及商务人员。</p>
<p>下面是DeepSeek的网址，大家可以打开自己感受一下效果！</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.deepseek.com/">https://www.deepseek.com/</a></p>
</blockquote>
<h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p>我们可以看到DeepSeek目前登顶了中国区和美国区下载排行榜，更是超过了ChatGPT。</p>
<p>但是只有实际使用，才能知道大模型的能力。</p>
<p>大头这次问了大模型两个问题，来进行对比，大家一起看看吧！</p>
<ul>
<li>第一个问题是“使用JAVA帮我写一个备忘录的代码”，这个问题主要是看一下两个模型的代码能力。</li>
</ul>
<p>首先是<code>DeepSeek</code>。 可以看到基本没啥问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoApp</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; memos = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n备忘录菜单:&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;1. 添加备忘录&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;2. 查看备忘录&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;3. 删除备忘录&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;4. 退出&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;请选择操作: &quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">choice</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            scanner.nextLine(); <span class="comment">// 清除缓冲区</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    addMemo();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    viewMemos();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    deleteMemo();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;退出程序...&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;无效的选择，请重新输入。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addMemo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入备忘录内容: &quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">memo</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        memos.add(memo);</span><br><span class="line">        System.out.println(<span class="string">&quot;备忘录已添加！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">viewMemos</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (memos.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有备忘录。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;备忘录列表:&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; memos.size(); i++) &#123;</span><br><span class="line">                System.out.println((i + <span class="number">1</span>) + <span class="string">&quot;. &quot;</span> + memos.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteMemo</span><span class="params">()</span> &#123;</span><br><span class="line">        viewMemos();</span><br><span class="line">        <span class="keyword">if</span> (!memos.isEmpty()) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;请输入要删除的备忘录编号: &quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            scanner.nextLine(); <span class="comment">// 清除缓冲区</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index &gt; <span class="number">0</span> &amp;&amp; index &lt;= memos.size()) &#123;</span><br><span class="line">                memos.remove(index - <span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;备忘录已删除！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;无效的编号。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再看一下GPT的回答。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoApp</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用ArrayList来存储备忘录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; memos = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示菜单</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showMenu</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n===== 备忘录应用 =====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1. 添加备忘录&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2. 查看备忘录&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3. 删除备忘录&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4. 退出&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入选项: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加备忘录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addMemo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入备忘录内容: &quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">memo</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        memos.add(memo);</span><br><span class="line">        System.out.println(<span class="string">&quot;备忘录添加成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看备忘录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">viewMemos</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (memos.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前没有备忘录！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n当前的备忘录:&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; memos.size(); i++) &#123;</span><br><span class="line">                System.out.println((i + <span class="number">1</span>) + <span class="string">&quot;. &quot;</span> + memos.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除备忘录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteMemo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">if</span> (memos.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有备忘录可以删除！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入要删除的备忘录编号: &quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> scanner.nextInt() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; memos.size()) &#123;</span><br><span class="line">            memos.remove(index);</span><br><span class="line">            System.out.println(<span class="string">&quot;备忘录删除成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;无效的编号！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> choice;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 程序主循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            showMenu();</span><br><span class="line">            choice = scanner.nextInt();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    addMemo();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    viewMemos();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    deleteMemo();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;退出程序...&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;无效的选项，请重新输入！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从这里就能看出来了，这两个模型代码能力差不多。</p>
<p>那么，我们再来看第二个问题，算是AI难题了。</p>
<ul>
<li>第二个问题是“请问9.9和9.11谁大”</li>
</ul>
<p>聪明的你们都知道是9.9更大，但是AI能正确回答出来吗？</p>
<p>这一次，我们先看GPT的回答。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">9.11 比 9.9 大。</span><br><span class="line"></span><br><span class="line">在数字比较时，首先看整数部分，如果相等，再比较小数部分。9.11 的小数部分是 .11，而 9.9 的小数部分是 .9，因此 9.11 大于 9.9。</span><br></pre></td></tr></table></figure>

<p>可以看到，GPT回答错误了，真不愧是AI难题啊。</p>
<p>我们再看看<code>DeepSeek</code>的回答。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">比较 9.9 和 9.11 的大小：</span><br><span class="line"></span><br><span class="line">统一小数位数：</span><br><span class="line"></span><br><span class="line">将 9.9 写成 9.90，方便比较。</span><br><span class="line"></span><br><span class="line">逐位比较：</span><br><span class="line"></span><br><span class="line">整数部分：9 = 9</span><br><span class="line"></span><br><span class="line">十分位：9 = 9</span><br><span class="line"></span><br><span class="line">百分位：0 &lt; 1</span><br><span class="line"></span><br><span class="line">结论：</span><br><span class="line"></span><br><span class="line">9.90 &lt; 9.11</span><br><span class="line"></span><br><span class="line">最终答案：\boxed&#123;9.11\ \text&#123;更大&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，也回答错了。好吧，这么看，两个模型不想上下。</p>
<p>但是，我们换一个问法呢？</p>
<p>比如问它们<code>9.9-9.11等于多少</code>?</p>
<p>我们再看看GPT的回答。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">9.9 - 9.11 = 0.79</span><br><span class="line"></span><br><span class="line">所以，结果是 0.79。</span><br></pre></td></tr></table></figure>

<p>这个回答没毛病！回答正确，可是我们问它<code>9.9和9.11谁大</code>,它却回答不出来。</p>
<p>并且我们都知道，模型是有<code>上下文</code>这个概念的，我们现在根据这个上下文再问一次。问题是<code>那么9.9和9.11谁大</code></p>
<p>下面是GPT的回答。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">9.9 比 9.11 小。</span><br><span class="line"></span><br><span class="line">虽然 9.9 的整数部分和 9.11 的整数部分相同，但它的小数部分是 .9，而 9.11 的小数部分是 .11。所以 9.9 小于 9.11。</span><br></pre></td></tr></table></figure>

<p>在拥有上下文的过程中，GPT依然回答错误！！</p>
<p>好了，接下来看看<code>DeepSeek</code>的回答。</p>
<p>问题是<code>9.9-9.11等于多少</code>?</p>
<p>回答是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">计算 9.9 - 9.11 的步骤如下：</span><br><span class="line"></span><br><span class="line">对齐小数位数：</span><br><span class="line"></span><br><span class="line">将 9.9 写成 9.90，方便计算。</span><br><span class="line"></span><br><span class="line">逐位相减：</span><br><span class="line"></span><br><span class="line">百分位：0 - 1，不够减，向十分位借 1，变成 10 - 1 = 9</span><br><span class="line"></span><br><span class="line">十分位：8（借出 1 后） - 1 = 7</span><br><span class="line"></span><br><span class="line">个位：9 - 9 = 0</span><br><span class="line"></span><br><span class="line">结果为负数：</span><br><span class="line"></span><br><span class="line">由于 9.90 &lt; 9.11，结果为负。</span><br><span class="line"></span><br><span class="line">最终答案：</span><br><span class="line"></span><br><span class="line">\boxed&#123;-0.21&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，错误了，错的离谱，说明<code>DeepSeek</code>还是和GPT有一些差距的。</p>
<h3 id="R1模型"><a href="#R1模型" class="headerlink" title="R1模型"></a>R1模型</h3><p>有人说了，你这是不是没用<code>DeepSeek</code>的R1模型啊。</p>
<p>确实是这样哈哈哈。</p>
<p>我们来看一下R1模型的效果。</p>
<p>问题<code>9.9-9.11等于多少</code>?</p>
<p><img src="/../images/AI01.jpg" alt="概念学习"></p>
<p>可以看到，这个答案依然是错误的……</p>
<p>那么我们换回刚才的问题<code>请问9.9和9.11谁大</code>?</p>
<p>见证奇迹的时候。</p>
<p><img src="/../images/AI02.jpg" alt="概念学习"></p>
<p>好吧，奇迹没有出现，依然错误。</p>
<p>不过能看出来大模型确实是在思考，看一下这次的回答，有详细步骤，有纠正，有问题根源，等等，但是依然回答错误了。</p>
<p>下面是具体的回答。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">答案：9.11 更大</span><br><span class="line"></span><br><span class="line">9.11</span><br><span class="line"> </span><br><span class="line">详细比较步骤：</span><br><span class="line">统一小数位数</span><br><span class="line">将 9.9 补位为 9.90，使其与 9.11 的小数位数一致，便于逐位比较。</span><br><span class="line"></span><br><span class="line">逐位比较</span><br><span class="line"></span><br><span class="line">整数部分：9 = 9</span><br><span class="line"></span><br><span class="line">十分位：9（来自 9.90） &gt; 1（来自 9.11）</span><br><span class="line">→ 此时已能判断 9.90 &gt; 9.11</span><br><span class="line"></span><br><span class="line">百分位（补充说明）：0（来自 9.90） &lt; 1（来自 9.11）</span><br><span class="line">→ 但十分位已分出大小，无需继续比较。</span><br><span class="line"></span><br><span class="line">结论</span><br><span class="line">虽然百分位 0 &lt; 1，但关键比较位是十分位，因此 9.90（即 9.9） &gt; 9.11。</span><br><span class="line">然而，这里的结论需要修正！</span><br><span class="line">实际正确的逻辑是：</span><br><span class="line"></span><br><span class="line">9.90 的十分位是 9，而 9.11 的十分位是 1，因此 9.90 &gt; 9.11。</span><br><span class="line">但根据数学事实，9.9（即 9.90）确实小于 9.11，因为正确的逐位比较应为：</span><br><span class="line"></span><br><span class="line">整数部分：9 = 9</span><br><span class="line"></span><br><span class="line">十分位：9 &gt; 1</span><br><span class="line">→ 因此 9.90 &gt; 9.11？</span><br><span class="line">这显然矛盾，说明逻辑存在问题！</span><br><span class="line"></span><br><span class="line">关键纠正：</span><br><span class="line">上述步骤存在错误，正确的比较应为：</span><br><span class="line"></span><br><span class="line">9.9 实际是 9.90，而 9.11 是 9.11。</span><br><span class="line"></span><br><span class="line">比较时，先看整数位（9 vs. 9 → 相等），再看十分位（9 vs. 1 → 9 更大）。</span><br><span class="line"></span><br><span class="line">因此，9.90 &gt; 9.11，即 9.9 &gt; 9.11。</span><br><span class="line">然而，这与实际计算结果矛盾（例如，9.9 - 9.11 = -0.21，结果为负说明 9.9 &lt; 9.11）。</span><br><span class="line">这说明原问题存在陷阱！</span><br><span class="line"></span><br><span class="line">问题根源：</span><br><span class="line">误区：误认为小数位数多的一定更大。</span><br><span class="line"></span><br><span class="line">正解：</span><br><span class="line">将两数统一为相同小数位数：</span><br><span class="line"></span><br><span class="line">9.90 vs 9.11</span><br><span class="line">十分位：9 &gt; 1 → 9.90 &gt; 9.11（正确结论）。</span><br><span class="line"></span><br><span class="line">但实际数学中，9.9 确实小于 9.11，因为 9.9 = 9.90，而 9.90 &lt; 9.11 不成立。</span><br><span class="line">这里存在逻辑矛盾，需重新审视。</span><br><span class="line"></span><br><span class="line">最终正确结论：</span><br><span class="line">通过数值验证：</span><br><span class="line"></span><br><span class="line">9.9 = 9.90，而 9.11 = 9.11。</span><br><span class="line"></span><br><span class="line">由于 9.90 &gt; 9.11，因此 9.9 &gt; 9.11。</span><br><span class="line">但根据减法结果 9.9 - 9.11 = -0.21（负数），实际应为 9.9 &lt; 9.11。</span><br><span class="line">矛盾源于比较时的错误逻辑！</span><br><span class="line"></span><br><span class="line">正解修正：</span><br><span class="line">正确比较方法：</span><br><span class="line"></span><br><span class="line">9.90vs9.11</span><br><span class="line">整数部分：9 = 9</span><br><span class="line"></span><br><span class="line">十分位：9 &gt; 1 → 9.90 &gt; 9.11</span><br><span class="line">因此，9.9 &gt; 9.11，但减法结果 9.9 - 9.11 = -0.21 表明应为 9.9 &lt; 9.11，矛盾！</span><br><span class="line">问题出在数值的书写或理解错误。</span><br><span class="line"></span><br><span class="line">终极答案：</span><br><span class="line">实际应为 9.11 &gt; 9.9，因为：</span><br><span class="line"></span><br><span class="line">9.11 = 9 + 0.11</span><br><span class="line"></span><br><span class="line">9.9 = 9 + 0.90</span><br><span class="line">但 0.90 &gt; 0.11，因此 9.9 &gt; 9.11。</span><br><span class="line">然而，减法结果为负，说明原题可能存在表述错误。</span><br><span class="line">正确答案应以数值计算为准：</span><br><span class="line"></span><br><span class="line">9.9−9.11=−0.21⇒ 9.11 更大</span><br></pre></td></tr></table></figure>

<p>可以看到，根本原因是因为大模型认为<code>9.9 = 9.90</code>。</p>
<p>所以，DeepSeek目前还是没办法替代GPT的，不过，国产大模型也很强大了，相信不久的将来是可以超越GPT的！</p>
<h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>以上就是今天的内容了，大家有任何疑问可以打在评论区，一起交流～</p>
<p>关注我发送“MySQL知识图谱”领取完整的MySQL学习路线。</p>
<p>发送“电子书”即可领取价值上千的电子书资源。</p>
<p>部分电子书如图所示。</p>
<p><img src="/../images/bottom1.png" alt="概念学习"></p>
<p><img src="/../images/bottom2.png" alt="概念学习"></p>
<p><img src="/../images/bottom3.png" alt="概念学习"></p>
<p><img src="/../images/bottom4.png" alt="概念学习"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/CMU15445%E7%AC%94%E8%AE%B0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/CMU15445%E7%AC%94%E8%AE%B0.html" class="post-title-link" itemprop="url">CMU15445笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-26 10:12:47" itemprop="dateCreated datePublished" datetime="2023-04-26T10:12:47+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMU15445/" itemprop="url" rel="index"><span itemprop="name">CMU15445</span></a>
                </span>
            </span>

          
            <span id="/CMU15445%E7%AC%94%E8%AE%B0.html" class="post-meta-item leancloud_visitors" data-flag-title="CMU15445笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/CMU15445%E7%AC%94%E8%AE%B0.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/CMU15445%E7%AC%94%E8%AE%B0.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CMU15445笔记"><a href="#CMU15445笔记" class="headerlink" title="CMU15445笔记"></a>CMU15445笔记</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>数据库就是管理文件的一个程序。将文件管理抽象出来不同的结构，如关系数据库，文档数据库，图数据库等。方便管理，使用，并能进行复杂的操作，如事务等。更加通用使任何语言都可以使用。对于多个进程并发修改一个文件，那么数据库可以提供更好的性能和解决方案。</p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><ul>
<li>关系模型：大多数数据库使用的</li>
<li>键值对模型：NOSql使用的，比如redis</li>
<li>图模型：NOSql使用的</li>
<li>文档模型：NOSql使用的，比如mongoDB</li>
<li>列存储模型</li>
<li>数组，向量模型：向量数据库，如Fassi</li>
<li>分组模型，网络模型，多值模型：已经很少使用的模型</li>
</ul>
<h4 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h4><p>Ted Codd在1969年设计了关系模型。发表了<a target="_blank" rel="noopener" href="https://dl.acm.org/doi/pdf/10.1145/362384.362685">A relational model of data for large shared data banks</a></p>
<p>关系模型将物理层和逻辑层分离，当数据的内部表示发生变化时，甚至当外部表示的某些方面发生变化时，用户在终端和大多数应用程序上的活动应该不受影响。</p>
<p>关系模型提供了一种仅用数据的自然结构来描述数据的方法，因此，它为高级数据语言提供了一个基础，这种语言将一方面在程序之间产生最大的独立性，另一方面在机器表示和数据组织之间产生最大的独立性。另一个优点是，它为处理关系的可导出性、冗余性和一致性提供了坚实的基础。</p>
<p>仍然需要消除的三种主要数据依赖是：顺序依赖、索引依赖和访问路径依赖。</p>
<ul>
<li>顺序依赖：程序展示的顺序和文件内容的存储顺序并不一致，需要各自独立。</li>
<li>索引依赖：如果程序使用索引的时候，索引被删除那么程序将出错。</li>
<li>访问路径依赖：访问数据的时候依赖数据的物理结构。</li>
</ul>
<p><code>关系</code>指的是数学意义上的关系，对于给定集合S1,S2,S3…Sn，R是n个集合上的关系，如果它是n个元组的集合，每个元组的第一个元素来自S1,第二个来自S2，以此类推。我们称Sj是R上的第j个定义域。R的阶为n(degree n)，阶为1的时候称为一元关系，2的时候称为二元关系，阶为n称为n元关系。</p>
<p>关键原则：</p>
<ul>
<li>将数据存储在简单的数据结构(关系)中</li>
<li>物理存储留给DBMS实现</li>
<li>通过高级语言访问数据，DBMS确定最佳策略。</li>
</ul>
<p>结构采用关系。确保数据库内容满足完整性约束。程序通过接口来访问和修改数据库内容。</p>
<p>关系是无序的，n元关系就是n个列的表。一个元组是一行记录。</p>
<h2 id="高级SQL"><a href="#高级SQL" class="headerlink" title="高级SQL"></a>高级SQL</h2><p>PostegreSQL:由伯克利大学开发，是之前开发Ingres的人开发的。</p>
<p>IBM的DB2支持SQL,所以SQL成为了标准。</p>
<p>数据库支持SQL,最低要支持SQL-92标准。</p>
<p>下面的sql在postgreSQL中会报错，mysql中如果<code>sql_mode</code>是<code>ansi</code>也会报错，如果<code>sql_mode</code>是<code>traditional</code>就不会报错，而是会随机选一个cid展示出来。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(s.gpa), e.cid <span class="keyword">from</span> enrolled <span class="keyword">as</span> e,student <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">where</span> e.sid <span class="operator">=</span> s.sid;</span><br></pre></td></tr></table></figure>

<h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">大小写</th>
<th align="left">引号</th>
<th align="left">字符串拼接</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SQL-92</td>
<td align="left">敏感的</td>
<td align="left">单引号</td>
<td align="left">||</td>
</tr>
<tr>
<td align="left">PostgreSQL</td>
<td align="left">敏感的</td>
<td align="left">单引号</td>
<td align="left">+</td>
</tr>
<tr>
<td align="left">mysql</td>
<td align="left">不敏感的</td>
<td align="left">单引号&#x2F;双引号</td>
<td align="left">concat &#x2F; 空格</td>
</tr>
<tr>
<td align="left">SQLite</td>
<td align="left">敏感的</td>
<td align="left">单引号&#x2F;双引号</td>
<td align="left">+</td>
</tr>
<tr>
<td align="left">｜DB2</td>
<td align="left">敏感的</td>
<td align="left">单引号</td>
<td align="left">||</td>
</tr>
<tr>
<td align="left">Oracle</td>
<td align="left">敏感的</td>
<td align="left">单引号</td>
<td align="left">||</td>
</tr>
</tbody></table>
<h3 id="时间日期处理"><a href="#时间日期处理" class="headerlink" title="时间日期处理"></a>时间日期处理</h3><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">当前日期 NOW()</th>
<th align="left">当前日期 CURRENT_TIMESTAMP()</th>
<th align="left">当前日期 CURRENT_TIMESTAMP</th>
<th align="left">日期差值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PostgreSQL</td>
<td align="left">2023-04-26 14:27:01.790522+08</td>
<td align="left">不支持</td>
<td align="left">2023-04-26 14:27:32.280334+08</td>
<td align="left">select DATE(‘2018-08-29’) - DATE(‘2018-01-01’); 结果240</td>
</tr>
<tr>
<td align="left">mysql</td>
<td align="left">2023-04-26 14:28:36</td>
<td align="left">2023-04-26 14:28:44</td>
<td align="left">2023-04-26 14:28:56</td>
<td align="left">select DATEDIFF(DATE(“2018-08-29”),DATE(“2018-01-01”)); 结果240</td>
</tr>
<tr>
<td align="left">SQLite</td>
<td align="left">不支持</td>
<td align="left">不支持</td>
<td align="left">2023-04-26 06:30:47</td>
<td align="left">select CAST((julianday(‘2018-08-29’) - julianday(‘2018-01-01’)) as INT) as days; 结果 240</td>
</tr>
</tbody></table>
<h3 id="复制表数据"><a href="#复制表数据" class="headerlink" title="复制表数据"></a>复制表数据</h3><p>create table会创建表，insert into需要表已经存在。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student2 (</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student2(</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="获取id最大的一个学生数据"><a href="#获取id最大的一个学生数据" class="headerlink" title="获取id最大的一个学生数据"></a>获取id最大的一个学生数据</h3><p>下面的是错误做法，因为不知道id最大的name是谁，会报错，如果sql_mode&#x3D;tranditional，会执行成功，但是name是随机的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">MAX</span>(e.sid),s.name <span class="keyword">from</span> enrolled <span class="keyword">as</span> e,student <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">where</span> e.sid <span class="operator">=</span> s.sid</span><br></pre></td></tr></table></figure>
<p>下面的在postgresql和mysql都可以执行成功，并获取到id最大的name数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sid, name <span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sid <span class="keyword">in</span> (<span class="keyword">select</span> <span class="built_in">max</span>(sid) <span class="keyword">from</span> enrolled)</span><br></pre></td></tr></table></figure>

<p>下面的SQL在postgresql中可以执行成功，结果和上面的一样，而在mysql8中报错<code>This version of MySQL doesn&#39;t yet support &#39;LIMIT &amp; IN/ALL/ANY/SOME subquery&#39;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sid, name <span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sid <span class="keyword">in</span> (<span class="keyword">select</span> sid <span class="keyword">from</span> enrolled <span class="keyword">order</span> <span class="keyword">by</span> sid <span class="keyword">desc</span> limit <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="获取没有学生报名的课程"><a href="#获取没有学生报名的课程" class="headerlink" title="获取没有学生报名的课程"></a>获取没有学生报名的课程</h3><p>下面的sql在postgresql 和 mysql 中都可以得到正确的结果</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> course </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> enrolled <span class="keyword">where</span> course.cid <span class="operator">=</span> enrolled.cid);</span><br></pre></td></tr></table></figure>

<h3 id="window窗口"><a href="#window窗口" class="headerlink" title="window窗口"></a>window窗口</h3><p><code>ROW_NUMBER</code>和<code>RANK</code>都需要和<code>OVER</code>一起使用。</p>
<ul>
<li>ROW_NUMBER(): 显示当前行号</li>
<li>RANK() : 显示排序后的排名，如果没有排序，都是1</li>
<li>OVER()<ul>
<li>PARTITION BY 进行分组</li>
<li>GROUP BY 进行分组</li>
<li>ORDER BY 排序</li>
</ul>
</li>
</ul>
<p><img src="/../images/15445001.png" alt="001"></p>
<p><img src="/../images/15445002.png" alt="002"></p>
<p><img src="/../images/15445003.png" alt="003"></p>
<h4 id="获取每个课程中分数最高的学生信息"><a href="#获取每个课程中分数最高的学生信息" class="headerlink" title="获取每个课程中分数最高的学生信息"></a>获取每个课程中分数最高的学生信息</h4><p>下面的SQL，在postgresql中执行成功，mysql8执行报错。</p>
<p>首先查询所有课程信息，并按照课程分组，按照分数排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line"><span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cid <span class="keyword">ORDER</span> <span class="keyword">BY</span> grade <span class="keyword">ASC</span>)</span><br><span class="line"><span class="keyword">AS</span> rank <span class="keyword">FROM</span> enrolled</span><br></pre></td></tr></table></figure>

<p><img src="/../images/15445004.png" alt="004"></p>
<p>接着搜索上表中分数为1，也就是分数最高的学生。也就是每个课分数最高的学生信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line">    <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cid</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> grade <span class="keyword">ASC</span>)</span><br><span class="line">    <span class="keyword">AS</span> rank <span class="keyword">FROM</span> enrolled) <span class="keyword">AS</span> ranking</span><br><span class="line"><span class="keyword">WHERE</span> ranking.rank <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="/../images/15445005.png" alt="005"></p>
<h3 id="CTE-common-table-expressions"><a href="#CTE-common-table-expressions" class="headerlink" title="CTE(common table expressions)"></a>CTE(common table expressions)</h3><p>使用<code>CTE</code>实现获取每个课程中分数最高的学生信息。</p>
<p>通过<code>WITH</code>语句来声明一个临时表。表名<code>cteSource</code>，表的内容就是最的sid，通过<code>SELECT MAX(sid) FROM enrolled</code>查询出来的结果。字段名叫<code>maxId</code>。</p>
<p>然后在查询语句里面就可以连接<code>cteSource</code>表，然后通过sid &#x3D; cteSource.maxId 来获取到sid最大的用户信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> cteSource (maxId) <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(sid) <span class="keyword">FROM</span> enrolled</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> student, cteSource</span><br><span class="line"><span class="keyword">WHERE</span> student.sid <span class="operator">=</span> cteSource.maxId</span><br></pre></td></tr></table></figure>

<p>还有一些其他的用法，比如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> cte1 (col1) <span class="keyword">AS</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span></span><br><span class="line">),</span><br><span class="line">cte2 (col2) <span class="keyword">AS</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> cte1, cte2;</span><br></pre></td></tr></table></figure>

<h3 id="lateral-join"><a href="#lateral-join" class="headerlink" title="lateral join"></a>lateral join</h3><p>mysql目前还不支持该功能，postgreSQL和Sqlserver等支持。</p>
<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>页的三个概念</p>
<ol>
<li>硬件上的页面(通常是4KB)</li>
<li>操作系统上的页面(4KB,x64 2MB&#x2F;1GB)</li>
<li>数据库页面(512B-32KB)</li>
</ol>
<p>磁盘和内存通信是一页一页的，如果数据都在一页里，后续的访问请求就可以走内存了，要不然还的从磁盘获取。内存中可以获取bit数据。</p>
<p>系统设计目标：给应用程序一个错觉，能提供足够的内存将整个数据库存入内存中。<br>实现：谨慎的最小化每次从磁盘读取内容或运行查询时所带来的影响。<br>流程：</p>
<ul>
<li>查询执行器：向内存中的<code>buffer pool</code>请求查询内容。</li>
<li>buffer pool: 如果数据所在的页已经在buffer pool中，就直接返回。如果数据所在的页不在buffer pool中，就向磁盘中的<code>database file</code>请求。</li>
<li>database file: 有页目录，还有具体的页，数据存在页中，查询页目录找到对应的页返回给<code>buffer pool</code>。</li>
</ul>
<p><img src="/../images/15445006.png" alt="006"></p>
<p>上面的步骤操作系统本身就可以实现，比如使用<code>mmap</code>，但是操作系统是统一的动作，遇到一些问题不知道该如何处理，而DBMS则可以根据不同的情况做不同的处理，进行优化。像主流的<code>mysql</code>,<code>SqlServer</code>,<code>Oracle</code>都没有用<code>mmap</code>。<code>mongoDB</code>早期使用的<code>mmap</code>，后面也是用<code>WiredTiger</code>替换掉了<code>mmap</code>。</p>
<p>DBMS自己实现的话，主要关心的两个问题:</p>
<ol>
<li>如何表示磁盘上文件的数据</li>
<li>如何管理内存以及在硬盘间移动数据</li>
</ol>
<h3 id="如何表示磁盘上文件的数据"><a href="#如何表示磁盘上文件的数据" class="headerlink" title="如何表示磁盘上文件的数据"></a>如何表示磁盘上文件的数据</h3><p>数据库的数据最终以文件的形式放在磁盘中。通过文件读写将数据读写到文件中。文件有特定的格式，具体的内容有数据库进行解析然后展示在数据库中。这就是<code>storage manager</code> or <code>storage engine</code>。</p>
<p><code>storage manager</code>负责文件的读写工作。所有的文件（不管是一个或者多个）以 <code>page</code> 的形式存储，管理多个 <code>page</code> 组成的集合。</p>
<p>一个<code>page</code>就是一个固定大小的数据块。<code>page</code> 可以保存任何东西，<code>tupe</code>, <code>metadata</code>, <code>indexes</code>, <code>log</code>等等。每个<code>page</code>有唯一的ID,是<code>page ID</code>。</p>
<p>有些<code>page</code>要求是独立的，自包含的(self-contained)。比如<code>mysql的InnoDB</code>。因为这样的话一个表的元数据和本身的数据内容在一起，如果发生问题的话，可以找回元数据和数据。如果元数据和数据在不同的<code>page</code>中，如果发生问题导致元数据的<code>page</code>丢失，那么数据则恢复不了了。</p>
<p><code>indirection layer</code>记录page ID的相对位置，方便找到对应的偏移量。这样page目录就能找到对应的page。 </p>
<p>不同的DBMS对于文件在磁盘上的存储方式不一样，有下面几种</p>
<ul>
<li>堆存储</li>
<li>树存储</li>
<li>有序文件存储（ISAM）</li>
<li>hashing文件存储</li>
</ul>
<p>堆存储</p>
<ul>
<li>无序的，保存的顺序和存储的顺序无关。</li>
<li>需要读写page</li>
<li>遍历所有的page</li>
<li>需要元数据记录哪些是空闲的page,哪些是已经使用的page。</li>
<li>使用 <code>page directory</code> 方式来记录文件位置。</li>
</ul>
<p>page directory</p>
<ul>
<li>存储page ID和所在位置的关系</li>
<li>存储page的空闲空间信息</li>
</ul>
<p><img src="/../images/15445010.png" alt="010"></p>
<p>page header</p>
<ul>
<li>page 大小</li>
<li>checksum 校验和</li>
<li>DBMS版本信息</li>
<li>事务可见性</li>
<li>压缩信息</li>
</ul>
<h4 id="page-layout"><a href="#page-layout" class="headerlink" title="page layout"></a>page layout</h4><h5 id="tuple-oriented-storage"><a href="#tuple-oriented-storage" class="headerlink" title="tuple oriented storage"></a>tuple oriented storage</h5><p>一般想法，直接存储，并在后面追加，但是对于可变数据长度很难管理。</p>
<ul>
<li>记录page数，也就是page内部可插入的偏移量</li>
<li>一个一个tupe按照顺序存储</li>
</ul>
<p><img src="/../images/15445007.png" alt="007"></p>
<p>所以，page内部，通常不使用上面那种，而使用的是slotted pages</p>
<ul>
<li>slotted pages<ul>
<li>slot array 存储插槽信息的偏移量，通过他找到对应的tuple</li>
<li>支持可变长度的 tuple</li>
<li>但是会产生一些碎片空间，因为太小，tuple放不下。</li>
<li>压缩可以去除碎片空间，但是压缩的时候这个page就不能读写了。</li>
</ul>
</li>
</ul>
<p><img src="/../images/15445008.png" alt="008"></p>
<p><code>record ID</code>表示一个tuple的物理位置,不同的DBMS有不同的名称，来表示数据的唯一位置，比如<code>postgresql</code>的<code>ctid</code>,<code>oracle</code>的<code>rowid</code>。<code>ctid</code>由<code>page id</code>和<code>slot number</code>组成。</p>
<p><img src="/../images/15445009.png" alt="009"></p>
<p>插入新的tuple的时候</p>
<ol>
<li>检查page direactory,找到一个page里面有空的可用的slot</li>
<li>如果该page不在内存,就从磁盘上获取它，将它加载到内存</li>
<li>在page里面检查slot array，找到一个空的空间，将tuple插入</li>
</ol>
<p>更新tuple的时候</p>
<ol>
<li>检查page direactory,找到tuple对应的page</li>
<li>如果该page不在内存,就从磁盘上获取它，将它加载到内存</li>
<li>在page里面通过slot array获取tuple的偏移量</li>
<li>如果数据空间合适，那么直接覆盖该tuple，否则，将原来的tuple标记为已删除，并将新tuple插入其他page。</li>
</ol>
<p>因此更新的时候有一些问题</p>
<ul>
<li>page会产生碎片空间</li>
<li>更新的时候需要从磁盘获取整个page</li>
<li>更新多条数据的时候，可能多个tuple在多个page中，产生随机IO</li>
</ul>
<p>所以有些DBMS不能更新数据，只能增加数据，比如HDFS等</p>
<h5 id="Log-Structured-Storage"><a href="#Log-Structured-Storage" class="headerlink" title="Log Structured Storage"></a>Log Structured Storage</h5><p>比如HBase,ClickHouse,RocksDB,LevelDB都是这个方式。 </p>
<p>这种方式的一些问题：</p>
<ul>
<li>Write-Amplification:在该tuple的生命周期里面可能写入无数次磁盘，并一直在那里且不被需要。</li>
<li>Compaction is Expensive：</li>
</ul>
<h5 id="Index-Organized-Storage"><a href="#Index-Organized-Storage" class="headerlink" title="Index Organized Storage"></a>Index Organized Storage</h5><p>tuple</p>
<ul>
<li>header</li>
<li>列1</li>
<li>列2</li>
<li>列n</li>
</ul>
<h4 id="tupe-layout"><a href="#tupe-layout" class="headerlink" title="tupe layout"></a>tupe layout</h4><p>tuple就是一堆bit，DBMS解释他们的作用。里面包含</p>
<ul>
<li>header</li>
<li>data</li>
</ul>
<h5 id="data-layout"><a href="#data-layout" class="headerlink" title="data layout"></a>data layout</h5><p>table foo</p>
<ul>
<li>id int primary key</li>
<li>value bigint</li>
</ul>
<p><img src="/../images/15445011.png" alt="011"></p>
<h5 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h5><p>现代CPU是64位对齐，创建表以后，DBMS会自动的将数据进行对齐存储，不过，如果在创建表的时候考虑对齐，可以优化速度和存储空间。</p>
<p><img src="/../images/15445012.png" alt="012"></p>
<h5 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h5><p>可变长度的数据<code>varchar</code>,<code>varbinary</code>,<code>text</code>,<code>blob</code>,他们的长度存在header里面。</p>
<p>日期时间类型存储的是时间戳。</p>
<p>float&#x2F;real&#x2F;double: 是浮点数，cpu支持浮点数运算，优点是速度快，但是会精度缺失<br>decimal: 是定点数，运算速度慢，但是精度高。</p>
<p><img src="/../images/15445013.png" alt="013"></p>
<p>large values，应该避免这样，因为维护overflow page很麻烦。</p>
<ul>
<li>tuple中存储另外一个page页的指针，将具体数据存放到另外一个page页中。</li>
<li>postgresql中叫<code>toast</code>，如果数据大于2KB，就会放到toast中，tuple中只存储指针。</li>
<li>mysql中叫<code>overflow page</code>，如果数据大于1&#x2F;2的page大小，就会放进去，tuple中只存储指针。</li>
</ul>
<p>外部存储</p>
<ul>
<li>tuple中存储指向外部文件的指针或者文件地址。</li>
</ul>
<p>NULL存储</p>
<ul>
<li>行数据库通常是在Header里面增加bit map来判断是否是null</li>
<li>列数据库通常使用占位符来标识NULL</li>
<li>在每个属性前面增加bit来标识是否是NULL，这么做会破坏对齐，或增加存储空间，MySQL曾使用这个方法，后来抛弃了这个方法。</li>
<li>NULL &#x3D;&#x3D; NULL 是 NULL, NULL is NULL 是 true</li>
</ul>
<p>catalogs 用来存储数据库元信息，大多数数据库将这些信息存到一张表里面</p>
<ul>
<li>表，字段，索引，视图等</li>
<li>用户，权限，安全等</li>
<li>内部数据统计等</li>
<li>infomation schemal api 通过这个来获取catalogs信息<ul>
<li>mysql<ul>
<li>show tables 获取所有的表</li>
<li>describe table_name 获取表的信息</li>
</ul>
</li>
<li>postgresql<ul>
<li>\d or \d+ 获取所有的表</li>
<li>\d table_name 获取表信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="DATABASE-WORKLOADS"><a href="#DATABASE-WORKLOADS" class="headerlink" title="DATABASE WORKLOADS"></a>DATABASE WORKLOADS</h3><p>OLTP</p>
<ul>
<li>通常是业务侧使用的传统数据库，比如oracle,postgresql,mysql</li>
<li>小的业务多次执行，比如多个简单的插入，更新，查询</li>
</ul>
<p>OLAP</p>
<ul>
<li>通常是大数据，数据分析来使用，比如Hbase等，支持复杂的数据查询</li>
<li>OLAP位于OLTP的后方</li>
</ul>
<p>HTAP</p>
<ul>
<li>OLTP和OLAP的混合，两个都可以做</li>
</ul>
<p><img src="/../images/15445014.png" alt="014"></p>
<p>N-ary 模型</p>
<ul>
<li>行存储模型</li>
<li>page里面是按行存储的，每个tuple就是一行</li>
</ul>
<p>优点</p>
<ul>
<li>快速的insert,update,delete</li>
<li>查找的优势是数据都在一起</li>
<li>能在集群中使用 <code>index-oriented</code>物理存储方式</li>
</ul>
<p>缺点</p>
<ul>
<li>不适合扫描table中大部分<code>and/or</code>属性的子集</li>
<li>访问的内存局部性糟糕，查找数据的弊端是会加载一个page的时候会加载不需要的行数据</li>
<li>不适合压缩，因为一个page里面有不同的<code>value domains</code></li>
</ul>
<p>Decomposition 模型</p>
<ul>
<li>列存储模型</li>
<li>一个page里面是一列数据</li>
</ul>
<p>优点</p>
<ul>
<li>优势是查找的时候不会加载不需要的数据</li>
<li>更快的查询过程，因为有更好的局部性和<code>cached data</code>重用</li>
<li>更好的数据压缩</li>
</ul>
<p>缺点</p>
<ul>
<li>劣势是查找的数据不在一起，需要去各个page里面找。所以insert update delete也更慢。</li>
</ul>
<p>列存储查询的时候处理where子句以后需要找到对应的其他列在其他page中的位置，有两个方法，通常使用第一个方法，第二个方法并不好</p>
<ul>
<li>固定长度：每个page中的每个列的长度都固定，顺序也一样，这样通过where子句对应列的偏移量，就可以确定其余列的偏移量</li>
<li>内嵌tuple id: 每个值里面都加入对应的tuple id，根据tuple id查询其他列</li>
</ul>
<p>Partition Attributes Across(PAX) Storage 模型</p>
<ul>
<li>将行存储和列存储混合的模型</li>
<li>目标是保留列存储的快速处理和行存储的空间局部性优势（这里空间局部性优势指访问的数据在一起）</li>
<li>比如<a target="_blank" rel="noopener" href="https://orc.apache.org/">Apache ORC</a>,<a target="_blank" rel="noopener" href="https://arrow.apache.org/">Apache Arrow</a>, <a target="_blank" rel="noopener" href="https://parquet.apache.org/">Apache Parquet</a>.</li>
</ul>
<p>PAX 物理数据组织</p>
<ul>
<li>水平划分为<code>row groups</code>，即一些行数据的集合</li>
<li>在<code>row groups</code>里面垂直划分为<code>column chunks</code>，即列的集合，也就是列存储方式</li>
<li>每个<code>column chunks</code>下面可能还会有page</li>
</ul>
<p><img src="/../images/15445015.png" alt="015"></p>
<h3 id="数据库压缩"><a href="#数据库压缩" class="headerlink" title="数据库压缩"></a>数据库压缩</h3><p>目标1：必须产生固定长度的值<br>目标2：在查询期间尽可能推迟解压缩，你不希望先解压缩在查询，这样很占空间且影响速度<br>目标3：必须是无损方案</p>
<p>压缩粒度</p>
<ul>
<li>Block-level: 压缩同一张表的tuple</li>
<li>Tuple-level: 压缩整个tuple的内容（仅限行存储）</li>
<li>Attribute-level：压缩同一个tuple的多个属性或单个属性</li>
<li>Column-level：压缩存储于多个tuple中的一个或多个属性的多个值（仅限列存储）</li>
</ul>
<h4 id="mysql-innodb-压缩"><a href="#mysql-innodb-压缩" class="headerlink" title="mysql innodb 压缩"></a>mysql innodb 压缩</h4><p>innodb 在写入的时候可以不解压，但是读取的时候会先在buffer pool中解压在读取。因此Mysql innodb的压缩的好处是提升空间利用率，减少了磁盘IO,缺点是读取的时候需要解压，因此增加了这部分的时间和CPU功耗以及解压以后会占用更多的内存空间。<br>innodb 默认page 是 16KB,可以压缩到1&#x2F;2&#x2F;4&#x2F;8KB。</p>
<p><img src="/../images/15445016.png" alt="016"></p>
<h4 id="Column-level-压缩算法"><a href="#Column-level-压缩算法" class="headerlink" title="Column-level 压缩算法"></a>Column-level 压缩算法</h4><h5 id="run-length-encoding"><a href="#run-length-encoding" class="headerlink" title="run length encoding"></a>run length encoding</h5><p>将单个column中的相同值压缩成三元组，需要对列进行智能排序，以最大限度地提高压缩机会。</p>
<ul>
<li>属性的值</li>
<li>column segment的起始位置</li>
<li>值的数量</li>
</ul>
<p>比如下面的数据，将压缩成右边的数据，(Y,0,3)，代表值是Y，起始位置0,值的数量有3个。后面的压缩数据是一样的。这种压缩方法可以快速计算count的数量等。</p>
<p>如果你的值类型很少，且有序，那么将大大减少空间占用。</p>
<p><img src="/../images/15445017.png" alt="017"></p>
<h5 id="bit-packing"><a href="#bit-packing" class="headerlink" title="bit packing"></a>bit packing</h5><p>如果字段里面的值都比较小，但是column type很大，可以忽略掉不需要的bit，比如int是32 bit，但是里面的值都很小，用不了这么多，就可以忽略他们。</p>
<p><img src="/../images/15445018.png" alt="018"></p>
<h5 id="bit-map-encoding"><a href="#bit-map-encoding" class="headerlink" title="bit map encoding"></a>bit map encoding</h5><p>使用bit map来标识数据值，仅仅适用于值的类型比较少的。</p>
<p><img src="/../images/15445019.png" alt="019"></p>
<h5 id="delta-encoding"><a href="#delta-encoding" class="headerlink" title="delta encoding"></a>delta encoding</h5><p>找到一个基本的数据，以它为基础，进行压缩，+1，-1这种。再将其按照<code>run length encoding</code>的方式压缩，可以再次节省空间。</p>
<p><img src="/../images/15445020.png" alt="020"></p>
<h5 id="DICTIONARY-COMPRESSION"><a href="#DICTIONARY-COMPRESSION" class="headerlink" title="DICTIONARY COMPRESSION"></a>DICTIONARY COMPRESSION</h5><p>按照字典将数据进行映射，并存储，这样可以节省空间，如果在字典映射的时候还能先排序，那么还可以完成将<code>where like &#39;and%&#39;</code>转成<code>where between 10 and 20</code>。</p>
<p><img src="/../images/15445021.png" alt="021"></p>
<h2 id="buffer-pool-和内存管理"><a href="#buffer-pool-和内存管理" class="headerlink" title="buffer pool 和内存管理"></a>buffer pool 和内存管理</h2><p>时间管理</p>
<ul>
<li>将数据写入磁盘的何处</li>
<li>目标是经常被一起使用的pages放在磁盘中也是一起的地方。</li>
</ul>
<p>空间管理</p>
<ul>
<li>何时将pages读入内存，何时将pages写入磁盘</li>
<li>目标是最小化的解决必须从磁盘读取数据这个事</li>
</ul>
<p>frame</p>
<ul>
<li>buffer pool中的一块内存区域</li>
<li>相当于page里面的slot</li>
</ul>
<p>page table</p>
<ul>
<li>记录pages在当前buffer pool中的位置,通过page table 和 page id可以知道在哪个frame中。</li>
</ul>
<p><img src="/../images/15445022.png" alt="022"></p>
<p>page 里面记录一些元数据</p>
<ul>
<li>dirty flag: 记录是否被修改过，也就是常说的”脏数据标记”</li>
<li>引用计数器： 记录有多少线程在使用这个数据</li>
<li>访问追踪信息</li>
</ul>
<p>lock and latch</p>
<ul>
<li>lock在数据库中指high-level的东西，可以保护数据库，数据表，数据。保护数据库内容不受其他事务影响，在事务持续期间保持，可以回滚。</li>
<li>latch保护内部的东西，数据结构，内存区域。保护内部数据结构不受其他线程的影响，在操作期间保持，不需要可以回滚。</li>
</ul>
<p>buffer pool 使用 mmap的问题：</p>
<ul>
<li>事务安全：操作系统完全控制page的写入，刷新，有可能在一个事务没有完成的时候有些数据就已经写入磁盘了。</li>
<li>IO停顿：DBMS不知道哪些page在内存中，当读取不在内存中的时候触发page fault，操作系统才会从磁盘获取。</li>
<li>错误处理：任何访问都可能触发操作系统的中断信号<code>SIGBUS</code>，而整个DBMS都需要处理它。</li>
<li>性能问题</li>
</ul>
<p>全局策略</p>
<ul>
<li>针对所有的查询或者事务的策略</li>
</ul>
<p>局部策略</p>
<ul>
<li>针对单个查询或者事务的策略</li>
<li>可以对单个优化，虽然对全局可能不好</li>
</ul>
<h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><p>淘汰策略有几种算法</p>
<ul>
<li>LRU</li>
<li>Clock：Linux使用的，把所有的page放成一个圈，每个page有一个标志位，如果为0表示没有被使用过，1被使用过，淘汰的时候淘汰0的，再把1改成0.</li>
<li>LRUK：记录使用的次数k，达到次数才放到缓存里面，淘汰的时候比对两次的时间间隔，间隔长的认为是最近最少使用</li>
<li>PRIORITY HINTS</li>
</ul>
<h4 id="mysql-近似-LRU-k"><a href="#mysql-近似-LRU-k" class="headerlink" title="mysql 近似 LRU-k"></a>mysql 近似 LRU-k</h4><p>相当于K&#x3D;2。有一个LRU List，但是有两个指针，分别表示<code>old list</code>和<code>young list</code>。当数据第一次被访问的时候放到<code>old list</code>中，再次被访问的时候放到<code>young list</code>中。</p>
<p><img src="/../images/15445023.png" alt="023"></p>
<p>当访问 page1 的时候，需要淘汰掉<code>old list</code>中的page8，其实也是整个LRU中的最后一个元素。然后将page1插入<code>old list</code>。</p>
<p><img src="/../images/15445024.png" alt="024"></p>
<p>当再次访问 page1 的时候，将page1 插入<code>young list</code>。这个时候<code>young list</code>最后的元素也就进入了<code>old list</code>.</p>
<p><img src="/../images/15445025.png" alt="025"></p>
<h4 id="PRIORITY-HINTS"><a href="#PRIORITY-HINTS" class="headerlink" title="PRIORITY HINTS"></a>PRIORITY HINTS</h4><p>比如B+树的根节点具有最高的优先级，所以一直放在内存中。</p>
<p><img src="/../images/15445026.png" alt="026"></p>
<p>多buffer pool</p>
<ul>
<li>通过使用多个buffer pool可以根据不同的table放入不同的buffer pool进行不同的优化。也可以通过其他的策略使用多个buffer pool</li>
<li>由于有多个buffer pool,减少了锁争抢和锁等待的时间。</li>
<li>mysql中通过hash确定数据是否在buffer pool，然后通过取余确定在哪个buffer pool</li>
</ul>
<p>预取数据</p>
<ul>
<li>顺序扫描的时候预先把后面的page取到buffer pool中。这一步mmap也可以实现</li>
<li>索引扫描的时候预先把索引中需要用到的后面的page取到buffer pool中。这一步mmap实现不了，这也是数据库自己实现buffer pool的优势。</li>
</ul>
<p>扫描共享</p>
<ul>
<li>共享扫描到的page内容</li>
<li>如果查询1需要扫描page1,page2,page3,page4的内容并且已经扫描到了page3,这个时候page1已经扫描完了被从buffer pool中丢弃了</li>
<li>这时候有一个查询2也需要扫描所有的pages，如果从page1开始扫描，就会把page1再次读入buffer pool，但是这样是低效率的，所以可以先共享查询1的page数据，先扫描page3,然后page4，这时候查询1执行完毕，在回头扫描page1,page2。</li>
<li>mysql不支持</li>
</ul>
<p>buffer pool bypass</p>
<ul>
<li>单独开辟一个本地内存区域来用，而不是使用buffer pool</li>
<li>可以避免操作page table带来的开销（latch锁住的开销）</li>
<li>可以避免污染buffer pool</li>
<li>适合数据量不大的情况</li>
<li>mysql5.7不支持</li>
</ul>
<p>os page cache</p>
<ul>
<li>操作系统的文件缓存，当使用fopen,fread,fwrite的时候会先从操作系统缓存中读取文件内容。</li>
<li>只有postgresql使用了这个。</li>
<li>通过 direct IO可以不使用这个</li>
<li>使用它会导致有两个缓存，buffer pool 和 os page cache。不好控制。</li>
<li>fsync如果失败以后再次调用也不会生效，因为它会将dirty设置为false</li>
</ul>
<p>两种写出方案需要做权衡，取舍</p>
<ul>
<li>如果写出dirty flag的数据然后读取新数据，就会产生2次IO。通常会有一个定时任务线程去将dirty flag的数据写入磁盘，写入之前必须要先将操作日志写入磁盘。</li>
<li>如果直接读取新数据就只有1次IO，但是这样有可能把下次会用到的数据丢弃。</li>
</ul>
<h2 id="hash-table"><a href="#hash-table" class="headerlink" title="hash table"></a>hash table</h2><p>hash function</p>
<ul>
<li>最快的是facebook 的 xxhash</li>
</ul>
<p>hash schema</p>
<ul>
<li>liner probe hashing<ul>
<li>如果要插入的位置有值了，就往下扫描，扫描到空的位置插入</li>
<li>删除的时候可以增加一个<code>墓碑</code>标记，这样就知道这里是有数据的不是空，查找的时候就会继续往下扫描而不会是没找到</li>
<li>删除的时候还可以把后面的数据往前移动，但是这样有的数据就不再原来的位置了，就找不到了。因为只会往下扫描不会往上扫描</li>
</ul>
</li>
<li>robin hood hashing<ul>
<li>记录<code>距离数</code>，表示插入的位置和应该插入的位置的距离。从0开始。</li>
<li>插入的时候判断距离数，进行<code>劫富济贫</code>，如果你向下扫描到距离数为3的地方插入，而在距离数为2的地方的数据x，x的距离数比你小，比如是0，1.那么你就占据这里，你插入距离数为2的地方，而将x插入你下面，x的距离数会+1.</li>
<li>从整体来看，这个方法牺牲了插入的效率，将数据的距离数变得更加平均</li>
</ul>
</li>
<li>cuckoo hashing<ul>
<li>该方法使用两个或多个<code>hash table</code>来记录数据，对A进行两次hash，得出两个hash table中的插入位置，随机选择一个进行插入</li>
<li>如果选择的插入位置已经有数据了，就选择另一个插入</li>
<li>如果两个都有数据了，就占据一个，然后对这个位置上之前的数据B再次hash选择其余位置。</li>
</ul>
</li>
</ul>
<p>动态hash table</p>
<ul>
<li>chained hashing<ul>
<li>把所有相同hash的组成一个bucket链表，然后一直往后面增加</li>
<li>java的hash table默认就是这样的</li>
</ul>
</li>
<li>extendible hashing<ul>
<li>对 chained hashing 的扩展</li>
<li>有一个slot array，在slot array上有一个 counter, 如果counter &#x3D; 2，代表看hash以后的数字的前两个bit,slot array就有4个位置，分别是00,01,10,11</li>
<li>每个slot指向一个bucket</li>
<li>hash以后找到前两位对应的slot指向的bucket，将数据放进去，如果满了，放不下了就进行拆分</li>
<li>将slot array的counter扩容为3，看前3个bit，slot array变成了8个位置</li>
<li>只将这个满了的bucket拆分成2个，其余的不变，重新进行slot的映射</li>
<li>再次hash这个值，看前3个bit找到对应的slot,在找到对应的bucket，然后插入进去</li>
</ul>
</li>
<li>linear hashing<ul>
<li>对 extendible hashing 的扩展</li>
<li>去掉了 conter，因为他每次加1，都会扩容一倍</li>
<li>增加了<code>split point</code>，一开始指向0，然后每次<code>overflow</code>需要拆分的时候就拆分split point指向的那个bucket，然后slot array只扩容一个，这个时候出现第二个hash函数并将split point+1</li>
<li>查询的时候如果slot array的位置小于split point，就使用第二个hash函数，因为被拆分了</li>
<li>如果大于等于split point，就使用第一个hash函数</li>
</ul>
</li>
</ul>
<h2 id="tree-index"><a href="#tree-index" class="headerlink" title="tree index"></a>tree index</h2><ul>
<li>b tree(1971)</li>
<li>b+ tree (1973)</li>
<li>b* tree (1977)</li>
<li>b link tree (1981)</li>
</ul>
<p>b+ tree 删除和插入的复杂度都是<code>O(log n)</code>， b 是 <code>balance (平衡)</code>，paper: <code>the ubiquitous B-tree</code></p>
<p>B+ tree,保证每个节点都必须是半满的，对于存放在节点中的key数量来说，key数量至少为<code>M/2 - 1</code>个，M为树的高度，key的数量必须小于 <code>M - 1</code>,如果当删除数据以后导致key数量小于M&#x2F;2 - 1个，就会进行平衡，使他满足M&#x2F;2 - 1个。</p>
<blockquote>
<p>M&#x2F;2 - 1 ≤ key数量 ≤ M - 1</p>
</blockquote>
<p>如果一个中间节点有k个key,那你就会有k+1个非空孩子节点，也就是k+1个指向下方节点的指针。每个节点的内容是一个<code>指针</code>和一个<code>key</code></p>
<p>叶子节点之间有连接叶子节点的兄弟指针，这个想法来源于b link tree。每个节点的内容是一个<code>数据</code>和一个<code>key</code>，数据可以是一个<code>record id</code> 也可以是一个 <code>tuple</code></p>
<p>叶子节点的内容，通常key和value是分开存储的，因为搜索的时候并不需要加载value数据</p>
<ul>
<li>元数据<ul>
<li>isleaf 是否是叶子节点</li>
<li>slots 有多少空闲的slot</li>
<li>prev 前一个叶子节点的指针</li>
<li>next 后一个叶子节点的指针</li>
</ul>
</li>
<li>key数据</li>
<li>value数据</li>
</ul>
<p>b tree 和 b+ tree 的区别</p>
<ul>
<li>b tree的中间节点也可以存数据，所以key是不重复的</li>
<li>b+ tree的中间节点没有数据，所有数据都在叶子节点，所以key有可能既存在中间节点也存在叶子节点。会重复</li>
<li>b tree的性能在并行处理上更差，因为修改以后需要向上传播也需要向下传播修改，这个时候两边都要增加<code>latch</code></li>
<li>b+ tree的性能更好，因为只修改叶子节点，所以只需要向上传播，只需要增加一个<code>latch</code></li>
</ul>
<p>b+ tree 插入</p>
<ol>
<li>向下扫描，找到对应的叶子节点</li>
<li>如果可以插入就直接插入</li>
<li>如果不可以插入，那么从中间分开，变成两个叶子节点，并将中间的key传递给父节点，插入父节点。</li>
<li>如果父节点可以插入就直接插入并分出一个指针指向新的叶子节点</li>
<li>如果父节点不可以插入重复上述操作3</li>
</ol>
<p>b+ tree 删除</p>
<ol>
<li>向下扫描，找到对应的叶子节点，这个时候就会增加<code>latch</code>，因为不知道需不需要合并，操作以后才会释放</li>
<li>如果可以删除就直接删除</li>
<li>如果删除后导致key数量 &lt; <code>M/2 - 1</code>,那么就会出发合并，因为不满足key数量啦</li>
<li>进行合并的时候删除这个key，然后先查看左右的兄弟节点，是否能直接把数据插入过来，如果可以的话就掠夺一个key过来，然后向上传播</li>
<li>如果不能掠夺，那么就合并到兄弟节点，然后向上传播。</li>
</ol>
<p>b+ tree 标准填充容量大概是67% - 69%，对于一个大小是8kb的page来说，如果高度为4，大约能记录30 0000个键值对。</p>
<p>b+ tree的查找</p>
<ul>
<li>对于&lt;a,b,c&gt;,查找a&#x3D;5 and b&#x3D;3也是可以走索引的，但是hash索引就不行，有些数据库还支持b&#x3D;3的搜索走索引，比如oracle和sql server</li>
</ul>
<p>b+ tree的节点大小，机械硬盘的大小最好在1M,ssd的大小在10KB</p>
<blockquote>
<p>推荐书籍 Modern B-Tree Techniques</p>
</blockquote>
<p>对于非唯一索引</p>
<ul>
<li>重复存储，需要注意两个相同的key存储在不同的page中</li>
<li>value list,key只存储一个，然后所有的value存储成value list</li>
</ul>
<p>节点内部的搜索</p>
<ul>
<li>线性搜索</li>
<li>二分搜索</li>
<li>interpolation<ul>
<li>通过数学计算出线性搜索的起点，提升搜索速度</li>
</ul>
</li>
</ul>
<p>优化方法</p>
<ul>
<li>前缀压缩<ul>
<li>比后缀截断用的更多</li>
<li>存储在page中的key,如果前缀一样的可以提取出来存储一次，然后剩余的数据在存储在key里面</li>
</ul>
</li>
<li>后缀截断<ul>
<li>存储在中间节点的，用来寻路的key，可以只存储前面的部分，如果后面的不需要可以截断</li>
<li>更新的时候需要进行维护</li>
</ul>
</li>
<li>批量插入<ul>
<li>如果已经有数据了再建立索引，这个时候不需要从头开始一个个建立，只需要先排序</li>
<li>然后建立所有的叶子节点</li>
<li>在一层层向上建立中间节点</li>
<li>非常普遍的方法，主流数据库都支持</li>
</ul>
</li>
<li>point willizeing<ul>
<li>将节点固定在内存中</li>
<li>对于page来说，直接存储page指针而不是page id，就不需要请求buffer pool了</li>
</ul>
</li>
</ul>
<p>b+ tree的重复key，通常使用增加<code>record id</code>的方式，这种方式影响更小。</p>
<ul>
<li>增加<code>record id</code>,<code>record id</code>是<code>page id</code> + <code>offset</code>用来确定tuple的位置。</li>
<li>垂直扩展叶子节点，将数据存在里面</li>
</ul>
<p>部分索引</p>
<ul>
<li>在创建索引的时候添加where条件，只有符合条件的才会进入索引。</li>
<li>查询的时候只有符合条件的才会走索引</li>
</ul>
<p>覆盖索引</p>
<ul>
<li>在创建索引的时候添加联合索引</li>
<li>查询的时候所需数据都在索引中，就不需要在找对应的tuple信息了。</li>
</ul>
<p>函数索引</p>
<ul>
<li>创建索引的时候添加函数信息，比如 MONTH(date), 只对月份创建索引</li>
<li>查询的时候 MONTH(date) 就会走索引了，而date就不会走索引了</li>
<li>如果创建的时候只创建 date 索引，那么查询的时候 MONTH(date) 就不会走索引</li>
</ul>
<p>trie index(前缀树)</p>
<ul>
<li>把每个单词建立成树，一层放一个字母</li>
</ul>
<p>radix tree</p>
<ul>
<li>trie index的升级版</li>
<li>对于trie index进行了横向的压缩和纵向的压缩</li>
</ul>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>Bloom filter</p>
<p>Counting Bloom filter</p>
<p>Cuckoo filter</p>
<p>Succinct Range Filter</p>
<h2 id="索引并发控制"><a href="#索引并发控制" class="headerlink" title="索引并发控制"></a>索引并发控制</h2><p>并发控制</p>
<ul>
<li>逻辑正确性<ul>
<li>获取id &#x3D; 5的数据，能正确返回id &#x3D; 5的数据</li>
</ul>
</li>
<li>物理正确性<ul>
<li>保护page指针指向正确的page数据，不会触发 segfualt</li>
</ul>
</li>
</ul>
<p>latch 模式</p>
<ul>
<li>读模式<ul>
<li>可以多个线程读取</li>
</ul>
</li>
<li>写模式<ul>
<li>只有一个线程可以写模式，这个时候其他线程不能读取也不能写入</li>
</ul>
</li>
</ul>
<p>latch</p>
<ul>
<li>blocking os mutex<ul>
<li>std::mutex m;</li>
<li>m.lock();</li>
<li>m.unlock();</li>
</ul>
</li>
<li>test and set spin latch<ul>
<li>std::atomic_flag latch</li>
<li>while(latch.test_and_set()){} &#x2F;&#x2F; 如果获取到锁就跳出循环</li>
</ul>
</li>
<li>read - write latch<ul>
<li>读锁，获取的时候线程数队列，等待队列，如果能获取就进入线程数队列，不能就进入等待队列</li>
<li>写锁，线程数队列，等待队列，如果能获取就进入线程队列，不能就进入等待队列</li>
<li>如果有一个写锁在等待队列，这个时候在获取读锁也放入等待队列，要不然一直读，写锁就获取不到了</li>
</ul>
</li>
</ul>
<p>latch crabbing&#x2F;coupling</p>
<ul>
<li>使用栈保存latchs</li>
<li>每个节点都需要一个latch</li>
<li>如果当前节点是<code>安全</code>的，就可以释放上层的所有latchs</li>
<li><code>安全</code>：指操作的时候不会触发<code>拆分</code>和<code>合并</code>。通常read latch都是安全的，write latch 插入的时候如果有足够的空间就是安全的，删除的时候删除以后不会合并就是安全的</li>
</ul>
<p>乐观锁</p>
<ul>
<li>乐观的认为不需要<code>合并</code>和<code>拆分</code>。</li>
<li>所有的操作都先获取read latch,如果发现需要<code>合并</code>和<code>拆分</code>，再次从头获取write latch来一遍</li>
<li>优点是所有操作都是read latch，可以更好的支持并发</li>
<li>缺点是遇到<code>合并</code>和<code>拆分</code>会再来一遍，而且如果连续的插入都需要合并，就会退化成每个都获取write latch。</li>
</ul>
<p>叶子节点扫描</p>
<ul>
<li>叶子节点的扫描可能会触发<code>死锁</code>，比如两个线程</li>
<li>线程1执行读取，读取到了叶子节点1</li>
<li>线程2执行写入，在叶子节点2处获取了write latch</li>
<li>这个时候线程1在叶子节点1里面没有找到数据，所以要扫描叶子节点2，但是获取read latch的时候卡主了，需要等待</li>
<li>而线程2有可能也需要访问叶子节点1，同样等待，产生死锁</li>
<li>这个时候可以设置等待时间，超过等待时间则<code>自杀</code>，然后重头再来，假如线程1自杀，然后再来一遍，这个时候线程2就可以获取到latch，然后执行下去了</li>
</ul>
<p>overflow处理</p>
<ul>
<li>来源于b link tree的优化</li>
<li>当需要拆分的时候，先拆分叶子节点，这个时候不向<code>父结点</code>传播，因为修改父结点需要从头开始获取write latch。</li>
<li>这个时候标记父结点需要插入一个key</li>
<li>等待下一个修改操作到父结点的时候，获取write latch，然后执行这个插入操作。</li>
</ul>
<h2 id="排序和聚合"><a href="#排序和聚合" class="headerlink" title="排序和聚合"></a>排序和聚合</h2><p>排序的好处</p>
<ul>
<li>有序的数据创建索引的时候可以快速的先创建叶子节点，在创建父结点</li>
<li>有序的数据在<code>order by</code>分组的时候可以更快的分组</li>
<li>有序的数据在<code>distinct</code>去重的时候可以更快的去重</li>
</ul>
<p>排序算法</p>
<ul>
<li>在内存中<ul>
<li>可以使用各种算法</li>
<li>但是有的数据内存放不下，就需要在磁盘上排序</li>
<li>需要先知道<code>可以用内存的大小</code>，这样就知道该内存排序还是磁盘排序</li>
</ul>
</li>
<li>在磁盘上<ul>
<li>快排会产生更多的随机IO,会更慢</li>
<li>使用<code>归并排序</code>更好，分成多个<code>runs</code>,对每个run排序，然后在通过<code>二路归并</code>生成总的排序，这可以减少随机IO</li>
<li>外部归并排序，需要3个<code>buffer pool</code>，2个用来排序run，1个用来二路归并。 </li>
<li>次数：1 + log(n)</li>
<li>总的IO数: 2N * (# of passes)</li>
<li>可以通过<code>预取</code>来优化，当对page排序的时候，另外一个线程先取出下次要排序的page。</li>
</ul>
</li>
</ul>
<p>聚簇索引</p>
<ul>
<li>排序的字段如果建立了聚簇索引，就不需要在排序了，直接可以走聚簇索引拿到排序好的数据</li>
</ul>
<h3 id="top-N-heap-sort"><a href="#top-N-heap-sort" class="headerlink" title="top-N heap sort"></a>top-N heap sort</h3><p>比如下面的sql</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">ASC</span></span><br><span class="line">limit <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>那么首先创建一个大小为2的有序数组或优先级队列之类的。假设我们的数据是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;id:3, name: xxx&#125;, &#123;id:4, name:xxx&#125;, &#123;id:5, name:xxx&#125;, &#123;id:2, name:xxx&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候优先级队列是空的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>然后扫描id为3的数据，放入优先级队列，再扫描id为4的数据，放入优先级队列。这个时候队列数据是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;id:3, name: xxx&#125;, &#123;id:4, name:xxx&#125;</span><br></pre></td></tr></table></figure>

<p>接下来扫描id5的数据，放不进优先级队列，因为id大，最后扫描id2的数据，放入优先级队列，队列就排好序了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;id:2, name:xxx&#125;,&#123;id:3, name: xxx&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/15445027.png" alt="027"></p>
<h3 id="external-merge-sort"><a href="#external-merge-sort" class="headerlink" title="external merge sort"></a>external merge sort</h3><p>当数据太大，无法放在内存中的时候，需要借助外部的文件来进行排序</p>
<ul>
<li>先排序小块的数据，然后写入文件</li>
<li>在将文件的内容合并</li>
</ul>
<p>early materialization</p>
<ul>
<li>将数据放在排序的数据里面，排序以后可以直接返回数据，行数据库一般用这个</li>
</ul>
<p>late materialization</p>
<ul>
<li>排序的数据里存的是tuple id or record id, 排序以后再根据id查询数据返回</li>
</ul>
<p><img src="/../images/15445028.png" alt="028"></p>
<p><img src="/../images/15445029.png" alt="029"></p>
<p>优化方法</p>
<ul>
<li>增加buffer pool在排序中可用的内存，当一个输出page进行写入IO的时候，CPU处理另一个输出page。</li>
<li>多线程，一个线程进行page排序，另外一个线程进行二路归并。</li>
</ul>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>两个实现方法</p>
<ul>
<li>排序</li>
<li>哈希，通常哈希更好，因为都在内存中</li>
</ul>
<blockquote>
<p>group by 和 distinct 本身执行的时候也是需要排序的</p>
</blockquote>
<p>hash</p>
<ol>
<li>分区<ul>
<li>可以顺序扫描每个page</li>
<li>对于每个page的key进行hash，然后分区，hash相同的说明key相同，分到一个区里面</li>
<li>这个时候不管distinct还是group by都可以方便的执行了</li>
</ul>
</li>
<li>重新哈希<ul>
<li>对于分区以后的数据再次进行hash</li>
<li>再次hash的数据放入一个临时的hash table</li>
<li>处理完一个临时的hash table就把结果写入结果集</li>
</ul>
</li>
</ol>
<p>排序的聚合实现，以distinct为例：</p>
<ol>
<li>先执行where条件筛选出符合的<code>tuple</code></li>
<li>再次根据列筛选出符合的列</li>
<li>对于需要排序的列进行排序</li>
<li>顺序扫描排序结果，实现去重，并生成最终结果</li>
</ol>
<p>哈希的聚合实现，以distinct为例：</p>
<ol>
<li>先执行where条件筛选出符合的<code>tuple</code></li>
<li>再次根据列筛选出符合的列</li>
<li>对于需要排序的列进行hash，先分区，再重新哈希。</li>
<li>重新哈希的时候生成最终结果。</li>
</ol>
<p>重新哈希的时候</p>
<ul>
<li>avg的话，需要再临时hash table里面存储key的数量和要求平均数的总数。在生成最终结果的时候进行计算平均数</li>
<li>min的话，临时hash table里面存入最小数，生成最终结果直接取</li>
<li>max同上</li>
<li>sum同上</li>
<li>count同上</li>
</ul>
<h2 id="join算法"><a href="#join算法" class="headerlink" title="join算法"></a>join算法</h2><p>join输出：数据</p>
<ul>
<li>在join的时候把两张表的数据全部输出给下一个处理器，这包括了表的所有字段</li>
<li>好处是，接下来的处理不需要再拿其他字段了，所有字段都有了</li>
<li>坏处是，Join的时候数据量很大，因为有所有字段</li>
<li>可以进行优化，在join的时候只获取需要的字段</li>
</ul>
<p>join输出：record id</p>
<ul>
<li>在join的时候，只获取on的字段和record id，然后需要其他字段的时候在通过 record id去获取，这个很适合列存储数据库</li>
<li>第一个使用的是<code>vertica</code>列存储数据库，不过现在已经不用了</li>
</ul>
<p>如何判断两个join算法的好坏？</p>
<ul>
<li>通过IO来计算</li>
<li>假设左表R有M个page,m个tuple</li>
<li>右表S有N个page,n个tuple</li>
</ul>
<p>join算法</p>
<ul>
<li>Nested Loop Join<ul>
<li>simple&#x2F;stupid</li>
<li>block</li>
<li>index</li>
</ul>
</li>
<li>Sort-Merge Join</li>
<li>Hash Join<ul>
<li>simple</li>
<li>GRACE(Externally partitioned)</li>
<li>Hybird</li>
</ul>
</li>
</ul>
<p><img src="/../images/15445030.png" alt="030"></p>
<h3 id="Simple-Nested-Loop-Join"><a href="#Simple-Nested-Loop-Join" class="headerlink" title="Simple Nested Loop Join"></a>Simple Nested Loop Join</h3><ul>
<li>通过两层for循环，然后符合条件的进行输出</li>
<li>IO计算：因为外层循环要读取 M 个 page,循环的tuple 是 m,内存循环要读取N个page，所以内层循环的IO数是 m * N,总的IO：M + (m * N)</li>
<li>假设 M &#x3D; 1000, m &#x3D; 10 0000, N &#x3D; 500, n &#x3D; 40000, 总的IO &#x3D; 1000 + (10 0000 * 500) &#x3D; 5000 1000</li>
<li>假设 SSD 执行速度 0.1ms 一次IO，大概需要1.3个小时</li>
<li>如果N是左表，那么总IO &#x3D; 500 + (4000 * 1000) &#x3D; 400 0500,大概需要1.1个小时</li>
<li>所以如果左表是小表，性能更好</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Tuple r: R) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Tuple s: S) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.id == r.id) &#123;</span><br><span class="line">            <span class="comment">// 输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested Loop Join"></a>Block Nested Loop Join</h3><ul>
<li>对simple的优化，不在循环tuple，而是循环page，将page打包成block，然后循环block</li>
<li>这样的话对于内层循环来说IO就是 M * N，总的IO就是 M + (M * N)</li>
<li>假设 M &#x3D; 1000, m &#x3D; 10 0000, N &#x3D; 500, n &#x3D; 40000, 总的IO &#x3D; 1000 + (1000 * 500) &#x3D; 50 1000</li>
<li>假设 SSD 执行速度 0.1ms 一次IO，大概需要50s</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个看上去循环多了，不过因为预先读取了两个block才循环，所以循环是在内存中，IO次数少了</span></span><br><span class="line"><span class="keyword">for</span> (Block br: R) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Block bs: S) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Tuple r: br) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Tuple s: bs) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.id == r.id) &#123;</span><br><span class="line">                    <span class="comment">// 输出</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Block-Nested-Loop-Join优化"><a href="#Block-Nested-Loop-Join优化" class="headerlink" title="Block Nested Loop Join优化"></a>Block Nested Loop Join优化</h4><ul>
<li>假设buffer pool容量是B,可以先获取B - 2个左表的Block,剩下2个位置，一个是获取右表的 Block 的，一个是输出的。</li>
<li>这样的话总的IO次数：M + ([M&#x2F;(B-2)] * N), M&#x2F;(B - 2)向上取整</li>
<li>最好的情况是 B &gt; M + 2，代表一次性能获取所有的左表的Block</li>
<li>这样总的IO就变成 M + N</li>
<li>假设 M &#x3D; 1000, m &#x3D; 10 0000, N &#x3D; 500, n &#x3D; 40000, 总的IO &#x3D; 1000  + 500 &#x3D; 1500</li>
<li>假设 SSD 执行速度 0.1ms 一次IO，大概需要0.15s</li>
</ul>
<h3 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested Loop Join"></a>Index Nested Loop Join</h3><p>假设s.id有索引，那么就可以根据索引进行匹配，加快速度.</p>
<ul>
<li>总的成本将是<code>M + (m * C)</code> C是索引需要的时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Tuple r: R) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Tuple s: Index(r = s)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.id == r.id) &#123;</span><br><span class="line">            <span class="comment">// 输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Sort-Merge-Join"><a href="#Sort-Merge-Join" class="headerlink" title="Sort Merge Join"></a>Sort Merge Join</h3><ul>
<li>Sort：先对要join的字段进行排序</li>
<li>Merge: 用两个指针进行匹配，如果数据匹配就输出，因为数据已经排序好了，所以只需要扫描一次就行了</li>
<li>这样的话总IO就是 sort io + merge io, merge io &#x3D; M + N, sort io看具体的排序算法</li>
<li>最好的情况是要join的key本身已经是有序的了，那么只需要merge io &#x3D; M + N,比如有索引，比如查询的时候使用了order by</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sort R,S on join <span class="type">keys</span></span><br><span class="line"><span class="variable">cursorR</span> <span class="operator">=</span> RSorted, cursorS = Ssorted;</span><br><span class="line"><span class="keyword">while</span> (cursorR &amp;&amp; cursorS) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cursorR &gt; cursorS) &#123;</span><br><span class="line">        <span class="comment">// 相当于内层循环指向下一个</span></span><br><span class="line">        cursorS++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cursorR &lt; cursorS) &#123;</span><br><span class="line">        <span class="comment">// 相当于外层循环指向下一个</span></span><br><span class="line">        cursorR++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cursorR == cursorS) &#123;</span><br><span class="line">        <span class="comment">// 输出 &amp;&amp; 内层循环指向下一个</span></span><br><span class="line">        cursorS++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hash-Join"><a href="#Hash-Join" class="headerlink" title="Hash Join"></a>Hash Join</h3><ul>
<li>Build: 先对左表要join的key进行hash，构建一个hash table</li>
<li>probe: 在对右表要join的key进行hash, hash相同的会放入同一个 bucket,也就完成了匹配</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Tuple r: R) &#123;</span><br><span class="line">    insert <span class="title function_">hash</span><span class="params">(r)</span> into hash table ht</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Tuple s: S) &#123;</span><br><span class="line">    insert <span class="title function_">hash</span><span class="params">(s)</span> into hash tbale ht</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Hash Join优化</p>
<ul>
<li>可以添加 <code>布隆过滤器</code> 来优化，这样的话在probe阶段，对右表的key， hash以后先查询布隆过滤器，如果false，就不需要在放入hash table去匹配了</li>
<li>如果true在去hash table里面匹配数据完成输出</li>
</ul>
<p>Grace Hash Join</p>
<ul>
<li>在 hash join中，只构建一个hash table来存储左表数据，右表的hash完成直接匹配</li>
<li>Grace hash join中，构建两个hash table，然后进行 nested loop join</li>
<li>总的IO： 3(M + N),大约0.45s</li>
</ul>
<p>hash 几乎总是好的。<br>排序是好的情况有两种</p>
<ul>
<li>non-uniform数据，排序更好</li>
<li>对于需要排序的数据，比如order by,排序更好</li>
</ul>
<p><img src="/../images/15445031.png" alt="031"></p>
<h2 id="query-exec"><a href="#query-exec" class="headerlink" title="query exec"></a>query exec</h2><p>processing Method</p>
<ul>
<li>Iterator Model: 大多数数据库使用的</li>
<li>Materialization Model：Iterator Model的一个特定版本，用在内存型数据库</li>
<li>Vectorized&#x2F; Batch Model：Iterator Model差不多，要传入一大堆东西， 分析型用的多</li>
</ul>
<p>Iterator Model</p>
<ul>
<li>像java的stream， 流的方式执行</li>
<li>先构建执行树，上层的通过<code>next</code>方法调用下层的方法并接收返回值</li>
</ul>
<p><img src="/../images/15445032.png" alt="032"></p>
<p>Materalization Model</p>
<ul>
<li>去掉了<code>next</code>方法，使用了<code>output</code>方法，一次输出所有数据给上层</li>
</ul>
<p><img src="/../images/15445033.png" alt="033"></p>
<p>Vectorized Model</p>
<ul>
<li>使用<code>next</code>方法，但是一次性返回一堆 tuples, 数量取决于 Buffer pool 大小</li>
<li>使用OLAP，大多数的数仓使用这个</li>
</ul>
<p><img src="/../images/15445034.png" alt="034"></p>
<p>Access Method</p>
<ul>
<li>顺序扫描</li>
<li>索引扫描</li>
<li>多索引扫描</li>
</ul>
<p>顺序扫描的优化</p>
<p><img src="/../images/15445035.png" alt="035"></p>
<p>多索引扫描</p>
<ul>
<li>对多个索引同时扫描</li>
<li>将扫描结果取交集或并集等</li>
<li>例如 <a target="_blank" rel="noopener" href="https://www.ibm.com/docs/en/dspafz/5.1.0?topic=report-multiple-index-scans">DB2 Multi index scan</a>,<a target="_blank" rel="noopener" href="https://www.postgresql.org/message-id/12553.1135634231@sss.pgh.pa.us">PostgreSQL bitmap scan</a>,<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/index-merge-optimization.html">MySQL Index Merge scan</a></li>
</ul>
<p>Zone Maps</p>
<ul>
<li>通过在page上面增加一个元数据，存储min,max,avg,count,sum信息</li>
<li>当查询的时候比如where val &gt; 600,先查询 Zone Maps，如果发现max &lt; 600，那么就不用在扫描这个page了</li>
<li>缺点是插入，更新，删除的时候还需要更新Zone Maps信息，所以适用于 OLAP数据库</li>
</ul>
<p>late materialization</p>
<ul>
<li>已经不需要的字段就不在往上层传了</li>
</ul>
<p>Expression Evaulate</p>
<ul>
<li>先建立where条件的 Expression tree,中间节点是操作符，比如<code>=</code>,<code>&gt;</code>,<code>&lt;</code>,<code>and</code>,<code>or</code>等。子节点是两边的值</li>
<li>对于每个tuple执行这个表达式</li>
<li>好的数据库会对表达式进行优化，比如优化成常量，像where 1 &#x3D; 1优化成 trues</li>
</ul>
<p>Process Models</p>
<ul>
<li>Process per DBMS Worker</li>
<li>Process Model</li>
<li>Thread per DBMS Worker</li>
<li>Embedded DBMS</li>
</ul>
<p>Process per DBMS Worker</p>
<ul>
<li>每个进程是一个worker,负责执行任务</li>
<li>通过<code>共享内存</code>进行buffer pool的通信，要不然每个进程都会有一个buffer pool。</li>
<li>老得数据库大部分使用的这个，因为当时没有统一的线程API,像DB2,oracle,postgraSQL</li>
</ul>
<p>Process Model</p>
<ul>
<li>和 Process per DBMS Worker一样</li>
<li>但是增加了 worker pool，有多个worker进行调度处理</li>
<li>像DB2,postgraSQL（2015）</li>
</ul>
<p>Thread per DBMS Worker</p>
<ul>
<li>一个进程，多个线程执行，由数据库自己控制线程。</li>
<li>现在的数据库几乎都使用这种，像DB2, MSSQL, MySQL, Oracle(2014)</li>
</ul>
<p>scheduling</p>
<ul>
<li>将查询分解为多少个任务？</li>
<li>它使用多少个CPU核心？</li>
<li>哪个CPU执行哪个任务？</li>
<li>任务输出到哪里？</li>
</ul>
<p>Intra query parallelism</p>
<ul>
<li>Intra operator(水平)</li>
<li>Inter operator(垂直)</li>
<li>Bushy(上面两种的组合)</li>
</ul>
<p>Intra operator(水平)</p>
<ul>
<li>通过水平拆分数据，由多个线程执行，比如3个线程，一个线程处理一个page，以此类推</li>
<li>处理完成以后通过<code>exchange operator</code>来进行合并，拆分也是通过它。</li>
</ul>
<p><img src="/../images/15445036.png" alt="036"></p>
<p>Exchange operator</p>
<ul>
<li>Gather:从多个线程的结果合并成一个输出流，PostgreSQL用这个</li>
<li>Repartition: 重新组织多个输入流到多个输出流的数据，像group by，BigQuery用这个</li>
<li>Distribute: 拆分一个输入流到多个输出流</li>
</ul>
<p><img src="/../images/15445037.png" alt="037"></p>
<p>Inter operator(垂直)</p>
<ul>
<li>重叠的操作从一个阶段到下一个阶段的pipeline数据，没有具体化</li>
<li>workers同时执行多个operators从一个查询计划的不同部分</li>
<li>也需要用到exchange operator</li>
<li>Spark,Kafka常用这个</li>
</ul>
<p><img src="/../images/15445038.png" alt="038"></p>
<p>Bushy</p>
<p><img src="/../images/15445039.png" alt="039"></p>
<h2 id="查询计划"><a href="#查询计划" class="headerlink" title="查询计划"></a>查询计划</h2><p>假设有以下sql，其中Emp表有10000个records, 1000个pages, Dept表有500个records, 50个pages</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> ename <span class="keyword">from</span> Emp E <span class="keyword">join</span> Dept D <span class="keyword">on</span> E.did <span class="operator">=</span> D.did <span class="keyword">where</span> D.dname <span class="operator">=</span> <span class="string">&#x27;Toy&#x27;</span></span><br></pre></td></tr></table></figure>

<p>数据库将构建以下关系代数的树</p>
<p><img src="/../images/15445040.png" alt="040"></p>
<p>按照这个关系代数的树来执行的话，总共需要 2M的IO</p>
<p><img src="/../images/15445041.png" alt="041"></p>
<p>接下来将笛卡尔积的代数换成join的代数，就算使用Nested Loop Join，也能获得54K的IO</p>
<p><img src="/../images/15445042.png" alt="042"></p>
<p>如果将Join算法替换成<code>Sort-Merge Join</code>，则可以将IO降低到<code>7159</code></p>
<p><img src="/../images/15445043.png" alt="043"></p>
<p>这个算法是基于<code>Materialization Model</code>的，所以每次还要写入文件，再读取。如果优化成<code>Veectorization Model</code>，减少重复的写入和读取，可以达到3151的IO</p>
<p><img src="/../images/15445044.png" alt="044"></p>
<p>wraning:</p>
<ul>
<li>这非常难！</li>
<li>Andy对这部分知道的是最少得</li>
<li>如果搞好了，很挣钱</li>
</ul>
<p>查询结构</p>
<ul>
<li>SQL rewrite (可选)：重写sql语句，对sql语句进行优化</li>
<li>Parser: 解析SQL查询，构建语法树</li>
<li>Binder: 查询catalog信息，并将表名等信息替换成内部标识，生成<code>逻辑查询计划</code></li>
<li>Tree rewrite (可选)：重写树结构，包括关系代数等</li>
<li>Optimizer: 调用成本模型，预估成本，选择合适的执行计划，生成<code>物理执行计划</code></li>
</ul>
<p><img src="/../images/15445045.png" alt="045"></p>
<blockquote>
<p>生成物理执行计划的时候，可能有多个执行路径，在短时间内可能无法从全部的路径中选出最佳的。</p>
</blockquote>
<h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><blockquote>
<p>查询优化是很难的，有些数据库的查询优化做的很差，DB2曾引入机器学习做查询优化，效果并不好，被吐糟安装DB2要做的第一件事就是关掉这个功能</p>
</blockquote>
<p>查询优化</p>
<ul>
<li>静态规则&#x2F;条件触发<ul>
<li>根据静态的规则，或者触发了某一个条件来重写查询，移除低效率的东西</li>
<li>需要检查catalog查看信息，而不需要去检查数据</li>
</ul>
</li>
<li>成本原则<ul>
<li>使用模型预估查询成本</li>
<li>估计出多个查询计划，选择其中成本最低的一个</li>
</ul>
</li>
</ul>
<h4 id="静态规则-x2F-条件触发"><a href="#静态规则-x2F-条件触发" class="headerlink" title="静态规则&#x2F;条件触发"></a>静态规则&#x2F;条件触发</h4><p>关系代数等价</p>
<ul>
<li>一个查询语句可以用多个关系代数来表示</li>
<li>可以选择其中代价更小的那个关系代数</li>
<li>这个被叫做 <code>query rewriting</code> 属于上面的 <code>Tree rewrite</code>阶段</li>
<li>比如用join代替笛卡尔积</li>
</ul>
<p>predicate pushdown</p>
<ul>
<li>比如select a.name,b.code from a join b where a.name &#x3D; ‘abc’</li>
<li>可以先join在where，也可以先where 再 join</li>
<li>显然先where更好，把where放到join的下层执行</li>
<li>还有可以再where之后只获取需要的列，其余不需要的列就不再往上层传递了</li>
</ul>
<p>projection pushdown</p>
<ul>
<li>比如select a.name,b.code from a join b on a.id &#x3D; b.aid</li>
<li>可以在扫描a表的时候进行投影，获取id和name传到join节点处理，而不是全部字段传过去，b表同样</li>
</ul>
<p><img src="/../images/15445046.png" alt="046"></p>
<p>语句重写</p>
<ul>
<li>比如select * from a where 1 &#x3D; 0; 那么不会返回任何数据。</li>
<li>select * from a where 1 &#x3D; 1 会返回所有数据，重写成select * from a</li>
</ul>
<h4 id="成本原则"><a href="#成本原则" class="headerlink" title="成本原则"></a>成本原则</h4><blockquote>
<p>mongoDB没有使用成本预测模型，而是执行所有的查询计划，哪个最先返回就用哪个</p>
</blockquote>
<p>最初是IBM提出的。枚举不同的查询计划，并估算他们的成本,在检查完所有的计划或者超时后，选择其中成本最低的一个。</p>
<ul>
<li>single relation</li>
<li>multiple relation </li>
<li>nested sub-queries</li>
</ul>
<p>single relation</p>
<ul>
<li>单表是比较简单的，比如根据后面的statistics决定走哪个索引更好</li>
<li>可以顺序扫描 </li>
<li>可以二分搜索</li>
<li>可以走索引</li>
</ul>
<p>对于单表查询来说，一般会使用<code>启发式规则</code>，他来判断哪些where条件能筛掉更多的数据，就先进行哪个where。</p>
<p><code>sargable (search argument able)</code>：他会比较不同的索引，比如这个索引合适，那么就会使用它，比如id&#x3D;1的，那么就会使用主键索引</p>
<p>multiple relation </p>
<ul>
<li>有两种方法，第一种是自底向上</li>
<li>还有是自顶向下</li>
</ul>
<h5 id="system-R-优化"><a href="#system-R-优化" class="headerlink" title="system R 优化"></a>system R 优化</h5><ul>
<li>这是一个自底向上的multiple relation</li>
<li>将查询分成block并为每个block生成逻辑运算</li>
<li>为每个逻辑运算生成物理运算并实现它</li>
<li>组合所有的join算法和访问路径</li>
<li>生成一个left deep的树</li>
</ul>
<p>比如有下面的SQL,ALBUM.NAME 字段有索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ARTIST.NAME</span><br><span class="line"> <span class="keyword">FROM</span> ARTIST, APPEARS, ALBUM</span><br><span class="line"><span class="keyword">WHERE</span> ARTIST.ID<span class="operator">=</span>APPEARS.ARTIST_ID</span><br><span class="line"> <span class="keyword">AND</span> APPEARS.ALBUM_ID<span class="operator">=</span>ALBUM.ID</span><br><span class="line"> <span class="keyword">AND</span> ALBUM.NAME<span class="operator">=</span>&quot;Andy&#x27;s OG Remix&quot;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ARTIST.ID</span><br></pre></td></tr></table></figure>

<p>进行第一步，可以得到三个表的扫描方法</p>
<ul>
<li>ARTIST：顺序扫描</li>
<li>APPEARS：顺序扫描</li>
<li>ALBUM：索引扫描</li>
</ul>
<p>接下来组合不同的join算法，我们可以先连接ARTIST和APPEARS表，也可以先连接APPEARS和ALBUM表，或者ALBUM和ARTIST表，并且可以使用hash join 或者 merge join</p>
<p><img src="/../images/15445047.png" alt="047"></p>
<p>最终为每个可能选择成本最低的join</p>
<p><img src="/../images/15445048.png" alt="048"></p>
<p>接下来为每个可能去join其他表，来完成最终的三个表join，这个时候还是有hash join和merge join,选择最适合的join方法，就会产生三个路径</p>
<p><img src="/../images/15445049.png" alt="049"></p>
<p>在从这三个中选择出成本最低的一个路径作为最终的路径</p>
<p><img src="/../images/15445050.png" alt="050"></p>
<h5 id="自顶向下优化"><a href="#自顶向下优化" class="headerlink" title="自顶向下优化"></a>自顶向下优化</h5><p>首先生成逻辑节点，最底下是三个表，最上面是三个表join并且order by，中间是两个表join</p>
<p><img src="/../images/15445051.png" alt="051"></p>
<p>接下来先生成三个表的一个物理操作，因为需要order by，所以可以认为merge join更好。</p>
<p><img src="/../images/15445052.png" alt="052"></p>
<p>接下来两个表的物理操作，可以选择hash join或这merge join，因为要排序，可以认为merge join更好</p>
<p><img src="/../images/15445053.png" alt="053"></p>
<p>最后在探测其他的路径，比如最上层还可能有hash join，或者先hash join，在排序，但是这些都没有merge join的成本低，所以在探测到以后就可以Pass掉了</p>
<p><img src="/../images/15445054.png" alt="054"></p>
<h5 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h5><ul>
<li>重写去掉and&#x2F;or来把他们变成同一个层级</li>
</ul>
<p>比如以下SQL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> sailors <span class="keyword">AS</span> S</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line"> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> reserves <span class="keyword">AS</span> R</span><br><span class="line"> <span class="keyword">WHERE</span> S.sid <span class="operator">=</span> R.sid</span><br><span class="line"> <span class="keyword">AND</span> R.day <span class="operator">=</span> <span class="string">&#x27;2022-10-25&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>可以被重写为</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"> <span class="keyword">FROM</span> sailors <span class="keyword">AS</span> S, reserves <span class="keyword">AS</span> R</span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="operator">=</span> R.sid</span><br><span class="line"> <span class="keyword">AND</span> R.day <span class="operator">=</span> <span class="string">&#x27;2022-10-25&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>分解子查询并将结果存储在临时表中，比如使用CTE，避免每个tuple都需要执行子查询</li>
</ul>
<p>比如下面的SQL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sid, <span class="built_in">MIN</span>(R.day)</span><br><span class="line"> <span class="keyword">FROM</span> sailors S, reserves R, boats B</span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="operator">=</span> R.sid</span><br><span class="line"> <span class="keyword">AND</span> R.bid <span class="operator">=</span> B.bid</span><br><span class="line"> <span class="keyword">AND</span> B.color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span></span><br><span class="line"> <span class="keyword">AND</span> S.rating <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(S2.rating)</span><br><span class="line"> <span class="keyword">FROM</span> sailors S2)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> S.sid</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>可以将子查询提取出来变成</p>
<p><img src="/../images/15445055.png" alt="055"></p>
<p>catalog会记录一些成本信息，不同的DBMS有不同的更新策略，也可以手动更新,这被叫做<code>statistics</code></p>
<ul>
<li>PostgreSQL&#x2F;SQLite : ANALYZE</li>
<li>Oracle&#x2F; Mysql: ANALYZE TABLE</li>
<li>SQL server: UPDATE STATISTICS</li>
<li>DB2: RUNSTATS</li>
</ul>
<p>statistics: 维护着下面的信息</p>
<ul>
<li>counter: 表中的tuple数量</li>
<li>V(A,R): R表中的A字段的去重数量</li>
<li>SC(A,R): <code>选择基数SC</code> 是 counter &#x2F; V(A,R) 的值</li>
</ul>
<p>选择率：有了上面的数据，就可以计算出要查询的数据的分布比例了。这里就是求概率。</p>
<ul>
<li>比如查询主键 id &#x3D; 1的数据，当前有数据5条，那么counter &#x3D; 5,V(A,R) &#x3D; 5, SC(A,R) &#x3D; 1, 选择率 &#x3D; 1&#x2F;5</li>
<li>比如范围查询 id &gt; 2的数据，当前有数据5条，那么counter &#x3D; 5, V(A,R) &#x3D; 5, SC(A,R) &#x3D; 1, 选择率 &#x3D; (Max - A) &#x2F; (Max - Min) &#x3D; 5-2&#x2F;5-1 &#x3D; 3&#x2F;4,显然这事错误的预测，但是数据库就是这样</li>
<li>比如not查询 id &lt;&gt; 1的数据，当前有数据5条，那么选择率 &#x3D; 1 - (id &#x3D; 1的选择率) &#x3D; 1 - 1&#x2F;5 &#x3D; 4&#x2F;5</li>
<li>比如多个条件 and, 那么取交集，也就是 两个选择率 相乘 &#x3D; sel(AB),这种计算同样不太准确，比如有一个<code>汽车表</code>，有<code>make</code>字段代表生产商，<code>model</code>代表型号，我们知道model &#x3D; “帕萨特”，make 一定是 <code>大众</code>。按照我们的算法 假设make 有10个，选择率就是1&#x2F;10, model 100个，选择率就是 1&#x2F;100,总的选择率就是 1&#x2F;1000,但是帕萨特一定是大众的，所以真实选择率其实是1&#x2F;100。有些数据库可以设置字段关联来解决这个问题，比如oracle等，mysql和postgresql不行。</li>
<li>比如多个条件 or, 那么取并集，也就是两个选择率相加 &#x3D; sel(A) + sel(B) - sel(AB)</li>
</ul>
<p><img src="/../images/15445056.png" alt="056"></p>
<p>直方图的存储，由于存储所有信息的直方图可能很占空间，可以选择稀疏存储，合并一些数据，这样会牺牲一些准确率，但是节省空间。</p>
<p>除了直方图以外，有些数据库还会使用抽样检查，花费一些时间进行抽样，然后根据样本来进行预测选择率。</p>
<h2 id="并发控制原理"><a href="#并发控制原理" class="headerlink" title="并发控制原理"></a>并发控制原理</h2><p>原子性：事务的每个操作都是原子的，要么全成功，要么全失败，通过undo redo log实现<br>一致性：保证事务执行前和执行后是一致的，中间可以临时不一致，但最终要一致。通过raft等共识协议实现<br>隔离性：保证事务的隔离性，每个事务都是独立运行的，并发的时候通过<code>并发控制协议</code>来保证交错执行，通过latch保证正确性。通过并发控制实现<br>持久性：事务提交后数据持久保存了，通过undo redo log实现</p>
<p>当转账的时候，事务被突然的中止，或者断电，该怎么做？</p>
<ul>
<li>Logging</li>
<li>shadow paging</li>
</ul>
<p>Logging</p>
<ul>
<li>记录所有的操作，使得事务中止或者故障后可以undo 操作。</li>
<li>在磁盘和内存中维护 undo records</li>
<li>就像飞机上的黑盒子一样</li>
</ul>
<p>shadow paging</p>
<ul>
<li>将数据复制到一个副本中进行事务更新，如果成功了，将副本作为新的数据库，如果没成功也不影响当前的数据库</li>
<li>起源于System R</li>
<li>CouchDB和LMDB使用这个方法</li>
</ul>
<p>并发控制协议：</p>
<ul>
<li>悲观的：两阶段提交</li>
<li>乐观的：时间戳</li>
</ul>
<p>顺序执行：</p>
<ul>
<li>顺序执行每个事务，保证事务的最终一致性</li>
</ul>
<p>交错执行：</p>
<ul>
<li>如果能达到顺序执行的结果，那么就是正确的执行 schedle</li>
</ul>
<p>假设a,b账户都有1000，那么经过t1事务和t2事务执行以后，总的结果应该不变，对于数据库来说，哪个事务先执行都可以，如果想控制事务执行顺序，应该由应用层控制。</p>
<p><img src="/../images/15445057.png" alt="057"></p>
<p>如果交错执行的结果和顺序执行的结果不一样，就是错误的</p>
<p><img src="/../images/15445058.png" alt="058"></p>
<p>总共会出现三种冲突</p>
<ul>
<li>读写冲突</li>
<li>写读冲突</li>
<li>写写冲突</li>
</ul>
<p>读写冲突（不可重复读）：当读第一次的时候，值被其他事务改变了，再次读的时候，值就和第一次读的时候不一样了</p>
<p><img src="/../images/15445059.png" alt="059"></p>
<p>写读冲突（读未提交或脏读）：A事务读取后，修改了值，B事务读取了修改的值，然后又修改了值，B事务提交后，A事务中止，回滚。</p>
<p><img src="/../images/15445060.png" alt="060"></p>
<p>写写冲突（覆盖数据）：两个事务同时写入一个值，有一个值会被覆盖掉。</p>
<p><img src="/../images/15445061.png" alt="061"></p>
<p>冲突可串行化,大多数数据库使用的，还有个视图可串行化，没数据库实现</p>
<ul>
<li>通过比较两个操作是否冲突，来修改顺序</li>
<li>使用依赖图（优先图）来判断依赖是否出现环</li>
</ul>
<p>假设事务t1写入了A数据，事务t2同时读取A数据，那么事务t2就依赖了事务t1</p>
<p><img src="/../images/15445062.png" alt="062"></p>
<p>假设事务t2又写入了B，事务t1要读取B，那么事务t1就依赖了事务t2，这个时候就产生了循环依赖，就跟死锁一样，所以这个时候需要回滚一个事务</p>
<p><img src="/../images/15445063.png" alt="063"></p>
<h2 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h2><p>事务A先获取锁，事务B等待锁，事务A执行完成以后，释放锁，事务B才能拿到锁。</p>
<p>共享锁，读锁，S-LOCK<br>独享锁，写锁，X-LOCK</p>
<p><img src="/../images/15445064.png" alt="064"></p>
<p>如上图所示，这样还是会出现不可重复读的问题，两阶段锁可以解决这个问题，两阶段锁是第一个正确的<code>并发控制协议</code></p>
<p>两阶段锁,遵循这个方法，使得事务是<code>冲突可串行化</code>的，但是会有级联事务中止（cascading aborts），可以通过强严格两阶段锁解决这个问题。</p>
<ul>
<li>第一阶段Growing:每个事务从lock manager获取锁，事务释放锁以后进入第二阶段shrinking</li>
<li>第二阶段Shrinking:事务释放锁以后不能获取新锁,只能释放锁或者提交事务释放持有的所有锁</li>
</ul>
<p>从生命周期来看，第一阶段是上升，第二阶段只会下降，不会再次上升，下图是正确的生命周期</p>
<p><img src="/../images/15445065.png" alt="065"></p>
<p>下图是错误的生命周期</p>
<p><img src="/../images/15445066.png" alt="066"></p>
<p>cascading aborts，如果事务t1中止回滚了，那么事务t2就发生了<code>脏读</code>，所以也需要回滚重来</p>
<p><img src="/../images/15445067.png" alt="067"></p>
<h3 id="严格两阶段锁"><a href="#严格两阶段锁" class="headerlink" title="严格两阶段锁"></a>严格两阶段锁</h3><p>在提交事务的时候才释放锁。可以解决脏读的问题。</p>
<p>非两阶段锁执行如下：</p>
<p><img src="/../images/15445068.png" alt="067"></p>
<p>两阶段锁执行如下：</p>
<p><img src="/../images/15445069.png" alt="067"></p>
<p>严格两阶段锁执行如下：</p>
<p><img src="/../images/15445070.png" alt="070"></p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁检测：通过使用<code>wait-for</code>图来检测依赖关系，如果有环就是死锁</p>
<p>检测的频率可以通过参数调整，这个需要权衡</p>
<p>victim选择，选择出回滚哪个事务，这也是企业级系统和开源系统的区别</p>
<ul>
<li>可以根据时间戳，选择年龄小的那个，认为刚加入的回滚成本小</li>
<li>根据持有锁的数量，选择持有锁少的那个回滚</li>
<li>根据已完成的工作量，选择查询数量少的那个回滚，可以认为回滚一个查询的成本比几十个查询的成本小</li>
<li>根据剩余的工作量</li>
<li>根据回滚的次数，这个事务老回滚，可能同情它不让它回滚，以避免“饥饿”</li>
</ul>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>根据时间戳来选择</p>
<ul>
<li>wait die: 老的等待新的，如果事务t1先开始，事务t2后开始，t2先获取了锁a, 然后t1要获取锁a，那么就等待，因为老的要等待新的，因为t1是老的，如果t1先获取锁a，t2新的后获取那么t2abort</li>
<li>wound die: 新的等待老的，如果事务t1先开始，事务t2后开始，t2先获取了锁a,然后t1要获取锁a,那么t2就abort，给老的让路，因为老的优先级高，如果t1先获取锁a，t2新的后获取锁a，那么就等待，因为新的等待老的</li>
</ul>
<p><img src="/../images/15445071.png" alt="071"></p>
<p>数据库锁层次</p>
<p><img src="/../images/15445072.png" alt="072"></p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>意向共享锁IS</p>
<ul>
<li>使用共享锁在较低级别锁定，共享锁粒度更细</li>
</ul>
<p>意向排它锁IX</p>
<ul>
<li>使用排它锁在较低级别锁定，排它锁粒度更细</li>
</ul>
<p>共享意向排它锁</p>
<ul>
<li>高级别用共享锁，低级别用排它锁</li>
</ul>
<p><img src="/../images/15445073.png" alt="073"></p>
<p>假设t1事务要查询一个tuple,那么可以在table上一个IS锁，然后在具体的tuple上一个S锁，接下来t2事务要更新一个tuple，发现表上是IS锁，那么根据规则，可以在table上在加一个IX锁，然后在要更新的tuple上一个X锁，如果恰好是同一个tuple，那么就等待S锁释放，如果不是同一个，那么就并发执行成功</p>
<p><img src="/../images/15445074.png" alt="073"></p>
<p>假设t1事务要扫描所有tuple来找到一个tuple去更新，那么table上一个SIX锁，然后扫描到一个tuple，就给一个tuple上X锁，扫描完就释放X锁，接下来t2事务要读取一个tuple，发现表上是SIX锁，那么根据规则，可以在table上一个IS锁，然后在要查询的tuple上S锁，如果刚巧tuple上有X锁，那么就等待t1事务释放。</p>
<p><img src="/../images/15445075.png" alt="073"></p>
<h2 id="时间戳并发控制"><a href="#时间戳并发控制" class="headerlink" title="时间戳并发控制"></a>时间戳并发控制</h2><p>两阶段锁是一种<code>悲观</code>的协议，所有人都会上锁，会争抢，时间戳是一种不依赖锁的<code>乐观</code>的协议。</p>
<p>Ti代表事务i得一个时间戳，Tj是j的，如果Ti &lt; Tj，那么i得事务会在j之前提交。</p>
<p>时间戳的两个特性</p>
<ul>
<li>唯一性，每个时间戳必须是唯一的</li>
<li>单调递增性，时间戳必须是增加的</li>
</ul>
<h3 id="基本时间戳协议"><a href="#基本时间戳协议" class="headerlink" title="基本时间戳协议"></a>基本时间戳协议</h3><p>每个tuple需要维护两个时间戳，一个<code>读时间戳</code>，一个<code>写时间戳</code>。</p>
<h4 id="读"><a href="#读" class="headerlink" title="读"></a>读</h4><p>在读取的时候要保证，当前时间戳 &gt; 写时间戳，也就是读取的是最新的值，未来不会被改变的值。<br>如果 当前时间戳 &lt; 写时间戳，那么重启事务，分配一个新的时间戳，再试一次。<br>如果成功取到tuple，那么需要更新<code>读时间戳</code>，使用自己的时间戳和原来的时间戳中大的那个去更新。</p>
<h4 id="写"><a href="#写" class="headerlink" title="写"></a>写</h4><p>写入的时候要保证，当前时间戳 &gt; 读时间戳 并且 &gt; 写时间戳<br>成功写入的时候要更新写时间戳，使用自己的时间戳和原来的时间戳中大的那个去更新。</p>
<h4 id="托马斯写入优化"><a href="#托马斯写入优化" class="headerlink" title="托马斯写入优化"></a>托马斯写入优化</h4><p>在写入的时候，如果当前时间戳 &lt; 写入时间戳，本来应该<code>中止</code>的事务，可以继续执行，但是写入操作不写入数据库，因为数据库的数据是更新的，而是写入本地副本，方便这个事务后面使用。</p>
<h3 id="乐观并发控制"><a href="#乐观并发控制" class="headerlink" title="乐观并发控制"></a>乐观并发控制</h3><p>另外一个是<code>乐观并发控制</code>。为每一个事务创建一个私有空间，他的所有操作都是先对私有空间的副本操作，最后执行到数据库里面的时候需要对比一下，是否能执行。如果不冲突，就可以执行。</p>
<p>三个阶段</p>
<ul>
<li>read phase(work phase): 执行事务的操作，操作都在私有空间执行。</li>
<li>validation phase: 提交事务的时候验证事务的有效性，是否冲突等，确实是否可以提交。在这个阶段才会分配时间戳。如果在之前需要写入时间戳，先暂时写入无穷大。并检测是否和其他事务的时间戳冲突，其他事务包括以前的所有事务和正在执行的事务</li>
<li>write phase: 如果校验成功，将时间戳写入W-TS列，将修改写入全局工作区，否则abort事务，这是原子的。</li>
</ul>
<p>假设事务t1读取tuple A,将从全局工作区复制A到私有工作区</p>
<p><img src="/../images/15445076.png" alt="076"></p>
<p>接下来事务t2读取tuple A，也将从全局工作区复制A到私有工作区</p>
<p><img src="/../images/15445077.png" alt="077"></p>
<p>接下来事务t2进入validation阶段，然后分配时间戳为1，接下来进入写入阶段，什么也不做</p>
<p><img src="/../images/15445078.png" alt="077"></p>
<p>事务t1修改tuple A，然后再次读取tuple A，可以重复读取，因为读取私有工作区的tuple A</p>
<p><img src="/../images/15445079.png" alt="077"></p>
<p>事务t1进入validation阶段，分配时间戳为2，因为1已经分配给t2事务了，写入阶段将私有工作区的tuple A，更新到全局工作区</p>
<p><img src="/../images/15445080.png" alt="077"></p>
<p>数据库拥有全局视野，在validation phase阶段，是单线程比较事务是否可以执行，会有一个大的latch上锁</p>
<ul>
<li>backward validation: 和并发执行中更早已经提交的事务进行比较</li>
<li>forward validation: 和并发执行中后面没有提交的事务进行比较</li>
</ul>
<h4 id="forward-validation"><a href="#forward-validation" class="headerlink" title="forward validation"></a>forward validation</h4><p>如果事务t1 &lt; t2,t1的写阶段在t2的读阶段之前，则没有任何冲突发生。</p>
<p>如果事务t1 &lt; t2,但是t1的valition阶段在t2的validation阶段之前，则冲突，因为t1已经更改了tuple A ,而t2读取的是W-TS&#x3D;0的tuple A，如果t1事务的W-TS是1，t2是2,那么t2读取的应该是W-TS&#x3D;1的tuple A才对</p>
<p><img src="/../images/15445081.png" alt="081"></p>
<p>如果t2的validation阶段在前就没问题，因为t2分配W-TS&#x3D;1，t1是2</p>
<p><img src="/../images/15445082.png" alt="082"></p>
<p>如果事务t1 &lt; t2 ，t1的validation阶段在t2的前面，但是t1已经写入全局工作区以后，t2在读取这个tuple，就没有问题</p>
<p><img src="/../images/15445083.png" alt="083"></p>
<p>forward validation和没有提交的事务进行比较<br><img src="/../images/15445084.png" alt="084"></p>
<p>backward 和已经提交的事务比较</p>
<p><img src="/../images/15445085.png" alt="085"></p>
<h3 id="partition-based-时间戳协议"><a href="#partition-based-时间戳协议" class="headerlink" title="partition based 时间戳协议"></a>partition based 时间戳协议</h3><p>按照时间戳水平分区，在同一个区里面，按照时间戳顺序执行，就不需要latch了。速度会很快。</p>
<p>在不同区执行的话，就很复杂了。</p>
<p>每个分区都是单线程执行的。这样不需要获取latch。</p>
<h3 id="幻读问题"><a href="#幻读问题" class="headerlink" title="幻读问题"></a>幻读问题</h3><p>假设事务t1读取了table a的count(<em>)是99,事务t2插入了一条数据，事务t1再次读取count(</em>)就变成了100，因为t1只能lock已经存在的数据，要插入的数据没办法lock</p>
<p><img src="/../images/15445086.png" alt="086"></p>
<p>解决幻读的三个方法</p>
<ul>
<li>重新执行扫描：提交后重新执行扫描看结果是否一致，不一致就发生了幻读，少见</li>
<li>predicate locking：System R提出的方案，锁定where语句，进行比较，很难实现，非常少见，duckDB,Hyper等实现了</li>
<li>Index Locking: 索引锁定，常见</li>
</ul>
<h4 id="Index-Locking"><a href="#Index-Locking" class="headerlink" title="Index Locking"></a>Index Locking</h4><ul>
<li>key-value locks</li>
<li>Gap locks (间隙锁)</li>
<li>Key-Range locks</li>
<li>Hierarchical locks</li>
</ul>
<p>key-value locks只能锁定键值，需要一个virtual key来锁定不存在的key</p>
<p><img src="/../images/15445087.png" alt="087"></p>
<p>间隙锁，锁定键值和下一个键值之间的间隙</p>
<p><img src="/../images/15445088.png" alt="088"></p>
<p>key-Range locks，锁定键值以及和下一个键值之间的间隙</p>
<p><img src="/../images/15445089.png" alt="089"></p>
<p>Hierarchical locks使用IX,IS等意向锁</p>
<p>不同隔离级别对应的问题，最受欢迎的隔离级别是读已提交，mysql默认是可重复读</p>
<p><img src="/../images/15445090.png" alt="090"></p>
<h2 id="多版本并发控制（MVCC）"><a href="#多版本并发控制（MVCC）" class="headerlink" title="多版本并发控制（MVCC）"></a>多版本并发控制（MVCC）</h2><p>MVCC(Multiple Version Concurrency Contronl)最早在1978年由一位MIT的Phd学生提出。在1980年被数据库实现。</p>
<p>firefox 最开始叫 phoenix， 但是因为和其他的重名了需要改名字，然后改成了firebird, firebird是个最早开源的数据库，它使用了MVCC,所以火狐还要改名，就成了firefox。</p>
<ul>
<li>Writers don’t block readers</li>
<li>Readers don’t block wirters</li>
</ul>
<p>只读事务读取快照，不需要锁。MVCC天然支持快照隔离，如果没有gc，支持time travel query，就是可以查询很久以前的更改</p>
<p>版本维护有3个元数据</p>
<ul>
<li>version 版本号 从0开始，递增</li>
<li>begin 开始的时间戳</li>
<li>end 结束的时间戳，默认是无穷大，当写入以后要更新上一个版本的end</li>
</ul>
<p><img src="/../images/15445097.png" alt="090"></p>
<p>还要维护一个事务状态表</p>
<ul>
<li>txnid: 比如事务t1,t2标识</li>
<li>timestamp: 时间戳，如OCC那样</li>
<li>status: 活动中，已提交等</li>
</ul>
<p><img src="/../images/15445098.png" alt="090"></p>
<p>假设事务t1读取A0的数据，然后事务t2写入A1数据，然后更新A0的end-ts&#x3D;2，事务t1再次读取的时候还能看到A0</p>
<p><img src="/../images/15445099.png" alt="090"></p>
<p>假设事务t1读取A0的数据，然后写入A1的数据，事务t2读取A0的数据，写入A2的数据，这个时候t2会阻塞，因为t1持有A的锁，当t1事务commit后，释放锁，事务t2才能继续写入A2的数据</p>
<p><img src="/../images/15445100.png" alt="100"></p>
<p>当事务启动的时候，会看到启动时数据库里的一致的快照</p>
<ul>
<li>没有来自未提交的事务的撕裂写入</li>
<li>如果两个事务更新同一个tuple，第一个写入将获胜</li>
</ul>
<p>快照隔离收到写入偏差异常(Write Skew Anomaly)的影响。</p>
<p>写入偏差异常，假设当前有2个黑球，2个白球，事务t1要将白球更新成黑球，事务t2要将黑球更新成白球，这个时候事务t1读取到2个白球，只将这个两个白球更新成黑球了，而事务t2读取了2个黑球，只把这2个黑球更新成白球了，最终结果还是2黑2白</p>
<p><img src="/../images/15445101.png" alt="100"></p>
<p>但是顺序执行的话结果应该是全白或全黑。</p>
<p><img src="/../images/15445102.png" alt="100"></p>
<p>并发控制协议</p>
<ul>
<li>timestamp ordering:分配一个确定顺序的时间戳</li>
<li>OCC:乐观并发控制</li>
<li>两阶段锁</li>
</ul>
<h3 id="版本存储"><a href="#版本存储" class="headerlink" title="版本存储"></a>版本存储</h3><p>版本存储：为每个逻辑tuple创建一个链表，每个事务通过指针遍历链表获取对应的版本。索引指针指向链表的头节点。</p>
<ul>
<li>append only storage: 复制一个tuple,更新数据，放到后面的节点作为tuple的新版本。</li>
<li>time travel storage: master version表中放最新版本的数据，老版本的数据放在 time travel 表中。master version表维护指向time travel表数据的指针。</li>
<li>Delta Storage: 最佳方案，只维护对前一个版本数据的修改，不直接维护所有副本。</li>
</ul>
<h4 id="append-only-storage"><a href="#append-only-storage" class="headerlink" title="append only storage"></a>append only storage</h4><p>要么最新到最旧的连接，要么最旧到最新的连接，全都放在一个工作空间中，然后用指针连一起</p>
<p><img src="/../images/15445091.png" alt="090"></p>
<h4 id="time-travel-storage"><a href="#time-travel-storage" class="headerlink" title="time travel storage"></a>time travel storage</h4><p>这个是两个空间来存储，一个main table存储最新的，一个time travel table存储所有旧的，像Sql server这种最初没有设计MVCC的数据库，为了兼容使用了这种方法。</p>
<p><img src="/../images/15445092.png" alt="090"></p>
<h4 id="Delta-storage"><a href="#Delta-storage" class="headerlink" title="Delta storage"></a>Delta storage</h4><p>也是两个空间存储，不同的是旧空间只存储修改的列的值</p>
<p><img src="/../images/15445093.png" alt="090"></p>
<h3 id="garbage-collection"><a href="#garbage-collection" class="headerlink" title="garbage collection"></a>garbage collection</h3><p>garbage collection(垃圾回收)</p>
<ul>
<li>tuple level：通过比较时间戳来确定哪些版本已经不用了，可以进行回收了。</li>
<li>transaction level：在事务提交的时候进行对比旧版本的数据是否可以删除</li>
</ul>
<h4 id="tuple-level-gc"><a href="#tuple-level-gc" class="headerlink" title="tuple level gc"></a>tuple level gc</h4><h5 id="vacuum"><a href="#vacuum" class="headerlink" title="vacuum"></a>vacuum</h5><p>后台线程的方式运行，每隔一段时间去扫描，还可以通过bit map来提升速度</p>
<p>假设现在正在运行的事务有两个，最低时间戳是12，那么所有end-ts低于12的都可以被gc，数据库基本都用的这个</p>
<p><img src="/../images/15445094.png" alt="090"></p>
<h5 id="cooperative-cleaning"><a href="#cooperative-cleaning" class="headerlink" title="cooperative cleaning"></a>cooperative cleaning</h5><p>当查询某个tuple的时候，进行扫描这个tuple的旧版本，从而gc，缺点是如果这个tuple一直不被访问，那么就一直不gc，很罕见</p>
<p><img src="/../images/15445095.png" alt="090"></p>
<h4 id="transaction-level-gc"><a href="#transaction-level-gc" class="headerlink" title="transaction level gc"></a>transaction level gc</h4><p>在事务提交的时候进行对比旧版本的数据是否可以删除</p>
<p><img src="/../images/15445096.png" alt="090"></p>
<h3 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h3><p>索引管理</p>
<ul>
<li>逻辑指针：通过中间表转化指针和物理地址，二级索引指向主键索引。</li>
<li>物理指针：直接记录指针</li>
</ul>
<h4 id="物理指针"><a href="#物理指针" class="headerlink" title="物理指针"></a>物理指针</h4><p>所有的索引都记录指针，缺点是更新的时候所有索引的指针都要更新</p>
<p><img src="/../images/15445103.png" alt="103"></p>
<h4 id="逻辑指针"><a href="#逻辑指针" class="headerlink" title="逻辑指针"></a>逻辑指针</h4><p>二级索引都记录主键，只有主键索引记录指针，mysql就这样的，这种方式更好</p>
<p><img src="/../images/15445104.png" alt="104"></p>
<h4 id="重复key问题"><a href="#重复key问题" class="headerlink" title="重复key问题"></a>重复key问题</h4><p>如果索引不是唯一索引，可以有多个key的话，假设事务t1读取A1，没问题</p>
<p>假设事务t2更新了A1，又删除了A1，那么数据如图所示A1老版本指向新版本，但是新版本是被删除的<br><img src="/../images/15445105.png" alt="104"></p>
<p>假设事务t3插入了一条A1数据，那么索引就指向两个A1数据</p>
<p><img src="/../images/15445106.png" alt="104"></p>
<p>MySQL使用两阶段锁，版本存储使用Delta Storage，垃圾回收是tuple level Vacuum,索引管理是逻辑指针。Mysql更快。<br>PostgreSQL使用两阶段锁，版本存储使用append only storage, 垃圾回收使用tuple level Vacuum，索引管理是物理指针。</p>
<p>MVCC实现</p>
<p><img src="/../images/15445107.png" alt="104"></p>
<h2 id="Logging-Schemes"><a href="#Logging-Schemes" class="headerlink" title="Logging Schemes"></a>Logging Schemes</h2><p>在数据库运行时，还没有把数据写入磁盘的时候发生故障，这个时候需要恢复数据。</p>
<h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><p>主要是两件事</p>
<ul>
<li>收集日志信息，以方便恢复</li>
<li>根据日志信息进行恢复</li>
</ul>
<p>故障类型</p>
<ul>
<li>事务故障</li>
<li>系统故障</li>
</ul>
<h3 id="UNDO-撤销-and-REDO-重做"><a href="#UNDO-撤销-and-REDO-重做" class="headerlink" title="UNDO(撤销) and REDO(重做)"></a>UNDO(撤销) and REDO(重做)</h3><p>Undo:维护一些信息，可以恢复事务对数据库中某个对象所做的任何修改。<br>Redo: 维护一些信息，可以重新执行某个事务对数据库中的某个对象所做的修改。可以重新执行一个已经提交的事务的修改。</p>
<h3 id="buffer-pool-策略"><a href="#buffer-pool-策略" class="headerlink" title="buffer pool 策略"></a>buffer pool 策略</h3><p>两个策略</p>
<ul>
<li>steal:是否允许一个已提交事务写入磁盘的时候把这个page里面的未提交事务的修改也写入磁盘。</li>
<li>force：提交事务的时候，是否允许事务的所有更新写入磁盘</li>
</ul>
<p>not steal + force</p>
<ul>
<li>优点：不需要恢复，因为只写入磁盘提交的事务更新的内容。磁盘就是已提交内容</li>
<li>缺点：多个事务提交需要写入多次磁盘，写入磁盘麻烦点，因为要复制一个副本出来，副本中是这个事务修改的内容，把这个副本写入磁盘。</li>
</ul>
<p><img src="/../images/15445108.png" alt="104"></p>
<p>shadow paging:</p>
<ul>
<li>有一个db root，记录当前使用的hash table</li>
<li>hash table有一个master table是当前使用的，每个事务会有一个shadow page table，提交以后更新db root指向这个shadow page table，然后回收之前的master table和对应的page文件</li>
</ul>
<p><img src="/../images/15445109.png" alt="104"></p>
<p>wirte ahead log</p>
<ul>
<li>先写入日志，在写入磁盘</li>
<li>日志中包含的信息可以用来undo and redo。</li>
<li>使用的策略是 steal + not force，所以不需要把事务的所有更新都写入磁盘。</li>
</ul>
<p>日志内容</p>
<ul>
<li>事务id</li>
<li>对象id</li>
<li>时间戳</li>
<li>before value(undo)</li>
<li>after value(redo)</li>
<li>写入更快，但是恢复速度慢</li>
</ul>
<p>当事务执行的时候，写入日志到内存中，比如事务t1,将A从1修改到8，当事务提交的时候，先把日志写入磁盘，然后告诉客户端事务成功，如果这个时候发生断电等，可以读取日志来恢复事务，如果写入日志之前断电，那么无需恢复，因为没有告诉客户端成功，事务没有成功如何办是客户端要考虑的。</p>
<p><img src="/../images/15445110.png" alt="104"></p>
<p>group commit</p>
<ul>
<li>有两个log buffer，写满一个以后，写另一个，将满的log buffer写入磁盘</li>
<li>除了满的时候写入磁盘，还有定时，如果知道写入磁盘的时间，可以定时成这个时间，没满的话时间到了也会写入磁盘。</li>
</ul>
<p>满了的写入磁盘可以异步写入，增加速度</p>
<p><img src="/../images/15445111.png" alt="111"></p>
<p>shadow paging 和 WAL 就是一种权衡，是看重运行时速度还是恢复速度，几乎所有的数据库都是用WAL,比如mysql的bin log, WAL运行时速度更快</p>
<p><img src="/../images/15445112.png" alt="111"></p>
<p>logging schemes</p>
<ul>
<li>物理日志：记录底层字节的修改，就像git diff一样能看见，但是修改1万条tuple,就会记录1万条tuple的修改。</li>
<li>逻辑日志：记录高层的事务操作，像update,delete,insert等。比物理日志省空间，但是恢复的时候不知道哪些tuple已经写入了磁盘，所以恢复的时候还会在写入一遍。</li>
<li>混合日志：记录相对底层的修改，但是不像git diff一样那么详细。</li>
</ul>
<p><img src="/../images/15445113.png" alt="111"></p>
<h3 id="check-point"><a href="#check-point" class="headerlink" title="check point"></a>check point</h3><p>WAL的缺点是无限增长，如果崩溃后，则需要重现所有的WAL，增加检查点以后，可以只重现检查点以后的日志。</p>
<p>日志中写入check point，check point之前的都是已经写入磁盘的，所以恢复的时候就不用管了。</p>
<p>假设事务t1在检查点前commit了，则不需要恢复，因为已经提交了，事务t2在检查点后commit，在检查点前开始，则需要redo恢复事务t2，事务t3在检查点前开始，但是还没有commit，所以不需要恢复，直接撤销即可。</p>
<p><img src="/../images/15445114.png" alt="114"></p>
<h2 id="aries-recovery"><a href="#aries-recovery" class="headerlink" title="aries recovery"></a>aries recovery</h2><p>三步</p>
<ul>
<li>预写式日志</li>
<li>Repeating history during redo: 重启并恢复事务到之前的状态</li>
<li>logging changes during undo：再次写入预写式日志</li>
</ul>
<p>日志序列号(LSN)</p>
<ul>
<li>每个日志都要有一个序列号，在一个事务中，可能不是连续的，但是递增的。</li>
<li>flushedLSN:在内存中，记录上一个刷到磁盘中的log的LSN</li>
<li>pageLSN: 在page中，记录page最新的序列号</li>
<li>recLSN: 在page中，记录最老的序列号，这个是不会变的，而pageLSN一直在更新。</li>
<li>lastLSN: 记录事务中最新的一个日志</li>
<li>Master Record: check point最新的LSN</li>
</ul>
<p>如果pageLSN &lt;&#x3D; flushedLSN, 表明这个page的数据都已经写入磁盘了</p>
<p>事务提交的时候，往日志里面写入一个<code>txn end</code>。</p>
<p>当事务commit后写入磁盘，然后更新flushedLSN，接下来添加txn end标识</p>
<p><img src="/../images/15445115.png" alt="114"></p>
<p>CLR:abort算法</p>
<ul>
<li>当事务abort的时候，进行撤销操作，日志里面添加CLR记录，before是对应的之前事务日志的after，CLR的after对应之前的before,undo next指针指向下个需要撤销的日志。</li>
<li>撤销完成以后添加 <code>txn end</code>。</li>
</ul>
<p>写入的时候如同链表一样，除了记录本次的LSN以外，还要记录上一个的LSN,比如本次001，上次是Nil，本次002，上次001，以此找出这一次事务的所有日志，比如事务t1是001-nil,002-001，接下来事务t2是003-nil,004-003,然后事务t1是005-002。</p>
<p>接下来插入CLR日志，CLR可以是026-011,CLR-002代表要撤销的是LSN&#x3D;002的日志，记录了从40恢复到30，最后在插入txn-end标识</p>
<p><img src="/../images/15445116.png" alt="114"></p>
<p>check point写入</p>
<ul>
<li>第一种方式是停止创建新事务，等所有事务完成的时候开始写入<ul>
<li>优点是能完全保证数据一致性</li>
<li>缺点是耗时，执行的时候不能创建新事务</li>
</ul>
</li>
<li>第二种方法暂停更新的事务，只读事务不受影响，需要维护一个active transation table和一个dirty page table<ul>
<li>active transation table包含事务id,lastLSN和状态，状态有运行中，提交中，等待undo</li>
<li>dirty page table 包含所有的dirty page信息</li>
</ul>
</li>
<li>第三种方法最好，叫fuzzy checkpoint，checkpoint的时候允许所有事务运行。<ul>
<li>开始的时候记录checkpoint begin</li>
<li>结束的时候记录checkpoint end,end里面包含了 checkpoint期间的active transation table和dirty page table信息。</li>
</ul>
</li>
</ul>
<p>ATT(Active Transation Table)</p>
<p><img src="/../images/15445117.png" alt="114"></p>
<p>DPT(Dirty Page Table)<br><img src="/../images/15445118.png" alt="114"></p>
<p>第一个check point记录了ATT是T2事务，代表事务t2在check point之前开始，且未提交，而事务t1在check point之前已经提交了，所以不记录，DPT记录了事务t2在check point之前修改的脏页是P22</p>
<p>第二个check point记录了事务T2,T3，因为T2虽然在第二个check point之前提交了，但是没有插入txn-end代表没有提交结束，DPT记录了两个check point之间的脏页P11和P33</p>
<p><img src="/../images/15445119.png" alt="114"></p>
<p>fuzzy check point </p>
<p>因为所有事务都在运行中，所以增加了check point begin 和 end来标识check point的开始和结束，第一个check point end里面记录了事务t2和脏页P22，是因为这些发生在check point begin之前。</p>
<p><img src="/../images/15445120.png" alt="120"></p>
<p>arise recovery</p>
<ul>
<li>分析：根据master record跳到对应的check point的位置，然后开始扫描需要恢复的信息。</li>
<li>redo: 重新执行所有的操作。</li>
<li>undo: 从日志最后开始往上，撤销所有未提交的更改。这个时候已提交的已经写入磁盘，未提交的已经被撤销。</li>
</ul>
<p>分析阶段：从master record的位置开始扫描到最后，找出这之间的所有active transation table和dirty page table信息。</p>
<p>redo: 根据分析出的信息，找到dirty page中最早的一个recLSN, 也就是最早的一个日志，然后从这里开始恢复数据，执行一遍所有的操作。来恢复buffer pool。</p>
<p>undo: 从最后开始往上面扫描，把需要撤销的数据进行撤销。</p>
<h2 id="分布式数据库介绍"><a href="#分布式数据库介绍" class="headerlink" title="分布式数据库介绍"></a>分布式数据库介绍</h2><p>并行数据库</p>
<ul>
<li>离得近的<br>分布式数据库</li>
<li>离得远的</li>
</ul>
<p>系统架构</p>
<ul>
<li>shared everthing</li>
<li>shared memory:常见于高性能计算领域，有多个CPU，共享内存和磁盘</li>
<li>shared disk: 内存也有多个，共享磁盘，这个更常见，例如云数据库<ul>
<li>更新数据的时候需要通知其余的节点</li>
<li>spark,HBase</li>
</ul>
</li>
<li>shared noting: 磁盘也是多个<ul>
<li>有更好的效率，但是很难保证数据一致性和扩容</li>
<li>mongo,ES,Etcd,Zookeeper,ClickHouse</li>
</ul>
</li>
</ul>
<p>shared noting example</p>
<p>首先通过catalog查询应该请求哪个节点</p>
<p><img src="/../images/15445121.png" alt="120"></p>
<p>然后发送查询请求到相应的节点</p>
<p><img src="/../images/15445122.png" alt="120"></p>
<p>如果数据跨节点存储，那么数据会节点间通信，比如获取100和200的数据，node p1会请求p2获取200的数据，然后p1将两个数据返回给客户端</p>
<p><img src="/../images/15445123.png" alt="120"></p>
<p>shared disk example</p>
<p>客户端请求节点获取数据，节点请求disk获取数据，然后返回</p>
<p><img src="/../images/15445124.png" alt="120"></p>
<p>但是更新的时候需要广播给其他节点</p>
<p><img src="/../images/15445125.png" alt="120"></p>
<p>mongo属于shared noting</p>
<ul>
<li>route节点，负责把请求路由到对应的节点上</li>
<li>config节点，route从这里获取请求应该到哪个节点上</li>
<li>db节点</li>
</ul>
<p>数据拆分</p>
<ul>
<li>将不同的数据放到每个shared上面</li>
<li>不同的查询交给不同的shared去做，可以通过exchange operate来并行执行。</li>
<li>最简单的方式是一个表一个分区，mongodb可以这样。</li>
<li>水平分区<ul>
<li>将数据水平分到每个分区中</li>
<li>可以是hash，也可以是一个范围一个范围的分区</li>
<li>hash的话，想增加分区很麻烦，可以使用<code>一致性hash</code>来解决增加分区的问题，而不是取余。</li>
<li>采用一致性hash的有snowflake,memcached,cassandra等</li>
</ul>
</li>
</ul>
<p>SHARED-DISK PARTITIONING<br><img src="/../images/15445126.png" alt="120"></p>
<p>SHARED-NOTHING PARTITIONING<br><img src="/../images/15445127.png" alt="120"></p>
<p>一致性hash</p>
<p>节点分布在环上，数据也分布在环上，顺时针旋转，数据就属于第一个到达的节点。</p>
<p><img src="/../images/15445128.png" alt="120"></p>
<p>增加节点的时候，只需要重新hash其中一个节点的数据就可以，比如增加p4，因为P4节点落在p3节点的范围里面，所以只需要重新hash节点p3的数据，其他节点无影响。</p>
<p><img src="/../images/15445129.png" alt="120"></p>
<p>如果需要复制数据，将数据存储在多个节点上，假设replication&#x3D;3，复制数据到三个节点，则顺时针旋转的3个节点都存储该数据。</p>
<p><img src="/../images/15445130.png" alt="130"></p>
<p>分布式事务</p>
<ul>
<li>通过中心化服务器，来分发lock，然后提交事务的时候通过他来请求每一个分区是否能提交事务，如果都可以，才提交事务</li>
<li>去中心化事务提交</li>
</ul>
<p>spanner</p>
<p>HNSW</p>
<h2 id="分布式OLTP数据库"><a href="#分布式OLTP数据库" class="headerlink" title="分布式OLTP数据库"></a>分布式OLTP数据库</h2><p>假设所有节点是友好的</p>
<p>replication:可以提高可用性</p>
<ul>
<li>分区 vs 非分区</li>
<li>shared noting vs shared disk</li>
<li>设计<ul>
<li>副本配置</li>
<li>传播方案</li>
<li>传播时序</li>
<li>更新方法</li>
</ul>
</li>
</ul>
<p>副本配置</p>
<ul>
<li>primary: 有一个主节点，其他是从节点，大部分都是这样的，主节点负责同步给其他从节点。比如主从复制，读写分离这种</li>
<li>multi-primary: 事务可以在任何一个节点提交，并同步给其他节点，mysql group replication就支持这个。这种方案所有副本都可以读写，冲突的时候通过两阶段提交或者Paxos来觉得写入哪个。Facebook使用了这个。</li>
</ul>
<p>primary，写入主节点，读取可以在从节点</p>
<p><img src="/../images/15445131.png" alt="130"></p>
<p>multi-primary 任何节点都可以读写</p>
<p><img src="/../images/15445132.png" alt="130"></p>
<p>K-safety: 通过监控对象来看有哪些replica是活跃的。至少要有k个replica，如果小于k个，就认为宕机了。</p>
<p>传播方案</p>
<ul>
<li>同步：强一致性，所有从节点都同步以后才返回成功</li>
<li>异步：最终一致性，先返回成功，在同步给其他的从节点</li>
<li>半同步：同步给一些节点后返回成功给客户端</li>
</ul>
<p>传播时序</p>
<ul>
<li>即时：立即传递给其他节点，同时当事务提交或回滚的时候也传递给其他节点</li>
<li>提交：事务提交的时候才传播给其他节点</li>
</ul>
<p>事务提交的顺序由数据库状态决定，原子提交协议也是分布式的共识协议</p>
<p>原子提交协议</p>
<ul>
<li>两阶段提交（1970）</li>
<li>三阶段提交（1983）</li>
<li>Viewstamped Replication (1988)</li>
<li>Paxos（1989）</li>
<li>Raft（2013）</li>
<li>ZAB（2008）</li>
</ul>
<p>两阶段提交</p>
<ul>
<li>第一阶段 prepare, 像所有参与者发送请求，是否能提交事务，只有所有都可以提交，才进入第二阶段，如果有一个节点abort,那么事务就会进入第二阶段abort</li>
<li>第二阶段 commit, 想所有参与者发送请求，进行提交事务。</li>
<li>第二阶段 abort, 返回abort，然后所有参与者abort。</li>
</ul>
<p>假设客户端发送提交事务的请求，有一个协调器和若干个参与者，协调器接收请求以后，向参与者发送第一阶段prepare请求。</p>
<p><img src="/../images/15445133.png" alt="130"></p>
<p>如果所有参与者返回OK,表示全部同意提交，则可以提交。</p>
<p><img src="/../images/15445134.png" alt="130"></p>
<p>接下来协调器发送第二阶段commit请求给所有参与者</p>
<p><img src="/../images/15445135.png" alt="130"></p>
<p>所有参与者返回OK以后，协调器返回提交成功给客户端</p>
<p><img src="/../images/15445136.png" alt="130"></p>
<p>假设有任何一个参与者在第一阶段返回了不同意，则终止事务提交</p>
<p><img src="/../images/15445137.png" alt="130"></p>
<p>协调器向所有节点发送第二阶段abort请求</p>
<p><img src="/../images/15445138.png" alt="130"></p>
<p>等待所有节点返回OK以后，协调器返回abort给客户端</p>
<p><img src="/../images/15445139.png" alt="130"></p>
<p>崩溃恢复</p>
<ul>
<li>如果协调器崩溃了。要么全部abort，要么选出新的协调器继续执行事务。</li>
<li>如果参与者崩溃了，那么协调器会认为参与者返回了abort，从而终止事务。</li>
</ul>
<p>优化</p>
<ul>
<li>early prepare voting: 这个很少，最后一个查询执行的时候，告诉他可以直接进入prepare阶段</li>
<li>early Ack After Prepare: 这个很常见，prepare阶段结束就返回事务执行成功，然后自己再接着commit。</li>
</ul>
<p>early Ack After Prepare：当第一阶段prepare返回成功以后，立即给客户端返回成功。</p>
<p><img src="/../images/15445140.png" alt="140"></p>
<p>返回给客户端以后再发送第二阶段commit请求给其他参与者。</p>
<p><img src="/../images/15445141.png" alt="140"></p>
<p>Paxos，来自分布式计算领域，也被称为<code>共识协议</code>。两阶段提交是Paxos的一个子集。</p>
<ul>
<li>Paxos大部分节点同意提交就可以提交，而两阶段提交需要所有参与者同意，所以Paxos没有容错。</li>
</ul>
<p><img src="/../images/15445142.png" alt="140"></p>
<p>multi-Paxos</p>
<ul>
<li>选举一个leader来进行提案，每隔一段时间重新选举</li>
<li>防止有两个 proposer 来回提交导致的starving问题</li>
</ul>
<p>两阶段提交 vs Paxos vs Raft</p>
<p>两阶段提交</p>
<ul>
<li>如果协调器在发送prepare消息后挂掉，则阻塞直到协调器恢复</li>
</ul>
<p>Paxos</p>
<ul>
<li>如果大多数参与者活着则非阻塞，前提是有足够长的时间不再出现故障</li>
</ul>
<p>Raft</p>
<ul>
<li>与Paxos类似，但节点类型较少。</li>
<li>只有拥有最新日志的节点才能成为领导者</li>
</ul>
<p>CAP理论</p>
<ul>
<li>Consistent: 一致性</li>
<li>Always Available: 始终可用</li>
<li>Network Partition Tolerant:分区容错性</li>
</ul>
<p>Nosql基本都是AP,事务性的基本都是CP</p>
<p>一致性代表从哪个节点获取的数据都是一样的</p>
<p><img src="/../images/15445143.png" alt="140"></p>
<p>可用性代表当节点挂了以后系统还可以使用</p>
<p><img src="/../images/15445144.png" alt="140"></p>
<p>分区容错性最难，容易出现<code>脑裂</code>问题。当网络挂掉以后从节点以为主节点挂了，所以把自己选举为主节点，就产生了两个主节点</p>
<p><img src="/../images/15445145.png" alt="140"></p>
<p>当网络恢复以后，两个节点的数据就不一样了。</p>
<p><img src="/../images/15445146.png" alt="140"></p>
<p>解决方法1：停止系统</p>
<ul>
<li>停止接受没有大多数节点的分区中的更新。</li>
</ul>
<p>解决方案2：允许拆分，协调更改</p>
<ul>
<li>允许分区的每一侧都接收更新</li>
<li>根据时间来确定最后的版本，以最后的版本为准<ul>
<li>服务端：last update wins 用最后的版本为准</li>
<li>客户端：vector clocks（不要这么做）</li>
</ul>
</li>
</ul>
<p>2010年提议对CAP进行扩展</p>
<ul>
<li>Partition Tolerant:分区容忍</li>
<li>Always Available：随时可用</li>
<li>Consistent：一致<ul>
<li>Latency：延迟</li>
<li>Consistency： 一致性</li>
</ul>
</li>
</ul>
<h2 id="分布式OLAP数据库"><a href="#分布式OLAP数据库" class="headerlink" title="分布式OLAP数据库"></a>分布式OLAP数据库</h2><p>OLAP数据库也被称作<code>数据仓库</code>，通过ETL，把数据存入数据仓库。</p>
<ul>
<li>Extract</li>
<li>Transform</li>
<li>Load</li>
</ul>
<p>星形模型</p>
<ul>
<li>一个事实表</li>
<li>几个dim表</li>
</ul>
<p>雪花模型</p>
<ul>
<li>一个事实表</li>
<li>更多的dim表，dim表可以有他的dim表</li>
</ul>
<p>查询执行</p>
<ul>
<li>push: 发送查询到包含数据的节点,返回数据的时候会做过滤和处理，就像<code>条件下推</code>那样</li>
<li>pull: 知道需要的数据在哪些page里面，把page取过来在执行查询。</li>
</ul>
<p>push</p>
<p>pull</p>
<p>查询计划</p>
<ul>
<li>物理操作： 先生成查询计划，然后将对应的需要执行的物理操作直接发送给其余节点，其余节点只负责执行，返回数据。大部分分布式数据库都这样。</li>
<li>sql: 将sql发给每个节点，每个节点生成自己的执行计划。然后执行返回。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/MySQL%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/MySQL%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html" class="post-title-link" itemprop="url">MySQL学习路线</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-26 10:12:47" itemprop="dateCreated datePublished" datetime="2023-04-26T10:12:47+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 10:07:53" itemprop="dateModified" datetime="2025-01-26T10:07:53+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMU15445/" itemprop="url" rel="index"><span itemprop="name">CMU15445</span></a>
                </span>
            </span>

          
            <span id="/MySQL%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html" class="post-meta-item leancloud_visitors" data-flag-title="MySQL学习路线" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/MySQL%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/MySQL%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL学习路线"><a href="#MySQL学习路线" class="headerlink" title="MySQL学习路线"></a>MySQL学习路线</h1><p>大家好，我是大头，98年，职高毕业，上市公司架构师，大厂资深开发，管理过10人团队，我是如何做到的呢？</p>
<p>这离不开持续学习的能力，而其中最重要的当然是数据库技术了！</p>
<p>对于所有开发来说，都离不开数据库，因为所有的数据都是要存储的。</p>
<p>其他的技能可能会变，比如业务开发、算法开发、基础设施开发，也不管你是用Java、php、golang、C++等等。你都会用到数据库，因此，学好数据库对于我们来说就至关重要了。</p>
<p>接下来大头将分享自己学习数据库的路线以及心得。</p>
<p>后续也会根据这个路线分享所有的学习方法以及实操案例。关注我一起学习！文末有惊喜哦！</p>
<h2 id="如何学好数据库"><a href="#如何学好数据库" class="headerlink" title="如何学好数据库"></a>如何学好数据库</h2><p>如何学好数据库？我相信这是一个老生常谈的问题了，如何学好XXX，这里我觉得最重要的是<code>实践</code>。</p>
<p>相信大家都知道这句话。<code>实践是检验真理的唯一标准</code>。因此，当分享结束以后，大头还会分享完整的实操应用，完全免费分享，放在外面至少价值大几百的实操应用训练营。</p>
<p>在现在这个AI发展迅速的时代，你不用点AI好像就被社会淘汰了一样。所以，我们来看一下AI给出的回答。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">学好数据库需要系统的学习方法和实践相结合，以下是一些建议：</span><br><span class="line">1. 基础知识积累</span><br><span class="line">理解数据库概念：首先明确数据库的定义，它是存储、管理和检索数据的系统。了解其基本功能，如数据存储、查询、更新和删除等。</span><br><span class="line">学习数据库类型：常见的数据库有关系型数据库（如MySQL、Oracle、SQL Server）和非关系型数据库（如MongoDB、Redis）。了解它们的特点和适用场景。</span><br><span class="line">掌握数据库模型：重点学习关系型数据库的表结构、字段类型、主键、外键等概念，以及非关系型数据库的键值存储、文档存储、列存储等模型。</span><br><span class="line">2. 理论学习</span><br><span class="line">学习SQL语言：SQL是数据库的核心语言，用于操作关系型数据库。学习SQL的基本语法，包括数据定义语言（DDL）、数据操纵语言（DML）和数据控制语言（DCL）。</span><br><span class="line">DDL：创建、修改和删除数据库对象（如表、索引）。</span><br><span class="line">DML：插入、更新、删除和查询数据。</span><br><span class="line">DCL：控制用户对数据的访问权限。</span><br><span class="line">理解数据库设计原则：学习如何设计合理的数据库结构，包括范式理论（如第一范式、第二范式、第三范式），以减少数据冗余和提高数据一致性。</span><br><span class="line">学习事务管理：了解事务的ACID特性（原子性、一致性、隔离性、持久性），以及事务的提交和回滚机制。</span><br><span class="line">掌握索引和优化：学习索引的原理和类型（如B树索引、哈希索引），以及如何通过索引优化查询性能。</span><br><span class="line">3. 实践操作</span><br><span class="line">安装和配置数据库：选择一种主流的数据库（如MySQL、SQLite），在本地安装并进行配置。熟悉数据库的启动、停止和基本管理操作。</span><br><span class="line">动手操作SQL：通过实际操作来巩固SQL语言的学习。可以使用在线数据库平台（如SQLFiddle）或本地数据库进行练习，编写和执行SQL语句，完成数据的增删改查操作。</span><br><span class="line">进行数据库设计：尝试设计一个小型的数据库项目，如学生管理系统或图书管理系统。从需求分析开始，设计表结构，确定字段类型和关系，然后实现数据库的创建和数据的插入。</span><br><span class="line">参与项目实践：如果有机会，参与实际的数据库项目开发，或者在开源项目中学习和实践。通过实际项目，了解数据库在真实场景中的应用和优化方法。</span><br><span class="line">4. 进阶学习</span><br><span class="line">学习高级SQL技术：如子查询、连接查询（内连接、外连接）、分组查询、窗口函数等。</span><br><span class="line">了解数据库架构设计：学习如何设计高可用、高性能的数据库架构，包括主从复制、读写分离、分库分表等技术。</span><br><span class="line">掌握数据库安全：学习如何保护数据库的安全，包括用户认证、授权、数据加密、备份和恢复等。</span><br><span class="line">学习数据库性能优化：了解如何分析和优化数据库性能，包括查询优化、存储优化、硬件优化等。</span><br><span class="line">5. 持续学习和拓展</span><br><span class="line">关注新技术：数据库领域不断发展，新的技术和工具不断涌现。关注NoSQL数据库、分布式数据库（如Cassandra、HBase）、云数据库（如AWS RDS、阿里云数据库）等新技术的发展。</span><br><span class="line">阅读经典书籍和文档：推荐一些经典书籍，如《数据库系统概念》《SQL必知必会》《高性能MySQL》等。同时，阅读数据库官方文档，深入了解其特性和最佳实践。</span><br><span class="line">参加培训和认证：如果条件允许，可以参加数据库相关的培训课程或考取相关认证（如Oracle认证、MySQL认证），提升自己的专业水平。</span><br><span class="line">加入技术社区：加入数据库相关的技术社区（如Stack Overflow、CSDN、知乎等），与其他开发者交流经验和问题，拓宽视野。</span><br><span class="line">总之，学好数据库需要理论学习和实践操作相结合，通过不断的学习和实践，逐步提升自己的数据库技能。</span><br></pre></td></tr></table></figure>

<p>可以看到AI给出的回答相当不错了。看起来也是那么回事。</p>
<p>对于学习一种新事物来说，我觉得要分为几个阶段吧，对于所有新事物都适用。</p>
<ol>
<li>新概念学习：逐步了解这个东西的概念，是什么？能做什么？什么时候用？如何使用？</li>
<li>基础学习：学习这个东西的一些基础使用，并实践应用。</li>
<li>实战应用：当了解概念和基础以后，可以自己开始实践了，最好能完整的实践每一个功能。一般来说到这一步就可以说熟练使用这个东西了。</li>
<li>深入学习原理：开始深入学习相关的原理性知识，了解这个东西是如何实现的，它当时为什么要这么做？有没有其他替代的方案呢？我们可以尝试自己去实现这个东西。一般来说这一步完成就可以说精通了。</li>
<li>扩展学习：扩展学习其他同类的产品，了解使用场景，优劣等。</li>
</ol>
<p>那么回到我们的话题上，如何学好数据库？</p>
<ol>
<li>概念学习：数据库是什么？能做什么？什么时候用？如何使用？</li>
<li>基础学习：数据库的基础操作，增删改查，DDL、DCL、DML语言。</li>
<li>实战应用：自己去使用数据库的各个功能，包括增删改查、函数、触发器、存储过程、视图等。</li>
<li>学习原理：深入学习数据库的原理，包括事务的实现、锁的实现、增删改查的实现、索引的实现等。</li>
<li>扩展学习：学习不同类型的数据库，如列式数据库、内存数据库、文档数据库等。</li>
</ol>
<p>那么再详细一些呢？如何学好MySQL数据库？</p>
<ol>
<li>概念学习：MySQL数据库是什么？能做什么？什么时候用？如何使用？</li>
<li>基础学习：MySQL数据库的基础操作，增删改查，DDL、DCL、DML语言。</li>
<li>实战应用：自己去使用MySQL数据库的各个功能，包括增删改查、函数、触发器、存储过程、视图等。</li>
<li>学习原理：深入学习MySQL数据库的原理，包括事务的实现、锁的实现、增删改查的实现、索引的实现等。</li>
<li>扩展学习：学习一些其他的数据库，如PostgreSQL、ES、ClickHouse、MongoDB等。</li>
</ol>
<h2 id="概念学习"><a href="#概念学习" class="headerlink" title="概念学习"></a>概念学习</h2><p>首先，我们应该知道什么是数据库？很多人都会搞混一个概念，那就是数据库和数据库管理系统。</p>
<p>数据库的英文是<code>DataBase</code>。它的概念是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">数据库是一个长期存储在计算机内的、有组织的、可共享的数据集合，它具有以下特点</span><br><span class="line">1. 数据的集合性</span><br><span class="line">2. 数据的共享性</span><br><span class="line">3. 数据的冗余度低</span><br><span class="line">4. 数据的独立性</span><br><span class="line">5. 数据的安全性</span><br><span class="line">6. 数据的完整性</span><br><span class="line">7. 数据的可维护性</span><br></pre></td></tr></table></figure>

<p>而数据库管理系统的英文是<code>DataBase Management System</code>。它的概念是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据库管理软件（Database Management System，简称DBMS）是用于创建、管理、维护和操作数据库的软件系统。它在用户和数据库之间提供了一个接口，使得用户能够方便地存储、检索、更新和管理数据。</span><br></pre></td></tr></table></figure>

<p>因此，我们要明白，<code>MySQL</code>是一个数据库管理系统，而不是一个数据库。</p>
<p>虽然我们老说<code>MySQL数据库</code>，但这个是因为大家已经习惯了，大家都明白MySQL是什么，因此省略了一些。</p>
<p><code>MySQL</code>是用来管理数据库的一个系统。</p>
<p>那么问题来了，<code>SQL</code>又是什么呢？</p>
<p>这里给出基础篇的概念学习路线。大家可以根据这些去了解具体的概念。</p>
<p><img src="/../images/mysql/mysql1-1.png" alt="概念学习"></p>
<p>这一个部分1-2小时就差不多了。</p>
<h2 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h2><p>学会了概念以后，我们就要应用，进行实践。只有这样才能将知识转化成我们自己的。</p>
<p>对于实战来说，首先肯定要进行MySQL的安装，可以直接到官网进行安装，这里给出连接。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.mysql.com/">https://www.mysql.com/</a></p>
</blockquote>
<p>安装完成以后，根据上面学习的概念，首先执行一遍DCL、DML、DDL。</p>
<p>接下来需要学习<code>ER图</code>。如何学习ER图呢？同意的，先了解一下概念，在进行实战应用。自己画一画ER图。</p>
<p>画ER图的工具，这里推荐几个</p>
<ul>
<li>visio，可以自己去网上买一些key，不贵，要注意买key，而不是破解机。</li>
<li><a target="_blank" rel="noopener" href="https://www.processon.com/">processOn</a>，强烈推荐，网页版，使用方便，免费的一般也够用了。</li>
<li><a target="_blank" rel="noopener" href="https://app.diagrams.net/">drwa.io</a>，强烈推荐，同样有网页版，使用方便，免费。</li>
<li><a target="_blank" rel="noopener" href="https://dbdiagram.io/">dbdiagram</a>，不同于自己画图，这个网站可以进行数据库建模，支持导入导出。缺点是需要使用<code>DBML</code>进行建模，需要学习一下。</li>
</ul>
<p>接下来进行一些高级的应用、包括CTE、窗口函数、存储过程、视图、触发器等等。</p>
<p>还可以进行导入导出。</p>
<p>还可以使用你熟悉的语言进行操作。Java的使用可以使用MyBatis Plus。</p>
<p><img src="/../images/mysql/mysql1-2.png" alt="概念学习"></p>
<h2 id="深入学习原理"><a href="#深入学习原理" class="headerlink" title="深入学习原理"></a>深入学习原理</h2><p>MySQL原理性的东西就比较多了。</p>
<p>自顶向下来看，首先有连接器、分析器、优化器、执行器。</p>
<p>连接器可以不用管。</p>
<p>分析器的原理，如何进行语法分析的，这里需要学一下<code>关系代数</code>。数据库是将SQL转化成关系代数，然后在生成执行树的。</p>
<p>优化器的原理，如何选择索引的，成本模型是什么？直方图是什么？MySQL本身实现了哪些优化？谓词下推，索引下推，Index Merge等等。</p>
<p>接下来会生成具体的执行计划，如何查看执行计划的各个字段，如何根据执行计划来优化SQL。</p>
<p>还需要学习MySQL事务，事务的隔离级别，ACID特性，MVCC实现，undo log等等。</p>
<p>还要学习SQL语句如何执行的，Select是怎么查询出数据的，where条件怎么筛选数据，join是怎么进行连表查询的，update是怎么更新的，delete怎么删除的，group by,order by怎么实现的。</p>
<p>接下来最重要的索引部分，学习b+树索引，hash索引，倒排索引等等的实现。</p>
<p>数据存储部分的原理，我们知道数据库只是管理数据的，数据最终存储在磁盘上还是一些文件，那么这些文件是如何存储的呢？文件内容是什么？加载到内存以后，内存布局是什么样的？老说page,page是什么？</p>
<p>还有数据库崩溃恢复怎么实现的，redo log怎么实现崩溃恢复，这个其实也挺重要的，因为我们自己进行一些数据处理，可能也需要理解这个，而且大部分的数据持久化，崩溃恢复机制核心都是一样的。</p>
<p>还需要学习mySQL的锁，表锁，行锁，乐观锁，悲观锁，意向锁，间隙锁等等。</p>
<p><img src="/../images/mysql/mysql1-3.png" alt="概念学习"></p>
<h2 id="架构学习"><a href="#架构学习" class="headerlink" title="架构学习"></a>架构学习</h2><p>你学习完上面的东西以后，可以说对于单机MySQL就已经很了解了。接下来就可以进一步保证数据的高可用、高扩展、高性能了。</p>
<p>也就是去了解一些架构上面的知识，比如经典的主从架构，主从同步，异步同步，bin log,relay log，GTID同步。</p>
<p>还有分库分表的只是，水平拆分、垂直拆分、mySQL自带的partition支持。</p>
<p>再比如MySQL自身的集群组件，group replication。还有分布式数据库的一些实现，分布式事务。</p>
<p>CAP理论等等。</p>
<p><img src="/../images/mysql/mysql1-4.png" alt="概念学习"></p>
<h2 id="扩展学习"><a href="#扩展学习" class="headerlink" title="扩展学习"></a>扩展学习</h2><p>当上面的都学习完成以后，可以扩展学习一些其他的数据库。</p>
<p>比如同类型的PostgreSQL。这个更偏向学术性。</p>
<p>再比如其他的文档数据库mongoDB。</p>
<p>常用的搜索数据库ES。</p>
<p>列式数据库ClickHouse这些。</p>
<h2 id="学习书籍推荐"><a href="#学习书籍推荐" class="headerlink" title="学习书籍推荐"></a>学习书籍推荐</h2><p>在这里也给大家推荐一些相关的书籍，可以看一看。</p>
<ul>
<li>MySQL必知必会</li>
<li>InnoDB技术内幕</li>
<li>数据库系统概念</li>
<li>数据密集型应用系统设计</li>
<li>亿级流量系统架构设计与实战</li>
</ul>
<h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>以上就是整体的MySQL学习路线了。</p>
<p>关注我发送“MySQL知识图谱”领取完整的MySQL学习路线。</p>
<p>发送“电子书”即可领取价值上千的电子书资源。</p>
<p>部分电子书如图所示。</p>
<p><img src="/../images/bottom1.png" alt="概念学习"></p>
<p><img src="/../images/bottom2.png" alt="概念学习"></p>
<p><img src="/../images/bottom3.png" alt="概念学习"></p>
<p><img src="/../images/bottom4.png" alt="概念学习"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9%20copy.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9%20copy.html" class="post-title-link" itemprop="url">MySQL学习路线</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-26 10:12:47" itemprop="dateCreated datePublished" datetime="2023-04-26T10:12:47+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-26 11:26:16" itemprop="dateModified" datetime="2025-01-26T11:26:16+08:00">2025-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMU15445/" itemprop="url" rel="index"><span itemprop="name">CMU15445</span></a>
                </span>
            </span>

          
            <span id="/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9%20copy.html" class="post-meta-item leancloud_visitors" data-flag-title="MySQL学习路线" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9%20copy.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9%20copy.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL索引失效"><a href="#MySQL索引失效" class="headerlink" title="MySQL索引失效"></a>MySQL索引失效</h1><p>大家好，我是大头，98年，职高毕业，上市公司架构师，大厂资深开发，管理过10人团队，我是如何做到的呢？</p>
<p>这离不开持续学习的能力，而其中最重要的当然是数据库技术了！</p>
<p>对于所有开发来说，都离不开数据库，因为所有的数据都是要存储的。</p>
<p>关注我一起学习！文末有惊喜哦！</p>
<h2 id="什么是MySQL索引失效？"><a href="#什么是MySQL索引失效？" class="headerlink" title="什么是MySQL索引失效？"></a>什么是MySQL索引失效？</h2><p>MySQL 索引失效是指尽管表中已经建立了索引，但在某些查询操作中，MySQL 的查询优化器选择不使用这些索引，而是采用全表扫描（Full Table Scan）或其他非索引扫描方式来执行查询。这种情况通常会导致查询性能下降，因为全表扫描需要扫描表中的每一行数据，而不是利用索引快速定位数据。</p>
<p>这里就要介绍一下MySQL的整体架构了。</p>
<p><img src="/../images/mysql/mysql2-1.png" alt="架构"></p>
<ul>
<li>连接器：MySQL连接器（MySQL Connector）是用于连接MySQL数据库的客户端库，它允许应用程序与MySQL数据库进行通信。这些连接器提供了API（应用程序编程接口），使得开发者可以在各种编程语言中轻松地执行SQL语句、管理数据库连接、处理查询结果等。</li>
<li>分析器：MySQL分析器才算真正进入了MySQL里面。它会分析词法和语法，如果你的SQL语句不对，就会看到一些报错，例如语法错误。</li>
<li>优化器：MySQL优化器是本文的重点内容，因为这里涉及了MySQL的一些优化，其中就包括了索引选择，也是导致索引失效的重要原因。在这一步也就确定了查询计划。</li>
<li>执行器：MySQL执行器会根据优化器输出的查询计划来执行这个查询计划，会调用底层的存储引擎进行执行。</li>
<li>存储引擎：MySQL支持多种存储引擎，每个存储引擎有不同的特点。其中InnoDB引擎因为支持事务等优点，现在是MySQL的默认存储引擎。</li>
</ul>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>MySQL连接器（MySQL Connector）是用于连接MySQL数据库的客户端库，它允许应用程序与MySQL数据库进行通信。这些连接器提供了API（应用程序编程接口），使得开发者可以在各种编程语言中轻松地执行SQL语句、管理数据库连接、处理查询结果等。</p>
<p>当我们最开始连接数据库实例的时候，我们要输入用户名密码，这时候连接器会从数据库的用户信息中判断你是否有权限连接数据库进行操作，有哪些权限。</p>
<p>如果你输入的用户名密码错误或者没有权限，那么你会收到下面的报错信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access denied <span class="keyword">for</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>(<span class="keyword">using</span> password: YES)</span><br></pre></td></tr></table></figure>

<p><img src="/../images/mysql/mysql2-2.png" alt="架构"></p>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>连接成功以后。分析器会分析这个语句的词法，语法，语义这些信息。</p>
<p>通俗来讲就是看到select,update这些关键字，知道你要来干啥，看看你是不是来搞破坏的，来捣蛋的。</p>
<p>看看你是查询哪个表啊，有什么条件啊，这些玩意。</p>
<p>最后会输出一个词法树。</p>
<p>当然了这一步还会分析你的语法有没有错误，比如你把select打错试试。打成elect，会出现下面的报错信息</p>
<blockquote>
<p>You have an error in your SQL syntax: check the maual that corresponds to your MySQL server version for the right syntax to use near ‘elect * from users’ at line 1</p>
</blockquote>
<p><img src="/../images/mysql/mysql2-3.png" alt="架构"></p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>优化器负责几个事情</p>
<ul>
<li>优化SQL：比如你写了一个很不友好的SQL，如<code>select * from a where 1 =1</code>,优化器会将1&#x3D;1去掉。还有比如括号的删除，如<code>select * from a where ((a AND b) AND c OR (((a AND b) AND (c AND d))))</code>改写成<code>select * from a where (a AND b AND c) OR (a AND b AND c AND d)</code>。等等。</li>
<li>一些内部的优化器：下面列出的是部分，更多的可以参考<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/optimization.html">MySQL官方文档优化器部分</a><ul>
<li>谓词下推：即where条件下推到扫描表的时候执行，而不是扫描表之后执行。</li>
<li>范围优化：对于BTREE和HASH索引，当使用&#x3D;、&lt;&#x3D;&gt;、IN（）、IS NULL或IS NOT NULL运算符时，键部分与常量值的比较是范围条件。此外，对于BTREE索引，当使用&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，BETWEEN，！&#x3D; 、或&lt;&gt;运算符，或者LIKE比较（如果LIKE的参数是不以小写字符开头的常量字符串）。对于所有索引类型，多个范围条件与OR或AND组合形成范围条件。</li>
<li>index merge优化：index merge就是多个索引并发扫描，再将扫描结果合并。</li>
<li>hash join优化：使用hash join来代替Nested Loop Join算法，能大幅度提升join速度。</li>
<li>Is Null优化：可以对<code>where a is null</code>这种条件进行优化，比如该字段设置了<code>not null</code>，那么这个条件就会被删除。</li>
<li>order by + limit优化：使用<code>Top N</code>排序</li>
<li>group by 优化：优化group by语句。</li>
<li>子查询物化：将子查询的内容物化保存起来。</li>
</ul>
</li>
<li>通过成本模型、直方图等信息生成不同的执行路径。</li>
<li>对比执行路径的内容，如取样等，进行选择最终的执行路径。生成查询计划。</li>
</ul>
<p>这里简单的介绍一些mysql内部的优化器，以了解mysql内部做了哪些优化手段。</p>
<p>最后会介绍mysql的成本模型、直方图信息等。结合实际的例子来给大家展示索引选择的问题。</p>
<h4 id="谓词下推优化"><a href="#谓词下推优化" class="headerlink" title="谓词下推优化"></a>谓词下推优化</h4><p>谓词下推优化（Predicate Pushdown Optimization）是一种查询优化技术，它将查询中的过滤条件（谓词）尽可能地推送到数据访问的早期阶段，以减少数据扫描的范围，从而提高查询性能。<br>在数据库查询中，谓词通常是指WHERE子句中的条件。谓词下推优化的目的是让这些条件在数据被读取或处理的早期阶段就发挥作用，避免不必要的数据处理和传输。</p>
<p>在没有谓词下推优化的情况下，数据库会先读取所有数据，然后在内存中应用过滤条件。这可能导致大量的数据被加载到内存中，增加了I&#x2F;O操作和内存使用。<br>通过谓词下推优化，数据库会在数据读取阶段就应用过滤条件，只加载满足条件的数据，从而减少数据的读取量和处理量。</p>
<p>假设存在<code>table_a</code>表，表里面有10条数据，<code>a = 1</code>的数据有一个，具体什么意思呢，我们来看一个SQL语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,b <span class="keyword">from</span> table_a <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>如果没有谓词下推优化的话，执行树如下。</p>
<p><img src="/../images/mysql/mysql2-4.png" alt="架构"></p>
<p>其执行顺序如下：</p>
<ol>
<li>扫描<code>table_a</code>表的10条数据，将10条数据传递给where过滤节点。</li>
<li>where过滤操作进行过滤，过滤出<code>a = 1</code>条件的1条数据，将这个数据传递给列选择节点。</li>
<li>列选择节点选择这条数据的2列，将结果返回。</li>
</ol>
<p>其内存中要存储10条数据。</p>
<p>而有了谓词下推优化以后，执行树如下。</p>
<p><img src="/../images/mysql/mysql2-5.png" alt="架构"></p>
<p>执行顺序如下：</p>
<ol>
<li>扫描<code>table_a</code>表的10条数据，过滤出符合<code>a = 1</code>条件的这一个数据。将这个数据传给列选择节点。</li>
<li>列选择节点选择这条数据的2列，将结果返回。</li>
</ol>
<h4 id="范围优化"><a href="#范围优化" class="headerlink" title="范围优化"></a>范围优化</h4><p>对于BTREE和HASH索引，当使用&#x3D;、&lt;&#x3D;&gt;、IN（）、IS NULL或IS NOT NULL运算符时，键部分与常量值的比较是范围条件。此外，对于BTREE索引，当使用&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，BETWEEN，！&#x3D; 、或&lt;&gt;运算符，或者LIKE比较（如果LIKE的参数是不以小写字符开头的常量字符串）。对于所有索引类型，多个范围条件与OR或AND组合形成范围条件。</p>
<p>给定数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">key_part1  key_part2  key_part3</span><br><span class="line">  NULL       1          &#x27;abc&#x27;</span><br><span class="line">  NULL       1          &#x27;xyz&#x27;</span><br><span class="line">  NULL       2          &#x27;foo&#x27;</span><br><span class="line">   1         1          &#x27;abc&#x27;</span><br><span class="line">   1         1          &#x27;xyz&#x27;</span><br><span class="line">   1         2          &#x27;abc&#x27;</span><br><span class="line">   2         1          &#x27;aaa&#x27;</span><br></pre></td></tr></table></figure>

<p>执行where key_part1&#x3D; 1，其扫描范围为 1,负无穷，负无穷到 1,正无穷，正无穷</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1,-inf,-inf) &lt;= (key_part1,key_part2,key_part3) &lt; (1,+inf,+inf)</span><br></pre></td></tr></table></figure>
<p>即覆盖了这三行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1         1          &#x27;abc&#x27;</span><br><span class="line">1         1          &#x27;xyz&#x27;</span><br><span class="line">1         2          &#x27;abc&#x27;</span><br></pre></td></tr></table></figure>

<p>index dives，优化器在范围的两端进行dives, 可以帮助优化器更准确的评估扫描的行数，index dives提供了更准确的行估计，但是随着比较值数量的增加，更加耗时，使用统计信息的准确性不如index dives，但允许对大值列表进行更快的行估计。</p>
<p>eq_range_index_dive_limit系统变量使您能够配置优化器从一个行估计策略切换到另一个行估计策略时的值数量。要允许使用索引潜水来比较最多N个相等范围，请将eq_range_index_dive_limit设置为N+ 1。要禁用统计信息并始终使用索引潜水而不管N，请将eq_range_index_dive_limit设置为0。</p>
<p>若要更新表索引统计信息以获得最佳估计值，请使用ANALYZE TABLE。</p>
<p>skip scan,比如有索引(f1,f2)，都知道最左前缀原则，所以一般where f2 &gt; 40是不走索引的，skip scan可以让他走索引，通过构造f1 &#x3D; 1 and f2 &gt; 40，扫描完以后再扫描 f1 &#x3D; 2 and f2 &gt; 40，以此类推，可以通过explain来看extra列是否有skip scan</p>
<p>in优化，in查询可以用如下形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FROM t1 WHERE ( col_1, col_2 ) IN (( &#x27;a&#x27;, &#x27;b&#x27; ), ( &#x27;c&#x27;, &#x27;d&#x27; ));</span><br></pre></td></tr></table></figure>

<p>range_optimizer_max_size_size系统变量可以设置优化器使用的内存</p>
<h4 id="index-merge-优化"><a href="#index-merge-优化" class="headerlink" title="index merge 优化"></a>index merge 优化</h4><p>index merge就是多个索引并发扫描，再将扫描结果合并</p>
<p>索引合并不适用于全文索引。</p>
<p>索引合并访问方法检索具有多个范围扫描的行，并将其结果合并为一个。此访问方法只合并单个表的索引扫描，而不合并多个表的扫描。合并可以产生其底层扫描的并集、交集或交集的并集。</p>
<p>可以使用索引合并的查询示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tbl_name WHERE key1 = 10 OR key2 = 20;</span><br><span class="line"></span><br><span class="line">SELECT * FROM tbl_name</span><br><span class="line">  WHERE (key1 = 10 OR key2 = 20) AND non_key = 30;</span><br><span class="line"></span><br><span class="line">SELECT * FROM t1, t2</span><br><span class="line">  WHERE (t1.key1 IN (1,2) OR t1.key2 LIKE &#x27;value%&#x27;)</span><br><span class="line">  AND t2.key1 = t1.some_col;</span><br><span class="line"></span><br><span class="line">SELECT * FROM t1, t2</span><br><span class="line">  WHERE t1.key1 = 1</span><br><span class="line">  AND (t2.key1 = t1.some_col OR t2.key2 = t1.some_col2);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你的查询有一个带有深度AND&#x2F;OR嵌套的复杂WHERE子句，并且MySQL没有选择最佳计划，请尝试使用以下恒等转换来分发术语：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(x AND y) OR z =&gt; (x OR z) AND (y OR z)</span><br><span class="line">(x OR y) AND z =&gt; (x AND z) OR (y AND z)</span><br></pre></td></tr></table></figure>

<p>在EXPLAIN输出中，Index Merge方法在type列中显示为index_merge。在本例中，key列包含使用的索引列表，key_len包含这些索引的最长键部分列表。</p>
<p>索引合并访问方法有几种算法，它们显示在EXPLAIN输出的Extra字段中：</p>
<ul>
<li>intersect：对多个and条件生效</li>
<li>union：对多个or条件生效</li>
<li>sort_union：sort-union算法和union算法之间的区别在于，sort-union算法必须首先获取所有行的行ID，并在返回任何行之前对其进行排序。</li>
</ul>
<p>索引合并的使用取决于optimizer_switch系统变量的index_merge、index_merge_intersection、index_merge_union和index_merge_sort_union标志的值。默认情况下，所有这些标志都是打开的。</p>
<h4 id="hash-join"><a href="#hash-join" class="headerlink" title="hash join"></a>hash join</h4><p>默认情况下，MySQL尽可能使用哈希连接。可以使用BNL和NO_BNL优化器提示之一来控制是否使用散列连接。</p>
<p>hash join比嵌套join快的多，首先创建hash表，在循环另一个表进行hash，判断是否相等</p>
<p>可以使用join_buffer_size系统变量控制哈希连接的内存使用量;哈希连接使用的内存量不能超过此值。当哈希连接所需的内存超过可用量时，MySQL会使用磁盘上的文件来处理。如果发生这种情况，您应该注意，如果哈希连接无法容纳内存并且它创建的文件比为open_files_limit设置的文件多，则连接可能不会成功。要避免此类问题，请进行以下更改之一：</p>
<ul>
<li>增加join_buffer_size，使哈希连接不会溢出到磁盘。</li>
<li>增加open_files_limit。</li>
</ul>
<h4 id="成本模型"><a href="#成本模型" class="headerlink" title="成本模型"></a>成本模型</h4><p>MySQL成本模型（Cost Model）是MySQL查询优化器（Query Optimizer）用来评估不同查询执行计划的成本（Cost）的一种机制。成本模型通过估算每种执行计划所需的资源（如CPU、I&#x2F;O、内存等）来选择最优的执行计划。</p>
<p>MySQL的成本模型主要考虑以下几个方面：</p>
<ol>
<li>CPU成本：<ul>
<li>评估执行计划中每个操作（如比较、计算、排序等）所需的CPU时间。</li>
<li>例如，WHERE子句中的条件计算、JOIN操作中的匹配等。</li>
</ul>
</li>
<li>I&#x2F;O成本：<ul>
<li>评估执行计划中每个操作所需的磁盘I&#x2F;O操作次数。</li>
<li>例如，全表扫描、索引扫描、数据页的读取等。</li>
<li>I&#x2F;O成本通常是最主要的成本因素之一，因为磁盘I&#x2F;O操作相对较慢。</li>
</ul>
</li>
<li>内存成本：<ul>
<li>评估执行计划中每个操作所需的内存使用量。</li>
<li>例如，排序操作、临时表的创建等。</li>
</ul>
</li>
<li>网络成本：<ul>
<li>评估执行计划中每个操作所需的网络传输量。</li>
<li>例如，分布式查询中跨节点的数据传输。</li>
</ul>
</li>
<li>数据分布：<ul>
<li>评估数据的分布情况，如表的大小、索引的覆盖率等。</li>
<li>数据分布会影响I&#x2F;O操作的次数和效率。</li>
</ul>
</li>
</ol>
<p>其中大部分的成本都是固定的，比如CPU成本、IO成本、内存成本。这个是根据你服务器的配置决定的。</p>
<p>所以，主要关注的是数据分布。</p>
<p>MySQL的数据分布使用<code>直方图</code>来记录。</p>
<h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h4><p><code>column_statistics数据字典表</code>存储有关列值的<code>直方图</code>统计信息，供优化器在构造查询执行计划时使用。要执行直方图管理，请使用<code>ANALYZE TABLE</code>语句。</p>
<ul>
<li>该表包含除几何类型（空间数据）和JSON之外的所有数据类型的列的统计信息。</li>
<li>该表是持久的，因此不必在每次服务器启动时都创建列统计信息。</li>
<li>服务器对表执行更新，用户不执行。</li>
</ul>
<p>用户不能直接访问<code>column_statistics</code>表，因为它是<code>数据字典</code>的一部分。直方图信息可使用 <code>INFORMATION_SCHEMA.COLUMN_STATISTICS</code> 获得，它是作为数据字典表上的视图实现的。<code>COLUMN_STATISTICS</code>包含以下列：</p>
<ul>
<li>SCHEMA_NAME、TABLE_NAME、COLUMN_NAME：应用统计信息的模式、表和列的名称。</li>
<li>HISTORIO：描述列统计信息的JSON值，存储为直方图。</li>
</ul>
<p>直方图实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;buckets&quot;: [</span><br><span class="line">    [</span><br><span class="line">      1,</span><br><span class="line">      0.3333333333333333</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      2,</span><br><span class="line">      0.6666666666666666</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      3,</span><br><span class="line">      1</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  &quot;null-values&quot;: 0,</span><br><span class="line">  &quot;last-updated&quot;: &quot;2017-03-24 13:32:40.000000&quot;,</span><br><span class="line">  &quot;sampling-rate&quot;: 1,</span><br><span class="line">  &quot;histogram-type&quot;: &quot;singleton&quot;,</span><br><span class="line">  &quot;number-of-buckets-specified&quot;: 128,</span><br><span class="line">  &quot;data-type&quot;: &quot;int&quot;,</span><br><span class="line">  &quot;collation-id&quot;: 8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>buckets：直方图桶。桶结构取决于直方图类型。</li>
<li>null-values：一个介于0.0和1.0之间的数字，表示<code>SQL NULL</code>值的列值的分数。如果为0，则该列不包含NULL值。</li>
<li>last-updated：直方图生成时，以 <code>YYYY-MM-DD hh:mm:ss.uuuuuu</code> 格式的UTC值表示。</li>
<li>sampling-rate：0.0到1.0之间的数字，表示为创建直方图而采样的数据比例。值为1表示已读取所有数据（无采样）。</li>
<li>histogram-type：直方图类型：<ul>
<li>singleton：一个bucket表示列中的一个值。当列中的非重复值数量小于或等于生成直方图的<code>ANALYZE TABLE</code>语句中指定的存储桶数量时，将创建此直方图类型。</li>
<li>equi-height：一个桶表示一个值范围。当列中的非重复值数量大于生成直方图的<code>ANALYZE TABLE</code>语句中指定的存储桶数量时，将创建此直方图类型。</li>
</ul>
</li>
<li>number-of-buckets-specified：生成直方图的<code>ANALYZE TABLE</code>语句中指定的<code>桶数</code>。</li>
<li>data-type：此直方图包含的数据类型。在将直方图从持久性存储器阅读和解析到内存中时，这是需要的。该值是int、uint（无符号整数）、double、decimal、datetime或string（包括字符和二进制字符串）之一。</li>
<li>collation-id：直方图数据的归类ID。当数据类型值是字符串时，它最有意义。值对应于信息架构<code>COLLATIONS</code>表中的ID列值。</li>
</ul>
<p>直方图统计信息主要用于非索引列。将索引添加到直方图统计信息适用的列还可以帮助优化器进行行估计。</p>
<p>优化器更喜欢范围优化器的行估计，而不是从直方图统计信息中获得的行估计。如果优化器确定范围优化器适用，则不使用直方图统计信息。</p>
<p>对于已建立索引的列，可以使用索引潜水(index dives)获得行估计值以进行相等比较。</p>
<p>在某些情况下，使用直方图统计信息可能不会改善查询执行（例如，如果统计信息过期）。要检查是否是这种情况，请使用<code>ANALYZE TABLE</code>重新生成直方图统计信息，然后再次运行查询。</p>
<p>这么看这些概念内容，可能很难理解直方图到底是干啥的，下面给出一个例子方便理解。</p>
<h5 id="直方图示例"><a href="#直方图示例" class="headerlink" title="直方图示例"></a>直方图示例</h5><h2 id="虽然直方图的字段很多，但其核心的字段只有几个"><a href="#虽然直方图的字段很多，但其核心的字段只有几个" class="headerlink" title="虽然直方图的字段很多，但其核心的字段只有几个"></a>虽然直方图的字段很多，但其核心的字段只有几个</h2><p>创建一个测试表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_a(id <span class="type">int</span> auto_increment,a <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span>, b <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>, <span class="keyword">primary</span> key(id));</span><br></pre></td></tr></table></figure>

<p>接下来我们插入几个数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_a (a, b) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;A1&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;B2&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;C3&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;D4&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;E5&#x27;</span>),</span><br><span class="line">(<span class="number">6</span>, <span class="string">&#x27;F6&#x27;</span>),</span><br><span class="line">(<span class="number">7</span>, <span class="string">&#x27;G7&#x27;</span>),</span><br><span class="line">(<span class="number">8</span>, <span class="string">&#x27;H8&#x27;</span>),</span><br><span class="line">(<span class="number">9</span>, <span class="string">&#x27;I9&#x27;</span>),</span><br><span class="line">(<span class="number">10</span>, <span class="string">&#x27;J10&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>接下来生成直方图信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE <span class="keyword">TABLE</span> test_a <span class="keyword">update</span>  HISTOGRAM <span class="keyword">ON</span> a <span class="keyword">WITH</span> <span class="number">5</span> BUCKETS;</span><br></pre></td></tr></table></figure>

<p>查询直方图信息。这里的<code>SCHEMA_NAME</code>是数据库的名称，TABLE_NAME是数据表的名称。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.COLUMN_STATISTICS <span class="keyword">where</span> SCHEMA_NAME <span class="operator">=</span> <span class="string">&#x27;test1&#x27;</span> <span class="keyword">and</span> TABLE_NAME <span class="operator">=</span> <span class="string">&#x27;test_a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>查询结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+-------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> SCHEMA_NAME <span class="operator">|</span> TABLE_NAME <span class="operator">|</span> COLUMN_NAME <span class="operator">|</span> HISTOGRAM</span><br><span class="line">                                                                                                                                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+-------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> test1       <span class="operator">|</span> test_a     <span class="operator">|</span> a           <span class="operator">|</span> &#123;&quot;buckets&quot;: [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0.2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">0.4</span>, <span class="number">2</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">0.6</span>, <span class="number">2</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">0.8</span>, <span class="number">2</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">1.0</span>, <span class="number">2</span>]], &quot;data-type&quot;: &quot;int&quot;, &quot;auto-update&quot;: <span class="literal">false</span>, &quot;null-values&quot;: <span class="number">0.0</span>, &quot;collation-id&quot;: <span class="number">8</span>, &quot;last-updated&quot;: &quot;2025-01-25 13:01:57.129967&quot;, &quot;sampling-rate&quot;: <span class="number">1.0</span>, &quot;histogram-type&quot;: &quot;equi-height&quot;, &quot;number-of-buckets-specified&quot;: <span class="number">5</span>&#125; <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+-------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>我们来看一下直方图的信息。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;buckets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">0.4</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">0.6</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">7</span><span class="punctuation">,</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">9</span><span class="punctuation">,</span> <span class="number">10</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;data-type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;int&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;auto-update&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;null-values&quot;</span><span class="punctuation">:</span> <span class="number">0.0</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;collation-id&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;last-updated&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2025-01-25 13:01:57.129967&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;sampling-rate&quot;</span><span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;histogram-type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;equi-height&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;number-of-buckets-specified&quot;</span><span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>buckets：直方图桶。桶结构取决于直方图类型。</li>
<li>null-values：0.0,表示没有null值，这是因为我们使用了<code>not null</code>声明字段。</li>
<li>last-updated：更新时间，没啥好说的。</li>
<li>sampling-rate：1.0 获取了所有数据，因为我们只有10条数据，很少。</li>
<li>histogram-type：直方图类型：equi-height，因为<code>a</code>列有10个值，都不重复，而桶数量我们用的是5，所以生成了这个类型。</li>
<li>number-of-buckets-specified：生成直方图的<code>ANALYZE TABLE</code>语句中指定的<code>桶数</code>。</li>
<li>data-type：列a是int类型</li>
<li>collation-id：直方图数据的归类ID。当数据类型值是字符串时，它最有意义。值对应于信息架构<code>COLLATIONS</code>表中的ID列值。</li>
</ul>
<p>桶里面有4个数据</p>
<ul>
<li>最小值</li>
<li>最大值</li>
<li>密度</li>
<li>高度</li>
</ul>
<p>比如，查询语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_a <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><code>a = 5</code>的数据在第三个桶里面，最小值5，最大值6，密度0.6，高度2.</p>
<p>根据计算公式<code>预估行数 = 密度 * 高度</code>来计算0.6 * 2，预估行数就是1.2，也就是1-2行。</p>
<p><img src="/../images/mysql/mysql2-6.jpg" alt="架构"></p>
<p>可以看到查询计划里面的rows是10行，这是因为类型是全表扫描，但是后面的<code>filtered</code>字段是10，表示的意思是会过滤出来 <code>10 * 10% = 10 * 0.1 = 1</code>行。</p>
<p>也就是最终会查出1行结果。</p>
<p>通常来说，对于没有索引的列，MySQL就是这样来预估行数的，并且通过这个结果来进行选择执行路线。</p>
<h3 id="执行路线选择"><a href="#执行路线选择" class="headerlink" title="执行路线选择"></a>执行路线选择</h3><p>什么叫路线选择呢，还是上面那个表，我们现在有如下SQL语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,b <span class="keyword">from</span> test_a <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> b <span class="operator">=</span> <span class="string">&#x27;A1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>根据表数据，其实我们知道，查出来的结果还是1条。但是对于mysql来说，却有不同的执行方式。</p>
<p>第一种执行方式，先查<code>a=1</code>在查询<code>b=&#39;A1&#39;</code>的数据。执行树如下。</p>
<p><img src="/../images/mysql/mysql2-7.jpg" alt="架构"></p>
<p>第二种执行方式，先查<code>b=&#39;A1&#39;</code>在查询 <code>a=1</code>。执行树如下。</p>
<p><img src="/../images/mysql/mysql2-8.jpg" alt="架构"></p>
<p>目前看着这两种方式都没啥问题。</p>
<p>但是，我们再插入一条数据呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_a (a, b) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">11</span>, <span class="string">&#x27;A1&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这样我们就知道了，方案1， 会直接过滤出1行数据，然后在过滤，这样显然比方案2更好。</p>
<p>因为方案2会先查出2条数据，再次过滤。</p>
<p>这就是不同的执行路线带来的性能区别。当然了，我们这里的例子只是打个比方，实际上<code>谓词下推</code>优化以后，这两个条件都是和扫描表一起执行的。</p>
<p>这个例子只是让你明白不同的路线选择而已。</p>
<p>对于<code>join</code>查询来说，会有更多的选择。</p>
<h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>以上就是今天的内容了，大家有任何疑问可以打在评论区，一起交流～</p>
<p>关注我发送“MySQL知识图谱”领取完整的MySQL学习路线。</p>
<p>发送“电子书”即可领取价值上千的电子书资源。</p>
<p>部分电子书如图所示。</p>
<p><img src="/../images/bottom1.png" alt="概念学习"></p>
<p><img src="/../images/bottom2.png" alt="概念学习"></p>
<p><img src="/../images/bottom3.png" alt="概念学习"></p>
<p><img src="/../images/bottom4.png" alt="概念学习"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9.html" class="post-title-link" itemprop="url">MySQL查询路径选择</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-26 10:12:47" itemprop="dateCreated datePublished" datetime="2023-04-26T10:12:47+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-11 16:34:45" itemprop="dateModified" datetime="2025-02-11T16:34:45+08:00">2025-02-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          
            <span id="/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9.html" class="post-meta-item leancloud_visitors" data-flag-title="MySQL查询路径选择" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL查询路径选择"><a href="#MySQL查询路径选择" class="headerlink" title="MySQL查询路径选择"></a>MySQL查询路径选择</h1><p>大家好，我是大头，98年，职高毕业，上市公司架构师，大厂资深开发，管理过10人团队，我是如何做到的呢？</p>
<p>这离不开持续学习的能力，而其中最重要的当然是数据库技术了！</p>
<p>对于所有开发来说，都离不开数据库，因为所有的数据都是要存储的。</p>
<p>关注我一起学习！文末有惊喜哦！</p>
<h2 id="什么是MySQL查询路径？"><a href="#什么是MySQL查询路径？" class="headerlink" title="什么是MySQL查询路径？"></a>什么是MySQL查询路径？</h2><p>MySQL查询路径是指查询优化器在执行查询时所选择的具体执行步骤和顺序。查询优化器的目标是找到最高效的方式来执行查询，以最小化资源消耗（如CPU、I&#x2F;O、内存等）和查询响应时间。查询路径包括以下几个关键阶段：</p>
<ol>
<li>解析（Parsing）：</li>
</ol>
<ul>
<li>将SQL语句解析成内部的逻辑结构，如语法树（Syntax Tree）。</li>
<li>检查SQL语句的语法是否正确。</li>
</ul>
<ol start="2">
<li>预处理（Preprocessing）：</li>
</ol>
<ul>
<li>检查用户是否有权限执行该查询。</li>
<li>检查表和列是否存在。</li>
<li>重写查询，如展开视图、处理子查询等。</li>
</ul>
<ol start="3">
<li>优化（Optimization）：</li>
</ol>
<ul>
<li>查询优化器评估不同的执行计划，选择最优的执行路径。</li>
<li>优化器会考虑索引、表的大小、数据分布等因素。</li>
<li>生成执行计划，决定如何访问表、如何连接表、如何过滤数据等。</li>
</ul>
<ol start="4">
<li>执行（Execution）：</li>
</ol>
<ul>
<li>按照优化器生成的执行计划，实际执行查询。</li>
<li>包括表扫描、索引扫描、连接操作、过滤操作等。</li>
</ul>
<ol start="5">
<li>结果返回（Result Returning）：</li>
</ol>
<ul>
<li>将查询结果返回给客户端。</li>
</ul>
<h3 id="查询路径的详细分析"><a href="#查询路径的详细分析" class="headerlink" title="查询路径的详细分析"></a>查询路径的详细分析</h3><ol>
<li>解析（Parsing）</li>
</ol>
<p>解析阶段将SQL语句转换为内部的逻辑结构。例如，对于查询SELECT a, b FROM test_a WHERE a &#x3D; 1 AND b &#x3D; ‘A1’;，解析器会将其解析为一个查询树，包含以下信息：</p>
<ul>
<li>查询类型：SELECT</li>
<li>查询的列：a, b</li>
<li>查询的表：test_a</li>
<li>查询的条件：a &#x3D; 1 AND b &#x3D; ‘A1’</li>
</ul>
<ol start="2">
<li>预处理（Preprocessing）</li>
</ol>
<p>预处理阶段会检查用户是否有权限执行该查询，表和列是否存在，以及是否需要重写查询。例如：</p>
<ul>
<li>如果test_a表不存在，查询会失败。</li>
<li>如果用户没有权限访问test_a表，查询会失败。</li>
<li>如果查询中包含子查询或视图，预处理器会将其展开。</li>
</ul>
<ol start="3">
<li>优化（Optimization）</li>
</ol>
<p>优化阶段是查询路径中最关键的部分。查询优化器会评估不同的执行计划，选择最优的执行路径。优化器考虑的因素包括：</p>
<ul>
<li>索引：是否有可用的索引，以及索引是否能有效过滤数据。</li>
<li>表的大小：表的大小会影响全表扫描的成本。</li>
<li>数据分布：数据的分布情况会影响过滤条件的效率。</li>
<li>连接顺序：如果有多个表连接，优化器会决定最佳的连接顺序。</li>
</ul>
<p>优化器会生成一个执行计划，描述如何执行查询。例如，对于查询SELECT a, b FROM test_a WHERE a &#x3D; 1 AND b &#x3D; ‘A1’;，优化器可能会生成以下执行计划：</p>
<ul>
<li>使用a列上的索引idx_a来定位满足条件a &#x3D; 1的行。</li>
<li>在这些行中进一步过滤满足条件b &#x3D; ‘A1’的行。</li>
</ul>
<ol start="4">
<li>执行（Execution）</li>
</ol>
<p>执行阶段按照优化器生成的执行计划，实际执行查询。例如：</p>
<ul>
<li>如果优化器选择使用a列上的索引idx_a，执行器会先扫描索引，找到满足条件a &#x3D; 1的行。</li>
<li>然后在这些行中进一步过滤满足条件b &#x3D; ‘A1’的行。</li>
<li>最终将结果返回给客户端。</li>
</ul>
<ol start="5">
<li>结果返回（Result Returning）</li>
</ol>
<p>执行器将查询结果返回给客户端。客户端可以是MySQL客户端工具、应用程序等。</p>
<h3 id="mysql架构"><a href="#mysql架构" class="headerlink" title="mysql架构"></a>mysql架构</h3><p>这里就要介绍一下MySQL的整体架构了。</p>
<p><img src="https://thepatterraining.github.io/images/mysql/mysql2-1.png" alt="架构"></p>
<ul>
<li>连接器：MySQL连接器（MySQL Connector）是用于连接MySQL数据库的客户端库，它允许应用程序与MySQL数据库进行通信。这些连接器提供了API（应用程序编程接口），使得开发者可以在各种编程语言中轻松地执行SQL语句、管理数据库连接、处理查询结果等。</li>
<li>分析器：MySQL分析器才算真正进入了MySQL里面。它会分析词法和语法，如果你的SQL语句不对，就会看到一些报错，例如语法错误。</li>
<li>优化器：MySQL优化器是本文的重点内容，因为这里涉及了MySQL的一些优化，其中就包括了索引选择，也是导致索引失效的重要原因。在这一步也就确定了查询计划。</li>
<li>执行器：MySQL执行器会根据优化器输出的查询计划来执行这个查询计划，会调用底层的存储引擎进行执行。</li>
<li>存储引擎：MySQL支持多种存储引擎，每个存储引擎有不同的特点。其中InnoDB引擎因为支持事务等优点，现在是MySQL的默认存储引擎。</li>
</ul>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>MySQL连接器（MySQL Connector）是用于连接MySQL数据库的客户端库，它允许应用程序与MySQL数据库进行通信。这些连接器提供了API（应用程序编程接口），使得开发者可以在各种编程语言中轻松地执行SQL语句、管理数据库连接、处理查询结果等。</p>
<p>当我们最开始连接数据库实例的时候，我们要输入用户名密码，这时候连接器会从数据库的用户信息中判断你是否有权限连接数据库进行操作，有哪些权限。</p>
<p>如果你输入的用户名密码错误或者没有权限，那么你会收到下面的报错信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access denied <span class="keyword">for</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>(<span class="keyword">using</span> password: YES)</span><br></pre></td></tr></table></figure>

<p><img src="https://thepatterraining.github.io/images/mysql/mysql2-2.png" alt="架构"></p>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>连接成功以后。分析器会分析这个语句的词法，语法，语义这些信息。</p>
<p>通俗来讲就是看到select,update这些关键字，知道你要来干啥，看看你是不是来搞破坏的，来捣蛋的。</p>
<p>看看你是查询哪个表啊，有什么条件啊，这些玩意。</p>
<p>最后会输出一个词法树。</p>
<p>当然了这一步还会分析你的语法有没有错误，比如你把select打错试试。打成elect，会出现下面的报错信息</p>
<blockquote>
<p>You have an error in your SQL syntax: check the maual that corresponds to your MySQL server version for the right syntax to use near ‘elect * from users’ at line 1</p>
</blockquote>
<p><img src="https://thepatterraining.github.io/images/mysql/mysql2-3.png" alt="架构"></p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>优化器负责几个事情</p>
<ul>
<li>优化SQL：比如你写了一个很不友好的SQL，如<code>select * from a where 1 =1</code>,优化器会将1&#x3D;1去掉。还有比如括号的删除，如<code>select * from a where ((a AND b) AND c OR (((a AND b) AND (c AND d))))</code>改写成<code>select * from a where (a AND b AND c) OR (a AND b AND c AND d)</code>。等等。</li>
<li>一些内部的优化器：下面列出的是部分，更多的可以参考<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/optimization.html">MySQL官方文档优化器部分</a><ul>
<li>谓词下推：即where条件下推到扫描表的时候执行，而不是扫描表之后执行。</li>
<li>范围优化：对于BTREE和HASH索引，当使用&#x3D;、&lt;&#x3D;&gt;、IN（）、IS NULL或IS NOT NULL运算符时，键部分与常量值的比较是范围条件。此外，对于BTREE索引，当使用&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，BETWEEN，！&#x3D; 、或&lt;&gt;运算符，或者LIKE比较（如果LIKE的参数是不以小写字符开头的常量字符串）。对于所有索引类型，多个范围条件与OR或AND组合形成范围条件。</li>
<li>index merge优化：index merge就是多个索引并发扫描，再将扫描结果合并。</li>
<li>hash join优化：使用hash join来代替Nested Loop Join算法，能大幅度提升join速度。</li>
<li>Is Null优化：可以对<code>where a is null</code>这种条件进行优化，比如该字段设置了<code>not null</code>，那么这个条件就会被删除。</li>
<li>order by + limit优化：使用<code>Top N</code>排序</li>
<li>group by 优化：优化group by语句。</li>
<li>子查询物化：将子查询的内容物化保存起来。</li>
</ul>
</li>
<li>通过成本模型、直方图等信息生成不同的执行路径。</li>
<li>对比执行路径的内容，如取样等，进行选择最终的执行路径。生成查询计划。</li>
</ul>
<p>这里简单的介绍一些mysql内部的优化器，以了解mysql内部做了哪些优化手段。</p>
<p>最后会介绍mysql的成本模型、直方图信息等。结合实际的例子来给大家展示索引选择的问题。</p>
<h4 id="谓词下推优化"><a href="#谓词下推优化" class="headerlink" title="谓词下推优化"></a>谓词下推优化</h4><p>谓词下推优化（Predicate Pushdown Optimization）是一种查询优化技术，它将查询中的过滤条件（谓词）尽可能地推送到数据访问的早期阶段，以减少数据扫描的范围，从而提高查询性能。<br>在数据库查询中，谓词通常是指WHERE子句中的条件。谓词下推优化的目的是让这些条件在数据被读取或处理的早期阶段就发挥作用，避免不必要的数据处理和传输。</p>
<p>在没有谓词下推优化的情况下，数据库会先读取所有数据，然后在内存中应用过滤条件。这可能导致大量的数据被加载到内存中，增加了I&#x2F;O操作和内存使用。<br>通过谓词下推优化，数据库会在数据读取阶段就应用过滤条件，只加载满足条件的数据，从而减少数据的读取量和处理量。</p>
<p>假设存在<code>table_a</code>表，表里面有10条数据，<code>a = 1</code>的数据有一个，具体什么意思呢，我们来看一个SQL语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,b <span class="keyword">from</span> table_a <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>如果没有谓词下推优化的话，执行树如下。</p>
<p><img src="https://thepatterraining.github.io/images/mysql/mysql2-4.png" alt="架构"></p>
<p>其执行顺序如下：</p>
<ol>
<li>扫描<code>table_a</code>表的10条数据，将10条数据传递给where过滤节点。</li>
<li>where过滤操作进行过滤，过滤出<code>a = 1</code>条件的1条数据，将这个数据传递给列选择节点。</li>
<li>列选择节点选择这条数据的2列，将结果返回。</li>
</ol>
<p>其内存中要存储10条数据。</p>
<p>而有了谓词下推优化以后，执行树如下。</p>
<p><img src="https://thepatterraining.github.io/images/mysql/mysql2-5.png" alt="架构"></p>
<p>执行顺序如下：</p>
<ol>
<li>扫描<code>table_a</code>表的10条数据，过滤出符合<code>a = 1</code>条件的这一个数据。将这个数据传给列选择节点。</li>
<li>列选择节点选择这条数据的2列，将结果返回。</li>
</ol>
<h4 id="范围优化"><a href="#范围优化" class="headerlink" title="范围优化"></a>范围优化</h4><p>对于BTREE和HASH索引，当使用&#x3D;、&lt;&#x3D;&gt;、IN（）、IS NULL或IS NOT NULL运算符时，键部分与常量值的比较是范围条件。此外，对于BTREE索引，当使用&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，BETWEEN，！&#x3D; 、或&lt;&gt;运算符，或者LIKE比较（如果LIKE的参数是不以小写字符开头的常量字符串）。对于所有索引类型，多个范围条件与OR或AND组合形成范围条件。</p>
<p>给定数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">key_part1  key_part2  key_part3</span><br><span class="line">  NULL       1          &#x27;abc&#x27;</span><br><span class="line">  NULL       1          &#x27;xyz&#x27;</span><br><span class="line">  NULL       2          &#x27;foo&#x27;</span><br><span class="line">   1         1          &#x27;abc&#x27;</span><br><span class="line">   1         1          &#x27;xyz&#x27;</span><br><span class="line">   1         2          &#x27;abc&#x27;</span><br><span class="line">   2         1          &#x27;aaa&#x27;</span><br></pre></td></tr></table></figure>

<p>执行where key_part1&#x3D; 1，其扫描范围为 1,负无穷，负无穷到 1,正无穷，正无穷</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1,-inf,-inf) &lt;= (key_part1,key_part2,key_part3) &lt; (1,+inf,+inf)</span><br></pre></td></tr></table></figure>
<p>即覆盖了这三行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1         1          &#x27;abc&#x27;</span><br><span class="line">1         1          &#x27;xyz&#x27;</span><br><span class="line">1         2          &#x27;abc&#x27;</span><br></pre></td></tr></table></figure>

<p>index dives，优化器在范围的两端进行dives, 可以帮助优化器更准确的评估扫描的行数，index dives提供了更准确的行估计，但是随着比较值数量的增加，更加耗时，使用统计信息的准确性不如index dives，但允许对大值列表进行更快的行估计。</p>
<p>eq_range_index_dive_limit系统变量使您能够配置优化器从一个行估计策略切换到另一个行估计策略时的值数量。要允许使用索引潜水来比较最多N个相等范围，请将eq_range_index_dive_limit设置为N+ 1。要禁用统计信息并始终使用索引潜水而不管N，请将eq_range_index_dive_limit设置为0。</p>
<p>若要更新表索引统计信息以获得最佳估计值，请使用ANALYZE TABLE。</p>
<p>skip scan,比如有索引(f1,f2)，都知道最左前缀原则，所以一般where f2 &gt; 40是不走索引的，skip scan可以让他走索引，通过构造f1 &#x3D; 1 and f2 &gt; 40，扫描完以后再扫描 f1 &#x3D; 2 and f2 &gt; 40，以此类推，可以通过explain来看extra列是否有skip scan</p>
<p>in优化，in查询可以用如下形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FROM t1 WHERE ( col_1, col_2 ) IN (( &#x27;a&#x27;, &#x27;b&#x27; ), ( &#x27;c&#x27;, &#x27;d&#x27; ));</span><br></pre></td></tr></table></figure>

<p>range_optimizer_max_size_size系统变量可以设置优化器使用的内存</p>
<h4 id="index-merge-优化"><a href="#index-merge-优化" class="headerlink" title="index merge 优化"></a>index merge 优化</h4><p>index merge就是多个索引并发扫描，再将扫描结果合并</p>
<p>索引合并不适用于全文索引。</p>
<p>索引合并访问方法检索具有多个范围扫描的行，并将其结果合并为一个。此访问方法只合并单个表的索引扫描，而不合并多个表的扫描。合并可以产生其底层扫描的并集、交集或交集的并集。</p>
<p>可以使用索引合并的查询示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tbl_name WHERE key1 = 10 OR key2 = 20;</span><br><span class="line"></span><br><span class="line">SELECT * FROM tbl_name</span><br><span class="line">  WHERE (key1 = 10 OR key2 = 20) AND non_key = 30;</span><br><span class="line"></span><br><span class="line">SELECT * FROM t1, t2</span><br><span class="line">  WHERE (t1.key1 IN (1,2) OR t1.key2 LIKE &#x27;value%&#x27;)</span><br><span class="line">  AND t2.key1 = t1.some_col;</span><br><span class="line"></span><br><span class="line">SELECT * FROM t1, t2</span><br><span class="line">  WHERE t1.key1 = 1</span><br><span class="line">  AND (t2.key1 = t1.some_col OR t2.key2 = t1.some_col2);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你的查询有一个带有深度AND&#x2F;OR嵌套的复杂WHERE子句，并且MySQL没有选择最佳计划，请尝试使用以下恒等转换来分发术语：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(x AND y) OR z =&gt; (x OR z) AND (y OR z)</span><br><span class="line">(x OR y) AND z =&gt; (x AND z) OR (y AND z)</span><br></pre></td></tr></table></figure>

<p>在EXPLAIN输出中，Index Merge方法在type列中显示为index_merge。在本例中，key列包含使用的索引列表，key_len包含这些索引的最长键部分列表。</p>
<p>索引合并访问方法有几种算法，它们显示在EXPLAIN输出的Extra字段中：</p>
<ul>
<li>intersect：对多个and条件生效</li>
<li>union：对多个or条件生效</li>
<li>sort_union：sort-union算法和union算法之间的区别在于，sort-union算法必须首先获取所有行的行ID，并在返回任何行之前对其进行排序。</li>
</ul>
<p>索引合并的使用取决于optimizer_switch系统变量的index_merge、index_merge_intersection、index_merge_union和index_merge_sort_union标志的值。默认情况下，所有这些标志都是打开的。</p>
<h4 id="hash-join"><a href="#hash-join" class="headerlink" title="hash join"></a>hash join</h4><p>默认情况下，MySQL尽可能使用哈希连接。可以使用BNL和NO_BNL优化器提示之一来控制是否使用散列连接。</p>
<p>hash join比嵌套join快的多，首先创建hash表，在循环另一个表进行hash，判断是否相等</p>
<p>可以使用join_buffer_size系统变量控制哈希连接的内存使用量;哈希连接使用的内存量不能超过此值。当哈希连接所需的内存超过可用量时，MySQL会使用磁盘上的文件来处理。如果发生这种情况，您应该注意，如果哈希连接无法容纳内存并且它创建的文件比为open_files_limit设置的文件多，则连接可能不会成功。要避免此类问题，请进行以下更改之一：</p>
<ul>
<li>增加join_buffer_size，使哈希连接不会溢出到磁盘。</li>
<li>增加open_files_limit。</li>
</ul>
<h4 id="成本模型"><a href="#成本模型" class="headerlink" title="成本模型"></a>成本模型</h4><p>MySQL成本模型（Cost Model）是MySQL查询优化器（Query Optimizer）用来评估不同查询执行计划的成本（Cost）的一种机制。成本模型通过估算每种执行计划所需的资源（如CPU、I&#x2F;O、内存等）来选择最优的执行计划。</p>
<p>MySQL的成本模型主要考虑以下几个方面：</p>
<ol>
<li>CPU成本：<ul>
<li>评估执行计划中每个操作（如比较、计算、排序等）所需的CPU时间。</li>
<li>例如，WHERE子句中的条件计算、JOIN操作中的匹配等。</li>
</ul>
</li>
<li>I&#x2F;O成本：<ul>
<li>评估执行计划中每个操作所需的磁盘I&#x2F;O操作次数。</li>
<li>例如，全表扫描、索引扫描、数据页的读取等。</li>
<li>I&#x2F;O成本通常是最主要的成本因素之一，因为磁盘I&#x2F;O操作相对较慢。</li>
</ul>
</li>
<li>内存成本：<ul>
<li>评估执行计划中每个操作所需的内存使用量。</li>
<li>例如，排序操作、临时表的创建等。</li>
</ul>
</li>
<li>网络成本：<ul>
<li>评估执行计划中每个操作所需的网络传输量。</li>
<li>例如，分布式查询中跨节点的数据传输。</li>
</ul>
</li>
<li>数据分布：<ul>
<li>评估数据的分布情况，如表的大小、索引的覆盖率等。</li>
<li>数据分布会影响I&#x2F;O操作的次数和效率。</li>
</ul>
</li>
</ol>
<p>其中大部分的成本都是固定的，比如CPU成本、IO成本、内存成本。这个是根据你服务器的配置决定的。</p>
<p>所以，主要关注的是数据分布。</p>
<p>MySQL的数据分布使用<code>直方图</code>来记录。</p>
<h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h4><p><code>column_statistics数据字典表</code>存储有关列值的<code>直方图</code>统计信息，供优化器在构造查询执行计划时使用。要执行直方图管理，请使用<code>ANALYZE TABLE</code>语句。</p>
<ul>
<li>该表包含除几何类型（空间数据）和JSON之外的所有数据类型的列的统计信息。</li>
<li>该表是持久的，因此不必在每次服务器启动时都创建列统计信息。</li>
<li>服务器对表执行更新，用户不执行。</li>
</ul>
<p>用户不能直接访问<code>column_statistics</code>表，因为它是<code>数据字典</code>的一部分。直方图信息可使用 <code>INFORMATION_SCHEMA.COLUMN_STATISTICS</code> 获得，它是作为数据字典表上的视图实现的。<code>COLUMN_STATISTICS</code>包含以下列：</p>
<ul>
<li>SCHEMA_NAME、TABLE_NAME、COLUMN_NAME：应用统计信息的模式、表和列的名称。</li>
<li>HISTORIO：描述列统计信息的JSON值，存储为直方图。</li>
</ul>
<p>直方图实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;buckets&quot;: [</span><br><span class="line">    [</span><br><span class="line">      1,</span><br><span class="line">      0.3333333333333333</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      2,</span><br><span class="line">      0.6666666666666666</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      3,</span><br><span class="line">      1</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  &quot;null-values&quot;: 0,</span><br><span class="line">  &quot;last-updated&quot;: &quot;2017-03-24 13:32:40.000000&quot;,</span><br><span class="line">  &quot;sampling-rate&quot;: 1,</span><br><span class="line">  &quot;histogram-type&quot;: &quot;singleton&quot;,</span><br><span class="line">  &quot;number-of-buckets-specified&quot;: 128,</span><br><span class="line">  &quot;data-type&quot;: &quot;int&quot;,</span><br><span class="line">  &quot;collation-id&quot;: 8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>buckets：直方图桶。桶结构取决于直方图类型。</li>
<li>null-values：一个介于0.0和1.0之间的数字，表示<code>SQL NULL</code>值的列值的分数。如果为0，则该列不包含NULL值。</li>
<li>last-updated：直方图生成时，以 <code>YYYY-MM-DD hh:mm:ss.uuuuuu</code> 格式的UTC值表示。</li>
<li>sampling-rate：0.0到1.0之间的数字，表示为创建直方图而采样的数据比例。值为1表示已读取所有数据（无采样）。</li>
<li>histogram-type：直方图类型：<ul>
<li>singleton：一个bucket表示列中的一个值。当列中的非重复值数量小于或等于生成直方图的<code>ANALYZE TABLE</code>语句中指定的存储桶数量时，将创建此直方图类型。</li>
<li>equi-height：一个桶表示一个值范围。当列中的非重复值数量大于生成直方图的<code>ANALYZE TABLE</code>语句中指定的存储桶数量时，将创建此直方图类型。</li>
</ul>
</li>
<li>number-of-buckets-specified：生成直方图的<code>ANALYZE TABLE</code>语句中指定的<code>桶数</code>。</li>
<li>data-type：此直方图包含的数据类型。在将直方图从持久性存储器阅读和解析到内存中时，这是需要的。该值是int、uint（无符号整数）、double、decimal、datetime或string（包括字符和二进制字符串）之一。</li>
<li>collation-id：直方图数据的归类ID。当数据类型值是字符串时，它最有意义。值对应于信息架构<code>COLLATIONS</code>表中的ID列值。</li>
</ul>
<p>直方图统计信息主要用于非索引列。将索引添加到直方图统计信息适用的列还可以帮助优化器进行行估计。</p>
<p>优化器更喜欢范围优化器的行估计，而不是从直方图统计信息中获得的行估计。如果优化器确定范围优化器适用，则不使用直方图统计信息。</p>
<p>对于已建立索引的列，可以使用索引潜水(index dives)获得行估计值以进行相等比较。</p>
<p>在某些情况下，使用直方图统计信息可能不会改善查询执行（例如，如果统计信息过期）。要检查是否是这种情况，请使用<code>ANALYZE TABLE</code>重新生成直方图统计信息，然后再次运行查询。</p>
<p>这么看这些概念内容，可能很难理解直方图到底是干啥的，下面给出一个例子方便理解。</p>
<h5 id="直方图示例"><a href="#直方图示例" class="headerlink" title="直方图示例"></a>直方图示例</h5><h2 id="虽然直方图的字段很多，但其核心的字段只有几个"><a href="#虽然直方图的字段很多，但其核心的字段只有几个" class="headerlink" title="虽然直方图的字段很多，但其核心的字段只有几个"></a>虽然直方图的字段很多，但其核心的字段只有几个</h2><p>创建一个测试表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_a(id <span class="type">int</span> auto_increment,a <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span>, b <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>, <span class="keyword">primary</span> key(id));</span><br></pre></td></tr></table></figure>

<p>接下来我们插入几个数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_a (a, b) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;A1&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;B2&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;C3&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;D4&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;E5&#x27;</span>),</span><br><span class="line">(<span class="number">6</span>, <span class="string">&#x27;F6&#x27;</span>),</span><br><span class="line">(<span class="number">7</span>, <span class="string">&#x27;G7&#x27;</span>),</span><br><span class="line">(<span class="number">8</span>, <span class="string">&#x27;H8&#x27;</span>),</span><br><span class="line">(<span class="number">9</span>, <span class="string">&#x27;I9&#x27;</span>),</span><br><span class="line">(<span class="number">10</span>, <span class="string">&#x27;J10&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>接下来生成直方图信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE <span class="keyword">TABLE</span> test_a <span class="keyword">update</span>  HISTOGRAM <span class="keyword">ON</span> a <span class="keyword">WITH</span> <span class="number">5</span> BUCKETS;</span><br></pre></td></tr></table></figure>

<p>查询直方图信息。这里的<code>SCHEMA_NAME</code>是数据库的名称，TABLE_NAME是数据表的名称。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.COLUMN_STATISTICS <span class="keyword">where</span> SCHEMA_NAME <span class="operator">=</span> <span class="string">&#x27;test1&#x27;</span> <span class="keyword">and</span> TABLE_NAME <span class="operator">=</span> <span class="string">&#x27;test_a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>查询结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+-------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> SCHEMA_NAME <span class="operator">|</span> TABLE_NAME <span class="operator">|</span> COLUMN_NAME <span class="operator">|</span> HISTOGRAM</span><br><span class="line">                                                                                                                                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+-------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> test1       <span class="operator">|</span> test_a     <span class="operator">|</span> a           <span class="operator">|</span> &#123;&quot;buckets&quot;: [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0.2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">0.4</span>, <span class="number">2</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">0.6</span>, <span class="number">2</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">0.8</span>, <span class="number">2</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">1.0</span>, <span class="number">2</span>]], &quot;data-type&quot;: &quot;int&quot;, &quot;auto-update&quot;: <span class="literal">false</span>, &quot;null-values&quot;: <span class="number">0.0</span>, &quot;collation-id&quot;: <span class="number">8</span>, &quot;last-updated&quot;: &quot;2025-01-25 13:01:57.129967&quot;, &quot;sampling-rate&quot;: <span class="number">1.0</span>, &quot;histogram-type&quot;: &quot;equi-height&quot;, &quot;number-of-buckets-specified&quot;: <span class="number">5</span>&#125; <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+-------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>我们来看一下直方图的信息。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;buckets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">0.4</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">0.6</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">7</span><span class="punctuation">,</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">9</span><span class="punctuation">,</span> <span class="number">10</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;data-type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;int&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;auto-update&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;null-values&quot;</span><span class="punctuation">:</span> <span class="number">0.0</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;collation-id&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;last-updated&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2025-01-25 13:01:57.129967&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;sampling-rate&quot;</span><span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;histogram-type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;equi-height&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;number-of-buckets-specified&quot;</span><span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>buckets：直方图桶。桶结构取决于直方图类型。</li>
<li>null-values：0.0,表示没有null值，这是因为我们使用了<code>not null</code>声明字段。</li>
<li>last-updated：更新时间，没啥好说的。</li>
<li>sampling-rate：1.0 获取了所有数据，因为我们只有10条数据，很少。</li>
<li>histogram-type：直方图类型：equi-height，因为<code>a</code>列有10个值，都不重复，而桶数量我们用的是5，所以生成了这个类型。</li>
<li>number-of-buckets-specified：生成直方图的<code>ANALYZE TABLE</code>语句中指定的<code>桶数</code>。</li>
<li>data-type：列a是int类型</li>
<li>collation-id：直方图数据的归类ID。当数据类型值是字符串时，它最有意义。值对应于信息架构<code>COLLATIONS</code>表中的ID列值。</li>
</ul>
<p>桶里面有4个数据</p>
<ul>
<li>最小值</li>
<li>最大值</li>
<li>密度</li>
<li>高度</li>
</ul>
<p>比如，查询语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_a <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><code>a = 5</code>的数据在第三个桶里面，最小值5，最大值6，密度0.6，高度2.</p>
<p>根据计算公式<code>预估行数 = 密度 * 高度</code>来计算0.6 * 2，预估行数就是1.2，也就是1-2行。</p>
<p><img src="https://thepatterraining.github.io/images/mysql/mysql2-6.jpg" alt="架构"></p>
<p>可以看到查询计划里面的rows是10行，这是因为类型是全表扫描，但是后面的<code>filtered</code>字段是10，表示的意思是会过滤出来 <code>10 * 10% = 10 * 0.1 = 1</code>行。</p>
<p>也就是最终会查出1行结果。</p>
<p>通常来说，对于没有索引的列，MySQL就是这样来预估行数的，并且通过这个结果来进行选择执行路线。</p>
<h3 id="执行路线选择"><a href="#执行路线选择" class="headerlink" title="执行路线选择"></a>执行路线选择</h3><p>什么叫路线选择呢，还是上面那个表，我们现在有如下SQL语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,b <span class="keyword">from</span> test_a <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> b <span class="operator">=</span> <span class="string">&#x27;A1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>根据表数据，其实我们知道，查出来的结果还是1条。但是对于mysql来说，却有不同的执行方式。</p>
<p>第一种执行方式，先查<code>a=1</code>在查询<code>b=&#39;A1&#39;</code>的数据。执行树如下。</p>
<p><img src="https://thepatterraining.github.io/images/mysql/mysql2-7.jpg" alt="架构"></p>
<p>第二种执行方式，先查<code>b=&#39;A1&#39;</code>在查询 <code>a=1</code>。执行树如下。</p>
<p><img src="https://thepatterraining.github.io/images/mysql/mysql2-8.jpg" alt="架构"></p>
<p>目前看着这两种方式都没啥问题。</p>
<p>但是，我们再插入一条数据呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_a (a, b) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">11</span>, <span class="string">&#x27;A1&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这样我们就知道了，方案1， 会直接过滤出1行数据，然后在过滤，这样显然比方案2更好。</p>
<p>因为方案2会先查出2条数据，再次过滤。</p>
<p>这就是不同的执行路线带来的性能区别。当然了，我们这里的例子只是打个比方，实际上<code>谓词下推</code>优化以后，这两个条件都是和扫描表一起执行的。</p>
<p>这个例子只是让你明白不同的路线选择而已。</p>
<p>对于<code>join</code>查询来说，会有更多的选择。</p>
<h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>以上就是今天的内容了，大家有任何疑问可以打在评论区，一起交流～</p>
<p>关注我发送“MySQL知识图谱”领取完整的MySQL学习路线。</p>
<p>发送“电子书”即可领取价值上千的电子书资源。</p>
<p>部分电子书如图所示。</p>
<p><img src="https://thepatterraining.github.io/images/bottom1.png" alt="概念学习"></p>
<p><img src="https://thepatterraining.github.io/images/bottom2.png" alt="概念学习"></p>
<p><img src="https://thepatterraining.github.io/images/bottom3.png" alt="概念学习"></p>
<p><img src="https://thepatterraining.github.io/images/bottom4.png" alt="概念学习"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQLDML%E7%AF%87.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQLDML%E7%AF%87.html" class="post-title-link" itemprop="url">MySQL零基础教程基础篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-26 10:12:47" itemprop="dateCreated datePublished" datetime="2023-04-26T10:12:47+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-27 15:52:17" itemprop="dateModified" datetime="2025-02-27T15:52:17+08:00">2025-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMU15445/" itemprop="url" rel="index"><span itemprop="name">CMU15445</span></a>
                </span>
            </span>

          
            <span id="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQLDML%E7%AF%87.html" class="post-meta-item leancloud_visitors" data-flag-title="MySQL零基础教程基础篇" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQLDML%E7%AF%87.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQLDML%E7%AF%87.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL零基础教程基础篇"><a href="#MySQL零基础教程基础篇" class="headerlink" title="MySQL零基础教程基础篇"></a>MySQL零基础教程基础篇</h1><p>大家好，我是大头，98年，职高毕业，上市公司架构师，大厂资深开发，管理过10人团队，我是如何做到的呢？</p>
<p>这离不开持续学习的能力，而其中最重要的当然是数据库技术了！</p>
<p>对于所有开发来说，都离不开数据库，因为所有的数据都是要存储的。</p>
<p>关注我一起学习！文末有惊喜哦！</p>
<p>基础篇的内容大致如下图所示。</p>
<p><img src="https://thepatterraining.github.io/images/mysql/mysql1-1.png" alt="概念学习"></p>
<h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><p>介绍完概念以后，我们可以来看看SQL语句了。SQL语句通常由三类组成。</p>
<p>数据定义 DDL</p>
<ul>
<li>CREATE 创建数据库或数据库对象</li>
<li>ALTER 对数据库或数据库对象进行修改</li>
<li>DROP 删除数据库或数据库对象<br>数据操纵 DML</li>
<li>SELECT 从表或视图中检索数据</li>
<li>INSERT 将数据插入到表或视图中</li>
<li>UPDATE 修改表或视图中的数据</li>
<li>DELETE 从表或视图中删除数据<br>数据控制 DCL</li>
<li>GRANT 用于授予权限</li>
<li>REVOKE 用于收回权限</li>
</ul>
<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p>MySQL 中的 DML（数据操纵语言，Data Manipulation Language） 语句用于对数据库中的数据进行操作，主要包括数据的插入、更新、删除和查询。DML 语句是数据库操作中最常用的语句类型。</p>
<h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><p>插入数据使用<code>insert</code>指令，可以往创建好的一张表里面插入数据，支持多种插入方式。</p>
<p>最常用的方式是<code>insert  values</code>，这种方式也支持批量插入数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name[(col_name)] <span class="keyword">values</span> ();</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (id, name, department, salary)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;John Doe&#x27;</span>, <span class="string">&#x27;IT&#x27;</span>, <span class="number">50000</span>);</span><br></pre></td></tr></table></figure>

<p>还有一种方式是 <code>insert  set</code>。这种方式不支持批量插入。这种方式以键值对的形式插入数据，适用于插入单行数据。这种方式在插入单行数据时更加直观，尤其是当列名较多时。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name</span><br><span class="line"><span class="keyword">set</span> col_name <span class="operator">=</span> <span class="string">&#x27;值&#x27;</span>, col_name <span class="operator">=</span> <span class="string">&#x27;值&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>还是刚才的插入示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (id, name, department, salary)</span><br><span class="line"><span class="keyword">set</span> id <span class="operator">=</span> <span class="number">1</span>，name <span class="operator">=</span> <span class="string">&#x27;John Doe&#x27;</span>，department<span class="operator">=</span><span class="string">&#x27;IT&#x27;</span>，salary<span class="operator">=</span><span class="number">50000</span>；</span><br></pre></td></tr></table></figure>

<p>还有一种方式是<code>insert  select</code>方式，这种方式适合快速复制表数据，将查询出来的数据插入到另外一个表里面。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure>

<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>可以使用<code>delete from</code>指令来删除已经插入的数据。如果不加where条件的话，就是删除全表数据。</p>
<p>删除数据操作一定要慎重！！！</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>示例：删除刚才插入到表<code>employees</code>的<code>ID=1</code>的数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> employees <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>除了使用delete指令以外，还可以使用<code>TRUNCATE</code>指令，这个指令可以删除全表的数据，并且新的数据id自增从1开始。删除全表数据的话，该指令通常更快速。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">TABLE</span> table_name</span><br></pre></td></tr></table></figure>

<h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><p>当插入的数据内容需要修改或者说更新的时候，则可以使用<code>update set</code>指令进行修改。修改操作可以使用where条件来选择要修改的数据，不加where条件则会更新所有数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> table_name <span class="keyword">set</span> col_name <span class="operator">=</span> <span class="string">&#x27;值&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>示例：将刚才插入的数据部门修改一下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> employees <span class="keyword">set</span> department <span class="operator">=</span> <span class="string">&#x27;Market&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h4><p>数据查询语句是最复杂的语句，这里只是介绍，想要完全用明白，需要大量的实践。</p>
<h5 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h5><p>select用于查询数据表里面插入的数据。</p>
<p><code>*</code>代表查询所有字段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>

<h5 id="列的选择与指定"><a href="#列的选择与指定" class="headerlink" title="列的选择与指定"></a>列的选择与指定</h5><p>如果查询指定字段，则使用字段名称代替<code>*</code>。</p>
<p>实际开发中不推荐查询所有字段，推荐查询需要的字段，可以提升查询速度。</p>
<ul>
<li>如果查询的字段正好是索引，那么可以触发覆盖索引</li>
<li>如果查询的字段过多，会增加网络传输消耗</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name1,col_name2... <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>

<h5 id="定义别名"><a href="#定义别名" class="headerlink" title="定义别名"></a>定义别名</h5><p>可以给字段和表定义别名，通过<code>as</code>指令实现。别名可以解决一些字段名冲突或者字段名过长的问题。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name <span class="keyword">as</span> alias <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>

<p>示例：department字段给一个别名是depart</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id，department <span class="keyword">as</span> depart <span class="keyword">from</span> employees</span><br></pre></td></tr></table></figure>

<h5 id="where条件"><a href="#where条件" class="headerlink" title="where条件"></a>where条件</h5><p>通过where关键字来进行条件筛选，可以选择出符合条件的数据。</p>
<p>比如当前用户表user有数据如下：以下数据均为随机生成，非真实数据。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#104;&#x61;&#x6e;&#x67;&#x73;&#97;&#x6e;&#64;&#x65;&#x78;&#x61;&#x6d;&#112;&#108;&#x65;&#46;&#99;&#111;&#109;">&#x7a;&#104;&#x61;&#x6e;&#x67;&#x73;&#97;&#x6e;&#64;&#x65;&#x78;&#x61;&#x6d;&#112;&#108;&#x65;&#46;&#99;&#111;&#109;</a></td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#x6c;&#x69;&#x73;&#x69;&#x40;&#101;&#120;&#97;&#109;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#x6d;">&#x6c;&#x69;&#x73;&#x69;&#x40;&#101;&#120;&#97;&#109;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>003</td>
<td>王五</td>
<td>男</td>
<td>13700009012</td>
<td><a href="mailto:&#119;&#97;&#x6e;&#103;&#x77;&#x75;&#64;&#x65;&#x78;&#97;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#x63;&#111;&#x6d;">&#119;&#97;&#x6e;&#103;&#x77;&#x75;&#64;&#x65;&#x78;&#97;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>004</td>
<td>赵六</td>
<td>女</td>
<td>13600003456</td>
<td><a href="mailto:&#122;&#104;&#x61;&#111;&#108;&#105;&#117;&#64;&#x65;&#x78;&#97;&#x6d;&#x70;&#108;&#x65;&#x2e;&#99;&#x6f;&#x6d;">&#122;&#104;&#x61;&#111;&#108;&#105;&#117;&#64;&#x65;&#x78;&#97;&#x6d;&#x70;&#108;&#x65;&#x2e;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>005</td>
<td>孙七</td>
<td>男</td>
<td>13500007890</td>
<td><a href="mailto:&#115;&#117;&#x6e;&#113;&#x69;&#x40;&#101;&#120;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#x6f;&#109;">&#115;&#117;&#x6e;&#113;&#x69;&#x40;&#101;&#120;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>006</td>
<td>周八</td>
<td>女</td>
<td>13400001234</td>
<td><a href="mailto:&#x7a;&#x68;&#x6f;&#117;&#98;&#97;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#x65;&#46;&#99;&#x6f;&#109;">&#x7a;&#x68;&#x6f;&#117;&#98;&#97;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#x65;&#46;&#99;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>007</td>
<td>吴九</td>
<td>男</td>
<td>13300005678</td>
<td><a href="mailto:&#x77;&#117;&#106;&#x69;&#117;&#x40;&#x65;&#120;&#x61;&#x6d;&#x70;&#108;&#101;&#x2e;&#99;&#x6f;&#109;">&#x77;&#117;&#106;&#x69;&#117;&#x40;&#x65;&#120;&#x61;&#x6d;&#x70;&#108;&#101;&#x2e;&#99;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>008</td>
<td>郑十</td>
<td>女</td>
<td>13200009012</td>
<td><a href="mailto:&#122;&#104;&#x65;&#x6e;&#x67;&#115;&#104;&#x69;&#64;&#101;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;">&#122;&#104;&#x65;&#x6e;&#x67;&#115;&#104;&#x69;&#64;&#101;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>009</td>
<td>钱伯</td>
<td>男</td>
<td>13100003456</td>
<td><a href="mailto:&#113;&#105;&#x61;&#110;&#98;&#x6f;&#64;&#x65;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;">&#113;&#105;&#x61;&#110;&#98;&#x6f;&#64;&#x65;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>010</td>
<td>孔仲</td>
<td>女</td>
<td>13000007890</td>
<td><a href="mailto:&#107;&#111;&#x6e;&#103;&#x7a;&#104;&#111;&#x6e;&#x67;&#64;&#x65;&#120;&#97;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;">&#107;&#111;&#x6e;&#103;&#x7a;&#104;&#111;&#x6e;&#x67;&#64;&#x65;&#120;&#97;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;</a></td>
</tr>
</tbody></table>
<p>这个时候我们需要查询出张三的用户信息，而不是将这10个数据都查询出来到程序里在筛选出张三的数据。</p>
<p>可以使用如下sql完成。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>; </span><br></pre></td></tr></table></figure>

<p>这个sql会把name字段中等于‘张三’的数据查询出来。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#x68;&#x61;&#110;&#x67;&#x73;&#97;&#x6e;&#x40;&#101;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;">&#x7a;&#x68;&#x61;&#110;&#x67;&#x73;&#97;&#x6e;&#x40;&#101;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;</a></td>
</tr>
</tbody></table>
<p>where条件支持的类型如下：</p>
<ul>
<li>比较操作符</li>
</ul>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td>等于</td>
</tr>
<tr>
<td><code>&lt;&gt;</code></td>
<td>不等于（也可用<code>!=</code>）</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
</tr>
</tbody></table>
<ul>
<li><p>逻辑操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>AND</code></td>
<td>逻辑与（两个条件都满足）</td>
</tr>
<tr>
<td><code>OR</code></td>
<td>逻辑或（至少一个条件满足）</td>
</tr>
<tr>
<td><code>NOT</code></td>
<td>逻辑非（对条件取反）</td>
</tr>
</tbody></table>
</li>
<li><p>范围操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>BETWEEN...AND...</code></td>
<td>在指定范围内（包括边界值）</td>
</tr>
<tr>
<td><code>NOT BETWEEN</code></td>
<td>不在指定范围内</td>
</tr>
</tbody></table>
</li>
<li><p>列表操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>IN</code></td>
<td>在指定的列表中</td>
</tr>
<tr>
<td><code>NOT IN</code></td>
<td>不在指定的列表中</td>
</tr>
</tbody></table>
</li>
<li><p>模糊匹配操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>LIKE</code></td>
<td>模糊匹配（使用<code>%</code>和<code>_</code>作为通配符）</td>
</tr>
<tr>
<td><code>NOT LIKE</code></td>
<td>不匹配指定模式</td>
</tr>
</tbody></table>
</li>
<li><p>空值操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>IS NULL</code></td>
<td>判断是否为<code>NULL</code></td>
</tr>
<tr>
<td><code>IS NOT NULL</code></td>
<td>判断是否不为<code>NULL</code></td>
</tr>
</tbody></table>
</li>
<li><p>其他操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>EXISTS</code></td>
<td>检查子查询是否存在结果</td>
</tr>
<tr>
<td><code>NOT EXISTS</code></td>
<td>检查子查询是否不存在结果</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="替换查询结果集中的数据"><a href="#替换查询结果集中的数据" class="headerlink" title="替换查询结果集中的数据"></a>替换查询结果集中的数据</h5><p>可以使用if条件来进行结果的判定，比如性别，数据库里面存的可能是1代表男，2代表女。如果要查询出来男和女的话，就可以直接通过sql处理。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> </span><br><span class="line"><span class="keyword">when</span> 条件<span class="number">1</span> <span class="keyword">then</span> 表达式<span class="number">1</span></span><br><span class="line"><span class="keyword">when</span> 条件<span class="number">2</span> <span class="keyword">then</span> 表达式<span class="number">2</span></span><br><span class="line"><span class="keyword">else</span> 表达式</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">as</span> alias</span><br></pre></td></tr></table></figure>

<p>示例：性别转换。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="keyword">CASE</span> </span><br><span class="line">        <span class="keyword">WHEN</span> gender <span class="operator">=</span> <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">&#x27;男&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> gender <span class="operator">=</span> <span class="number">2</span> <span class="keyword">THEN</span> <span class="string">&#x27;女&#x27;</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">&#x27;未知&#x27;</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> 性别</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<h4 id="计算列值"><a href="#计算列值" class="headerlink" title="计算列值"></a>计算列值</h4><p>可以直接计算将字段的值进行加减乘除运算。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name <span class="operator">+</span> <span class="number">100</span> <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>

<h4 id="from-子句与多表连接查询"><a href="#from-子句与多表连接查询" class="headerlink" title="from 子句与多表连接查询"></a>from 子句与多表连接查询</h4><h5 id="交叉连接，笛卡尔积"><a href="#交叉连接，笛卡尔积" class="headerlink" title="交叉连接，笛卡尔积"></a>交叉连接，笛卡尔积</h5><p>交叉连接可以连接两个表，产生两个表的笛卡尔积作为结果。</p>
<p>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_namme1 <span class="keyword">cross</span> <span class="keyword">join</span> table_name2</span><br></pre></td></tr></table></figure>
<p>可以直接简写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name1,table_name2;</span><br></pre></td></tr></table></figure>

<p>示例：获取两个表的交叉连接。</p>
<p>假设有表user如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#x68;&#x61;&#110;&#x67;&#x73;&#97;&#110;&#x40;&#101;&#x78;&#97;&#109;&#x70;&#108;&#101;&#x2e;&#99;&#111;&#109;">&#x7a;&#x68;&#x61;&#110;&#x67;&#x73;&#97;&#110;&#x40;&#101;&#x78;&#97;&#109;&#x70;&#108;&#101;&#x2e;&#99;&#111;&#109;</a></td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#x69;&#x73;&#105;&#x40;&#x65;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;">&#108;&#x69;&#x73;&#105;&#x40;&#x65;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;</a></td>
</tr>
</tbody></table>
<p>还有表user_account存储用户的账户余额信息如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
</tbody></table>
<p>使用如下sql语句获取交叉连接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>,user_account;</span><br></pre></td></tr></table></figure>

<p>结果如下：也就是用户表数据001和用户账户001产生一条数据，和用户账户002产生一条数据，用户数据002同样。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
<th>ID2</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#x68;&#97;&#x6e;&#x67;&#x73;&#x61;&#110;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;">&#x7a;&#x68;&#97;&#x6e;&#x67;&#x73;&#x61;&#110;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;</a></td>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#122;&#104;&#x61;&#x6e;&#x67;&#115;&#97;&#x6e;&#64;&#x65;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#x6f;&#109;">&#122;&#104;&#x61;&#x6e;&#x67;&#115;&#97;&#x6e;&#64;&#x65;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#x6f;&#109;</a></td>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#105;&#x73;&#105;&#x40;&#101;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#109;">&#108;&#105;&#x73;&#105;&#x40;&#101;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#109;</a></td>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#105;&#115;&#105;&#64;&#101;&#x78;&#x61;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#111;&#x6d;">&#108;&#105;&#115;&#105;&#64;&#101;&#x78;&#x61;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#111;&#x6d;</a></td>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
</tbody></table>
<h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>内连接返回两个表中匹配的记录。只有当两个表中的记录满足连接条件时，才会出现在结果集中。可以理解为两个表的交集。</p>
<p>连接的时候，<code>on</code>就类似于where条件，只不过仅仅在连接表数据的时候生效。内连接返回两个表都满足这个条件的交集。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name <span class="keyword">from</span> table_name <span class="keyword">inner</span> <span class="keyword">join</span> table_name2 <span class="keyword">on</span> table_name.id <span class="operator">=</span> table_name2.t_id;</span><br></pre></td></tr></table></figure>

<p>示例：获取用户数据和用户账户数据的内连接。</p>
<p>假设有表user如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#104;&#x61;&#x6e;&#103;&#115;&#x61;&#110;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#108;&#101;&#46;&#99;&#x6f;&#x6d;">&#x7a;&#104;&#x61;&#x6e;&#103;&#115;&#x61;&#110;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#108;&#101;&#46;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#x6c;&#x69;&#x73;&#105;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#101;&#46;&#x63;&#x6f;&#x6d;">&#x6c;&#x69;&#x73;&#105;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#101;&#46;&#x63;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>003</td>
<td>王五</td>
<td>男</td>
<td>13700009012</td>
<td><a href="mailto:&#119;&#x61;&#110;&#103;&#119;&#x75;&#x40;&#x65;&#x78;&#x61;&#x6d;&#112;&#108;&#101;&#x2e;&#x63;&#x6f;&#x6d;">&#119;&#x61;&#110;&#103;&#119;&#x75;&#x40;&#x65;&#x78;&#x61;&#x6d;&#112;&#108;&#101;&#x2e;&#x63;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>004</td>
<td>赵六</td>
<td>女</td>
<td>13600003456</td>
<td><a href="mailto:&#122;&#x68;&#97;&#x6f;&#x6c;&#x69;&#117;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#109;">&#122;&#x68;&#97;&#x6f;&#x6c;&#x69;&#117;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>005</td>
<td>孙七</td>
<td>男</td>
<td>13500007890</td>
<td><a href="mailto:&#x73;&#117;&#x6e;&#x71;&#x69;&#64;&#101;&#120;&#97;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#109;">&#x73;&#117;&#x6e;&#x71;&#x69;&#64;&#101;&#120;&#97;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#109;</a></td>
</tr>
<tr>
<td>006</td>
<td>周八</td>
<td>女</td>
<td>13400001234</td>
<td><a href="mailto:&#x7a;&#x68;&#x6f;&#117;&#x62;&#97;&#64;&#x65;&#120;&#x61;&#109;&#112;&#x6c;&#x65;&#46;&#99;&#111;&#109;">&#x7a;&#x68;&#x6f;&#117;&#x62;&#97;&#64;&#x65;&#120;&#x61;&#109;&#112;&#x6c;&#x65;&#46;&#99;&#111;&#109;</a></td>
</tr>
<tr>
<td>007</td>
<td>吴九</td>
<td>男</td>
<td>13300005678</td>
<td><a href="mailto:&#119;&#117;&#106;&#105;&#x75;&#64;&#101;&#x78;&#97;&#109;&#112;&#108;&#x65;&#x2e;&#99;&#x6f;&#109;">&#119;&#117;&#106;&#105;&#x75;&#64;&#101;&#x78;&#97;&#109;&#112;&#108;&#x65;&#x2e;&#99;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>008</td>
<td>郑十</td>
<td>女</td>
<td>13200009012</td>
<td><a href="mailto:&#x7a;&#x68;&#x65;&#x6e;&#103;&#115;&#x68;&#x69;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#111;&#x6d;">&#x7a;&#x68;&#x65;&#x6e;&#103;&#115;&#x68;&#x69;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>009</td>
<td>钱伯</td>
<td>男</td>
<td>13100003456</td>
<td><a href="mailto:&#x71;&#105;&#x61;&#110;&#98;&#x6f;&#64;&#101;&#120;&#x61;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#x6d;">&#x71;&#105;&#x61;&#110;&#98;&#x6f;&#64;&#101;&#120;&#x61;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>010</td>
<td>孔仲</td>
<td>女</td>
<td>13000007890</td>
<td><a href="mailto:&#107;&#x6f;&#x6e;&#x67;&#x7a;&#x68;&#x6f;&#110;&#x67;&#64;&#101;&#120;&#x61;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#109;">&#107;&#x6f;&#x6e;&#x67;&#x7a;&#x68;&#x6f;&#110;&#x67;&#64;&#101;&#120;&#x61;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#109;</a></td>
</tr>
</tbody></table>
<p>还有表user_account存储用户的账户余额信息如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>003</td>
<td>011</td>
<td>20</td>
</tr>
</tbody></table>
<p>可以看到这两个表的交集就只有两条数据，也就是001和002，</p>
<p>使用如下sql语句获取交叉连接：</p>
<p><code>on user.id = user_account.user_id</code>这个条件代表只有当user表的id字段和user_account表的user_id字段相等的时候，才会有结果;</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">inner</span> <span class="keyword">join</span> user_account <span class="keyword">on</span> user.id <span class="operator">=</span> user_account.user_id;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
<th>ID2</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#122;&#x68;&#x61;&#110;&#103;&#x73;&#x61;&#110;&#64;&#101;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;">&#122;&#x68;&#x61;&#110;&#103;&#x73;&#x61;&#110;&#64;&#101;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;</a></td>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#x69;&#x73;&#x69;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#101;&#46;&#99;&#111;&#109;">&#108;&#x69;&#x73;&#x69;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#101;&#46;&#99;&#111;&#109;</a></td>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
</tbody></table>
<h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>外连接分为左连接和右连接，左连接返回内连接的结果+左表剩余的数据，右连接返回内连接的结果+右表剩余的数据。</p>
<p>左表就是 <code>join</code>左边的表，右表就是<code>join</code>右边的表。</p>
<p>左连接使用<code>left join</code>指令。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name <span class="keyword">from</span> table_name <span class="keyword">left</span> <span class="keyword">join</span> table_name2 <span class="keyword">on</span> table_name.id <span class="operator">=</span> table_name2.t_id;</span><br></pre></td></tr></table></figure>

<p>示例：获取用户表和用户账户表的左连接结果。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#122;&#x68;&#97;&#110;&#x67;&#115;&#97;&#110;&#64;&#x65;&#120;&#97;&#109;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#x6d;">&#122;&#x68;&#97;&#110;&#x67;&#115;&#97;&#110;&#64;&#x65;&#120;&#97;&#109;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#x6c;&#105;&#115;&#105;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#46;&#99;&#111;&#109;">&#x6c;&#105;&#115;&#105;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#46;&#99;&#111;&#109;</a></td>
</tr>
<tr>
<td>003</td>
<td>王五</td>
<td>男</td>
<td>13700009012</td>
<td><a href="mailto:&#119;&#x61;&#110;&#x67;&#119;&#x75;&#x40;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#119;&#x61;&#110;&#x67;&#119;&#x75;&#x40;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#101;&#x2e;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>004</td>
<td>赵六</td>
<td>女</td>
<td>13600003456</td>
<td><a href="mailto:&#122;&#x68;&#x61;&#111;&#x6c;&#105;&#x75;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;">&#122;&#x68;&#x61;&#111;&#x6c;&#105;&#x75;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>005</td>
<td>孙七</td>
<td>男</td>
<td>13500007890</td>
<td><a href="mailto:&#x73;&#x75;&#110;&#113;&#105;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#111;&#109;">&#x73;&#x75;&#110;&#113;&#105;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>006</td>
<td>周八</td>
<td>女</td>
<td>13400001234</td>
<td><a href="mailto:&#x7a;&#104;&#111;&#x75;&#x62;&#x61;&#64;&#101;&#120;&#97;&#109;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;">&#x7a;&#104;&#111;&#x75;&#x62;&#x61;&#64;&#101;&#120;&#97;&#109;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>007</td>
<td>吴九</td>
<td>男</td>
<td>13300005678</td>
<td><a href="mailto:&#x77;&#x75;&#x6a;&#105;&#x75;&#64;&#101;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#x6f;&#x6d;">&#x77;&#x75;&#x6a;&#105;&#x75;&#64;&#101;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>008</td>
<td>郑十</td>
<td>女</td>
<td>13200009012</td>
<td><a href="mailto:&#x7a;&#x68;&#x65;&#x6e;&#x67;&#115;&#x68;&#105;&#x40;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#109;">&#x7a;&#x68;&#x65;&#x6e;&#x67;&#115;&#x68;&#105;&#x40;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>009</td>
<td>钱伯</td>
<td>男</td>
<td>13100003456</td>
<td><a href="mailto:&#113;&#105;&#97;&#x6e;&#98;&#x6f;&#x40;&#101;&#120;&#x61;&#109;&#112;&#x6c;&#x65;&#x2e;&#x63;&#111;&#x6d;">&#113;&#105;&#97;&#x6e;&#98;&#x6f;&#x40;&#101;&#120;&#x61;&#109;&#112;&#x6c;&#x65;&#x2e;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>010</td>
<td>孔仲</td>
<td>女</td>
<td>13000007890</td>
<td><a href="mailto:&#107;&#x6f;&#x6e;&#x67;&#x7a;&#104;&#x6f;&#110;&#103;&#x40;&#x65;&#120;&#97;&#109;&#112;&#108;&#101;&#x2e;&#99;&#111;&#x6d;">&#107;&#x6f;&#x6e;&#x67;&#x7a;&#104;&#x6f;&#110;&#103;&#x40;&#x65;&#120;&#97;&#109;&#112;&#108;&#101;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
</tbody></table>
<p>还有表user_account存储用户的账户余额信息如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>003</td>
<td>011</td>
<td>20</td>
</tr>
</tbody></table>
<p>使用如下sql语句，可以看到，仅仅是<code>inner join</code>换成了<code>left join</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">left</span> <span class="keyword">join</span> user_account <span class="keyword">on</span> user.id <span class="operator">=</span> user_account.user_id;</span><br></pre></td></tr></table></figure>

<p>结果如下：在内连接的结果基础上，增加了<code>左表user表</code>剩下的8条数据，右表的字段内容则是<code>null</code>，代表没有对应字段的数据。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
<th>ID2</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#104;&#x61;&#110;&#103;&#x73;&#x61;&#110;&#64;&#x65;&#x78;&#97;&#x6d;&#112;&#108;&#x65;&#46;&#99;&#111;&#109;">&#x7a;&#104;&#x61;&#110;&#103;&#x73;&#x61;&#110;&#64;&#x65;&#x78;&#97;&#x6d;&#112;&#108;&#x65;&#46;&#99;&#111;&#109;</a></td>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#x6c;&#x69;&#x73;&#105;&#64;&#101;&#120;&#97;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">&#x6c;&#x69;&#x73;&#105;&#64;&#101;&#120;&#97;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#x6d;</a></td>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>003</td>
<td>王五</td>
<td>男</td>
<td>13700009012</td>
<td><a href="mailto:&#x77;&#97;&#110;&#103;&#x77;&#117;&#64;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#109;">&#x77;&#97;&#110;&#103;&#x77;&#117;&#64;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#109;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>004</td>
<td>赵六</td>
<td>女</td>
<td>13600003456</td>
<td><a href="mailto:&#122;&#104;&#x61;&#x6f;&#x6c;&#x69;&#117;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#x65;&#x2e;&#99;&#x6f;&#x6d;">&#122;&#104;&#x61;&#x6f;&#x6c;&#x69;&#117;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#x65;&#x2e;&#99;&#x6f;&#x6d;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>005</td>
<td>孙七</td>
<td>男</td>
<td>13500007890</td>
<td><a href="mailto:&#115;&#117;&#110;&#113;&#x69;&#64;&#101;&#x78;&#97;&#109;&#x70;&#108;&#101;&#46;&#99;&#111;&#x6d;">&#115;&#117;&#110;&#113;&#x69;&#64;&#101;&#x78;&#97;&#109;&#x70;&#108;&#101;&#46;&#99;&#111;&#x6d;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>006</td>
<td>周八</td>
<td>女</td>
<td>13400001234</td>
<td><a href="mailto:&#122;&#104;&#111;&#x75;&#98;&#97;&#x40;&#101;&#x78;&#97;&#109;&#112;&#x6c;&#101;&#46;&#99;&#111;&#109;">&#122;&#104;&#111;&#x75;&#98;&#97;&#x40;&#101;&#x78;&#97;&#109;&#112;&#x6c;&#101;&#46;&#99;&#111;&#109;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>007</td>
<td>吴九</td>
<td>男</td>
<td>13300005678</td>
<td><a href="mailto:&#x77;&#117;&#106;&#105;&#117;&#64;&#x65;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#x6d;">&#x77;&#117;&#106;&#105;&#117;&#64;&#x65;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#x6d;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>008</td>
<td>郑十</td>
<td>女</td>
<td>13200009012</td>
<td><a href="mailto:&#x7a;&#x68;&#x65;&#x6e;&#x67;&#115;&#x68;&#105;&#x40;&#x65;&#120;&#x61;&#109;&#112;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">&#x7a;&#x68;&#x65;&#x6e;&#x67;&#115;&#x68;&#105;&#x40;&#x65;&#120;&#x61;&#109;&#112;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#x6d;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>009</td>
<td>钱伯</td>
<td>男</td>
<td>13100003456</td>
<td><a href="mailto:&#113;&#x69;&#97;&#110;&#x62;&#x6f;&#64;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#46;&#x63;&#111;&#x6d;">&#113;&#x69;&#97;&#110;&#x62;&#x6f;&#64;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#46;&#x63;&#111;&#x6d;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>010</td>
<td>孔仲</td>
<td>女</td>
<td>13000007890</td>
<td><a href="mailto:&#x6b;&#x6f;&#110;&#103;&#122;&#104;&#x6f;&#x6e;&#x67;&#x40;&#x65;&#120;&#x61;&#109;&#x70;&#108;&#101;&#46;&#99;&#x6f;&#x6d;">&#x6b;&#x6f;&#110;&#103;&#122;&#104;&#x6f;&#x6e;&#x67;&#x40;&#x65;&#120;&#x61;&#109;&#x70;&#108;&#101;&#46;&#99;&#x6f;&#x6d;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
</tbody></table>
<p>右连接使用<code>right join</code>指令。<br>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name <span class="keyword">from</span> table_name <span class="keyword">right</span> <span class="keyword">join</span> table_name2 <span class="keyword">on</span> table_name.id <span class="operator">=</span> table_name2.t_id;</span><br></pre></td></tr></table></figure>

<p>示例：获取用户表和用户账户表的右连接结果。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#x68;&#97;&#110;&#x67;&#115;&#97;&#x6e;&#x40;&#x65;&#120;&#x61;&#109;&#112;&#108;&#x65;&#46;&#x63;&#111;&#109;">&#x7a;&#x68;&#97;&#110;&#x67;&#115;&#97;&#x6e;&#x40;&#x65;&#120;&#x61;&#109;&#112;&#108;&#x65;&#46;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#x69;&#x73;&#105;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#109;">&#108;&#x69;&#x73;&#105;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>003</td>
<td>王五</td>
<td>男</td>
<td>13700009012</td>
<td><a href="mailto:&#x77;&#x61;&#110;&#x67;&#x77;&#117;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#46;&#x63;&#111;&#x6d;">&#x77;&#x61;&#110;&#x67;&#x77;&#117;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#46;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>004</td>
<td>赵六</td>
<td>女</td>
<td>13600003456</td>
<td><a href="mailto:&#122;&#x68;&#97;&#111;&#x6c;&#x69;&#117;&#64;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#x65;&#x2e;&#x63;&#111;&#x6d;">&#122;&#x68;&#97;&#111;&#x6c;&#x69;&#117;&#64;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#x65;&#x2e;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>005</td>
<td>孙七</td>
<td>男</td>
<td>13500007890</td>
<td><a href="mailto:&#115;&#117;&#110;&#113;&#x69;&#64;&#x65;&#x78;&#x61;&#109;&#112;&#108;&#x65;&#46;&#x63;&#111;&#109;">&#115;&#117;&#110;&#113;&#x69;&#64;&#x65;&#x78;&#x61;&#109;&#112;&#108;&#x65;&#46;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>006</td>
<td>周八</td>
<td>女</td>
<td>13400001234</td>
<td><a href="mailto:&#x7a;&#104;&#111;&#x75;&#x62;&#97;&#x40;&#x65;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#111;&#109;">&#x7a;&#104;&#111;&#x75;&#x62;&#97;&#x40;&#x65;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>007</td>
<td>吴九</td>
<td>男</td>
<td>13300005678</td>
<td><a href="mailto:&#119;&#x75;&#x6a;&#105;&#x75;&#64;&#101;&#120;&#97;&#x6d;&#112;&#108;&#101;&#46;&#x63;&#x6f;&#109;">&#119;&#x75;&#x6a;&#105;&#x75;&#64;&#101;&#120;&#97;&#x6d;&#112;&#108;&#101;&#46;&#x63;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>008</td>
<td>郑十</td>
<td>女</td>
<td>13200009012</td>
<td><a href="mailto:&#x7a;&#104;&#101;&#110;&#103;&#115;&#x68;&#105;&#64;&#101;&#x78;&#x61;&#x6d;&#112;&#108;&#101;&#x2e;&#99;&#111;&#x6d;">&#x7a;&#104;&#101;&#110;&#103;&#115;&#x68;&#105;&#64;&#101;&#x78;&#x61;&#x6d;&#112;&#108;&#101;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>009</td>
<td>钱伯</td>
<td>男</td>
<td>13100003456</td>
<td><a href="mailto:&#113;&#105;&#97;&#x6e;&#98;&#111;&#64;&#x65;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#101;&#46;&#99;&#111;&#x6d;">&#113;&#105;&#97;&#x6e;&#98;&#111;&#64;&#x65;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#101;&#46;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>010</td>
<td>孔仲</td>
<td>女</td>
<td>13000007890</td>
<td><a href="mailto:&#107;&#111;&#110;&#103;&#x7a;&#x68;&#111;&#110;&#103;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;">&#107;&#111;&#110;&#103;&#x7a;&#x68;&#111;&#110;&#103;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
</tbody></table>
<p>还有表user_account存储用户的账户余额信息如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>003</td>
<td>011</td>
<td>20</td>
</tr>
</tbody></table>
<p>使用如下sql语句，可以看到，仅仅是<code>left join</code>换成了<code>right join</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">right</span> <span class="keyword">join</span> user_account <span class="keyword">on</span> user.id <span class="operator">=</span> user_account.user_id;</span><br></pre></td></tr></table></figure>

<p>结果如下：在内连接的结果基础上，增加了<code>右表user_account表</code>剩下的1条数据，左表的字段内容则是<code>null</code>，代表没有对应字段的数据。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
<th>ID2</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#x68;&#97;&#x6e;&#103;&#115;&#97;&#x6e;&#x40;&#101;&#x78;&#x61;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;">&#x7a;&#x68;&#97;&#x6e;&#103;&#115;&#97;&#x6e;&#x40;&#101;&#x78;&#x61;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;</a></td>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#x69;&#115;&#105;&#64;&#x65;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#x6d;">&#108;&#x69;&#115;&#105;&#64;&#x65;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#x6d;</a></td>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>003</td>
<td>011</td>
<td>20</td>
</tr>
</tbody></table>
<h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><p>在MySQL中，子查询是一种强大的功能，允许在一个查询中嵌套另一个查询。根据子查询返回的结果类型，可以将其分为以下几种：</p>
<ul>
<li>表子查询</li>
<li>行子查询</li>
<li>列子查询</li>
<li>标量子查询</li>
</ul>
<blockquote>
<p>注意：所有的子查询应该慎重使用，因为子查询会导致查询速度降低。</p>
</blockquote>
<table>
<thead>
<tr>
<th>子查询类型</th>
<th>定义</th>
<th>特点</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>表子查询</strong></td>
<td>返回一个完整的表（多行多列）</td>
<td>通常用于<code>FROM</code>子句或<code>JOIN</code>操作中，结果是一个表结构</td>
<td><code>sql &lt;br&gt;SELECT * FROM (SELECT id, name FROM users) AS subquery;&lt;br&gt; </code></td>
</tr>
<tr>
<td><strong>行子查询</strong></td>
<td>返回一行数据（多列）</td>
<td>通常用于<code>WHERE</code>子句中，结果是一行数据，可以与多列比较</td>
<td><code>sql &lt;br&gt;SELECT * FROM users WHERE (id, name) = (SELECT id, name FROM users WHERE age = 25);&lt;br&gt;</code></td>
</tr>
<tr>
<td><strong>列子查询</strong></td>
<td>返回一列数据（多行）</td>
<td>通常用于<code>WHERE</code>子句中，结果是一列数据，可以与<code>IN</code>、<code>ANY</code>、<code>ALL</code>等操作符配合使用</td>
<td><code>sql&lt;br&gt;SELECT * FROM users WHERE id IN (SELECT id FROM orders);&lt;br&gt;</code></td>
</tr>
<tr>
<td><strong>标量子查询</strong></td>
<td>返回单个值（一行一列）</td>
<td>通常用于<code>WHERE</code>子句中，结果是一个单一值，可以与比较操作符配合使用</td>
<td><code>sql&lt;br&gt;SELECT * FROM users WHERE age = (SELECT MAX(age) FROM users);&lt;br&gt;</code></td>
</tr>
</tbody></table>
<h6 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h6><ul>
<li>定义：返回一个完整的表（多行多列）。</li>
<li>特点：可以作为虚拟表使用，通常用于FROM子句或JOIN操作中。</li>
<li>示例：SELECT id, name FROM users 这就是一个子查询，该子查询返回的结果是一张表的数据，将该子查询的结果作为一张表，供外部的查询使用。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> users) <span class="keyword">AS</span> subquery;</span><br></pre></td></tr></table></figure>

<h6 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h6><ul>
<li>定义：返回一行数据（多列）。</li>
<li>特点：结果是一行数据，可以与多列比较，通常用于WHERE子句中。</li>
<li>示例：SELECT id, name FROM users WHERE mobile &#x3D; “13012345678” 是一个子查询，该子查询返回了mobile字段等于13012345678的一行数据，并且只查询了id和name字段。将这两个字段作为外部查询的where条件。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> (id, name) <span class="operator">=</span> (<span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> mobile <span class="operator">=</span> &quot;13012345678&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h6><ul>
<li>定义：返回一列数据（多行）。</li>
<li>特点：结果是一列数据，可以与IN、ANY、ALL等操作符配合使用，通常用于WHERE子句中。</li>
<li>示例：SELECT user_id FROM orders 是一个子查询，该子查询返回了orders表的所有用户id信息，并将这些用户id作为外部查询的where条件。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> user_id <span class="keyword">FROM</span> orders);</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h6><ul>
<li>定义：返回单个值（一行一列）。</li>
<li>特点：结果是一个单一值，可以与比较操作符配合使用，通常用于WHERE子句中。</li>
<li>示例：SELECT MAX(age) FROM users 是一个子查询，该子查询返回了users表的最大的年龄信息，并将最大的用户年龄作为外部查询的where条件。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> age <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(age) <span class="keyword">FROM</span> users);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h5><ul>
<li>group语句可以实现分组的效果，什么是分组？</li>
</ul>
<p>假设该数据表中存储了10条订单信息，有3条是张三的，3条是李四的，剩下4条是王五的。</p>
<p>group分组以后就可以分成3组，一组是张三的3条数据，一组是李四的3条数据，一组是王五的4条数据。</p>
<ul>
<li>分组能干什么？</li>
</ul>
<p>分组以后可以统计每个分组中的订单数量、订单总额、订单平均金额等。</p>
<p>语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> col_name</span><br></pre></td></tr></table></figure>

<p>支持的聚合函数：</p>
<ul>
<li>count(col_name): 计算每个分组中该字段的数量，比如订单数量</li>
<li>sum(col_name): 计算每个分组中该字段的总额，比如订单总金额</li>
<li>avg(col_name): 计算每个分组中该字段的平均值，比如订单平均金额</li>
<li>min(col_name): 获取每个分组中该字段的最小值</li>
<li>max(col_name): 获取每个分组中该字段的最大值</li>
</ul>
<p>有人要问了？那我不使用<code>group by</code>的情况下，可以使用上面的聚合函数吗？</p>
<p>当然可以了，没有分组，其实相当于所有数据是一个大分组，所以计算的是所有数据数量、总额等。</p>
<p>示例：下表是订单表，记录了3个用户的订单信息，现在需要查询这3个用户的订单数量、订单总金额、订单平均金额、最小金额以及最大金额。</p>
<table>
<thead>
<tr>
<th>OrderID</th>
<th>UserID</th>
<th>OrderDate</th>
<th>OrderAmount</th>
<th>OrderStatus</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>1</td>
<td>2025-02-01</td>
<td>120.00</td>
<td>Completed</td>
</tr>
<tr>
<td>1002</td>
<td>1</td>
<td>2025-02-02</td>
<td>85.00</td>
<td>Pending</td>
</tr>
<tr>
<td>1003</td>
<td>1</td>
<td>2025-02-03</td>
<td>230.00</td>
<td>Shipped</td>
</tr>
<tr>
<td>1004</td>
<td>2</td>
<td>2025-02-04</td>
<td>150.00</td>
<td>Completed</td>
</tr>
<tr>
<td>1005</td>
<td>2</td>
<td>2025-02-05</td>
<td>90.25</td>
<td>Pending</td>
</tr>
<tr>
<td>1006</td>
<td>2</td>
<td>2025-02-06</td>
<td>110.00</td>
<td>Shipped</td>
</tr>
<tr>
<td>1007</td>
<td>3</td>
<td>2025-02-07</td>
<td>100.00</td>
<td>Completed</td>
</tr>
<tr>
<td>1008</td>
<td>3</td>
<td>2025-02-08</td>
<td>200.00</td>
<td>Pending</td>
</tr>
<tr>
<td>1009</td>
<td>3</td>
<td>2025-02-09</td>
<td>130.75</td>
<td>Shipped</td>
</tr>
<tr>
<td>1010</td>
<td>3</td>
<td>2025-02-10</td>
<td>160.00</td>
<td>Completed</td>
</tr>
</tbody></table>
<p>使用如下sql：对userID进行分组，就可以分成三组数据了，在对每个分组使用聚合函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, <span class="built_in">count</span>(OrderID), <span class="built_in">sum</span>(OrderAmount), <span class="built_in">avg</span>(OrderAmount), <span class="built_in">min</span>(OrderAmount), <span class="built_in">max</span>(OrderAmount)</span><br><span class="line"><span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> UserID</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<table>
<thead>
<tr>
<th>UserID</th>
<th>count(OrderID)</th>
<th>sum(OrderAmount)</th>
<th>avg(OrderAmount)</th>
<th>min(OrderAmount)</th>
<th>max(OrderAmount)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>3</td>
<td>435.00</td>
<td>145.00</td>
<td>85.00</td>
<td>230.00</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>350.25</td>
<td>116.75</td>
<td>90.25</td>
<td>150.00</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>590.75</td>
<td>147.68</td>
<td>100.00</td>
<td>200.00</td>
</tr>
</tbody></table>
<h5 id="having"><a href="#having" class="headerlink" title="having"></a>having</h5><p><code>having</code>语句用来过滤<code>group by</code>分组以后的数据。</p>
<p>简单点说，就是相当于where条件，只不过<code>where条件</code>的执行顺序在<code>group by</code>之前，having条件的执行顺序在group by之后。</p>
<p>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> col_name [<span class="keyword">having</span> col_name <span class="operator">=</span> 任何数]</span><br></pre></td></tr></table></figure>

<p>示例：还是上面group by的表，这次我们只需要总金额大于400的数据，从上面的结果来看，我们知道，只需要userId为1和3的数据。</p>
<p>但是注意，<code>where条件</code>是在<code>group by</code>之前执行，这个时候还没有总金额这个字段呢。所以，就需要使用<code>having</code>了。</p>
<p>使用的sql如下：可以看到，仅仅是在后面增加了<code>having sum(OrderAmount) &gt; 400</code>这一条。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, <span class="built_in">count</span>(OrderID), <span class="built_in">sum</span>(OrderAmount), <span class="built_in">avg</span>(OrderAmount), <span class="built_in">min</span>(OrderAmount), <span class="built_in">max</span>(OrderAmount)</span><br><span class="line"><span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> UserID <span class="keyword">having</span> <span class="built_in">sum</span>(OrderAmount) <span class="operator">&gt;</span> <span class="number">400</span></span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<table>
<thead>
<tr>
<th>UserID</th>
<th>count(OrderID)</th>
<th>sum(OrderAmount)</th>
<th>avg(OrderAmount)</th>
<th>min(OrderAmount)</th>
<th>max(OrderAmount)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>3</td>
<td>435.00</td>
<td>145.00</td>
<td>85.00</td>
<td>230.00</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>590.75</td>
<td>147.68</td>
<td>100.00</td>
<td>200.00</td>
</tr>
</tbody></table>
<h5 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h5><p>如果想对查询出来的结果集进行排序，可以使用<code>order by</code>语句。</p>
<p>语法如下：asc代表升序，即1，2，3这种排序，desc代表降序，即3，2，1这种。默认是asc。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> col_name [<span class="keyword">asc</span>｜<span class="keyword">desc</span>]</span><br></pre></td></tr></table></figure>

<p>order by排序作用在group by分组之后，这意味着可以使用分组之后的聚合函数的结果进行排序，同时也意味着可以影响group by之后的数据。</p>
<p>示例：对上面group by之后的数据按照总金额进行降序排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, <span class="built_in">count</span>(OrderID), <span class="built_in">sum</span>(OrderAmount), <span class="built_in">avg</span>(OrderAmount), <span class="built_in">min</span>(OrderAmount), <span class="built_in">max</span>(OrderAmount)</span><br><span class="line"><span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> UserID <span class="keyword">having</span> <span class="built_in">sum</span>(OrderAmount) <span class="operator">&gt;</span> <span class="number">400</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">sum</span>(OrderAmount) <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<table>
<thead>
<tr>
<th>UserID</th>
<th>count(OrderID)</th>
<th>sum(OrderAmount)</th>
<th>avg(OrderAmount)</th>
<th>min(OrderAmount)</th>
<th>max(OrderAmount)</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>4</td>
<td>590.75</td>
<td>147.68</td>
<td>100.00</td>
<td>200.00</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>435.00</td>
<td>145.00</td>
<td>85.00</td>
<td>230.00</td>
</tr>
</tbody></table>
<h5 id="group-和-order的差别"><a href="#group-和-order的差别" class="headerlink" title="group 和 order的差别"></a>group 和 order的差别</h5><table>
<thead>
<tr>
<th align="left">group</th>
<th align="left">order</th>
</tr>
</thead>
<tbody><tr>
<td align="left">分组行，但输出可能不是分组的排序</td>
<td align="left">排序产生的输出</td>
</tr>
<tr>
<td align="left">只能使用选择列或表达式列</td>
<td align="left">任意列都可以使用</td>
</tr>
<tr>
<td align="left">若与聚合函数一起使用列或表达式, 则必须使用group</td>
<td align="left">不一定需要</td>
</tr>
</tbody></table>
<h5 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h5><p>如果不想每次都查询数据表的全部数据，只想获取几条数据呢？比如分页功能，一页10条数据这种，就可以使用<code>limit</code>命令来实现。</p>
<p>语法如下：start代表开始的位置，end代表结束的位置。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> orders </span><br><span class="line">limit [<span class="keyword">start</span>, <span class="keyword">end</span>]</span><br></pre></td></tr></table></figure>

<p>比如表中有100条数据。获取1-10条数据就是<code>limit 1,10</code>，获取11-20条数据就是<code>limit 11,20</code>。</p>
<p>limit最好是配合order by使用。性能更佳，另外，如果只获取1条数据，也建议使用<code>limit 1</code>代表获取1条数据。</p>
<p>具体的原因在后面原理篇会讲到。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thepatterraining.github.io/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQL%E7%AF%87.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="Thepatter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dream">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQL%E7%AF%87.html" class="post-title-link" itemprop="url">MySQL零基础教程基础篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-26 10:12:47" itemprop="dateCreated datePublished" datetime="2023-04-26T10:12:47+08:00">2023-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-11 16:34:49" itemprop="dateModified" datetime="2025-02-11T16:34:49+08:00">2025-02-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMU15445/" itemprop="url" rel="index"><span itemprop="name">CMU15445</span></a>
                </span>
            </span>

          
            <span id="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQL%E7%AF%87.html" class="post-meta-item leancloud_visitors" data-flag-title="MySQL零基础教程基础篇" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQL%E7%AF%87.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQL%E7%AF%87.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL零基础教程基础篇"><a href="#MySQL零基础教程基础篇" class="headerlink" title="MySQL零基础教程基础篇"></a>MySQL零基础教程基础篇</h1><p>大家好，我是大头，98年，职高毕业，做过上市公司架构师，做过大厂资深开发，管理过10人团队，我是如何做到的呢？</p>
<p>这离不开持续学习的能力，而其中最重要的当然是数据库技术了！</p>
<p>对于所有开发来说，都离不开数据库，因为所有的数据都是要存储的。</p>
<p>关注我一起学习！可获得系统性的学习教程、转码经验、技术交流、大厂内推等～</p>
<p>文末有惊喜哦！</p>
<p>基础篇的内容大致如下图所示。</p>
<p><img src="https://thepatterraining.github.io/images/mysql/mysql1-1.png" alt="概念学习"></p>
<h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><p>介绍完概念以后，我们可以来看看SQL语句了。SQL语句通常由三类组成。</p>
<p>数据定义 DDL</p>
<ul>
<li>CREATE 创建数据库或数据库对象</li>
<li>ALTER 对数据库或数据库对象进行修改</li>
<li>DROP 删除数据库或数据库对象<br>数据操纵 DML</li>
<li>SELECT 从表或视图中检索数据</li>
<li>INSERT 将数据插入到表或视图中</li>
<li>UPDATE 修改表或视图中的数据</li>
<li>DELETE 从表或视图中删除数据<br>数据控制 DCL</li>
<li>GRANT 用于授予权限</li>
<li>REVOKE 用于收回权限</li>
</ul>
<h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p>DCL（Data Control Language）语句用于控制对数据库的访问权限，包括用户权限的授予和撤销。DCL语句主要涉及用户和角色的权限管理，确保数据库的安全性和数据的完整性。</p>
<ul>
<li>授予权限（GRANT）</li>
<li>撤销权限（REVOKE）</li>
<li>设置用户密码（SET PASSWORD）</li>
<li>查看用户权限（SHOW GRANTS）</li>
</ul>
<h4 id="GRANT"><a href="#GRANT" class="headerlink" title="GRANT"></a>GRANT</h4><ul>
<li>GRANT语句用于授予用户或角色特定的权限。</li>
<li>权限可以包括对表、视图、存储过程等的访问和操作权限。</li>
</ul>
<p>语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> privilege_type <span class="keyword">ON</span> object_name <span class="keyword">TO</span> user_or_role;</span><br></pre></td></tr></table></figure>

<p>示例：授予用户zhangsan对employees表的SELECT和INSERT权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> employees <span class="keyword">TO</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="REVOKE"><a href="#REVOKE" class="headerlink" title="REVOKE"></a>REVOKE</h4><ul>
<li>REVOKE语句用于撤销用户或角色的特定权限。</li>
<li>撤销的权限可以是之前授予的任何权限。</li>
</ul>
<p>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> privilege_type <span class="keyword">ON</span> object_name <span class="keyword">FROM</span> user_or_role;</span><br></pre></td></tr></table></figure>

<p>示例：撤销用户zhangsan对employees表的INSERT权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> employees <span class="keyword">FROM</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="SET-PASSWORD"><a href="#SET-PASSWORD" class="headerlink" title="SET PASSWORD"></a>SET PASSWORD</h4><ul>
<li>SET PASSWORD语句用于设置或更改用户的密码。</li>
</ul>
<p>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> <span class="keyword">user</span> <span class="operator">=</span> <span class="string">&#x27;new_password&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>示例：设置用户zhangsan的新密码为new_password。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;new_password&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="SHOW-GRANTS"><a href="#SHOW-GRANTS" class="headerlink" title="SHOW GRANTS"></a>SHOW GRANTS</h4><ul>
<li>SHOW GRANTS语句用于查看用户的权限。</li>
</ul>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p>示例如下：查看用户zhangsan的权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>DCL主要是对于权限的控制，希望大家可以自己创建一个数据库a，在创建一个用户a,授予a用户a数据库的权限。进行练习。</p>
<h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><p>DDL（Data Definition Language，数据定义语言）是SQL语言的一部分，用于定义和修改数据库的结构。DDL语句主要涉及数据库、表、索引、视图等的创建、修改和删除操作。这些语句直接影响数据库的结构，但不会直接操作数据本身。</p>
<h4 id="数据库模式定义"><a href="#数据库模式定义" class="headerlink" title="数据库模式定义"></a>数据库模式定义</h4><h5 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h5><p>使用 <code>CREATE DATABASE</code> 语句，<code>IF NOT EXISTS</code>代表没有这个数据库，才会进行创建。如果已经有了，则不会再创建了。</p>
<p><code>CHARACTER SET</code>是设置字符集，推荐设置为utf8mb4字符集，<code>COLLATE</code>则使用默认的就可以了。</p>
<p>这里说一下<code>utf8</code>和<code>utf8mb4</code>这两个字符集的区别。</p>
<ul>
<li>utf8字符集：在MySQL中实际上是一个有限的字符集，它只支持最多3字节的UTF-8字符。这意味着它不能存储所有可能的Unicode字符，特别是那些需要4字节表示的字符（如某些表情符号）。utf8字符集支持的Unicode范围是U+0000到U+FFFF，即基本多语言平面（BMP）。</li>
<li>utf8mb4字符集支持完整的UTF-8字符集，包括4字节的字符。这意味着它可以存储所有可能的Unicode字符，包括表情符号和一些罕见的字符。utf8mb4字符集支持的Unicode范围是U+0000到U+10FFFF，即整个Unicode范围。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> &#123;DATABASE&#125; [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] db_name</span><br><span class="line">[<span class="keyword">DEFAULT</span>] <span class="type">CHARACTER</span> <span class="keyword">SET</span>[<span class="operator">=</span>]charset_name</span><br><span class="line"><span class="operator">|</span> [<span class="keyword">DEFAULT</span>] <span class="keyword">COLLATE</span>[<span class="operator">=</span>]collation_name</span><br></pre></td></tr></table></figure>

<p>创建一个测试数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database test;</span><br></pre></td></tr></table></figure>

<h5 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h5><p>使用<code>show databases</code>命令可以查看所有的数据库。也包括一些MySQL自带的数据库。这些数据库存储了MySQL的元数据，具体的等到原理篇会讲到。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> &#123;DATABASES&#125;</span><br><span class="line">[<span class="keyword">LIKE</span> <span class="keyword">pattern</span> <span class="operator">|</span> <span class="keyword">WHERE</span> expr] </span><br></pre></td></tr></table></figure>

<h5 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h5><p>使用<code>use</code>指令➕数据库名称可以选择数据库，或者说进入数据库。只有先进入一个数据库，才能操作这个数据库里面的数据表等等。</p>
<p>除此之外，也可以在操作数据表的前面加上数据库名称，但是那样比较麻烦。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use db_name</span><br></pre></td></tr></table></figure>

<h5 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h5><p>使用<code>ALTER DATABASE</code>指令可以修改数据库。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE db_name</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> gb2312</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> gb2312_chinese_ci;</span><br></pre></td></tr></table></figure>

<h5 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h5><p>当这个数据库不再使用的时候，可以通过<code>DROP DATABSE</code>指令来删除掉这个数据库。</p>
<p><code>IF EXISTS</code>代表存在则删除，不存在就不会删除。和创建的时候那个指令正好相反。都是可选指令。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> &#123;DATABASE&#125; [IF <span class="keyword">EXISTS</span>] db_name;</span><br></pre></td></tr></table></figure>


<h4 id="表定义"><a href="#表定义" class="headerlink" title="表定义"></a>表定义</h4><p>数据表被定义为字段的集合<br>按 <code>行</code> 和<code>列</code>的格式存储<br>每一行代表一条记录<br>每一列代表记录中一个字段的取值</p>
<h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><p>使用<code>create table</code>指令可以创建数据表，后面跟的是表名称和字段。</p>
<p><code>temporary</code>表示临时表，临时表存放在内存中。</p>
<p>字段类型常用的如下：</p>
<ul>
<li>int类型，占11位，也可以设置为int(5)等，但是这个只影响展示，并不影响实际的存储。</li>
<li>varchar&#x2F;char类型，相当于字符串类型，varchar是可变长度的字符串，char是不可变长度的字符串。</li>
<li>text类型，很不推荐使用该类型，会导致查询速度变慢，尽量使用varchar代替。</li>
<li>timestamp时间戳类型，不推荐使用，因为该类型表示1970年到现在的秒数，最大只能到2038-01-19号，而现在已经2025年了。</li>
<li>datetime类型，推荐使用这个代替时间戳，直接存储时间类型，并且表里的updated_time字段可以使用<code>DEFAULT CURRENT_TIMESTAMP</code>作为默认值，还可以使用<code>ON UPDATE CURRENT_TIMESTAMP</code>来实现自动更新。</li>
<li>decimal类型,用来存储小数，使用定点小数来存储，可以防止精度丢失。请避免使用<code>float</code>和<code>double</code>来存储小数。</li>
<li>json类型，可以存储json字符串。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [temporary] <span class="keyword">table</span> [if <span class="keyword">not</span> <span class="keyword">exists</span>] tbl_name</span><br><span class="line">(</span><br><span class="line">    字段名<span class="number">1</span> 数据类型 [列完整性约束条件] [默认值]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h5><p>对于创建的表结构不满意，可以通过<code>ALTER TABLE</code>指令来修改表结构。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br></pre></td></tr></table></figure>

<p>下面介绍一些子句，配合alter table命令来执行。</p>
<ul>
<li>ADD [COLUMN] 子句：给表结构增加字段。</li>
<li>change [COLUMN] 子句：修改表结构的字段类型、字段名称等。<ul>
<li>CHANGE COLUMN name new_name VARCHAR(200);</li>
</ul>
</li>
<li>alter [column] 子句 修改或删除表中指定列的默认值。<ul>
<li>alter colum city set default ‘bj’</li>
</ul>
</li>
<li>modify [column] 子句 只修改指定列的数据类型，不会干涉它的列名<ul>
<li>modify column city char(50);</li>
</ul>
</li>
<li>drop [column] 子句 删除指定列<ul>
<li>drop column city;</li>
</ul>
</li>
<li>rename [to] 子句 修改表名<ul>
<li>rename table table_name to new_table_name</li>
</ul>
</li>
<li>add index index_name(column_name) 创建索引</li>
<li>drop index index_name</li>
</ul>
<h5 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h5><p>当一个表不再使用的时候，也可以使用<code>drop table</code>将它删除。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> [temporary] <span class="keyword">table</span> [if <span class="keyword">exists</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h5><p>可以通过<code>SHOW CREATE TABLE</code>来查看表结构。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename;</span><br></pre></td></tr></table></figure>

<h4 id="索引定义"><a href="#索引定义" class="headerlink" title="索引定义"></a>索引定义</h4><p>索引是提高数据文件访问效率的有效方法，比如MySQL中的B+树索引、hash索引、全文索引等。</p>
<p>缺点</p>
<ul>
<li>索引是以文件的形式存储的，如果有大量的索引，索引文件可能比数据文件更快达到最大的文件尺寸</li>
<li>索引在提高查询速度的同时，会降低更新表的速度</li>
</ul>
<h5 id="索引物理结构"><a href="#索引物理结构" class="headerlink" title="索引物理结构"></a>索引物理结构</h5><ul>
<li>b+树索引</li>
<li>hash索引</li>
<li>倒排索引</li>
</ul>
<h5 id="索引逻辑结构"><a href="#索引逻辑结构" class="headerlink" title="索引逻辑结构"></a>索引逻辑结构</h5><ul>
<li>index 或 key： 普通索引</li>
<li>unique ：唯一性索引 候选码</li>
<li>primary key： 主键</li>
</ul>
<h5 id="索引逻辑概念"><a href="#索引逻辑概念" class="headerlink" title="索引逻辑概念"></a>索引逻辑概念</h5><ul>
<li>聚簇索引：比如主键索引，也就是b树的叶子节点存储数据的索引。</li>
<li>联合索引：由多个字段共同组成的索引。</li>
<li>覆盖索引：查询的字段和索引的字段一致，从而避免了再次去主键索引获取数据。</li>
</ul>
<p>关于索引的具体讲解将放在原理篇讲解，这里以介绍DDL语句为主，有个概念就可以了。</p>
<h5 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h5><p>想要创建一个索引可以使用<code>create index</code>命令，<code>unique</code>表示创建唯一索引。</p>
<p><code>index_col_name</code>表示要将索引创建在哪个字段上面，也可以是多个字段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>] index index_name</span><br><span class="line"><span class="keyword">on</span> table_name(index_col_name)</span><br></pre></td></tr></table></figure>

<p>示例，在user表上的<code>email</code>字段上创建一个索引，索引名称是<code>email_idx</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index email_idx</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">user</span>(email);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>索引并不是越多越好，太多的索引会导致维护成本升高，尽量少且有用即可。尤其是后续增加索引的时候，如果数据表中数据过多，建立索引的过程会较慢，会对业务产生影响，这个时候需要慎重。</p>
</blockquote>
<h5 id="索引删除"><a href="#索引删除" class="headerlink" title="索引删除"></a>索引删除</h5><p>当索引不再使用的时候，可以删除索引，使用命令<code>drop index</code>可以删除索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> [<span class="keyword">unique</span>] index index_name</span><br><span class="line"><span class="keyword">on</span> table_name</span><br></pre></td></tr></table></figure>

<p>示例：删除刚才建立的<code>email_idx</code>索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index email_idx</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<h4 id="视图定义"><a href="#视图定义" class="headerlink" title="视图定义"></a>视图定义</h4><p>什么是视图</p>
<ul>
<li>视图是一个对象，他是数据库提供给用户的以多种角度观察数据库中数据的一种重要机制</li>
<li>视图不是数据库中真实的表，而是一张虚拟表，其自身并不存储数据</li>
</ul>
<p>视图的优点</p>
<ul>
<li>集中分散数据</li>
<li>简化查询语句</li>
<li>重用SQL语句</li>
<li>保护数据安全</li>
<li>共享所需数据</li>
<li>更改数据格式</li>
</ul>
<h5 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h5><p>想要创建视图，可以使用<code>create view</code>指令。</p>
<p><code>or replace</code> 防止报错，存在替换，不存在创建。<br><code>with check option</code> 增删改查的时候检查视图条件。<br><code>select_statement</code> 是一段select查询语句。视图的本质就是这一段select查询语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">view</span> view_name [(col_list)]</span><br><span class="line"><span class="keyword">as</span> select_statement</span><br><span class="line">[<span class="keyword">with</span> <span class="keyword">check</span> option]</span><br></pre></td></tr></table></figure>

<p>示例：创建一个<code>zhangsan</code>用户的登录记录的视图。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> zhangsan</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> login_log <span class="keyword">where</span> <span class="keyword">user</span> <span class="operator">=</span> ‘zhangsan’</span><br></pre></td></tr></table></figure>

<h5 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h5><p>想要修改视图，可以使用<code>alter view</code>指令。</p>
<p>修改视图其实就是修改这个查询语句。当然了，也可以修改其他的属性等。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> view_name [(col_list)]</span><br><span class="line"><span class="keyword">as</span> select_statement</span><br><span class="line">[<span class="keyword">with</span> <span class="keyword">check</span> option]</span><br></pre></td></tr></table></figure>

<h5 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h5><p>当视图不需要了，可以使用<code>drop view</code>指令删除视图。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [IF <span class="keyword">EXISTS</span>] view_name</span><br></pre></td></tr></table></figure>

<p>示例：删除刚才创建的视图zhangsan</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">view</span> zhangsan</span><br></pre></td></tr></table></figure>

<h5 id="查看视图定义"><a href="#查看视图定义" class="headerlink" title="查看视图定义"></a>查看视图定义</h5><p>和上面说的查看表的定义一样，也可以查看视图的定义。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> view_name</span><br></pre></td></tr></table></figure>

<h4 id="存储过程定义"><a href="#存储过程定义" class="headerlink" title="存储过程定义"></a>存储过程定义</h4><p><code>存储过程</code> 是一组为了完成某项特定功能的 <code>SQL语句集</code></p>
<ul>
<li>可增强SQL语言的功能和灵活性</li>
<li>良好的封装性</li>
<li>高性能</li>
<li>可减少网络流量</li>
<li>可作为一种安全机制来确保数据库的安全性和数据的完整性<br>其实质就是一段存储在数据库中的 <code>代码</code><br>它可以由声明式的sql语句和过程式sql语句组成</li>
</ul>
<h5 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h5><p><code>DELIMITER $$</code>是用户定义的MYSQL 结束符</p>
<p>参数：in|out|inout 参数名 参数类型</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> sp_name(参数)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">body <span class="operator">/</span><span class="operator">/</span>存储过程代码</span><br><span class="line"><span class="keyword">END</span> $$</span><br></pre></td></tr></table></figure>

<p>示例：查询员工表的名称、部门和薪资。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> get_employee_details(<span class="keyword">IN</span> emp_id <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> name, department, salary</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> id <span class="operator">=</span> emp_id;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h5 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h5><p>调用需要使用<code>call</code>指令来调用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> sp_name(参数)</span><br></pre></td></tr></table></figure>

<p>示例：调用刚才的存储过程。 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> get_employee_details(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h5 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h5><p>如果存储过程不再需要了，则可以通过<code>drop procedure</code>指令来删除它。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> sp_name</span><br></pre></td></tr></table></figure>

<p>示例：删除刚才的存储过程。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> get_employee_details;</span><br></pre></td></tr></table></figure>

<h4 id="存储函数定义"><a href="#存储函数定义" class="headerlink" title="存储函数定义"></a>存储函数定义</h4><p>存储函数由SQL语句和过程式语句组成。</p>
<h5 id="创建存储函数"><a href="#创建存储函数" class="headerlink" title="创建存储函数"></a>创建存储函数</h5><p>使用 <code>create function</code>指令可以创建一个存储函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> sp_name(参数)</span><br><span class="line">    <span class="keyword">returns</span> type</span><br><span class="line">    routine_body <span class="operator">/</span><span class="operator">/</span>主体</span><br></pre></td></tr></table></figure>

<p>示例：给定id号返回性别。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">use test; <span class="operator">/</span><span class="operator">/</span>进入数据库test</span><br><span class="line">delimiter $$ <span class="operator">/</span><span class="operator">/</span>声明结束符号</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> fn_search(cid <span class="type">int</span>) <span class="operator">/</span><span class="operator">/</span>创建函数fn <span class="keyword">search</span>，参数为cid，<span class="type">int</span>类型</span><br><span class="line">    <span class="keyword">returns</span> <span class="type">char</span>(<span class="number">20</span>) <span class="operator">/</span><span class="operator">/</span>声明返回值类型char20</span><br><span class="line">    <span class="keyword">deterministic</span></span><br><span class="line"><span class="keyword">begin</span> <span class="operator">/</span><span class="operator">/</span>开始</span><br><span class="line">    <span class="keyword">declare</span> sex <span class="type">char</span>(<span class="number">20</span>) <span class="operator">/</span><span class="operator">/</span>声明一个变量sex 类型char20</span><br><span class="line">    <span class="keyword">select</span> cust_sex <span class="keyword">into</span> sex <span class="keyword">from</span> customers <span class="keyword">where</span> id <span class="operator">=</span> cid; <span class="operator">/</span><span class="operator">/</span><span class="keyword">select</span>语句，把查询出来的cust_sex字段内容放入变量sex中</span><br><span class="line">    if sex <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="operator">/</span><span class="operator">/</span>if判断，如果sex变量是<span class="keyword">null</span>，则返回<span class="string">&#x27;没有该客户&#x27;</span></span><br><span class="line">        <span class="keyword">return</span>(<span class="keyword">select</span> <span class="string">&#x27;没有该客户&#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="operator">/</span><span class="operator">/</span>如果sex变量不是<span class="keyword">null</span></span><br><span class="line">        if sex <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">then</span> <span class="operator">/</span><span class="operator">/</span>则判断是F的话，返回<span class="string">&#x27;女&#x27;</span></span><br><span class="line">            <span class="keyword">return</span>(<span class="keyword">select</span> <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="operator">/</span><span class="operator">/</span> 不然的话就返回<span class="string">&#x27;男&#x27;</span></span><br><span class="line">            <span class="keyword">return</span>(<span class="keyword">select</span> <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        <span class="keyword">end</span> if;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span> $$</span><br></pre></td></tr></table></figure>

<h5 id="调用存储函数"><a href="#调用存储函数" class="headerlink" title="调用存储函数"></a>调用存储函数</h5><p>使用 select 调用存储函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sp_name(参数)；</span><br></pre></td></tr></table></figure>

<p>示例：调用刚才的存储函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> fn_search(<span class="number">1</span>)$$</span><br></pre></td></tr></table></figure>

<h5 id="删除存储函数"><a href="#删除存储函数" class="headerlink" title="删除存储函数"></a>删除存储函数</h5><p>当存储函数不再使用的时候，可以使用<code>drop function</code>将它删除。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">function</span> fun_name</span><br></pre></td></tr></table></figure>

<p>示例：删除刚才的存储函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">function</span> fn_search</span><br></pre></td></tr></table></figure>

<h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>以上就是整体的MySQL学习路线了。</p>
<p>关注我发送“MySQL知识图谱”领取完整的MySQL学习路线。</p>
<p>发送“电子书”即可领取价值上千的电子书资源。</p>
<p>部分电子书如图所示。</p>
<p><img src="https://thepatterraining.github.io/images/bottom1.png" alt="概念学习"></p>
<p><img src="https://thepatterraining.github.io/images/bottom2.png" alt="概念学习"></p>
<p><img src="https://thepatterraining.github.io/images/bottom3.png" alt="概念学习"></p>
<p><img src="https://thepatterraining.github.io/images/bottom4.png" alt="概念学习"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Thepatter"
      src="/images/header.jpeg">
  <p class="site-author-name" itemprop="name">Thepatter</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">195</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">82</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Thepatterraining" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Thepatterraining" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ztzhoutao041@163.com" title="E-Mail → mailto:ztzhoutao041@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://blog.csdn.net/Thepatterraining" title="CSDN → http:&#x2F;&#x2F;blog.csdn.net&#x2F;Thepatterraining" rel="noopener" target="_blank"><i class="fa fa-fw fa-CSDN"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Thepatter</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"RWllimOI5okO7WFTUmJ4EeeD-gzGzoHsz","app_key":"hXeefwCw8aDKTJ1Xqye7fLYb","security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'RWllimOI5okO7WFTUmJ4EeeD-gzGzoHsz',
      appKey     : 'hXeefwCw8aDKTJ1Xqye7fLYb',
      placeholder: "给我的文章加点评论吧~",
      avatar     : 'mp',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
