<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DeepSeek百万年薪招聘：AI领域人才争夺战的“顶配”条件与薪资揭秘</title>
    <url>/DeepSeek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2.html</url>
    <content><![CDATA[<h1 id="DeepSeek-R1本地部署"><a href="#DeepSeek-R1本地部署" class="headerlink" title="DeepSeek R1本地部署"></a>DeepSeek R1本地部署</h1><h2 id="DeepSeek大火-但天下苦服务器繁忙，请稍后再试久矣"><a href="#DeepSeek大火-但天下苦服务器繁忙，请稍后再试久矣" class="headerlink" title="DeepSeek大火,但天下苦服务器繁忙，请稍后再试久矣."></a>DeepSeek大火,但天下苦服务器繁忙，请稍后再试久矣.</h2><p>近期,DeepSeek大模型大火,一举超越ChatGPT登顶下载榜首.</p>
<p>DeepSeek从很少人知道一下子变成了人尽皆知的大厂,招聘薪资更是开出了年薪百万的价格,应届生都可以去.可谓是梦中情厂.</p>
<p>但是,就连DeepSeek自己可能都没想到自己这么火.因此招架不住大家的热情,频繁的出现<code>服务器繁忙，请稍后再试</code>.</p>
<p>使用体验实在糟糕.</p>
<p>好在,DeepSeek开源了自己的大模型,我们可以将DeepSeek部署到本地进行使用,这样的话就可以不再担心服务器繁忙了.可以尽情的蹂躏DeepSeek了!!!</p>
<p>关于DeepSeek的技术有兴趣的可以看看他们的论文.<br><a href="https://github.com/deepseek-ai/DeepSeek-R1/blob/main/DeepSeek_R1.pdf">DeepSeekR1论文</a></p>
<ul>
<li>DeepSeek-R1 遵循 MIT License，允许用户通过蒸馏技术借助 R1 训练其他模型。</li>
<li>DeepSeek-R1 上线 API，对用户开放思维链输出，通过设置 model&#x3D;’deepseek-reasoner’ 即可调用。</li>
<li>DeepSeek 官网与 App 即日起同步更新上线。</li>
</ul>
<p>DeepSeek-R1 在后训练阶段大规模使用了强化学习技术，在仅有极少标注数据的情况下，极大提升了模型推理能力。在数学、代码、自然语言推理等任务上，性能比肩 OpenAI o1 正式版。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol>
<li><p><strong>硬件要求</strong></p>
<ul>
<li>需要至少一个 CPU 核心（推荐使用多核处理器）。</li>
<li>内存建议至少 4GB，具体内存可以根据实际需求调整。</li>
<li>磁盘空间建议至少 20GB 可用空间。</li>
</ul>
</li>
<li><p><strong>操作系统</strong></p>
<ul>
<li>Windows、Linux 或 macOS 均可支持。</li>
</ul>
</li>
</ol>
<h2 id="蒸馏模型"><a href="#蒸馏模型" class="headerlink" title="蒸馏模型"></a>蒸馏模型</h2><p>DeepSeek本地部署的基本是蒸馏模型,简单理解为阉割版.</p>
<p>为什么?因为本地无法支持真正大模型的算力.</p>
<p>蒸馏模型虽然无法和完整版一样,但是胜在我们可以本地部署,自己玩.还避免了服务器繁忙的苦恼.毕竟,东西再好,你用不了也是白搭啊.</p>
<p><code>DeepSeek</code> 在开源 <code>DeepSeek-R1-Zero</code> 和 <code>DeepSeek-R1</code> 两个 660B 模型的同时，通过 <code>DeepSeek-R1</code> 的输出，蒸馏了 <code>6个小模型</code>开源给社区，其中 32B 和 70B 模型在多项能力上实现了对标 <code>OpenAI o1-mini</code> 的效果。</p>
<p><img src="/../images/ai/deepseek2-1.png" alt="deepseek2-1"></p>
<p>满血版DeepSeek 671B的要求:</p>
<ul>
<li>显存需求：完整版（未量化）的显存需求极高，<code>BF16</code>精度下需 <code>1342GB</code>显存，即使使用<code>FP16</code>精度也需约 <code>350GB</code>显存</li>
<li>硬件配置：需多节点分布式计算，例如8张NVIDIA A100&#x2F;H100（每卡80GB显存）并行运行，或更高端的超算集群</li>
<li>性能限制：单卡无法支持，即使最新RTX 5090（32GB显存）也无法有效运行，推理速度极低（低于每秒10个token）</li>
</ul>
<p><img src="/../images/ai/deepseek2-2.jpg" alt="deepseek2-1"></p>
<p>看一下蒸馏版的要求和推荐配置.</p>
<table>
<thead>
<tr>
<th>版本名称</th>
<th>参数数量</th>
<th>显存需求 (FP16)</th>
<th>内存需求</th>
<th>推荐Mac配置</th>
<th>推荐Windows配置</th>
</tr>
</thead>
<tbody><tr>
<td>DeepSeek-R1-1.5B</td>
<td>1.5B</td>
<td>~3GB</td>
<td>8GB+</td>
<td>M1&#x2F;M2芯片，8GB统一内存[^2^]</td>
<td>GTX 1650&#x2F;RTX 2060，4GB+显存[^5^]</td>
</tr>
<tr>
<td>DeepSeek-R1-7B</td>
<td>7B</td>
<td>~14GB</td>
<td>16GB+</td>
<td>M1 Pro&#x2F;M2 Pro，16GB统一内存[^2^]</td>
<td>RTX 3060&#x2F;4070 Ti，12GB显存[^2^]</td>
</tr>
<tr>
<td>DeepSeek-R1-14B</td>
<td>14B</td>
<td>~28GB</td>
<td>32GB+</td>
<td>M1 Max&#x2F;M2 Max，32GB统一内存[^2^]</td>
<td>RTX 4090&#x2F;A100 40G，24GB+显存[^2^]</td>
</tr>
<tr>
<td>DeepSeek-R1-32B</td>
<td>32B</td>
<td>~64GB</td>
<td>64GB+</td>
<td>M1 Ultra&#x2F;M2 Ultra，64GB统一内存[^2^]</td>
<td>2x RTX 4090&#x2F;A100 80G，48GB+显存[^2^]</td>
</tr>
<tr>
<td>DeepSeek-R1-70B</td>
<td>70B</td>
<td>~140GB</td>
<td>128GB+</td>
<td>需要更高配置的Mac Pro[^6^]</td>
<td>4x RTX 4090&#x2F;A100 80G[^6^]</td>
</tr>
</tbody></table>
<p><img src="/../images/ai/deepseek2-3.jpg" alt="deepseek2-1"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>介绍完以后,开始安装吧.</p>
<p>安装相对来说比较简单,可以使用<code>Ollama</code>这个东西.</p>
<p>直接在<a href="https://ollama.com/">Ollama官网</a>下载就可以了.</p>
<p>在如下界面,直接点击<code>DownLoad</code>就可以了.</p>
<p><img src="/../images/ai/deepseek2-4.jpg" alt="deepseek2-1"></p>
<p>接下来选择版本,Mac、Linux或者Windows.</p>
<p><img src="/../images/ai/deepseek2-5.png" alt="deepseek2-1"></p>
<p>等待下载完成以后,运行<code>Ollama</code>.这个东西可以理解为大模型的运行环境.</p>
<p><img src="/../images/ai/deepseek2-6.png" alt="deepseek2-1"></p>
<p>接下来点击Ollama官网左上角的<code>Models</code>可以准备大模型了.</p>
<p><img src="/../images/ai/deepseek2-7.png" alt="deepseek2-1"></p>
<p>选择我们要部署的<code>DeepSeek R1</code>大模型.</p>
<p>接下里可以选择要部署的版本.版本信息上面已经介绍过了.</p>
<p><img src="/../images/ai/deepseek2-8.png" alt="deepseek2-8"></p>
<p>选择以后右侧的命令会改变,直接复制右侧的命令即可.比如我选择<code>7b</code>版本,右侧的命令就是<code>ollama run deepseek-r1:7b</code>.</p>
<p><img src="/../images/ai/deepseek2-9.png" alt="deepseek2-9"></p>
<p>直接在命令行中输入这个命令就可以了.<code>Windows</code>使用<code>CMD</code>或者<code>终端</code>都可以.<code>Mac</code>使用<code>终端</code>或者<code>Iterm2</code>都可以.运行以后会先开始下载大模型.</p>
<blockquote>
<p>在windows下,可以在下面的搜索里面输入CMD打开终端程序,或者按住键盘Win + R两个键,然后在里面输入CMD打开终端程序.</p>
</blockquote>
<p><img src="/../images/ai/deepseek2-10.png" alt="deepseek2-9"></p>
<p>下载完成以后进入大模型的输入界面,是命令行格式的,可以直接输入.</p>
<p>比如我输入<code>你是谁</code>.回答中的<think>标签里面对应的是思考的内容.</p>
<p><img src="/../images/ai/deepseek2-11.png" alt="deepseek2-9"></p>
<p>到这里其实就安装完成了,不过如果需要UI界面在浏览器中使用的话,也可以再安装一个UI界面.</p>
<p>后续如果还想运行的话依然是两个步骤</p>
<ol>
<li>打开Ollama程序</li>
<li>运行命令ollama run deepseek-r1:7b, 注意替换成你自己的命令.</li>
</ol>
<h3 id="可视化界面安装"><a href="#可视化界面安装" class="headerlink" title="可视化界面安装"></a>可视化界面安装</h3><p>有很多人可能使用不惯命令行程序来输入,因此可以安装一个可视化界面,这样就和在DeepSeek官网使用一样了.</p>
<p>接下来我们看看如何安装UI界面吧!</p>
<p>可视化界面使用<a href="https://github.com/open-webui/open-webui">Open-Web UI</a>提供的界面程序.可以先下载Docker,使用<code>Docker</code>运行<code>Open-Web UI</code>.</p>
<h4 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h4><p>进入<a href="https://www.docker.com/">Docker官网</a>,进行下载.选择要下载的版本.</p>
<p><img src="/../images/ai/deepseek2-12.png" alt="deepseek2-9"></p>
<p>下载以后进行安装,安装完成以后,打开程序,使用推荐配置就可以了.</p>
<p><img src="/../images/ai/deepseek2-13.png" alt="deepseek2-9"></p>
<h4 id="安装Open-Web-UI"><a href="#安装Open-Web-UI" class="headerlink" title="安装Open Web-UI"></a>安装Open Web-UI</h4><p>接下来就可以安装<code>Open Web-UI</code>了.</p>
<p>使用如下命令即可.和之前一样,在CMD或者终端程序中运行如下命令.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main</span><br></pre></td></tr></table></figure>

<p>接下来等待下载完成就可以了.</p>
<p><img src="/../images/ai/deepseek2-14.png" alt="deepseek2-9"></p>
<p>现在打开浏览器,输入<code>http://localhost:3000/</code>即可进入本地部署的可视化界面了!</p>
<p>第一次的话需要创建管理员账号,输入名称、邮箱、密码就可以了.</p>
<p>进来以后如图所示.</p>
<p><img src="/../images/ai/deepseek2-15.png" alt="deepseek2-9"></p>
<p>使用体验如下</p>
<p><img src="/../images/ai/deepseek2-16.png" alt="deepseek2-9"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这样就算安装完成了,可以使用命令行或者界面,看个人喜好了!</p>
<p>通过以上步骤，您可以在本地部署 DeepSeek。请根据实际需求调整配置并确保所有依赖项已正确安装。如果在运行过程中遇到问题，请参考官方文档或联系技术支持团队。</p>
<p>希望这份指南对您有所帮助！</p>
<h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>关注我发送“MySQL知识图谱”领取完整的MySQL学习路线。</p>
<p>发送“电子书”即可领取价值上千的电子书资源。</p>
<p>发送“大厂内推”即可获取京东、美团等大厂内推信息，祝你获得高薪职位。</p>
<p>部分电子书如图所示。</p>
<p><img src="/../images/bottom1.png" alt="概念学习"></p>
<p><img src="/../images/bottom2.png" alt="概念学习"></p>
<p><img src="/../images/bottom3.png" alt="概念学习"></p>
<p><img src="/../images/bottom4.png" alt="概念学习"></p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>DeepSeek</tag>
      </tags>
  </entry>
  <entry>
    <title>DeepSeek百万年薪招聘：AI领域人才争夺战的“顶配”条件与薪资揭秘</title>
    <url>/DeepSeek%E9%AB%98%E4%BB%B7%E6%8B%9B%E8%81%98.html</url>
    <content><![CDATA[<h1 id="DeepSeek百万年薪招聘：AI领域人才争夺战的“顶配”条件与薪资揭秘"><a href="#DeepSeek百万年薪招聘：AI领域人才争夺战的“顶配”条件与薪资揭秘" class="headerlink" title="DeepSeek百万年薪招聘：AI领域人才争夺战的“顶配”条件与薪资揭秘"></a>DeepSeek百万年薪招聘：AI领域人才争夺战的“顶配”条件与薪资揭秘</h1><p>随着人工智能技术的飞速发展，中国AI初创企业DeepSeek（杭州深度求索人工智能基础技术研究有限公司）凭借其高性价比的大模型与开源创新举措，迅速成为全球科技界的焦点。为支撑业务扩张与技术突破，DeepSeek近期发布了大规模招聘计划，52个在招职位涵盖深度学习、系统研发、UI设计等领域，并开出了<code>年薪最高154万元</code>的诱人待遇，引发行业热议</p>
<p>AI人才如此值钱的当下，我们程序员该何去何从？</p>
<p>想要拿到如此高的薪资，需要什么条件？</p>
<p>DeepSeek甚至给校招实习生开出了<code>1000元</code>每天的工资，这些实习生的工资已经超过了大部分一线城市的程序员了。</p>
<p>最重要的在于一句话<code>不看经验只看能力</code>。只要你能力够好，那么Deepseek就可以给你高薪。</p>
<p>如同之前马斯克发的一句话，只要你能力够好，我们就可以给你发offer。</p>
<h2 id="公司背景与行业趋势"><a href="#公司背景与行业趋势" class="headerlink" title="公司背景与行业趋势"></a>公司背景与行业趋势</h2><p>DeepSeek成立于2023年7月，由量化投资巨头幻方量化创立，2025年1月发布的DeepSeek-R1和DeepSeek-V3大模型因“低成本、高性能”引发全球关注，用户量激增，日活跃用户（DAU）突破2000万，跻身全球AI产品榜第二。此次招聘规模超现有团队1&#x2F;3（现有员工约150人），凸显其快速扩张需求。</p>
<p>行业层面，AI人才缺口持续扩大。《2024年度人才迁徙报告》显示，大模型相关岗位占据技术岗平均月薪前十名的半数，算法工程师需求激增，预计到2030年中国AI人才缺口将达400万</p>
<h2 id="招聘特点与竞争门槛"><a href="#招聘特点与竞争门槛" class="headerlink" title="招聘特点与竞争门槛"></a>招聘特点与竞争门槛</h2><ul>
<li>学历放宽，校招优先：部分岗位（如核心系统研发工程师）对本科生开放，且校招薪酬高于社招，吸引年轻人才711。</li>
<li>成果导向：深度学习研究员需以论文、竞赛成绩或开源项目证明研究能力，强调“创新品味”与对AGI的信仰210。</li>
<li>抗压能力与热情：公司更青睐“年轻、反应敏捷、有冲劲”的候选人，要求具备持续学习能力和跨学科视野27。</li>
</ul>
<h2 id="核心岗位与薪资结构"><a href="#核心岗位与薪资结构" class="headerlink" title="核心岗位与薪资结构"></a>核心岗位与薪资结构</h2><ol>
<li>深度学习研究员-AGI</li>
</ol>
<ul>
<li>薪资水平：月薪8万至11万元，按14薪计算，年薪最高达154万元。</li>
<li>岗位要求：<ul>
<li>精通机器学习和深度学习，需具备创新研究能力；</li>
<li>熟练掌握至少两种编程语言（如Python、C++）；</li>
<li>有国际顶会（如NeurIPS、ICML）或顶级期刊论文发表经验；<ul>
<li>在知名AI竞赛中取得优异成绩者优先。</li>
</ul>
</li>
</ul>
</li>
<li>目标人群：博士学历为主，优秀硕士或本科生亦可参与实习。</li>
</ul>
<ol start="2">
<li>核心系统研发工程师（校招）</li>
</ol>
<ul>
<li>薪资范围：月薪6万至9万元，年薪最高126万元。</li>
<li>岗位要求：围绕大模型预训练、算法优化等展开工程化实现，要求熟悉软硬件协同开发，具备高性能计算经验</li>
</ul>
<p><img src="/../images/ai/deepseek1-2.png" alt="deepseek1"></p>
<ol start="3">
<li>全栈开发工程师</li>
</ol>
<ul>
<li>薪资水平：月薪4万至7万元，年薪最高98万元。</li>
<li>能力要求：扎实的编程能力，优秀的设计能力和代码品味，较强的责任心。对主流开源软件有深入了解并对此有贡献者优先。具有自我驱动和自我管理能力。</li>
</ul>
<p><img src="/../images/ai/deepseek1-3.png" alt="deepseek1"></p>
<ol start="4">
<li>实习生岗位</li>
</ol>
<ul>
<li>AGI大模型实习生日薪500至1000元，按每月22天计算，月薪可达1.1万至2.2万元，要求掌握PyTorch框架，并有论文或开源项目经验。主要是顶会论文。</li>
</ul>
<p><img src="/../images/ai/deepseek1-1.png" alt="deepseek1"></p>
<h2 id="我们如何努力破局？"><a href="#我们如何努力破局？" class="headerlink" title="我们如何努力破局？"></a>我们如何努力破局？</h2><p>目前有3类人急需掌握AI能力</p>
<ol>
<li>还没入行但是想入行的</li>
<li>已经是程序员但是想破局的</li>
<li>本科生、研究生、博士生这类学生。</li>
</ol>
<p>其实，看到这些招聘信息，我们可以提炼出几点信息。</p>
<ol>
<li>不看经验只看能力：所以能力尤为重要，我们需要尽快提升自己，那么如何提升自己？</li>
<li>名校毕业生：如何成为名校毕业生？</li>
<li>顶会论文：如何发表顶会论文？</li>
</ol>
<h3 id="如何提升自己"><a href="#如何提升自己" class="headerlink" title="如何提升自己"></a>如何提升自己</h3><p>提升自己的能力最重要的是持续学习能力，要持续不断的学习新的知识。利用业余时间、碎片时间等。</p>
<p>学习知识也是有技巧的，需要<code>系统性学习</code>、<code>有目的的去学习</code>、找到<code>学习方法</code>、有正确的<code>学习路径</code>。</p>
<p>在现在这个互联网发达的社会，网上的<code>学习资料</code>成百上千，如何选择？</p>
<p>大头作为工作了快10年的开发，当过<code>上市公司的架构师</code>，当过<code>大厂资深研发</code>，管理过<code>10人团队</code>。</p>
<p>大头会持续分享自身的经验以及学习方法、系统性的学习路径、教程。</p>
<p>所有的信息都由大头本身经过严格的筛选，大家不需要自己去选择，以免走歪路。如果有想学习的小伙伴可以私信大头，免费1对1交流。</p>
<p>目前大头正在输出<code>mysql数据库零基础教程</code>。后续还会输出更多的<code>系统性教程</code>。</p>
<h3 id="如何提升学历"><a href="#如何提升学历" class="headerlink" title="如何提升学历"></a>如何提升学历</h3><p>从上面的招聘也可以看出来，虽然是看能力，可其实大多数要求还是要本科的。像顶会论文这些也需要名校的学生才能发布，其他的学校教学能力有限，学生很难发布顶会论文。</p>
<p>尤其现在大环境不好，大头最开始工作的时候，完全不看学历，现在，就连外包都要求统招本科了。</p>
<p>大头也遇见过很多优秀的人才，干的好好的，今年却被突然要求本科毕业证，哪怕是非统招的也可以，要不然就会面临不续合同、被裁员等。</p>
<p>因此，提升学历也很重要。</p>
<p>但是，如此多的提升学历的方法，如此多付费的广告，该如何选择呢？</p>
<p>现在提升学历无非几种方案。</p>
<ul>
<li>非统招<ul>
<li>成考&#x2F;业余&#x2F;函授&#x2F;非脱产：这四个现在是一样的，没区别，今年开始统一叫<code>非脱产</code>形式了。需要参加<code>成人高考</code>。相对来说比较简单，入学以后多数学校需要在周末去上课，参加考试，有平时分，毕业很简单。</li>
<li>网络教育：无需上课，网上学习，参加考试即可毕业。也是很多机构推的方案。不过现在已经取消了。所以大家不要再相信了。</li>
<li>国家开放大学：入学以后有的需要到学校学习，和非脱产类似，但是比非脱产容易毕业。</li>
<li>自考：极难、没有入学一说，只要参加这个专业所有课程的考试并且考试合格就可以了。也不用到学校学习，适合有自制力且有时间的人。</li>
</ul>
</li>
<li>统招：参加高考上大学，很多人有误区，以为现在不能高考了，其实没有年龄限制，只要你想还是可以去参加的。</li>
</ul>
<p>上面说的是本科，那么对于研究生来说也是一样的。</p>
<ul>
<li>非统招：参加研究生统一考试，入学以后工作日晚上和周末去上课，和统招的统一毕业条件，因此学习年限更久。学费更多。但是入学分数要低一些。因为竞争者少。</li>
<li>统招：参加研究生统一考试，正常上课毕业。</li>
<li>在职：在职研究生属于只有毕业证没有学位证的研究生，是以前的一种形式，以后会被非统招代替。在职研究生入学简单，毕业简单。</li>
</ul>
<h3 id="如何发表顶会论文"><a href="#如何发表顶会论文" class="headerlink" title="如何发表顶会论文"></a>如何发表顶会论文</h3><p>要满足顶会论文的要求，需从选题创新性、实验设计、论文写作、格式规范、投稿流程等多个环节系统把控。</p>
<p>此外，需要不断的阅读优秀的文献，比如其他的顶会论文，学习他们的技巧。</p>
<p>需要有不错的idea和综合能力支撑你的论文发表。</p>
<p>平常可以多练习写作。</p>
<p>对于已经工作的该如何做呢？</p>
<p>可以多撰写软著、专利等。</p>
<p>再比如提升自身的影响力，发表书籍等。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>DeepSeek的高薪招聘不仅反映了AI行业对顶尖人才的渴求，也揭示了技术驱动型企业“以薪酬换速度”的竞争策略。对于求职者而言，扎实的学术背景、工程能力与持续创新意识，是叩开百万年薪大门的核心钥匙。未来，随着AGI研发的深入，这场人才争夺战或将愈演愈烈。</p>
<h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>关注我发送“MySQL知识图谱”领取完整的MySQL学习路线。</p>
<p>发送“电子书”即可领取价值上千的电子书资源。</p>
<p>发送“大厂内推”即可获取京东、美团等大厂内推信息，祝你获得高薪职位。</p>
<p>部分电子书如图所示。</p>
<p><img src="/../images/bottom1.png" alt="概念学习"></p>
<p><img src="/../images/bottom2.png" alt="概念学习"></p>
<p><img src="/../images/bottom3.png" alt="概念学习"></p>
<p><img src="/../images/bottom4.png" alt="概念学习"></p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>DeepSeek</tag>
      </tags>
  </entry>
  <entry>
    <title>支付宝 P0 事故，太离谱了。。。</title>
    <url>/%E6%94%AF%E4%BB%98%E5%AE%9D%20P0%20%E4%BA%8B%E6%95%85%EF%BC%8C%E5%A4%AA%E7%A6%BB%E8%B0%B1%E4%BA%86%E3%80%82%E3%80%82%E3%80%82.html</url>
    <content><![CDATA[<h2 id="支付宝P0事故"><a href="#支付宝P0事故" class="headerlink" title="支付宝P0事故"></a>支付宝P0事故</h2><p>大家好，我是大头。<br>就在2025年1月16号，支付宝平台被曝出现了P0级事故，真可谓是2025年的过年惊喜啊。</p>
<p>怎么回事呢？<br>有网友晒出，在昨天下午14:40-14:45的这段时间里，通过支付宝支付时，均被提示“政府补贴”，减免优惠20%。</p>
<p><img src="/../images/640.jpg" alt="P0"></p>
<p>而这些优惠包括支付以及转账，什么概念呢？</p>
<p>也就是说假设你手里有1万块钱，你把1万转给你媳妇，你只需要支付8000，你媳妇收到1万，白嫖2000。你媳妇再转给你，又能白嫖2000.</p>
<p>来钱简直不要太快啊。如果你有100万呢？一次就是20万啊。</p>
<p>不过呢，真这样可能有点刑。。。</p>
<p>那么什么是P0事故呢？在互联网大厂里面，如何对事故定级呢？</p>
<p>为什么支付宝可以如此快的处理这种事故？</p>
<p>如果我们的公司遇到这种事故该如何处理？</p>
<h3 id="什么是P0事故"><a href="#什么是P0事故" class="headerlink" title="什么是P0事故"></a>什么是P0事故</h3><p>在互联网企业中，P0代表最高级别的事故，通常是核心业务重要功能不可用，且影响范围广泛。以目前这起事故的严重程度来看，绝对是妥妥的P0级别事故了。</p>
<p>除此之外，还会对于涉及到的金额进行资金定损，比如这一次事故中，造成了多少资金损失。</p>
<p>大家别看只是短短的5分钟，对于支付宝这个体量来说，其造成的损失数额绝对不小，不过对于支付宝来说，可能洒洒水啦。</p>
<p>那么除了P0事故来说，还有别的事故等级吗？</p>
<p>当然是有的，还有P1、P2等等，其中P0是最严重的。</p>
<p>相信对于程序员来说，最关心的一点还是，出了这么大的事故，对我有什么影响吗？</p>
<p>不同的事故等级对应的影响也不一样。</p>
<ul>
<li>最低级的事故：可能只是通报批评，下次注意</li>
<li>有一定损失或者影响的事故：比如P2事故，可能会影响你的当年绩效了</li>
<li>有不少损失或者影响的事故：比如P1事故，那么不仅影响你当年的绩效奖金了，还会影响到你的评优、内部的奖项以及最重要的晋升，还可能影响到你直属leader的绩效奖金。</li>
<li>有很大损失或者影响的事故：比如P0事故，那么不光影响上面那些，还包括了你leader的评优、奖项以及晋升。可能还会导致你们团队负责人的绩效、评优、晋升。再严重一些还会收到辞退。</li>
</ul>
<h3 id="为什么支付宝可以如此快的处理这种事故？"><a href="#为什么支付宝可以如此快的处理这种事故？" class="headerlink" title="为什么支付宝可以如此快的处理这种事故？"></a>为什么支付宝可以如此快的处理这种事故？</h3><p>大厂通常都有完善的上线流程以及监控处理。</p>
<p>如何监控呢？</p>
<ul>
<li>链路服务监控</li>
<li>日志机制</li>
<li>报警机制</li>
</ul>
<p>大厂内部都有自己研发的一整套监控报警系统，所以可以快速的发现事故，并依据一整套完善的事故处理机制进行处理。</p>
<p>那对于我们其他公司来说如何处理呢？</p>
<p>对于链路服务监控，我们可以使用<code>SkyWalking</code>来进行监控，以及日志收集，那么当日志收集以后我们还需要进行报警，比如发送报警邮件、短信或者微信提醒。</p>
<p>SkyWalking是什么？</p>
<p>SkyWalking是分布式系统的应用程序性能监控工具，专为微服务、云原生和基于容器（Kubernetes）架构而设计。</p>
<p>下面是SkyWalking官网。</p>
<blockquote>
<p><a href="https://skywalking.apache.org/">https://skywalking.apache.org/</a></p>
</blockquote>
<p>那么当发现事故以后，我们第一步该做什么？定位问题，然后修改？不不不….</p>
<p>当然是第一时间回滚止损了。</p>
<p>接下来才是定位问题、修复。</p>
<p>这么一来就会发现，还需要完善的上线流程、回滚方案。事故处理方案。</p>
<p>对于很多小问题的修改或者需求，我们可能会下意识的觉得，就改动这么点东西，没问题，上了吧。</p>
<p>如果这个时候出了问题，你可能就傻了，根本没想过出问题的解决方案。而且出的问题可能和你改动的东西八竿子打不着，你都想不到是因为你上线导致的。</p>
<p>所以大家切记，上线方案很重要！！！</p>
<p>经验主义害死人啊！！！实践才是检验真理的唯一标准！！！</p>
<h3 id="如果我们的公司遇到这种事故该如何处理"><a href="#如果我们的公司遇到这种事故该如何处理" class="headerlink" title="如果我们的公司遇到这种事故该如何处理"></a>如果我们的公司遇到这种事故该如何处理</h3><p>接下来，如果我们的公司遇到这种事故该如何处理？</p>
<p>首先，像上面说的，我们需要几个方案</p>
<ol>
<li>完善的监控机制，可以使用SkyWalking</li>
<li>完善的日志机制，可以帮助我们快速定位问题</li>
<li>完善的报警机制，可以帮助我们发现问题</li>
<li>完善的上线流程，这里包括代码Review，回滚方案，git分支管理方案等。可以帮助我们快速的解决问题</li>
<li>完善的事故处理流程，当事故发生以后我们该如何处理</li>
</ol>
<h4 id="监控机制"><a href="#监控机制" class="headerlink" title="监控机制"></a>监控机制</h4><p>使用 SkyWalking 即可，官网已经放在上面了，可以根据官方文档进行学习。</p>
<h4 id="日志机制"><a href="#日志机制" class="headerlink" title="日志机制"></a>日志机制</h4><p>不同的日志等级代表不同的日志，并且分开不同的文件，还有在一次请求的时候，需要有唯一ID来检查这一次请求的所有日志。</p>
<p>此外，哪些地方需要记录日志呢？</p>
<ul>
<li>输入</li>
<li>输出</li>
<li>重要处理节点</li>
<li>重要计算结果</li>
<li>异常处理</li>
<li>其他</li>
</ul>
<p>根据这些来快速定位问题。</p>
<p>这里要注意：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不要在日志中记录一些容易报错的代码，你不能因为日志报错而影响主流程。</span><br></pre></td></tr></table></figure>

<h4 id="报警机制"><a href="#报警机制" class="headerlink" title="报警机制"></a>报警机制</h4><p>当监控检测到错误的时候，我们可以进行报警通知，通过邮件、微信、短信等手段进行通知相关人员。</p>
<p>这样可以快速的让相关人员知道出现事故了。接下来才能解决。</p>
<h4 id="上线流程"><a href="#上线流程" class="headerlink" title="上线流程"></a>上线流程</h4><p>上线流程最重要的几点</p>
<ul>
<li>代码Review</li>
<li>完善的测试</li>
<li>回滚方案</li>
</ul>
<p>上线的时候一定要经过这些，哪怕是需求再小 or 改动再小。</p>
<p>因为你永远不知道意外和明天哪一个先来。。。</p>
<h4 id="事故处理流程"><a href="#事故处理流程" class="headerlink" title="事故处理流程"></a>事故处理流程</h4><p>当发现事故以后，如何处理就成为了重点。</p>
<p>当报警机制触发以后，我们首先应该根据上线方案进行回滚。</p>
<p>回滚以后，我们需要发送一些通知，让其他成员知道回滚了。以防止有人稀里糊涂的又把代码发布了或者覆盖了。</p>
<p>接下来根据日志信息配合测试一起快速的定位问题。</p>
<p>……</p>
<p>最终将问题修复。</p>
<p>再次上线。</p>
<p>并将这次事故记录，复盘。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>话说回来了。那么支付宝这次事故。钱会不会追回呢？</p>
<p><img src="/../images/641.jpg" alt="P0"></p>
<p>答案是不会追回资金，支付宝还是很强大的，选择了自己承担这笔损失，当然了，具体哪些程序员倒霉就不知道了。</p>
<p>如果你收到追回短信等，不要相信，都是骗子！！！</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>我是如何一个小时教会小白手写netty框架的</title>
    <url>/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%97%B6%E6%95%99%E4%BC%9A%E5%B0%8F%E7%99%BD%E6%89%8B%E5%86%99netty%E6%A1%86%E6%9E%B6%E7%9A%84.html</url>
    <content><![CDATA[<h1 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h1><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>今天，小白的老师让小白写一个服务器，小白学艺不精，过来向大头求救了。</p>
<p><img src="/../images/java/netty1.png" alt="netty服务器"></p>
<p><img src="/../images/java/netty2.png" alt="netty服务器"></p>
<p><img src="/../images/java/netty3.png" alt="netty服务器"></p>
<p>那么socket究竟是什么呢？套接字接口(socket interface)是一组函数，它们和Unix I &#x2F;O函数结合起来，用以创建网络应用。从Linux内核的角度来看， 一个套接字就是通信的一个端点。从Linux程序的角度来看，套接字就是一个有相应描述符的打开文件。</p>
<p>下图来源于CSAPP的书。</p>
<p><img src="/../images/csapp/csapp11-2.png" alt="page table"></p>
<p>这张图清晰的表明了socket是个啥，从逻辑上说，这玩意就是个接口，从这个接口能发送和接收数据，从物理上说，这玩意就是个文件，发送数据就是往这个文件里面写入数据，接收数据就是从这个文件里面读取数据。所以Socket也是个IO操作。只不过这个文件的数据不存储在你电脑的硬盘里面，而是通过网络发送出去了。</p>
<p>通过<code>socket</code>函数可以打开一个文件，返回一个文件描述符。文件描述符可以简单的理解为文件的ID，唯一标识，一般默认打开的3个文件描述符就是标准输入，标准输出，错误输出，对应0、1、2.假设我们打开了一个socket文件，描述符是3.</p>
<p>接下来通过服务器通过<code>bind</code>函数，可以将这个socket文件，和一个IP还有端口号进行绑定。绑定以后写入这个文件的数据就会从这个IP端口读取出来或者发送出去。</p>
<p>socket分为客户端和服务器，客户端主动发起请求，服务器被动接受请求，<code>listen</code>函数就是告诉Linux内核，我这个socket是一个服务器，而不是一个客户端。</p>
<p>最后通过<code>accept</code>函数，来等待客户端的连接.accept函数会返回一个新的文件描述符，通过这个新的文件进行传递数据，而老的文件仅仅负责建立连接。</p>
<p>下图为accept的时候服务器的状态，这个时候等待连接。<br><img src="/../images/java/netty4.png" alt="netty服务器"></p>
<p>当连接建立以后，会通过新的文件描述符4进行通信。</p>
<p><img src="/../images/java/netty5.png" alt="netty服务器"></p>
<p>基于上述理论知识，学过哲学的都知道，<code>实践是检验真理的唯一标准</code>。所以小白用java实现了第一版socket服务器。端口号是8888，祝看到这里的兄弟们发发发发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILE_PATH</span> <span class="operator">=</span> <span class="string">&quot;HelloWorld.java&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">readFileAsString</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">contentBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath))) &#123;</span><br><span class="line">            String currentLine;</span><br><span class="line">            <span class="keyword">while</span> ((currentLine = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(currentLine); <span class="comment">// 打印读取的每一行</span></span><br><span class="line">                contentBuilder.append(currentLine).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> contentBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8888</span>; <span class="comment">// 服务器监听的端口号</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建服务器端的ServerSocket，绑定端口号</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">            System.out.println(<span class="string">&quot;Server is running and listening on port &quot;</span> + port);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 服务器无限循环，等待客户端连接</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 服务器调用accept()方法，阻塞并等待客户端连接</span></span><br><span class="line">                <span class="type">Socket</span> <span class="variable">clientSocket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                System.out.println(<span class="string">&quot;Client connected.&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 读取HTTP请求</span></span><br><span class="line">                    <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(clientSocket.getInputStream()));</span><br><span class="line">                    String inputLine;</span><br><span class="line">                    <span class="type">StringBuilder</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                    <span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="literal">null</span> &amp;&amp; !inputLine.isEmpty()) &#123;</span><br><span class="line">                        request.append(inputLine).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 发送HTTP响应</span></span><br><span class="line">                    <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(clientSocket.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">fileContent</span> <span class="operator">=</span> readFileAsString(FILE_PATH);</span><br><span class="line">                    <span class="type">long</span> <span class="variable">contentLength</span> <span class="operator">=</span> fileContent.getBytes().length;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span> +</span><br><span class="line">                            <span class="string">&quot;Content-Type: application/json\r\n&quot;</span> +</span><br><span class="line">                            <span class="string">&quot;Content-Length: &quot;</span> + contentLength + <span class="string">&quot;\r\n&quot;</span> +</span><br><span class="line">                            <span class="string">&quot;Connection: close\r\n&quot;</span> +</span><br><span class="line">                            <span class="string">&quot;\r\n&quot;</span> +</span><br><span class="line">                            fileContent;</span><br><span class="line">                    out.println(response);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 关闭连接</span></span><br><span class="line">                    clientSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Client says: hello world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 关闭连接</span></span><br><span class="line">                clientSocket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码里面没有<code>bind</code>和<code>listen</code>。这是因为被java封装起来了。如果看看<code>ServerSocket</code>里面的代码就能看见这两个函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ServerSocket</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//调用了另外一个构造函数</span></span><br><span class="line">    <span class="built_in">this</span>(port, <span class="number">50</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ServerSocket</span><span class="params">(<span class="type">int</span> port, <span class="type">int</span> backlog, InetAddress bindAddr)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// 参数检测</span></span><br><span class="line">  <span class="keyword">if</span> (port &lt; <span class="number">0</span> || port &gt; <span class="number">0xFFFF</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Port value out of range: &quot;</span> + port);</span><br><span class="line">  <span class="keyword">if</span> (backlog &lt; <span class="number">1</span>)</span><br><span class="line">      backlog = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建了一个实现类</span></span><br><span class="line">  <span class="built_in">this</span>.impl = createImpl();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 调用了bind方法</span></span><br><span class="line">      bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(bindAddr, port), backlog);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException | SecurityException e) &#123;</span><br><span class="line">      close();</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面能看到调用了<code>bind</code>方法。再看看<code>bind</code>里面呢。能看到这个里面有<code>getImpl().bind</code>和<code>getImpl().listen</code>。这就是上面说的<code>bind</code>和<code>listen</code>函数了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将服务器Socket绑定到指定的端点地址并设置监听队列长度</span></span><br><span class="line"><span class="comment"> * 此方法确保Socket未关闭且未绑定，并验证端点地址和backlog参数的合法性</span></span><br><span class="line"><span class="comment"> * 如果满足所有条件，则进行绑定和监听设置</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> endpoint 要绑定的端点地址，如果为null，则创建一个未指定端口的InetSocketAddress实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> backlog 监听队列的长度，如果小于1，则使用默认值50</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException 如果绑定或监听过程中发生I/O错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SocketException 如果Socket已关闭、已绑定、地址未解析或不支持的地址类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果端点地址类型不受支持</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(SocketAddress endpoint, <span class="type">int</span> backlog)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 检查Socket是否已关闭</span></span><br><span class="line">    <span class="keyword">if</span> (isClosed())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SocketException</span>(<span class="string">&quot;Socket is closed&quot;</span>);</span><br><span class="line">    <span class="comment">// 检查Socket是否已绑定</span></span><br><span class="line">    <span class="keyword">if</span> (isBound())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SocketException</span>(<span class="string">&quot;Already bound&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果未指定端点地址，则创建一个未指定端口的InetSocketAddress实例</span></span><br><span class="line">    <span class="keyword">if</span> (endpoint == <span class="literal">null</span>)</span><br><span class="line">        endpoint = <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 检查端点地址是否为InetSocketAddress类型</span></span><br><span class="line">    <span class="keyword">if</span> (!(endpoint <span class="keyword">instanceof</span> InetSocketAddress epoint))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unsupported address type&quot;</span>);</span><br><span class="line">    <span class="comment">// 检查端点地址是否已解析</span></span><br><span class="line">    <span class="keyword">if</span> (epoint.isUnresolved())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SocketException</span>(<span class="string">&quot;Unresolved address&quot;</span>);</span><br><span class="line">    <span class="comment">// 检查backlog参数是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (backlog &lt; <span class="number">1</span>)</span><br><span class="line">        backlog = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全检查，确保有权限监听指定端口</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;removal&quot;)</span></span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="literal">null</span>)</span><br><span class="line">        security.checkListen(epoint.getPort());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步块，确保线程安全</span></span><br><span class="line">    <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">        <span class="comment">// 再次检查Socket是否已关闭或绑定</span></span><br><span class="line">        <span class="keyword">if</span> (closed)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SocketException</span>(<span class="string">&quot;Socket is closed&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (bound)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SocketException</span>(<span class="string">&quot;Already bound&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用实现类的方法进行实际的绑定和监听设置</span></span><br><span class="line">        getImpl().bind(epoint.getAddress(), epoint.getPort());</span><br><span class="line">        getImpl().listen(backlog);</span><br><span class="line">        <span class="comment">// 设置绑定状态为true</span></span><br><span class="line">        bound = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../images/java/netty6.png" alt="第一版socket"></p>
<p><img src="/../images/java/netty7.png" alt="第一版socket"></p>
<p>让我们用<code>wrk</code>压测一下。可以发现很垃圾。仅仅处理了4个请求，虽然响应时间很快。可是吞吐量太低了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Running 30s test @ http://localhost:8888</span><br><span class="line">  10 threads and 10000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency    55.33ms  326.77us  55.72ms   50.00%</span><br><span class="line">    Req/Sec    40.00      0.00    40.00    100.00%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%   55.44ms</span><br><span class="line">     75%   55.72ms</span><br><span class="line">     90%   55.72ms</span><br><span class="line">     99%   55.72ms</span><br><span class="line">  4 requests in 30.10s, 852.00B read</span><br><span class="line">  Socket errors: connect 7967, read 196512, write 14, timeout 0</span><br><span class="line">Requests/sec:      0.13</span><br><span class="line">Transfer/sec:      28.30B</span><br></pre></td></tr></table></figure>

<p><img src="/../images/java/netty8.png" alt="第一版socket"></p>
<p><img src="/../images/java/netty9.png" alt="第一版socket"></p>
<p><img src="/../images/java/netty10.png" alt="第一版socket"></p>
<p>接下来，上线程池，小白实现了第二版代码。这次的代码加入了线程池，所有的客户端请求建立以后通过线程池的线程进行处理。建立10个线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleHttpServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8888</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILE_PATH</span> <span class="operator">=</span> <span class="string">&quot;HelloWorld.java&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(PORT)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Server is running at http://localhost:&quot;</span> + PORT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">clientSocket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> <span class="title class_">ClientHandler</span>(clientSocket));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClientHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Socket clientSocket;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ClientHandler</span><span class="params">(Socket clientSocket)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.clientSocket = clientSocket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 读取HTTP请求</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(clientSocket.getInputStream()));</span><br><span class="line">                String inputLine;</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="literal">null</span> &amp;&amp; !inputLine.isEmpty()) &#123;</span><br><span class="line">                    request.append(inputLine).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 发送HTTP响应</span></span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(clientSocket.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">fileContent</span> <span class="operator">=</span> readFileAsString(FILE_PATH);</span><br><span class="line">                <span class="type">long</span> <span class="variable">contentLength</span> <span class="operator">=</span> fileContent.getBytes().length;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span> +</span><br><span class="line">                            <span class="string">&quot;Content-Type: application/json\r\n&quot;</span> +</span><br><span class="line">                            <span class="string">&quot;Content-Length: &quot;</span> + contentLength + <span class="string">&quot;\r\n&quot;</span> +</span><br><span class="line">                            <span class="string">&quot;Connection: close\r\n&quot;</span> +</span><br><span class="line">                            <span class="string">&quot;\r\n&quot;</span> +</span><br><span class="line">                            fileContent;</span><br><span class="line">                    out.println(response);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 关闭连接</span></span><br><span class="line">                clientSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String <span class="title function_">readFileAsString</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">contentBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath))) &#123;</span><br><span class="line">                String currentLine;</span><br><span class="line">                <span class="keyword">while</span> ((currentLine = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println(currentLine); <span class="comment">// 打印读取的每一行</span></span><br><span class="line">                    contentBuilder.append(currentLine).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> contentBuilder.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>接下来在看压测结果。同样30s，处理了13个请求，处理时间虽然略有上升，但是整体性能提升了很多。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Running 30s test @ http://localhost:8888</span><br><span class="line">  10 threads and 10000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency   118.94ms   32.73ms 148.30ms   53.85%</span><br><span class="line">    Req/Sec    17.50     21.62    60.00     83.33%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%  147.83ms</span><br><span class="line">     75%  148.02ms</span><br><span class="line">     90%  148.25ms</span><br><span class="line">     99%  148.30ms</span><br><span class="line">  13 requests in 30.10s, 2.70KB read</span><br><span class="line">  Socket errors: connect 7967, read 198469, write 1, timeout 0</span><br><span class="line">Requests/sec:      0.43</span><br><span class="line">Transfer/sec:      91.99B</span><br></pre></td></tr></table></figure>

<p><img src="/../images/java/netty11.png" alt="第一版socket"></p>
<p><img src="/../images/java/netty12.png" alt="第一版socket"></p>
<h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p>在 Java 中，BIO、NIO 和 AIO 是三种不同的 I&#x2F;O 模型，它们各自的工作原理和使用场景有所不同。下面简要说明这三种 I&#x2F;O 模型：</p>
<h4 id="BIO（Blocking-I-x2F-O，阻塞-I-x2F-O）"><a href="#BIO（Blocking-I-x2F-O，阻塞-I-x2F-O）" class="headerlink" title="BIO（Blocking I&#x2F;O，阻塞 I&#x2F;O）"></a>BIO（Blocking I&#x2F;O，阻塞 I&#x2F;O）</h4><p>BIO就类似于你去胖东来，但是人太多了，要排队进去，而且你这个时候走了，那么你的位置就没了，需要重新排队，所以你不能离开，你只能排队等着！！！这就是所谓的同步阻塞。</p>
<p><img src="/../images/java/netty13.png" alt="第一版socket"></p>
<p>原理：<br>BIO 是传统的 I&#x2F;O 模型，在这个模型中，每次读取或写入数据时，线程都会被阻塞，直到操作完成。<br>每个连接对应一个线程，线程会一直阻塞，直到 I&#x2F;O 操作完成后才能继续执行其他任务。</p>
<p>特性：</p>
<ul>
<li>阻塞：每次读写操作都会等待数据的到来或写入完成，阻塞当前线程。</li>
<li>线程绑定：每个客户端连接都会占用一个独立的线程。</li>
<li>简单直观：编程模型简单，适合小规模应用，但不适合高并发的场景。</li>
</ul>
<p>优缺点：</p>
<ul>
<li>优点：实现简单，编程模型直观。</li>
<li>缺点：性能差，尤其是在高并发场景下，线程过多导致资源浪费（线程上下文切换开销大）。</li>
</ul>
<p>使用场景：<br>适合低并发、连接数不多的应用场景，例如小型 Web 服务。</p>
<h4 id="NIO（New-I-x2F-O，新-I-x2F-O）"><a href="#NIO（New-I-x2F-O，新-I-x2F-O）" class="headerlink" title="NIO（New I&#x2F;O，新 I&#x2F;O）"></a>NIO（New I&#x2F;O，新 I&#x2F;O）</h4><p>NIO通过操作系统提供的IO多路复用机制，可以实现多线程的性能，因为IO多路复用，本质上是单线程的，所以省去了操作系统线程切换的开销。</p>
<p>拿胖东来说，BIO你只能等着，但如果你是NIO，那么胖东来说，我给你发个号吧，你是88号，接下来你爱干啥干啥去，等我叫88号了，你过来就行了。但是呢，我只负责叫号，你离远了听不见那是你的事，你的时不时的过来问我一下，到88号了吗？到了你就进去，没到你就等着。</p>
<p><img src="/../images/java/netty14.png" alt="第一版socket"></p>
<p>从代码来说，就是通过select进行订阅。比如select订阅文件描述符3号的状态，操作系统如果发现有数据从网络中传输过来，那么就写入3号文件，写完以后，操作系统就改变3号文件的状态，这个时候select如果过来判断3号的状态，发现变了，就知道可以执行对应的操作了，比如服务器开始运行，然后读取文件内容发送给客户端。</p>
<p><img src="/../images/java/netty15.png" alt="第一版socket"></p>
<p>原理：<br>NIO 提供了 非阻塞 I&#x2F;O 的能力，支持多路复用技术，允许一个线程同时处理多个 I&#x2F;O 操作。<br>通过使用 Selector 和 Channel，NIO 可以在一个线程中处理多个客户端的 I&#x2F;O 请求。<br>非阻塞：读取和写入操作不会阻塞线程，如果没有数据可用，线程会继续执行其他任务。</p>
<p>特性：</p>
<ul>
<li>非阻塞 I&#x2F;O：可以通过轮询和事件通知的方式处理 I&#x2F;O 请求，而不必阻塞等待。</li>
<li>多路复用：通过 Selector 实现一个线程管理多个 Channel，处理多个连接。</li>
<li>高效：减少了线程的开销，适用于高并发场景。</li>
</ul>
<p>优缺点：</p>
<ul>
<li>优点：比 BIO 更高效，适合高并发、高负载的应用。</li>
<li>缺点：编程模型较为复杂，需要理解 Selector、Channel、Buffer 的使用方式，开发成本较高。</li>
</ul>
<p>使用场景：<br>高并发、大规模连接的网络应用，如服务器（HTTP、Chat Server 等）、数据库连接池、文件上传下载等。</p>
<h4 id="AIO（Asynchronous-I-x2F-O，异步-I-x2F-O）"><a href="#AIO（Asynchronous-I-x2F-O，异步-I-x2F-O）" class="headerlink" title="AIO（Asynchronous I&#x2F;O，异步 I&#x2F;O）"></a>AIO（Asynchronous I&#x2F;O，异步 I&#x2F;O）</h4><p>AIO就是说，在胖东来排队的时候，你找他要号的时候，还留了个手机号码，告诉他，到我了你就给我打电话，他给你88号，等叫到88号了，他就给你打电话说，到你了，过来吧。和NIO的区别就是你不用老过来问了，到了我打电话叫你。</p>
<p><img src="/../images/java/netty16.png" alt="第一版socket"></p>
<p>原理：<br>AIO 是 Java 7 引入的异步 I&#x2F;O 模型，它的关键特性是完全异步，即操作完成后系统会通过回调通知应用程序。<br>在 AIO 中，线程发起 I&#x2F;O 请求后，不会阻塞等待，而是返回，等 I&#x2F;O 操作完成时，操作系统会通知 Java 程序，程序再通过回调函数获取结果。</p>
<p>特性：</p>
<ul>
<li>异步：I&#x2F;O 操作发起后，线程立即返回，不会等待操作完成。</li>
<li>事件驱动：操作完成后，系统通过回调通知应用程序处理结果。</li>
<li>无需轮询：不同于 NIO，AIO 不需要手动轮询 Selector，操作完成后直接通过回调处理结果。</li>
</ul>
<p>优缺点：</p>
<ul>
<li>优点：可以进一步减少线程和上下文切换，性能非常高，适合超高并发的应用。</li>
<li>缺点：复杂度最高，需要理解回调和事件处理机制，调试较为困难。</li>
</ul>
<p>使用场景：<br>适用于极高并发的应用场景，如实时数据流处理、大规模分布式系统等。</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>BIO</strong></th>
<th><strong>NIO</strong></th>
<th><strong>AIO</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>阻塞方式</strong></td>
<td>阻塞（每个操作阻塞当前线程）</td>
<td>非阻塞（通过轮询和事件驱动）</td>
<td>异步（操作完成后通过回调通知）</td>
</tr>
<tr>
<td><strong>线程管理</strong></td>
<td>每个连接一个线程</td>
<td>一个线程处理多个连接</td>
<td>一个线程发起请求，回调通知结果</td>
</tr>
<tr>
<td><strong>编程复杂度</strong></td>
<td>低</td>
<td>中</td>
<td>高</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>性能差，适用于低并发场景</td>
<td>性能优越，适用于高并发场景</td>
<td>性能最优，适用于超高并发场景</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>小规模服务，低并发应用</td>
<td>高并发应用，如 Web 服务器</td>
<td>极高并发应用，如大数据流处理</td>
</tr>
</tbody></table>
<h4 id="NIO实现"><a href="#NIO实现" class="headerlink" title="NIO实现"></a>NIO实现</h4><p>说了这么多，小白也实现了NIO版本的服务器。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOHttpServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8888</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILE_TO_SERVE</span> <span class="operator">=</span> <span class="string">&quot;HelloWorld.java&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 打开一个 Selector，用于管理多个通道的 I/O 事件</span></span><br><span class="line">            <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 打开一个 ServerSocketChannel，用于监听客户端连接</span></span><br><span class="line">            <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 绑定到指定端口，并配置为非阻塞模式</span></span><br><span class="line">            serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">java</span>.net.InetSocketAddress(PORT));</span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 将 ServerSocketChannel 注册到 Selector，监听 ACCEPT 事件</span></span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;NIO HTTP Server started on port &quot;</span> + PORT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 5. 阻塞等待事件发生（或超时返回）</span></span><br><span class="line">                selector.select();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 6. 获取所有准备好的事件</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                    iterator.remove(); <span class="comment">// 移除已处理的事件</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        <span class="comment">// 处理新的客户端连接</span></span><br><span class="line">                        handleAccept(key);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        <span class="comment">// 处理客户端请求</span></span><br><span class="line">                        handleRead(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受客户端连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleAccept</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">        clientChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 注册客户端通道到 Selector，监听 READ 事件</span></span><br><span class="line">        clientChannel.register(key.selector(), SelectionKey.OP_READ);</span><br><span class="line">        System.out.println(<span class="string">&quot;Accepted new connection from &quot;</span> + clientChannel.getRemoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取客户端请求并响应</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取客户端发送的数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> clientChannel.read(buffer);</span><br><span class="line">        <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 客户端关闭连接</span></span><br><span class="line">            clientChannel.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="type">byte</span>[] requestData = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.remaining()];</span><br><span class="line">        buffer.get(requestData);</span><br><span class="line">        <span class="type">String</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(requestData);</span><br><span class="line">        System.out.println(<span class="string">&quot;Received request:\n&quot;</span> + request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取 HelloWorld.java 文件内容</span></span><br><span class="line">        String fileContent;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileContent = Files.readString(Paths.get(FILE_TO_SERVE));</span><br><span class="line">            System.out.println(<span class="string">&quot;Read file content:\n&quot;</span> + fileContent);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            fileContent = <span class="string">&quot;Error reading file: &quot;</span> + e.getMessage();</span><br><span class="line">            System.err.println(fileContent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造 HTTP 响应</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;Content-Type: application/json\r\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;Content-Length: &quot;</span> + fileContent.length() + <span class="string">&quot;\r\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;\r\n&quot;</span> +</span><br><span class="line">                fileContent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将响应写入客户端</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">responseBuffer</span> <span class="operator">=</span> ByteBuffer.wrap(response.getBytes());</span><br><span class="line">        clientChannel.write(responseBuffer);</span><br><span class="line">        clientChannel.close(); <span class="comment">// 响应完成后关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在执行一下压测,结果表明处理了24个请求，吞吐量大大增加了。性能有明显提升，而且更加稳定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Running 30s test @ http://localhost:8888</span><br><span class="line">  10 threads and 10000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency   145.80ms    9.32ms 170.26ms   87.50%</span><br><span class="line">    Req/Sec    14.88      8.95    30.00     62.50%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%  142.46ms</span><br><span class="line">     75%  142.72ms</span><br><span class="line">     90%  168.73ms</span><br><span class="line">     99%  170.26ms</span><br><span class="line">  24 requests in 30.09s, 4.52KB read</span><br><span class="line">  Socket errors: connect 7967, read 192317, write 0, timeout 0</span><br><span class="line">Requests/sec:      0.80</span><br><span class="line">Transfer/sec:     153.92B</span><br></pre></td></tr></table></figure>

<p><img src="/../images/java/netty17.png" alt="第一版socket"></p>
<p><img src="/../images/java/netty18.png" alt="第一版socket"></p>
<p><img src="/../images/java/netty19.png" alt="第一版socket"></p>
<p>小白又把代码重新改了一遍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOHttpServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8888</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILE_PATH</span> <span class="operator">=</span> <span class="string">&quot;HelloWorld.java&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NIOHttpServer</span>().start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Server error: &quot;</span> + e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverChannel.bind(<span class="keyword">new</span> <span class="title class_">java</span>.net.InetSocketAddress(PORT));</span><br><span class="line">        serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Server started on port &quot;</span> + PORT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">                keyIterator.remove();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    handleAccept(key, selector);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    handleRead(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleAccept</span><span class="params">(SelectionKey key, Selector selector)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> serverChannel.accept();</span><br><span class="line">        clientChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        clientChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        System.out.println(<span class="string">&quot;Accepted connection from &quot;</span> + clientChannel.getRemoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleRead</span><span class="params">(SelectionKey key)</span> &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> clientChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;</span><br><span class="line">                clientChannel.close();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="type">String</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.limit());</span><br><span class="line">            System.out.println(<span class="string">&quot;Received request: \n&quot;</span> + request);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileContent</span> <span class="operator">=</span> readFileContent(FILE_PATH);</span><br><span class="line">            <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> constructHttpResponse(fileContent);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">responseBuffer</span> <span class="operator">=</span> ByteBuffer.wrap(response.getBytes());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (responseBuffer.hasRemaining()) &#123;</span><br><span class="line">                clientChannel.write(responseBuffer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clientChannel.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Error handling client request: &quot;</span> + e.getMessage());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clientChannel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Error closing client connection: &quot;</span> + ex.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">constructHttpResponse</span><span class="params">(String bodyContent)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">headers</span> <span class="operator">=</span> constructHttpHeaders(bodyContent.length());</span><br><span class="line">        <span class="keyword">return</span> headers + bodyContent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">constructHttpHeaders</span><span class="params">(<span class="type">int</span> contentLength)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;Content-Type: text/plain\r\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;Content-Length: &quot;</span> + contentLength + <span class="string">&quot;\r\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">readFileContent</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(filePath);</span><br><span class="line">            <span class="keyword">return</span> Files.readString(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Error reading file: &quot;</span> + e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;File not found or error reading file.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../images/java/netty23.png" alt="netty"></p>
<p><img src="/../images/java/netty24.png" alt="netty"></p>
<h3 id="零拷贝技术"><a href="#零拷贝技术" class="headerlink" title="零拷贝技术"></a>零拷贝技术</h3><p>现在代码中读取文件内容在返回的过程如下图所示。可以看到一共有7步，有多次IO，而且内存里面有两份一样的数据，空间占用大。</p>
<p><img src="/../images/java/netty25.png" alt="netty"></p>
<p>零拷贝是操作系统提供的一种技术，操作系统提供了一个函数，通过这个函数就可以实现零拷贝，看一下零拷贝的过程吧。</p>
<p>零拷贝可以减少IO操作次数，减少内存空间占用，内存里面实际上只有一份内容，网络发送读取的就是那个内容。没有发送内存拷贝动作。</p>
<p><img src="/../images/java/netty26.png" alt="netty"></p>
<p>用零拷贝技术重写代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOZeroCopyHttpServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8888</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILE_PATH</span> <span class="operator">=</span> <span class="string">&quot;HelloWorld.java&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NIOZeroCopyHttpServer</span>().start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Server error: &quot;</span> + e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverChannel.bind(<span class="keyword">new</span> <span class="title class_">java</span>.net.InetSocketAddress(PORT));</span><br><span class="line">        serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Server started on port &quot;</span> + PORT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">                keyIterator.remove();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    handleAccept(key, selector);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    handleRead(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleAccept</span><span class="params">(SelectionKey key, Selector selector)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> serverChannel.accept();</span><br><span class="line">        clientChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        clientChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        System.out.println(<span class="string">&quot;Accepted connection from &quot;</span> + clientChannel.getRemoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleRead</span><span class="params">(SelectionKey key)</span> &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> clientChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;</span><br><span class="line">                clientChannel.close();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="type">String</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.limit());</span><br><span class="line">            System.out.println(<span class="string">&quot;Received request: \n&quot;</span> + request);</span><br><span class="line"></span><br><span class="line">            sendFileUsingZeroCopy(clientChannel, FILE_PATH);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Error handling client request: &quot;</span> + e.getMessage());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clientChannel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Error closing client connection: &quot;</span> + ex.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendFileUsingZeroCopy</span><span class="params">(SocketChannel clientChannel, String filePath)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(filePath))) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">fileSize</span> <span class="operator">=</span> fileChannel.size();</span><br><span class="line">            <span class="type">String</span> <span class="variable">headers</span> <span class="operator">=</span> constructHttpHeaders(fileSize);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">headerBuffer</span> <span class="operator">=</span> ByteBuffer.wrap(headers.getBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Write headers first</span></span><br><span class="line">            <span class="keyword">while</span> (headerBuffer.hasRemaining()) &#123;</span><br><span class="line">                clientChannel.write(headerBuffer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 零拷贝</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (position &lt; fileSize) &#123;</span><br><span class="line">                position += fileChannel.transferTo(position, fileSize - position, clientChannel);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clientChannel.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Error sending file: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">constructHttpHeaders</span><span class="params">(<span class="type">long</span> contentLength)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;Content-Type: text/plain\r\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;Content-Length: &quot;</span> + contentLength + <span class="string">&quot;\r\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;Connection: close\r\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次使用wrk压测。可以看到同样30s内，处理了48个请求，吞吐量再次提升。性能更加强大了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Running 30s test @ http://localhost:8888</span><br><span class="line">  10 threads and 10000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency   100.27ms   64.55ms 208.10ms   72.92%</span><br><span class="line">    Req/Sec    36.45     88.79   303.00     90.91%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%   62.63ms</span><br><span class="line">     75%  200.92ms</span><br><span class="line">     90%  204.08ms</span><br><span class="line">     99%  208.10ms</span><br><span class="line">  48 requests in 30.10s, 9.66KB read</span><br><span class="line">  Socket errors: connect 7967, read 195016, write 3, timeout 0</span><br><span class="line">Requests/sec:      1.59</span><br><span class="line">Transfer/sec:     328.50B</span><br></pre></td></tr></table></figure>

<p><img src="/../images/java/netty27.png" alt="netty"></p>
<h3 id="零拷贝-线程池"><a href="#零拷贝-线程池" class="headerlink" title="零拷贝+线程池"></a>零拷贝+线程池</h3><p>小白又给代码加上了线程池。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOThreadZeroCopyHttpServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8888</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILE_PATH</span> <span class="operator">=</span> <span class="string">&quot;HelloWorld.java&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREAD_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(THREAD_POOL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NIOThreadZeroCopyHttpServer</span>().start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Server error: &quot;</span> + e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverChannel.bind(<span class="keyword">new</span> <span class="title class_">java</span>.net.InetSocketAddress(PORT));</span><br><span class="line">        serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Server started on port &quot;</span> + PORT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            selector.select(); <span class="comment">// Block until events are available</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">                keyIterator.remove(); <span class="comment">// Ensure key is removed to prevent re-processing</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!key.isValid()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// Skip invalid keys</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        handleAccept(key, selector);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;CancelledKeyException: &quot;</span> + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleAccept</span><span class="params">(SelectionKey key, Selector selector)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> serverChannel.accept();</span><br><span class="line">        clientChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        clientChannel.setOption(java.net.StandardSocketOptions.TCP_NODELAY, <span class="literal">true</span>);</span><br><span class="line">        clientChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Accepted connection from &quot;</span> + clientChannel.getRemoteAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Submit task to thread pool for processing</span></span><br><span class="line">        threadPool.submit(() -&gt; handleRequest(clientChannel));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(SocketChannel clientChannel)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> clientChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;</span><br><span class="line">                clientChannel.close();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="type">String</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.limit());</span><br><span class="line">            System.out.println(<span class="string">&quot;Received request: \n&quot;</span> + request);</span><br><span class="line"></span><br><span class="line">            sendFileUsingZeroCopy(clientChannel, FILE_PATH);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Error handling client request: &quot;</span> + e.getMessage());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clientChannel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Error closing client connection: &quot;</span> + ex.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendFileUsingZeroCopy</span><span class="params">(SocketChannel clientChannel, String filePath)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(filePath))) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">fileSize</span> <span class="operator">=</span> fileChannel.size();</span><br><span class="line">            <span class="type">String</span> <span class="variable">headers</span> <span class="operator">=</span> constructHttpHeaders(fileSize);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">headerBuffer</span> <span class="operator">=</span> ByteBuffer.wrap(headers.getBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Write headers first</span></span><br><span class="line">            <span class="keyword">while</span> (headerBuffer.hasRemaining()) &#123;</span><br><span class="line">                clientChannel.write(headerBuffer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Use zero-copy to send file content</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (position &lt; fileSize) &#123;</span><br><span class="line">                position += fileChannel.transferTo(position, fileSize - position, clientChannel);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clientChannel.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Error sending file: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">constructHttpHeaders</span><span class="params">(<span class="type">long</span> contentLength)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;Content-Type: text/plain\r\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;Content-Length: &quot;</span> + contentLength + <span class="string">&quot;\r\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;Connection: close\r\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>压测结果如下,整体性能有明显提升</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Running 30s test @ http://localhost:8888</span><br><span class="line">  10 threads and 10000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     7.64ms    8.85ms  27.32ms   82.47%</span><br><span class="line">    Req/Sec   113.30     99.51   300.00     80.00%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    2.09ms</span><br><span class="line">     75%   13.33ms</span><br><span class="line">     90%   23.46ms</span><br><span class="line">     99%   27.32ms</span><br><span class="line">  113 requests in 30.10s, 22.73KB read</span><br><span class="line">  Socket errors: connect 7967, read 191435, write 12, timeout 0</span><br><span class="line">Requests/sec:      3.75</span><br><span class="line">Transfer/sec:     773.29B</span><br></pre></td></tr></table></figure>

<p><img src="/../images/java/netty28.png" alt="netty"></p>
<p><img src="/../images/java/netty29.png" alt="netty"></p>
<h3 id="BOSS-Worker模式"><a href="#BOSS-Worker模式" class="headerlink" title="BOSS-Worker模式"></a>BOSS-Worker模式</h3><p>之前的代码里面，Worker线程接收到请求以后进行工作，这个时候就会占用这个请求连接，在工作。就相当于干了两份活</p>
<ul>
<li>接收请求</li>
<li>处理任务</li>
</ul>
<p>将这两个活，分给两个人，就能提升效率，BOSS线程池仅仅接收请求，再把请求分配给Worker线程，Worker线程仅仅需要处理任务。还有一个好处就是，BOSS可以有多个，比如多个领导负责分配任务。</p>
<p>新的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOBossWorkerHttpServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8888</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BOSS_THREAD_COUNT</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// Boss 线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WORKER_THREAD_COUNT</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// Worker 线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILE_PATH</span> <span class="operator">=</span> <span class="string">&quot;HelloWorld.java&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// Boss 线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">bossThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(BOSS_THREAD_COUNT);</span><br><span class="line">        <span class="comment">// Worker 线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">workerThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(WORKER_THREAD_COUNT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个主选择器（Boss Selector）</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">bossSelector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        serverChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(PORT));</span><br><span class="line">        serverChannel.register(bossSelector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;HTTP Server started on port &quot;</span> + PORT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Boss 线程负责分发连接</span></span><br><span class="line">        bossThreadPool.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    bossSelector.select(); <span class="comment">// 等待事件</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = bossSelector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                        iterator.remove();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> serverChannel.accept();</span><br><span class="line">                            clientChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                            System.out.println(<span class="string">&quot;Accepted new connection: &quot;</span> + clientChannel.getRemoteAddress());</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 将新连接交给 Worker 线程池处理</span></span><br><span class="line">                            workerThreadPool.submit(() -&gt; handleClient(clientChannel));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Error in Boss thread: &quot;</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Worker 线程处理客户端连接的读写操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleClient</span><span class="params">(SocketChannel clientChannel)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Selector</span> <span class="variable">workerSelector</span> <span class="operator">=</span> Selector.open()) &#123;</span><br><span class="line">            clientChannel.register(workerSelector, SelectionKey.OP_READ);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (clientChannel.isOpen()) &#123;</span><br><span class="line">                workerSelector.select(); <span class="comment">// 等待事件</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = workerSelector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                    iterator.remove();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                        buffer.clear();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">                        <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;</span><br><span class="line">                            closeChannel(channel);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 请求解析 (这里只简单返回文件内容作为响应)</span></span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        sendFile(channel, FILE_PATH);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Error in Worker thread: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeChannel(clientChannel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用零拷贝技术发送文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendFile</span><span class="params">(SocketChannel clientChannel, String filePath)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(filePath))) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">fileSize</span> <span class="operator">=</span> fileChannel.size();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构造 HTTP 响应头</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;Content-Type: text/plain\r\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;Content-Length: &quot;</span> + fileSize + <span class="string">&quot;\r\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">headerBuffer</span> <span class="operator">=</span> ByteBuffer.wrap(headers.getBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送响应头</span></span><br><span class="line">            <span class="keyword">while</span> (headerBuffer.hasRemaining()) &#123;</span><br><span class="line">                clientChannel.write(headerBuffer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用零拷贝发送文件内容</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (position &lt; fileSize) &#123;</span><br><span class="line">                position += fileChannel.transferTo(position, fileSize - position, clientChannel);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;File sent successfully to: &quot;</span> + clientChannel.getRemoteAddress());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Error sending file: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭通道</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeChannel</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="literal">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">                System.out.println(<span class="string">&quot;Channel closed.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Error closing channel: &quot;</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当BOSS数量为1个的时候，压测结果。可以看到吞吐量大大提升了一波。整体性能更好了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Running 30s test @ http://localhost:8888</span><br><span class="line">  10 threads and 10000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency   326.78ms   66.97ms   1.18s    95.07%</span><br><span class="line">    Req/Sec     7.73      9.44    40.00     87.74%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%  310.27ms</span><br><span class="line">     75%  340.00ms</span><br><span class="line">     90%  369.37ms</span><br><span class="line">     99%  488.59ms</span><br><span class="line">  912 requests in 30.10s, 166.80KB read</span><br><span class="line">  Socket errors: connect 7967, read 187538, write 0, timeout 0</span><br><span class="line">Requests/sec:     30.30</span><br><span class="line">Transfer/sec:      5.54KB</span><br></pre></td></tr></table></figure>

<p>当BOSS数量为4个的时候，压测结果，能看到性能再次提升了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Running 30s test @ http://localhost:8888</span><br><span class="line">  10 threads and 10000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency   221.00ms   25.30ms 331.05ms   85.11%</span><br><span class="line">    Req/Sec    23.14     14.81    70.00     50.55%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%  211.31ms</span><br><span class="line">     75%  226.24ms</span><br><span class="line">     90%  257.96ms</span><br><span class="line">     99%  297.11ms</span><br><span class="line">  1350 requests in 30.10s, 246.66KB read</span><br><span class="line">  Socket errors: connect 7967, read 242633, write 0, timeout 0</span><br><span class="line">Requests/sec:     44.85</span><br><span class="line">Transfer/sec:      8.19KB</span><br></pre></td></tr></table></figure>


<p><img src="/../images/java/netty20.png" alt="netty"></p>
<p><img src="/../images/java/netty21.png" alt="netty"></p>
<p><img src="/../images/java/netty30.png" alt="netty"></p>
<h3 id="netty-1"><a href="#netty-1" class="headerlink" title="netty"></a>netty</h3><p>Netty是一个NIO客户端服务器框架，可以快速轻松地开发网络应用程序，例如协议服务器和客户端。它极大地简化了网络编程，如TCP和UDP套接字服务器。</p>
<p>netty就是基于上述的网络编程实现的，区别就是netty封装的更好，更完善，做了一些优化，支持了更多的协议。参考netty官网的架构图。</p>
<p>可以看到支持TCP、UDP, 支持大文件传输，支持压缩，支持HTTP、HTTPS、SMTP邮件、Google Protobuf一般用来实现RPC，通过事件模型实现，还实现了零拷贝技术。</p>
<p><img src="/../images/java/netty22.png" alt="netty"></p>
<h4 id="如何使用netty来实现上面的服务器"><a href="#如何使用netty来实现上面的服务器" class="headerlink" title="如何使用netty来实现上面的服务器"></a>如何使用netty来实现上面的服务器</h4><p>通过netty实现的话，代码简单了很多，只需要关注读取文件并返回给客户端这个逻辑就可以了。但是其根本模型没有变化，比如BOSS和Worker，还有零拷贝，线程池，NIO技术，这些是netty的核心，他只是增加了更多的逻辑，支持，优化等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.stream.ChunkedWriteHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8888</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Boss 线程池: 接收客户端连接</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// Worker 线程池: 处理 I/O 操作</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建 ServerBootstrap</span></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(io.netty.channel.socket.nio.NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>()); <span class="comment">// HTTP 编解码</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">65536</span>)); <span class="comment">// 处理 HTTP 请求体</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChunkedWriteHandler</span>()); <span class="comment">// 支持大文件传输</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">HelloWorldServerHandler</span>()); <span class="comment">// 自定义处理逻辑</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 绑定端口并启动</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> b.bind(PORT).sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;Server started on port 8888...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待服务器关闭</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloWorldServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;FullHttpRequest&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, FullHttpRequest msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 读取文件内容</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./HelloWorld.java&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            <span class="type">byte</span>[] fileContent = Files.readAllBytes(file.toPath());</span><br><span class="line">            <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1, HttpResponseStatus.OK,</span><br><span class="line">                    Unpooled.copiedBuffer(fileContent));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置响应头</span></span><br><span class="line">            response.headers().set(HttpHeaders.Names.CONTENT_TYPE, <span class="string">&quot;text/plain; charset=UTF-8&quot;</span>);</span><br><span class="line">            response.headers().set(HttpHeaders.Names.CONTENT_LENGTH, response.content().readableBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送响应</span></span><br><span class="line">            ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 文件不存在时返回 404</span></span><br><span class="line">            <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1, HttpResponseStatus.NOT_FOUND,</span><br><span class="line">                    Unpooled.copiedBuffer(<span class="string">&quot;File Not Found&quot;</span>.getBytes(CharsetUtil.UTF_8)));</span><br><span class="line"></span><br><span class="line">            response.headers().set(HttpHeaders.Names.CONTENT_TYPE, <span class="string">&quot;text/plain; charset=UTF-8&quot;</span>);</span><br><span class="line">            response.headers().set(HttpHeaders.Names.CONTENT_LENGTH, response.content().readableBytes());</span><br><span class="line"></span><br><span class="line">            ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>压测结果，性能很高。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Running 30s test @ http://localhost:8888</span><br><span class="line">  10 threads and 10000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     8.39ms   12.28ms 113.55ms   92.66%</span><br><span class="line">    Req/Sec   192.24    343.10     2.51k    88.08%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    4.41ms</span><br><span class="line">     75%    9.55ms</span><br><span class="line">     90%   17.22ms</span><br><span class="line">     99%   72.18ms</span><br><span class="line">  15693 requests in 30.10s, 3.02MB read</span><br><span class="line">  Socket errors: connect 7967, read 22110, write 1, timeout 0</span><br><span class="line">Requests/sec:    521.32</span><br><span class="line">Transfer/sec:    102.84KB</span><br></pre></td></tr></table></figure>

<h4 id="并发测试对比"><a href="#并发测试对比" class="headerlink" title="并发测试对比"></a>并发测试对比</h4><p>上面都是10个线程并发10000测试的结果。我们现在改成并发1000，再做个对比。</p>
<p>netty实现的压测结果，和10000没什么区别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Running 30s test @ http://localhost:8888</span><br><span class="line">  10 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency    94.20ms  178.90ms 896.17ms   86.02%</span><br><span class="line">    Req/Sec   324.69    443.24     2.20k    85.19%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%   10.05ms</span><br><span class="line">     75%   49.68ms</span><br><span class="line">     90%  365.89ms</span><br><span class="line">     99%  724.64ms</span><br><span class="line">  16390 requests in 30.05s, 3.16MB read</span><br><span class="line">  Socket errors: connect 0, read 36092, write 117, timeout 0</span><br><span class="line">Requests/sec:    545.36</span><br><span class="line">Transfer/sec:    107.58KB</span><br></pre></td></tr></table></figure>

<p>我们自己实现的BOSS-Worker代码，压测结果，1000并发的性能提升很明显。因为我们的实现更加原始，而netty的实现更重。更注重高并发，对于低并发而言我们的实现更好，这也说明我们确实实现了netty的核心功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Running 30s test @ http://localhost:8888</span><br><span class="line">  10 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency   205.91us  529.03us  75.25ms   99.30%</span><br><span class="line">    Req/Sec    15.51k     5.85k   25.50k    62.44%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%  177.00us</span><br><span class="line">     75%  207.00us</span><br><span class="line">     90%  245.00us</span><br><span class="line">     99%  518.00us</span><br><span class="line">  1389306 requests in 30.09s, 247.76MB read</span><br><span class="line">  Socket errors: connect 0, read 10787, write 0, timeout 0</span><br><span class="line">Requests/sec:  46169.43</span><br><span class="line">Transfer/sec:      8.23MB</span><br></pre></td></tr></table></figure>

<p>接下来是线程池+NIO+零拷贝的实现压测结果。对于低并发的性能同样很好，但是比BOSS-Worker实现低了很多很多。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Running 30s test @ http://localhost:8888</span><br><span class="line">  10 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     7.38ms   13.68ms 201.55ms   91.31%</span><br><span class="line">    Req/Sec   102.92    287.63     2.54k    92.41%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    3.65ms</span><br><span class="line">     75%    6.38ms</span><br><span class="line">     90%   18.18ms</span><br><span class="line">     99%   68.71ms</span><br><span class="line">  11677 requests in 30.08s, 2.29MB read</span><br><span class="line">  Socket errors: connect 0, read 454831, write 242, timeout 0</span><br><span class="line">Requests/sec:    388.15</span><br><span class="line">Transfer/sec:     78.09KB</span><br></pre></td></tr></table></figure>

<p>接下来试试NIO+零拷贝的实现压测结果。可以看到结果也很棒</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Running 30s test @ http://localhost:8888</span><br><span class="line">  10 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     4.49ms    9.53ms 178.38ms   93.80%</span><br><span class="line">    Req/Sec   127.52    313.84     2.42k    91.95%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    2.21ms</span><br><span class="line">     75%    4.10ms</span><br><span class="line">     90%    8.91ms</span><br><span class="line">     99%   41.68ms</span><br><span class="line">  13680 requests in 30.06s, 2.69MB read</span><br><span class="line">  Socket errors: connect 0, read 80895, write 7, timeout 0</span><br><span class="line">Requests/sec:    455.12</span><br><span class="line">Transfer/sec:     91.56KB</span><br></pre></td></tr></table></figure>

<p>再看看NIO的实现压测结果，因为没有零拷贝，所以执行时间增加了很多。尤其是最大延迟，吞吐量也有降低。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Running 30s test @ http://localhost:8888</span><br><span class="line">  10 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     8.24ms   27.62ms 675.49ms   96.24%</span><br><span class="line">    Req/Sec   125.39    301.56     3.01k    91.31%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    2.22ms</span><br><span class="line">     75%    9.52ms</span><br><span class="line">     90%   24.23ms</span><br><span class="line">     99%   45.71ms</span><br><span class="line">  11657 requests in 30.10s, 2.08MB read</span><br><span class="line">  Socket errors: connect 0, read 87555, write 1308, timeout 0</span><br><span class="line">Requests/sec:    387.33</span><br><span class="line">Transfer/sec:     70.73KB</span><br></pre></td></tr></table></figure>

<p>最后看看BIO的实现吧。可以看到吞吐量还是低了不少的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Running 30s test @ http://localhost:8888</span><br><span class="line">  10 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency    55.22ms   48.14ms 181.62ms   65.71%</span><br><span class="line">    Req/Sec    83.94    221.86     1.33k    93.39%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%   48.44ms</span><br><span class="line">     75%   68.44ms</span><br><span class="line">     90%  153.94ms</span><br><span class="line">     99%  170.59ms</span><br><span class="line">  5304 requests in 30.09s, 1.08MB read</span><br><span class="line">  Socket errors: connect 0, read 60714, write 723, timeout 0</span><br><span class="line">Requests/sec:    176.29</span><br><span class="line">Transfer/sec:     36.67KB</span><br></pre></td></tr></table></figure>

<p>整体总结而言，主要的提升手段是NIO和BOSS-Worker模型，零拷贝也有一定的性能提升。</p>
<p><img src="/../images/java/netty31.png" alt="netty"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java gc 横向对比</title>
    <url>/gc%E6%AF%94%E8%BE%83.html</url>
    <content><![CDATA[<h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>分代假设：大部分新生对象很快无用，存活较长时间的对象，可能存活更长时间。经历了15次GC还存在的就放在老年代.新生代80%，S0,S1各10%新生代到存活区是复制，到老年代是移动。</p>
<p>-XX: +MaxTenuringThreshold&#x3D;15 表示15次后放到老年代。</p>
<p>可以做为GC ROOT的对象</p>
<ol>
<li>当前正在执行的方法里的局部变量和输入参数</li>
<li>活动线程</li>
<li>所有类的静态字段</li>
<li>JNI引用</li>
</ol>
<h4 id="Serial-GC-x2F-ParNewGC"><a href="#Serial-GC-x2F-ParNewGC" class="headerlink" title="Serial GC&#x2F;ParNewGC"></a>Serial GC&#x2F;ParNewGC</h4><p>-XX: +UseSerialGC开启</p>
<p>对年轻代使用mark-copy算法，对老年代使用mark-sweep-compact算法</p>
<p>串行GC不能并行处理，所以触发全部暂停(STW)</p>
<p>ParNewGC可以配合CMSGC使用</p>
<p>适用场景：</p>
<ul>
<li>单线程应用或资源有限的环境（如嵌入式系统）。</li>
<li>小型应用，不需要频繁的垃圾回收。</li>
</ul>
<p>java版本19，测试GC效率</p>
<p>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+UseSerialGC -Xms128m -Xmx128m -XX:+PrintGCDetails -Xlog:gc\*:file=gc.log:time,uptime,level,tags GCLogAnalysis</span><br></pre></td></tr></table></figure>

<p>效果。可以看到当分配128m内存的时候，频繁触发GC,最终还是OOM，说明堆大小设置的太小了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0.003s][warning][gc] -XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.</span><br><span class="line">[0.009s][info   ][gc,init] CardTable entry size: 512</span><br><span class="line">[0.009s][info   ][gc     ] Using Serial</span><br><span class="line">[0.009s][info   ][gc,init] Version: 19.0.2+7-44 (release)</span><br><span class="line">[0.009s][info   ][gc,init] CPUs: 8 total, 8 available</span><br><span class="line">[0.009s][info   ][gc,init] Memory: 16384M</span><br><span class="line">[0.009s][info   ][gc,init] Large Page Support: Disabled</span><br><span class="line">[0.009s][info   ][gc,init] NUMA Support: Disabled</span><br><span class="line">[0.009s][info   ][gc,init] Compressed Oops: Enabled (Zero based)</span><br><span class="line">[0.009s][info   ][gc,init] Heap Min Capacity: 128M</span><br><span class="line">[0.009s][info   ][gc,init] Heap Initial Capacity: 128M</span><br><span class="line">[0.009s][info   ][gc,init] Heap Max Capacity: 128M</span><br><span class="line">[0.009s][info   ][gc,init] Pre-touch: Disabled</span><br><span class="line">[0.009s][info   ][gc,metaspace] CDS archive(s) mapped at: [0x0000000800000000-0x0000000800c44000-0x0000000800c44000), size 12861440, SharedBaseAddress: 0x0000000800000000, ArchiveRelocationMode: 0.</span><br><span class="line">[0.009s][info   ][gc,metaspace] Compressed class space mapped at: 0x0000000801000000-0x0000000841000000, reserved size: 1073741824</span><br><span class="line">[0.009s][info   ][gc,metaspace] Narrow klass base: 0x0000000800000000, Narrow klass shift: 0, Narrow klass range: 0x100000000</span><br><span class="line">gc...</span><br><span class="line">[0.042s][info   ][gc,start    ] GC(0) Pause Young (Allocation Failure)</span><br><span class="line">[0.044s][info   ][gc,heap     ] GC(0) DefNew: 34915K(39296K)-&gt;4352K(39296K) Eden: 34915K(34944K)-&gt;0K(34944K) From: 0K(4352K)-&gt;4352K(4352K)</span><br><span class="line">[0.045s][info   ][gc,heap     ] GC(0) Tenured: 992K(87424K)-&gt;11701K(87424K)</span><br><span class="line">[0.045s][info   ][gc,metaspace] GC(0) Metaspace: 141K(384K)-&gt;141K(384K) NonClass: 135K(256K)-&gt;135K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.045s][info   ][gc          ] GC(0) Pause Young (Allocation Failure) 35M-&gt;15M(123M) 2.838ms</span><br><span class="line">[0.045s][info   ][gc,cpu      ] GC(0) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.048s][info   ][gc,start    ] GC(1) Pause Young (Allocation Failure)</span><br><span class="line">[0.052s][info   ][gc,heap     ] GC(1) DefNew: 39296K(39296K)-&gt;4347K(39296K) Eden: 34944K(34944K)-&gt;0K(34944K) From: 4352K(4352K)-&gt;4347K(4352K)</span><br><span class="line">[0.052s][info   ][gc,heap     ] GC(1) Tenured: 11701K(87424K)-&gt;25898K(87424K)</span><br><span class="line">[0.052s][info   ][gc,metaspace] GC(1) Metaspace: 145K(384K)-&gt;145K(384K) NonClass: 139K(256K)-&gt;139K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.052s][info   ][gc          ] GC(1) Pause Young (Allocation Failure) 49M-&gt;29M(123M) 3.616ms</span><br><span class="line">[0.052s][info   ][gc,cpu      ] GC(1) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">[0.056s][info   ][gc,start    ] GC(2) Pause Young (Allocation Failure)</span><br><span class="line">[0.060s][info   ][gc,heap     ] GC(2) DefNew: 39098K(39296K)-&gt;4349K(39296K) Eden: 34751K(34944K)-&gt;0K(34944K) From: 4347K(4352K)-&gt;4349K(4352K)</span><br><span class="line">[0.060s][info   ][gc,heap     ] GC(2) Tenured: 25898K(87424K)-&gt;42379K(87424K)</span><br><span class="line">[0.060s][info   ][gc,metaspace] GC(2) Metaspace: 155K(384K)-&gt;155K(384K) NonClass: 149K(256K)-&gt;149K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.061s][info   ][gc          ] GC(2) Pause Young (Allocation Failure) 63M-&gt;45M(123M) 4.161ms</span><br><span class="line">[0.061s][info   ][gc,cpu      ] GC(2) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.067s][info   ][gc,start    ] GC(3) Pause Young (Allocation Failure)</span><br><span class="line">[0.069s][info   ][gc,heap     ] GC(3) DefNew: 39069K(39296K)-&gt;4349K(39296K) Eden: 34720K(34944K)-&gt;0K(34944K) From: 4349K(4352K)-&gt;4349K(4352K)</span><br><span class="line">[0.069s][info   ][gc,heap     ] GC(3) Tenured: 42379K(87424K)-&gt;53353K(87424K)</span><br><span class="line">[0.069s][info   ][gc,metaspace] GC(3) Metaspace: 155K(384K)-&gt;155K(384K) NonClass: 149K(256K)-&gt;149K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.069s][info   ][gc          ] GC(3) Pause Young (Allocation Failure) 79M-&gt;56M(123M) 2.338ms</span><br><span class="line">[0.069s][info   ][gc,cpu      ] GC(3) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.074s][info   ][gc,start    ] GC(4) Pause Young (Allocation Failure)</span><br><span class="line">[0.076s][info   ][gc,heap     ] GC(4) DefNew: 39137K(39296K)-&gt;4349K(39296K) Eden: 34787K(34944K)-&gt;0K(34944K) From: 4349K(4352K)-&gt;4349K(4352K)</span><br><span class="line">[0.076s][info   ][gc,heap     ] GC(4) Tenured: 53353K(87424K)-&gt;65261K(87424K)</span><br><span class="line">[0.076s][info   ][gc,metaspace] GC(4) Metaspace: 155K(384K)-&gt;155K(384K) NonClass: 149K(256K)-&gt;149K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.076s][info   ][gc          ] GC(4) Pause Young (Allocation Failure) 90M-&gt;67M(123M) 2.158ms</span><br><span class="line">[0.076s][info   ][gc,cpu      ] GC(4) User=0.00s Sys=0.01s Real=0.00s</span><br><span class="line">[0.079s][info   ][gc,start    ] GC(5) Pause Young (Allocation Failure)</span><br><span class="line">[0.081s][info   ][gc,heap     ] GC(5) DefNew: 39247K(39296K)-&gt;4349K(39296K) Eden: 34898K(34944K)-&gt;0K(34944K) From: 4349K(4352K)-&gt;4349K(4352K)</span><br><span class="line">[0.081s][info   ][gc,heap     ] GC(5) Tenured: 65261K(87424K)-&gt;81029K(87424K)</span><br><span class="line">[0.081s][info   ][gc,metaspace] GC(5) Metaspace: 155K(384K)-&gt;155K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.081s][info   ][gc          ] GC(5) Pause Young (Allocation Failure) 102M-&gt;83M(123M) 2.255ms</span><br><span class="line">[0.081s][info   ][gc,cpu      ] GC(5) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">[0.085s][info   ][gc,start    ] GC(6) Pause Young (Allocation Failure)</span><br><span class="line">[0.085s][info   ][gc          ] GC(6) Pause Young (Allocation Failure) 117M-&gt;117M(123M) 0.040ms</span><br><span class="line">[0.085s][info   ][gc,cpu      ] GC(6) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.085s][info   ][gc,start    ] GC(7) Pause Full (Allocation Failure)</span><br><span class="line">[0.085s][info   ][gc,phases,start] GC(7) Phase 1: Mark live objects</span><br><span class="line">[0.086s][info   ][gc,phases      ] GC(7) Phase 1: Mark live objects 1.153ms</span><br><span class="line">[0.086s][info   ][gc,phases,start] GC(7) Phase 2: Compute new object addresses</span><br><span class="line">[0.086s][info   ][gc,phases      ] GC(7) Phase 2: Compute new object addresses 0.337ms</span><br><span class="line">[0.086s][info   ][gc,phases,start] GC(7) Phase 3: Adjust pointers</span><br><span class="line">[0.087s][info   ][gc,phases      ] GC(7) Phase 3: Adjust pointers 0.472ms</span><br><span class="line">[0.087s][info   ][gc,phases,start] GC(7) Phase 4: Move objects</span><br><span class="line">[0.091s][info   ][gc,phases      ] GC(7) Phase 4: Move objects 4.672ms</span><br><span class="line">[0.092s][info   ][gc,heap        ] GC(7) DefNew: 39110K(39296K)-&gt;8773K(39296K) Eden: 34760K(34944K)-&gt;8773K(34944K) From: 4349K(4352K)-&gt;0K(4352K)</span><br><span class="line">[0.092s][info   ][gc,heap        ] GC(7) Tenured: 81029K(87424K)-&gt;87392K(87424K)</span><br><span class="line">[0.092s][info   ][gc,metaspace   ] GC(7) Metaspace: 155K(384K)-&gt;155K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.092s][info   ][gc             ] GC(7) Pause Full (Allocation Failure) 117M-&gt;93M(123M) 6.850ms</span><br><span class="line">[0.092s][info   ][gc,cpu         ] GC(7) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.095s][info   ][gc,start       ] GC(8) Pause Full (Allocation Failure)</span><br><span class="line">[0.095s][info   ][gc,phases,start] GC(8) Phase 1: Mark live objects</span><br><span class="line">[0.095s][info   ][gc,phases      ] GC(8) Phase 1: Mark live objects 0.749ms</span><br><span class="line">[0.095s][info   ][gc,phases,start] GC(8) Phase 2: Compute new object addresses</span><br><span class="line">[0.096s][info   ][gc,phases      ] GC(8) Phase 2: Compute new object addresses 0.296ms</span><br><span class="line">[0.096s][info   ][gc,phases,start] GC(8) Phase 3: Adjust pointers</span><br><span class="line">[0.096s][info   ][gc,phases      ] GC(8) Phase 3: Adjust pointers 0.471ms</span><br><span class="line">[0.096s][info   ][gc,phases,start] GC(8) Phase 4: Move objects</span><br><span class="line">[0.099s][info   ][gc,phases      ] GC(8) Phase 4: Move objects 2.909ms</span><br><span class="line">[0.099s][info   ][gc,heap        ] GC(8) DefNew: 39262K(39296K)-&gt;18370K(39296K) Eden: 34944K(34944K)-&gt;18370K(34944K) From: 4318K(4352K)-&gt;0K(4352K)</span><br><span class="line">[0.099s][info   ][gc,heap        ] GC(8) Tenured: 87392K(87424K)-&gt;86941K(87424K)</span><br><span class="line">[0.099s][info   ][gc,metaspace   ] GC(8) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.099s][info   ][gc             ] GC(8) Pause Full (Allocation Failure) 123M-&gt;102M(123M) 4.681ms</span><br><span class="line">[0.099s][info   ][gc,cpu         ] GC(8) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.102s][info   ][gc,start       ] GC(9) Pause Full (Allocation Failure)</span><br><span class="line">[0.102s][info   ][gc,phases,start] GC(9) Phase 1: Mark live objects</span><br><span class="line">[0.103s][info   ][gc,phases      ] GC(9) Phase 1: Mark live objects 0.799ms</span><br><span class="line">[0.103s][info   ][gc,phases,start] GC(9) Phase 2: Compute new object addresses</span><br><span class="line">[0.103s][info   ][gc,phases      ] GC(9) Phase 2: Compute new object addresses 0.277ms</span><br><span class="line">[0.103s][info   ][gc,phases,start] GC(9) Phase 3: Adjust pointers</span><br><span class="line">[0.103s][info   ][gc,phases      ] GC(9) Phase 3: Adjust pointers 0.586ms</span><br><span class="line">[0.103s][info   ][gc,phases,start] GC(9) Phase 4: Move objects</span><br><span class="line">[0.107s][info   ][gc,phases      ] GC(9) Phase 4: Move objects 3.101ms</span><br><span class="line">[0.107s][info   ][gc,heap        ] GC(9) DefNew: 39236K(39296K)-&gt;22308K(39296K) Eden: 34944K(34944K)-&gt;22308K(34944K) From: 4292K(4352K)-&gt;0K(4352K)</span><br><span class="line">[0.107s][info   ][gc,heap        ] GC(9) Tenured: 87271K(87424K)-&gt;87127K(87424K)</span><br><span class="line">[0.107s][info   ][gc,metaspace   ] GC(9) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.107s][info   ][gc             ] GC(9) Pause Full (Allocation Failure) 123M-&gt;106M(123M) 5.070ms</span><br><span class="line">[0.107s][info   ][gc,cpu         ] GC(9) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.108s][info   ][gc,start       ] GC(10) Pause Full (Allocation Failure)</span><br><span class="line">[0.108s][info   ][gc,phases,start] GC(10) Phase 1: Mark live objects</span><br><span class="line">[0.109s][info   ][gc,phases      ] GC(10) Phase 1: Mark live objects 0.717ms</span><br><span class="line">[0.109s][info   ][gc,phases,start] GC(10) Phase 2: Compute new object addresses</span><br><span class="line">[0.109s][info   ][gc,phases      ] GC(10) Phase 2: Compute new object addresses 0.264ms</span><br><span class="line">[0.109s][info   ][gc,phases,start] GC(10) Phase 3: Adjust pointers</span><br><span class="line">[0.109s][info   ][gc,phases      ] GC(10) Phase 3: Adjust pointers 0.514ms</span><br><span class="line">[0.109s][info   ][gc,phases,start] GC(10) Phase 4: Move objects</span><br><span class="line">[0.115s][info   ][gc,phases      ] GC(10) Phase 4: Move objects 5.167ms</span><br><span class="line">[0.115s][info   ][gc,heap        ] GC(10) DefNew: 39000K(39296K)-&gt;20667K(39296K) Eden: 34944K(34944K)-&gt;20667K(34944K) From: 4056K(4352K)-&gt;0K(4352K)</span><br><span class="line">[0.115s][info   ][gc,heap        ] GC(10) Tenured: 87127K(87424K)-&gt;87132K(87424K)</span><br><span class="line">[0.115s][info   ][gc,metaspace   ] GC(10) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.115s][info   ][gc             ] GC(10) Pause Full (Allocation Failure) 123M-&gt;105M(123M) 6.894ms</span><br><span class="line">[0.115s][info   ][gc,cpu         ] GC(10) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">[0.117s][info   ][gc,start       ] GC(11) Pause Full (Allocation Failure)</span><br><span class="line">[0.117s][info   ][gc,phases,start] GC(11) Phase 1: Mark live objects</span><br><span class="line">[0.118s][info   ][gc,phases      ] GC(11) Phase 1: Mark live objects 0.705ms</span><br><span class="line">[0.118s][info   ][gc,phases,start] GC(11) Phase 2: Compute new object addresses</span><br><span class="line">[0.118s][info   ][gc,phases      ] GC(11) Phase 2: Compute new object addresses 0.447ms</span><br><span class="line">[0.118s][info   ][gc,phases,start] GC(11) Phase 3: Adjust pointers</span><br><span class="line">[0.119s][info   ][gc,phases      ] GC(11) Phase 3: Adjust pointers 0.495ms</span><br><span class="line">[0.119s][info   ][gc,phases,start] GC(11) Phase 4: Move objects</span><br><span class="line">[0.119s][info   ][gc,phases      ] GC(11) Phase 4: Move objects 0.717ms</span><br><span class="line">[0.119s][info   ][gc,heap        ] GC(11) DefNew: 39253K(39296K)-&gt;26315K(39296K) Eden: 34944K(34944K)-&gt;26315K(34944K) From: 4309K(4352K)-&gt;0K(4352K)</span><br><span class="line">[0.119s][info   ][gc,heap        ] GC(11) Tenured: 87132K(87424K)-&gt;87132K(87424K)</span><br><span class="line">[0.119s][info   ][gc,metaspace   ] GC(11) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.119s][info   ][gc             ] GC(11) Pause Full (Allocation Failure) 123M-&gt;110M(123M) 2.592ms</span><br><span class="line">[0.119s][info   ][gc,cpu         ] GC(11) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">[0.120s][info   ][gc,start       ] GC(12) Pause Full (Allocation Failure)</span><br><span class="line">[0.120s][info   ][gc,phases,start] GC(12) Phase 1: Mark live objects</span><br><span class="line">[0.121s][info   ][gc,phases      ] GC(12) Phase 1: Mark live objects 0.716ms</span><br><span class="line">[0.121s][info   ][gc,phases,start] GC(12) Phase 2: Compute new object addresses</span><br><span class="line">[0.121s][info   ][gc,phases      ] GC(12) Phase 2: Compute new object addresses 0.262ms</span><br><span class="line">[0.121s][info   ][gc,phases,start] GC(12) Phase 3: Adjust pointers</span><br><span class="line">[0.121s][info   ][gc,phases      ] GC(12) Phase 3: Adjust pointers 0.468ms</span><br><span class="line">[0.121s][info   ][gc,phases,start] GC(12) Phase 4: Move objects</span><br><span class="line">[0.122s][info   ][gc,phases      ] GC(12) Phase 4: Move objects 0.754ms</span><br><span class="line">[0.122s][info   ][gc,heap        ] GC(12) DefNew: 39165K(39296K)-&gt;31275K(39296K) Eden: 34944K(34944K)-&gt;31275K(34944K) From: 4221K(4352K)-&gt;0K(4352K)</span><br><span class="line">[0.122s][info   ][gc,heap        ] GC(12) Tenured: 87132K(87424K)-&gt;87132K(87424K)</span><br><span class="line">[0.122s][info   ][gc,metaspace   ] GC(12) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.122s][info   ][gc             ] GC(12) Pause Full (Allocation Failure) 123M-&gt;115M(123M) 2.393ms</span><br><span class="line">[0.122s][info   ][gc,cpu         ] GC(12) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.123s][info   ][gc,start       ] GC(13) Pause Full (Allocation Failure)</span><br><span class="line">[0.123s][info   ][gc,phases,start] GC(13) Phase 1: Mark live objects</span><br><span class="line">[0.123s][info   ][gc,phases      ] GC(13) Phase 1: Mark live objects 0.703ms</span><br><span class="line">[0.123s][info   ][gc,phases,start] GC(13) Phase 2: Compute new object addresses</span><br><span class="line">[0.124s][info   ][gc,phases      ] GC(13) Phase 2: Compute new object addresses 0.257ms</span><br><span class="line">[0.124s][info   ][gc,phases,start] GC(13) Phase 3: Adjust pointers</span><br><span class="line">[0.124s][info   ][gc,phases      ] GC(13) Phase 3: Adjust pointers 0.455ms</span><br><span class="line">[0.124s][info   ][gc,phases,start] GC(13) Phase 4: Move objects</span><br><span class="line">[0.124s][info   ][gc,phases      ] GC(13) Phase 4: Move objects 0.272ms</span><br><span class="line">[0.124s][info   ][gc,heap        ] GC(13) DefNew: 38965K(39296K)-&gt;34581K(39296K) Eden: 34944K(34944K)-&gt;34581K(34944K) From: 4021K(4352K)-&gt;0K(4352K)</span><br><span class="line">[0.124s][info   ][gc,heap        ] GC(13) Tenured: 87132K(87424K)-&gt;87090K(87424K)</span><br><span class="line">[0.124s][info   ][gc,metaspace   ] GC(13) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.125s][info   ][gc             ] GC(13) Pause Full (Allocation Failure) 123M-&gt;118M(123M) 1.844ms</span><br><span class="line">[0.125s][info   ][gc,cpu         ] GC(13) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.125s][info   ][gc,start       ] GC(14) Pause Full (Allocation Failure)</span><br><span class="line">[0.125s][info   ][gc,phases,start] GC(14) Phase 1: Mark live objects</span><br><span class="line">[0.126s][info   ][gc,phases      ] GC(14) Phase 1: Mark live objects 0.624ms</span><br><span class="line">[0.126s][info   ][gc,phases,start] GC(14) Phase 2: Compute new object addresses</span><br><span class="line">[0.126s][info   ][gc,phases      ] GC(14) Phase 2: Compute new object addresses 0.256ms</span><br><span class="line">[0.126s][info   ][gc,phases,start] GC(14) Phase 3: Adjust pointers</span><br><span class="line">[0.126s][info   ][gc,phases      ] GC(14) Phase 3: Adjust pointers 0.467ms</span><br><span class="line">[0.126s][info   ][gc,phases,start] GC(14) Phase 4: Move objects</span><br><span class="line">[0.130s][info   ][gc,phases      ] GC(14) Phase 4: Move objects 3.626ms</span><br><span class="line">[0.130s][info   ][gc,heap        ] GC(14) DefNew: 39291K(39296K)-&gt;31220K(39296K) Eden: 34944K(34944K)-&gt;31220K(34944K) From: 4347K(4352K)-&gt;0K(4352K)</span><br><span class="line">[0.130s][info   ][gc,heap        ] GC(14) Tenured: 87386K(87424K)-&gt;87412K(87424K)</span><br><span class="line">[0.130s][info   ][gc,metaspace   ] GC(14) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.130s][info   ][gc             ] GC(14) Pause Full (Allocation Failure) 123M-&gt;115M(123M) 5.206ms</span><br><span class="line">[0.130s][info   ][gc,cpu         ] GC(14) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.130s][info   ][gc,start       ] GC(15) Pause Full (Allocation Failure)</span><br><span class="line">[0.130s][info   ][gc,phases,start] GC(15) Phase 1: Mark live objects</span><br><span class="line">[0.131s][info   ][gc,phases      ] GC(15) Phase 1: Mark live objects 0.681ms</span><br><span class="line">[0.131s][info   ][gc,phases,start] GC(15) Phase 2: Compute new object addresses</span><br><span class="line">[0.131s][info   ][gc,phases      ] GC(15) Phase 2: Compute new object addresses 0.254ms</span><br><span class="line">[0.131s][info   ][gc,phases,start] GC(15) Phase 3: Adjust pointers</span><br><span class="line">[0.132s][info   ][gc,phases      ] GC(15) Phase 3: Adjust pointers 0.470ms</span><br><span class="line">[0.132s][info   ][gc,phases,start] GC(15) Phase 4: Move objects</span><br><span class="line">[0.133s][info   ][gc,phases      ] GC(15) Phase 4: Move objects 0.595ms</span><br><span class="line">[0.133s][info   ][gc,heap        ] GC(15) DefNew: 38637K(39296K)-&gt;34717K(39296K) Eden: 34944K(34944K)-&gt;34717K(34944K) From: 3693K(4352K)-&gt;0K(4352K)</span><br><span class="line">[0.133s][info   ][gc,heap        ] GC(15) Tenured: 87412K(87424K)-&gt;87412K(87424K)</span><br><span class="line">[0.133s][info   ][gc,metaspace   ] GC(15) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.133s][info   ][gc             ] GC(15) Pause Full (Allocation Failure) 123M-&gt;119M(123M) 2.189ms</span><br><span class="line">[0.133s][info   ][gc,cpu         ] GC(15) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.133s][info   ][gc,start       ] GC(16) Pause Full (Allocation Failure)</span><br><span class="line">[0.133s][info   ][gc,phases,start] GC(16) Phase 1: Mark live objects</span><br><span class="line">[0.134s][info   ][gc,phases      ] GC(16) Phase 1: Mark live objects 0.642ms</span><br><span class="line">[0.134s][info   ][gc,phases,start] GC(16) Phase 2: Compute new object addresses</span><br><span class="line">[0.134s][info   ][gc,phases      ] GC(16) Phase 2: Compute new object addresses 0.259ms</span><br><span class="line">[0.134s][info   ][gc,phases,start] GC(16) Phase 3: Adjust pointers</span><br><span class="line">[0.135s][info   ][gc,phases      ] GC(16) Phase 3: Adjust pointers 0.468ms</span><br><span class="line">[0.135s][info   ][gc,phases,start] GC(16) Phase 4: Move objects</span><br><span class="line">[0.135s][info   ][gc,phases      ] GC(16) Phase 4: Move objects 0.522ms</span><br><span class="line">[0.135s][info   ][gc,heap        ] GC(16) DefNew: 39167K(39296K)-&gt;35607K(39296K) Eden: 34944K(34944K)-&gt;34667K(34944K) From: 4223K(4352K)-&gt;939K(4352K)</span><br><span class="line">[0.135s][info   ][gc,heap        ] GC(16) Tenured: 87412K(87424K)-&gt;87412K(87424K)</span><br><span class="line">[0.135s][info   ][gc,metaspace   ] GC(16) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.135s][info   ][gc             ] GC(16) Pause Full (Allocation Failure) 123M-&gt;120M(123M) 2.098ms</span><br><span class="line">[0.135s][info   ][gc,cpu         ] GC(16) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.136s][info   ][gc,start       ] GC(17) Pause Full (Allocation Failure)</span><br><span class="line">[0.136s][info   ][gc,phases,start] GC(17) Phase 1: Mark live objects</span><br><span class="line">[0.136s][info   ][gc,phases      ] GC(17) Phase 1: Mark live objects 0.638ms</span><br><span class="line">[0.136s][info   ][gc,phases,start] GC(17) Phase 2: Compute new object addresses</span><br><span class="line">[0.137s][info   ][gc,phases      ] GC(17) Phase 2: Compute new object addresses 0.257ms</span><br><span class="line">[0.137s][info   ][gc,phases,start] GC(17) Phase 3: Adjust pointers</span><br><span class="line">[0.137s][info   ][gc,phases      ] GC(17) Phase 3: Adjust pointers 0.453ms</span><br><span class="line">[0.137s][info   ][gc,phases,start] GC(17) Phase 4: Move objects</span><br><span class="line">[0.138s][info   ][gc,phases      ] GC(17) Phase 4: Move objects 0.920ms</span><br><span class="line">[0.138s][info   ][gc,heap        ] GC(17) DefNew: 38716K(39296K)-&gt;36469K(39296K) Eden: 34944K(34944K)-&gt;34616K(34944K) From: 3772K(4352K)-&gt;1853K(4352K)</span><br><span class="line">[0.138s][info   ][gc,heap        ] GC(17) Tenured: 87412K(87424K)-&gt;87412K(87424K)</span><br><span class="line">[0.138s][info   ][gc,metaspace   ] GC(17) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.138s][info   ][gc             ] GC(17) Pause Full (Allocation Failure) 123M-&gt;120M(123M) 2.471ms</span><br><span class="line">[0.138s][info   ][gc,cpu         ] GC(17) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.138s][info   ][gc,start       ] GC(18) Pause Full (Allocation Failure)</span><br><span class="line">[0.138s][info   ][gc,phases,start] GC(18) Phase 1: Mark live objects</span><br><span class="line">[0.139s][info   ][gc,phases      ] GC(18) Phase 1: Mark live objects 0.701ms</span><br><span class="line">[0.139s][info   ][gc,phases,start] GC(18) Phase 2: Compute new object addresses</span><br><span class="line">[0.139s][info   ][gc,phases      ] GC(18) Phase 2: Compute new object addresses 0.264ms</span><br><span class="line">[0.139s][info   ][gc,phases,start] GC(18) Phase 3: Adjust pointers</span><br><span class="line">[0.140s][info   ][gc,phases      ] GC(18) Phase 3: Adjust pointers 0.461ms</span><br><span class="line">[0.140s][info   ][gc,phases,start] GC(18) Phase 4: Move objects</span><br><span class="line">[0.143s][info   ][gc,phases      ] GC(18) Phase 4: Move objects 3.442ms</span><br><span class="line">[0.143s][info   ][gc,heap        ] GC(18) DefNew: 39244K(39296K)-&gt;36771K(39296K) Eden: 34943K(34944K)-&gt;34930K(34944K) From: 4300K(4352K)-&gt;1840K(4352K)</span><br><span class="line">[0.144s][info   ][gc,heap        ] GC(18) Tenured: 87412K(87424K)-&gt;87365K(87424K)</span><br><span class="line">[0.144s][info   ][gc,metaspace   ] GC(18) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.144s][info   ][gc             ] GC(18) Pause Full (Allocation Failure) 123M-&gt;121M(123M) 5.098ms</span><br><span class="line">[0.144s][info   ][gc,cpu         ] GC(18) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">[0.144s][info   ][gc,start       ] GC(19) Pause Full (Allocation Failure)</span><br><span class="line">[0.144s][info   ][gc,phases,start] GC(19) Phase 1: Mark live objects</span><br><span class="line">[0.145s][info   ][gc,phases      ] GC(19) Phase 1: Mark live objects 0.789ms</span><br><span class="line">[0.145s][info   ][gc,phases,start] GC(19) Phase 2: Compute new object addresses</span><br><span class="line">[0.145s][info   ][gc,phases      ] GC(19) Phase 2: Compute new object addresses 0.258ms</span><br><span class="line">[0.145s][info   ][gc,phases,start] GC(19) Phase 3: Adjust pointers</span><br><span class="line">[0.145s][info   ][gc,phases      ] GC(19) Phase 3: Adjust pointers 0.477ms</span><br><span class="line">[0.145s][info   ][gc,phases,start] GC(19) Phase 4: Move objects</span><br><span class="line">[0.146s][info   ][gc,phases      ] GC(19) Phase 4: Move objects 0.258ms</span><br><span class="line">[0.146s][info   ][gc,heap        ] GC(19) DefNew: 39219K(39296K)-&gt;38523K(39296K) Eden: 34944K(34944K)-&gt;34930K(34944K) From: 4275K(4352K)-&gt;3592K(4352K)</span><br><span class="line">[0.146s][info   ][gc,heap        ] GC(19) Tenured: 87365K(87424K)-&gt;87365K(87424K)</span><br><span class="line">[0.146s][info   ][gc,metaspace   ] GC(19) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.146s][info   ][gc             ] GC(19) Pause Full (Allocation Failure) 123M-&gt;122M(123M) 1.957ms</span><br><span class="line">[0.146s][info   ][gc,cpu         ] GC(19) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.146s][info   ][gc,start       ] GC(20) Pause Full (Allocation Failure)</span><br><span class="line">[0.146s][info   ][gc,phases,start] GC(20) Phase 1: Mark live objects</span><br><span class="line">[0.147s][info   ][gc,phases      ] GC(20) Phase 1: Mark live objects 0.717ms</span><br><span class="line">[0.147s][info   ][gc,phases,start] GC(20) Phase 2: Compute new object addresses</span><br><span class="line">[0.147s][info   ][gc,phases      ] GC(20) Phase 2: Compute new object addresses 0.253ms</span><br><span class="line">[0.147s][info   ][gc,phases,start] GC(20) Phase 3: Adjust pointers</span><br><span class="line">[0.147s][info   ][gc,phases      ] GC(20) Phase 3: Adjust pointers 0.448ms</span><br><span class="line">[0.147s][info   ][gc,phases,start] GC(20) Phase 4: Move objects</span><br><span class="line">[0.147s][info   ][gc,phases      ] GC(20) Phase 4: Move objects 0.008ms</span><br><span class="line">[0.147s][info   ][gc,heap        ] GC(20) DefNew: 39281K(39296K)-&gt;38838K(39296K) Eden: 34944K(34944K)-&gt;34931K(34944K) From: 4337K(4352K)-&gt;3907K(4352K)</span><br><span class="line">[0.147s][info   ][gc,heap        ] GC(20) Tenured: 87365K(87424K)-&gt;87365K(87424K)</span><br><span class="line">[0.147s][info   ][gc,metaspace   ] GC(20) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.147s][info   ][gc             ] GC(20) Pause Full (Allocation Failure) 123M-&gt;123M(123M) 1.594ms</span><br><span class="line">[0.147s][info   ][gc,cpu         ] GC(20) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.148s][info   ][gc,start       ] GC(21) Pause Full (Allocation Failure)</span><br><span class="line">[0.148s][info   ][gc,phases,start] GC(21) Phase 1: Mark live objects</span><br><span class="line">[0.148s][info   ][gc,phases      ] GC(21) Phase 1: Mark live objects 0.551ms</span><br><span class="line">[0.148s][info   ][gc,phases,start] GC(21) Phase 2: Compute new object addresses</span><br><span class="line">[0.148s][info   ][gc,phases      ] GC(21) Phase 2: Compute new object addresses 0.248ms</span><br><span class="line">[0.148s][info   ][gc,phases,start] GC(21) Phase 3: Adjust pointers</span><br><span class="line">[0.149s][info   ][gc,phases      ] GC(21) Phase 3: Adjust pointers 0.418ms</span><br><span class="line">[0.149s][info   ][gc,phases,start] GC(21) Phase 4: Move objects</span><br><span class="line">[0.149s][info   ][gc,phases      ] GC(21) Phase 4: Move objects 0.012ms</span><br><span class="line">[0.149s][info   ][gc,heap        ] GC(21) DefNew: 39249K(39296K)-&gt;39101K(39296K) Eden: 34944K(34944K)-&gt;34931K(34944K) From: 4305K(4352K)-&gt;4170K(4352K)</span><br><span class="line">[0.149s][info   ][gc,heap        ] GC(21) Tenured: 87365K(87424K)-&gt;87365K(87424K)</span><br><span class="line">[0.149s][info   ][gc,metaspace   ] GC(21) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.149s][info   ][gc             ] GC(21) Pause Full (Allocation Failure) 123M-&gt;123M(123M) 1.355ms</span><br><span class="line">[0.149s][info   ][gc,cpu         ] GC(21) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.149s][info   ][gc,start       ] GC(22) Pause Full (Allocation Failure)</span><br><span class="line">[0.149s][info   ][gc,phases,start] GC(22) Phase 1: Mark live objects</span><br><span class="line">[0.150s][info   ][gc,phases      ] GC(22) Phase 1: Mark live objects 0.558ms</span><br><span class="line">[0.150s][info   ][gc,phases,start] GC(22) Phase 2: Compute new object addresses</span><br><span class="line">[0.150s][info   ][gc,phases      ] GC(22) Phase 2: Compute new object addresses 0.253ms</span><br><span class="line">[0.150s][info   ][gc,phases,start] GC(22) Phase 3: Adjust pointers</span><br><span class="line">[0.150s][info   ][gc,phases      ] GC(22) Phase 3: Adjust pointers 0.426ms</span><br><span class="line">[0.150s][info   ][gc,phases,start] GC(22) Phase 4: Move objects</span><br><span class="line">[0.154s][info   ][gc,phases      ] GC(22) Phase 4: Move objects 3.805ms</span><br><span class="line">[0.154s][info   ][gc,heap        ] GC(22) DefNew: 39280K(39296K)-&gt;39047K(39296K) Eden: 34931K(34944K)-&gt;34871K(34944K) From: 4348K(4352K)-&gt;4175K(4352K)</span><br><span class="line">[0.154s][info   ][gc,heap        ] GC(22) Tenured: 87387K(87424K)-&gt;87368K(87424K)</span><br><span class="line">[0.154s][info   ][gc,metaspace   ] GC(22) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.154s][info   ][gc             ] GC(22) Pause Full (Allocation Failure) 123M-&gt;123M(123M) 5.380ms</span><br><span class="line">[0.154s][info   ][gc,cpu         ] GC(22) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">[0.154s][info   ][gc,start       ] GC(23) Pause Full (Allocation Failure)</span><br><span class="line">[0.154s][info   ][gc,phases,start] GC(23) Phase 1: Mark live objects</span><br><span class="line">[0.155s][info   ][gc,phases      ] GC(23) Phase 1: Mark live objects 0.698ms</span><br><span class="line">[0.155s][info   ][gc,phases,start] GC(23) Phase 2: Compute new object addresses</span><br><span class="line">[0.155s][info   ][gc,phases      ] GC(23) Phase 2: Compute new object addresses 0.277ms</span><br><span class="line">[0.155s][info   ][gc,phases,start] GC(23) Phase 3: Adjust pointers</span><br><span class="line">[0.156s][info   ][gc,phases      ] GC(23) Phase 3: Adjust pointers 0.468ms</span><br><span class="line">[0.156s][info   ][gc,phases,start] GC(23) Phase 4: Move objects</span><br><span class="line">[0.156s][info   ][gc,phases      ] GC(23) Phase 4: Move objects 0.008ms</span><br><span class="line">[0.156s][info   ][gc,heap        ] GC(23) DefNew: 39131K(39296K)-&gt;39047K(39296K) Eden: 34871K(34944K)-&gt;34871K(34944K) From: 4259K(4352K)-&gt;4175K(4352K)</span><br><span class="line">[0.156s][info   ][gc,heap        ] GC(23) Tenured: 87368K(87424K)-&gt;87368K(87424K)</span><br><span class="line">[0.156s][info   ][gc,metaspace   ] GC(23) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.156s][info   ][gc             ] GC(23) Pause Full (Allocation Failure) 123M-&gt;123M(123M) 1.622ms</span><br><span class="line">[0.156s][info   ][gc,cpu         ] GC(23) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.156s][info   ][gc,start       ] GC(24) Pause Full (Allocation Failure)</span><br><span class="line">[0.156s][info   ][gc,phases,start] GC(24) Phase 1: Mark live objects</span><br><span class="line">[0.157s][info   ][gc,phases      ] GC(24) Phase 1: Mark live objects 0.616ms</span><br><span class="line">[0.157s][info   ][gc,phases,start] GC(24) Phase 2: Compute new object addresses</span><br><span class="line">[0.157s][info   ][gc,phases      ] GC(24) Phase 2: Compute new object addresses 0.254ms</span><br><span class="line">[0.157s][info   ][gc,phases,start] GC(24) Phase 3: Adjust pointers</span><br><span class="line">[0.157s][info   ][gc,phases      ] GC(24) Phase 3: Adjust pointers 0.450ms</span><br><span class="line">[0.157s][info   ][gc,phases,start] GC(24) Phase 4: Move objects</span><br><span class="line">[0.157s][info   ][gc,phases      ] GC(24) Phase 4: Move objects 0.011ms</span><br><span class="line">[0.158s][info   ][gc,heap        ] GC(24) DefNew: 39219K(39296K)-&gt;39152K(39296K) Eden: 34938K(34944K)-&gt;34871K(34944K) From: 4281K(4352K)-&gt;4281K(4352K)</span><br><span class="line">[0.158s][info   ][gc,heap        ] GC(24) Tenured: 87368K(87424K)-&gt;87368K(87424K)</span><br><span class="line">[0.158s][info   ][gc,metaspace   ] GC(24) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.158s][info   ][gc             ] GC(24) Pause Full (Allocation Failure) 123M-&gt;123M(123M) 1.490ms</span><br><span class="line">[0.158s][info   ][gc,cpu         ] GC(24) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.158s][info   ][gc,start       ] GC(25) Pause Full (Allocation Failure)</span><br><span class="line">[0.158s][info   ][gc,phases,start] GC(25) Phase 1: Mark live objects</span><br><span class="line">[0.158s][info   ][gc,phases      ] GC(25) Phase 1: Mark live objects 0.751ms</span><br><span class="line">[0.158s][info   ][gc,phases,start] GC(25) Phase 2: Compute new object addresses</span><br><span class="line">[0.159s][info   ][gc,phases      ] GC(25) Phase 2: Compute new object addresses 0.253ms</span><br><span class="line">[0.159s][info   ][gc,phases,start] GC(25) Phase 3: Adjust pointers</span><br><span class="line">[0.159s][info   ][gc,phases      ] GC(25) Phase 3: Adjust pointers 0.463ms</span><br><span class="line">[0.159s][info   ][gc,phases,start] GC(25) Phase 4: Move objects</span><br><span class="line">[0.162s][info   ][gc,phases      ] GC(25) Phase 4: Move objects 2.588ms</span><br><span class="line">[0.162s][info   ][gc,heap        ] GC(25) DefNew: 39152K(39296K)-&gt;39152K(39296K) Eden: 34871K(34944K)-&gt;34871K(34944K) From: 4281K(4352K)-&gt;4281K(4352K)</span><br><span class="line">[0.162s][info   ][gc,heap        ] GC(25) Tenured: 87368K(87424K)-&gt;87366K(87424K)</span><br><span class="line">[0.162s][info   ][gc,metaspace   ] GC(25) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.162s][info   ][gc             ] GC(25) Pause Full (Allocation Failure) 123M-&gt;123M(123M) 4.292ms</span><br><span class="line">[0.162s][info   ][gc,cpu         ] GC(25) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at GCLogAnalysis.generateGarbage(GCLogAnalysis.java:42)</span><br><span class="line">	at GCLogAnalysis.main(GCLogAnalysis.java:20)</span><br><span class="line">[0.163s][info   ][gc,heap,exit   ] Heap</span><br><span class="line">[0.163s][info   ][gc,heap,exit   ]  def new generation   total 39296K, used 39225K [0x00000007f8000000, 0x00000007faaa0000, 0x00000007faaa0000)</span><br><span class="line">[0.163s][info   ][gc,heap,exit   ]   eden space 34944K, 100% used [0x00000007f8000000, 0x00000007fa220000, 0x00000007fa220000)</span><br><span class="line">[0.163s][info   ][gc,heap,exit   ]   from space 4352K,  98% used [0x00000007fa220000, 0x00000007fa64e5c0, 0x00000007fa660000)</span><br><span class="line">[0.163s][info   ][gc,heap,exit   ]   to   space 4352K,   0% used [0x00000007fa660000, 0x00000007fa660000, 0x00000007faaa0000)</span><br><span class="line">[0.163s][info   ][gc,heap,exit   ]  tenured generation   total 87424K, used 87366K [0x00000007faaa0000, 0x0000000800000000, 0x0000000800000000)</span><br><span class="line">[0.163s][info   ][gc,heap,exit   ]    the space 87424K,  99% used [0x00000007faaa0000, 0x00000007ffff1a90, 0x00000007ffff1c00, 0x0000000800000000)</span><br><span class="line">[0.163s][info   ][gc,heap,exit   ]  Metaspace       used 163K, committed 384K, reserved 1114112K</span><br><span class="line">[0.163s][info   ][gc,heap,exit   ]   class space    used 7K, committed 128K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>接下来试试512m堆大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+UseSerialGC -Xms512m -Xmx512m -XX:+PrintGCDetails -Xlog:gc\*:file=gc.log:time,uptime,level,tags GCLogAnalysis</span><br></pre></td></tr></table></figure>

<p>可以看到效果，前面几次yong GC后，触发了很多次full GC，最终成功运行，但是时间很长</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0.002s][warning][gc] -XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.</span><br><span class="line">[0.006s][info   ][gc,init] CardTable entry size: 512</span><br><span class="line">[0.006s][info   ][gc     ] Using Serial</span><br><span class="line">[0.006s][info   ][gc,init] Version: 19.0.2+7-44 (release)</span><br><span class="line">[0.006s][info   ][gc,init] CPUs: 8 total, 8 available</span><br><span class="line">[0.006s][info   ][gc,init] Memory: 16384M</span><br><span class="line">[0.006s][info   ][gc,init] Large Page Support: Disabled</span><br><span class="line">[0.006s][info   ][gc,init] NUMA Support: Disabled</span><br><span class="line">[0.006s][info   ][gc,init] Compressed Oops: Enabled (Zero based)</span><br><span class="line">[0.006s][info   ][gc,init] Heap Min Capacity: 512M</span><br><span class="line">[0.006s][info   ][gc,init] Heap Initial Capacity: 512M</span><br><span class="line">[0.006s][info   ][gc,init] Heap Max Capacity: 512M</span><br><span class="line">[0.006s][info   ][gc,init] Pre-touch: Disabled</span><br><span class="line">[0.006s][info   ][gc,metaspace] CDS archive(s) mapped at: [0x0000000800000000-0x0000000800c44000-0x0000000800c44000), size 12861440, SharedBaseAddress: 0x0000000800000000, ArchiveRelocationMode: 0.</span><br><span class="line">[0.006s][info   ][gc,metaspace] Compressed class space mapped at: 0x0000000801000000-0x0000000841000000, reserved size: 1073741824</span><br><span class="line">[0.006s][info   ][gc,metaspace] Narrow klass base: 0x0000000800000000, Narrow klass shift: 0, Narrow klass range: 0x100000000</span><br><span class="line">gc...</span><br><span class="line">[0.061s][info   ][gc,start    ] GC(0) Pause Young (Allocation Failure)</span><br><span class="line">[0.079s][info   ][gc,heap     ] GC(0) DefNew: 139776K(157248K)-&gt;17472K(157248K) Eden: 139776K(139776K)-&gt;0K(139776K) From: 0K(17472K)-&gt;17472K(17472K)</span><br><span class="line">[0.079s][info   ][gc,heap     ] GC(0) Tenured: 992K(349568K)-&gt;36431K(349568K)</span><br><span class="line">[0.079s][info   ][gc,metaspace] GC(0) Metaspace: 155K(384K)-&gt;155K(384K) NonClass: 149K(256K)-&gt;149K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.079s][info   ][gc          ] GC(0) Pause Young (Allocation Failure) 137M-&gt;52M(494M) 18.248ms</span><br><span class="line">[0.079s][info   ][gc,cpu      ] GC(0) User=0.01s Sys=0.01s Real=0.02s</span><br><span class="line">[0.098s][info   ][gc,start    ] GC(1) Pause Young (Allocation Failure)</span><br><span class="line">[0.112s][info   ][gc,heap     ] GC(1) DefNew: 157248K(157248K)-&gt;17471K(157248K) Eden: 139776K(139776K)-&gt;0K(139776K) From: 17472K(17472K)-&gt;17471K(17472K)</span><br><span class="line">[0.112s][info   ][gc,heap     ] GC(1) Tenured: 36431K(349568K)-&gt;90386K(349568K)</span><br><span class="line">[0.112s][info   ][gc,metaspace] GC(1) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.112s][info   ][gc          ] GC(1) Pause Young (Allocation Failure) 189M-&gt;105M(494M) 14.222ms</span><br><span class="line">[0.112s][info   ][gc,cpu      ] GC(1) User=0.00s Sys=0.01s Real=0.01s</span><br><span class="line">[0.125s][info   ][gc,start    ] GC(2) Pause Young (Allocation Failure)</span><br><span class="line">[0.133s][info   ][gc,heap     ] GC(2) DefNew: 156732K(157248K)-&gt;17471K(157248K) Eden: 139260K(139776K)-&gt;0K(139776K) From: 17471K(17472K)-&gt;17471K(17472K)</span><br><span class="line">[0.133s][info   ][gc,heap     ] GC(2) Tenured: 90386K(349568K)-&gt;136437K(349568K)</span><br><span class="line">[0.133s][info   ][gc,metaspace] GC(2) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.133s][info   ][gc          ] GC(2) Pause Young (Allocation Failure) 241M-&gt;150M(494M) 7.935ms</span><br><span class="line">[0.133s][info   ][gc,cpu      ] GC(2) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.142s][info   ][gc,start    ] GC(3) Pause Young (Allocation Failure)</span><br><span class="line">[0.151s][info   ][gc,heap     ] GC(3) DefNew: 157247K(157248K)-&gt;17471K(157248K) Eden: 139776K(139776K)-&gt;0K(139776K) From: 17471K(17472K)-&gt;17471K(17472K)</span><br><span class="line">[0.152s][info   ][gc,heap     ] GC(3) Tenured: 136437K(349568K)-&gt;192764K(349568K)</span><br><span class="line">[0.152s][info   ][gc,metaspace] GC(3) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.152s][info   ][gc          ] GC(3) Pause Young (Allocation Failure) 286M-&gt;205M(494M) 9.671ms</span><br><span class="line">[0.152s][info   ][gc,cpu      ] GC(3) User=0.00s Sys=0.01s Real=0.01s</span><br><span class="line">[0.161s][info   ][gc,start    ] GC(4) Pause Young (Allocation Failure)</span><br><span class="line">[0.168s][info   ][gc,heap     ] GC(4) DefNew: 157247K(157248K)-&gt;17471K(157248K) Eden: 139776K(139776K)-&gt;0K(139776K) From: 17471K(17472K)-&gt;17471K(17472K)</span><br><span class="line">[0.168s][info   ][gc,heap     ] GC(4) Tenured: 192764K(349568K)-&gt;239146K(349568K)</span><br><span class="line">[0.168s][info   ][gc,metaspace] GC(4) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.168s][info   ][gc          ] GC(4) Pause Young (Allocation Failure) 341M-&gt;250M(494M) 6.916ms</span><br><span class="line">[0.168s][info   ][gc,cpu      ] GC(4) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">[0.176s][info   ][gc,start    ] GC(5) Pause Young (Allocation Failure)</span><br><span class="line">[0.183s][info   ][gc,heap     ] GC(5) DefNew: 157247K(157248K)-&gt;17471K(157248K) Eden: 139776K(139776K)-&gt;0K(139776K) From: 17471K(17472K)-&gt;17471K(17472K)</span><br><span class="line">[0.183s][info   ][gc,heap     ] GC(5) Tenured: 239146K(349568K)-&gt;289739K(349568K)</span><br><span class="line">[0.183s][info   ][gc,metaspace] GC(5) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.183s][info   ][gc          ] GC(5) Pause Young (Allocation Failure) 387M-&gt;300M(494M) 7.126ms</span><br><span class="line">[0.183s][info   ][gc,cpu      ] GC(5) User=0.01s Sys=0.01s Real=0.00s</span><br><span class="line">[0.193s][info   ][gc,start    ] GC(6) Pause Young (Allocation Failure)</span><br><span class="line">[0.200s][info   ][gc,heap     ] GC(6) DefNew: 157247K(157248K)-&gt;17471K(157248K) Eden: 139776K(139776K)-&gt;0K(139776K) From: 17471K(17472K)-&gt;17471K(17472K)</span><br><span class="line">[0.200s][info   ][gc,heap     ] GC(6) Tenured: 289739K(349568K)-&gt;340047K(349568K)</span><br><span class="line">[0.200s][info   ][gc,metaspace] GC(6) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.200s][info   ][gc          ] GC(6) Pause Young (Allocation Failure) 436M-&gt;349M(494M) 7.159ms</span><br><span class="line">[0.200s][info   ][gc,cpu      ] GC(6) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">[0.213s][info   ][gc,start    ] GC(7) Pause Young (Allocation Failure)</span><br><span class="line">[0.213s][info   ][gc          ] GC(7) Pause Young (Allocation Failure) 485M-&gt;485M(494M) 0.085ms</span><br><span class="line">[0.213s][info   ][gc,cpu      ] GC(7) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.213s][info   ][gc,start    ] GC(8) Pause Full (Allocation Failure)</span><br><span class="line">[0.213s][info   ][gc,phases,start] GC(8) Phase 1: Mark live objects</span><br><span class="line">[0.214s][info   ][gc,phases      ] GC(8) Phase 1: Mark live objects 1.714ms</span><br><span class="line">[0.214s][info   ][gc,phases,start] GC(8) Phase 2: Compute new object addresses</span><br><span class="line">[0.216s][info   ][gc,phases      ] GC(8) Phase 2: Compute new object addresses 1.139ms</span><br><span class="line">[0.216s][info   ][gc,phases,start] GC(8) Phase 3: Adjust pointers</span><br><span class="line">[0.216s][info   ][gc,phases      ] GC(8) Phase 3: Adjust pointers 0.541ms</span><br><span class="line">[0.216s][info   ][gc,phases,start] GC(8) Phase 4: Move objects</span><br><span class="line">[0.245s][info   ][gc,phases      ] GC(8) Phase 4: Move objects 28.964ms</span><br><span class="line">[0.245s][info   ][gc,heap        ] GC(8) DefNew: 157247K(157248K)-&gt;0K(157248K) Eden: 139776K(139776K)-&gt;0K(139776K) From: 17471K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.245s][info   ][gc,heap        ] GC(8) Tenured: 340047K(349568K)-&gt;265000K(349568K)</span><br><span class="line">[0.245s][info   ][gc,metaspace   ] GC(8) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.245s][info   ][gc             ] GC(8) Pause Full (Allocation Failure) 485M-&gt;258M(494M) 32.666ms</span><br><span class="line">[0.245s][info   ][gc,cpu         ] GC(8) User=0.02s Sys=0.02s Real=0.04s</span><br><span class="line">[0.256s][info   ][gc,start       ] GC(9) Pause Young (Allocation Failure)</span><br><span class="line">[0.259s][info   ][gc,heap        ] GC(9) DefNew: 139776K(157248K)-&gt;17470K(157248K) Eden: 139776K(139776K)-&gt;0K(139776K) From: 0K(17472K)-&gt;17470K(17472K)</span><br><span class="line">[0.259s][info   ][gc,heap        ] GC(9) Tenured: 265000K(349568K)-&gt;297074K(349568K)</span><br><span class="line">[0.259s][info   ][gc,metaspace   ] GC(9) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.259s][info   ][gc             ] GC(9) Pause Young (Allocation Failure) 395M-&gt;307M(494M) 3.024ms</span><br><span class="line">[0.259s][info   ][gc,cpu         ] GC(9) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.268s][info   ][gc,start       ] GC(10) Pause Young (Allocation Failure)</span><br><span class="line">[0.268s][info   ][gc             ] GC(10) Pause Young (Allocation Failure) 443M-&gt;443M(494M) 0.064ms</span><br><span class="line">[0.268s][info   ][gc,cpu         ] GC(10) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.268s][info   ][gc,start       ] GC(11) Pause Full (Allocation Failure)</span><br><span class="line">[0.268s][info   ][gc,phases,start] GC(11) Phase 1: Mark live objects</span><br><span class="line">[0.269s][info   ][gc,phases      ] GC(11) Phase 1: Mark live objects 0.848ms</span><br><span class="line">[0.269s][info   ][gc,phases,start] GC(11) Phase 2: Compute new object addresses</span><br><span class="line">[0.269s][info   ][gc,phases      ] GC(11) Phase 2: Compute new object addresses 0.585ms</span><br><span class="line">[0.269s][info   ][gc,phases,start] GC(11) Phase 3: Adjust pointers</span><br><span class="line">[0.270s][info   ][gc,phases      ] GC(11) Phase 3: Adjust pointers 0.548ms</span><br><span class="line">[0.270s][info   ][gc,phases,start] GC(11) Phase 4: Move objects</span><br><span class="line">[0.279s][info   ][gc,phases      ] GC(11) Phase 4: Move objects 9.684ms</span><br><span class="line">[0.280s][info   ][gc,heap        ] GC(11) DefNew: 157246K(157248K)-&gt;0K(157248K) Eden: 139776K(139776K)-&gt;0K(139776K) From: 17470K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.280s][info   ][gc,heap        ] GC(11) Tenured: 297074K(349568K)-&gt;286655K(349568K)</span><br><span class="line">[0.280s][info   ][gc,metaspace   ] GC(11) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.280s][info   ][gc             ] GC(11) Pause Full (Allocation Failure) 443M-&gt;279M(494M) 11.897ms</span><br><span class="line">[0.280s][info   ][gc,cpu         ] GC(11) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.287s][info   ][gc,start       ] GC(12) Pause Young (Allocation Failure)</span><br><span class="line">[0.290s][info   ][gc,heap        ] GC(12) DefNew: 139776K(157248K)-&gt;17471K(157248K) Eden: 139776K(139776K)-&gt;0K(139776K) From: 0K(17472K)-&gt;17471K(17472K)</span><br><span class="line">[0.290s][info   ][gc,heap        ] GC(12) Tenured: 286655K(349568K)-&gt;322214K(349568K)</span><br><span class="line">[0.290s][info   ][gc,metaspace   ] GC(12) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.290s][info   ][gc             ] GC(12) Pause Young (Allocation Failure) 416M-&gt;331M(494M) 2.629ms</span><br><span class="line">[0.290s][info   ][gc,cpu         ] GC(12) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.297s][info   ][gc,start       ] GC(13) Pause Young (Allocation Failure)</span><br><span class="line">[0.297s][info   ][gc             ] GC(13) Pause Young (Allocation Failure) 467M-&gt;467M(494M) 0.094ms</span><br><span class="line">[0.297s][info   ][gc,cpu         ] GC(13) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.297s][info   ][gc,start       ] GC(14) Pause Full (Allocation Failure)</span><br><span class="line">[0.297s][info   ][gc,phases,start] GC(14) Phase 1: Mark live objects</span><br><span class="line">[0.298s][info   ][gc,phases      ] GC(14) Phase 1: Mark live objects 0.916ms</span><br><span class="line">[0.298s][info   ][gc,phases,start] GC(14) Phase 2: Compute new object addresses</span><br><span class="line">[0.299s][info   ][gc,phases      ] GC(14) Phase 2: Compute new object addresses 0.565ms</span><br><span class="line">[0.299s][info   ][gc,phases,start] GC(14) Phase 3: Adjust pointers</span><br><span class="line">[0.299s][info   ][gc,phases      ] GC(14) Phase 3: Adjust pointers 0.548ms</span><br><span class="line">[0.299s][info   ][gc,phases,start] GC(14) Phase 4: Move objects</span><br><span class="line">[0.310s][info   ][gc,phases      ] GC(14) Phase 4: Move objects 10.832ms</span><br><span class="line">[0.310s][info   ][gc,heap        ] GC(14) DefNew: 156857K(157248K)-&gt;0K(157248K) Eden: 139386K(139776K)-&gt;0K(139776K) From: 17471K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.310s][info   ][gc,heap        ] GC(14) Tenured: 322214K(349568K)-&gt;307104K(349568K)</span><br><span class="line">[0.310s][info   ][gc,metaspace   ] GC(14) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.310s][info   ][gc             ] GC(14) Pause Full (Allocation Failure) 467M-&gt;299M(494M) 13.115ms</span><br><span class="line">[0.310s][info   ][gc,cpu         ] GC(14) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.317s][info   ][gc,start       ] GC(15) Pause Young (Allocation Failure)</span><br><span class="line">[0.317s][info   ][gc             ] GC(15) Pause Young (Allocation Failure) 436M-&gt;436M(494M) 0.088ms</span><br><span class="line">[0.317s][info   ][gc,cpu         ] GC(15) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.317s][info   ][gc,start       ] GC(16) Pause Full (Allocation Failure)</span><br><span class="line">[0.318s][info   ][gc,phases,start] GC(16) Phase 1: Mark live objects</span><br><span class="line">[0.318s][info   ][gc,phases      ] GC(16) Phase 1: Mark live objects 0.847ms</span><br><span class="line">[0.318s][info   ][gc,phases,start] GC(16) Phase 2: Compute new object addresses</span><br><span class="line">[0.319s][info   ][gc,phases      ] GC(16) Phase 2: Compute new object addresses 0.515ms</span><br><span class="line">[0.319s][info   ][gc,phases,start] GC(16) Phase 3: Adjust pointers</span><br><span class="line">[0.319s][info   ][gc,phases      ] GC(16) Phase 3: Adjust pointers 0.585ms</span><br><span class="line">[0.319s][info   ][gc,phases,start] GC(16) Phase 4: Move objects</span><br><span class="line">[0.332s][info   ][gc,phases      ] GC(16) Phase 4: Move objects 12.746ms</span><br><span class="line">[0.332s][info   ][gc,heap        ] GC(16) DefNew: 139776K(157248K)-&gt;0K(157248K) Eden: 139776K(139776K)-&gt;0K(139776K) From: 0K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.332s][info   ][gc,heap        ] GC(16) Tenured: 307104K(349568K)-&gt;302981K(349568K)</span><br><span class="line">[0.332s][info   ][gc,metaspace   ] GC(16) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.332s][info   ][gc             ] GC(16) Pause Full (Allocation Failure) 436M-&gt;295M(494M) 14.919ms</span><br><span class="line">[0.332s][info   ][gc,cpu         ] GC(16) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.340s][info   ][gc,start       ] GC(17) Pause Young (Allocation Failure)</span><br><span class="line">[0.343s][info   ][gc,heap        ] GC(17) DefNew: 139776K(157248K)-&gt;17471K(157248K) Eden: 139776K(139776K)-&gt;0K(139776K) From: 0K(17472K)-&gt;17471K(17472K)</span><br><span class="line">[0.343s][info   ][gc,heap        ] GC(17) Tenured: 302981K(349568K)-&gt;344094K(349568K)</span><br><span class="line">[0.343s][info   ][gc,metaspace   ] GC(17) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.343s][info   ][gc             ] GC(17) Pause Young (Allocation Failure) 432M-&gt;353M(494M) 3.047ms</span><br><span class="line">[0.344s][info   ][gc,cpu         ] GC(17) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.352s][info   ][gc,start       ] GC(18) Pause Young (Allocation Failure)</span><br><span class="line">[0.352s][info   ][gc             ] GC(18) Pause Young (Allocation Failure) 489M-&gt;489M(494M) 0.039ms</span><br><span class="line">[0.352s][info   ][gc,cpu         ] GC(18) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.352s][info   ][gc,start       ] GC(19) Pause Full (Allocation Failure)</span><br><span class="line">[0.352s][info   ][gc,phases,start] GC(19) Phase 1: Mark live objects</span><br><span class="line">[0.353s][info   ][gc,phases      ] GC(19) Phase 1: Mark live objects 0.851ms</span><br><span class="line">[0.353s][info   ][gc,phases,start] GC(19) Phase 2: Compute new object addresses</span><br><span class="line">[0.353s][info   ][gc,phases      ] GC(19) Phase 2: Compute new object addresses 0.641ms</span><br><span class="line">[0.353s][info   ][gc,phases,start] GC(19) Phase 3: Adjust pointers</span><br><span class="line">[0.354s][info   ][gc,phases      ] GC(19) Phase 3: Adjust pointers 0.556ms</span><br><span class="line">[0.354s][info   ][gc,phases,start] GC(19) Phase 4: Move objects</span><br><span class="line">[0.364s][info   ][gc,phases      ] GC(19) Phase 4: Move objects 9.830ms</span><br><span class="line">[0.364s][info   ][gc,heap        ] GC(19) DefNew: 157247K(157248K)-&gt;0K(157248K) Eden: 139776K(139776K)-&gt;0K(139776K) From: 17471K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.364s][info   ][gc,heap        ] GC(19) Tenured: 344094K(349568K)-&gt;335517K(349568K)</span><br><span class="line">[0.364s][info   ][gc,metaspace   ] GC(19) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.364s][info   ][gc             ] GC(19) Pause Full (Allocation Failure) 489M-&gt;327M(494M) 12.093ms</span><br><span class="line">[0.364s][info   ][gc,cpu         ] GC(19) User=0.01s Sys=0.00s Real=0.02s</span><br><span class="line">[0.372s][info   ][gc,start       ] GC(20) Pause Young (Allocation Failure)</span><br><span class="line">[0.372s][info   ][gc             ] GC(20) Pause Young (Allocation Failure) 464M-&gt;464M(494M) 0.060ms</span><br><span class="line">[0.372s][info   ][gc,cpu         ] GC(20) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.372s][info   ][gc,start       ] GC(21) Pause Full (Allocation Failure)</span><br><span class="line">[0.372s][info   ][gc,phases,start] GC(21) Phase 1: Mark live objects</span><br><span class="line">[0.373s][info   ][gc,phases      ] GC(21) Phase 1: Mark live objects 0.795ms</span><br><span class="line">[0.373s][info   ][gc,phases,start] GC(21) Phase 2: Compute new object addresses</span><br><span class="line">[0.373s][info   ][gc,phases      ] GC(21) Phase 2: Compute new object addresses 0.629ms</span><br><span class="line">[0.373s][info   ][gc,phases,start] GC(21) Phase 3: Adjust pointers</span><br><span class="line">[0.374s][info   ][gc,phases      ] GC(21) Phase 3: Adjust pointers 0.549ms</span><br><span class="line">[0.374s][info   ][gc,phases,start] GC(21) Phase 4: Move objects</span><br><span class="line">[0.384s][info   ][gc,phases      ] GC(21) Phase 4: Move objects 9.949ms</span><br><span class="line">[0.384s][info   ][gc,heap        ] GC(21) DefNew: 139622K(157248K)-&gt;0K(157248K) Eden: 139622K(139776K)-&gt;0K(139776K) From: 0K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.384s][info   ][gc,heap        ] GC(21) Tenured: 335517K(349568K)-&gt;333618K(349568K)</span><br><span class="line">[0.384s][info   ][gc,metaspace   ] GC(21) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.384s][info   ][gc             ] GC(21) Pause Full (Allocation Failure) 464M-&gt;325M(494M) 12.146ms</span><br><span class="line">[0.384s][info   ][gc,cpu         ] GC(21) User=0.01s Sys=0.00s Real=0.02s</span><br><span class="line">[0.395s][info   ][gc,start       ] GC(22) Pause Young (Allocation Failure)</span><br><span class="line">[0.395s][info   ][gc             ] GC(22) Pause Young (Allocation Failure) 462M-&gt;462M(494M) 0.044ms</span><br><span class="line">[0.395s][info   ][gc,cpu         ] GC(22) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.395s][info   ][gc,start       ] GC(23) Pause Full (Allocation Failure)</span><br><span class="line">[0.395s][info   ][gc,phases,start] GC(23) Phase 1: Mark live objects</span><br><span class="line">[0.396s][info   ][gc,phases      ] GC(23) Phase 1: Mark live objects 0.919ms</span><br><span class="line">[0.396s][info   ][gc,phases,start] GC(23) Phase 2: Compute new object addresses</span><br><span class="line">[0.397s][info   ][gc,phases      ] GC(23) Phase 2: Compute new object addresses 0.660ms</span><br><span class="line">[0.397s][info   ][gc,phases,start] GC(23) Phase 3: Adjust pointers</span><br><span class="line">[0.397s][info   ][gc,phases      ] GC(23) Phase 3: Adjust pointers 0.552ms</span><br><span class="line">[0.397s][info   ][gc,phases,start] GC(23) Phase 4: Move objects</span><br><span class="line">[0.408s][info   ][gc,phases      ] GC(23) Phase 4: Move objects 10.520ms</span><br><span class="line">[0.408s][info   ][gc,heap        ] GC(23) DefNew: 139776K(157248K)-&gt;0K(157248K) Eden: 139776K(139776K)-&gt;0K(139776K) From: 0K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.408s][info   ][gc,heap        ] GC(23) Tenured: 333618K(349568K)-&gt;337034K(349568K)</span><br><span class="line">[0.408s][info   ][gc,metaspace   ] GC(23) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.408s][info   ][gc             ] GC(23) Pause Full (Allocation Failure) 462M-&gt;329M(494M) 12.928ms</span><br><span class="line">[0.408s][info   ][gc,cpu         ] GC(23) User=0.02s Sys=0.00s Real=0.01s</span><br><span class="line">[0.416s][info   ][gc,start       ] GC(24) Pause Young (Allocation Failure)</span><br><span class="line">[0.416s][info   ][gc             ] GC(24) Pause Young (Allocation Failure) 465M-&gt;465M(494M) 0.049ms</span><br><span class="line">[0.416s][info   ][gc,cpu         ] GC(24) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.416s][info   ][gc,start       ] GC(25) Pause Full (Allocation Failure)</span><br><span class="line">[0.416s][info   ][gc,phases,start] GC(25) Phase 1: Mark live objects</span><br><span class="line">[0.417s][info   ][gc,phases      ] GC(25) Phase 1: Mark live objects 0.831ms</span><br><span class="line">[0.417s][info   ][gc,phases,start] GC(25) Phase 2: Compute new object addresses</span><br><span class="line">[0.418s][info   ][gc,phases      ] GC(25) Phase 2: Compute new object addresses 0.650ms</span><br><span class="line">[0.418s][info   ][gc,phases,start] GC(25) Phase 3: Adjust pointers</span><br><span class="line">[0.418s][info   ][gc,phases      ] GC(25) Phase 3: Adjust pointers 0.546ms</span><br><span class="line">[0.418s][info   ][gc,phases,start] GC(25) Phase 4: Move objects</span><br><span class="line">[0.430s][info   ][gc,phases      ] GC(25) Phase 4: Move objects 11.446ms</span><br><span class="line">[0.430s][info   ][gc,heap        ] GC(25) DefNew: 139776K(157248K)-&gt;0K(157248K) Eden: 139776K(139776K)-&gt;0K(139776K) From: 0K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.430s][info   ][gc,heap        ] GC(25) Tenured: 337034K(349568K)-&gt;323827K(349568K)</span><br><span class="line">[0.430s][info   ][gc,metaspace   ] GC(25) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.430s][info   ][gc             ] GC(25) Pause Full (Allocation Failure) 465M-&gt;316M(494M) 13.698ms</span><br><span class="line">[0.430s][info   ][gc,cpu         ] GC(25) User=0.02s Sys=0.00s Real=0.01s</span><br><span class="line">[0.438s][info   ][gc,start       ] GC(26) Pause Young (Allocation Failure)</span><br><span class="line">[0.438s][info   ][gc             ] GC(26) Pause Young (Allocation Failure) 452M-&gt;452M(494M) 0.045ms</span><br><span class="line">[0.438s][info   ][gc,cpu         ] GC(26) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.438s][info   ][gc,start       ] GC(27) Pause Full (Allocation Failure)</span><br><span class="line">[0.438s][info   ][gc,phases,start] GC(27) Phase 1: Mark live objects</span><br><span class="line">[0.438s][info   ][gc,phases      ] GC(27) Phase 1: Mark live objects 0.780ms</span><br><span class="line">[0.438s][info   ][gc,phases,start] GC(27) Phase 2: Compute new object addresses</span><br><span class="line">[0.439s][info   ][gc,phases      ] GC(27) Phase 2: Compute new object addresses 0.578ms</span><br><span class="line">[0.439s][info   ][gc,phases,start] GC(27) Phase 3: Adjust pointers</span><br><span class="line">[0.440s][info   ][gc,phases      ] GC(27) Phase 3: Adjust pointers 0.543ms</span><br><span class="line">[0.440s][info   ][gc,phases,start] GC(27) Phase 4: Move objects</span><br><span class="line">[0.448s][info   ][gc,phases      ] GC(27) Phase 4: Move objects 8.568ms</span><br><span class="line">[0.448s][info   ][gc,heap        ] GC(27) DefNew: 139324K(157248K)-&gt;0K(157248K) Eden: 139324K(139776K)-&gt;0K(139776K) From: 0K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.448s][info   ][gc,heap        ] GC(27) Tenured: 323827K(349568K)-&gt;341582K(349568K)</span><br><span class="line">[0.448s][info   ][gc,metaspace   ] GC(27) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.448s][info   ][gc             ] GC(27) Pause Full (Allocation Failure) 452M-&gt;333M(494M) 10.722ms</span><br><span class="line">[0.448s][info   ][gc,cpu         ] GC(27) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.455s][info   ][gc,start       ] GC(28) Pause Young (Allocation Failure)</span><br><span class="line">[0.455s][info   ][gc             ] GC(28) Pause Young (Allocation Failure) 470M-&gt;470M(494M) 0.078ms</span><br><span class="line">[0.455s][info   ][gc,cpu         ] GC(28) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.455s][info   ][gc,start       ] GC(29) Pause Full (Allocation Failure)</span><br><span class="line">[0.455s][info   ][gc,phases,start] GC(29) Phase 1: Mark live objects</span><br><span class="line">[0.456s][info   ][gc,phases      ] GC(29) Phase 1: Mark live objects 0.869ms</span><br><span class="line">[0.456s][info   ][gc,phases,start] GC(29) Phase 2: Compute new object addresses</span><br><span class="line">[0.457s][info   ][gc,phases      ] GC(29) Phase 2: Compute new object addresses 0.548ms</span><br><span class="line">[0.457s][info   ][gc,phases,start] GC(29) Phase 3: Adjust pointers</span><br><span class="line">[0.457s][info   ][gc,phases      ] GC(29) Phase 3: Adjust pointers 0.552ms</span><br><span class="line">[0.457s][info   ][gc,phases,start] GC(29) Phase 4: Move objects</span><br><span class="line">[0.468s][info   ][gc,phases      ] GC(29) Phase 4: Move objects 10.686ms</span><br><span class="line">[0.468s][info   ][gc,heap        ] GC(29) DefNew: 139776K(157248K)-&gt;2162K(157248K) Eden: 139776K(139776K)-&gt;2162K(139776K) From: 0K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.468s][info   ][gc,heap        ] GC(29) Tenured: 341582K(349568K)-&gt;349021K(349568K)</span><br><span class="line">[0.468s][info   ][gc,metaspace   ] GC(29) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.468s][info   ][gc             ] GC(29) Pause Full (Allocation Failure) 470M-&gt;342M(494M) 12.888ms</span><br><span class="line">[0.468s][info   ][gc,cpu         ] GC(29) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.476s][info   ][gc,start       ] GC(30) Pause Full (Allocation Failure)</span><br><span class="line">[0.476s][info   ][gc,phases,start] GC(30) Phase 1: Mark live objects</span><br><span class="line">[0.477s][info   ][gc,phases      ] GC(30) Phase 1: Mark live objects 0.774ms</span><br><span class="line">[0.477s][info   ][gc,phases,start] GC(30) Phase 2: Compute new object addresses</span><br><span class="line">[0.478s][info   ][gc,phases      ] GC(30) Phase 2: Compute new object addresses 0.627ms</span><br><span class="line">[0.478s][info   ][gc,phases,start] GC(30) Phase 3: Adjust pointers</span><br><span class="line">[0.478s][info   ][gc,phases      ] GC(30) Phase 3: Adjust pointers 0.549ms</span><br><span class="line">[0.478s][info   ][gc,phases,start] GC(30) Phase 4: Move objects</span><br><span class="line">[0.490s][info   ][gc,phases      ] GC(30) Phase 4: Move objects 11.357ms</span><br><span class="line">[0.490s][info   ][gc,heap        ] GC(30) DefNew: 157236K(157248K)-&gt;6660K(157248K) Eden: 139776K(139776K)-&gt;6660K(139776K) From: 17460K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.490s][info   ][gc,heap        ] GC(30) Tenured: 349348K(349568K)-&gt;349431K(349568K)</span><br><span class="line">[0.490s][info   ][gc,metaspace   ] GC(30) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.490s][info   ][gc             ] GC(30) Pause Full (Allocation Failure) 494M-&gt;347M(494M) 13.570ms</span><br><span class="line">[0.490s][info   ][gc,cpu         ] GC(30) User=0.02s Sys=0.00s Real=0.01s</span><br><span class="line">[0.499s][info   ][gc,start       ] GC(31) Pause Full (Allocation Failure)</span><br><span class="line">[0.499s][info   ][gc,phases,start] GC(31) Phase 1: Mark live objects</span><br><span class="line">[0.500s][info   ][gc,phases      ] GC(31) Phase 1: Mark live objects 0.808ms</span><br><span class="line">[0.500s][info   ][gc,phases,start] GC(31) Phase 2: Compute new object addresses</span><br><span class="line">[0.500s][info   ][gc,phases      ] GC(31) Phase 2: Compute new object addresses 0.630ms</span><br><span class="line">[0.500s][info   ][gc,phases,start] GC(31) Phase 3: Adjust pointers</span><br><span class="line">[0.501s][info   ][gc,phases      ] GC(31) Phase 3: Adjust pointers 0.551ms</span><br><span class="line">[0.501s][info   ][gc,phases,start] GC(31) Phase 4: Move objects</span><br><span class="line">[0.513s][info   ][gc,phases      ] GC(31) Phase 4: Move objects 12.077ms</span><br><span class="line">[0.513s][info   ][gc,heap        ] GC(31) DefNew: 157242K(157248K)-&gt;0K(157248K) Eden: 139776K(139776K)-&gt;0K(139776K) From: 17466K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.513s][info   ][gc,heap        ] GC(31) Tenured: 349539K(349568K)-&gt;336807K(349568K)</span><br><span class="line">[0.513s][info   ][gc,metaspace   ] GC(31) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.513s][info   ][gc             ] GC(31) Pause Full (Allocation Failure) 494M-&gt;328M(494M) 14.318ms</span><br><span class="line">[0.513s][info   ][gc,cpu         ] GC(31) User=0.02s Sys=0.00s Real=0.01s</span><br><span class="line">[0.521s][info   ][gc,start       ] GC(32) Pause Young (Allocation Failure)</span><br><span class="line">[0.521s][info   ][gc             ] GC(32) Pause Young (Allocation Failure) 465M-&gt;465M(494M) 0.063ms</span><br><span class="line">[0.521s][info   ][gc,cpu         ] GC(32) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.521s][info   ][gc,start       ] GC(33) Pause Full (Allocation Failure)</span><br><span class="line">[0.521s][info   ][gc,phases,start] GC(33) Phase 1: Mark live objects</span><br><span class="line">[0.522s][info   ][gc,phases      ] GC(33) Phase 1: Mark live objects 0.819ms</span><br><span class="line">[0.522s][info   ][gc,phases,start] GC(33) Phase 2: Compute new object addresses</span><br><span class="line">[0.523s][info   ][gc,phases      ] GC(33) Phase 2: Compute new object addresses 0.560ms</span><br><span class="line">[0.523s][info   ][gc,phases,start] GC(33) Phase 3: Adjust pointers</span><br><span class="line">[0.523s][info   ][gc,phases      ] GC(33) Phase 3: Adjust pointers 0.558ms</span><br><span class="line">[0.523s][info   ][gc,phases,start] GC(33) Phase 4: Move objects</span><br><span class="line">[0.530s][info   ][gc,phases      ] GC(33) Phase 4: Move objects 6.884ms</span><br><span class="line">[0.530s][info   ][gc,heap        ] GC(33) DefNew: 139703K(157248K)-&gt;2909K(157248K) Eden: 139703K(139776K)-&gt;2909K(139776K) From: 0K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.530s][info   ][gc,heap        ] GC(33) Tenured: 336807K(349568K)-&gt;349437K(349568K)</span><br><span class="line">[0.530s][info   ][gc,metaspace   ] GC(33) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.530s][info   ][gc             ] GC(33) Pause Full (Allocation Failure) 465M-&gt;344M(494M) 9.019ms</span><br><span class="line">[0.530s][info   ][gc,cpu         ] GC(33) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">[0.538s][info   ][gc,start       ] GC(34) Pause Full (Allocation Failure)</span><br><span class="line">[0.539s][info   ][gc,phases,start] GC(34) Phase 1: Mark live objects</span><br><span class="line">[0.539s][info   ][gc,phases      ] GC(34) Phase 1: Mark live objects 0.845ms</span><br><span class="line">[0.539s][info   ][gc,phases,start] GC(34) Phase 2: Compute new object addresses</span><br><span class="line">[0.540s][info   ][gc,phases      ] GC(34) Phase 2: Compute new object addresses 0.634ms</span><br><span class="line">[0.540s][info   ][gc,phases,start] GC(34) Phase 3: Adjust pointers</span><br><span class="line">[0.541s][info   ][gc,phases      ] GC(34) Phase 3: Adjust pointers 0.548ms</span><br><span class="line">[0.541s][info   ][gc,phases,start] GC(34) Phase 4: Move objects</span><br><span class="line">[0.551s][info   ][gc,phases      ] GC(34) Phase 4: Move objects 10.689ms</span><br><span class="line">[0.551s][info   ][gc,heap        ] GC(34) DefNew: 156992K(157248K)-&gt;14461K(157248K) Eden: 139776K(139776K)-&gt;14461K(139776K) From: 17216K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.551s][info   ][gc,heap        ] GC(34) Tenured: 349437K(349568K)-&gt;348945K(349568K)</span><br><span class="line">[0.551s][info   ][gc,metaspace   ] GC(34) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.551s][info   ][gc             ] GC(34) Pause Full (Allocation Failure) 494M-&gt;354M(494M) 13.010ms</span><br><span class="line">[0.551s][info   ][gc,cpu         ] GC(34) User=0.02s Sys=0.00s Real=0.01s</span><br><span class="line">[0.560s][info   ][gc,start       ] GC(35) Pause Full (Allocation Failure)</span><br><span class="line">[0.560s][info   ][gc,phases,start] GC(35) Phase 1: Mark live objects</span><br><span class="line">[0.561s][info   ][gc,phases      ] GC(35) Phase 1: Mark live objects 0.747ms</span><br><span class="line">[0.561s][info   ][gc,phases,start] GC(35) Phase 2: Compute new object addresses</span><br><span class="line">[0.562s][info   ][gc,phases      ] GC(35) Phase 2: Compute new object addresses 0.623ms</span><br><span class="line">[0.562s][info   ][gc,phases,start] GC(35) Phase 3: Adjust pointers</span><br><span class="line">[0.562s][info   ][gc,phases      ] GC(35) Phase 3: Adjust pointers 0.540ms</span><br><span class="line">[0.562s][info   ][gc,phases,start] GC(35) Phase 4: Move objects</span><br><span class="line">[0.573s][info   ][gc,phases      ] GC(35) Phase 4: Move objects 10.715ms</span><br><span class="line">[0.573s][info   ][gc,heap        ] GC(35) DefNew: 157247K(157248K)-&gt;13031K(157248K) Eden: 139776K(139776K)-&gt;13031K(139776K) From: 17471K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.573s][info   ][gc,heap        ] GC(35) Tenured: 349562K(349568K)-&gt;349380K(349568K)</span><br><span class="line">[0.573s][info   ][gc,metaspace   ] GC(35) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.573s][info   ][gc             ] GC(35) Pause Full (Allocation Failure) 494M-&gt;353M(494M) 12.855ms</span><br><span class="line">[0.573s][info   ][gc,cpu         ] GC(35) User=0.02s Sys=0.00s Real=0.01s</span><br><span class="line">[0.582s][info   ][gc,start       ] GC(36) Pause Full (Allocation Failure)</span><br><span class="line">[0.582s][info   ][gc,phases,start] GC(36) Phase 1: Mark live objects</span><br><span class="line">[0.583s][info   ][gc,phases      ] GC(36) Phase 1: Mark live objects 0.793ms</span><br><span class="line">[0.583s][info   ][gc,phases,start] GC(36) Phase 2: Compute new object addresses</span><br><span class="line">[0.583s][info   ][gc,phases      ] GC(36) Phase 2: Compute new object addresses 0.617ms</span><br><span class="line">[0.583s][info   ][gc,phases,start] GC(36) Phase 3: Adjust pointers</span><br><span class="line">[0.584s][info   ][gc,phases      ] GC(36) Phase 3: Adjust pointers 0.548ms</span><br><span class="line">[0.584s][info   ][gc,phases,start] GC(36) Phase 4: Move objects</span><br><span class="line">[0.597s][info   ][gc,phases      ] GC(36) Phase 4: Move objects 13.087ms</span><br><span class="line">[0.597s][info   ][gc,heap        ] GC(36) DefNew: 156867K(157248K)-&gt;2089K(157248K) Eden: 139776K(139776K)-&gt;2089K(139776K) From: 17091K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.597s][info   ][gc,heap        ] GC(36) Tenured: 349380K(349568K)-&gt;349559K(349568K)</span><br><span class="line">[0.597s][info   ][gc,metaspace   ] GC(36) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.597s][info   ][gc             ] GC(36) Pause Full (Allocation Failure) 494M-&gt;343M(494M) 15.326ms</span><br><span class="line">[0.597s][info   ][gc,cpu         ] GC(36) User=0.01s Sys=0.00s Real=0.02s</span><br><span class="line">[0.609s][info   ][gc,start       ] GC(37) Pause Full (Allocation Failure)</span><br><span class="line">[0.609s][info   ][gc,phases,start] GC(37) Phase 1: Mark live objects</span><br><span class="line">[0.610s][info   ][gc,phases      ] GC(37) Phase 1: Mark live objects 0.811ms</span><br><span class="line">[0.610s][info   ][gc,phases,start] GC(37) Phase 2: Compute new object addresses</span><br><span class="line">[0.610s][info   ][gc,phases      ] GC(37) Phase 2: Compute new object addresses 0.620ms</span><br><span class="line">[0.610s][info   ][gc,phases,start] GC(37) Phase 3: Adjust pointers</span><br><span class="line">[0.611s][info   ][gc,phases      ] GC(37) Phase 3: Adjust pointers 0.556ms</span><br><span class="line">[0.611s][info   ][gc,phases,start] GC(37) Phase 4: Move objects</span><br><span class="line">[0.620s][info   ][gc,phases      ] GC(37) Phase 4: Move objects 9.410ms</span><br><span class="line">[0.621s][info   ][gc,heap        ] GC(37) DefNew: 157135K(157248K)-&gt;18892K(157248K) Eden: 139776K(139776K)-&gt;18892K(139776K) From: 17359K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.621s][info   ][gc,heap        ] GC(37) Tenured: 349559K(349568K)-&gt;349187K(349568K)</span><br><span class="line">[0.621s][info   ][gc,metaspace   ] GC(37) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.621s][info   ][gc             ] GC(37) Pause Full (Allocation Failure) 494M-&gt;359M(494M) 11.644ms</span><br><span class="line">[0.621s][info   ][gc,cpu         ] GC(37) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.629s][info   ][gc,start       ] GC(38) Pause Full (Allocation Failure)</span><br><span class="line">[0.629s][info   ][gc,phases,start] GC(38) Phase 1: Mark live objects</span><br><span class="line">[0.630s][info   ][gc,phases      ] GC(38) Phase 1: Mark live objects 0.840ms</span><br><span class="line">[0.630s][info   ][gc,phases,start] GC(38) Phase 2: Compute new object addresses</span><br><span class="line">[0.631s][info   ][gc,phases      ] GC(38) Phase 2: Compute new object addresses 0.642ms</span><br><span class="line">[0.631s][info   ][gc,phases,start] GC(38) Phase 3: Adjust pointers</span><br><span class="line">[0.631s][info   ][gc,phases      ] GC(38) Phase 3: Adjust pointers 0.594ms</span><br><span class="line">[0.631s][info   ][gc,phases,start] GC(38) Phase 4: Move objects</span><br><span class="line">[0.642s][info   ][gc,phases      ] GC(38) Phase 4: Move objects 10.918ms</span><br><span class="line">[0.642s][info   ][gc,heap        ] GC(38) DefNew: 157187K(157248K)-&gt;25556K(157248K) Eden: 139776K(139776K)-&gt;25556K(139776K) From: 17411K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.642s][info   ][gc,heap        ] GC(38) Tenured: 349483K(349568K)-&gt;349555K(349568K)</span><br><span class="line">[0.642s][info   ][gc,metaspace   ] GC(38) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.642s][info   ][gc             ] GC(38) Pause Full (Allocation Failure) 494M-&gt;366M(494M) 13.287ms</span><br><span class="line">[0.642s][info   ][gc,cpu         ] GC(38) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.650s][info   ][gc,start       ] GC(39) Pause Full (Allocation Failure)</span><br><span class="line">[0.650s][info   ][gc,phases,start] GC(39) Phase 1: Mark live objects</span><br><span class="line">[0.650s][info   ][gc,phases      ] GC(39) Phase 1: Mark live objects 0.815ms</span><br><span class="line">[0.650s][info   ][gc,phases,start] GC(39) Phase 2: Compute new object addresses</span><br><span class="line">[0.651s][info   ][gc,phases      ] GC(39) Phase 2: Compute new object addresses 0.603ms</span><br><span class="line">[0.651s][info   ][gc,phases,start] GC(39) Phase 3: Adjust pointers</span><br><span class="line">[0.652s][info   ][gc,phases      ] GC(39) Phase 3: Adjust pointers 0.557ms</span><br><span class="line">[0.652s][info   ][gc,phases,start] GC(39) Phase 4: Move objects</span><br><span class="line">[0.663s][info   ][gc,phases      ] GC(39) Phase 4: Move objects 11.124ms</span><br><span class="line">[0.663s][info   ][gc,heap        ] GC(39) DefNew: 157159K(157248K)-&gt;18623K(157248K) Eden: 139776K(139776K)-&gt;18623K(139776K) From: 17383K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.663s][info   ][gc,heap        ] GC(39) Tenured: 349555K(349568K)-&gt;349322K(349568K)</span><br><span class="line">[0.663s][info   ][gc,metaspace   ] GC(39) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.663s][info   ][gc             ] GC(39) Pause Full (Allocation Failure) 494M-&gt;359M(494M) 13.374ms</span><br><span class="line">[0.663s][info   ][gc,cpu         ] GC(39) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.671s][info   ][gc,start       ] GC(40) Pause Full (Allocation Failure)</span><br><span class="line">[0.671s][info   ][gc,phases,start] GC(40) Phase 1: Mark live objects</span><br><span class="line">[0.672s][info   ][gc,phases      ] GC(40) Phase 1: Mark live objects 0.886ms</span><br><span class="line">[0.672s][info   ][gc,phases,start] GC(40) Phase 2: Compute new object addresses</span><br><span class="line">[0.672s][info   ][gc,phases      ] GC(40) Phase 2: Compute new object addresses 0.600ms</span><br><span class="line">[0.672s][info   ][gc,phases,start] GC(40) Phase 3: Adjust pointers</span><br><span class="line">[0.673s][info   ][gc,phases      ] GC(40) Phase 3: Adjust pointers 0.686ms</span><br><span class="line">[0.673s][info   ][gc,phases,start] GC(40) Phase 4: Move objects</span><br><span class="line">[0.685s][info   ][gc,phases      ] GC(40) Phase 4: Move objects 12.441ms</span><br><span class="line">[0.685s][info   ][gc,heap        ] GC(40) DefNew: 156701K(157248K)-&gt;2071K(157248K) Eden: 139776K(139776K)-&gt;2071K(139776K) From: 16925K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.685s][info   ][gc,heap        ] GC(40) Tenured: 349322K(349568K)-&gt;349271K(349568K)</span><br><span class="line">[0.686s][info   ][gc,metaspace   ] GC(40) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.686s][info   ][gc             ] GC(40) Pause Full (Allocation Failure) 494M-&gt;343M(494M) 14.957ms</span><br><span class="line">[0.686s][info   ][gc,cpu         ] GC(40) User=0.01s Sys=0.00s Real=0.02s</span><br><span class="line">[0.694s][info   ][gc,start       ] GC(41) Pause Full (Allocation Failure)</span><br><span class="line">[0.694s][info   ][gc,phases,start] GC(41) Phase 1: Mark live objects</span><br><span class="line">[0.695s][info   ][gc,phases      ] GC(41) Phase 1: Mark live objects 0.787ms</span><br><span class="line">[0.695s][info   ][gc,phases,start] GC(41) Phase 2: Compute new object addresses</span><br><span class="line">[0.696s][info   ][gc,phases      ] GC(41) Phase 2: Compute new object addresses 0.637ms</span><br><span class="line">[0.696s][info   ][gc,phases,start] GC(41) Phase 3: Adjust pointers</span><br><span class="line">[0.696s][info   ][gc,phases      ] GC(41) Phase 3: Adjust pointers 0.546ms</span><br><span class="line">[0.697s][info   ][gc,phases,start] GC(41) Phase 4: Move objects</span><br><span class="line">[0.706s][info   ][gc,phases      ] GC(41) Phase 4: Move objects 9.183ms</span><br><span class="line">[0.706s][info   ][gc,heap        ] GC(41) DefNew: 157171K(157248K)-&gt;15970K(157248K) Eden: 139776K(139776K)-&gt;15970K(139776K) From: 17395K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.706s][info   ][gc,heap        ] GC(41) Tenured: 349271K(349568K)-&gt;349083K(349568K)</span><br><span class="line">[0.706s][info   ][gc,metaspace   ] GC(41) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.706s][info   ][gc             ] GC(41) Pause Full (Allocation Failure) 494M-&gt;356M(494M) 11.410ms</span><br><span class="line">[0.706s][info   ][gc,cpu         ] GC(41) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.715s][info   ][gc,start       ] GC(42) Pause Full (Allocation Failure)</span><br><span class="line">[0.715s][info   ][gc,phases,start] GC(42) Phase 1: Mark live objects</span><br><span class="line">[0.716s][info   ][gc,phases      ] GC(42) Phase 1: Mark live objects 0.868ms</span><br><span class="line">[0.716s][info   ][gc,phases,start] GC(42) Phase 2: Compute new object addresses</span><br><span class="line">[0.717s][info   ][gc,phases      ] GC(42) Phase 2: Compute new object addresses 0.638ms</span><br><span class="line">[0.717s][info   ][gc,phases,start] GC(42) Phase 3: Adjust pointers</span><br><span class="line">[0.717s][info   ][gc,phases      ] GC(42) Phase 3: Adjust pointers 0.553ms</span><br><span class="line">[0.717s][info   ][gc,phases,start] GC(42) Phase 4: Move objects</span><br><span class="line">[0.728s][info   ][gc,phases      ] GC(42) Phase 4: Move objects 10.819ms</span><br><span class="line">[0.728s][info   ][gc,heap        ] GC(42) DefNew: 157093K(157248K)-&gt;14052K(157248K) Eden: 139776K(139776K)-&gt;14052K(139776K) From: 17317K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.728s][info   ][gc,heap        ] GC(42) Tenured: 349083K(349568K)-&gt;349199K(349568K)</span><br><span class="line">[0.728s][info   ][gc,metaspace   ] GC(42) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.728s][info   ][gc             ] GC(42) Pause Full (Allocation Failure) 494M-&gt;354M(494M) 13.173ms</span><br><span class="line">[0.728s][info   ][gc,cpu         ] GC(42) User=0.02s Sys=0.00s Real=0.01s</span><br><span class="line">[0.736s][info   ][gc,start       ] GC(43) Pause Full (Allocation Failure)</span><br><span class="line">[0.736s][info   ][gc,phases,start] GC(43) Phase 1: Mark live objects</span><br><span class="line">[0.737s][info   ][gc,phases      ] GC(43) Phase 1: Mark live objects 0.867ms</span><br><span class="line">[0.737s][info   ][gc,phases,start] GC(43) Phase 2: Compute new object addresses</span><br><span class="line">[0.738s][info   ][gc,phases      ] GC(43) Phase 2: Compute new object addresses 0.631ms</span><br><span class="line">[0.738s][info   ][gc,phases,start] GC(43) Phase 3: Adjust pointers</span><br><span class="line">[0.738s][info   ][gc,phases      ] GC(43) Phase 3: Adjust pointers 0.552ms</span><br><span class="line">[0.738s][info   ][gc,phases,start] GC(43) Phase 4: Move objects</span><br><span class="line">[0.749s][info   ][gc,phases      ] GC(43) Phase 4: Move objects 11.168ms</span><br><span class="line">[0.749s][info   ][gc,heap        ] GC(43) DefNew: 157182K(157248K)-&gt;7478K(157248K) Eden: 139776K(139776K)-&gt;7478K(139776K) From: 17406K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.749s][info   ][gc,heap        ] GC(43) Tenured: 349199K(349568K)-&gt;349196K(349568K)</span><br><span class="line">[0.749s][info   ][gc,metaspace   ] GC(43) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.750s][info   ][gc             ] GC(43) Pause Full (Allocation Failure) 494M-&gt;348M(494M) 13.534ms</span><br><span class="line">[0.750s][info   ][gc,cpu         ] GC(43) User=0.02s Sys=0.00s Real=0.01s</span><br><span class="line">[0.757s][info   ][gc,start       ] GC(44) Pause Full (Allocation Failure)</span><br><span class="line">[0.757s][info   ][gc,phases,start] GC(44) Phase 1: Mark live objects</span><br><span class="line">[0.758s][info   ][gc,phases      ] GC(44) Phase 1: Mark live objects 0.791ms</span><br><span class="line">[0.758s][info   ][gc,phases,start] GC(44) Phase 2: Compute new object addresses</span><br><span class="line">[0.759s][info   ][gc,phases      ] GC(44) Phase 2: Compute new object addresses 0.618ms</span><br><span class="line">[0.759s][info   ][gc,phases,start] GC(44) Phase 3: Adjust pointers</span><br><span class="line">[0.759s][info   ][gc,phases      ] GC(44) Phase 3: Adjust pointers 0.538ms</span><br><span class="line">[0.759s][info   ][gc,phases,start] GC(44) Phase 4: Move objects</span><br><span class="line">[0.772s][info   ][gc,phases      ] GC(44) Phase 4: Move objects 12.159ms</span><br><span class="line">[0.772s][info   ][gc,heap        ] GC(44) DefNew: 157054K(157248K)-&gt;0K(157248K) Eden: 139776K(139776K)-&gt;0K(139776K) From: 17278K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.772s][info   ][gc,heap        ] GC(44) Tenured: 349196K(349568K)-&gt;340337K(349568K)</span><br><span class="line">[0.772s][info   ][gc,metaspace   ] GC(44) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.772s][info   ][gc             ] GC(44) Pause Full (Allocation Failure) 494M-&gt;332M(494M) 14.407ms</span><br><span class="line">[0.772s][info   ][gc,cpu         ] GC(44) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.780s][info   ][gc,start       ] GC(45) Pause Young (Allocation Failure)</span><br><span class="line">[0.780s][info   ][gc             ] GC(45) Pause Young (Allocation Failure) 468M-&gt;468M(494M) 0.069ms</span><br><span class="line">[0.780s][info   ][gc,cpu         ] GC(45) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.780s][info   ][gc,start       ] GC(46) Pause Full (Allocation Failure)</span><br><span class="line">[0.780s][info   ][gc,phases,start] GC(46) Phase 1: Mark live objects</span><br><span class="line">[0.781s][info   ][gc,phases      ] GC(46) Phase 1: Mark live objects 0.898ms</span><br><span class="line">[0.781s][info   ][gc,phases,start] GC(46) Phase 2: Compute new object addresses</span><br><span class="line">[0.781s][info   ][gc,phases      ] GC(46) Phase 2: Compute new object addresses 0.646ms</span><br><span class="line">[0.781s][info   ][gc,phases,start] GC(46) Phase 3: Adjust pointers</span><br><span class="line">[0.782s][info   ][gc,phases      ] GC(46) Phase 3: Adjust pointers 0.566ms</span><br><span class="line">[0.782s][info   ][gc,phases,start] GC(46) Phase 4: Move objects</span><br><span class="line">[0.791s][info   ][gc,phases      ] GC(46) Phase 4: Move objects 8.666ms</span><br><span class="line">[0.791s][info   ][gc,heap        ] GC(46) DefNew: 139776K(157248K)-&gt;7769K(157248K) Eden: 139776K(139776K)-&gt;7769K(139776K) From: 0K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.791s][info   ][gc,heap        ] GC(46) Tenured: 340337K(349568K)-&gt;349312K(349568K)</span><br><span class="line">[0.791s][info   ][gc,metaspace   ] GC(46) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.791s][info   ][gc             ] GC(46) Pause Full (Allocation Failure) 468M-&gt;348M(494M) 11.036ms</span><br><span class="line">[0.791s][info   ][gc,cpu         ] GC(46) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.799s][info   ][gc,start       ] GC(47) Pause Full (Allocation Failure)</span><br><span class="line">[0.799s][info   ][gc,phases,start] GC(47) Phase 1: Mark live objects</span><br><span class="line">[0.800s][info   ][gc,phases      ] GC(47) Phase 1: Mark live objects 0.828ms</span><br><span class="line">[0.800s][info   ][gc,phases,start] GC(47) Phase 2: Compute new object addresses</span><br><span class="line">[0.800s][info   ][gc,phases      ] GC(47) Phase 2: Compute new object addresses 0.634ms</span><br><span class="line">[0.801s][info   ][gc,phases,start] GC(47) Phase 3: Adjust pointers</span><br><span class="line">[0.801s][info   ][gc,phases      ] GC(47) Phase 3: Adjust pointers 0.550ms</span><br><span class="line">[0.801s][info   ][gc,phases,start] GC(47) Phase 4: Move objects</span><br><span class="line">[0.812s][info   ][gc,phases      ] GC(47) Phase 4: Move objects 10.607ms</span><br><span class="line">[0.812s][info   ][gc,heap        ] GC(47) DefNew: 157222K(157248K)-&gt;10018K(157248K) Eden: 139776K(139776K)-&gt;10018K(139776K) From: 17446K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.812s][info   ][gc,heap        ] GC(47) Tenured: 349514K(349568K)-&gt;349365K(349568K)</span><br><span class="line">[0.812s][info   ][gc,metaspace   ] GC(47) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.812s][info   ][gc             ] GC(47) Pause Full (Allocation Failure) 494M-&gt;350M(494M) 12.986ms</span><br><span class="line">[0.812s][info   ][gc,cpu         ] GC(47) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.820s][info   ][gc,start       ] GC(48) Pause Full (Allocation Failure)</span><br><span class="line">[0.820s][info   ][gc,phases,start] GC(48) Phase 1: Mark live objects</span><br><span class="line">[0.821s][info   ][gc,phases      ] GC(48) Phase 1: Mark live objects 0.826ms</span><br><span class="line">[0.821s][info   ][gc,phases,start] GC(48) Phase 2: Compute new object addresses</span><br><span class="line">[0.821s][info   ][gc,phases      ] GC(48) Phase 2: Compute new object addresses 0.621ms</span><br><span class="line">[0.821s][info   ][gc,phases,start] GC(48) Phase 3: Adjust pointers</span><br><span class="line">[0.822s][info   ][gc,phases      ] GC(48) Phase 3: Adjust pointers 0.557ms</span><br><span class="line">[0.822s][info   ][gc,phases,start] GC(48) Phase 4: Move objects</span><br><span class="line">[0.833s][info   ][gc,phases      ] GC(48) Phase 4: Move objects 11.102ms</span><br><span class="line">[0.833s][info   ][gc,heap        ] GC(48) DefNew: 156898K(157248K)-&gt;16090K(157248K) Eden: 139776K(139776K)-&gt;16090K(139776K) From: 17122K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.833s][info   ][gc,heap        ] GC(48) Tenured: 349365K(349568K)-&gt;349424K(349568K)</span><br><span class="line">[0.833s][info   ][gc,metaspace   ] GC(48) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.833s][info   ][gc             ] GC(48) Pause Full (Allocation Failure) 494M-&gt;356M(494M) 13.404ms</span><br><span class="line">[0.833s][info   ][gc,cpu         ] GC(48) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.841s][info   ][gc,start       ] GC(49) Pause Full (Allocation Failure)</span><br><span class="line">[0.841s][info   ][gc,phases,start] GC(49) Phase 1: Mark live objects</span><br><span class="line">[0.842s][info   ][gc,phases      ] GC(49) Phase 1: Mark live objects 0.820ms</span><br><span class="line">[0.842s][info   ][gc,phases,start] GC(49) Phase 2: Compute new object addresses</span><br><span class="line">[0.843s][info   ][gc,phases      ] GC(49) Phase 2: Compute new object addresses 0.598ms</span><br><span class="line">[0.843s][info   ][gc,phases,start] GC(49) Phase 3: Adjust pointers</span><br><span class="line">[0.843s][info   ][gc,phases      ] GC(49) Phase 3: Adjust pointers 0.565ms</span><br><span class="line">[0.843s][info   ][gc,phases,start] GC(49) Phase 4: Move objects</span><br><span class="line">[0.856s][info   ][gc,phases      ] GC(49) Phase 4: Move objects 13.026ms</span><br><span class="line">[0.856s][info   ][gc,heap        ] GC(49) DefNew: 157019K(157248K)-&gt;0K(157248K) Eden: 139776K(139776K)-&gt;0K(139776K) From: 17243K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.856s][info   ][gc,heap        ] GC(49) Tenured: 349424K(349568K)-&gt;348902K(349568K)</span><br><span class="line">[0.856s][info   ][gc,metaspace   ] GC(49) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.856s][info   ][gc             ] GC(49) Pause Full (Allocation Failure) 494M-&gt;340M(494M) 15.290ms</span><br><span class="line">[0.856s][info   ][gc,cpu         ] GC(49) User=0.01s Sys=0.00s Real=0.02s</span><br><span class="line">[0.863s][info   ][gc,start       ] GC(50) Pause Young (Allocation Failure)</span><br><span class="line">[0.863s][info   ][gc             ] GC(50) Pause Young (Allocation Failure) 477M-&gt;477M(494M) 0.077ms</span><br><span class="line">[0.863s][info   ][gc,cpu         ] GC(50) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.864s][info   ][gc,start       ] GC(51) Pause Full (Allocation Failure)</span><br><span class="line">[0.864s][info   ][gc,phases,start] GC(51) Phase 1: Mark live objects</span><br><span class="line">[0.864s][info   ][gc,phases      ] GC(51) Phase 1: Mark live objects 0.903ms</span><br><span class="line">[0.864s][info   ][gc,phases,start] GC(51) Phase 2: Compute new object addresses</span><br><span class="line">[0.865s][info   ][gc,phases      ] GC(51) Phase 2: Compute new object addresses 0.601ms</span><br><span class="line">[0.865s][info   ][gc,phases,start] GC(51) Phase 3: Adjust pointers</span><br><span class="line">[0.866s][info   ][gc,phases      ] GC(51) Phase 3: Adjust pointers 0.547ms</span><br><span class="line">[0.866s][info   ][gc,phases,start] GC(51) Phase 4: Move objects</span><br><span class="line">[0.875s][info   ][gc,phases      ] GC(51) Phase 4: Move objects 8.977ms</span><br><span class="line">[0.875s][info   ][gc,heap        ] GC(51) DefNew: 139776K(157248K)-&gt;23562K(157248K) Eden: 139776K(139776K)-&gt;23562K(139776K) From: 0K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.875s][info   ][gc,heap        ] GC(51) Tenured: 348902K(349568K)-&gt;349464K(349568K)</span><br><span class="line">[0.875s][info   ][gc,metaspace   ] GC(51) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.875s][info   ][gc             ] GC(51) Pause Full (Allocation Failure) 477M-&gt;364M(494M) 11.281ms</span><br><span class="line">[0.875s][info   ][gc,cpu         ] GC(51) User=0.01s Sys=0.00s Real=0.02s</span><br><span class="line">[0.882s][info   ][gc,start       ] GC(52) Pause Full (Allocation Failure)</span><br><span class="line">[0.882s][info   ][gc,phases,start] GC(52) Phase 1: Mark live objects</span><br><span class="line">[0.883s][info   ][gc,phases      ] GC(52) Phase 1: Mark live objects 0.917ms</span><br><span class="line">[0.883s][info   ][gc,phases,start] GC(52) Phase 2: Compute new object addresses</span><br><span class="line">[0.883s][info   ][gc,phases      ] GC(52) Phase 2: Compute new object addresses 0.661ms</span><br><span class="line">[0.883s][info   ][gc,phases,start] GC(52) Phase 3: Adjust pointers</span><br><span class="line">[0.884s][info   ][gc,phases      ] GC(52) Phase 3: Adjust pointers 0.584ms</span><br><span class="line">[0.884s][info   ][gc,phases,start] GC(52) Phase 4: Move objects</span><br><span class="line">[0.898s][info   ][gc,phases      ] GC(52) Phase 4: Move objects 13.409ms</span><br><span class="line">[0.898s][info   ][gc,heap        ] GC(52) DefNew: 157156K(157248K)-&gt;25183K(157248K) Eden: 139776K(139776K)-&gt;25183K(139776K) From: 17380K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.898s][info   ][gc,heap        ] GC(52) Tenured: 349464K(349568K)-&gt;349024K(349568K)</span><br><span class="line">[0.898s][info   ][gc,metaspace   ] GC(52) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.898s][info   ][gc             ] GC(52) Pause Full (Allocation Failure) 494M-&gt;365M(494M) 15.926ms</span><br><span class="line">[0.898s][info   ][gc,cpu         ] GC(52) User=0.01s Sys=0.00s Real=0.02s</span><br><span class="line">[0.906s][info   ][gc,start       ] GC(53) Pause Full (Allocation Failure)</span><br><span class="line">[0.906s][info   ][gc,phases,start] GC(53) Phase 1: Mark live objects</span><br><span class="line">[0.907s][info   ][gc,phases      ] GC(53) Phase 1: Mark live objects 0.937ms</span><br><span class="line">[0.907s][info   ][gc,phases,start] GC(53) Phase 2: Compute new object addresses</span><br><span class="line">[0.907s][info   ][gc,phases      ] GC(53) Phase 2: Compute new object addresses 0.613ms</span><br><span class="line">[0.907s][info   ][gc,phases,start] GC(53) Phase 3: Adjust pointers</span><br><span class="line">[0.908s][info   ][gc,phases      ] GC(53) Phase 3: Adjust pointers 0.632ms</span><br><span class="line">[0.908s][info   ][gc,phases,start] GC(53) Phase 4: Move objects</span><br><span class="line">[0.922s][info   ][gc,phases      ] GC(53) Phase 4: Move objects 13.518ms</span><br><span class="line">[0.922s][info   ][gc,heap        ] GC(53) DefNew: 157246K(157248K)-&gt;30369K(157248K) Eden: 139776K(139776K)-&gt;30369K(139776K) From: 17470K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.922s][info   ][gc,heap        ] GC(53) Tenured: 349525K(349568K)-&gt;349346K(349568K)</span><br><span class="line">[0.922s][info   ][gc,metaspace   ] GC(53) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.922s][info   ][gc             ] GC(53) Pause Full (Allocation Failure) 494M-&gt;370M(494M) 16.112ms</span><br><span class="line">[0.922s][info   ][gc,cpu         ] GC(53) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.929s][info   ][gc,start       ] GC(54) Pause Full (Allocation Failure)</span><br><span class="line">[0.929s][info   ][gc,phases,start] GC(54) Phase 1: Mark live objects</span><br><span class="line">[0.930s][info   ][gc,phases      ] GC(54) Phase 1: Mark live objects 0.899ms</span><br><span class="line">[0.930s][info   ][gc,phases,start] GC(54) Phase 2: Compute new object addresses</span><br><span class="line">[0.931s][info   ][gc,phases      ] GC(54) Phase 2: Compute new object addresses 0.544ms</span><br><span class="line">[0.931s][info   ][gc,phases,start] GC(54) Phase 3: Adjust pointers</span><br><span class="line">[0.931s][info   ][gc,phases      ] GC(54) Phase 3: Adjust pointers 0.554ms</span><br><span class="line">[0.931s][info   ][gc,phases,start] GC(54) Phase 4: Move objects</span><br><span class="line">[0.945s][info   ][gc,phases      ] GC(54) Phase 4: Move objects 13.288ms</span><br><span class="line">[0.945s][info   ][gc,heap        ] GC(54) DefNew: 157162K(157248K)-&gt;15434K(157248K) Eden: 139776K(139776K)-&gt;15434K(139776K) From: 17386K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.945s][info   ][gc,heap        ] GC(54) Tenured: 349441K(349568K)-&gt;349541K(349568K)</span><br><span class="line">[0.945s][info   ][gc,metaspace   ] GC(54) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.945s][info   ][gc             ] GC(54) Pause Full (Allocation Failure) 494M-&gt;356M(494M) 16.098ms</span><br><span class="line">[0.945s][info   ][gc,cpu         ] GC(54) User=0.02s Sys=0.00s Real=0.02s</span><br><span class="line">[0.954s][info   ][gc,start       ] GC(55) Pause Full (Allocation Failure)</span><br><span class="line">[0.954s][info   ][gc,phases,start] GC(55) Phase 1: Mark live objects</span><br><span class="line">[0.954s][info   ][gc,phases      ] GC(55) Phase 1: Mark live objects 0.854ms</span><br><span class="line">[0.954s][info   ][gc,phases,start] GC(55) Phase 2: Compute new object addresses</span><br><span class="line">[0.955s][info   ][gc,phases      ] GC(55) Phase 2: Compute new object addresses 0.604ms</span><br><span class="line">[0.955s][info   ][gc,phases,start] GC(55) Phase 3: Adjust pointers</span><br><span class="line">[0.956s][info   ][gc,phases      ] GC(55) Phase 3: Adjust pointers 0.554ms</span><br><span class="line">[0.956s][info   ][gc,phases,start] GC(55) Phase 4: Move objects</span><br><span class="line">[0.965s][info   ][gc,phases      ] GC(55) Phase 4: Move objects 9.673ms</span><br><span class="line">[0.965s][info   ][gc,heap        ] GC(55) DefNew: 156722K(157248K)-&gt;26861K(157248K) Eden: 139776K(139776K)-&gt;26861K(139776K) From: 16946K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.965s][info   ][gc,heap        ] GC(55) Tenured: 349541K(349568K)-&gt;349125K(349568K)</span><br><span class="line">[0.965s][info   ][gc,metaspace   ] GC(55) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.965s][info   ][gc             ] GC(55) Pause Full (Allocation Failure) 494M-&gt;367M(494M) 11.989ms</span><br><span class="line">[0.966s][info   ][gc,cpu         ] GC(55) User=0.02s Sys=0.00s Real=0.02s</span><br><span class="line">[0.972s][info   ][gc,start       ] GC(56) Pause Full (Allocation Failure)</span><br><span class="line">[0.972s][info   ][gc,phases,start] GC(56) Phase 1: Mark live objects</span><br><span class="line">[0.973s][info   ][gc,phases      ] GC(56) Phase 1: Mark live objects 0.788ms</span><br><span class="line">[0.973s][info   ][gc,phases,start] GC(56) Phase 2: Compute new object addresses</span><br><span class="line">[0.974s][info   ][gc,phases      ] GC(56) Phase 2: Compute new object addresses 0.557ms</span><br><span class="line">[0.974s][info   ][gc,phases,start] GC(56) Phase 3: Adjust pointers</span><br><span class="line">[0.974s][info   ][gc,phases      ] GC(56) Phase 3: Adjust pointers 0.557ms</span><br><span class="line">[0.974s][info   ][gc,phases,start] GC(56) Phase 4: Move objects</span><br><span class="line">[0.986s][info   ][gc,phases      ] GC(56) Phase 4: Move objects 11.644ms</span><br><span class="line">[0.986s][info   ][gc,heap        ] GC(56) DefNew: 156826K(157248K)-&gt;26775K(157248K) Eden: 139776K(139776K)-&gt;26775K(139776K) From: 17050K(17472K)-&gt;0K(17472K)</span><br><span class="line">[0.986s][info   ][gc,heap        ] GC(56) Tenured: 349125K(349568K)-&gt;349506K(349568K)</span><br><span class="line">[0.986s][info   ][gc,metaspace   ] GC(56) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.986s][info   ][gc             ] GC(56) Pause Full (Allocation Failure) 494M-&gt;367M(494M) 13.802ms</span><br><span class="line">[0.986s][info   ][gc,cpu         ] GC(56) User=0.02s Sys=0.00s Real=0.02s</span><br><span class="line">[0.993s][info   ][gc,start       ] GC(57) Pause Full (Allocation Failure)</span><br><span class="line">[0.994s][info   ][gc,phases,start] GC(57) Phase 1: Mark live objects</span><br><span class="line">[0.994s][info   ][gc,phases      ] GC(57) Phase 1: Mark live objects 0.843ms</span><br><span class="line">[0.994s][info   ][gc,phases,start] GC(57) Phase 2: Compute new object addresses</span><br><span class="line">[0.995s][info   ][gc,phases      ] GC(57) Phase 2: Compute new object addresses 0.592ms</span><br><span class="line">[0.995s][info   ][gc,phases,start] GC(57) Phase 3: Adjust pointers</span><br><span class="line">[0.996s][info   ][gc,phases      ] GC(57) Phase 3: Adjust pointers 0.566ms</span><br><span class="line">[0.996s][info   ][gc,phases,start] GC(57) Phase 4: Move objects</span><br><span class="line">[1.008s][info   ][gc,phases      ] GC(57) Phase 4: Move objects 12.205ms</span><br><span class="line">[1.008s][info   ][gc,heap        ] GC(57) DefNew: 157232K(157248K)-&gt;28181K(157248K) Eden: 139776K(139776K)-&gt;28181K(139776K) From: 17456K(17472K)-&gt;0K(17472K)</span><br><span class="line">[1.008s][info   ][gc,heap        ] GC(57) Tenured: 349506K(349568K)-&gt;349071K(349568K)</span><br><span class="line">[1.008s][info   ][gc,metaspace   ] GC(57) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.008s][info   ][gc             ] GC(57) Pause Full (Allocation Failure) 494M-&gt;368M(494M) 14.498ms</span><br><span class="line">[1.008s][info   ][gc,cpu         ] GC(57) User=0.02s Sys=0.00s Real=0.02s</span><br><span class="line">[1.015s][info   ][gc,start       ] GC(58) Pause Full (Allocation Failure)</span><br><span class="line">[1.016s][info   ][gc,phases,start] GC(58) Phase 1: Mark live objects</span><br><span class="line">[1.016s][info   ][gc,phases      ] GC(58) Phase 1: Mark live objects 0.831ms</span><br><span class="line">[1.016s][info   ][gc,phases,start] GC(58) Phase 2: Compute new object addresses</span><br><span class="line">[1.017s][info   ][gc,phases      ] GC(58) Phase 2: Compute new object addresses 0.606ms</span><br><span class="line">[1.017s][info   ][gc,phases,start] GC(58) Phase 3: Adjust pointers</span><br><span class="line">[1.018s][info   ][gc,phases      ] GC(58) Phase 3: Adjust pointers 0.553ms</span><br><span class="line">[1.018s][info   ][gc,phases,start] GC(58) Phase 4: Move objects</span><br><span class="line">[1.030s][info   ][gc,phases      ] GC(58) Phase 4: Move objects 12.647ms</span><br><span class="line">[1.030s][info   ][gc,heap        ] GC(58) DefNew: 157242K(157248K)-&gt;8800K(157248K) Eden: 139776K(139776K)-&gt;8800K(139776K) From: 17466K(17472K)-&gt;0K(17472K)</span><br><span class="line">[1.030s][info   ][gc,heap        ] GC(58) Tenured: 349534K(349568K)-&gt;349202K(349568K)</span><br><span class="line">[1.030s][info   ][gc,metaspace   ] GC(58) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.030s][info   ][gc             ] GC(58) Pause Full (Allocation Failure) 494M-&gt;349M(494M) 14.913ms</span><br><span class="line">[1.030s][info   ][gc,cpu         ] GC(58) User=0.02s Sys=0.00s Real=0.01s</span><br><span class="line">counter:30528</span><br><span class="line">[1.037s][info   ][gc,heap,exit   ] Heap</span><br><span class="line">[1.037s][info   ][gc,heap,exit   ]  def new generation   total 157248K, used 14321K [0x00000007e0000000, 0x00000007eaaa0000, 0x00000007eaaa0000)</span><br><span class="line">[1.037s][info   ][gc,heap,exit   ]   eden space 139776K,  10% used [0x00000007e0000000, 0x00000007e0dfc490, 0x00000007e8880000)</span><br><span class="line">[1.037s][info   ][gc,heap,exit   ]   from space 17472K,   0% used [0x00000007e8880000, 0x00000007e8880000, 0x00000007e9990000)</span><br><span class="line">[1.037s][info   ][gc,heap,exit   ]   to   space 17472K,   0% used [0x00000007e9990000, 0x00000007e9990000, 0x00000007eaaa0000)</span><br><span class="line">[1.037s][info   ][gc,heap,exit   ]  tenured generation   total 349568K, used 349202K [0x00000007eaaa0000, 0x0000000800000000, 0x0000000800000000)</span><br><span class="line">[1.037s][info   ][gc,heap,exit   ]    the space 349568K,  99% used [0x00000007eaaa0000, 0x00000007fffa4a88, 0x00000007fffa4c00, 0x0000000800000000)</span><br><span class="line">[1.037s][info   ][gc,heap,exit   ]  Metaspace       used 233K, committed 448K, reserved 1114112K</span><br><span class="line">[1.037s][info   ][gc,heap,exit   ]   class space    used 9K, committed 128K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>再试试1G内存呢</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+UseSerialGC -Xms1g -Xmx1g -XX:+PrintGCDetails -Xlog:gc\*:file=gc.log:time,uptime,level,tags GCLogAnalysis</span><br></pre></td></tr></table></figure>

<p>可以看到GC次数大大减少，效率提升，512m的时候生成了30000多个对象，1g的时候生成了33000多个对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0.008s][warning][gc] -XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.</span><br><span class="line">[0.013s][info   ][gc,init] CardTable entry size: 512</span><br><span class="line">[0.013s][info   ][gc     ] Using Serial</span><br><span class="line">[0.013s][info   ][gc,init] Version: 19.0.2+7-44 (release)</span><br><span class="line">[0.013s][info   ][gc,init] CPUs: 8 total, 8 available</span><br><span class="line">[0.013s][info   ][gc,init] Memory: 16384M</span><br><span class="line">[0.013s][info   ][gc,init] Large Page Support: Disabled</span><br><span class="line">[0.013s][info   ][gc,init] NUMA Support: Disabled</span><br><span class="line">[0.014s][info   ][gc,init] Compressed Oops: Enabled (Zero based)</span><br><span class="line">[0.014s][info   ][gc,init] Heap Min Capacity: 1G</span><br><span class="line">[0.014s][info   ][gc,init] Heap Initial Capacity: 1G</span><br><span class="line">[0.014s][info   ][gc,init] Heap Max Capacity: 1G</span><br><span class="line">[0.014s][info   ][gc,init] Pre-touch: Disabled</span><br><span class="line">[0.014s][info   ][gc,metaspace] CDS archive(s) mapped at: [0x0000000800000000-0x0000000800c44000-0x0000000800c44000), size 12861440, SharedBaseAddress: 0x0000000800000000, ArchiveRelocationMode: 0.</span><br><span class="line">[0.014s][info   ][gc,metaspace] Compressed class space mapped at: 0x0000000801000000-0x0000000841000000, reserved size: 1073741824</span><br><span class="line">[0.014s][info   ][gc,metaspace] Narrow klass base: 0x0000000800000000, Narrow klass shift: 0, Narrow klass range: 0x100000000</span><br><span class="line">gc...</span><br><span class="line">[0.135s][info   ][gc,start    ] GC(0) Pause Young (Allocation Failure)</span><br><span class="line">[0.188s][info   ][gc,heap     ] GC(0) DefNew: 279616K(314560K)-&gt;34944K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 0K(34944K)-&gt;34944K(34944K)</span><br><span class="line">[0.188s][info   ][gc,heap     ] GC(0) Tenured: 992K(699072K)-&gt;51147K(699072K)</span><br><span class="line">[0.189s][info   ][gc,metaspace] GC(0) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.189s][info   ][gc          ] GC(0) Pause Young (Allocation Failure) 274M-&gt;84M(989M) 53.599ms</span><br><span class="line">[0.189s][info   ][gc,cpu      ] GC(0) User=0.01s Sys=0.02s Real=0.06s</span><br><span class="line">[0.219s][info   ][gc,start    ] GC(1) Pause Young (Allocation Failure)</span><br><span class="line">[0.240s][info   ][gc,heap     ] GC(1) DefNew: 314560K(314560K)-&gt;34943K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 34944K(34944K)-&gt;34943K(34944K)</span><br><span class="line">[0.240s][info   ][gc,heap     ] GC(1) Tenured: 51147K(699072K)-&gt;141144K(699072K)</span><br><span class="line">[0.240s][info   ][gc,metaspace] GC(1) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.240s][info   ][gc          ] GC(1) Pause Young (Allocation Failure) 357M-&gt;171M(989M) 21.714ms</span><br><span class="line">[0.240s][info   ][gc,cpu      ] GC(1) User=0.00s Sys=0.01s Real=0.02s</span><br><span class="line">[0.255s][info   ][gc,start    ] GC(2) Pause Young (Allocation Failure)</span><br><span class="line">[0.307s][info   ][gc,heap     ] GC(2) DefNew: 314559K(314560K)-&gt;34943K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 34943K(34944K)-&gt;34943K(34944K)</span><br><span class="line">[0.307s][info   ][gc,heap     ] GC(2) Tenured: 141144K(699072K)-&gt;242755K(699072K)</span><br><span class="line">[0.307s][info   ][gc,metaspace] GC(2) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.307s][info   ][gc          ] GC(2) Pause Young (Allocation Failure) 445M-&gt;271M(989M) 51.781ms</span><br><span class="line">[0.307s][info   ][gc,cpu      ] GC(2) User=0.01s Sys=0.01s Real=0.06s</span><br><span class="line">[0.324s][info   ][gc,start    ] GC(3) Pause Young (Allocation Failure)</span><br><span class="line">[0.340s][info   ][gc,heap     ] GC(3) DefNew: 314559K(314560K)-&gt;34943K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 34943K(34944K)-&gt;34943K(34944K)</span><br><span class="line">[0.340s][info   ][gc,heap     ] GC(3) Tenured: 242755K(699072K)-&gt;320838K(699072K)</span><br><span class="line">[0.340s][info   ][gc,metaspace] GC(3) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.340s][info   ][gc          ] GC(3) Pause Young (Allocation Failure) 544M-&gt;347M(989M) 15.604ms</span><br><span class="line">[0.340s][info   ][gc,cpu      ] GC(3) User=0.01s Sys=0.01s Real=0.02s</span><br><span class="line">[0.356s][info   ][gc,start    ] GC(4) Pause Young (Allocation Failure)</span><br><span class="line">[0.373s][info   ][gc,heap     ] GC(4) DefNew: 314559K(314560K)-&gt;34943K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 34943K(34944K)-&gt;34943K(34944K)</span><br><span class="line">[0.373s][info   ][gc,heap     ] GC(4) Tenured: 320838K(699072K)-&gt;407917K(699072K)</span><br><span class="line">[0.373s][info   ][gc,metaspace] GC(4) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.373s][info   ][gc          ] GC(4) Pause Young (Allocation Failure) 620M-&gt;432M(989M) 17.074ms</span><br><span class="line">[0.373s][info   ][gc,cpu      ] GC(4) User=0.00s Sys=0.01s Real=0.01s</span><br><span class="line">[0.401s][info   ][gc,start    ] GC(5) Pause Young (Allocation Failure)</span><br><span class="line">[0.440s][info   ][gc,heap     ] GC(5) DefNew: 314559K(314560K)-&gt;34943K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 34943K(34944K)-&gt;34943K(34944K)</span><br><span class="line">[0.441s][info   ][gc,heap     ] GC(5) Tenured: 407917K(699072K)-&gt;492748K(699072K)</span><br><span class="line">[0.441s][info   ][gc,metaspace] GC(5) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.441s][info   ][gc          ] GC(5) Pause Young (Allocation Failure) 705M-&gt;515M(989M) 39.247ms</span><br><span class="line">[0.441s][info   ][gc,cpu      ] GC(5) User=0.00s Sys=0.01s Real=0.04s</span><br><span class="line">[0.460s][info   ][gc,start    ] GC(6) Pause Young (Allocation Failure)</span><br><span class="line">[0.480s][info   ][gc,heap     ] GC(6) DefNew: 314559K(314560K)-&gt;34943K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 34943K(34944K)-&gt;34943K(34944K)</span><br><span class="line">[0.480s][info   ][gc,heap     ] GC(6) Tenured: 492748K(699072K)-&gt;586536K(699072K)</span><br><span class="line">[0.480s][info   ][gc,metaspace] GC(6) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.480s][info   ][gc          ] GC(6) Pause Young (Allocation Failure) 788M-&gt;606M(989M) 20.249ms</span><br><span class="line">[0.480s][info   ][gc,cpu      ] GC(6) User=0.01s Sys=0.01s Real=0.02s</span><br><span class="line">[0.500s][info   ][gc,start    ] GC(7) Pause Young (Allocation Failure)</span><br><span class="line">[0.512s][info   ][gc,heap     ] GC(7) DefNew: 314559K(314560K)-&gt;34943K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 34943K(34944K)-&gt;34943K(34944K)</span><br><span class="line">[0.512s][info   ][gc,heap     ] GC(7) Tenured: 586536K(699072K)-&gt;665345K(699072K)</span><br><span class="line">[0.512s][info   ][gc,metaspace] GC(7) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.512s][info   ][gc          ] GC(7) Pause Young (Allocation Failure) 879M-&gt;683M(989M) 12.727ms</span><br><span class="line">[0.512s][info   ][gc,cpu      ] GC(7) User=0.01s Sys=0.01s Real=0.01s</span><br><span class="line">[0.566s][info   ][gc,start    ] GC(8) Pause Young (Allocation Failure)</span><br><span class="line">[0.566s][info   ][gc          ] GC(8) Pause Young (Allocation Failure) 956M-&gt;956M(989M) 0.081ms</span><br><span class="line">[0.566s][info   ][gc,cpu      ] GC(8) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.566s][info   ][gc,start    ] GC(9) Pause Full (Allocation Failure)</span><br><span class="line">[0.566s][info   ][gc,phases,start] GC(9) Phase 1: Mark live objects</span><br><span class="line">[0.568s][info   ][gc,phases      ] GC(9) Phase 1: Mark live objects 1.876ms</span><br><span class="line">[0.568s][info   ][gc,phases,start] GC(9) Phase 2: Compute new object addresses</span><br><span class="line">[0.572s][info   ][gc,phases      ] GC(9) Phase 2: Compute new object addresses 4.283ms</span><br><span class="line">[0.572s][info   ][gc,phases,start] GC(9) Phase 3: Adjust pointers</span><br><span class="line">[0.573s][info   ][gc,phases      ] GC(9) Phase 3: Adjust pointers 0.796ms</span><br><span class="line">[0.573s][info   ][gc,phases,start] GC(9) Phase 4: Move objects</span><br><span class="line">[0.620s][info   ][gc,phases      ] GC(9) Phase 4: Move objects 46.776ms</span><br><span class="line">[0.620s][info   ][gc,heap        ] GC(9) DefNew: 314559K(314560K)-&gt;0K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 34943K(34944K)-&gt;0K(34944K)</span><br><span class="line">[0.620s][info   ][gc,heap        ] GC(9) Tenured: 665345K(699072K)-&gt;365197K(699072K)</span><br><span class="line">[0.620s][info   ][gc,metaspace   ] GC(9) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.620s][info   ][gc             ] GC(9) Pause Full (Allocation Failure) 956M-&gt;356M(989M) 54.196ms</span><br><span class="line">[0.620s][info   ][gc,cpu         ] GC(9) User=0.02s Sys=0.03s Real=0.05s</span><br><span class="line">[0.640s][info   ][gc,start       ] GC(10) Pause Young (Allocation Failure)</span><br><span class="line">[0.647s][info   ][gc,heap        ] GC(10) DefNew: 279616K(314560K)-&gt;34943K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 0K(34944K)-&gt;34943K(34944K)</span><br><span class="line">[0.648s][info   ][gc,heap        ] GC(10) Tenured: 365197K(699072K)-&gt;432245K(699072K)</span><br><span class="line">[0.648s][info   ][gc,metaspace   ] GC(10) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.648s][info   ][gc             ] GC(10) Pause Young (Allocation Failure) 629M-&gt;456M(989M) 7.406ms</span><br><span class="line">[0.648s][info   ][gc,cpu         ] GC(10) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.664s][info   ][gc,start       ] GC(11) Pause Young (Allocation Failure)</span><br><span class="line">[0.672s][info   ][gc,heap        ] GC(11) DefNew: 314559K(314560K)-&gt;34943K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 34943K(34944K)-&gt;34943K(34944K)</span><br><span class="line">[0.672s][info   ][gc,heap        ] GC(11) Tenured: 432245K(699072K)-&gt;519962K(699072K)</span><br><span class="line">[0.672s][info   ][gc,metaspace   ] GC(11) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.672s][info   ][gc             ] GC(11) Pause Young (Allocation Failure) 729M-&gt;541M(989M) 8.206ms</span><br><span class="line">[0.672s][info   ][gc,cpu         ] GC(11) User=0.00s Sys=0.01s Real=0.01s</span><br><span class="line">[0.688s][info   ][gc,start       ] GC(12) Pause Young (Allocation Failure)</span><br><span class="line">[0.695s][info   ][gc,heap        ] GC(12) DefNew: 314559K(314560K)-&gt;34942K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 34943K(34944K)-&gt;34942K(34944K)</span><br><span class="line">[0.695s][info   ][gc,heap        ] GC(12) Tenured: 519962K(699072K)-&gt;607219K(699072K)</span><br><span class="line">[0.695s][info   ][gc,metaspace   ] GC(12) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.695s][info   ][gc             ] GC(12) Pause Young (Allocation Failure) 814M-&gt;627M(989M) 7.465ms</span><br><span class="line">[0.695s][info   ][gc,cpu         ] GC(12) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.710s][info   ][gc,start       ] GC(13) Pause Young (Allocation Failure)</span><br><span class="line">[0.710s][info   ][gc             ] GC(13) Pause Young (Allocation Failure) 900M-&gt;900M(989M) 0.080ms</span><br><span class="line">[0.710s][info   ][gc,cpu         ] GC(13) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.710s][info   ][gc,start       ] GC(14) Pause Full (Allocation Failure)</span><br><span class="line">[0.710s][info   ][gc,phases,start] GC(14) Phase 1: Mark live objects</span><br><span class="line">[0.711s][info   ][gc,phases      ] GC(14) Phase 1: Mark live objects 0.829ms</span><br><span class="line">[0.711s][info   ][gc,phases,start] GC(14) Phase 2: Compute new object addresses</span><br><span class="line">[0.712s][info   ][gc,phases      ] GC(14) Phase 2: Compute new object addresses 1.122ms</span><br><span class="line">[0.712s][info   ][gc,phases,start] GC(14) Phase 3: Adjust pointers</span><br><span class="line">[0.713s][info   ][gc,phases      ] GC(14) Phase 3: Adjust pointers 0.564ms</span><br><span class="line">[0.713s][info   ][gc,phases,start] GC(14) Phase 4: Move objects</span><br><span class="line">[0.727s][info   ][gc,phases      ] GC(14) Phase 4: Move objects 14.587ms</span><br><span class="line">[0.727s][info   ][gc,heap        ] GC(14) DefNew: 314558K(314560K)-&gt;0K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 34942K(34944K)-&gt;0K(34944K)</span><br><span class="line">[0.727s][info   ][gc,heap        ] GC(14) Tenured: 607219K(699072K)-&gt;377979K(699072K)</span><br><span class="line">[0.727s][info   ][gc,metaspace   ] GC(14) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.727s][info   ][gc             ] GC(14) Pause Full (Allocation Failure) 900M-&gt;369M(989M) 17.364ms</span><br><span class="line">[0.727s][info   ][gc,cpu         ] GC(14) User=0.01s Sys=0.00s Real=0.02s</span><br><span class="line">[0.742s][info   ][gc,start       ] GC(15) Pause Young (Allocation Failure)</span><br><span class="line">[0.747s][info   ][gc,heap        ] GC(15) DefNew: 279616K(314560K)-&gt;34943K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 0K(34944K)-&gt;34943K(34944K)</span><br><span class="line">[0.748s][info   ][gc,heap        ] GC(15) Tenured: 377979K(699072K)-&gt;443461K(699072K)</span><br><span class="line">[0.748s][info   ][gc,metaspace   ] GC(15) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.748s][info   ][gc             ] GC(15) Pause Young (Allocation Failure) 642M-&gt;467M(989M) 5.446ms</span><br><span class="line">[0.748s][info   ][gc,cpu         ] GC(15) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">[0.764s][info   ][gc,start       ] GC(16) Pause Young (Allocation Failure)</span><br><span class="line">[0.769s][info   ][gc,heap        ] GC(16) DefNew: 314559K(314560K)-&gt;34943K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 34943K(34944K)-&gt;34943K(34944K)</span><br><span class="line">[0.770s][info   ][gc,heap        ] GC(16) Tenured: 443461K(699072K)-&gt;538072K(699072K)</span><br><span class="line">[0.770s][info   ][gc,metaspace   ] GC(16) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.770s][info   ][gc             ] GC(16) Pause Young (Allocation Failure) 740M-&gt;559M(989M) 5.349ms</span><br><span class="line">[0.770s][info   ][gc,cpu         ] GC(16) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">[0.787s][info   ][gc,start       ] GC(17) Pause Young (Allocation Failure)</span><br><span class="line">[0.793s][info   ][gc,heap        ] GC(17) DefNew: 314559K(314560K)-&gt;34942K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 34943K(34944K)-&gt;34942K(34944K)</span><br><span class="line">[0.793s][info   ][gc,heap        ] GC(17) Tenured: 538072K(699072K)-&gt;623620K(699072K)</span><br><span class="line">[0.793s][info   ][gc,metaspace   ] GC(17) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.795s][info   ][gc             ] GC(17) Pause Young (Allocation Failure) 832M-&gt;643M(989M) 7.911ms</span><br><span class="line">[0.795s][info   ][gc,cpu         ] GC(17) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.812s][info   ][gc,start       ] GC(18) Pause Young (Allocation Failure)</span><br><span class="line">[0.812s][info   ][gc             ] GC(18) Pause Young (Allocation Failure) 916M-&gt;916M(989M) 0.057ms</span><br><span class="line">[0.812s][info   ][gc,cpu         ] GC(18) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.812s][info   ][gc,start       ] GC(19) Pause Full (Allocation Failure)</span><br><span class="line">[0.812s][info   ][gc,phases,start] GC(19) Phase 1: Mark live objects</span><br><span class="line">[0.813s][info   ][gc,phases      ] GC(19) Phase 1: Mark live objects 0.855ms</span><br><span class="line">[0.813s][info   ][gc,phases,start] GC(19) Phase 2: Compute new object addresses</span><br><span class="line">[0.814s][info   ][gc,phases      ] GC(19) Phase 2: Compute new object addresses 1.188ms</span><br><span class="line">[0.814s][info   ][gc,phases,start] GC(19) Phase 3: Adjust pointers</span><br><span class="line">[0.815s][info   ][gc,phases      ] GC(19) Phase 3: Adjust pointers 0.566ms</span><br><span class="line">[0.815s][info   ][gc,phases,start] GC(19) Phase 4: Move objects</span><br><span class="line">[0.827s][info   ][gc,phases      ] GC(19) Phase 4: Move objects 12.398ms</span><br><span class="line">[0.828s][info   ][gc,heap        ] GC(19) DefNew: 314558K(314560K)-&gt;0K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 34942K(34944K)-&gt;0K(34944K)</span><br><span class="line">[0.828s][info   ][gc,heap        ] GC(19) Tenured: 623620K(699072K)-&gt;383627K(699072K)</span><br><span class="line">[0.828s][info   ][gc,metaspace   ] GC(19) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.828s][info   ][gc             ] GC(19) Pause Full (Allocation Failure) 916M-&gt;374M(989M) 15.248ms</span><br><span class="line">[0.828s][info   ][gc,cpu         ] GC(19) User=0.02s Sys=0.00s Real=0.02s</span><br><span class="line">[0.843s][info   ][gc,start       ] GC(20) Pause Young (Allocation Failure)</span><br><span class="line">[0.847s][info   ][gc,heap        ] GC(20) DefNew: 279616K(314560K)-&gt;34944K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 0K(34944K)-&gt;34944K(34944K)</span><br><span class="line">[0.847s][info   ][gc,heap        ] GC(20) Tenured: 383627K(699072K)-&gt;441402K(699072K)</span><br><span class="line">[0.847s][info   ][gc,metaspace   ] GC(20) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.847s][info   ][gc             ] GC(20) Pause Young (Allocation Failure) 647M-&gt;465M(989M) 4.018ms</span><br><span class="line">[0.847s][info   ][gc,cpu         ] GC(20) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.862s][info   ][gc,start       ] GC(21) Pause Young (Allocation Failure)</span><br><span class="line">[0.867s][info   ][gc,heap        ] GC(21) DefNew: 314077K(314560K)-&gt;34943K(314560K) Eden: 279133K(279616K)-&gt;0K(279616K) From: 34944K(34944K)-&gt;34943K(34944K)</span><br><span class="line">[0.867s][info   ][gc,heap        ] GC(21) Tenured: 441402K(699072K)-&gt;529351K(699072K)</span><br><span class="line">[0.867s][info   ][gc,metaspace   ] GC(21) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.867s][info   ][gc             ] GC(21) Pause Young (Allocation Failure) 737M-&gt;551M(989M) 5.370ms</span><br><span class="line">[0.867s][info   ][gc,cpu         ] GC(21) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.881s][info   ][gc,start       ] GC(22) Pause Young (Allocation Failure)</span><br><span class="line">[0.887s][info   ][gc,heap        ] GC(22) DefNew: 314559K(314560K)-&gt;34943K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 34943K(34944K)-&gt;34943K(34944K)</span><br><span class="line">[0.887s][info   ][gc,heap        ] GC(22) Tenured: 529351K(699072K)-&gt;627351K(699072K)</span><br><span class="line">[0.887s][info   ][gc,metaspace   ] GC(22) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.887s][info   ][gc             ] GC(22) Pause Young (Allocation Failure) 824M-&gt;646M(989M) 5.647ms</span><br><span class="line">[0.887s][info   ][gc,cpu         ] GC(22) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.902s][info   ][gc,start       ] GC(23) Pause Young (Allocation Failure)</span><br><span class="line">[0.902s][info   ][gc             ] GC(23) Pause Young (Allocation Failure) 919M-&gt;919M(989M) 0.079ms</span><br><span class="line">[0.902s][info   ][gc,cpu         ] GC(23) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.902s][info   ][gc,start       ] GC(24) Pause Full (Allocation Failure)</span><br><span class="line">[0.902s][info   ][gc,phases,start] GC(24) Phase 1: Mark live objects</span><br><span class="line">[0.903s][info   ][gc,phases      ] GC(24) Phase 1: Mark live objects 0.983ms</span><br><span class="line">[0.903s][info   ][gc,phases,start] GC(24) Phase 2: Compute new object addresses</span><br><span class="line">[0.904s][info   ][gc,phases      ] GC(24) Phase 2: Compute new object addresses 1.191ms</span><br><span class="line">[0.904s][info   ][gc,phases,start] GC(24) Phase 3: Adjust pointers</span><br><span class="line">[0.905s][info   ][gc,phases      ] GC(24) Phase 3: Adjust pointers 0.629ms</span><br><span class="line">[0.905s][info   ][gc,phases,start] GC(24) Phase 4: Move objects</span><br><span class="line">[0.921s][info   ][gc,phases      ] GC(24) Phase 4: Move objects 16.387ms</span><br><span class="line">[0.921s][info   ][gc,heap        ] GC(24) DefNew: 314559K(314560K)-&gt;0K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 34943K(34944K)-&gt;0K(34944K)</span><br><span class="line">[0.921s][info   ][gc,heap        ] GC(24) Tenured: 627351K(699072K)-&gt;366208K(699072K)</span><br><span class="line">[0.921s][info   ][gc,metaspace   ] GC(24) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.921s][info   ][gc             ] GC(24) Pause Full (Allocation Failure) 919M-&gt;357M(989M) 19.686ms</span><br><span class="line">[0.921s][info   ][gc,cpu         ] GC(24) User=0.02s Sys=0.00s Real=0.02s</span><br><span class="line">[0.937s][info   ][gc,start       ] GC(25) Pause Young (Allocation Failure)</span><br><span class="line">[0.942s][info   ][gc,heap        ] GC(25) DefNew: 279616K(314560K)-&gt;34943K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 0K(34944K)-&gt;34943K(34944K)</span><br><span class="line">[0.942s][info   ][gc,heap        ] GC(25) Tenured: 366208K(699072K)-&gt;427626K(699072K)</span><br><span class="line">[0.942s][info   ][gc,metaspace   ] GC(25) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.942s][info   ][gc             ] GC(25) Pause Young (Allocation Failure) 630M-&gt;451M(989M) 5.413ms</span><br><span class="line">[0.942s][info   ][gc,cpu         ] GC(25) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.957s][info   ][gc,start       ] GC(26) Pause Young (Allocation Failure)</span><br><span class="line">[0.962s][info   ][gc,heap        ] GC(26) DefNew: 314559K(314560K)-&gt;34943K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 34943K(34944K)-&gt;34943K(34944K)</span><br><span class="line">[0.962s][info   ][gc,heap        ] GC(26) Tenured: 427626K(699072K)-&gt;508828K(699072K)</span><br><span class="line">[0.962s][info   ][gc,metaspace   ] GC(26) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.962s][info   ][gc             ] GC(26) Pause Young (Allocation Failure) 724M-&gt;531M(989M) 5.551ms</span><br><span class="line">[0.962s][info   ][gc,cpu         ] GC(26) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.978s][info   ][gc,start       ] GC(27) Pause Young (Allocation Failure)</span><br><span class="line">[0.985s][info   ][gc,heap        ] GC(27) DefNew: 314559K(314560K)-&gt;34943K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 34943K(34944K)-&gt;34943K(34944K)</span><br><span class="line">[0.985s][info   ][gc,heap        ] GC(27) Tenured: 508828K(699072K)-&gt;598561K(699072K)</span><br><span class="line">[0.985s][info   ][gc,metaspace   ] GC(27) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.985s][info   ][gc             ] GC(27) Pause Young (Allocation Failure) 804M-&gt;618M(989M) 6.823ms</span><br><span class="line">[0.985s][info   ][gc,cpu         ] GC(27) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[1.000s][info   ][gc,start       ] GC(28) Pause Young (Allocation Failure)</span><br><span class="line">[1.000s][info   ][gc             ] GC(28) Pause Young (Allocation Failure) 891M-&gt;891M(989M) 0.078ms</span><br><span class="line">[1.000s][info   ][gc,cpu         ] GC(28) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[1.000s][info   ][gc,start       ] GC(29) Pause Full (Allocation Failure)</span><br><span class="line">[1.000s][info   ][gc,phases,start] GC(29) Phase 1: Mark live objects</span><br><span class="line">[1.001s][info   ][gc,phases      ] GC(29) Phase 1: Mark live objects 0.884ms</span><br><span class="line">[1.001s][info   ][gc,phases,start] GC(29) Phase 2: Compute new object addresses</span><br><span class="line">[1.002s][info   ][gc,phases      ] GC(29) Phase 2: Compute new object addresses 1.359ms</span><br><span class="line">[1.002s][info   ][gc,phases,start] GC(29) Phase 3: Adjust pointers</span><br><span class="line">[1.003s][info   ][gc,phases      ] GC(29) Phase 3: Adjust pointers 0.875ms</span><br><span class="line">[1.003s][info   ][gc,phases,start] GC(29) Phase 4: Move objects</span><br><span class="line">[1.016s][info   ][gc,phases      ] GC(29) Phase 4: Move objects 13.026ms</span><br><span class="line">[1.016s][info   ][gc,heap        ] GC(29) DefNew: 314559K(314560K)-&gt;0K(314560K) Eden: 279616K(279616K)-&gt;0K(279616K) From: 34943K(34944K)-&gt;0K(34944K)</span><br><span class="line">[1.016s][info   ][gc,heap        ] GC(29) Tenured: 598561K(699072K)-&gt;385239K(699072K)</span><br><span class="line">[1.016s][info   ][gc,metaspace   ] GC(29) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.016s][info   ][gc             ] GC(29) Pause Full (Allocation Failure) 891M-&gt;376M(989M) 16.473ms</span><br><span class="line">[1.016s][info   ][gc,cpu         ] GC(29) User=0.02s Sys=0.00s Real=0.02s</span><br><span class="line">counter:33659</span><br><span class="line">[1.040s][info   ][gc,heap,exit   ] Heap</span><br><span class="line">[1.040s][info   ][gc,heap,exit   ]  def new generation   total 314560K, used 279616K [0x00000007c0000000, 0x00000007d5550000, 0x00000007d5550000)</span><br><span class="line">[1.040s][info   ][gc,heap,exit   ]   eden space 279616K, 100% used [0x00000007c0000000, 0x00000007d1110000, 0x00000007d1110000)</span><br><span class="line">[1.040s][info   ][gc,heap,exit   ]   from space 34944K,   0% used [0x00000007d1110000, 0x00000007d1110000, 0x00000007d3330000)</span><br><span class="line">[1.040s][info   ][gc,heap,exit   ]   to   space 34944K,   0% used [0x00000007d3330000, 0x00000007d3330000, 0x00000007d5550000)</span><br><span class="line">[1.040s][info   ][gc,heap,exit   ]  tenured generation   total 699072K, used 385239K [0x00000007d5550000, 0x0000000800000000, 0x0000000800000000)</span><br><span class="line">[1.040s][info   ][gc,heap,exit   ]    the space 699072K,  55% used [0x00000007d5550000, 0x00000007ecd85fa8, 0x00000007ecd86000, 0x0000000800000000)</span><br><span class="line">[1.040s][info   ][gc,heap,exit   ]  Metaspace       used 236K, committed 448K, reserved 1114112K</span><br><span class="line">[1.040s][info   ][gc,heap,exit   ]   class space    used 9K, committed 128K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>接下来试试2g内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+UseSerialGC -Xms2g -Xmx2g -XX:+PrintGCDetails -Xlog:gc\*:file=gc.log:time,uptime,level,tags GCLogAnalysis</span><br></pre></td></tr></table></figure>

<p>可以看到GC次数减少了一半，生成了36000多个对象。性能再次提升</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0.001s][warning][gc] -XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.</span><br><span class="line">[0.005s][info   ][gc,init] CardTable entry size: 512</span><br><span class="line">[0.005s][info   ][gc     ] Using Serial</span><br><span class="line">[0.006s][info   ][gc,init] Version: 19.0.2+7-44 (release)</span><br><span class="line">[0.006s][info   ][gc,init] CPUs: 8 total, 8 available</span><br><span class="line">[0.006s][info   ][gc,init] Memory: 16384M</span><br><span class="line">[0.006s][info   ][gc,init] Large Page Support: Disabled</span><br><span class="line">[0.006s][info   ][gc,init] NUMA Support: Disabled</span><br><span class="line">[0.006s][info   ][gc,init] Compressed Oops: Enabled (Zero based)</span><br><span class="line">[0.006s][info   ][gc,init] Heap Min Capacity: 2G</span><br><span class="line">[0.006s][info   ][gc,init] Heap Initial Capacity: 2G</span><br><span class="line">[0.006s][info   ][gc,init] Heap Max Capacity: 2G</span><br><span class="line">[0.006s][info   ][gc,init] Pre-touch: Disabled</span><br><span class="line">[0.006s][info   ][gc,metaspace] CDS archive(s) mapped at: [0x0000000800000000-0x0000000800c44000-0x0000000800c44000), size 12861440, SharedBaseAddress: 0x0000000800000000, ArchiveRelocationMode: 0.</span><br><span class="line">[0.006s][info   ][gc,metaspace] Compressed class space mapped at: 0x0000000801000000-0x0000000841000000, reserved size: 1073741824</span><br><span class="line">[0.006s][info   ][gc,metaspace] Narrow klass base: 0x0000000800000000, Narrow klass shift: 0, Narrow klass range: 0x100000000</span><br><span class="line">gc...</span><br><span class="line">[0.101s][info   ][gc,start    ] GC(0) Pause Young (Allocation Failure)</span><br><span class="line">[0.122s][info   ][gc,heap     ] GC(0) DefNew: 559232K(629120K)-&gt;69888K(629120K) Eden: 559232K(559232K)-&gt;0K(559232K) From: 0K(69888K)-&gt;69888K(69888K)</span><br><span class="line">[0.122s][info   ][gc,heap     ] GC(0) Tenured: 992K(1398144K)-&gt;99229K(1398144K)</span><br><span class="line">[0.122s][info   ][gc,metaspace] GC(0) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.122s][info   ][gc          ] GC(0) Pause Young (Allocation Failure) 547M-&gt;165M(1979M) 21.143ms</span><br><span class="line">[0.122s][info   ][gc,cpu      ] GC(0) User=0.01s Sys=0.01s Real=0.02s</span><br><span class="line">[0.157s][info   ][gc,start    ] GC(1) Pause Young (Allocation Failure)</span><br><span class="line">[0.181s][info   ][gc,heap     ] GC(1) DefNew: 629120K(629120K)-&gt;69887K(629120K) Eden: 559232K(559232K)-&gt;0K(559232K) From: 69888K(69888K)-&gt;69887K(69888K)</span><br><span class="line">[0.181s][info   ][gc,heap     ] GC(1) Tenured: 99229K(1398144K)-&gt;226904K(1398144K)</span><br><span class="line">[0.181s][info   ][gc,metaspace] GC(1) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.181s][info   ][gc          ] GC(1) Pause Young (Allocation Failure) 711M-&gt;289M(1979M) 24.433ms</span><br><span class="line">[0.181s][info   ][gc,cpu      ] GC(1) User=0.01s Sys=0.01s Real=0.03s</span><br><span class="line">[0.216s][info   ][gc,start    ] GC(2) Pause Young (Allocation Failure)</span><br><span class="line">[0.236s][info   ][gc,heap     ] GC(2) DefNew: 629119K(629120K)-&gt;69887K(629120K) Eden: 559232K(559232K)-&gt;0K(559232K) From: 69887K(69888K)-&gt;69887K(69888K)</span><br><span class="line">[0.236s][info   ][gc,heap     ] GC(2) Tenured: 226904K(1398144K)-&gt;371886K(1398144K)</span><br><span class="line">[0.236s][info   ][gc,metaspace] GC(2) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.236s][info   ][gc          ] GC(2) Pause Young (Allocation Failure) 835M-&gt;431M(1979M) 20.184ms</span><br><span class="line">[0.236s][info   ][gc,cpu      ] GC(2) User=0.01s Sys=0.01s Real=0.02s</span><br><span class="line">[0.268s][info   ][gc,start    ] GC(3) Pause Young (Allocation Failure)</span><br><span class="line">[0.300s][info   ][gc,heap     ] GC(3) DefNew: 629119K(629120K)-&gt;69887K(629120K) Eden: 559232K(559232K)-&gt;0K(559232K) From: 69887K(69888K)-&gt;69887K(69888K)</span><br><span class="line">[0.300s][info   ][gc,heap     ] GC(3) Tenured: 371886K(1398144K)-&gt;506536K(1398144K)</span><br><span class="line">[0.300s][info   ][gc,metaspace] GC(3) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.300s][info   ][gc          ] GC(3) Pause Young (Allocation Failure) 977M-&gt;562M(1979M) 32.214ms</span><br><span class="line">[0.301s][info   ][gc,cpu      ] GC(3) User=0.01s Sys=0.02s Real=0.04s</span><br><span class="line">[0.330s][info   ][gc,start    ] GC(4) Pause Young (Allocation Failure)</span><br><span class="line">[0.361s][info   ][gc,heap     ] GC(4) DefNew: 629119K(629120K)-&gt;69887K(629120K) Eden: 559232K(559232K)-&gt;0K(559232K) From: 69887K(69888K)-&gt;69887K(69888K)</span><br><span class="line">[0.361s][info   ][gc,heap     ] GC(4) Tenured: 506536K(1398144K)-&gt;650167K(1398144K)</span><br><span class="line">[0.361s][info   ][gc,metaspace] GC(4) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.361s][info   ][gc          ] GC(4) Pause Young (Allocation Failure) 1109M-&gt;703M(1979M) 30.771ms</span><br><span class="line">[0.361s][info   ][gc,cpu      ] GC(4) User=0.01s Sys=0.01s Real=0.03s</span><br><span class="line">[0.393s][info   ][gc,start    ] GC(5) Pause Young (Allocation Failure)</span><br><span class="line">[0.428s][info   ][gc,heap     ] GC(5) DefNew: 629119K(629120K)-&gt;69887K(629120K) Eden: 559232K(559232K)-&gt;0K(559232K) From: 69887K(69888K)-&gt;69887K(69888K)</span><br><span class="line">[0.428s][info   ][gc,heap     ] GC(5) Tenured: 650167K(1398144K)-&gt;778619K(1398144K)</span><br><span class="line">[0.428s][info   ][gc,metaspace] GC(5) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.429s][info   ][gc          ] GC(5) Pause Young (Allocation Failure) 1249M-&gt;828M(1979M) 36.079ms</span><br><span class="line">[0.429s][info   ][gc,cpu      ] GC(5) User=0.01s Sys=0.01s Real=0.04s</span><br><span class="line">[0.465s][info   ][gc,start    ] GC(6) Pause Young (Allocation Failure)</span><br><span class="line">[0.499s][info   ][gc,heap     ] GC(6) DefNew: 629119K(629120K)-&gt;69888K(629120K) Eden: 559232K(559232K)-&gt;0K(559232K) From: 69887K(69888K)-&gt;69888K(69888K)</span><br><span class="line">[0.499s][info   ][gc,heap     ] GC(6) Tenured: 778619K(1398144K)-&gt;921168K(1398144K)</span><br><span class="line">[0.500s][info   ][gc,metaspace] GC(6) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.500s][info   ][gc          ] GC(6) Pause Young (Allocation Failure) 1374M-&gt;967M(1979M) 34.268ms</span><br><span class="line">[0.500s][info   ][gc,cpu      ] GC(6) User=0.02s Sys=0.02s Real=0.04s</span><br><span class="line">[0.531s][info   ][gc,start    ] GC(7) Pause Young (Allocation Failure)</span><br><span class="line">[0.557s][info   ][gc,heap     ] GC(7) DefNew: 629120K(629120K)-&gt;69887K(629120K) Eden: 559232K(559232K)-&gt;0K(559232K) From: 69888K(69888K)-&gt;69887K(69888K)</span><br><span class="line">[0.557s][info   ][gc,heap     ] GC(7) Tenured: 921168K(1398144K)-&gt;1054491K(1398144K)</span><br><span class="line">[0.557s][info   ][gc,metaspace] GC(7) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.558s][info   ][gc          ] GC(7) Pause Young (Allocation Failure) 1513M-&gt;1098M(1979M) 26.353ms</span><br><span class="line">[0.558s][info   ][gc,cpu      ] GC(7) User=0.01s Sys=0.02s Real=0.02s</span><br><span class="line">[0.590s][info   ][gc,start    ] GC(8) Pause Young (Allocation Failure)</span><br><span class="line">[0.617s][info   ][gc,heap     ] GC(8) DefNew: 629119K(629120K)-&gt;69888K(629120K) Eden: 559232K(559232K)-&gt;0K(559232K) From: 69887K(69888K)-&gt;69888K(69888K)</span><br><span class="line">[0.617s][info   ][gc,heap     ] GC(8) Tenured: 1054491K(1398144K)-&gt;1190510K(1398144K)</span><br><span class="line">[0.617s][info   ][gc,metaspace] GC(8) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.617s][info   ][gc          ] GC(8) Pause Young (Allocation Failure) 1644M-&gt;1230M(1979M) 26.769ms</span><br><span class="line">[0.617s][info   ][gc,cpu      ] GC(8) User=0.01s Sys=0.01s Real=0.02s</span><br><span class="line">[0.647s][info   ][gc,start    ] GC(9) Pause Young (Allocation Failure)</span><br><span class="line">[0.674s][info   ][gc,heap     ] GC(9) DefNew: 629120K(629120K)-&gt;69887K(629120K) Eden: 559232K(559232K)-&gt;0K(559232K) From: 69888K(69888K)-&gt;69887K(69888K)</span><br><span class="line">[0.674s][info   ][gc,heap     ] GC(9) Tenured: 1190510K(1398144K)-&gt;1324896K(1398144K)</span><br><span class="line">[0.674s][info   ][gc,metaspace] GC(9) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.674s][info   ][gc          ] GC(9) Pause Young (Allocation Failure) 1776M-&gt;1362M(1979M) 26.741ms</span><br><span class="line">[0.674s][info   ][gc,cpu      ] GC(9) User=0.01s Sys=0.01s Real=0.03s</span><br><span class="line">[0.710s][info   ][gc,start    ] GC(10) Pause Young (Allocation Failure)</span><br><span class="line">[0.710s][info   ][gc          ] GC(10) Pause Young (Allocation Failure) 1908M-&gt;1908M(1979M) 0.093ms</span><br><span class="line">[0.710s][info   ][gc,cpu      ] GC(10) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.710s][info   ][gc,start    ] GC(11) Pause Full (Allocation Failure)</span><br><span class="line">[0.710s][info   ][gc,phases,start] GC(11) Phase 1: Mark live objects</span><br><span class="line">[0.711s][info   ][gc,phases      ] GC(11) Phase 1: Mark live objects 1.296ms</span><br><span class="line">[0.711s][info   ][gc,phases,start] GC(11) Phase 2: Compute new object addresses</span><br><span class="line">[0.719s][info   ][gc,phases      ] GC(11) Phase 2: Compute new object addresses 8.079ms</span><br><span class="line">[0.719s][info   ][gc,phases,start] GC(11) Phase 3: Adjust pointers</span><br><span class="line">[0.720s][info   ][gc,phases      ] GC(11) Phase 3: Adjust pointers 0.684ms</span><br><span class="line">[0.720s][info   ][gc,phases,start] GC(11) Phase 4: Move objects</span><br><span class="line">[0.808s][info   ][gc,phases      ] GC(11) Phase 4: Move objects 87.442ms</span><br><span class="line">[0.808s][info   ][gc,heap        ] GC(11) DefNew: 629119K(629120K)-&gt;0K(629120K) Eden: 559232K(559232K)-&gt;0K(559232K) From: 69887K(69888K)-&gt;0K(69888K)</span><br><span class="line">[0.808s][info   ][gc,heap        ] GC(11) Tenured: 1324896K(1398144K)-&gt;345972K(1398144K)</span><br><span class="line">[0.808s][info   ][gc,metaspace   ] GC(11) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.808s][info   ][gc             ] GC(11) Pause Full (Allocation Failure) 1908M-&gt;337M(1979M) 97.966ms</span><br><span class="line">[0.808s][info   ][gc,cpu         ] GC(11) User=0.03s Sys=0.06s Real=0.09s</span><br><span class="line">[0.862s][info   ][gc,start       ] GC(12) Pause Young (Allocation Failure)</span><br><span class="line">[0.887s][info   ][gc,heap        ] GC(12) DefNew: 559232K(629120K)-&gt;69888K(629120K) Eden: 559232K(559232K)-&gt;0K(559232K) From: 0K(69888K)-&gt;69888K(69888K)</span><br><span class="line">[0.888s][info   ][gc,heap        ] GC(12) Tenured: 345972K(1398144K)-&gt;447899K(1398144K)</span><br><span class="line">[0.888s][info   ][gc,metaspace   ] GC(12) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.888s][info   ][gc             ] GC(12) Pause Young (Allocation Failure) 883M-&gt;505M(1979M) 25.431ms</span><br><span class="line">[0.888s][info   ][gc,cpu         ] GC(12) User=0.01s Sys=0.01s Real=0.02s</span><br><span class="line">[0.921s][info   ][gc,start       ] GC(13) Pause Young (Allocation Failure)</span><br><span class="line">[0.950s][info   ][gc,heap        ] GC(13) DefNew: 629120K(629120K)-&gt;69888K(629120K) Eden: 559232K(559232K)-&gt;0K(559232K) From: 69888K(69888K)-&gt;69888K(69888K)</span><br><span class="line">[0.950s][info   ][gc,heap        ] GC(13) Tenured: 447899K(1398144K)-&gt;587988K(1398144K)</span><br><span class="line">[0.950s][info   ][gc,metaspace   ] GC(13) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.950s][info   ][gc             ] GC(13) Pause Young (Allocation Failure) 1051M-&gt;642M(1979M) 28.591ms</span><br><span class="line">[0.950s][info   ][gc,cpu         ] GC(13) User=0.01s Sys=0.02s Real=0.03s</span><br><span class="line">[0.980s][info   ][gc,start       ] GC(14) Pause Young (Allocation Failure)</span><br><span class="line">[1.031s][info   ][gc,heap        ] GC(14) DefNew: 629120K(629120K)-&gt;69888K(629120K) Eden: 559232K(559232K)-&gt;0K(559232K) From: 69888K(69888K)-&gt;69888K(69888K)</span><br><span class="line">[1.031s][info   ][gc,heap        ] GC(14) Tenured: 587988K(1398144K)-&gt;731410K(1398144K)</span><br><span class="line">[1.031s][info   ][gc,metaspace   ] GC(14) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.031s][info   ][gc             ] GC(14) Pause Young (Allocation Failure) 1188M-&gt;782M(1979M) 51.353ms</span><br><span class="line">[1.031s][info   ][gc,cpu         ] GC(14) User=0.01s Sys=0.01s Real=0.05s</span><br><span class="line">counter:36077</span><br><span class="line">[1.038s][info   ][gc,heap,exit   ] Heap</span><br><span class="line">[1.038s][info   ][gc,heap,exit   ]  def new generation   total 629120K, used 92263K [0x0000000780000000, 0x00000007aaaa0000, 0x00000007aaaa0000)</span><br><span class="line">[1.038s][info   ][gc,heap,exit   ]   eden space 559232K,   4% used [0x0000000780000000, 0x00000007815d9dc0, 0x00000007a2220000)</span><br><span class="line">[1.038s][info   ][gc,heap,exit   ]   from space 69888K, 100% used [0x00000007a6660000, 0x00000007aaaa0000, 0x00000007aaaa0000)</span><br><span class="line">[1.038s][info   ][gc,heap,exit   ]   to   space 69888K,   0% used [0x00000007a2220000, 0x00000007a2220000, 0x00000007a6660000)</span><br><span class="line">[1.038s][info   ][gc,heap,exit   ]  tenured generation   total 1398144K, used 731410K [0x00000007aaaa0000, 0x0000000800000000, 0x0000000800000000)</span><br><span class="line">[1.038s][info   ][gc,heap,exit   ]    the space 1398144K,  52% used [0x00000007aaaa0000, 0x00000007d74e4a20, 0x00000007d74e4c00, 0x0000000800000000)</span><br><span class="line">[1.038s][info   ][gc,heap,exit   ]  Metaspace       used 232K, committed 448K, reserved 1114112K</span><br><span class="line">[1.038s][info   ][gc,heap,exit   ]   class space    used 9K, committed 128K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<h4 id="Parallel-GC"><a href="#Parallel-GC" class="headerlink" title="Parallel GC"></a>Parallel GC</h4><p>目标是最大化应用程序运行时间（吞吐量），最小化 GC 时间。还是会短暂的暂停业务。需要业务能接受短暂的暂停。</p>
<p>-XX: +UseParallelGC<br>-XX: +UseParallelOldGC 这个在java9以上已经被移除</p>
<p>年轻代和老年代GC都会触发STW事件。</p>
<p>对年轻代使用mark-copy算法，对老年代使用mark-sweep-compact算法</p>
<p>-XX: ParallelGCThreads&#x3D;N 来指定GC线程数，默认值为CPU核心数。</p>
<p>优点：</p>
<ul>
<li>多线程回收显著提高了回收效率，适合多核环境。</li>
<li>停顿时间较 Serial GC 短。</li>
<li>两次GC之间不消耗系统资源。</li>
</ul>
<p>缺点：</p>
<ul>
<li>GC 停顿仍然是全暂停（STW）。</li>
<li>不适合对延迟要求苛刻的场景。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>需要高吞吐量的大型后台任务（如批处理、数据分析）。</li>
<li>多核 CPU 环境。</li>
</ul>
<p>接下来试试并行GC 128m内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+UseParallelGC -Xms128m -Xmx128m -XX:+PrintGCDetails -Xlog:gc\*:file=gc.log:time,uptime,level,tags GCLogAnalysis</span><br></pre></td></tr></table></figure>

<p>结果同样OOM，但是仅仅GC了16次,串行GC了25次，花了0.162s才OOM,而并行GC花了0.108s</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0.002s][warning][gc] -XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.</span><br><span class="line">[0.005s][info   ][gc,init] CardTable entry size: 512</span><br><span class="line">[0.005s][info   ][gc     ] Using Parallel</span><br><span class="line">[0.005s][info   ][gc,init] Version: 19.0.2+7-44 (release)</span><br><span class="line">[0.005s][info   ][gc,init] CPUs: 8 total, 8 available</span><br><span class="line">[0.005s][info   ][gc,init] Memory: 16384M</span><br><span class="line">[0.005s][info   ][gc,init] Large Page Support: Disabled</span><br><span class="line">[0.005s][info   ][gc,init] NUMA Support: Disabled</span><br><span class="line">[0.005s][info   ][gc,init] Compressed Oops: Enabled (Zero based)</span><br><span class="line">[0.005s][info   ][gc,init] Alignments: Space 512K, Generation 512K, Heap 8M</span><br><span class="line">[0.005s][info   ][gc,init] Heap Min Capacity: 128M</span><br><span class="line">[0.005s][info   ][gc,init] Heap Initial Capacity: 128M</span><br><span class="line">[0.005s][info   ][gc,init] Heap Max Capacity: 128M</span><br><span class="line">[0.005s][info   ][gc,init] Pre-touch: Disabled</span><br><span class="line">[0.005s][info   ][gc,init] Parallel Workers: 8</span><br><span class="line">[0.006s][info   ][gc,metaspace] CDS archive(s) mapped at: [0x0000000800000000-0x0000000800c44000-0x0000000800c44000), size 12861440, SharedBaseAddress: 0x0000000800000000, ArchiveRelocationMode: 0.</span><br><span class="line">[0.006s][info   ][gc,metaspace] Compressed class space mapped at: 0x0000000801000000-0x0000000841000000, reserved size: 1073741824</span><br><span class="line">[0.006s][info   ][gc,metaspace] Narrow klass base: 0x0000000800000000, Narrow klass shift: 0, Narrow klass range: 0x100000000</span><br><span class="line">gc...</span><br><span class="line">[0.028s][info   ][gc,start    ] GC(0) Pause Young (Allocation Failure)</span><br><span class="line">[0.031s][info   ][gc,heap     ] GC(0) PSYoungGen: 32583K(38400K)-&gt;5118K(38400K) Eden: 32583K(33280K)-&gt;0K(33280K) From: 0K(5120K)-&gt;5118K(5120K)</span><br><span class="line">[0.031s][info   ][gc,heap     ] GC(0) ParOldGen: 992K(87552K)-&gt;10238K(87552K)</span><br><span class="line">[0.031s][info   ][gc,metaspace] GC(0) Metaspace: 141K(384K)-&gt;141K(384K) NonClass: 135K(256K)-&gt;135K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.031s][info   ][gc          ] GC(0) Pause Young (Allocation Failure) 32M-&gt;14M(123M) 2.555ms</span><br><span class="line">[0.031s][info   ][gc,cpu      ] GC(0) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.034s][info   ][gc,start    ] GC(1) Pause Young (Allocation Failure)</span><br><span class="line">[0.036s][info   ][gc,heap     ] GC(1) PSYoungGen: 38054K(38400K)-&gt;5094K(38400K) Eden: 32935K(33280K)-&gt;0K(33280K) From: 5118K(5120K)-&gt;5094K(5120K)</span><br><span class="line">[0.036s][info   ][gc,heap     ] GC(1) ParOldGen: 10238K(87552K)-&gt;22029K(87552K)</span><br><span class="line">[0.036s][info   ][gc,metaspace] GC(1) Metaspace: 147K(384K)-&gt;147K(384K) NonClass: 141K(256K)-&gt;141K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.036s][info   ][gc          ] GC(1) Pause Young (Allocation Failure) 47M-&gt;26M(123M) 1.805ms</span><br><span class="line">[0.036s][info   ][gc,cpu      ] GC(1) User=0.00s Sys=0.01s Real=0.00s</span><br><span class="line">[0.038s][info   ][gc,start    ] GC(2) Pause Young (Allocation Failure)</span><br><span class="line">[0.040s][info   ][gc,heap     ] GC(2) PSYoungGen: 37809K(38400K)-&gt;5111K(38400K) Eden: 32715K(33280K)-&gt;0K(33280K) From: 5094K(5120K)-&gt;5111K(5120K)</span><br><span class="line">[0.040s][info   ][gc,heap     ] GC(2) ParOldGen: 22029K(87552K)-&gt;37342K(87552K)</span><br><span class="line">[0.040s][info   ][gc,metaspace] GC(2) Metaspace: 154K(384K)-&gt;154K(384K) NonClass: 148K(256K)-&gt;148K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.040s][info   ][gc          ] GC(2) Pause Young (Allocation Failure) 58M-&gt;41M(123M) 2.612ms</span><br><span class="line">[0.040s][info   ][gc,cpu      ] GC(2) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.043s][info   ][gc,start    ] GC(3) Pause Young (Allocation Failure)</span><br><span class="line">[0.046s][info   ][gc,heap     ] GC(3) PSYoungGen: 38003K(38400K)-&gt;5115K(38400K) Eden: 32892K(33280K)-&gt;0K(33280K) From: 5111K(5120K)-&gt;5115K(5120K)</span><br><span class="line">[0.046s][info   ][gc,heap     ] GC(3) ParOldGen: 37342K(87552K)-&gt;53010K(87552K)</span><br><span class="line">[0.046s][info   ][gc,metaspace] GC(3) Metaspace: 155K(384K)-&gt;155K(384K) NonClass: 149K(256K)-&gt;149K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.046s][info   ][gc          ] GC(3) Pause Young (Allocation Failure) 73M-&gt;56M(123M) 2.422ms</span><br><span class="line">[0.046s][info   ][gc,cpu      ] GC(3) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.048s][info   ][gc,start    ] GC(4) Pause Young (Allocation Failure)</span><br><span class="line">[0.051s][info   ][gc,heap     ] GC(4) PSYoungGen: 38395K(38400K)-&gt;5112K(38400K) Eden: 33280K(33280K)-&gt;0K(33280K) From: 5115K(5120K)-&gt;5112K(5120K)</span><br><span class="line">[0.051s][info   ][gc,heap     ] GC(4) ParOldGen: 53010K(87552K)-&gt;65895K(87552K)</span><br><span class="line">[0.051s][info   ][gc,metaspace] GC(4) Metaspace: 155K(384K)-&gt;155K(384K) NonClass: 149K(256K)-&gt;149K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.051s][info   ][gc          ] GC(4) Pause Young (Allocation Failure) 89M-&gt;69M(123M) 2.624ms</span><br><span class="line">[0.051s][info   ][gc,cpu      ] GC(4) User=0.01s Sys=0.01s Real=0.00s</span><br><span class="line">[0.053s][info   ][gc,start    ] GC(5) Pause Young (Allocation Failure)</span><br><span class="line">[0.055s][info   ][gc,heap     ] GC(5) PSYoungGen: 38105K(38400K)-&gt;5100K(19968K) Eden: 32992K(33280K)-&gt;0K(14848K) From: 5112K(5120K)-&gt;5100K(5120K)</span><br><span class="line">[0.056s][info   ][gc,heap     ] GC(5) ParOldGen: 65895K(87552K)-&gt;79828K(87552K)</span><br><span class="line">[0.056s][info   ][gc,metaspace] GC(5) Metaspace: 155K(384K)-&gt;155K(384K) NonClass: 149K(256K)-&gt;149K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.056s][info   ][gc          ] GC(5) Pause Young (Allocation Failure) 101M-&gt;82M(105M) 2.261ms</span><br><span class="line">[0.056s][info   ][gc,cpu      ] GC(5) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.056s][info   ][gc,start    ] GC(6) Pause Full (Ergonomics)</span><br><span class="line">[0.056s][info   ][gc,phases,start] GC(6) Marking Phase</span><br><span class="line">[0.057s][info   ][gc,phases      ] GC(6) Marking Phase 1.307ms</span><br><span class="line">[0.057s][info   ][gc,phases,start] GC(6) Summary Phase</span><br><span class="line">[0.057s][info   ][gc,phases      ] GC(6) Summary Phase 0.011ms</span><br><span class="line">[0.057s][info   ][gc,phases,start] GC(6) Adjust Roots</span><br><span class="line">[0.057s][info   ][gc,phases      ] GC(6) Adjust Roots 0.145ms</span><br><span class="line">[0.057s][info   ][gc,phases,start] GC(6) Compaction Phase</span><br><span class="line">[0.061s][info   ][gc,phases      ] GC(6) Compaction Phase 3.587ms</span><br><span class="line">[0.061s][info   ][gc,phases,start] GC(6) Post Compact</span><br><span class="line">[0.061s][info   ][gc,phases      ] GC(6) Post Compact 0.048ms</span><br><span class="line">[0.061s][info   ][gc,heap        ] GC(6) PSYoungGen: 5100K(19968K)-&gt;0K(29184K) Eden: 0K(14848K)-&gt;0K(14848K) From: 5100K(5120K)-&gt;0K(14336K)</span><br><span class="line">[0.061s][info   ][gc,heap        ] GC(6) ParOldGen: 79828K(87552K)-&gt;78802K(87552K)</span><br><span class="line">[0.061s][info   ][gc,metaspace   ] GC(6) Metaspace: 155K(384K)-&gt;155K(384K) NonClass: 149K(256K)-&gt;149K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.061s][info   ][gc             ] GC(6) Pause Full (Ergonomics) 82M-&gt;76M(114M) 5.271ms</span><br><span class="line">[0.061s][info   ][gc,cpu         ] GC(6) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.062s][info   ][gc,start       ] GC(7) Pause Full (Ergonomics)</span><br><span class="line">[0.062s][info   ][gc,phases,start] GC(7) Marking Phase</span><br><span class="line">[0.064s][info   ][gc,phases      ] GC(7) Marking Phase 1.826ms</span><br><span class="line">[0.064s][info   ][gc,phases,start] GC(7) Summary Phase</span><br><span class="line">[0.064s][info   ][gc,phases      ] GC(7) Summary Phase 0.014ms</span><br><span class="line">[0.064s][info   ][gc,phases,start] GC(7) Adjust Roots</span><br><span class="line">[0.064s][info   ][gc,phases      ] GC(7) Adjust Roots 0.144ms</span><br><span class="line">[0.064s][info   ][gc,phases,start] GC(7) Compaction Phase</span><br><span class="line">[0.066s][info   ][gc,phases      ] GC(7) Compaction Phase 1.702ms</span><br><span class="line">[0.066s][info   ][gc,phases,start] GC(7) Post Compact</span><br><span class="line">[0.066s][info   ][gc,phases      ] GC(7) Post Compact 0.054ms</span><br><span class="line">[0.066s][info   ][gc,heap        ] GC(7) PSYoungGen: 14848K(29184K)-&gt;0K(29184K) Eden: 14848K(14848K)-&gt;0K(14848K) From: 0K(14336K)-&gt;0K(14336K)</span><br><span class="line">[0.066s][info   ][gc,heap        ] GC(7) ParOldGen: 78802K(87552K)-&gt;83255K(87552K)</span><br><span class="line">[0.066s][info   ][gc,metaspace   ] GC(7) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.066s][info   ][gc             ] GC(7) Pause Full (Ergonomics) 91M-&gt;81M(114M) 3.928ms</span><br><span class="line">[0.066s][info   ][gc,cpu         ] GC(7) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.067s][info   ][gc,start       ] GC(8) Pause Full (Ergonomics)</span><br><span class="line">[0.067s][info   ][gc,phases,start] GC(8) Marking Phase</span><br><span class="line">[0.069s][info   ][gc,phases      ] GC(8) Marking Phase 2.060ms</span><br><span class="line">[0.069s][info   ][gc,phases,start] GC(8) Summary Phase</span><br><span class="line">[0.069s][info   ][gc,phases      ] GC(8) Summary Phase 0.010ms</span><br><span class="line">[0.069s][info   ][gc,phases,start] GC(8) Adjust Roots</span><br><span class="line">[0.070s][info   ][gc,phases      ] GC(8) Adjust Roots 0.616ms</span><br><span class="line">[0.070s][info   ][gc,phases,start] GC(8) Compaction Phase</span><br><span class="line">[0.075s][info   ][gc,phases      ] GC(8) Compaction Phase 5.364ms</span><br><span class="line">[0.076s][info   ][gc,phases,start] GC(8) Post Compact</span><br><span class="line">[0.076s][info   ][gc,phases      ] GC(8) Post Compact 0.056ms</span><br><span class="line">[0.076s][info   ][gc,heap        ] GC(8) PSYoungGen: 14643K(29184K)-&gt;0K(29184K) Eden: 14643K(14848K)-&gt;0K(14848K) From: 0K(14336K)-&gt;0K(14336K)</span><br><span class="line">[0.076s][info   ][gc,heap        ] GC(8) ParOldGen: 83255K(87552K)-&gt;87322K(87552K)</span><br><span class="line">[0.076s][info   ][gc,metaspace   ] GC(8) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.076s][info   ][gc             ] GC(8) Pause Full (Ergonomics) 95M-&gt;85M(114M) 8.277ms</span><br><span class="line">[0.076s][info   ][gc,cpu         ] GC(8) User=0.01s Sys=0.01s Real=0.00s</span><br><span class="line">[0.078s][info   ][gc,start       ] GC(9) Pause Full (Ergonomics)</span><br><span class="line">[0.078s][info   ][gc,phases,start] GC(9) Marking Phase</span><br><span class="line">[0.079s][info   ][gc,phases      ] GC(9) Marking Phase 1.251ms</span><br><span class="line">[0.079s][info   ][gc,phases,start] GC(9) Summary Phase</span><br><span class="line">[0.079s][info   ][gc,phases      ] GC(9) Summary Phase 0.011ms</span><br><span class="line">[0.079s][info   ][gc,phases,start] GC(9) Adjust Roots</span><br><span class="line">[0.079s][info   ][gc,phases      ] GC(9) Adjust Roots 0.162ms</span><br><span class="line">[0.079s][info   ][gc,phases,start] GC(9) Compaction Phase</span><br><span class="line">[0.083s][info   ][gc,phases      ] GC(9) Compaction Phase 3.974ms</span><br><span class="line">[0.084s][info   ][gc,phases,start] GC(9) Post Compact</span><br><span class="line">[0.084s][info   ][gc,phases      ] GC(9) Post Compact 0.088ms</span><br><span class="line">[0.084s][info   ][gc,heap        ] GC(9) PSYoungGen: 14556K(29184K)-&gt;4765K(29184K) Eden: 14556K(14848K)-&gt;4765K(14848K) From: 0K(14336K)-&gt;0K(14336K)</span><br><span class="line">[0.084s][info   ][gc,heap        ] GC(9) ParOldGen: 87322K(87552K)-&gt;87356K(87552K)</span><br><span class="line">[0.084s][info   ][gc,metaspace   ] GC(9) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.084s][info   ][gc             ] GC(9) Pause Full (Ergonomics) 99M-&gt;89M(114M) 5.831ms</span><br><span class="line">[0.084s][info   ][gc,cpu         ] GC(9) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.085s][info   ][gc,start       ] GC(10) Pause Full (Ergonomics)</span><br><span class="line">[0.086s][info   ][gc,phases,start] GC(10) Marking Phase</span><br><span class="line">[0.088s][info   ][gc,phases      ] GC(10) Marking Phase 2.046ms</span><br><span class="line">[0.088s][info   ][gc,phases,start] GC(10) Summary Phase</span><br><span class="line">[0.088s][info   ][gc,phases      ] GC(10) Summary Phase 0.011ms</span><br><span class="line">[0.088s][info   ][gc,phases,start] GC(10) Adjust Roots</span><br><span class="line">[0.088s][info   ][gc,phases      ] GC(10) Adjust Roots 0.129ms</span><br><span class="line">[0.088s][info   ][gc,phases,start] GC(10) Compaction Phase</span><br><span class="line">[0.090s][info   ][gc,phases      ] GC(10) Compaction Phase 1.986ms</span><br><span class="line">[0.090s][info   ][gc,phases,start] GC(10) Post Compact</span><br><span class="line">[0.090s][info   ][gc,phases      ] GC(10) Post Compact 0.060ms</span><br><span class="line">[0.090s][info   ][gc,heap        ] GC(10) PSYoungGen: 14439K(29184K)-&gt;10132K(29184K) Eden: 14439K(14848K)-&gt;10132K(14848K) From: 0K(14336K)-&gt;0K(14336K)</span><br><span class="line">[0.090s][info   ][gc,heap        ] GC(10) ParOldGen: 87356K(87552K)-&gt;86976K(87552K)</span><br><span class="line">[0.090s][info   ][gc,metaspace   ] GC(10) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.090s][info   ][gc             ] GC(10) Pause Full (Ergonomics) 99M-&gt;94M(114M) 4.406ms</span><br><span class="line">[0.090s][info   ][gc,cpu         ] GC(10) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.091s][info   ][gc,start       ] GC(11) Pause Full (Ergonomics)</span><br><span class="line">[0.091s][info   ][gc,phases,start] GC(11) Marking Phase</span><br><span class="line">[0.093s][info   ][gc,phases      ] GC(11) Marking Phase 2.085ms</span><br><span class="line">[0.093s][info   ][gc,phases,start] GC(11) Summary Phase</span><br><span class="line">[0.093s][info   ][gc,phases      ] GC(11) Summary Phase 0.011ms</span><br><span class="line">[0.093s][info   ][gc,phases,start] GC(11) Adjust Roots</span><br><span class="line">[0.093s][info   ][gc,phases      ] GC(11) Adjust Roots 0.125ms</span><br><span class="line">[0.093s][info   ][gc,phases,start] GC(11) Compaction Phase</span><br><span class="line">[0.094s][info   ][gc,phases      ] GC(11) Compaction Phase 1.132ms</span><br><span class="line">[0.094s][info   ][gc,phases,start] GC(11) Post Compact</span><br><span class="line">[0.094s][info   ][gc,phases      ] GC(11) Post Compact 0.054ms</span><br><span class="line">[0.094s][info   ][gc,heap        ] GC(11) PSYoungGen: 14839K(29184K)-&gt;11329K(29184K) Eden: 14839K(14848K)-&gt;11329K(14848K) From: 0K(14336K)-&gt;0K(14336K)</span><br><span class="line">[0.094s][info   ][gc,heap        ] GC(11) ParOldGen: 86976K(87552K)-&gt;87429K(87552K)</span><br><span class="line">[0.094s][info   ][gc,metaspace   ] GC(11) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.094s][info   ][gc             ] GC(11) Pause Full (Ergonomics) 99M-&gt;96M(114M) 3.584ms</span><br><span class="line">[0.094s][info   ][gc,cpu         ] GC(11) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.095s][info   ][gc,start       ] GC(12) Pause Full (Ergonomics)</span><br><span class="line">[0.095s][info   ][gc,phases,start] GC(12) Marking Phase</span><br><span class="line">[0.097s][info   ][gc,phases      ] GC(12) Marking Phase 2.000ms</span><br><span class="line">[0.097s][info   ][gc,phases,start] GC(12) Summary Phase</span><br><span class="line">[0.097s][info   ][gc,phases      ] GC(12) Summary Phase 0.008ms</span><br><span class="line">[0.097s][info   ][gc,phases,start] GC(12) Adjust Roots</span><br><span class="line">[0.097s][info   ][gc,phases      ] GC(12) Adjust Roots 0.136ms</span><br><span class="line">[0.097s][info   ][gc,phases,start] GC(12) Compaction Phase</span><br><span class="line">[0.097s][info   ][gc,phases      ] GC(12) Compaction Phase 0.325ms</span><br><span class="line">[0.097s][info   ][gc,phases,start] GC(12) Post Compact</span><br><span class="line">[0.097s][info   ][gc,phases      ] GC(12) Post Compact 0.041ms</span><br><span class="line">[0.097s][info   ][gc,heap        ] GC(12) PSYoungGen: 14804K(29184K)-&gt;12796K(29184K) Eden: 14804K(14848K)-&gt;12796K(14848K) From: 0K(14336K)-&gt;0K(14336K)</span><br><span class="line">[0.097s][info   ][gc,heap        ] GC(12) ParOldGen: 87429K(87552K)-&gt;87429K(87552K)</span><br><span class="line">[0.097s][info   ][gc,metaspace   ] GC(12) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.097s][info   ][gc             ] GC(12) Pause Full (Ergonomics) 99M-&gt;97M(114M) 2.665ms</span><br><span class="line">[0.097s][info   ][gc,cpu         ] GC(12) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.098s][info   ][gc,start       ] GC(13) Pause Full (Ergonomics)</span><br><span class="line">[0.098s][info   ][gc,phases,start] GC(13) Marking Phase</span><br><span class="line">[0.099s][info   ][gc,phases      ] GC(13) Marking Phase 0.880ms</span><br><span class="line">[0.099s][info   ][gc,phases,start] GC(13) Summary Phase</span><br><span class="line">[0.099s][info   ][gc,phases      ] GC(13) Summary Phase 0.008ms</span><br><span class="line">[0.099s][info   ][gc,phases,start] GC(13) Adjust Roots</span><br><span class="line">[0.099s][info   ][gc,phases      ] GC(13) Adjust Roots 0.103ms</span><br><span class="line">[0.099s][info   ][gc,phases,start] GC(13) Compaction Phase</span><br><span class="line">[0.101s][info   ][gc,phases      ] GC(13) Compaction Phase 1.874ms</span><br><span class="line">[0.101s][info   ][gc,phases,start] GC(13) Post Compact</span><br><span class="line">[0.101s][info   ][gc,phases      ] GC(13) Post Compact 0.047ms</span><br><span class="line">[0.101s][info   ][gc,heap        ] GC(13) PSYoungGen: 14544K(29184K)-&gt;13373K(29184K) Eden: 14544K(14848K)-&gt;13373K(14848K) From: 0K(14336K)-&gt;0K(14336K)</span><br><span class="line">[0.101s][info   ][gc,heap        ] GC(13) ParOldGen: 87429K(87552K)-&gt;87084K(87552K)</span><br><span class="line">[0.101s][info   ][gc,metaspace   ] GC(13) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.101s][info   ][gc             ] GC(13) Pause Full (Ergonomics) 99M-&gt;98M(114M) 3.072ms</span><br><span class="line">[0.101s][info   ][gc,cpu         ] GC(13) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.101s][info   ][gc,start       ] GC(14) Pause Full (Ergonomics)</span><br><span class="line">[0.101s][info   ][gc,phases,start] GC(14) Marking Phase</span><br><span class="line">[0.102s][info   ][gc,phases      ] GC(14) Marking Phase 0.963ms</span><br><span class="line">[0.102s][info   ][gc,phases,start] GC(14) Summary Phase</span><br><span class="line">[0.102s][info   ][gc,phases      ] GC(14) Summary Phase 0.009ms</span><br><span class="line">[0.102s][info   ][gc,phases,start] GC(14) Adjust Roots</span><br><span class="line">[0.102s][info   ][gc,phases      ] GC(14) Adjust Roots 0.175ms</span><br><span class="line">[0.102s][info   ][gc,phases,start] GC(14) Compaction Phase</span><br><span class="line">[0.103s][info   ][gc,phases      ] GC(14) Compaction Phase 0.350ms</span><br><span class="line">[0.103s][info   ][gc,phases,start] GC(14) Post Compact</span><br><span class="line">[0.103s][info   ][gc,phases      ] GC(14) Post Compact 0.048ms</span><br><span class="line">[0.103s][info   ][gc,heap        ] GC(14) PSYoungGen: 14724K(29184K)-&gt;13944K(29184K) Eden: 14724K(14848K)-&gt;13944K(14848K) From: 0K(14336K)-&gt;0K(14336K)</span><br><span class="line">[0.103s][info   ][gc,heap        ] GC(14) ParOldGen: 87084K(87552K)-&gt;87084K(87552K)</span><br><span class="line">[0.103s][info   ][gc,metaspace   ] GC(14) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.103s][info   ][gc             ] GC(14) Pause Full (Ergonomics) 99M-&gt;98M(114M) 1.712ms</span><br><span class="line">[0.103s][info   ][gc,cpu         ] GC(14) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.103s][info   ][gc,start       ] GC(15) Pause Full (Ergonomics)</span><br><span class="line">[0.103s][info   ][gc,phases,start] GC(15) Marking Phase</span><br><span class="line">[0.105s][info   ][gc,phases      ] GC(15) Marking Phase 1.857ms</span><br><span class="line">[0.105s][info   ][gc,phases,start] GC(15) Summary Phase</span><br><span class="line">[0.105s][info   ][gc,phases      ] GC(15) Summary Phase 0.009ms</span><br><span class="line">[0.105s][info   ][gc,phases,start] GC(15) Adjust Roots</span><br><span class="line">[0.105s][info   ][gc,phases      ] GC(15) Adjust Roots 0.104ms</span><br><span class="line">[0.105s][info   ][gc,phases,start] GC(15) Compaction Phase</span><br><span class="line">[0.105s][info   ][gc,phases      ] GC(15) Compaction Phase 0.326ms</span><br><span class="line">[0.105s][info   ][gc,phases,start] GC(15) Post Compact</span><br><span class="line">[0.105s][info   ][gc,phases      ] GC(15) Post Compact 0.039ms</span><br><span class="line">[0.105s][info   ][gc,heap        ] GC(15) PSYoungGen: 14610K(29184K)-&gt;14454K(29184K) Eden: 14610K(14848K)-&gt;14454K(14848K) From: 0K(14336K)-&gt;0K(14336K)</span><br><span class="line">[0.105s][info   ][gc,heap        ] GC(15) ParOldGen: 87084K(87552K)-&gt;87084K(87552K)</span><br><span class="line">[0.105s][info   ][gc,metaspace   ] GC(15) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.105s][info   ][gc             ] GC(15) Pause Full (Ergonomics) 99M-&gt;99M(114M) 2.439ms</span><br><span class="line">[0.105s][info   ][gc,cpu         ] GC(15) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.105s][info   ][gc,start       ] GC(16) Pause Full (Allocation Failure)</span><br><span class="line">[0.105s][info   ][gc,phases,start] GC(16) Marking Phase</span><br><span class="line">[0.106s][info   ][gc,phases      ] GC(16) Marking Phase 1.070ms</span><br><span class="line">[0.107s][info   ][gc,phases,start] GC(16) Summary Phase</span><br><span class="line">[0.107s][info   ][gc,phases      ] GC(16) Summary Phase 0.009ms</span><br><span class="line">[0.107s][info   ][gc,phases,start] GC(16) Adjust Roots</span><br><span class="line">[0.107s][info   ][gc,phases      ] GC(16) Adjust Roots 0.090ms</span><br><span class="line">[0.107s][info   ][gc,phases,start] GC(16) Compaction Phase</span><br><span class="line">[0.107s][info   ][gc,phases      ] GC(16) Compaction Phase 0.678ms</span><br><span class="line">[0.107s][info   ][gc,phases,start] GC(16) Post Compact</span><br><span class="line">[0.107s][info   ][gc,phases      ] GC(16) Post Compact 0.056ms</span><br><span class="line">[0.107s][info   ][gc,heap        ] GC(16) PSYoungGen: 14454K(29184K)-&gt;14454K(29184K) Eden: 14454K(14848K)-&gt;14454K(14848K) From: 0K(14336K)-&gt;0K(14336K)</span><br><span class="line">[0.107s][info   ][gc,heap        ] GC(16) ParOldGen: 87084K(87552K)-&gt;87082K(87552K)</span><br><span class="line">[0.107s][info   ][gc,metaspace   ] GC(16) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.107s][info   ][gc             ] GC(16) Pause Full (Allocation Failure) 99M-&gt;99M(114M) 2.041ms</span><br><span class="line">[0.107s][info   ][gc,cpu         ] GC(16) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at GCLogAnalysis.generateGarbage(GCLogAnalysis.java:42)</span><br><span class="line">	at GCLogAnalysis.main(GCLogAnalysis.java:20)</span><br><span class="line">[0.108s][info   ][gc,heap,exit   ] Heap</span><br><span class="line">[0.108s][info   ][gc,heap,exit   ]  PSYoungGen      total 29184K, used 14811K [0x00000007fd580000, 0x0000000800000000, 0x0000000800000000)</span><br><span class="line">[0.108s][info   ][gc,heap,exit   ]   eden space 14848K, 99% used [0x00000007fd580000,0x00000007fe3f6d70,0x00000007fe400000)</span><br><span class="line">[0.108s][info   ][gc,heap,exit   ]   from space 14336K, 0% used [0x00000007fe400000,0x00000007fe400000,0x00000007ff200000)</span><br><span class="line">[0.108s][info   ][gc,heap,exit   ]   to   space 14336K, 0% used [0x00000007ff200000,0x00000007ff200000,0x0000000800000000)</span><br><span class="line">[0.108s][info   ][gc,heap,exit   ]  ParOldGen       total 87552K, used 87082K [0x00000007f8000000, 0x00000007fd580000, 0x00000007fd580000)</span><br><span class="line">[0.108s][info   ][gc,heap,exit   ]   object space 87552K, 99% used [0x00000007f8000000,0x00000007fd50a8f0,0x00000007fd580000)</span><br><span class="line">[0.108s][info   ][gc,heap,exit   ]  Metaspace       used 163K, committed 384K, reserved 1114112K</span><br><span class="line">[0.108s][info   ][gc,heap,exit   ]   class space    used 7K, committed 128K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>接下来试试512m</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+UseParallelGC -Xms512m -Xmx512m -XX:+PrintGCDetails -Xlog:gc\*:file=gc.log:time,uptime,level,tags GCLogAnalysis</span><br></pre></td></tr></table></figure>

<p>可以发现GC次数大大增加了，吞吐量也降低了。27000多个对象，99次GC。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0.293s][info   ][gc,phases      ] GC(35) Adjust Roots 0.149ms</span><br><span class="line">[0.293s][info   ][gc,phases,start] GC(35) Compaction Phase</span><br><span class="line">[0.298s][info   ][gc,phases      ] GC(35) Compaction Phase 5.147ms</span><br><span class="line">[0.298s][info   ][gc,phases,start] GC(35) Post Compact</span><br><span class="line">[0.298s][info   ][gc,phases      ] GC(35) Post Compact 0.154ms</span><br><span class="line">[0.298s][info   ][gc,heap        ] GC(35) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.298s][info   ][gc,heap        ] GC(35) ParOldGen: 319789K(349696K)-&gt;323740K(349696K)</span><br><span class="line">[0.298s][info   ][gc,metaspace   ] GC(35) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.298s][info   ][gc             ] GC(35) Pause Full (Ergonomics) 369M-&gt;316M(455M) 7.260ms</span><br><span class="line">[0.298s][info   ][gc,cpu         ] GC(35) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.301s][info   ][gc,start       ] GC(36) Pause Full (Ergonomics)</span><br><span class="line">[0.301s][info   ][gc,phases,start] GC(36) Marking Phase</span><br><span class="line">[0.303s][info   ][gc,phases      ] GC(36) Marking Phase 2.059ms</span><br><span class="line">[0.303s][info   ][gc,phases,start] GC(36) Summary Phase</span><br><span class="line">[0.303s][info   ][gc,phases      ] GC(36) Summary Phase 0.017ms</span><br><span class="line">[0.303s][info   ][gc,phases,start] GC(36) Adjust Roots</span><br><span class="line">[0.303s][info   ][gc,phases      ] GC(36) Adjust Roots 0.151ms</span><br><span class="line">[0.303s][info   ][gc,phases,start] GC(36) Compaction Phase</span><br><span class="line">[0.309s][info   ][gc,phases      ] GC(36) Compaction Phase 5.908ms</span><br><span class="line">[0.309s][info   ][gc,phases,start] GC(36) Post Compact</span><br><span class="line">[0.309s][info   ][gc,phases      ] GC(36) Post Compact 0.157ms</span><br><span class="line">[0.310s][info   ][gc,heap        ] GC(36) PSYoungGen: 58212K(116736K)-&gt;0K(116736K) Eden: 58212K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.310s][info   ][gc,heap        ] GC(36) ParOldGen: 323740K(349696K)-&gt;324378K(349696K)</span><br><span class="line">[0.310s][info   ][gc,metaspace   ] GC(36) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.310s][info   ][gc             ] GC(36) Pause Full (Ergonomics) 373M-&gt;316M(455M) 8.553ms</span><br><span class="line">[0.310s][info   ][gc,cpu         ] GC(36) User=0.04s Sys=0.01s Real=0.01s</span><br><span class="line">[0.313s][info   ][gc,start       ] GC(37) Pause Full (Ergonomics)</span><br><span class="line">[0.313s][info   ][gc,phases,start] GC(37) Marking Phase</span><br><span class="line">[0.315s][info   ][gc,phases      ] GC(37) Marking Phase 2.002ms</span><br><span class="line">[0.315s][info   ][gc,phases,start] GC(37) Summary Phase</span><br><span class="line">[0.315s][info   ][gc,phases      ] GC(37) Summary Phase 0.017ms</span><br><span class="line">[0.315s][info   ][gc,phases,start] GC(37) Adjust Roots</span><br><span class="line">[0.315s][info   ][gc,phases      ] GC(37) Adjust Roots 0.145ms</span><br><span class="line">[0.315s][info   ][gc,phases,start] GC(37) Compaction Phase</span><br><span class="line">[0.320s][info   ][gc,phases      ] GC(37) Compaction Phase 5.274ms</span><br><span class="line">[0.320s][info   ][gc,phases,start] GC(37) Post Compact</span><br><span class="line">[0.320s][info   ][gc,phases      ] GC(37) Post Compact 0.156ms</span><br><span class="line">[0.320s][info   ][gc,heap        ] GC(37) PSYoungGen: 58330K(116736K)-&gt;0K(116736K) Eden: 58330K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.320s][info   ][gc,heap        ] GC(37) ParOldGen: 324378K(349696K)-&gt;330545K(349696K)</span><br><span class="line">[0.321s][info   ][gc,metaspace   ] GC(37) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.321s][info   ][gc             ] GC(37) Pause Full (Ergonomics) 373M-&gt;322M(455M) 7.833ms</span><br><span class="line">[0.321s][info   ][gc,cpu         ] GC(37) User=0.03s Sys=0.00s Real=0.00s</span><br><span class="line">[0.324s][info   ][gc,start       ] GC(38) Pause Full (Ergonomics)</span><br><span class="line">[0.324s][info   ][gc,phases,start] GC(38) Marking Phase</span><br><span class="line">[0.326s][info   ][gc,phases      ] GC(38) Marking Phase 1.991ms</span><br><span class="line">[0.326s][info   ][gc,phases,start] GC(38) Summary Phase</span><br><span class="line">[0.326s][info   ][gc,phases      ] GC(38) Summary Phase 0.016ms</span><br><span class="line">[0.326s][info   ][gc,phases,start] GC(38) Adjust Roots</span><br><span class="line">[0.326s][info   ][gc,phases      ] GC(38) Adjust Roots 0.132ms</span><br><span class="line">[0.326s][info   ][gc,phases,start] GC(38) Compaction Phase</span><br><span class="line">[0.331s][info   ][gc,phases      ] GC(38) Compaction Phase 4.801ms</span><br><span class="line">[0.331s][info   ][gc,phases,start] GC(38) Post Compact</span><br><span class="line">[0.331s][info   ][gc,phases      ] GC(38) Post Compact 0.196ms</span><br><span class="line">[0.331s][info   ][gc,heap        ] GC(38) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.331s][info   ][gc,heap        ] GC(38) ParOldGen: 330545K(349696K)-&gt;327226K(349696K)</span><br><span class="line">[0.331s][info   ][gc,metaspace   ] GC(38) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.331s][info   ][gc             ] GC(38) Pause Full (Ergonomics) 380M-&gt;319M(455M) 7.330ms</span><br><span class="line">[0.331s][info   ][gc,cpu         ] GC(38) User=0.03s Sys=0.00s Real=0.00s</span><br><span class="line">[0.334s][info   ][gc,start       ] GC(39) Pause Full (Ergonomics)</span><br><span class="line">[0.334s][info   ][gc,phases,start] GC(39) Marking Phase</span><br><span class="line">[0.336s][info   ][gc,phases      ] GC(39) Marking Phase 1.339ms</span><br><span class="line">[0.336s][info   ][gc,phases,start] GC(39) Summary Phase</span><br><span class="line">[0.336s][info   ][gc,phases      ] GC(39) Summary Phase 0.017ms</span><br><span class="line">[0.336s][info   ][gc,phases,start] GC(39) Adjust Roots</span><br><span class="line">[0.336s][info   ][gc,phases      ] GC(39) Adjust Roots 0.147ms</span><br><span class="line">[0.336s][info   ][gc,phases,start] GC(39) Compaction Phase</span><br><span class="line">[0.342s][info   ][gc,phases      ] GC(39) Compaction Phase 5.525ms</span><br><span class="line">[0.342s][info   ][gc,phases,start] GC(39) Post Compact</span><br><span class="line">[0.342s][info   ][gc,phases      ] GC(39) Post Compact 0.159ms</span><br><span class="line">[0.342s][info   ][gc,heap        ] GC(39) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.342s][info   ][gc,heap        ] GC(39) ParOldGen: 327226K(349696K)-&gt;328568K(349696K)</span><br><span class="line">[0.342s][info   ][gc,metaspace   ] GC(39) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.342s][info   ][gc             ] GC(39) Pause Full (Ergonomics) 377M-&gt;320M(455M) 7.366ms</span><br><span class="line">[0.342s][info   ][gc,cpu         ] GC(39) User=0.03s Sys=0.00s Real=0.00s</span><br><span class="line">[0.345s][info   ][gc,start       ] GC(40) Pause Full (Ergonomics)</span><br><span class="line">[0.345s][info   ][gc,phases,start] GC(40) Marking Phase</span><br><span class="line">[0.347s][info   ][gc,phases      ] GC(40) Marking Phase 1.575ms</span><br><span class="line">[0.347s][info   ][gc,phases,start] GC(40) Summary Phase</span><br><span class="line">[0.347s][info   ][gc,phases      ] GC(40) Summary Phase 0.024ms</span><br><span class="line">[0.347s][info   ][gc,phases,start] GC(40) Adjust Roots</span><br><span class="line">[0.347s][info   ][gc,phases      ] GC(40) Adjust Roots 0.156ms</span><br><span class="line">[0.347s][info   ][gc,phases,start] GC(40) Compaction Phase</span><br><span class="line">[0.352s][info   ][gc,phases      ] GC(40) Compaction Phase 5.421ms</span><br><span class="line">[0.352s][info   ][gc,phases,start] GC(40) Post Compact</span><br><span class="line">[0.353s][info   ][gc,phases      ] GC(40) Post Compact 0.152ms</span><br><span class="line">[0.353s][info   ][gc,heap        ] GC(40) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.353s][info   ][gc,heap        ] GC(40) ParOldGen: 328568K(349696K)-&gt;327872K(349696K)</span><br><span class="line">[0.353s][info   ][gc,metaspace   ] GC(40) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.353s][info   ][gc             ] GC(40) Pause Full (Ergonomics) 378M-&gt;320M(455M) 7.517ms</span><br><span class="line">[0.353s][info   ][gc,cpu         ] GC(40) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.356s][info   ][gc,start       ] GC(41) Pause Full (Ergonomics)</span><br><span class="line">[0.356s][info   ][gc,phases,start] GC(41) Marking Phase</span><br><span class="line">[0.358s][info   ][gc,phases      ] GC(41) Marking Phase 2.070ms</span><br><span class="line">[0.358s][info   ][gc,phases,start] GC(41) Summary Phase</span><br><span class="line">[0.358s][info   ][gc,phases      ] GC(41) Summary Phase 0.015ms</span><br><span class="line">[0.358s][info   ][gc,phases,start] GC(41) Adjust Roots</span><br><span class="line">[0.358s][info   ][gc,phases      ] GC(41) Adjust Roots 0.139ms</span><br><span class="line">[0.358s][info   ][gc,phases,start] GC(41) Compaction Phase</span><br><span class="line">[0.363s][info   ][gc,phases      ] GC(41) Compaction Phase 5.207ms</span><br><span class="line">[0.363s][info   ][gc,phases,start] GC(41) Post Compact</span><br><span class="line">[0.363s][info   ][gc,phases      ] GC(41) Post Compact 0.153ms</span><br><span class="line">[0.363s][info   ][gc,heap        ] GC(41) PSYoungGen: 58603K(116736K)-&gt;0K(116736K) Eden: 58603K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.363s][info   ][gc,heap        ] GC(41) ParOldGen: 327872K(349696K)-&gt;325933K(349696K)</span><br><span class="line">[0.363s][info   ][gc,metaspace   ] GC(41) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.363s][info   ][gc             ] GC(41) Pause Full (Ergonomics) 377M-&gt;318M(455M) 7.759ms</span><br><span class="line">[0.364s][info   ][gc,cpu         ] GC(41) User=0.04s Sys=0.00s Real=0.01s</span><br><span class="line">[0.366s][info   ][gc,start       ] GC(42) Pause Full (Ergonomics)</span><br><span class="line">[0.366s][info   ][gc,phases,start] GC(42) Marking Phase</span><br><span class="line">[0.368s][info   ][gc,phases      ] GC(42) Marking Phase 1.962ms</span><br><span class="line">[0.368s][info   ][gc,phases,start] GC(42) Summary Phase</span><br><span class="line">[0.368s][info   ][gc,phases      ] GC(42) Summary Phase 0.013ms</span><br><span class="line">[0.368s][info   ][gc,phases,start] GC(42) Adjust Roots</span><br><span class="line">[0.369s][info   ][gc,phases      ] GC(42) Adjust Roots 0.159ms</span><br><span class="line">[0.369s][info   ][gc,phases,start] GC(42) Compaction Phase</span><br><span class="line">[0.375s][info   ][gc,phases      ] GC(42) Compaction Phase 6.241ms</span><br><span class="line">[0.375s][info   ][gc,phases,start] GC(42) Post Compact</span><br><span class="line">[0.375s][info   ][gc,phases      ] GC(42) Post Compact 0.169ms</span><br><span class="line">[0.375s][info   ][gc,heap        ] GC(42) PSYoungGen: 58777K(116736K)-&gt;0K(116736K) Eden: 58777K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.375s][info   ][gc,heap        ] GC(42) ParOldGen: 325933K(349696K)-&gt;329364K(349696K)</span><br><span class="line">[0.375s][info   ][gc,metaspace   ] GC(42) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.375s][info   ][gc             ] GC(42) Pause Full (Ergonomics) 375M-&gt;321M(455M) 8.773ms</span><br><span class="line">[0.375s][info   ][gc,cpu         ] GC(42) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.378s][info   ][gc,start       ] GC(43) Pause Full (Ergonomics)</span><br><span class="line">[0.378s][info   ][gc,phases,start] GC(43) Marking Phase</span><br><span class="line">[0.380s][info   ][gc,phases      ] GC(43) Marking Phase 2.313ms</span><br><span class="line">[0.380s][info   ][gc,phases,start] GC(43) Summary Phase</span><br><span class="line">[0.380s][info   ][gc,phases      ] GC(43) Summary Phase 0.017ms</span><br><span class="line">[0.380s][info   ][gc,phases,start] GC(43) Adjust Roots</span><br><span class="line">[0.380s][info   ][gc,phases      ] GC(43) Adjust Roots 0.177ms</span><br><span class="line">[0.380s][info   ][gc,phases,start] GC(43) Compaction Phase</span><br><span class="line">[0.385s][info   ][gc,phases      ] GC(43) Compaction Phase 5.140ms</span><br><span class="line">[0.386s][info   ][gc,phases,start] GC(43) Post Compact</span><br><span class="line">[0.386s][info   ][gc,phases      ] GC(43) Post Compact 0.163ms</span><br><span class="line">[0.386s][info   ][gc,heap        ] GC(43) PSYoungGen: 58784K(116736K)-&gt;0K(116736K) Eden: 58784K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.386s][info   ][gc,heap        ] GC(43) ParOldGen: 329364K(349696K)-&gt;326673K(349696K)</span><br><span class="line">[0.386s][info   ][gc,metaspace   ] GC(43) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.386s][info   ][gc             ] GC(43) Pause Full (Ergonomics) 379M-&gt;319M(455M) 8.001ms</span><br><span class="line">[0.386s][info   ][gc,cpu         ] GC(43) User=0.04s Sys=0.00s Real=0.01s</span><br><span class="line">[0.389s][info   ][gc,start       ] GC(44) Pause Full (Ergonomics)</span><br><span class="line">[0.389s][info   ][gc,phases,start] GC(44) Marking Phase</span><br><span class="line">[0.390s][info   ][gc,phases      ] GC(44) Marking Phase 1.584ms</span><br><span class="line">[0.390s][info   ][gc,phases,start] GC(44) Summary Phase</span><br><span class="line">[0.390s][info   ][gc,phases      ] GC(44) Summary Phase 0.018ms</span><br><span class="line">[0.390s][info   ][gc,phases,start] GC(44) Adjust Roots</span><br><span class="line">[0.391s][info   ][gc,phases      ] GC(44) Adjust Roots 0.324ms</span><br><span class="line">[0.391s][info   ][gc,phases,start] GC(44) Compaction Phase</span><br><span class="line">[0.396s][info   ][gc,phases      ] GC(44) Compaction Phase 5.119ms</span><br><span class="line">[0.396s][info   ][gc,phases,start] GC(44) Post Compact</span><br><span class="line">[0.396s][info   ][gc,phases      ] GC(44) Post Compact 0.165ms</span><br><span class="line">[0.396s][info   ][gc,heap        ] GC(44) PSYoungGen: 58849K(116736K)-&gt;0K(116736K) Eden: 58849K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.396s][info   ][gc,heap        ] GC(44) ParOldGen: 326673K(349696K)-&gt;323222K(349696K)</span><br><span class="line">[0.396s][info   ][gc,metaspace   ] GC(44) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.396s][info   ][gc             ] GC(44) Pause Full (Ergonomics) 376M-&gt;315M(455M) 7.410ms</span><br><span class="line">[0.396s][info   ][gc,cpu         ] GC(44) User=0.04s Sys=0.01s Real=0.01s</span><br><span class="line">[0.398s][info   ][gc,start       ] GC(45) Pause Full (Ergonomics)</span><br><span class="line">[0.398s][info   ][gc,phases,start] GC(45) Marking Phase</span><br><span class="line">[0.400s][info   ][gc,phases      ] GC(45) Marking Phase 1.678ms</span><br><span class="line">[0.400s][info   ][gc,phases,start] GC(45) Summary Phase</span><br><span class="line">[0.400s][info   ][gc,phases      ] GC(45) Summary Phase 0.016ms</span><br><span class="line">[0.400s][info   ][gc,phases,start] GC(45) Adjust Roots</span><br><span class="line">[0.400s][info   ][gc,phases      ] GC(45) Adjust Roots 0.132ms</span><br><span class="line">[0.400s][info   ][gc,phases,start] GC(45) Compaction Phase</span><br><span class="line">[0.406s][info   ][gc,phases      ] GC(45) Compaction Phase 5.856ms</span><br><span class="line">[0.406s][info   ][gc,phases,start] GC(45) Post Compact</span><br><span class="line">[0.406s][info   ][gc,phases      ] GC(45) Post Compact 0.160ms</span><br><span class="line">[0.406s][info   ][gc,heap        ] GC(45) PSYoungGen: 58674K(116736K)-&gt;0K(116736K) Eden: 58674K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.406s][info   ][gc,heap        ] GC(45) ParOldGen: 323222K(349696K)-&gt;330037K(349696K)</span><br><span class="line">[0.406s][info   ][gc,metaspace   ] GC(45) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.406s][info   ][gc             ] GC(45) Pause Full (Ergonomics) 372M-&gt;322M(455M) 8.008ms</span><br><span class="line">[0.406s][info   ][gc,cpu         ] GC(45) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.409s][info   ][gc,start       ] GC(46) Pause Full (Ergonomics)</span><br><span class="line">[0.409s][info   ][gc,phases,start] GC(46) Marking Phase</span><br><span class="line">[0.413s][info   ][gc,phases      ] GC(46) Marking Phase 3.590ms</span><br><span class="line">[0.413s][info   ][gc,phases,start] GC(46) Summary Phase</span><br><span class="line">[0.413s][info   ][gc,phases      ] GC(46) Summary Phase 0.015ms</span><br><span class="line">[0.413s][info   ][gc,phases,start] GC(46) Adjust Roots</span><br><span class="line">[0.413s][info   ][gc,phases      ] GC(46) Adjust Roots 0.170ms</span><br><span class="line">[0.413s][info   ][gc,phases,start] GC(46) Compaction Phase</span><br><span class="line">[0.418s][info   ][gc,phases      ] GC(46) Compaction Phase 5.598ms</span><br><span class="line">[0.418s][info   ][gc,phases,start] GC(46) Post Compact</span><br><span class="line">[0.419s][info   ][gc,phases      ] GC(46) Post Compact 0.166ms</span><br><span class="line">[0.419s][info   ][gc,heap        ] GC(46) PSYoungGen: 58618K(116736K)-&gt;0K(116736K) Eden: 58618K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.419s][info   ][gc,heap        ] GC(46) ParOldGen: 330037K(349696K)-&gt;330388K(349696K)</span><br><span class="line">[0.419s][info   ][gc,metaspace   ] GC(46) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.419s][info   ][gc             ] GC(46) Pause Full (Ergonomics) 379M-&gt;322M(455M) 9.759ms</span><br><span class="line">[0.419s][info   ][gc,cpu         ] GC(46) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.422s][info   ][gc,start       ] GC(47) Pause Full (Ergonomics)</span><br><span class="line">[0.422s][info   ][gc,phases,start] GC(47) Marking Phase</span><br><span class="line">[0.424s][info   ][gc,phases      ] GC(47) Marking Phase 1.691ms</span><br><span class="line">[0.424s][info   ][gc,phases,start] GC(47) Summary Phase</span><br><span class="line">[0.424s][info   ][gc,phases      ] GC(47) Summary Phase 0.026ms</span><br><span class="line">[0.424s][info   ][gc,phases,start] GC(47) Adjust Roots</span><br><span class="line">[0.424s][info   ][gc,phases      ] GC(47) Adjust Roots 0.139ms</span><br><span class="line">[0.424s][info   ][gc,phases,start] GC(47) Compaction Phase</span><br><span class="line">[0.429s][info   ][gc,phases      ] GC(47) Compaction Phase 4.712ms</span><br><span class="line">[0.429s][info   ][gc,phases,start] GC(47) Post Compact</span><br><span class="line">[0.429s][info   ][gc,phases      ] GC(47) Post Compact 0.166ms</span><br><span class="line">[0.429s][info   ][gc,heap        ] GC(47) PSYoungGen: 58864K(116736K)-&gt;0K(116736K) Eden: 58864K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.429s][info   ][gc,heap        ] GC(47) ParOldGen: 330388K(349696K)-&gt;328098K(349696K)</span><br><span class="line">[0.429s][info   ][gc,metaspace   ] GC(47) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.429s][info   ][gc             ] GC(47) Pause Full (Ergonomics) 380M-&gt;320M(455M) 6.936ms</span><br><span class="line">[0.429s][info   ][gc,cpu         ] GC(47) User=0.04s Sys=0.00s Real=0.01s</span><br><span class="line">[0.432s][info   ][gc,start       ] GC(48) Pause Full (Ergonomics)</span><br><span class="line">[0.432s][info   ][gc,phases,start] GC(48) Marking Phase</span><br><span class="line">[0.434s][info   ][gc,phases      ] GC(48) Marking Phase 1.833ms</span><br><span class="line">[0.434s][info   ][gc,phases,start] GC(48) Summary Phase</span><br><span class="line">[0.434s][info   ][gc,phases      ] GC(48) Summary Phase 0.018ms</span><br><span class="line">[0.434s][info   ][gc,phases,start] GC(48) Adjust Roots</span><br><span class="line">[0.434s][info   ][gc,phases      ] GC(48) Adjust Roots 0.134ms</span><br><span class="line">[0.434s][info   ][gc,phases,start] GC(48) Compaction Phase</span><br><span class="line">[0.439s][info   ][gc,phases      ] GC(48) Compaction Phase 5.470ms</span><br><span class="line">[0.439s][info   ][gc,phases,start] GC(48) Post Compact</span><br><span class="line">[0.440s][info   ][gc,phases      ] GC(48) Post Compact 0.162ms</span><br><span class="line">[0.440s][info   ][gc,heap        ] GC(48) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.440s][info   ][gc,heap        ] GC(48) ParOldGen: 328098K(349696K)-&gt;329754K(349696K)</span><br><span class="line">[0.440s][info   ][gc,metaspace   ] GC(48) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.440s][info   ][gc             ] GC(48) Pause Full (Ergonomics) 377M-&gt;322M(455M) 7.822ms</span><br><span class="line">[0.440s][info   ][gc,cpu         ] GC(48) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.443s][info   ][gc,start       ] GC(49) Pause Full (Ergonomics)</span><br><span class="line">[0.443s][info   ][gc,phases,start] GC(49) Marking Phase</span><br><span class="line">[0.445s][info   ][gc,phases      ] GC(49) Marking Phase 2.241ms</span><br><span class="line">[0.445s][info   ][gc,phases,start] GC(49) Summary Phase</span><br><span class="line">[0.445s][info   ][gc,phases      ] GC(49) Summary Phase 0.014ms</span><br><span class="line">[0.445s][info   ][gc,phases,start] GC(49) Adjust Roots</span><br><span class="line">[0.445s][info   ][gc,phases      ] GC(49) Adjust Roots 0.148ms</span><br><span class="line">[0.445s][info   ][gc,phases,start] GC(49) Compaction Phase</span><br><span class="line">[0.451s][info   ][gc,phases      ] GC(49) Compaction Phase 5.532ms</span><br><span class="line">[0.451s][info   ][gc,phases,start] GC(49) Post Compact</span><br><span class="line">[0.451s][info   ][gc,phases      ] GC(49) Post Compact 0.171ms</span><br><span class="line">[0.451s][info   ][gc,heap        ] GC(49) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.451s][info   ][gc,heap        ] GC(49) ParOldGen: 329754K(349696K)-&gt;329787K(349696K)</span><br><span class="line">[0.451s][info   ][gc,metaspace   ] GC(49) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.451s][info   ][gc             ] GC(49) Pause Full (Ergonomics) 379M-&gt;322M(455M) 8.304ms</span><br><span class="line">[0.451s][info   ][gc,cpu         ] GC(49) User=0.03s Sys=0.01s Real=0.00s</span><br><span class="line">[0.454s][info   ][gc,start       ] GC(50) Pause Full (Ergonomics)</span><br><span class="line">[0.454s][info   ][gc,phases,start] GC(50) Marking Phase</span><br><span class="line">[0.455s][info   ][gc,phases      ] GC(50) Marking Phase 1.630ms</span><br><span class="line">[0.455s][info   ][gc,phases,start] GC(50) Summary Phase</span><br><span class="line">[0.455s][info   ][gc,phases      ] GC(50) Summary Phase 0.014ms</span><br><span class="line">[0.455s][info   ][gc,phases,start] GC(50) Adjust Roots</span><br><span class="line">[0.456s][info   ][gc,phases      ] GC(50) Adjust Roots 0.144ms</span><br><span class="line">[0.456s][info   ][gc,phases,start] GC(50) Compaction Phase</span><br><span class="line">[0.461s][info   ][gc,phases      ] GC(50) Compaction Phase 5.108ms</span><br><span class="line">[0.461s][info   ][gc,phases,start] GC(50) Post Compact</span><br><span class="line">[0.461s][info   ][gc,phases      ] GC(50) Post Compact 0.147ms</span><br><span class="line">[0.461s][info   ][gc,heap        ] GC(50) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.461s][info   ][gc,heap        ] GC(50) ParOldGen: 329787K(349696K)-&gt;333951K(349696K)</span><br><span class="line">[0.461s][info   ][gc,metaspace   ] GC(50) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.461s][info   ][gc             ] GC(50) Pause Full (Ergonomics) 379M-&gt;326M(455M) 7.241ms</span><br><span class="line">[0.461s][info   ][gc,cpu         ] GC(50) User=0.04s Sys=0.00s Real=0.00s</span><br><span class="line">[0.464s][info   ][gc,start       ] GC(51) Pause Full (Ergonomics)</span><br><span class="line">[0.464s][info   ][gc,phases,start] GC(51) Marking Phase</span><br><span class="line">[0.465s][info   ][gc,phases      ] GC(51) Marking Phase 1.691ms</span><br><span class="line">[0.465s][info   ][gc,phases,start] GC(51) Summary Phase</span><br><span class="line">[0.465s][info   ][gc,phases      ] GC(51) Summary Phase 0.014ms</span><br><span class="line">[0.465s][info   ][gc,phases,start] GC(51) Adjust Roots</span><br><span class="line">[0.466s][info   ][gc,phases      ] GC(51) Adjust Roots 0.133ms</span><br><span class="line">[0.466s][info   ][gc,phases,start] GC(51) Compaction Phase</span><br><span class="line">[0.471s][info   ][gc,phases      ] GC(51) Compaction Phase 5.033ms</span><br><span class="line">[0.471s][info   ][gc,phases,start] GC(51) Post Compact</span><br><span class="line">[0.471s][info   ][gc,phases      ] GC(51) Post Compact 0.160ms</span><br><span class="line">[0.471s][info   ][gc,heap        ] GC(51) PSYoungGen: 58617K(116736K)-&gt;0K(116736K) Eden: 58617K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.471s][info   ][gc,heap        ] GC(51) ParOldGen: 333951K(349696K)-&gt;333136K(349696K)</span><br><span class="line">[0.471s][info   ][gc,metaspace   ] GC(51) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.471s][info   ][gc             ] GC(51) Pause Full (Ergonomics) 383M-&gt;325M(455M) 7.240ms</span><br><span class="line">[0.471s][info   ][gc,cpu         ] GC(51) User=0.03s Sys=0.00s Real=0.00s</span><br><span class="line">[0.475s][info   ][gc,start       ] GC(52) Pause Full (Ergonomics)</span><br><span class="line">[0.475s][info   ][gc,phases,start] GC(52) Marking Phase</span><br><span class="line">[0.476s][info   ][gc,phases      ] GC(52) Marking Phase 1.368ms</span><br><span class="line">[0.476s][info   ][gc,phases,start] GC(52) Summary Phase</span><br><span class="line">[0.476s][info   ][gc,phases      ] GC(52) Summary Phase 0.015ms</span><br><span class="line">[0.476s][info   ][gc,phases,start] GC(52) Adjust Roots</span><br><span class="line">[0.476s][info   ][gc,phases      ] GC(52) Adjust Roots 0.167ms</span><br><span class="line">[0.476s][info   ][gc,phases,start] GC(52) Compaction Phase</span><br><span class="line">[0.483s][info   ][gc,phases      ] GC(52) Compaction Phase 6.434ms</span><br><span class="line">[0.483s][info   ][gc,phases,start] GC(52) Post Compact</span><br><span class="line">[0.483s][info   ][gc,phases      ] GC(52) Post Compact 0.160ms</span><br><span class="line">[0.483s][info   ][gc,heap        ] GC(52) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.483s][info   ][gc,heap        ] GC(52) ParOldGen: 333136K(349696K)-&gt;335627K(349696K)</span><br><span class="line">[0.483s][info   ][gc,metaspace   ] GC(52) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.483s][info   ][gc             ] GC(52) Pause Full (Ergonomics) 382M-&gt;327M(455M) 8.342ms</span><br><span class="line">[0.483s][info   ][gc,cpu         ] GC(52) User=0.04s Sys=0.00s Real=0.01s</span><br><span class="line">[0.486s][info   ][gc,start       ] GC(53) Pause Full (Ergonomics)</span><br><span class="line">[0.486s][info   ][gc,phases,start] GC(53) Marking Phase</span><br><span class="line">[0.487s][info   ][gc,phases      ] GC(53) Marking Phase 1.415ms</span><br><span class="line">[0.487s][info   ][gc,phases,start] GC(53) Summary Phase</span><br><span class="line">[0.487s][info   ][gc,phases      ] GC(53) Summary Phase 0.013ms</span><br><span class="line">[0.487s][info   ][gc,phases,start] GC(53) Adjust Roots</span><br><span class="line">[0.487s][info   ][gc,phases      ] GC(53) Adjust Roots 0.125ms</span><br><span class="line">[0.487s][info   ][gc,phases,start] GC(53) Compaction Phase</span><br><span class="line">[0.493s][info   ][gc,phases      ] GC(53) Compaction Phase 5.581ms</span><br><span class="line">[0.493s][info   ][gc,phases,start] GC(53) Post Compact</span><br><span class="line">[0.493s][info   ][gc,phases      ] GC(53) Post Compact 0.169ms</span><br><span class="line">[0.493s][info   ][gc,heap        ] GC(53) PSYoungGen: 58857K(116736K)-&gt;0K(116736K) Eden: 58857K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.493s][info   ][gc,heap        ] GC(53) ParOldGen: 335627K(349696K)-&gt;336226K(349696K)</span><br><span class="line">[0.493s][info   ][gc,metaspace   ] GC(53) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.493s][info   ][gc             ] GC(53) Pause Full (Ergonomics) 385M-&gt;328M(455M) 7.470ms</span><br><span class="line">[0.493s][info   ][gc,cpu         ] GC(53) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.496s][info   ][gc,start       ] GC(54) Pause Full (Ergonomics)</span><br><span class="line">[0.496s][info   ][gc,phases,start] GC(54) Marking Phase</span><br><span class="line">[0.498s][info   ][gc,phases      ] GC(54) Marking Phase 2.113ms</span><br><span class="line">[0.498s][info   ][gc,phases,start] GC(54) Summary Phase</span><br><span class="line">[0.498s][info   ][gc,phases      ] GC(54) Summary Phase 0.017ms</span><br><span class="line">[0.498s][info   ][gc,phases,start] GC(54) Adjust Roots</span><br><span class="line">[0.499s][info   ][gc,phases      ] GC(54) Adjust Roots 0.131ms</span><br><span class="line">[0.499s][info   ][gc,phases,start] GC(54) Compaction Phase</span><br><span class="line">[0.504s][info   ][gc,phases      ] GC(54) Compaction Phase 5.501ms</span><br><span class="line">[0.504s][info   ][gc,phases,start] GC(54) Post Compact</span><br><span class="line">[0.504s][info   ][gc,phases      ] GC(54) Post Compact 0.164ms</span><br><span class="line">[0.504s][info   ][gc,heap        ] GC(54) PSYoungGen: 58838K(116736K)-&gt;0K(116736K) Eden: 58838K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.504s][info   ][gc,heap        ] GC(54) ParOldGen: 336226K(349696K)-&gt;333074K(349696K)</span><br><span class="line">[0.504s][info   ][gc,metaspace   ] GC(54) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.504s][info   ][gc             ] GC(54) Pause Full (Ergonomics) 385M-&gt;325M(455M) 8.120ms</span><br><span class="line">[0.504s][info   ][gc,cpu         ] GC(54) User=0.03s Sys=0.01s Real=0.01s</span><br><span class="line">[0.507s][info   ][gc,start       ] GC(55) Pause Full (Ergonomics)</span><br><span class="line">[0.507s][info   ][gc,phases,start] GC(55) Marking Phase</span><br><span class="line">[0.509s][info   ][gc,phases      ] GC(55) Marking Phase 1.806ms</span><br><span class="line">[0.509s][info   ][gc,phases,start] GC(55) Summary Phase</span><br><span class="line">[0.509s][info   ][gc,phases      ] GC(55) Summary Phase 0.017ms</span><br><span class="line">[0.509s][info   ][gc,phases,start] GC(55) Adjust Roots</span><br><span class="line">[0.509s][info   ][gc,phases      ] GC(55) Adjust Roots 0.145ms</span><br><span class="line">[0.509s][info   ][gc,phases,start] GC(55) Compaction Phase</span><br><span class="line">[0.516s][info   ][gc,phases      ] GC(55) Compaction Phase 6.341ms</span><br><span class="line">[0.516s][info   ][gc,phases,start] GC(55) Post Compact</span><br><span class="line">[0.516s][info   ][gc,phases      ] GC(55) Post Compact 0.176ms</span><br><span class="line">[0.516s][info   ][gc,heap        ] GC(55) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.516s][info   ][gc,heap        ] GC(55) ParOldGen: 333074K(349696K)-&gt;336203K(349696K)</span><br><span class="line">[0.516s][info   ][gc,metaspace   ] GC(55) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.516s][info   ][gc             ] GC(55) Pause Full (Ergonomics) 382M-&gt;328M(455M) 8.700ms</span><br><span class="line">[0.516s][info   ][gc,cpu         ] GC(55) User=0.04s Sys=0.00s Real=0.01s</span><br><span class="line">[0.520s][info   ][gc,start       ] GC(56) Pause Full (Ergonomics)</span><br><span class="line">[0.520s][info   ][gc,phases,start] GC(56) Marking Phase</span><br><span class="line">[0.522s][info   ][gc,phases      ] GC(56) Marking Phase 2.003ms</span><br><span class="line">[0.522s][info   ][gc,phases,start] GC(56) Summary Phase</span><br><span class="line">[0.522s][info   ][gc,phases      ] GC(56) Summary Phase 0.013ms</span><br><span class="line">[0.522s][info   ][gc,phases,start] GC(56) Adjust Roots</span><br><span class="line">[0.523s][info   ][gc,phases      ] GC(56) Adjust Roots 0.145ms</span><br><span class="line">[0.523s][info   ][gc,phases,start] GC(56) Compaction Phase</span><br><span class="line">[0.527s][info   ][gc,phases      ] GC(56) Compaction Phase 4.909ms</span><br><span class="line">[0.527s][info   ][gc,phases,start] GC(56) Post Compact</span><br><span class="line">[0.528s][info   ][gc,phases      ] GC(56) Post Compact 0.170ms</span><br><span class="line">[0.528s][info   ][gc,heap        ] GC(56) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.528s][info   ][gc,heap        ] GC(56) ParOldGen: 336203K(349696K)-&gt;333268K(349696K)</span><br><span class="line">[0.528s][info   ][gc,metaspace   ] GC(56) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.528s][info   ][gc             ] GC(56) Pause Full (Ergonomics) 385M-&gt;325M(455M) 7.453ms</span><br><span class="line">[0.528s][info   ][gc,cpu         ] GC(56) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.531s][info   ][gc,start       ] GC(57) Pause Full (Ergonomics)</span><br><span class="line">[0.531s][info   ][gc,phases,start] GC(57) Marking Phase</span><br><span class="line">[0.533s][info   ][gc,phases      ] GC(57) Marking Phase 2.016ms</span><br><span class="line">[0.533s][info   ][gc,phases,start] GC(57) Summary Phase</span><br><span class="line">[0.533s][info   ][gc,phases      ] GC(57) Summary Phase 0.014ms</span><br><span class="line">[0.533s][info   ][gc,phases,start] GC(57) Adjust Roots</span><br><span class="line">[0.533s][info   ][gc,phases      ] GC(57) Adjust Roots 0.382ms</span><br><span class="line">[0.534s][info   ][gc,phases,start] GC(57) Compaction Phase</span><br><span class="line">[0.540s][info   ][gc,phases      ] GC(57) Compaction Phase 6.359ms</span><br><span class="line">[0.540s][info   ][gc,phases,start] GC(57) Post Compact</span><br><span class="line">[0.540s][info   ][gc,phases      ] GC(57) Post Compact 0.189ms</span><br><span class="line">[0.540s][info   ][gc,heap        ] GC(57) PSYoungGen: 58677K(116736K)-&gt;0K(116736K) Eden: 58677K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.540s][info   ][gc,heap        ] GC(57) ParOldGen: 333268K(349696K)-&gt;330756K(349696K)</span><br><span class="line">[0.540s][info   ][gc,metaspace   ] GC(57) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.540s][info   ][gc             ] GC(57) Pause Full (Ergonomics) 382M-&gt;323M(455M) 9.153ms</span><br><span class="line">[0.540s][info   ][gc,cpu         ] GC(57) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.543s][info   ][gc,start       ] GC(58) Pause Full (Ergonomics)</span><br><span class="line">[0.543s][info   ][gc,phases,start] GC(58) Marking Phase</span><br><span class="line">[0.545s][info   ][gc,phases      ] GC(58) Marking Phase 1.607ms</span><br><span class="line">[0.545s][info   ][gc,phases,start] GC(58) Summary Phase</span><br><span class="line">[0.545s][info   ][gc,phases      ] GC(58) Summary Phase 0.014ms</span><br><span class="line">[0.545s][info   ][gc,phases,start] GC(58) Adjust Roots</span><br><span class="line">[0.545s][info   ][gc,phases      ] GC(58) Adjust Roots 0.199ms</span><br><span class="line">[0.545s][info   ][gc,phases,start] GC(58) Compaction Phase</span><br><span class="line">[0.550s][info   ][gc,phases      ] GC(58) Compaction Phase 5.526ms</span><br><span class="line">[0.550s][info   ][gc,phases,start] GC(58) Post Compact</span><br><span class="line">[0.551s][info   ][gc,phases      ] GC(58) Post Compact 0.183ms</span><br><span class="line">[0.551s][info   ][gc,heap        ] GC(58) PSYoungGen: 58547K(116736K)-&gt;0K(116736K) Eden: 58547K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.551s][info   ][gc,heap        ] GC(58) ParOldGen: 330756K(349696K)-&gt;331991K(349696K)</span><br><span class="line">[0.551s][info   ][gc,metaspace   ] GC(58) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.551s][info   ][gc             ] GC(58) Pause Full (Ergonomics) 380M-&gt;324M(455M) 7.739ms</span><br><span class="line">[0.551s][info   ][gc,cpu         ] GC(58) User=0.03s Sys=0.01s Real=0.00s</span><br><span class="line">[0.553s][info   ][gc,start       ] GC(59) Pause Full (Ergonomics)</span><br><span class="line">[0.553s][info   ][gc,phases,start] GC(59) Marking Phase</span><br><span class="line">[0.555s][info   ][gc,phases      ] GC(59) Marking Phase 1.991ms</span><br><span class="line">[0.555s][info   ][gc,phases,start] GC(59) Summary Phase</span><br><span class="line">[0.555s][info   ][gc,phases      ] GC(59) Summary Phase 0.016ms</span><br><span class="line">[0.555s][info   ][gc,phases,start] GC(59) Adjust Roots</span><br><span class="line">[0.556s][info   ][gc,phases      ] GC(59) Adjust Roots 0.163ms</span><br><span class="line">[0.556s][info   ][gc,phases,start] GC(59) Compaction Phase</span><br><span class="line">[0.561s][info   ][gc,phases      ] GC(59) Compaction Phase 5.049ms</span><br><span class="line">[0.561s][info   ][gc,phases,start] GC(59) Post Compact</span><br><span class="line">[0.561s][info   ][gc,phases      ] GC(59) Post Compact 0.173ms</span><br><span class="line">[0.561s][info   ][gc,heap        ] GC(59) PSYoungGen: 58488K(116736K)-&gt;0K(116736K) Eden: 58488K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.561s][info   ][gc,heap        ] GC(59) ParOldGen: 331991K(349696K)-&gt;330268K(349696K)</span><br><span class="line">[0.561s][info   ][gc,metaspace   ] GC(59) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.561s][info   ][gc             ] GC(59) Pause Full (Ergonomics) 381M-&gt;322M(455M) 7.630ms</span><br><span class="line">[0.561s][info   ][gc,cpu         ] GC(59) User=0.03s Sys=0.00s Real=0.00s</span><br><span class="line">[0.564s][info   ][gc,start       ] GC(60) Pause Full (Ergonomics)</span><br><span class="line">[0.564s][info   ][gc,phases,start] GC(60) Marking Phase</span><br><span class="line">[0.566s][info   ][gc,phases      ] GC(60) Marking Phase 1.843ms</span><br><span class="line">[0.566s][info   ][gc,phases,start] GC(60) Summary Phase</span><br><span class="line">[0.566s][info   ][gc,phases      ] GC(60) Summary Phase 0.013ms</span><br><span class="line">[0.566s][info   ][gc,phases,start] GC(60) Adjust Roots</span><br><span class="line">[0.566s][info   ][gc,phases      ] GC(60) Adjust Roots 0.191ms</span><br><span class="line">[0.566s][info   ][gc,phases,start] GC(60) Compaction Phase</span><br><span class="line">[0.573s][info   ][gc,phases      ] GC(60) Compaction Phase 6.442ms</span><br><span class="line">[0.573s][info   ][gc,phases,start] GC(60) Post Compact</span><br><span class="line">[0.573s][info   ][gc,phases      ] GC(60) Post Compact 0.171ms</span><br><span class="line">[0.573s][info   ][gc,heap        ] GC(60) PSYoungGen: 58733K(116736K)-&gt;0K(116736K) Eden: 58733K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.573s][info   ][gc,heap        ] GC(60) ParOldGen: 330268K(349696K)-&gt;332936K(349696K)</span><br><span class="line">[0.573s][info   ][gc,metaspace   ] GC(60) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.573s][info   ][gc             ] GC(60) Pause Full (Ergonomics) 379M-&gt;325M(455M) 8.837ms</span><br><span class="line">[0.573s][info   ][gc,cpu         ] GC(60) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.576s][info   ][gc,start       ] GC(61) Pause Full (Ergonomics)</span><br><span class="line">[0.576s][info   ][gc,phases,start] GC(61) Marking Phase</span><br><span class="line">[0.578s][info   ][gc,phases      ] GC(61) Marking Phase 2.161ms</span><br><span class="line">[0.578s][info   ][gc,phases,start] GC(61) Summary Phase</span><br><span class="line">[0.578s][info   ][gc,phases      ] GC(61) Summary Phase 0.014ms</span><br><span class="line">[0.578s][info   ][gc,phases,start] GC(61) Adjust Roots</span><br><span class="line">[0.578s][info   ][gc,phases      ] GC(61) Adjust Roots 0.146ms</span><br><span class="line">[0.578s][info   ][gc,phases,start] GC(61) Compaction Phase</span><br><span class="line">[0.584s][info   ][gc,phases      ] GC(61) Compaction Phase 5.470ms</span><br><span class="line">[0.584s][info   ][gc,phases,start] GC(61) Post Compact</span><br><span class="line">[0.584s][info   ][gc,phases      ] GC(61) Post Compact 0.166ms</span><br><span class="line">[0.584s][info   ][gc,heap        ] GC(61) PSYoungGen: 58865K(116736K)-&gt;0K(116736K) Eden: 58865K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.584s][info   ][gc,heap        ] GC(61) ParOldGen: 332936K(349696K)-&gt;330348K(349696K)</span><br><span class="line">[0.584s][info   ][gc,metaspace   ] GC(61) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.584s][info   ][gc             ] GC(61) Pause Full (Ergonomics) 382M-&gt;322M(455M) 8.180ms</span><br><span class="line">[0.584s][info   ][gc,cpu         ] GC(61) User=0.04s Sys=0.00s Real=0.01s</span><br><span class="line">[0.586s][info   ][gc,start       ] GC(62) Pause Full (Ergonomics)</span><br><span class="line">[0.587s][info   ][gc,phases,start] GC(62) Marking Phase</span><br><span class="line">[0.589s][info   ][gc,phases      ] GC(62) Marking Phase 2.143ms</span><br><span class="line">[0.589s][info   ][gc,phases,start] GC(62) Summary Phase</span><br><span class="line">[0.589s][info   ][gc,phases      ] GC(62) Summary Phase 0.024ms</span><br><span class="line">[0.589s][info   ][gc,phases,start] GC(62) Adjust Roots</span><br><span class="line">[0.589s][info   ][gc,phases      ] GC(62) Adjust Roots 0.143ms</span><br><span class="line">[0.589s][info   ][gc,phases,start] GC(62) Compaction Phase</span><br><span class="line">[0.594s][info   ][gc,phases      ] GC(62) Compaction Phase 4.937ms</span><br><span class="line">[0.594s][info   ][gc,phases,start] GC(62) Post Compact</span><br><span class="line">[0.594s][info   ][gc,phases      ] GC(62) Post Compact 0.176ms</span><br><span class="line">[0.594s][info   ][gc,heap        ] GC(62) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.594s][info   ][gc,heap        ] GC(62) ParOldGen: 330348K(349696K)-&gt;327859K(349696K)</span><br><span class="line">[0.594s][info   ][gc,metaspace   ] GC(62) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.594s][info   ][gc             ] GC(62) Pause Full (Ergonomics) 380M-&gt;320M(455M) 7.643ms</span><br><span class="line">[0.594s][info   ][gc,cpu         ] GC(62) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.597s][info   ][gc,start       ] GC(63) Pause Full (Ergonomics)</span><br><span class="line">[0.597s][info   ][gc,phases,start] GC(63) Marking Phase</span><br><span class="line">[0.599s][info   ][gc,phases      ] GC(63) Marking Phase 1.793ms</span><br><span class="line">[0.599s][info   ][gc,phases,start] GC(63) Summary Phase</span><br><span class="line">[0.599s][info   ][gc,phases      ] GC(63) Summary Phase 0.024ms</span><br><span class="line">[0.599s][info   ][gc,phases,start] GC(63) Adjust Roots</span><br><span class="line">[0.599s][info   ][gc,phases      ] GC(63) Adjust Roots 0.176ms</span><br><span class="line">[0.599s][info   ][gc,phases,start] GC(63) Compaction Phase</span><br><span class="line">[0.605s][info   ][gc,phases      ] GC(63) Compaction Phase 6.124ms</span><br><span class="line">[0.605s][info   ][gc,phases,start] GC(63) Post Compact</span><br><span class="line">[0.605s][info   ][gc,phases      ] GC(63) Post Compact 0.158ms</span><br><span class="line">[0.605s][info   ][gc,heap        ] GC(63) PSYoungGen: 58766K(116736K)-&gt;0K(116736K) Eden: 58766K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.605s][info   ][gc,heap        ] GC(63) ParOldGen: 327859K(349696K)-&gt;330218K(349696K)</span><br><span class="line">[0.605s][info   ][gc,metaspace   ] GC(63) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.605s][info   ][gc             ] GC(63) Pause Full (Ergonomics) 377M-&gt;322M(455M) 8.541ms</span><br><span class="line">[0.605s][info   ][gc,cpu         ] GC(63) User=0.03s Sys=0.01s Real=0.01s</span><br><span class="line">[0.608s][info   ][gc,start       ] GC(64) Pause Full (Ergonomics)</span><br><span class="line">[0.608s][info   ][gc,phases,start] GC(64) Marking Phase</span><br><span class="line">[0.610s][info   ][gc,phases      ] GC(64) Marking Phase 1.500ms</span><br><span class="line">[0.610s][info   ][gc,phases,start] GC(64) Summary Phase</span><br><span class="line">[0.610s][info   ][gc,phases      ] GC(64) Summary Phase 0.013ms</span><br><span class="line">[0.610s][info   ][gc,phases,start] GC(64) Adjust Roots</span><br><span class="line">[0.610s][info   ][gc,phases      ] GC(64) Adjust Roots 0.141ms</span><br><span class="line">[0.610s][info   ][gc,phases,start] GC(64) Compaction Phase</span><br><span class="line">[0.616s][info   ][gc,phases      ] GC(64) Compaction Phase 6.293ms</span><br><span class="line">[0.616s][info   ][gc,phases,start] GC(64) Post Compact</span><br><span class="line">[0.616s][info   ][gc,phases      ] GC(64) Post Compact 0.204ms</span><br><span class="line">[0.617s][info   ][gc,heap        ] GC(64) PSYoungGen: 58592K(116736K)-&gt;0K(116736K) Eden: 58592K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.617s][info   ][gc,heap        ] GC(64) ParOldGen: 330218K(349696K)-&gt;330538K(349696K)</span><br><span class="line">[0.617s][info   ][gc,metaspace   ] GC(64) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.617s][info   ][gc             ] GC(64) Pause Full (Ergonomics) 379M-&gt;322M(455M) 8.385ms</span><br><span class="line">[0.617s][info   ][gc,cpu         ] GC(64) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.620s][info   ][gc,start       ] GC(65) Pause Full (Ergonomics)</span><br><span class="line">[0.620s][info   ][gc,phases,start] GC(65) Marking Phase</span><br><span class="line">[0.621s][info   ][gc,phases      ] GC(65) Marking Phase 1.650ms</span><br><span class="line">[0.621s][info   ][gc,phases,start] GC(65) Summary Phase</span><br><span class="line">[0.621s][info   ][gc,phases      ] GC(65) Summary Phase 0.015ms</span><br><span class="line">[0.621s][info   ][gc,phases,start] GC(65) Adjust Roots</span><br><span class="line">[0.621s][info   ][gc,phases      ] GC(65) Adjust Roots 0.133ms</span><br><span class="line">[0.621s][info   ][gc,phases,start] GC(65) Compaction Phase</span><br><span class="line">[0.627s][info   ][gc,phases      ] GC(65) Compaction Phase 5.194ms</span><br><span class="line">[0.627s][info   ][gc,phases,start] GC(65) Post Compact</span><br><span class="line">[0.627s][info   ][gc,phases      ] GC(65) Post Compact 0.157ms</span><br><span class="line">[0.627s][info   ][gc,heap        ] GC(65) PSYoungGen: 58406K(116736K)-&gt;0K(116736K) Eden: 58406K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.627s][info   ][gc,heap        ] GC(65) ParOldGen: 330538K(349696K)-&gt;332417K(349696K)</span><br><span class="line">[0.627s][info   ][gc,metaspace   ] GC(65) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.627s][info   ][gc             ] GC(65) Pause Full (Ergonomics) 379M-&gt;324M(455M) 7.320ms</span><br><span class="line">[0.627s][info   ][gc,cpu         ] GC(65) User=0.04s Sys=0.00s Real=0.01s</span><br><span class="line">[0.630s][info   ][gc,start       ] GC(66) Pause Full (Ergonomics)</span><br><span class="line">[0.630s][info   ][gc,phases,start] GC(66) Marking Phase</span><br><span class="line">[0.632s][info   ][gc,phases      ] GC(66) Marking Phase 1.899ms</span><br><span class="line">[0.632s][info   ][gc,phases,start] GC(66) Summary Phase</span><br><span class="line">[0.632s][info   ][gc,phases      ] GC(66) Summary Phase 0.014ms</span><br><span class="line">[0.632s][info   ][gc,phases,start] GC(66) Adjust Roots</span><br><span class="line">[0.632s][info   ][gc,phases      ] GC(66) Adjust Roots 0.144ms</span><br><span class="line">[0.632s][info   ][gc,phases,start] GC(66) Compaction Phase</span><br><span class="line">[0.638s][info   ][gc,phases      ] GC(66) Compaction Phase 5.538ms</span><br><span class="line">[0.638s][info   ][gc,phases,start] GC(66) Post Compact</span><br><span class="line">[0.638s][info   ][gc,phases      ] GC(66) Post Compact 0.152ms</span><br><span class="line">[0.638s][info   ][gc,heap        ] GC(66) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.638s][info   ][gc,heap        ] GC(66) ParOldGen: 332417K(349696K)-&gt;333424K(349696K)</span><br><span class="line">[0.638s][info   ][gc,metaspace   ] GC(66) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.638s][info   ][gc             ] GC(66) Pause Full (Ergonomics) 382M-&gt;325M(455M) 7.917ms</span><br><span class="line">[0.638s][info   ][gc,cpu         ] GC(66) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.641s][info   ][gc,start       ] GC(67) Pause Full (Ergonomics)</span><br><span class="line">[0.641s][info   ][gc,phases,start] GC(67) Marking Phase</span><br><span class="line">[0.642s][info   ][gc,phases      ] GC(67) Marking Phase 1.727ms</span><br><span class="line">[0.642s][info   ][gc,phases,start] GC(67) Summary Phase</span><br><span class="line">[0.642s][info   ][gc,phases      ] GC(67) Summary Phase 0.017ms</span><br><span class="line">[0.642s][info   ][gc,phases,start] GC(67) Adjust Roots</span><br><span class="line">[0.643s][info   ][gc,phases      ] GC(67) Adjust Roots 0.148ms</span><br><span class="line">[0.643s][info   ][gc,phases,start] GC(67) Compaction Phase</span><br><span class="line">[0.648s][info   ][gc,phases      ] GC(67) Compaction Phase 5.819ms</span><br><span class="line">[0.648s][info   ][gc,phases,start] GC(67) Post Compact</span><br><span class="line">[0.649s][info   ][gc,phases      ] GC(67) Post Compact 0.203ms</span><br><span class="line">[0.649s][info   ][gc,heap        ] GC(67) PSYoungGen: 58770K(116736K)-&gt;0K(116736K) Eden: 58770K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.649s][info   ][gc,heap        ] GC(67) ParOldGen: 333424K(349696K)-&gt;337292K(349696K)</span><br><span class="line">[0.649s][info   ][gc,metaspace   ] GC(67) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.649s][info   ][gc             ] GC(67) Pause Full (Ergonomics) 383M-&gt;329M(455M) 8.141ms</span><br><span class="line">[0.649s][info   ][gc,cpu         ] GC(67) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.652s][info   ][gc,start       ] GC(68) Pause Full (Ergonomics)</span><br><span class="line">[0.652s][info   ][gc,phases,start] GC(68) Marking Phase</span><br><span class="line">[0.654s][info   ][gc,phases      ] GC(68) Marking Phase 2.332ms</span><br><span class="line">[0.654s][info   ][gc,phases,start] GC(68) Summary Phase</span><br><span class="line">[0.654s][info   ][gc,phases      ] GC(68) Summary Phase 0.017ms</span><br><span class="line">[0.654s][info   ][gc,phases,start] GC(68) Adjust Roots</span><br><span class="line">[0.654s][info   ][gc,phases      ] GC(68) Adjust Roots 0.159ms</span><br><span class="line">[0.654s][info   ][gc,phases,start] GC(68) Compaction Phase</span><br><span class="line">[0.659s][info   ][gc,phases      ] GC(68) Compaction Phase 5.186ms</span><br><span class="line">[0.660s][info   ][gc,phases,start] GC(68) Post Compact</span><br><span class="line">[0.660s][info   ][gc,phases      ] GC(68) Post Compact 0.163ms</span><br><span class="line">[0.660s][info   ][gc,heap        ] GC(68) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.660s][info   ][gc,heap        ] GC(68) ParOldGen: 337292K(349696K)-&gt;339280K(349696K)</span><br><span class="line">[0.660s][info   ][gc,metaspace   ] GC(68) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.660s][info   ][gc             ] GC(68) Pause Full (Ergonomics) 386M-&gt;331M(455M) 8.047ms</span><br><span class="line">[0.660s][info   ][gc,cpu         ] GC(68) User=0.03s Sys=0.01s Real=0.01s</span><br><span class="line">[0.664s][info   ][gc,start       ] GC(69) Pause Full (Ergonomics)</span><br><span class="line">[0.664s][info   ][gc,phases,start] GC(69) Marking Phase</span><br><span class="line">[0.666s][info   ][gc,phases      ] GC(69) Marking Phase 2.091ms</span><br><span class="line">[0.666s][info   ][gc,phases,start] GC(69) Summary Phase</span><br><span class="line">[0.666s][info   ][gc,phases      ] GC(69) Summary Phase 0.019ms</span><br><span class="line">[0.666s][info   ][gc,phases,start] GC(69) Adjust Roots</span><br><span class="line">[0.666s][info   ][gc,phases      ] GC(69) Adjust Roots 0.141ms</span><br><span class="line">[0.666s][info   ][gc,phases,start] GC(69) Compaction Phase</span><br><span class="line">[0.672s][info   ][gc,phases      ] GC(69) Compaction Phase 5.529ms</span><br><span class="line">[0.672s][info   ][gc,phases,start] GC(69) Post Compact</span><br><span class="line">[0.672s][info   ][gc,phases      ] GC(69) Post Compact 0.168ms</span><br><span class="line">[0.672s][info   ][gc,heap        ] GC(69) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.672s][info   ][gc,heap        ] GC(69) ParOldGen: 339280K(349696K)-&gt;341907K(349696K)</span><br><span class="line">[0.672s][info   ][gc,metaspace   ] GC(69) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.672s][info   ][gc             ] GC(69) Pause Full (Ergonomics) 388M-&gt;333M(455M) 8.258ms</span><br><span class="line">[0.672s][info   ][gc,cpu         ] GC(69) User=0.03s Sys=0.00s Real=0.00s</span><br><span class="line">[0.675s][info   ][gc,start       ] GC(70) Pause Full (Ergonomics)</span><br><span class="line">[0.675s][info   ][gc,phases,start] GC(70) Marking Phase</span><br><span class="line">[0.677s][info   ][gc,phases      ] GC(70) Marking Phase 2.046ms</span><br><span class="line">[0.677s][info   ][gc,phases,start] GC(70) Summary Phase</span><br><span class="line">[0.677s][info   ][gc,phases      ] GC(70) Summary Phase 0.016ms</span><br><span class="line">[0.677s][info   ][gc,phases,start] GC(70) Adjust Roots</span><br><span class="line">[0.677s][info   ][gc,phases      ] GC(70) Adjust Roots 0.145ms</span><br><span class="line">[0.677s][info   ][gc,phases,start] GC(70) Compaction Phase</span><br><span class="line">[0.684s][info   ][gc,phases      ] GC(70) Compaction Phase 6.715ms</span><br><span class="line">[0.684s][info   ][gc,phases,start] GC(70) Post Compact</span><br><span class="line">[0.684s][info   ][gc,phases      ] GC(70) Post Compact 0.190ms</span><br><span class="line">[0.684s][info   ][gc,heap        ] GC(70) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.684s][info   ][gc,heap        ] GC(70) ParOldGen: 341907K(349696K)-&gt;340487K(349696K)</span><br><span class="line">[0.684s][info   ][gc,metaspace   ] GC(70) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.684s][info   ][gc             ] GC(70) Pause Full (Ergonomics) 391M-&gt;332M(455M) 9.337ms</span><br><span class="line">[0.684s][info   ][gc,cpu         ] GC(70) User=0.04s Sys=0.00s Real=0.01s</span><br><span class="line">[0.687s][info   ][gc,start       ] GC(71) Pause Full (Ergonomics)</span><br><span class="line">[0.687s][info   ][gc,phases,start] GC(71) Marking Phase</span><br><span class="line">[0.689s][info   ][gc,phases      ] GC(71) Marking Phase 2.016ms</span><br><span class="line">[0.689s][info   ][gc,phases,start] GC(71) Summary Phase</span><br><span class="line">[0.689s][info   ][gc,phases      ] GC(71) Summary Phase 0.016ms</span><br><span class="line">[0.689s][info   ][gc,phases,start] GC(71) Adjust Roots</span><br><span class="line">[0.689s][info   ][gc,phases      ] GC(71) Adjust Roots 0.132ms</span><br><span class="line">[0.689s][info   ][gc,phases,start] GC(71) Compaction Phase</span><br><span class="line">[0.695s][info   ][gc,phases      ] GC(71) Compaction Phase 5.310ms</span><br><span class="line">[0.695s][info   ][gc,phases,start] GC(71) Post Compact</span><br><span class="line">[0.695s][info   ][gc,phases      ] GC(71) Post Compact 0.160ms</span><br><span class="line">[0.695s][info   ][gc,heap        ] GC(71) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.695s][info   ][gc,heap        ] GC(71) ParOldGen: 340487K(349696K)-&gt;338549K(349696K)</span><br><span class="line">[0.695s][info   ][gc,metaspace   ] GC(71) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.695s][info   ][gc             ] GC(71) Pause Full (Ergonomics) 390M-&gt;330M(455M) 7.848ms</span><br><span class="line">[0.695s][info   ][gc,cpu         ] GC(71) User=0.04s Sys=0.00s Real=0.01s</span><br><span class="line">[0.699s][info   ][gc,start       ] GC(72) Pause Full (Ergonomics)</span><br><span class="line">[0.699s][info   ][gc,phases,start] GC(72) Marking Phase</span><br><span class="line">[0.702s][info   ][gc,phases      ] GC(72) Marking Phase 2.214ms</span><br><span class="line">[0.702s][info   ][gc,phases,start] GC(72) Summary Phase</span><br><span class="line">[0.702s][info   ][gc,phases      ] GC(72) Summary Phase 0.016ms</span><br><span class="line">[0.702s][info   ][gc,phases,start] GC(72) Adjust Roots</span><br><span class="line">[0.702s][info   ][gc,phases      ] GC(72) Adjust Roots 0.152ms</span><br><span class="line">[0.702s][info   ][gc,phases,start] GC(72) Compaction Phase</span><br><span class="line">[0.708s][info   ][gc,phases      ] GC(72) Compaction Phase 6.382ms</span><br><span class="line">[0.708s][info   ][gc,phases,start] GC(72) Post Compact</span><br><span class="line">[0.708s][info   ][gc,phases      ] GC(72) Post Compact 0.166ms</span><br><span class="line">[0.708s][info   ][gc,heap        ] GC(72) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.708s][info   ][gc,heap        ] GC(72) ParOldGen: 338549K(349696K)-&gt;338045K(349696K)</span><br><span class="line">[0.709s][info   ][gc,metaspace   ] GC(72) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.709s][info   ][gc             ] GC(72) Pause Full (Ergonomics) 388M-&gt;330M(455M) 9.121ms</span><br><span class="line">[0.709s][info   ][gc,cpu         ] GC(72) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.711s][info   ][gc,start       ] GC(73) Pause Full (Ergonomics)</span><br><span class="line">[0.711s][info   ][gc,phases,start] GC(73) Marking Phase</span><br><span class="line">[0.713s][info   ][gc,phases      ] GC(73) Marking Phase 1.658ms</span><br><span class="line">[0.713s][info   ][gc,phases,start] GC(73) Summary Phase</span><br><span class="line">[0.713s][info   ][gc,phases      ] GC(73) Summary Phase 0.015ms</span><br><span class="line">[0.713s][info   ][gc,phases,start] GC(73) Adjust Roots</span><br><span class="line">[0.713s][info   ][gc,phases      ] GC(73) Adjust Roots 0.154ms</span><br><span class="line">[0.713s][info   ][gc,phases,start] GC(73) Compaction Phase</span><br><span class="line">[0.719s][info   ][gc,phases      ] GC(73) Compaction Phase 5.657ms</span><br><span class="line">[0.719s][info   ][gc,phases,start] GC(73) Post Compact</span><br><span class="line">[0.719s][info   ][gc,phases      ] GC(73) Post Compact 0.159ms</span><br><span class="line">[0.719s][info   ][gc,heap        ] GC(73) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.719s][info   ][gc,heap        ] GC(73) ParOldGen: 338045K(349696K)-&gt;339245K(349696K)</span><br><span class="line">[0.719s][info   ][gc,metaspace   ] GC(73) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.719s][info   ][gc             ] GC(73) Pause Full (Ergonomics) 387M-&gt;331M(455M) 7.902ms</span><br><span class="line">[0.719s][info   ][gc,cpu         ] GC(73) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.722s][info   ][gc,start       ] GC(74) Pause Full (Ergonomics)</span><br><span class="line">[0.722s][info   ][gc,phases,start] GC(74) Marking Phase</span><br><span class="line">[0.724s][info   ][gc,phases      ] GC(74) Marking Phase 1.732ms</span><br><span class="line">[0.724s][info   ][gc,phases,start] GC(74) Summary Phase</span><br><span class="line">[0.724s][info   ][gc,phases      ] GC(74) Summary Phase 0.014ms</span><br><span class="line">[0.724s][info   ][gc,phases,start] GC(74) Adjust Roots</span><br><span class="line">[0.724s][info   ][gc,phases      ] GC(74) Adjust Roots 0.166ms</span><br><span class="line">[0.724s][info   ][gc,phases,start] GC(74) Compaction Phase</span><br><span class="line">[0.730s][info   ][gc,phases      ] GC(74) Compaction Phase 5.952ms</span><br><span class="line">[0.730s][info   ][gc,phases,start] GC(74) Post Compact</span><br><span class="line">[0.730s][info   ][gc,phases      ] GC(74) Post Compact 0.218ms</span><br><span class="line">[0.730s][info   ][gc,heap        ] GC(74) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.730s][info   ][gc,heap        ] GC(74) ParOldGen: 339245K(349696K)-&gt;339435K(349696K)</span><br><span class="line">[0.730s][info   ][gc,metaspace   ] GC(74) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.730s][info   ][gc             ] GC(74) Pause Full (Ergonomics) 388M-&gt;331M(455M) 8.335ms</span><br><span class="line">[0.730s][info   ][gc,cpu         ] GC(74) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.733s][info   ][gc,start       ] GC(75) Pause Full (Ergonomics)</span><br><span class="line">[0.733s][info   ][gc,phases,start] GC(75) Marking Phase</span><br><span class="line">[0.736s][info   ][gc,phases      ] GC(75) Marking Phase 2.042ms</span><br><span class="line">[0.736s][info   ][gc,phases,start] GC(75) Summary Phase</span><br><span class="line">[0.736s][info   ][gc,phases      ] GC(75) Summary Phase 0.015ms</span><br><span class="line">[0.736s][info   ][gc,phases,start] GC(75) Adjust Roots</span><br><span class="line">[0.736s][info   ][gc,phases      ] GC(75) Adjust Roots 0.155ms</span><br><span class="line">[0.736s][info   ][gc,phases,start] GC(75) Compaction Phase</span><br><span class="line">[0.742s][info   ][gc,phases      ] GC(75) Compaction Phase 6.069ms</span><br><span class="line">[0.742s][info   ][gc,phases,start] GC(75) Post Compact</span><br><span class="line">[0.742s][info   ][gc,phases      ] GC(75) Post Compact 0.172ms</span><br><span class="line">[0.742s][info   ][gc,heap        ] GC(75) PSYoungGen: 58731K(116736K)-&gt;0K(116736K) Eden: 58731K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.742s][info   ][gc,heap        ] GC(75) ParOldGen: 339435K(349696K)-&gt;341139K(349696K)</span><br><span class="line">[0.742s][info   ][gc,metaspace   ] GC(75) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.742s][info   ][gc             ] GC(75) Pause Full (Ergonomics) 388M-&gt;333M(455M) 8.642ms</span><br><span class="line">[0.742s][info   ][gc,cpu         ] GC(75) User=0.04s Sys=0.00s Real=0.00s</span><br><span class="line">[0.745s][info   ][gc,start       ] GC(76) Pause Full (Ergonomics)</span><br><span class="line">[0.745s][info   ][gc,phases,start] GC(76) Marking Phase</span><br><span class="line">[0.747s][info   ][gc,phases      ] GC(76) Marking Phase 1.948ms</span><br><span class="line">[0.747s][info   ][gc,phases,start] GC(76) Summary Phase</span><br><span class="line">[0.747s][info   ][gc,phases      ] GC(76) Summary Phase 0.015ms</span><br><span class="line">[0.747s][info   ][gc,phases,start] GC(76) Adjust Roots</span><br><span class="line">[0.748s][info   ][gc,phases      ] GC(76) Adjust Roots 0.147ms</span><br><span class="line">[0.748s][info   ][gc,phases,start] GC(76) Compaction Phase</span><br><span class="line">[0.753s][info   ][gc,phases      ] GC(76) Compaction Phase 5.275ms</span><br><span class="line">[0.753s][info   ][gc,phases,start] GC(76) Post Compact</span><br><span class="line">[0.753s][info   ][gc,phases      ] GC(76) Post Compact 0.160ms</span><br><span class="line">[0.753s][info   ][gc,heap        ] GC(76) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.753s][info   ][gc,heap        ] GC(76) ParOldGen: 341139K(349696K)-&gt;342065K(349696K)</span><br><span class="line">[0.753s][info   ][gc,metaspace   ] GC(76) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.753s][info   ][gc             ] GC(76) Pause Full (Ergonomics) 390M-&gt;334M(455M) 7.788ms</span><br><span class="line">[0.753s][info   ][gc,cpu         ] GC(76) User=0.04s Sys=0.00s Real=0.01s</span><br><span class="line">[0.757s][info   ][gc,start       ] GC(77) Pause Full (Ergonomics)</span><br><span class="line">[0.757s][info   ][gc,phases,start] GC(77) Marking Phase</span><br><span class="line">[0.759s][info   ][gc,phases      ] GC(77) Marking Phase 2.001ms</span><br><span class="line">[0.759s][info   ][gc,phases,start] GC(77) Summary Phase</span><br><span class="line">[0.759s][info   ][gc,phases      ] GC(77) Summary Phase 0.014ms</span><br><span class="line">[0.759s][info   ][gc,phases,start] GC(77) Adjust Roots</span><br><span class="line">[0.759s][info   ][gc,phases      ] GC(77) Adjust Roots 0.184ms</span><br><span class="line">[0.759s][info   ][gc,phases,start] GC(77) Compaction Phase</span><br><span class="line">[0.765s][info   ][gc,phases      ] GC(77) Compaction Phase 6.052ms</span><br><span class="line">[0.765s][info   ][gc,phases,start] GC(77) Post Compact</span><br><span class="line">[0.765s][info   ][gc,phases      ] GC(77) Post Compact 0.248ms</span><br><span class="line">[0.765s][info   ][gc,heap        ] GC(77) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.765s][info   ][gc,heap        ] GC(77) ParOldGen: 342065K(349696K)-&gt;340685K(349696K)</span><br><span class="line">[0.765s][info   ][gc,metaspace   ] GC(77) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.765s][info   ][gc             ] GC(77) Pause Full (Ergonomics) 391M-&gt;332M(455M) 8.753ms</span><br><span class="line">[0.765s][info   ][gc,cpu         ] GC(77) User=0.03s Sys=0.01s Real=0.01s</span><br><span class="line">[0.768s][info   ][gc,start       ] GC(78) Pause Full (Ergonomics)</span><br><span class="line">[0.768s][info   ][gc,phases,start] GC(78) Marking Phase</span><br><span class="line">[0.770s][info   ][gc,phases      ] GC(78) Marking Phase 1.999ms</span><br><span class="line">[0.770s][info   ][gc,phases,start] GC(78) Summary Phase</span><br><span class="line">[0.770s][info   ][gc,phases      ] GC(78) Summary Phase 0.015ms</span><br><span class="line">[0.770s][info   ][gc,phases,start] GC(78) Adjust Roots</span><br><span class="line">[0.770s][info   ][gc,phases      ] GC(78) Adjust Roots 0.142ms</span><br><span class="line">[0.770s][info   ][gc,phases,start] GC(78) Compaction Phase</span><br><span class="line">[0.775s][info   ][gc,phases      ] GC(78) Compaction Phase 4.969ms</span><br><span class="line">[0.775s][info   ][gc,phases,start] GC(78) Post Compact</span><br><span class="line">[0.776s][info   ][gc,phases      ] GC(78) Post Compact 0.164ms</span><br><span class="line">[0.776s][info   ][gc,heap        ] GC(78) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.776s][info   ][gc,heap        ] GC(78) ParOldGen: 340685K(349696K)-&gt;345247K(349696K)</span><br><span class="line">[0.776s][info   ][gc,metaspace   ] GC(78) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.776s][info   ][gc             ] GC(78) Pause Full (Ergonomics) 390M-&gt;337M(455M) 7.506ms</span><br><span class="line">[0.776s][info   ][gc,cpu         ] GC(78) User=0.04s Sys=0.00s Real=0.01s</span><br><span class="line">[0.779s][info   ][gc,start       ] GC(79) Pause Full (Ergonomics)</span><br><span class="line">[0.779s][info   ][gc,phases,start] GC(79) Marking Phase</span><br><span class="line">[0.780s][info   ][gc,phases      ] GC(79) Marking Phase 1.796ms</span><br><span class="line">[0.780s][info   ][gc,phases,start] GC(79) Summary Phase</span><br><span class="line">[0.780s][info   ][gc,phases      ] GC(79) Summary Phase 0.021ms</span><br><span class="line">[0.780s][info   ][gc,phases,start] GC(79) Adjust Roots</span><br><span class="line">[0.781s][info   ][gc,phases      ] GC(79) Adjust Roots 0.136ms</span><br><span class="line">[0.781s][info   ][gc,phases,start] GC(79) Compaction Phase</span><br><span class="line">[0.786s][info   ][gc,phases      ] GC(79) Compaction Phase 4.974ms</span><br><span class="line">[0.786s][info   ][gc,phases,start] GC(79) Post Compact</span><br><span class="line">[0.786s][info   ][gc,phases      ] GC(79) Post Compact 0.169ms</span><br><span class="line">[0.786s][info   ][gc,heap        ] GC(79) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.786s][info   ][gc,heap        ] GC(79) ParOldGen: 345247K(349696K)-&gt;341591K(349696K)</span><br><span class="line">[0.786s][info   ][gc,metaspace   ] GC(79) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.786s][info   ][gc             ] GC(79) Pause Full (Ergonomics) 394M-&gt;333M(455M) 7.317ms</span><br><span class="line">[0.786s][info   ][gc,cpu         ] GC(79) User=0.04s Sys=0.00s Real=0.01s</span><br><span class="line">[0.788s][info   ][gc,start       ] GC(80) Pause Full (Ergonomics)</span><br><span class="line">[0.788s][info   ][gc,phases,start] GC(80) Marking Phase</span><br><span class="line">[0.790s][info   ][gc,phases      ] GC(80) Marking Phase 1.717ms</span><br><span class="line">[0.790s][info   ][gc,phases,start] GC(80) Summary Phase</span><br><span class="line">[0.790s][info   ][gc,phases      ] GC(80) Summary Phase 0.014ms</span><br><span class="line">[0.790s][info   ][gc,phases,start] GC(80) Adjust Roots</span><br><span class="line">[0.790s][info   ][gc,phases      ] GC(80) Adjust Roots 0.139ms</span><br><span class="line">[0.790s][info   ][gc,phases,start] GC(80) Compaction Phase</span><br><span class="line">[0.800s][info   ][gc,phases      ] GC(80) Compaction Phase 9.428ms</span><br><span class="line">[0.800s][info   ][gc,phases,start] GC(80) Post Compact</span><br><span class="line">[0.800s][info   ][gc,phases      ] GC(80) Post Compact 0.151ms</span><br><span class="line">[0.800s][info   ][gc,heap        ] GC(80) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.800s][info   ][gc,heap        ] GC(80) ParOldGen: 341591K(349696K)-&gt;339177K(349696K)</span><br><span class="line">[0.800s][info   ][gc,metaspace   ] GC(80) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.800s][info   ][gc             ] GC(80) Pause Full (Ergonomics) 391M-&gt;331M(455M) 11.639ms</span><br><span class="line">[0.800s][info   ][gc,cpu         ] GC(80) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.803s][info   ][gc,start       ] GC(81) Pause Full (Ergonomics)</span><br><span class="line">[0.803s][info   ][gc,phases,start] GC(81) Marking Phase</span><br><span class="line">[0.805s][info   ][gc,phases      ] GC(81) Marking Phase 2.156ms</span><br><span class="line">[0.805s][info   ][gc,phases,start] GC(81) Summary Phase</span><br><span class="line">[0.806s][info   ][gc,phases      ] GC(81) Summary Phase 0.014ms</span><br><span class="line">[0.806s][info   ][gc,phases,start] GC(81) Adjust Roots</span><br><span class="line">[0.806s][info   ][gc,phases      ] GC(81) Adjust Roots 0.153ms</span><br><span class="line">[0.806s][info   ][gc,phases,start] GC(81) Compaction Phase</span><br><span class="line">[0.811s][info   ][gc,phases      ] GC(81) Compaction Phase 5.151ms</span><br><span class="line">[0.811s][info   ][gc,phases,start] GC(81) Post Compact</span><br><span class="line">[0.811s][info   ][gc,phases      ] GC(81) Post Compact 0.159ms</span><br><span class="line">[0.811s][info   ][gc,heap        ] GC(81) PSYoungGen: 58707K(116736K)-&gt;0K(116736K) Eden: 58707K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.811s][info   ][gc,heap        ] GC(81) ParOldGen: 339177K(349696K)-&gt;337198K(349696K)</span><br><span class="line">[0.811s][info   ][gc,metaspace   ] GC(81) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.811s][info   ][gc             ] GC(81) Pause Full (Ergonomics) 388M-&gt;329M(455M) 7.834ms</span><br><span class="line">[0.811s][info   ][gc,cpu         ] GC(81) User=0.04s Sys=0.00s Real=0.00s</span><br><span class="line">[0.814s][info   ][gc,start       ] GC(82) Pause Full (Ergonomics)</span><br><span class="line">[0.814s][info   ][gc,phases,start] GC(82) Marking Phase</span><br><span class="line">[0.816s][info   ][gc,phases      ] GC(82) Marking Phase 1.875ms</span><br><span class="line">[0.816s][info   ][gc,phases,start] GC(82) Summary Phase</span><br><span class="line">[0.816s][info   ][gc,phases      ] GC(82) Summary Phase 0.017ms</span><br><span class="line">[0.816s][info   ][gc,phases,start] GC(82) Adjust Roots</span><br><span class="line">[0.816s][info   ][gc,phases      ] GC(82) Adjust Roots 0.342ms</span><br><span class="line">[0.816s][info   ][gc,phases,start] GC(82) Compaction Phase</span><br><span class="line">[0.822s][info   ][gc,phases      ] GC(82) Compaction Phase 5.214ms</span><br><span class="line">[0.822s][info   ][gc,phases,start] GC(82) Post Compact</span><br><span class="line">[0.822s][info   ][gc,phases      ] GC(82) Post Compact 0.187ms</span><br><span class="line">[0.822s][info   ][gc,heap        ] GC(82) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.822s][info   ][gc,heap        ] GC(82) ParOldGen: 337198K(349696K)-&gt;333216K(349696K)</span><br><span class="line">[0.822s][info   ][gc,metaspace   ] GC(82) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.822s][info   ][gc             ] GC(82) Pause Full (Ergonomics) 386M-&gt;325M(455M) 7.852ms</span><br><span class="line">[0.822s][info   ][gc,cpu         ] GC(82) User=0.04s Sys=0.01s Real=0.00s</span><br><span class="line">[0.825s][info   ][gc,start       ] GC(83) Pause Full (Ergonomics)</span><br><span class="line">[0.825s][info   ][gc,phases,start] GC(83) Marking Phase</span><br><span class="line">[0.827s][info   ][gc,phases      ] GC(83) Marking Phase 2.247ms</span><br><span class="line">[0.827s][info   ][gc,phases,start] GC(83) Summary Phase</span><br><span class="line">[0.827s][info   ][gc,phases      ] GC(83) Summary Phase 0.017ms</span><br><span class="line">[0.827s][info   ][gc,phases,start] GC(83) Adjust Roots</span><br><span class="line">[0.829s][info   ][gc,phases      ] GC(83) Adjust Roots 1.196ms</span><br><span class="line">[0.829s][info   ][gc,phases,start] GC(83) Compaction Phase</span><br><span class="line">[0.834s][info   ][gc,phases      ] GC(83) Compaction Phase 5.418ms</span><br><span class="line">[0.834s][info   ][gc,phases,start] GC(83) Post Compact</span><br><span class="line">[0.834s][info   ][gc,phases      ] GC(83) Post Compact 0.163ms</span><br><span class="line">[0.834s][info   ][gc,heap        ] GC(83) PSYoungGen: 58736K(116736K)-&gt;0K(116736K) Eden: 58736K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.834s][info   ][gc,heap        ] GC(83) ParOldGen: 333216K(349696K)-&gt;333547K(349696K)</span><br><span class="line">[0.834s][info   ][gc,metaspace   ] GC(83) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.834s][info   ][gc             ] GC(83) Pause Full (Ergonomics) 382M-&gt;325M(455M) 9.264ms</span><br><span class="line">[0.834s][info   ][gc,cpu         ] GC(83) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.837s][info   ][gc,start       ] GC(84) Pause Full (Ergonomics)</span><br><span class="line">[0.837s][info   ][gc,phases,start] GC(84) Marking Phase</span><br><span class="line">[0.839s][info   ][gc,phases      ] GC(84) Marking Phase 2.042ms</span><br><span class="line">[0.839s][info   ][gc,phases,start] GC(84) Summary Phase</span><br><span class="line">[0.839s][info   ][gc,phases      ] GC(84) Summary Phase 0.015ms</span><br><span class="line">[0.839s][info   ][gc,phases,start] GC(84) Adjust Roots</span><br><span class="line">[0.840s][info   ][gc,phases      ] GC(84) Adjust Roots 0.145ms</span><br><span class="line">[0.840s][info   ][gc,phases,start] GC(84) Compaction Phase</span><br><span class="line">[0.845s][info   ][gc,phases      ] GC(84) Compaction Phase 5.179ms</span><br><span class="line">[0.845s][info   ][gc,phases,start] GC(84) Post Compact</span><br><span class="line">[0.845s][info   ][gc,phases      ] GC(84) Post Compact 0.172ms</span><br><span class="line">[0.845s][info   ][gc,heap        ] GC(84) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.845s][info   ][gc,heap        ] GC(84) ParOldGen: 333547K(349696K)-&gt;332593K(349696K)</span><br><span class="line">[0.845s][info   ][gc,metaspace   ] GC(84) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.845s][info   ][gc             ] GC(84) Pause Full (Ergonomics) 383M-&gt;324M(455M) 7.745ms</span><br><span class="line">[0.845s][info   ][gc,cpu         ] GC(84) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.848s][info   ][gc,start       ] GC(85) Pause Full (Ergonomics)</span><br><span class="line">[0.848s][info   ][gc,phases,start] GC(85) Marking Phase</span><br><span class="line">[0.850s][info   ][gc,phases      ] GC(85) Marking Phase 1.964ms</span><br><span class="line">[0.850s][info   ][gc,phases,start] GC(85) Summary Phase</span><br><span class="line">[0.850s][info   ][gc,phases      ] GC(85) Summary Phase 0.017ms</span><br><span class="line">[0.850s][info   ][gc,phases,start] GC(85) Adjust Roots</span><br><span class="line">[0.850s][info   ][gc,phases      ] GC(85) Adjust Roots 0.143ms</span><br><span class="line">[0.850s][info   ][gc,phases,start] GC(85) Compaction Phase</span><br><span class="line">[0.855s][info   ][gc,phases      ] GC(85) Compaction Phase 5.475ms</span><br><span class="line">[0.855s][info   ][gc,phases,start] GC(85) Post Compact</span><br><span class="line">[0.856s][info   ][gc,phases      ] GC(85) Post Compact 0.219ms</span><br><span class="line">[0.856s][info   ][gc,heap        ] GC(85) PSYoungGen: 58805K(116736K)-&gt;0K(116736K) Eden: 58805K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.856s][info   ][gc,heap        ] GC(85) ParOldGen: 332593K(349696K)-&gt;337090K(349696K)</span><br><span class="line">[0.856s][info   ][gc,metaspace   ] GC(85) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.856s][info   ][gc             ] GC(85) Pause Full (Ergonomics) 382M-&gt;329M(455M) 8.015ms</span><br><span class="line">[0.856s][info   ][gc,cpu         ] GC(85) User=0.04s Sys=0.00s Real=0.01s</span><br><span class="line">[0.859s][info   ][gc,start       ] GC(86) Pause Full (Ergonomics)</span><br><span class="line">[0.859s][info   ][gc,phases,start] GC(86) Marking Phase</span><br><span class="line">[0.862s][info   ][gc,phases      ] GC(86) Marking Phase 2.598ms</span><br><span class="line">[0.862s][info   ][gc,phases,start] GC(86) Summary Phase</span><br><span class="line">[0.862s][info   ][gc,phases      ] GC(86) Summary Phase 0.026ms</span><br><span class="line">[0.862s][info   ][gc,phases,start] GC(86) Adjust Roots</span><br><span class="line">[0.862s][info   ][gc,phases      ] GC(86) Adjust Roots 0.160ms</span><br><span class="line">[0.862s][info   ][gc,phases,start] GC(86) Compaction Phase</span><br><span class="line">[0.869s][info   ][gc,phases      ] GC(86) Compaction Phase 7.084ms</span><br><span class="line">[0.869s][info   ][gc,phases,start] GC(86) Post Compact</span><br><span class="line">[0.869s][info   ][gc,phases      ] GC(86) Post Compact 0.157ms</span><br><span class="line">[0.869s][info   ][gc,heap        ] GC(86) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.869s][info   ][gc,heap        ] GC(86) ParOldGen: 337090K(349696K)-&gt;340061K(349696K)</span><br><span class="line">[0.869s][info   ][gc,metaspace   ] GC(86) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.869s][info   ][gc             ] GC(86) Pause Full (Ergonomics) 386M-&gt;332M(455M) 10.208ms</span><br><span class="line">[0.869s][info   ][gc,cpu         ] GC(86) User=0.04s Sys=0.00s Real=0.01s</span><br><span class="line">[0.872s][info   ][gc,start       ] GC(87) Pause Full (Ergonomics)</span><br><span class="line">[0.872s][info   ][gc,phases,start] GC(87) Marking Phase</span><br><span class="line">[0.874s][info   ][gc,phases      ] GC(87) Marking Phase 1.803ms</span><br><span class="line">[0.874s][info   ][gc,phases,start] GC(87) Summary Phase</span><br><span class="line">[0.874s][info   ][gc,phases      ] GC(87) Summary Phase 0.016ms</span><br><span class="line">[0.874s][info   ][gc,phases,start] GC(87) Adjust Roots</span><br><span class="line">[0.874s][info   ][gc,phases      ] GC(87) Adjust Roots 0.135ms</span><br><span class="line">[0.874s][info   ][gc,phases,start] GC(87) Compaction Phase</span><br><span class="line">[0.880s][info   ][gc,phases      ] GC(87) Compaction Phase 5.511ms</span><br><span class="line">[0.880s][info   ][gc,phases,start] GC(87) Post Compact</span><br><span class="line">[0.880s][info   ][gc,phases      ] GC(87) Post Compact 0.155ms</span><br><span class="line">[0.880s][info   ][gc,heap        ] GC(87) PSYoungGen: 58622K(116736K)-&gt;0K(116736K) Eden: 58622K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.880s][info   ][gc,heap        ] GC(87) ParOldGen: 340061K(349696K)-&gt;339338K(349696K)</span><br><span class="line">[0.880s][info   ][gc,metaspace   ] GC(87) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.880s][info   ][gc             ] GC(87) Pause Full (Ergonomics) 389M-&gt;331M(455M) 7.801ms</span><br><span class="line">[0.880s][info   ][gc,cpu         ] GC(87) User=0.04s Sys=0.01s Real=0.01s</span><br><span class="line">[0.883s][info   ][gc,start       ] GC(88) Pause Full (Ergonomics)</span><br><span class="line">[0.883s][info   ][gc,phases,start] GC(88) Marking Phase</span><br><span class="line">[0.885s][info   ][gc,phases      ] GC(88) Marking Phase 2.168ms</span><br><span class="line">[0.885s][info   ][gc,phases,start] GC(88) Summary Phase</span><br><span class="line">[0.885s][info   ][gc,phases      ] GC(88) Summary Phase 0.017ms</span><br><span class="line">[0.885s][info   ][gc,phases,start] GC(88) Adjust Roots</span><br><span class="line">[0.885s][info   ][gc,phases      ] GC(88) Adjust Roots 0.144ms</span><br><span class="line">[0.885s][info   ][gc,phases,start] GC(88) Compaction Phase</span><br><span class="line">[0.891s][info   ][gc,phases      ] GC(88) Compaction Phase 5.649ms</span><br><span class="line">[0.891s][info   ][gc,phases,start] GC(88) Post Compact</span><br><span class="line">[0.891s][info   ][gc,phases      ] GC(88) Post Compact 0.159ms</span><br><span class="line">[0.891s][info   ][gc,heap        ] GC(88) PSYoungGen: 58825K(116736K)-&gt;0K(116736K) Eden: 58825K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.891s][info   ][gc,heap        ] GC(88) ParOldGen: 339338K(349696K)-&gt;338980K(349696K)</span><br><span class="line">[0.891s][info   ][gc,metaspace   ] GC(88) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.891s][info   ][gc             ] GC(88) Pause Full (Ergonomics) 388M-&gt;331M(455M) 8.363ms</span><br><span class="line">[0.891s][info   ][gc,cpu         ] GC(88) User=0.04s Sys=0.00s Real=0.00s</span><br><span class="line">[0.894s][info   ][gc,start       ] GC(89) Pause Full (Ergonomics)</span><br><span class="line">[0.894s][info   ][gc,phases,start] GC(89) Marking Phase</span><br><span class="line">[0.896s][info   ][gc,phases      ] GC(89) Marking Phase 2.470ms</span><br><span class="line">[0.896s][info   ][gc,phases,start] GC(89) Summary Phase</span><br><span class="line">[0.896s][info   ][gc,phases      ] GC(89) Summary Phase 0.020ms</span><br><span class="line">[0.896s][info   ][gc,phases,start] GC(89) Adjust Roots</span><br><span class="line">[0.896s][info   ][gc,phases      ] GC(89) Adjust Roots 0.148ms</span><br><span class="line">[0.896s][info   ][gc,phases,start] GC(89) Compaction Phase</span><br><span class="line">[0.903s][info   ][gc,phases      ] GC(89) Compaction Phase 6.296ms</span><br><span class="line">[0.903s][info   ][gc,phases,start] GC(89) Post Compact</span><br><span class="line">[0.903s][info   ][gc,phases      ] GC(89) Post Compact 0.186ms</span><br><span class="line">[0.903s][info   ][gc,heap        ] GC(89) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.903s][info   ][gc,heap        ] GC(89) ParOldGen: 338980K(349696K)-&gt;337584K(349696K)</span><br><span class="line">[0.903s][info   ][gc,metaspace   ] GC(89) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.903s][info   ][gc             ] GC(89) Pause Full (Ergonomics) 388M-&gt;329M(455M) 9.335ms</span><br><span class="line">[0.903s][info   ][gc,cpu         ] GC(89) User=0.04s Sys=0.00s Real=0.01s</span><br><span class="line">[0.906s][info   ][gc,start       ] GC(90) Pause Full (Ergonomics)</span><br><span class="line">[0.906s][info   ][gc,phases,start] GC(90) Marking Phase</span><br><span class="line">[0.908s][info   ][gc,phases      ] GC(90) Marking Phase 2.283ms</span><br><span class="line">[0.909s][info   ][gc,phases,start] GC(90) Summary Phase</span><br><span class="line">[0.909s][info   ][gc,phases      ] GC(90) Summary Phase 0.016ms</span><br><span class="line">[0.909s][info   ][gc,phases,start] GC(90) Adjust Roots</span><br><span class="line">[0.909s][info   ][gc,phases      ] GC(90) Adjust Roots 0.150ms</span><br><span class="line">[0.909s][info   ][gc,phases,start] GC(90) Compaction Phase</span><br><span class="line">[0.914s][info   ][gc,phases      ] GC(90) Compaction Phase 5.759ms</span><br><span class="line">[0.915s][info   ][gc,phases,start] GC(90) Post Compact</span><br><span class="line">[0.915s][info   ][gc,phases      ] GC(90) Post Compact 0.154ms</span><br><span class="line">[0.915s][info   ][gc,heap        ] GC(90) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.915s][info   ][gc,heap        ] GC(90) ParOldGen: 337584K(349696K)-&gt;337049K(349696K)</span><br><span class="line">[0.915s][info   ][gc,metaspace   ] GC(90) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.915s][info   ][gc             ] GC(90) Pause Full (Ergonomics) 387M-&gt;329M(455M) 8.577ms</span><br><span class="line">[0.915s][info   ][gc,cpu         ] GC(90) User=0.04s Sys=0.00s Real=0.01s</span><br><span class="line">[0.918s][info   ][gc,start       ] GC(91) Pause Full (Ergonomics)</span><br><span class="line">[0.918s][info   ][gc,phases,start] GC(91) Marking Phase</span><br><span class="line">[0.920s][info   ][gc,phases      ] GC(91) Marking Phase 2.154ms</span><br><span class="line">[0.920s][info   ][gc,phases,start] GC(91) Summary Phase</span><br><span class="line">[0.920s][info   ][gc,phases      ] GC(91) Summary Phase 0.013ms</span><br><span class="line">[0.920s][info   ][gc,phases,start] GC(91) Adjust Roots</span><br><span class="line">[0.920s][info   ][gc,phases      ] GC(91) Adjust Roots 0.176ms</span><br><span class="line">[0.920s][info   ][gc,phases,start] GC(91) Compaction Phase</span><br><span class="line">[0.926s][info   ][gc,phases      ] GC(91) Compaction Phase 5.547ms</span><br><span class="line">[0.926s][info   ][gc,phases,start] GC(91) Post Compact</span><br><span class="line">[0.926s][info   ][gc,phases      ] GC(91) Post Compact 0.158ms</span><br><span class="line">[0.926s][info   ][gc,heap        ] GC(91) PSYoungGen: 58798K(116736K)-&gt;0K(116736K) Eden: 58798K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.926s][info   ][gc,heap        ] GC(91) ParOldGen: 337049K(349696K)-&gt;332320K(349696K)</span><br><span class="line">[0.926s][info   ][gc,metaspace   ] GC(91) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.926s][info   ][gc             ] GC(91) Pause Full (Ergonomics) 386M-&gt;324M(455M) 8.247ms</span><br><span class="line">[0.926s][info   ][gc,cpu         ] GC(91) User=0.04s Sys=0.00s Real=0.01s</span><br><span class="line">[0.930s][info   ][gc,start       ] GC(92) Pause Full (Ergonomics)</span><br><span class="line">[0.930s][info   ][gc,phases,start] GC(92) Marking Phase</span><br><span class="line">[0.932s][info   ][gc,phases      ] GC(92) Marking Phase 2.350ms</span><br><span class="line">[0.932s][info   ][gc,phases,start] GC(92) Summary Phase</span><br><span class="line">[0.932s][info   ][gc,phases      ] GC(92) Summary Phase 0.015ms</span><br><span class="line">[0.932s][info   ][gc,phases,start] GC(92) Adjust Roots</span><br><span class="line">[0.932s][info   ][gc,phases      ] GC(92) Adjust Roots 0.153ms</span><br><span class="line">[0.932s][info   ][gc,phases,start] GC(92) Compaction Phase</span><br><span class="line">[0.938s][info   ][gc,phases      ] GC(92) Compaction Phase 5.653ms</span><br><span class="line">[0.938s][info   ][gc,phases,start] GC(92) Post Compact</span><br><span class="line">[0.938s][info   ][gc,phases      ] GC(92) Post Compact 0.160ms</span><br><span class="line">[0.938s][info   ][gc,heap        ] GC(92) PSYoungGen: 58620K(116736K)-&gt;0K(116736K) Eden: 58620K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.938s][info   ][gc,heap        ] GC(92) ParOldGen: 332320K(349696K)-&gt;332929K(349696K)</span><br><span class="line">[0.938s][info   ][gc,metaspace   ] GC(92) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.938s][info   ][gc             ] GC(92) Pause Full (Ergonomics) 381M-&gt;325M(455M) 8.542ms</span><br><span class="line">[0.938s][info   ][gc,cpu         ] GC(92) User=0.03s Sys=0.01s Real=0.01s</span><br><span class="line">[0.941s][info   ][gc,start       ] GC(93) Pause Full (Ergonomics)</span><br><span class="line">[0.941s][info   ][gc,phases,start] GC(93) Marking Phase</span><br><span class="line">[0.943s][info   ][gc,phases      ] GC(93) Marking Phase 2.195ms</span><br><span class="line">[0.943s][info   ][gc,phases,start] GC(93) Summary Phase</span><br><span class="line">[0.943s][info   ][gc,phases      ] GC(93) Summary Phase 0.014ms</span><br><span class="line">[0.943s][info   ][gc,phases,start] GC(93) Adjust Roots</span><br><span class="line">[0.944s][info   ][gc,phases      ] GC(93) Adjust Roots 0.155ms</span><br><span class="line">[0.944s][info   ][gc,phases,start] GC(93) Compaction Phase</span><br><span class="line">[0.949s][info   ][gc,phases      ] GC(93) Compaction Phase 5.683ms</span><br><span class="line">[0.949s][info   ][gc,phases,start] GC(93) Post Compact</span><br><span class="line">[0.950s][info   ][gc,phases      ] GC(93) Post Compact 0.159ms</span><br><span class="line">[0.950s][info   ][gc,heap        ] GC(93) PSYoungGen: 58576K(116736K)-&gt;0K(116736K) Eden: 58576K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.950s][info   ][gc,heap        ] GC(93) ParOldGen: 332929K(349696K)-&gt;332316K(349696K)</span><br><span class="line">[0.950s][info   ][gc,metaspace   ] GC(93) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.950s][info   ][gc             ] GC(93) Pause Full (Ergonomics) 382M-&gt;324M(455M) 8.425ms</span><br><span class="line">[0.950s][info   ][gc,cpu         ] GC(93) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.954s][info   ][gc,start       ] GC(94) Pause Full (Ergonomics)</span><br><span class="line">[0.954s][info   ][gc,phases,start] GC(94) Marking Phase</span><br><span class="line">[0.956s][info   ][gc,phases      ] GC(94) Marking Phase 1.754ms</span><br><span class="line">[0.956s][info   ][gc,phases,start] GC(94) Summary Phase</span><br><span class="line">[0.956s][info   ][gc,phases      ] GC(94) Summary Phase 0.016ms</span><br><span class="line">[0.956s][info   ][gc,phases,start] GC(94) Adjust Roots</span><br><span class="line">[0.956s][info   ][gc,phases      ] GC(94) Adjust Roots 0.130ms</span><br><span class="line">[0.956s][info   ][gc,phases,start] GC(94) Compaction Phase</span><br><span class="line">[0.961s][info   ][gc,phases      ] GC(94) Compaction Phase 5.308ms</span><br><span class="line">[0.962s][info   ][gc,phases,start] GC(94) Post Compact</span><br><span class="line">[0.962s][info   ][gc,phases      ] GC(94) Post Compact 0.159ms</span><br><span class="line">[0.962s][info   ][gc,heap        ] GC(94) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.962s][info   ][gc,heap        ] GC(94) ParOldGen: 332316K(349696K)-&gt;333329K(349696K)</span><br><span class="line">[0.962s][info   ][gc,metaspace   ] GC(94) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.962s][info   ][gc             ] GC(94) Pause Full (Ergonomics) 382M-&gt;325M(455M) 7.525ms</span><br><span class="line">[0.962s][info   ][gc,cpu         ] GC(94) User=0.03s Sys=0.00s Real=0.00s</span><br><span class="line">[0.965s][info   ][gc,start       ] GC(95) Pause Full (Ergonomics)</span><br><span class="line">[0.965s][info   ][gc,phases,start] GC(95) Marking Phase</span><br><span class="line">[0.967s][info   ][gc,phases      ] GC(95) Marking Phase 1.880ms</span><br><span class="line">[0.967s][info   ][gc,phases,start] GC(95) Summary Phase</span><br><span class="line">[0.967s][info   ][gc,phases      ] GC(95) Summary Phase 0.014ms</span><br><span class="line">[0.967s][info   ][gc,phases,start] GC(95) Adjust Roots</span><br><span class="line">[0.967s][info   ][gc,phases      ] GC(95) Adjust Roots 0.148ms</span><br><span class="line">[0.967s][info   ][gc,phases,start] GC(95) Compaction Phase</span><br><span class="line">[0.973s][info   ][gc,phases      ] GC(95) Compaction Phase 5.887ms</span><br><span class="line">[0.973s][info   ][gc,phases,start] GC(95) Post Compact</span><br><span class="line">[0.973s][info   ][gc,phases      ] GC(95) Post Compact 0.170ms</span><br><span class="line">[0.973s][info   ][gc,heap        ] GC(95) PSYoungGen: 58673K(116736K)-&gt;0K(116736K) Eden: 58673K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.973s][info   ][gc,heap        ] GC(95) ParOldGen: 333329K(349696K)-&gt;329838K(349696K)</span><br><span class="line">[0.973s][info   ][gc,metaspace   ] GC(95) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.973s][info   ][gc             ] GC(95) Pause Full (Ergonomics) 382M-&gt;322M(455M) 8.300ms</span><br><span class="line">[0.973s][info   ][gc,cpu         ] GC(95) User=0.04s Sys=0.00s Real=0.01s</span><br><span class="line">[0.976s][info   ][gc,start       ] GC(96) Pause Full (Ergonomics)</span><br><span class="line">[0.976s][info   ][gc,phases,start] GC(96) Marking Phase</span><br><span class="line">[0.979s][info   ][gc,phases      ] GC(96) Marking Phase 2.129ms</span><br><span class="line">[0.979s][info   ][gc,phases,start] GC(96) Summary Phase</span><br><span class="line">[0.979s][info   ][gc,phases      ] GC(96) Summary Phase 0.016ms</span><br><span class="line">[0.979s][info   ][gc,phases,start] GC(96) Adjust Roots</span><br><span class="line">[0.979s][info   ][gc,phases      ] GC(96) Adjust Roots 0.142ms</span><br><span class="line">[0.979s][info   ][gc,phases,start] GC(96) Compaction Phase</span><br><span class="line">[0.984s][info   ][gc,phases      ] GC(96) Compaction Phase 5.409ms</span><br><span class="line">[0.984s][info   ][gc,phases,start] GC(96) Post Compact</span><br><span class="line">[0.984s][info   ][gc,phases      ] GC(96) Post Compact 0.161ms</span><br><span class="line">[0.984s][info   ][gc,heap        ] GC(96) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[0.984s][info   ][gc,heap        ] GC(96) ParOldGen: 329838K(349696K)-&gt;332469K(349696K)</span><br><span class="line">[0.984s][info   ][gc,metaspace   ] GC(96) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.984s][info   ][gc             ] GC(96) Pause Full (Ergonomics) 379M-&gt;324M(455M) 8.052ms</span><br><span class="line">[0.984s][info   ][gc,cpu         ] GC(96) User=0.04s Sys=0.00s Real=0.01s</span><br><span class="line">[0.991s][info   ][gc,start       ] GC(97) Pause Full (Ergonomics)</span><br><span class="line">[0.991s][info   ][gc,phases,start] GC(97) Marking Phase</span><br><span class="line">[0.993s][info   ][gc,phases      ] GC(97) Marking Phase 2.074ms</span><br><span class="line">[0.993s][info   ][gc,phases,start] GC(97) Summary Phase</span><br><span class="line">[0.993s][info   ][gc,phases      ] GC(97) Summary Phase 0.017ms</span><br><span class="line">[0.993s][info   ][gc,phases,start] GC(97) Adjust Roots</span><br><span class="line">[0.993s][info   ][gc,phases      ] GC(97) Adjust Roots 0.146ms</span><br><span class="line">[0.993s][info   ][gc,phases,start] GC(97) Compaction Phase</span><br><span class="line">[1.000s][info   ][gc,phases      ] GC(97) Compaction Phase 6.613ms</span><br><span class="line">[1.000s][info   ][gc,phases,start] GC(97) Post Compact</span><br><span class="line">[1.000s][info   ][gc,phases      ] GC(97) Post Compact 0.187ms</span><br><span class="line">[1.000s][info   ][gc,heap        ] GC(97) PSYoungGen: 58749K(116736K)-&gt;0K(116736K) Eden: 58749K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[1.000s][info   ][gc,heap        ] GC(97) ParOldGen: 332469K(349696K)-&gt;338455K(349696K)</span><br><span class="line">[1.000s][info   ][gc,metaspace   ] GC(97) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.000s][info   ][gc             ] GC(97) Pause Full (Ergonomics) 382M-&gt;330M(455M) 9.249ms</span><br><span class="line">[1.000s][info   ][gc,cpu         ] GC(97) User=0.03s Sys=0.01s Real=0.01s</span><br><span class="line">[1.003s][info   ][gc,start       ] GC(98) Pause Full (Ergonomics)</span><br><span class="line">[1.003s][info   ][gc,phases,start] GC(98) Marking Phase</span><br><span class="line">[1.005s][info   ][gc,phases      ] GC(98) Marking Phase 1.781ms</span><br><span class="line">[1.005s][info   ][gc,phases,start] GC(98) Summary Phase</span><br><span class="line">[1.005s][info   ][gc,phases      ] GC(98) Summary Phase 0.029ms</span><br><span class="line">[1.005s][info   ][gc,phases,start] GC(98) Adjust Roots</span><br><span class="line">[1.005s][info   ][gc,phases      ] GC(98) Adjust Roots 0.137ms</span><br><span class="line">[1.005s][info   ][gc,phases,start] GC(98) Compaction Phase</span><br><span class="line">[1.010s][info   ][gc,phases      ] GC(98) Compaction Phase 5.105ms</span><br><span class="line">[1.010s][info   ][gc,phases,start] GC(98) Post Compact</span><br><span class="line">[1.011s][info   ][gc,phases      ] GC(98) Post Compact 0.156ms</span><br><span class="line">[1.011s][info   ][gc,heap        ] GC(98) PSYoungGen: 58880K(116736K)-&gt;0K(116736K) Eden: 58880K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[1.011s][info   ][gc,heap        ] GC(98) ParOldGen: 338455K(349696K)-&gt;344861K(349696K)</span><br><span class="line">[1.011s][info   ][gc,metaspace   ] GC(98) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.011s][info   ][gc             ] GC(98) Pause Full (Ergonomics) 388M-&gt;336M(455M) 7.448ms</span><br><span class="line">[1.011s][info   ][gc,cpu         ] GC(98) User=0.03s Sys=0.00s Real=0.00s</span><br><span class="line">[1.014s][info   ][gc,start       ] GC(99) Pause Full (Ergonomics)</span><br><span class="line">[1.014s][info   ][gc,phases,start] GC(99) Marking Phase</span><br><span class="line">[1.016s][info   ][gc,phases      ] GC(99) Marking Phase 1.975ms</span><br><span class="line">[1.016s][info   ][gc,phases,start] GC(99) Summary Phase</span><br><span class="line">[1.016s][info   ][gc,phases      ] GC(99) Summary Phase 0.015ms</span><br><span class="line">[1.016s][info   ][gc,phases,start] GC(99) Adjust Roots</span><br><span class="line">[1.016s][info   ][gc,phases      ] GC(99) Adjust Roots 0.143ms</span><br><span class="line">[1.016s][info   ][gc,phases,start] GC(99) Compaction Phase</span><br><span class="line">[1.021s][info   ][gc,phases      ] GC(99) Compaction Phase 5.385ms</span><br><span class="line">[1.021s][info   ][gc,phases,start] GC(99) Post Compact</span><br><span class="line">[1.021s][info   ][gc,phases      ] GC(99) Post Compact 0.176ms</span><br><span class="line">[1.021s][info   ][gc,heap        ] GC(99) PSYoungGen: 58862K(116736K)-&gt;0K(116736K) Eden: 58862K(58880K)-&gt;0K(58880K) From: 0K(57856K)-&gt;0K(57856K)</span><br><span class="line">[1.021s][info   ][gc,heap        ] GC(99) ParOldGen: 344861K(349696K)-&gt;340647K(349696K)</span><br><span class="line">[1.021s][info   ][gc,metaspace   ] GC(99) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.021s][info   ][gc             ] GC(99) Pause Full (Ergonomics) 394M-&gt;332M(455M) 7.849ms</span><br><span class="line">[1.021s][info   ][gc,cpu         ] GC(99) User=0.03s Sys=0.00s Real=0.00s</span><br><span class="line">counter:27740</span><br><span class="line">[1.027s][info   ][gc,heap,exit   ] Heap</span><br><span class="line">[1.027s][info   ][gc,heap,exit   ]  PSYoungGen      total 116736K, used 2641K [0x00000007f5580000, 0x0000000800000000, 0x0000000800000000)</span><br><span class="line">[1.027s][info   ][gc,heap,exit   ]   eden space 58880K, 4% used [0x00000007f5580000,0x00000007f5814680,0x00000007f8f00000)</span><br><span class="line">[1.027s][info   ][gc,heap,exit   ]   from space 57856K, 0% used [0x00000007fc780000,0x00000007fc780000,0x0000000800000000)</span><br><span class="line">[1.027s][info   ][gc,heap,exit   ]   to   space 57856K, 0% used [0x00000007f8f00000,0x00000007f8f00000,0x00000007fc780000)</span><br><span class="line">[1.027s][info   ][gc,heap,exit   ]  ParOldGen       total 349696K, used 340647K [0x00000007e0000000, 0x00000007f5580000, 0x00000007f5580000)</span><br><span class="line">[1.027s][info   ][gc,heap,exit   ]   object space 349696K, 97% used [0x00000007e0000000,0x00000007f4ca9c40,0x00000007f5580000)</span><br><span class="line">[1.027s][info   ][gc,heap,exit   ]  Metaspace       used 232K, committed 448K, reserved 1114112K</span><br><span class="line">[1.027s][info   ][gc,heap,exit   ]   class space    used 9K, committed 128K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>再来试试1g内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+UseParallelGC -Xms1g -Xmx1g -XX:+PrintGCDetails -Xlog:gc\*:file=gc.log:time,uptime,level,tags GCLogAnalysis</span><br></pre></td></tr></table></figure>

<p>跟串行GC相比，GC次数增加，但是吞吐量也增加了很多，串行GC生成了33000多个对象，而并行GC生成了50000多个对象。有明显提升。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0.002s][warning][gc] -XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.</span><br><span class="line">[0.005s][info   ][gc,init] CardTable entry size: 512</span><br><span class="line">[0.005s][info   ][gc     ] Using Parallel</span><br><span class="line">[0.005s][info   ][gc,init] Version: 19.0.2+7-44 (release)</span><br><span class="line">[0.005s][info   ][gc,init] CPUs: 8 total, 8 available</span><br><span class="line">[0.005s][info   ][gc,init] Memory: 16384M</span><br><span class="line">[0.005s][info   ][gc,init] Large Page Support: Disabled</span><br><span class="line">[0.005s][info   ][gc,init] NUMA Support: Disabled</span><br><span class="line">[0.005s][info   ][gc,init] Compressed Oops: Enabled (Zero based)</span><br><span class="line">[0.005s][info   ][gc,init] Alignments: Space 512K, Generation 512K, Heap 8M</span><br><span class="line">[0.005s][info   ][gc,init] Heap Min Capacity: 1G</span><br><span class="line">[0.005s][info   ][gc,init] Heap Initial Capacity: 1G</span><br><span class="line">[0.005s][info   ][gc,init] Heap Max Capacity: 1G</span><br><span class="line">[0.005s][info   ][gc,init] Pre-touch: Disabled</span><br><span class="line">[0.005s][info   ][gc,init] Parallel Workers: 8</span><br><span class="line">[0.006s][info   ][gc,metaspace] CDS archive(s) mapped at: [0x0000000800000000-0x0000000800c44000-0x0000000800c44000), size 12861440, SharedBaseAddress: 0x0000000800000000, ArchiveRelocationMode: 0.</span><br><span class="line">[0.006s][info   ][gc,metaspace] Compressed class space mapped at: 0x0000000801000000-0x0000000841000000, reserved size: 1073741824</span><br><span class="line">[0.006s][info   ][gc,metaspace] Narrow klass base: 0x0000000800000000, Narrow klass shift: 0, Narrow klass range: 0x100000000</span><br><span class="line">gc...</span><br><span class="line">[0.070s][info   ][gc,start    ] GC(0) Pause Young (Allocation Failure)</span><br><span class="line">[0.085s][info   ][gc,heap     ] GC(0) PSYoungGen: 262144K(305664K)-&gt;43515K(305664K) Eden: 262144K(262144K)-&gt;0K(262144K) From: 0K(43520K)-&gt;43515K(43520K)</span><br><span class="line">[0.085s][info   ][gc,heap     ] GC(0) ParOldGen: 992K(699392K)-&gt;38587K(699392K)</span><br><span class="line">[0.085s][info   ][gc,metaspace] GC(0) Metaspace: 155K(384K)-&gt;155K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.085s][info   ][gc          ] GC(0) Pause Young (Allocation Failure) 256M-&gt;80M(981M) 14.914ms</span><br><span class="line">[0.085s][info   ][gc,cpu      ] GC(0) User=0.01s Sys=0.04s Real=0.02s</span><br><span class="line">[0.112s][info   ][gc,start    ] GC(1) Pause Young (Allocation Failure)</span><br><span class="line">[0.144s][info   ][gc,heap     ] GC(1) PSYoungGen: 305659K(305664K)-&gt;43519K(305664K) Eden: 262144K(262144K)-&gt;0K(262144K) From: 43515K(43520K)-&gt;43519K(43520K)</span><br><span class="line">[0.144s][info   ][gc,heap     ] GC(1) ParOldGen: 38587K(699392K)-&gt;123605K(699392K)</span><br><span class="line">[0.144s][info   ][gc,metaspace] GC(1) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.144s][info   ][gc          ] GC(1) Pause Young (Allocation Failure) 336M-&gt;163M(981M) 32.202ms</span><br><span class="line">[0.144s][info   ][gc,cpu      ] GC(1) User=0.02s Sys=0.08s Real=0.04s</span><br><span class="line">[0.158s][info   ][gc,start    ] GC(2) Pause Young (Allocation Failure)</span><br><span class="line">[0.172s][info   ][gc,heap     ] GC(2) PSYoungGen: 305663K(305664K)-&gt;43517K(305664K) Eden: 262144K(262144K)-&gt;0K(262144K) From: 43519K(43520K)-&gt;43517K(43520K)</span><br><span class="line">[0.172s][info   ][gc,heap     ] GC(2) ParOldGen: 123605K(699392K)-&gt;208282K(699392K)</span><br><span class="line">[0.172s][info   ][gc,metaspace] GC(2) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.172s][info   ][gc          ] GC(2) Pause Young (Allocation Failure) 419M-&gt;245M(981M) 13.297ms</span><br><span class="line">[0.172s][info   ][gc,cpu      ] GC(2) User=0.01s Sys=0.04s Real=0.01s</span><br><span class="line">[0.185s][info   ][gc,start    ] GC(3) Pause Young (Allocation Failure)</span><br><span class="line">[0.197s][info   ][gc,heap     ] GC(3) PSYoungGen: 305661K(305664K)-&gt;43515K(305664K) Eden: 262144K(262144K)-&gt;0K(262144K) From: 43517K(43520K)-&gt;43515K(43520K)</span><br><span class="line">[0.197s][info   ][gc,heap     ] GC(3) ParOldGen: 208282K(699392K)-&gt;278596K(699392K)</span><br><span class="line">[0.197s][info   ][gc,metaspace] GC(3) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.197s][info   ][gc          ] GC(3) Pause Young (Allocation Failure) 501M-&gt;314M(981M) 12.068ms</span><br><span class="line">[0.197s][info   ][gc,cpu      ] GC(3) User=0.01s Sys=0.04s Real=0.01s</span><br><span class="line">[0.211s][info   ][gc,start    ] GC(4) Pause Young (Allocation Failure)</span><br><span class="line">[0.225s][info   ][gc,heap     ] GC(4) PSYoungGen: 305659K(305664K)-&gt;43503K(305664K) Eden: 262144K(262144K)-&gt;0K(262144K) From: 43515K(43520K)-&gt;43503K(43520K)</span><br><span class="line">[0.225s][info   ][gc,heap     ] GC(4) ParOldGen: 278596K(699392K)-&gt;357837K(699392K)</span><br><span class="line">[0.225s][info   ][gc,metaspace] GC(4) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.225s][info   ][gc          ] GC(4) Pause Young (Allocation Failure) 570M-&gt;391M(981M) 14.287ms</span><br><span class="line">[0.225s][info   ][gc,cpu      ] GC(4) User=0.01s Sys=0.06s Real=0.02s</span><br><span class="line">[0.239s][info   ][gc,start    ] GC(5) Pause Young (Allocation Failure)</span><br><span class="line">[0.252s][info   ][gc,heap     ] GC(5) PSYoungGen: 305647K(305664K)-&gt;43514K(160256K) Eden: 262144K(262144K)-&gt;0K(116736K) From: 43503K(43520K)-&gt;43514K(43520K)</span><br><span class="line">[0.252s][info   ][gc,heap     ] GC(5) ParOldGen: 357837K(699392K)-&gt;436169K(699392K)</span><br><span class="line">[0.252s][info   ][gc,metaspace] GC(5) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.252s][info   ][gc          ] GC(5) Pause Young (Allocation Failure) 647M-&gt;468M(839M) 13.030ms</span><br><span class="line">[0.252s][info   ][gc,cpu      ] GC(5) User=0.01s Sys=0.04s Real=0.01s</span><br><span class="line">[0.258s][info   ][gc,start    ] GC(6) Pause Young (Allocation Failure)</span><br><span class="line">[0.261s][info   ][gc,heap     ] GC(6) PSYoungGen: 160085K(160256K)-&gt;74365K(232960K) Eden: 116571K(116736K)-&gt;0K(116736K) From: 43514K(43520K)-&gt;74365K(116224K)</span><br><span class="line">[0.261s][info   ][gc,heap     ] GC(6) ParOldGen: 436169K(699392K)-&gt;440682K(699392K)</span><br><span class="line">[0.261s][info   ][gc,metaspace] GC(6) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.261s][info   ][gc          ] GC(6) Pause Young (Allocation Failure) 582M-&gt;502M(910M) 2.826ms</span><br><span class="line">[0.261s][info   ][gc,cpu      ] GC(6) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.266s][info   ][gc,start    ] GC(7) Pause Young (Allocation Failure)</span><br><span class="line">[0.269s][info   ][gc,heap     ] GC(7) PSYoungGen: 191101K(232960K)-&gt;103114K(232960K) Eden: 116736K(116736K)-&gt;0K(116736K) From: 74365K(116224K)-&gt;103114K(116224K)</span><br><span class="line">[0.269s][info   ][gc,heap     ] GC(7) ParOldGen: 440682K(699392K)-&gt;449904K(699392K)</span><br><span class="line">[0.269s][info   ][gc,metaspace] GC(7) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.269s][info   ][gc          ] GC(7) Pause Young (Allocation Failure) 616M-&gt;540M(910M) 2.714ms</span><br><span class="line">[0.269s][info   ][gc,cpu      ] GC(7) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.274s][info   ][gc,start    ] GC(8) Pause Young (Allocation Failure)</span><br><span class="line">[0.278s][info   ][gc,heap     ] GC(8) PSYoungGen: 219586K(232960K)-&gt;115563K(232960K) Eden: 116471K(116736K)-&gt;0K(116736K) From: 103114K(116224K)-&gt;115563K(116224K)</span><br><span class="line">[0.278s][info   ][gc,heap     ] GC(8) ParOldGen: 449904K(699392K)-&gt;466909K(699392K)</span><br><span class="line">[0.278s][info   ][gc,metaspace] GC(8) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.278s][info   ][gc          ] GC(8) Pause Young (Allocation Failure) 653M-&gt;568M(910M) 3.646ms</span><br><span class="line">[0.278s][info   ][gc,cpu      ] GC(8) User=0.01s Sys=0.01s Real=0.00s</span><br><span class="line">[0.283s][info   ][gc,start    ] GC(9) Pause Young (Allocation Failure)</span><br><span class="line">[0.293s][info   ][gc,heap     ] GC(9) PSYoungGen: 232299K(232960K)-&gt;82692K(232960K) Eden: 116736K(116736K)-&gt;0K(116736K) From: 115563K(116224K)-&gt;82692K(116224K)</span><br><span class="line">[0.293s][info   ][gc,heap     ] GC(9) ParOldGen: 466909K(699392K)-&gt;528082K(699392K)</span><br><span class="line">[0.293s][info   ][gc,metaspace] GC(9) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.293s][info   ][gc          ] GC(9) Pause Young (Allocation Failure) 682M-&gt;596M(910M) 9.914ms</span><br><span class="line">[0.293s][info   ][gc,cpu      ] GC(9) User=0.01s Sys=0.02s Real=0.01s</span><br><span class="line">[0.299s][info   ][gc,start    ] GC(10) Pause Young (Allocation Failure)</span><br><span class="line">[0.313s][info   ][gc,heap     ] GC(10) PSYoungGen: 199428K(232960K)-&gt;45380K(232960K) Eden: 116736K(116736K)-&gt;0K(116736K) From: 82692K(116224K)-&gt;45380K(116224K)</span><br><span class="line">[0.313s][info   ][gc,heap     ] GC(10) ParOldGen: 528082K(699392K)-&gt;601186K(699392K)</span><br><span class="line">[0.313s][info   ][gc,metaspace] GC(10) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.313s][info   ][gc          ] GC(10) Pause Young (Allocation Failure) 710M-&gt;631M(910M) 13.654ms</span><br><span class="line">[0.313s][info   ][gc,cpu      ] GC(10) User=0.01s Sys=0.03s Real=0.01s</span><br><span class="line">[0.313s][info   ][gc,start    ] GC(11) Pause Full (Ergonomics)</span><br><span class="line">[0.313s][info   ][gc,phases,start] GC(11) Marking Phase</span><br><span class="line">[0.320s][info   ][gc,phases      ] GC(11) Marking Phase 6.583ms</span><br><span class="line">[0.320s][info   ][gc,phases,start] GC(11) Summary Phase</span><br><span class="line">[0.321s][info   ][gc,phases      ] GC(11) Summary Phase 0.869ms</span><br><span class="line">[0.321s][info   ][gc,phases,start] GC(11) Adjust Roots</span><br><span class="line">[0.321s][info   ][gc,phases      ] GC(11) Adjust Roots 0.197ms</span><br><span class="line">[0.321s][info   ][gc,phases,start] GC(11) Compaction Phase</span><br><span class="line">[0.360s][info   ][gc,phases      ] GC(11) Compaction Phase 39.470ms</span><br><span class="line">[0.360s][info   ][gc,phases,start] GC(11) Post Compact</span><br><span class="line">[0.361s][info   ][gc,phases      ] GC(11) Post Compact 0.593ms</span><br><span class="line">[0.361s][info   ][gc,heap        ] GC(11) PSYoungGen: 45380K(232960K)-&gt;0K(232960K) Eden: 0K(116736K)-&gt;0K(116736K) From: 45380K(116224K)-&gt;0K(116224K)</span><br><span class="line">[0.361s][info   ][gc,heap        ] GC(11) ParOldGen: 601186K(699392K)-&gt;305448K(699392K)</span><br><span class="line">[0.361s][info   ][gc,metaspace   ] GC(11) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.361s][info   ][gc             ] GC(11) Pause Full (Ergonomics) 631M-&gt;298M(910M) 47.948ms</span><br><span class="line">[0.361s][info   ][gc,cpu         ] GC(11) User=0.04s Sys=0.10s Real=0.05s</span><br><span class="line">[0.367s][info   ][gc,start       ] GC(12) Pause Young (Allocation Failure)</span><br><span class="line">[0.369s][info   ][gc,heap        ] GC(12) PSYoungGen: 116736K(232960K)-&gt;46339K(232960K) Eden: 116736K(116736K)-&gt;0K(116736K) From: 0K(116224K)-&gt;46339K(116224K)</span><br><span class="line">[0.369s][info   ][gc,heap        ] GC(12) ParOldGen: 305448K(699392K)-&gt;305448K(699392K)</span><br><span class="line">[0.369s][info   ][gc,metaspace   ] GC(12) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.369s][info   ][gc             ] GC(12) Pause Young (Allocation Failure) 412M-&gt;343M(910M) 1.555ms</span><br><span class="line">[0.369s][info   ][gc,cpu         ] GC(12) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.375s][info   ][gc,start       ] GC(13) Pause Young (Allocation Failure)</span><br><span class="line">[0.377s][info   ][gc,heap        ] GC(13) PSYoungGen: 162419K(232960K)-&gt;49019K(232960K) Eden: 116079K(116736K)-&gt;0K(116736K) From: 46339K(116224K)-&gt;49019K(116224K)</span><br><span class="line">[0.377s][info   ][gc,heap        ] GC(13) ParOldGen: 305448K(699392K)-&gt;346492K(699392K)</span><br><span class="line">[0.377s][info   ][gc,metaspace   ] GC(13) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.377s][info   ][gc             ] GC(13) Pause Young (Allocation Failure) 456M-&gt;386M(910M) 2.714ms</span><br><span class="line">[0.377s][info   ][gc,cpu         ] GC(13) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.383s][info   ][gc,start       ] GC(14) Pause Young (Allocation Failure)</span><br><span class="line">[0.385s][info   ][gc,heap        ] GC(14) PSYoungGen: 165755K(232960K)-&gt;41809K(232960K) Eden: 116736K(116736K)-&gt;0K(116736K) From: 49019K(116224K)-&gt;41809K(116224K)</span><br><span class="line">[0.385s][info   ][gc,heap        ] GC(14) ParOldGen: 346492K(699392K)-&gt;387467K(699392K)</span><br><span class="line">[0.385s][info   ][gc,metaspace   ] GC(14) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.385s][info   ][gc             ] GC(14) Pause Young (Allocation Failure) 500M-&gt;419M(910M) 2.585ms</span><br><span class="line">[0.385s][info   ][gc,cpu         ] GC(14) User=0.02s Sys=0.00s Real=0.01s</span><br><span class="line">[0.391s][info   ][gc,start       ] GC(15) Pause Young (Allocation Failure)</span><br><span class="line">[0.393s][info   ][gc,heap        ] GC(15) PSYoungGen: 158545K(232960K)-&gt;46584K(232960K) Eden: 116736K(116736K)-&gt;0K(116736K) From: 41809K(116224K)-&gt;46584K(116224K)</span><br><span class="line">[0.393s][info   ][gc,heap        ] GC(15) ParOldGen: 387467K(699392K)-&gt;423884K(699392K)</span><br><span class="line">[0.393s][info   ][gc,metaspace   ] GC(15) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.393s][info   ][gc             ] GC(15) Pause Young (Allocation Failure) 533M-&gt;459M(910M) 2.366ms</span><br><span class="line">[0.393s][info   ][gc,cpu         ] GC(15) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.399s][info   ][gc,start       ] GC(16) Pause Young (Allocation Failure)</span><br><span class="line">[0.401s][info   ][gc,heap        ] GC(16) PSYoungGen: 163320K(232960K)-&gt;40142K(232960K) Eden: 116736K(116736K)-&gt;0K(116736K) From: 46584K(116224K)-&gt;40142K(116224K)</span><br><span class="line">[0.401s][info   ][gc,heap        ] GC(16) ParOldGen: 423884K(699392K)-&gt;462716K(699392K)</span><br><span class="line">[0.401s][info   ][gc,metaspace   ] GC(16) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.401s][info   ][gc             ] GC(16) Pause Young (Allocation Failure) 573M-&gt;491M(910M) 2.467ms</span><br><span class="line">[0.401s][info   ][gc,cpu         ] GC(16) User=0.01s Sys=0.01s Real=0.00s</span><br><span class="line">[0.407s][info   ][gc,start       ] GC(17) Pause Young (Allocation Failure)</span><br><span class="line">[0.409s][info   ][gc,heap        ] GC(17) PSYoungGen: 156878K(232960K)-&gt;43590K(232960K) Eden: 116736K(116736K)-&gt;0K(116736K) From: 40142K(116224K)-&gt;43590K(116224K)</span><br><span class="line">[0.409s][info   ][gc,heap        ] GC(17) ParOldGen: 462716K(699392K)-&gt;496672K(699392K)</span><br><span class="line">[0.409s][info   ][gc,metaspace   ] GC(17) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.410s][info   ][gc             ] GC(17) Pause Young (Allocation Failure) 605M-&gt;527M(910M) 2.280ms</span><br><span class="line">[0.410s][info   ][gc,cpu         ] GC(17) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.416s][info   ][gc,start       ] GC(18) Pause Young (Allocation Failure)</span><br><span class="line">[0.418s][info   ][gc,heap        ] GC(18) PSYoungGen: 160326K(232960K)-&gt;39611K(232960K) Eden: 116736K(116736K)-&gt;0K(116736K) From: 43590K(116224K)-&gt;39611K(116224K)</span><br><span class="line">[0.419s][info   ][gc,heap        ] GC(18) ParOldGen: 496672K(699392K)-&gt;536456K(699392K)</span><br><span class="line">[0.419s][info   ][gc,metaspace   ] GC(18) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.419s][info   ][gc             ] GC(18) Pause Young (Allocation Failure) 641M-&gt;562M(910M) 2.493ms</span><br><span class="line">[0.419s][info   ][gc,cpu         ] GC(18) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.425s][info   ][gc,start       ] GC(19) Pause Young (Allocation Failure)</span><br><span class="line">[0.427s][info   ][gc,heap        ] GC(19) PSYoungGen: 156347K(232960K)-&gt;46572K(232960K) Eden: 116736K(116736K)-&gt;0K(116736K) From: 39611K(116224K)-&gt;46572K(116224K)</span><br><span class="line">[0.427s][info   ][gc,heap        ] GC(19) ParOldGen: 536456K(699392K)-&gt;570411K(699392K)</span><br><span class="line">[0.427s][info   ][gc,metaspace   ] GC(19) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.427s][info   ][gc             ] GC(19) Pause Young (Allocation Failure) 676M-&gt;602M(910M) 2.223ms</span><br><span class="line">[0.427s][info   ][gc,cpu         ] GC(19) User=0.02s Sys=0.00s Real=0.00s</span><br><span class="line">[0.433s][info   ][gc,start       ] GC(20) Pause Young (Allocation Failure)</span><br><span class="line">[0.436s][info   ][gc,heap        ] GC(20) PSYoungGen: 163019K(232960K)-&gt;38093K(232960K) Eden: 116447K(116736K)-&gt;0K(116736K) From: 46572K(116224K)-&gt;38093K(116224K)</span><br><span class="line">[0.436s][info   ][gc,heap        ] GC(20) ParOldGen: 570411K(699392K)-&gt;610440K(699392K)</span><br><span class="line">[0.436s][info   ][gc,metaspace   ] GC(20) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.436s][info   ][gc             ] GC(20) Pause Young (Allocation Failure) 716M-&gt;633M(910M) 2.895ms</span><br><span class="line">[0.436s][info   ][gc,cpu         ] GC(20) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.442s][info   ][gc,start       ] GC(21) Pause Young (Allocation Failure)</span><br><span class="line">[0.447s][info   ][gc,heap        ] GC(21) PSYoungGen: 154491K(232960K)-&gt;49732K(232960K) Eden: 116398K(116736K)-&gt;0K(116736K) From: 38093K(116224K)-&gt;49732K(116224K)</span><br><span class="line">[0.447s][info   ][gc,heap        ] GC(21) ParOldGen: 610440K(699392K)-&gt;642556K(699392K)</span><br><span class="line">[0.447s][info   ][gc,metaspace   ] GC(21) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.447s][info   ][gc             ] GC(21) Pause Young (Allocation Failure) 747M-&gt;676M(910M) 4.859ms</span><br><span class="line">[0.447s][info   ][gc,cpu         ] GC(21) User=0.01s Sys=0.02s Real=0.01s</span><br><span class="line">[0.447s][info   ][gc,start       ] GC(22) Pause Full (Ergonomics)</span><br><span class="line">[0.447s][info   ][gc,phases,start] GC(22) Marking Phase</span><br><span class="line">[0.450s][info   ][gc,phases      ] GC(22) Marking Phase 2.570ms</span><br><span class="line">[0.450s][info   ][gc,phases,start] GC(22) Summary Phase</span><br><span class="line">[0.450s][info   ][gc,phases      ] GC(22) Summary Phase 0.031ms</span><br><span class="line">[0.450s][info   ][gc,phases,start] GC(22) Adjust Roots</span><br><span class="line">[0.450s][info   ][gc,phases      ] GC(22) Adjust Roots 0.169ms</span><br><span class="line">[0.450s][info   ][gc,phases,start] GC(22) Compaction Phase</span><br><span class="line">[0.458s][info   ][gc,phases      ] GC(22) Compaction Phase 8.449ms</span><br><span class="line">[0.458s][info   ][gc,phases,start] GC(22) Post Compact</span><br><span class="line">[0.459s][info   ][gc,phases      ] GC(22) Post Compact 0.365ms</span><br><span class="line">[0.459s][info   ][gc,heap        ] GC(22) PSYoungGen: 49732K(232960K)-&gt;0K(232960K) Eden: 0K(116736K)-&gt;0K(116736K) From: 49732K(116224K)-&gt;0K(116224K)</span><br><span class="line">[0.459s][info   ][gc,heap        ] GC(22) ParOldGen: 642556K(699392K)-&gt;329548K(699392K)</span><br><span class="line">[0.459s][info   ][gc,metaspace   ] GC(22) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.459s][info   ][gc             ] GC(22) Pause Full (Ergonomics) 676M-&gt;321M(910M) 11.804ms</span><br><span class="line">[0.459s][info   ][gc,cpu         ] GC(22) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.466s][info   ][gc,start       ] GC(23) Pause Young (Allocation Failure)</span><br><span class="line">[0.468s][info   ][gc,heap        ] GC(23) PSYoungGen: 116736K(232960K)-&gt;51238K(232960K) Eden: 116736K(116736K)-&gt;0K(116736K) From: 0K(116224K)-&gt;51238K(116224K)</span><br><span class="line">[0.468s][info   ][gc,heap        ] GC(23) ParOldGen: 329548K(699392K)-&gt;329548K(699392K)</span><br><span class="line">[0.468s][info   ][gc,metaspace   ] GC(23) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.468s][info   ][gc             ] GC(23) Pause Young (Allocation Failure) 435M-&gt;371M(910M) 2.526ms</span><br><span class="line">[0.468s][info   ][gc,cpu         ] GC(23) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.474s][info   ][gc,start       ] GC(24) Pause Young (Allocation Failure)</span><br><span class="line">[0.476s][info   ][gc,heap        ] GC(24) PSYoungGen: 167896K(232960K)-&gt;39986K(232960K) Eden: 116658K(116736K)-&gt;0K(116736K) From: 51238K(116224K)-&gt;39986K(116224K)</span><br><span class="line">[0.476s][info   ][gc,heap        ] GC(24) ParOldGen: 329548K(699392K)-&gt;372500K(699392K)</span><br><span class="line">[0.476s][info   ][gc,metaspace   ] GC(24) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.476s][info   ][gc             ] GC(24) Pause Young (Allocation Failure) 485M-&gt;402M(910M) 2.028ms</span><br><span class="line">[0.476s][info   ][gc,cpu         ] GC(24) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.482s][info   ][gc,start       ] GC(25) Pause Young (Allocation Failure)</span><br><span class="line">[0.485s][info   ][gc,heap        ] GC(25) PSYoungGen: 156653K(232960K)-&gt;48228K(232960K) Eden: 116666K(116736K)-&gt;0K(116736K) From: 39986K(116224K)-&gt;48228K(116224K)</span><br><span class="line">[0.485s][info   ][gc,heap        ] GC(25) ParOldGen: 372500K(699392K)-&gt;407933K(699392K)</span><br><span class="line">[0.485s][info   ][gc,metaspace   ] GC(25) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.485s][info   ][gc             ] GC(25) Pause Young (Allocation Failure) 516M-&gt;445M(910M) 2.561ms</span><br><span class="line">[0.485s][info   ][gc,cpu         ] GC(25) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.490s][info   ][gc,start       ] GC(26) Pause Young (Allocation Failure)</span><br><span class="line">[0.492s][info   ][gc,heap        ] GC(26) PSYoungGen: 164964K(232960K)-&gt;46375K(232960K) Eden: 116736K(116736K)-&gt;0K(116736K) From: 48228K(116224K)-&gt;46375K(116224K)</span><br><span class="line">[0.492s][info   ][gc,heap        ] GC(26) ParOldGen: 407933K(699392K)-&gt;452835K(699392K)</span><br><span class="line">[0.492s][info   ][gc,metaspace   ] GC(26) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.492s][info   ][gc             ] GC(26) Pause Young (Allocation Failure) 559M-&gt;487M(910M) 2.187ms</span><br><span class="line">[0.492s][info   ][gc,cpu         ] GC(26) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.499s][info   ][gc,start       ] GC(27) Pause Young (Allocation Failure)</span><br><span class="line">[0.501s][info   ][gc,heap        ] GC(27) PSYoungGen: 162793K(232960K)-&gt;45280K(232960K) Eden: 116417K(116736K)-&gt;0K(116736K) From: 46375K(116224K)-&gt;45280K(116224K)</span><br><span class="line">[0.501s][info   ][gc,heap        ] GC(27) ParOldGen: 452835K(699392K)-&gt;492807K(699392K)</span><br><span class="line">[0.501s][info   ][gc,metaspace   ] GC(27) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.501s][info   ][gc             ] GC(27) Pause Young (Allocation Failure) 601M-&gt;525M(910M) 2.327ms</span><br><span class="line">[0.501s][info   ][gc,cpu         ] GC(27) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.508s][info   ][gc,start       ] GC(28) Pause Young (Allocation Failure)</span><br><span class="line">[0.510s][info   ][gc,heap        ] GC(28) PSYoungGen: 162016K(232960K)-&gt;50138K(232960K) Eden: 116736K(116736K)-&gt;0K(116736K) From: 45280K(116224K)-&gt;50138K(116224K)</span><br><span class="line">[0.510s][info   ][gc,heap        ] GC(28) ParOldGen: 492807K(699392K)-&gt;531392K(699392K)</span><br><span class="line">[0.510s][info   ][gc,metaspace   ] GC(28) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.510s][info   ][gc             ] GC(28) Pause Young (Allocation Failure) 639M-&gt;567M(910M) 2.295ms</span><br><span class="line">[0.510s][info   ][gc,cpu         ] GC(28) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.515s][info   ][gc,start       ] GC(29) Pause Young (Allocation Failure)</span><br><span class="line">[0.518s][info   ][gc,heap        ] GC(29) PSYoungGen: 166874K(232960K)-&gt;41125K(239104K) Eden: 116736K(116736K)-&gt;0K(125440K) From: 50138K(116224K)-&gt;41125K(113664K)</span><br><span class="line">[0.518s][info   ][gc,heap        ] GC(29) ParOldGen: 531392K(699392K)-&gt;575382K(699392K)</span><br><span class="line">[0.518s][info   ][gc,metaspace   ] GC(29) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.518s][info   ][gc             ] GC(29) Pause Young (Allocation Failure) 681M-&gt;602M(916M) 2.468ms</span><br><span class="line">[0.518s][info   ][gc,cpu         ] GC(29) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.524s][info   ][gc,start       ] GC(30) Pause Young (Allocation Failure)</span><br><span class="line">[0.526s][info   ][gc,heap        ] GC(30) PSYoungGen: 166565K(239104K)-&gt;52109K(235520K) Eden: 125440K(125440K)-&gt;0K(125440K) From: 41125K(113664K)-&gt;52109K(110080K)</span><br><span class="line">[0.526s][info   ][gc,heap        ] GC(30) ParOldGen: 575382K(699392K)-&gt;610145K(699392K)</span><br><span class="line">[0.526s][info   ][gc,metaspace   ] GC(30) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.526s][info   ][gc             ] GC(30) Pause Young (Allocation Failure) 724M-&gt;646M(913M) 2.349ms</span><br><span class="line">[0.526s][info   ][gc,cpu         ] GC(30) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.532s][info   ][gc,start       ] GC(31) Pause Young (Allocation Failure)</span><br><span class="line">[0.536s][info   ][gc,heap        ] GC(31) PSYoungGen: 177549K(235520K)-&gt;48950K(248320K) Eden: 125440K(125440K)-&gt;0K(143360K) From: 52109K(110080K)-&gt;48950K(104960K)</span><br><span class="line">[0.536s][info   ][gc,heap        ] GC(31) ParOldGen: 610145K(699392K)-&gt;653512K(699392K)</span><br><span class="line">[0.536s][info   ][gc,metaspace   ] GC(31) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.536s][info   ][gc             ] GC(31) Pause Young (Allocation Failure) 769M-&gt;685M(925M) 3.575ms</span><br><span class="line">[0.536s][info   ][gc,cpu         ] GC(31) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.536s][info   ][gc,start       ] GC(32) Pause Full (Ergonomics)</span><br><span class="line">[0.536s][info   ][gc,phases,start] GC(32) Marking Phase</span><br><span class="line">[0.538s][info   ][gc,phases      ] GC(32) Marking Phase 1.833ms</span><br><span class="line">[0.538s][info   ][gc,phases,start] GC(32) Summary Phase</span><br><span class="line">[0.538s][info   ][gc,phases      ] GC(32) Summary Phase 0.018ms</span><br><span class="line">[0.538s][info   ][gc,phases,start] GC(32) Adjust Roots</span><br><span class="line">[0.538s][info   ][gc,phases      ] GC(32) Adjust Roots 0.463ms</span><br><span class="line">[0.538s][info   ][gc,phases,start] GC(32) Compaction Phase</span><br><span class="line">[0.545s][info   ][gc,phases      ] GC(32) Compaction Phase 7.015ms</span><br><span class="line">[0.545s][info   ][gc,phases,start] GC(32) Post Compact</span><br><span class="line">[0.546s][info   ][gc,phases      ] GC(32) Post Compact 0.327ms</span><br><span class="line">[0.546s][info   ][gc,heap        ] GC(32) PSYoungGen: 48950K(248320K)-&gt;0K(244224K) Eden: 0K(143360K)-&gt;0K(143360K) From: 48950K(104960K)-&gt;0K(100864K)</span><br><span class="line">[0.546s][info   ][gc,heap        ] GC(32) ParOldGen: 653512K(699392K)-&gt;360191K(699392K)</span><br><span class="line">[0.546s][info   ][gc,metaspace   ] GC(32) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.546s][info   ][gc             ] GC(32) Pause Full (Ergonomics) 685M-&gt;351M(921M) 9.868ms</span><br><span class="line">[0.546s][info   ][gc,cpu         ] GC(32) User=0.03s Sys=0.01s Real=0.01s</span><br><span class="line">[0.556s][info   ][gc,start       ] GC(33) Pause Young (Allocation Failure)</span><br><span class="line">[0.558s][info   ][gc,heap        ] GC(33) PSYoungGen: 143272K(244224K)-&gt;54984K(252416K) Eden: 143272K(143360K)-&gt;0K(151552K) From: 0K(100864K)-&gt;54984K(100864K)</span><br><span class="line">[0.558s][info   ][gc,heap        ] GC(33) ParOldGen: 360191K(699392K)-&gt;360191K(699392K)</span><br><span class="line">[0.558s][info   ][gc,metaspace   ] GC(33) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.558s][info   ][gc             ] GC(33) Pause Young (Allocation Failure) 491M-&gt;405M(929M) 1.840ms</span><br><span class="line">[0.558s][info   ][gc,cpu         ] GC(33) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.568s][info   ][gc,start       ] GC(34) Pause Young (Allocation Failure)</span><br><span class="line">[0.571s][info   ][gc,heap        ] GC(34) PSYoungGen: 206536K(252416K)-&gt;49881K(248320K) Eden: 151552K(151552K)-&gt;0K(151552K) From: 54984K(100864K)-&gt;49881K(96768K)</span><br><span class="line">[0.571s][info   ][gc,heap        ] GC(34) ParOldGen: 360191K(699392K)-&gt;407788K(699392K)</span><br><span class="line">[0.571s][info   ][gc,metaspace   ] GC(34) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.571s][info   ][gc             ] GC(34) Pause Young (Allocation Failure) 553M-&gt;446M(925M) 3.013ms</span><br><span class="line">[0.571s][info   ][gc,cpu         ] GC(34) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.579s][info   ][gc,start       ] GC(35) Pause Young (Allocation Failure)</span><br><span class="line">[0.581s][info   ][gc,heap        ] GC(35) PSYoungGen: 201433K(248320K)-&gt;56576K(259072K) Eden: 151552K(151552K)-&gt;0K(165888K) From: 49881K(96768K)-&gt;56576K(93184K)</span><br><span class="line">[0.581s][info   ][gc,heap        ] GC(35) ParOldGen: 407788K(699392K)-&gt;449784K(699392K)</span><br><span class="line">[0.581s][info   ][gc,metaspace   ] GC(35) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.581s][info   ][gc             ] GC(35) Pause Young (Allocation Failure) 594M-&gt;494M(936M) 2.424ms</span><br><span class="line">[0.581s][info   ][gc,cpu         ] GC(35) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.589s][info   ][gc,start       ] GC(36) Pause Young (Allocation Failure)</span><br><span class="line">[0.591s][info   ][gc,heap        ] GC(36) PSYoungGen: 222464K(259072K)-&gt;61935K(256000K) Eden: 165888K(165888K)-&gt;0K(165888K) From: 56576K(93184K)-&gt;61935K(90112K)</span><br><span class="line">[0.592s][info   ][gc,heap        ] GC(36) ParOldGen: 449784K(699392K)-&gt;496669K(699392K)</span><br><span class="line">[0.592s][info   ][gc,metaspace   ] GC(36) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.592s][info   ][gc             ] GC(36) Pause Young (Allocation Failure) 656M-&gt;545M(933M) 2.855ms</span><br><span class="line">[0.592s][info   ][gc,cpu         ] GC(36) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.599s][info   ][gc,start       ] GC(37) Pause Young (Allocation Failure)</span><br><span class="line">[0.602s][info   ][gc,heap        ] GC(37) PSYoungGen: 227823K(256000K)-&gt;57373K(262144K) Eden: 165888K(165888K)-&gt;0K(172544K) From: 61935K(90112K)-&gt;57373K(89600K)</span><br><span class="line">[0.602s][info   ][gc,heap        ] GC(37) ParOldGen: 496669K(699392K)-&gt;547969K(699392K)</span><br><span class="line">[0.602s][info   ][gc,metaspace   ] GC(37) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.602s][info   ][gc             ] GC(37) Pause Young (Allocation Failure) 707M-&gt;591M(939M) 2.692ms</span><br><span class="line">[0.602s][info   ][gc,cpu         ] GC(37) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.610s][info   ][gc,start       ] GC(38) Pause Young (Allocation Failure)</span><br><span class="line">[0.612s][info   ][gc,heap        ] GC(38) PSYoungGen: 229917K(262144K)-&gt;60373K(259584K) Eden: 172544K(172544K)-&gt;0K(172544K) From: 57373K(89600K)-&gt;60373K(87040K)</span><br><span class="line">[0.612s][info   ][gc,heap        ] GC(38) ParOldGen: 547969K(699392K)-&gt;596538K(699392K)</span><br><span class="line">[0.612s][info   ][gc,metaspace   ] GC(38) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.612s][info   ][gc             ] GC(38) Pause Young (Allocation Failure) 759M-&gt;641M(936M) 2.529ms</span><br><span class="line">[0.612s][info   ][gc,cpu         ] GC(38) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.620s][info   ][gc,start       ] GC(39) Pause Young (Allocation Failure)</span><br><span class="line">[0.623s][info   ][gc,heap        ] GC(39) PSYoungGen: 232917K(259584K)-&gt;61240K(264192K) Eden: 172544K(172544K)-&gt;0K(178176K) From: 60373K(87040K)-&gt;61240K(86016K)</span><br><span class="line">[0.623s][info   ][gc,heap        ] GC(39) ParOldGen: 596538K(699392K)-&gt;646693K(699392K)</span><br><span class="line">[0.623s][info   ][gc,metaspace   ] GC(39) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.623s][info   ][gc             ] GC(39) Pause Young (Allocation Failure) 810M-&gt;691M(941M) 3.024ms</span><br><span class="line">[0.623s][info   ][gc,cpu         ] GC(39) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.623s][info   ][gc,start       ] GC(40) Pause Full (Ergonomics)</span><br><span class="line">[0.623s][info   ][gc,phases,start] GC(40) Marking Phase</span><br><span class="line">[0.625s][info   ][gc,phases      ] GC(40) Marking Phase 1.908ms</span><br><span class="line">[0.625s][info   ][gc,phases,start] GC(40) Summary Phase</span><br><span class="line">[0.625s][info   ][gc,phases      ] GC(40) Summary Phase 0.027ms</span><br><span class="line">[0.625s][info   ][gc,phases,start] GC(40) Adjust Roots</span><br><span class="line">[0.625s][info   ][gc,phases      ] GC(40) Adjust Roots 0.168ms</span><br><span class="line">[0.625s][info   ][gc,phases,start] GC(40) Compaction Phase</span><br><span class="line">[0.632s][info   ][gc,phases      ] GC(40) Compaction Phase 6.803ms</span><br><span class="line">[0.632s][info   ][gc,phases,start] GC(40) Post Compact</span><br><span class="line">[0.632s][info   ][gc,phases      ] GC(40) Post Compact 0.261ms</span><br><span class="line">[0.632s][info   ][gc,heap        ] GC(40) PSYoungGen: 61240K(264192K)-&gt;0K(263168K) Eden: 0K(178176K)-&gt;0K(178176K) From: 61240K(86016K)-&gt;0K(84992K)</span><br><span class="line">[0.632s][info   ][gc,heap        ] GC(40) ParOldGen: 646693K(699392K)-&gt;353610K(699392K)</span><br><span class="line">[0.632s][info   ][gc,metaspace   ] GC(40) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.632s][info   ][gc             ] GC(40) Pause Full (Ergonomics) 691M-&gt;345M(940M) 9.320ms</span><br><span class="line">[0.632s][info   ][gc,cpu         ] GC(40) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.641s][info   ][gc,start       ] GC(41) Pause Young (Allocation Failure)</span><br><span class="line">[0.643s][info   ][gc,heap        ] GC(41) PSYoungGen: 177868K(263168K)-&gt;60186K(265216K) Eden: 177868K(178176K)-&gt;0K(180224K) From: 0K(84992K)-&gt;60186K(84992K)</span><br><span class="line">[0.643s][info   ][gc,heap        ] GC(41) ParOldGen: 353610K(699392K)-&gt;353610K(699392K)</span><br><span class="line">[0.643s][info   ][gc,metaspace   ] GC(41) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.643s][info   ][gc             ] GC(41) Pause Young (Allocation Failure) 519M-&gt;404M(942M) 2.137ms</span><br><span class="line">[0.643s][info   ][gc,cpu         ] GC(41) User=0.01s Sys=0.01s Real=0.00s</span><br><span class="line">[0.653s][info   ][gc,start       ] GC(42) Pause Young (Allocation Failure)</span><br><span class="line">[0.657s][info   ][gc,heap        ] GC(42) PSYoungGen: 240410K(265216K)-&gt;64911K(264192K) Eden: 180224K(180224K)-&gt;0K(180224K) From: 60186K(84992K)-&gt;64911K(83968K)</span><br><span class="line">[0.657s][info   ][gc,heap        ] GC(42) ParOldGen: 353610K(699392K)-&gt;400995K(699392K)</span><br><span class="line">[0.657s][info   ][gc,metaspace   ] GC(42) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.657s][info   ][gc             ] GC(42) Pause Young (Allocation Failure) 580M-&gt;454M(941M) 3.931ms</span><br><span class="line">[0.657s][info   ][gc,cpu         ] GC(42) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.665s][info   ][gc,start       ] GC(43) Pause Young (Allocation Failure)</span><br><span class="line">[0.668s][info   ][gc,heap        ] GC(43) PSYoungGen: 245135K(264192K)-&gt;65593K(264704K) Eden: 180224K(180224K)-&gt;0K(180224K) From: 64911K(83968K)-&gt;65593K(84480K)</span><br><span class="line">[0.668s][info   ][gc,heap        ] GC(43) ParOldGen: 400995K(699392K)-&gt;452628K(699392K)</span><br><span class="line">[0.668s][info   ][gc,metaspace   ] GC(43) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.668s][info   ][gc             ] GC(43) Pause Young (Allocation Failure) 630M-&gt;506M(941M) 3.067ms</span><br><span class="line">[0.668s][info   ][gc,cpu         ] GC(43) User=0.02s Sys=0.00s Real=0.00s</span><br><span class="line">[0.676s][info   ][gc,start       ] GC(44) Pause Young (Allocation Failure)</span><br><span class="line">[0.679s][info   ][gc,heap        ] GC(44) PSYoungGen: 245817K(264704K)-&gt;66009K(246272K) Eden: 180224K(180224K)-&gt;0K(180224K) From: 65593K(84480K)-&gt;66009K(66048K)</span><br><span class="line">[0.679s][info   ][gc,heap        ] GC(44) ParOldGen: 452628K(699392K)-&gt;502125K(699392K)</span><br><span class="line">[0.679s][info   ][gc,metaspace   ] GC(44) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.679s][info   ][gc             ] GC(44) Pause Young (Allocation Failure) 682M-&gt;554M(923M) 2.990ms</span><br><span class="line">[0.679s][info   ][gc,cpu         ] GC(44) User=0.02s Sys=0.00s Real=0.00s</span><br><span class="line">[0.689s][info   ][gc,start       ] GC(45) Pause Young (Allocation Failure)</span><br><span class="line">[0.696s][info   ][gc,heap        ] GC(45) PSYoungGen: 246184K(246272K)-&gt;65652K(264192K) Eden: 180174K(180224K)-&gt;0K(179200K) From: 66009K(66048K)-&gt;65652K(84992K)</span><br><span class="line">[0.696s][info   ][gc,heap        ] GC(45) ParOldGen: 502125K(699392K)-&gt;555658K(699392K)</span><br><span class="line">[0.696s][info   ][gc,metaspace   ] GC(45) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.697s][info   ][gc             ] GC(45) Pause Young (Allocation Failure) 730M-&gt;606M(941M) 7.331ms</span><br><span class="line">[0.697s][info   ][gc,cpu         ] GC(45) User=0.02s Sys=0.00s Real=0.01s</span><br><span class="line">[0.705s][info   ][gc,start       ] GC(46) Pause Young (Allocation Failure)</span><br><span class="line">[0.708s][info   ][gc,heap        ] GC(46) PSYoungGen: 244852K(264192K)-&gt;63211K(264192K) Eden: 179200K(179200K)-&gt;0K(179200K) From: 65652K(84992K)-&gt;63211K(84992K)</span><br><span class="line">[0.708s][info   ][gc,heap        ] GC(46) ParOldGen: 555658K(699392K)-&gt;610839K(699392K)</span><br><span class="line">[0.708s][info   ][gc,metaspace   ] GC(46) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.708s][info   ][gc             ] GC(46) Pause Young (Allocation Failure) 781M-&gt;658M(941M) 3.544ms</span><br><span class="line">[0.708s][info   ][gc,cpu         ] GC(46) User=0.02s Sys=0.00s Real=0.00s</span><br><span class="line">[0.717s][info   ][gc,start       ] GC(47) Pause Young (Allocation Failure)</span><br><span class="line">[0.720s][info   ][gc,heap        ] GC(47) PSYoungGen: 242378K(264192K)-&gt;64949K(265728K) Eden: 179166K(179200K)-&gt;0K(181760K) From: 63211K(84992K)-&gt;64949K(83968K)</span><br><span class="line">[0.720s][info   ][gc,heap        ] GC(47) ParOldGen: 610839K(699392K)-&gt;661578K(699392K)</span><br><span class="line">[0.720s][info   ][gc,metaspace   ] GC(47) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.720s][info   ][gc             ] GC(47) Pause Young (Allocation Failure) 833M-&gt;709M(942M) 3.314ms</span><br><span class="line">[0.720s][info   ][gc,cpu         ] GC(47) User=0.02s Sys=0.00s Real=0.00s</span><br><span class="line">[0.720s][info   ][gc,start       ] GC(48) Pause Full (Ergonomics)</span><br><span class="line">[0.720s][info   ][gc,phases,start] GC(48) Marking Phase</span><br><span class="line">[0.722s][info   ][gc,phases      ] GC(48) Marking Phase 2.200ms</span><br><span class="line">[0.722s][info   ][gc,phases,start] GC(48) Summary Phase</span><br><span class="line">[0.722s][info   ][gc,phases      ] GC(48) Summary Phase 0.027ms</span><br><span class="line">[0.722s][info   ][gc,phases,start] GC(48) Adjust Roots</span><br><span class="line">[0.723s][info   ][gc,phases      ] GC(48) Adjust Roots 0.218ms</span><br><span class="line">[0.723s][info   ][gc,phases,start] GC(48) Compaction Phase</span><br><span class="line">[0.729s][info   ][gc,phases      ] GC(48) Compaction Phase 6.742ms</span><br><span class="line">[0.729s][info   ][gc,phases,start] GC(48) Post Compact</span><br><span class="line">[0.730s][info   ][gc,phases      ] GC(48) Post Compact 0.278ms</span><br><span class="line">[0.730s][info   ][gc,heap        ] GC(48) PSYoungGen: 64949K(265728K)-&gt;0K(265216K) Eden: 0K(181760K)-&gt;0K(181760K) From: 64949K(83968K)-&gt;0K(83456K)</span><br><span class="line">[0.730s][info   ][gc,heap        ] GC(48) ParOldGen: 661578K(699392K)-&gt;353965K(699392K)</span><br><span class="line">[0.730s][info   ][gc,metaspace   ] GC(48) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.730s][info   ][gc             ] GC(48) Pause Full (Ergonomics) 709M-&gt;345M(942M) 9.648ms</span><br><span class="line">[0.730s][info   ][gc,cpu         ] GC(48) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[0.739s][info   ][gc,start       ] GC(49) Pause Young (Allocation Failure)</span><br><span class="line">[0.740s][info   ][gc,heap        ] GC(49) PSYoungGen: 181290K(265216K)-&gt;66108K(266240K) Eden: 181290K(181760K)-&gt;0K(182784K) From: 0K(83456K)-&gt;66108K(83456K)</span><br><span class="line">[0.741s][info   ][gc,heap        ] GC(49) ParOldGen: 353965K(699392K)-&gt;353965K(699392K)</span><br><span class="line">[0.741s][info   ][gc,metaspace   ] GC(49) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.741s][info   ][gc             ] GC(49) Pause Young (Allocation Failure) 522M-&gt;410M(943M) 1.834ms</span><br><span class="line">[0.741s][info   ][gc,cpu         ] GC(49) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.749s][info   ][gc,start       ] GC(50) Pause Young (Allocation Failure)</span><br><span class="line">[0.751s][info   ][gc,heap        ] GC(50) PSYoungGen: 248892K(266240K)-&gt;72180K(254976K) Eden: 182784K(182784K)-&gt;0K(182784K) From: 66108K(83456K)-&gt;72180K(72192K)</span><br><span class="line">[0.751s][info   ][gc,heap        ] GC(50) ParOldGen: 353965K(699392K)-&gt;403126K(699392K)</span><br><span class="line">[0.751s][info   ][gc,metaspace   ] GC(50) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.751s][info   ][gc             ] GC(50) Pause Young (Allocation Failure) 588M-&gt;464M(932M) 2.622ms</span><br><span class="line">[0.751s][info   ][gc,cpu         ] GC(50) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.760s][info   ][gc,start       ] GC(51) Pause Young (Allocation Failure)</span><br><span class="line">[0.764s][info   ][gc,heap        ] GC(51) PSYoungGen: 254964K(254976K)-&gt;66763K(264704K) Eden: 182784K(182784K)-&gt;0K(179712K) From: 72180K(72192K)-&gt;66763K(84992K)</span><br><span class="line">[0.764s][info   ][gc,heap        ] GC(51) ParOldGen: 403126K(699392K)-&gt;461598K(699392K)</span><br><span class="line">[0.764s][info   ][gc,metaspace   ] GC(51) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.764s][info   ][gc             ] GC(51) Pause Young (Allocation Failure) 642M-&gt;515M(941M) 3.769ms</span><br><span class="line">[0.764s][info   ][gc,cpu         ] GC(51) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.778s][info   ][gc,start       ] GC(52) Pause Young (Allocation Failure)</span><br><span class="line">[0.781s][info   ][gc,heap        ] GC(52) PSYoungGen: 246475K(264704K)-&gt;64251K(264192K) Eden: 179712K(179712K)-&gt;0K(179712K) From: 66763K(84992K)-&gt;64251K(84480K)</span><br><span class="line">[0.781s][info   ][gc,heap        ] GC(52) ParOldGen: 461598K(699392K)-&gt;514402K(699392K)</span><br><span class="line">[0.781s][info   ][gc,metaspace   ] GC(52) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.781s][info   ][gc             ] GC(52) Pause Young (Allocation Failure) 691M-&gt;565M(941M) 2.976ms</span><br><span class="line">[0.781s][info   ][gc,cpu         ] GC(52) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.789s][info   ][gc,start       ] GC(53) Pause Young (Allocation Failure)</span><br><span class="line">[0.793s][info   ][gc,heap        ] GC(53) PSYoungGen: 243963K(264192K)-&gt;66862K(266752K) Eden: 179712K(179712K)-&gt;0K(183808K) From: 64251K(84480K)-&gt;66862K(82944K)</span><br><span class="line">[0.793s][info   ][gc,heap        ] GC(53) ParOldGen: 514402K(699392K)-&gt;562241K(699392K)</span><br><span class="line">[0.793s][info   ][gc,metaspace   ] GC(53) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.793s][info   ][gc             ] GC(53) Pause Young (Allocation Failure) 740M-&gt;614M(943M) 3.696ms</span><br><span class="line">[0.793s][info   ][gc,cpu         ] GC(53) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.801s][info   ][gc,start       ] GC(54) Pause Young (Allocation Failure)</span><br><span class="line">[0.804s][info   ][gc,heap        ] GC(54) PSYoungGen: 250670K(266752K)-&gt;69836K(266240K) Eden: 183808K(183808K)-&gt;0K(183808K) From: 66862K(82944K)-&gt;69836K(82432K)</span><br><span class="line">[0.804s][info   ][gc,heap        ] GC(54) ParOldGen: 562241K(699392K)-&gt;617792K(699392K)</span><br><span class="line">[0.804s][info   ][gc,metaspace   ] GC(54) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.804s][info   ][gc             ] GC(54) Pause Young (Allocation Failure) 793M-&gt;671M(943M) 3.001ms</span><br><span class="line">[0.804s][info   ][gc,cpu         ] GC(54) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.813s][info   ][gc,start       ] GC(55) Pause Young (Allocation Failure)</span><br><span class="line">[0.817s][info   ][gc,heap        ] GC(55) PSYoungGen: 253644K(266240K)-&gt;71613K(264192K) Eden: 183808K(183808K)-&gt;0K(181248K) From: 69836K(82432K)-&gt;71613K(82944K)</span><br><span class="line">[0.817s][info   ][gc,heap        ] GC(55) ParOldGen: 617792K(699392K)-&gt;672132K(699392K)</span><br><span class="line">[0.817s][info   ][gc,metaspace   ] GC(55) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.817s][info   ][gc             ] GC(55) Pause Young (Allocation Failure) 851M-&gt;726M(941M) 4.353ms</span><br><span class="line">[0.817s][info   ][gc,cpu         ] GC(55) User=0.01s Sys=0.01s Real=0.01s</span><br><span class="line">[0.817s][info   ][gc,start       ] GC(56) Pause Full (Ergonomics)</span><br><span class="line">[0.817s][info   ][gc,phases,start] GC(56) Marking Phase</span><br><span class="line">[0.819s][info   ][gc,phases      ] GC(56) Marking Phase 1.712ms</span><br><span class="line">[0.819s][info   ][gc,phases,start] GC(56) Summary Phase</span><br><span class="line">[0.819s][info   ][gc,phases      ] GC(56) Summary Phase 0.027ms</span><br><span class="line">[0.819s][info   ][gc,phases,start] GC(56) Adjust Roots</span><br><span class="line">[0.819s][info   ][gc,phases      ] GC(56) Adjust Roots 0.148ms</span><br><span class="line">[0.819s][info   ][gc,phases,start] GC(56) Compaction Phase</span><br><span class="line">[0.825s][info   ][gc,phases      ] GC(56) Compaction Phase 6.432ms</span><br><span class="line">[0.826s][info   ][gc,phases,start] GC(56) Post Compact</span><br><span class="line">[0.826s][info   ][gc,phases      ] GC(56) Post Compact 0.284ms</span><br><span class="line">[0.826s][info   ][gc,heap        ] GC(56) PSYoungGen: 71613K(264192K)-&gt;0K(265216K) Eden: 0K(181248K)-&gt;0K(181248K) From: 71613K(82944K)-&gt;0K(83968K)</span><br><span class="line">[0.826s][info   ][gc,heap        ] GC(56) ParOldGen: 672132K(699392K)-&gt;354796K(699392K)</span><br><span class="line">[0.826s][info   ][gc,metaspace   ] GC(56) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.826s][info   ][gc             ] GC(56) Pause Full (Ergonomics) 726M-&gt;346M(942M) 8.802ms</span><br><span class="line">[0.826s][info   ][gc,cpu         ] GC(56) User=0.04s Sys=0.00s Real=0.01s</span><br><span class="line">[0.835s][info   ][gc,start       ] GC(57) Pause Young (Allocation Failure)</span><br><span class="line">[0.836s][info   ][gc,heap        ] GC(57) PSYoungGen: 181248K(265216K)-&gt;73337K(262144K) Eden: 181248K(181248K)-&gt;0K(178176K) From: 0K(83968K)-&gt;73337K(83968K)</span><br><span class="line">[0.836s][info   ][gc,heap        ] GC(57) ParOldGen: 354796K(699392K)-&gt;354796K(699392K)</span><br><span class="line">[0.836s][info   ][gc,metaspace   ] GC(57) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.836s][info   ][gc             ] GC(57) Pause Young (Allocation Failure) 523M-&gt;418M(939M) 1.907ms</span><br><span class="line">[0.836s][info   ][gc,cpu         ] GC(57) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.845s][info   ][gc,start       ] GC(58) Pause Young (Allocation Failure)</span><br><span class="line">[0.847s][info   ][gc,heap        ] GC(58) PSYoungGen: 251513K(262144K)-&gt;64626K(263680K) Eden: 178176K(178176K)-&gt;0K(178176K) From: 73337K(83968K)-&gt;64626K(85504K)</span><br><span class="line">[0.847s][info   ][gc,heap        ] GC(58) ParOldGen: 354796K(699392K)-&gt;413600K(699392K)</span><br><span class="line">[0.847s][info   ][gc,metaspace   ] GC(58) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.847s][info   ][gc             ] GC(58) Pause Young (Allocation Failure) 592M-&gt;467M(940M) 2.891ms</span><br><span class="line">[0.847s][info   ][gc,cpu         ] GC(58) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.857s][info   ][gc,start       ] GC(59) Pause Young (Allocation Failure)</span><br><span class="line">[0.859s][info   ][gc,heap        ] GC(59) PSYoungGen: 242798K(263680K)-&gt;59709K(266240K) Eden: 178171K(178176K)-&gt;0K(182784K) From: 64626K(85504K)-&gt;59709K(83456K)</span><br><span class="line">[0.859s][info   ][gc,heap        ] GC(59) ParOldGen: 413600K(699392K)-&gt;465864K(699392K)</span><br><span class="line">[0.859s][info   ][gc,metaspace   ] GC(59) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.859s][info   ][gc             ] GC(59) Pause Young (Allocation Failure) 641M-&gt;513M(943M) 2.607ms</span><br><span class="line">[0.859s][info   ][gc,cpu         ] GC(59) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.868s][info   ][gc,start       ] GC(60) Pause Young (Allocation Failure)</span><br><span class="line">[0.870s][info   ][gc,heap        ] GC(60) PSYoungGen: 241907K(266240K)-&gt;64716K(265728K) Eden: 182198K(182784K)-&gt;0K(182784K) From: 59709K(83456K)-&gt;64716K(82944K)</span><br><span class="line">[0.870s][info   ][gc,heap        ] GC(60) ParOldGen: 465864K(699392K)-&gt;518404K(699392K)</span><br><span class="line">[0.870s][info   ][gc,metaspace   ] GC(60) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.870s][info   ][gc             ] GC(60) Pause Young (Allocation Failure) 691M-&gt;569M(942M) 2.742ms</span><br><span class="line">[0.870s][info   ][gc,cpu         ] GC(60) User=0.02s Sys=0.00s Real=0.00s</span><br><span class="line">[0.878s][info   ][gc,start       ] GC(61) Pause Young (Allocation Failure)</span><br><span class="line">[0.882s][info   ][gc,heap        ] GC(61) PSYoungGen: 247263K(265728K)-&gt;70965K(267264K) Eden: 182546K(182784K)-&gt;0K(186368K) From: 64716K(82944K)-&gt;70965K(80896K)</span><br><span class="line">[0.882s][info   ][gc,heap        ] GC(61) ParOldGen: 518404K(699392K)-&gt;572494K(699392K)</span><br><span class="line">[0.882s][info   ][gc,metaspace   ] GC(61) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.882s][info   ][gc             ] GC(61) Pause Young (Allocation Failure) 747M-&gt;628M(944M) 3.305ms</span><br><span class="line">[0.882s][info   ][gc,cpu         ] GC(61) User=0.02s Sys=0.00s Real=0.00s</span><br><span class="line">[0.891s][info   ][gc,start       ] GC(62) Pause Young (Allocation Failure)</span><br><span class="line">[0.894s][info   ][gc,heap        ] GC(62) PSYoungGen: 257266K(267264K)-&gt;69320K(267776K) Eden: 186301K(186368K)-&gt;0K(186368K) From: 70965K(80896K)-&gt;69320K(81408K)</span><br><span class="line">[0.894s][info   ][gc,heap        ] GC(62) ParOldGen: 572494K(699392K)-&gt;626234K(699392K)</span><br><span class="line">[0.894s][info   ][gc,metaspace   ] GC(62) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.894s][info   ][gc             ] GC(62) Pause Young (Allocation Failure) 810M-&gt;679M(944M) 2.927ms</span><br><span class="line">[0.894s][info   ][gc,cpu         ] GC(62) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.894s][info   ][gc,start       ] GC(63) Pause Full (Ergonomics)</span><br><span class="line">[0.894s][info   ][gc,phases,start] GC(63) Marking Phase</span><br><span class="line">[0.896s][info   ][gc,phases      ] GC(63) Marking Phase 1.986ms</span><br><span class="line">[0.896s][info   ][gc,phases,start] GC(63) Summary Phase</span><br><span class="line">[0.896s][info   ][gc,phases      ] GC(63) Summary Phase 0.027ms</span><br><span class="line">[0.896s][info   ][gc,phases,start] GC(63) Adjust Roots</span><br><span class="line">[0.896s][info   ][gc,phases      ] GC(63) Adjust Roots 0.169ms</span><br><span class="line">[0.896s][info   ][gc,phases,start] GC(63) Compaction Phase</span><br><span class="line">[0.903s][info   ][gc,phases      ] GC(63) Compaction Phase 6.331ms</span><br><span class="line">[0.903s][info   ][gc,phases,start] GC(63) Post Compact</span><br><span class="line">[0.903s][info   ][gc,phases      ] GC(63) Post Compact 0.282ms</span><br><span class="line">[0.903s][info   ][gc,heap        ] GC(63) PSYoungGen: 69320K(267776K)-&gt;0K(267776K) Eden: 0K(186368K)-&gt;0K(186368K) From: 69320K(81408K)-&gt;0K(81408K)</span><br><span class="line">[0.903s][info   ][gc,heap        ] GC(63) ParOldGen: 626234K(699392K)-&gt;348289K(699392K)</span><br><span class="line">[0.903s][info   ][gc,metaspace   ] GC(63) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.903s][info   ][gc             ] GC(63) Pause Full (Ergonomics) 679M-&gt;340M(944M) 8.978ms</span><br><span class="line">[0.903s][info   ][gc,cpu         ] GC(63) User=0.03s Sys=0.00s Real=0.00s</span><br><span class="line">[0.912s][info   ][gc,start       ] GC(64) Pause Young (Allocation Failure)</span><br><span class="line">[0.914s][info   ][gc,heap        ] GC(64) PSYoungGen: 185978K(267776K)-&gt;63872K(267776K) Eden: 185978K(186368K)-&gt;0K(186368K) From: 0K(81408K)-&gt;63872K(81408K)</span><br><span class="line">[0.914s][info   ][gc,heap        ] GC(64) ParOldGen: 348289K(699392K)-&gt;348289K(699392K)</span><br><span class="line">[0.914s][info   ][gc,metaspace   ] GC(64) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.914s][info   ][gc             ] GC(64) Pause Young (Allocation Failure) 521M-&gt;402M(944M) 1.973ms</span><br><span class="line">[0.914s][info   ][gc,cpu         ] GC(64) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.923s][info   ][gc,start       ] GC(65) Pause Young (Allocation Failure)</span><br><span class="line">[0.925s][info   ][gc,heap        ] GC(65) PSYoungGen: 250191K(267776K)-&gt;63711K(269824K) Eden: 186319K(186368K)-&gt;0K(189440K) From: 63872K(81408K)-&gt;63711K(80384K)</span><br><span class="line">[0.925s][info   ][gc,heap        ] GC(65) ParOldGen: 348289K(699392K)-&gt;400820K(699392K)</span><br><span class="line">[0.925s][info   ][gc,metaspace   ] GC(65) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.925s][info   ][gc             ] GC(65) Pause Young (Allocation Failure) 584M-&gt;453M(946M) 2.612ms</span><br><span class="line">[0.925s][info   ][gc,cpu         ] GC(65) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.935s][info   ][gc,start       ] GC(66) Pause Young (Allocation Failure)</span><br><span class="line">[0.937s][info   ][gc,heap        ] GC(66) PSYoungGen: 253151K(269824K)-&gt;66375K(268800K) Eden: 189440K(189440K)-&gt;0K(189440K) From: 63711K(80384K)-&gt;66375K(79360K)</span><br><span class="line">[0.937s][info   ][gc,heap        ] GC(66) ParOldGen: 400820K(699392K)-&gt;454260K(699392K)</span><br><span class="line">[0.937s][info   ][gc,metaspace   ] GC(66) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.937s][info   ][gc             ] GC(66) Pause Young (Allocation Failure) 638M-&gt;508M(945M) 2.595ms</span><br><span class="line">[0.937s][info   ][gc,cpu         ] GC(66) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.949s][info   ][gc,start       ] GC(67) Pause Young (Allocation Failure)</span><br><span class="line">[0.954s][info   ][gc,heap        ] GC(67) PSYoungGen: 255320K(268800K)-&gt;69962K(270848K) Eden: 188944K(189440K)-&gt;0K(192512K) From: 66375K(79360K)-&gt;69962K(78336K)</span><br><span class="line">[0.954s][info   ][gc,heap        ] GC(67) ParOldGen: 454260K(699392K)-&gt;509352K(699392K)</span><br><span class="line">[0.954s][info   ][gc,metaspace   ] GC(67) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.954s][info   ][gc             ] GC(67) Pause Young (Allocation Failure) 692M-&gt;565M(947M) 4.234ms</span><br><span class="line">[0.954s][info   ][gc,cpu         ] GC(67) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.964s][info   ][gc,start       ] GC(68) Pause Young (Allocation Failure)</span><br><span class="line">[0.967s][info   ][gc,heap        ] GC(68) PSYoungGen: 262474K(270848K)-&gt;66503K(270848K) Eden: 192512K(192512K)-&gt;0K(192512K) From: 69962K(78336K)-&gt;66503K(78336K)</span><br><span class="line">[0.967s][info   ][gc,heap        ] GC(68) ParOldGen: 509352K(699392K)-&gt;563032K(699392K)</span><br><span class="line">[0.967s][info   ][gc,metaspace   ] GC(68) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.967s][info   ][gc             ] GC(68) Pause Young (Allocation Failure) 753M-&gt;614M(947M) 3.037ms</span><br><span class="line">[0.967s][info   ][gc,cpu         ] GC(68) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.977s][info   ][gc,start       ] GC(69) Pause Young (Allocation Failure)</span><br><span class="line">[0.981s][info   ][gc,heap        ] GC(69) PSYoungGen: 259001K(270848K)-&gt;70775K(269824K) Eden: 192497K(192512K)-&gt;0K(192512K) From: 66503K(78336K)-&gt;70775K(77312K)</span><br><span class="line">[0.981s][info   ][gc,heap        ] GC(69) ParOldGen: 563032K(699392K)-&gt;617318K(699392K)</span><br><span class="line">[0.981s][info   ][gc,metaspace   ] GC(69) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.981s][info   ][gc             ] GC(69) Pause Young (Allocation Failure) 802M-&gt;671M(946M) 4.155ms</span><br><span class="line">[0.981s][info   ][gc,cpu         ] GC(69) User=0.02s Sys=0.00s Real=0.00s</span><br><span class="line">[0.991s][info   ][gc,start       ] GC(70) Pause Young (Allocation Failure)</span><br><span class="line">[0.994s][info   ][gc,heap        ] GC(70) PSYoungGen: 263287K(269824K)-&gt;72525K(265216K) Eden: 192512K(192512K)-&gt;0K(192512K) From: 70775K(77312K)-&gt;72525K(72704K)</span><br><span class="line">[0.994s][info   ][gc,heap        ] GC(70) ParOldGen: 617318K(699392K)-&gt;675529K(699392K)</span><br><span class="line">[0.994s][info   ][gc,metaspace   ] GC(70) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.994s][info   ][gc             ] GC(70) Pause Young (Allocation Failure) 859M-&gt;730M(942M) 3.413ms</span><br><span class="line">[0.994s][info   ][gc,cpu         ] GC(70) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.994s][info   ][gc,start       ] GC(71) Pause Full (Ergonomics)</span><br><span class="line">[0.994s][info   ][gc,phases,start] GC(71) Marking Phase</span><br><span class="line">[0.996s][info   ][gc,phases      ] GC(71) Marking Phase 1.916ms</span><br><span class="line">[0.996s][info   ][gc,phases,start] GC(71) Summary Phase</span><br><span class="line">[0.996s][info   ][gc,phases      ] GC(71) Summary Phase 0.027ms</span><br><span class="line">[0.996s][info   ][gc,phases,start] GC(71) Adjust Roots</span><br><span class="line">[0.996s][info   ][gc,phases      ] GC(71) Adjust Roots 0.148ms</span><br><span class="line">[0.996s][info   ][gc,phases,start] GC(71) Compaction Phase</span><br><span class="line">[1.002s][info   ][gc,phases      ] GC(71) Compaction Phase 6.091ms</span><br><span class="line">[1.002s][info   ][gc,phases,start] GC(71) Post Compact</span><br><span class="line">[1.003s][info   ][gc,phases      ] GC(71) Post Compact 0.287ms</span><br><span class="line">[1.003s][info   ][gc,heap        ] GC(71) PSYoungGen: 72525K(265216K)-&gt;0K(269824K) Eden: 0K(192512K)-&gt;0K(190464K) From: 72525K(72704K)-&gt;0K(79360K)</span><br><span class="line">[1.003s][info   ][gc,heap        ] GC(71) ParOldGen: 675529K(699392K)-&gt;349547K(699392K)</span><br><span class="line">[1.003s][info   ][gc,metaspace   ] GC(71) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.003s][info   ][gc             ] GC(71) Pause Full (Ergonomics) 730M-&gt;341M(946M) 8.659ms</span><br><span class="line">[1.003s][info   ][gc,cpu         ] GC(71) User=0.04s Sys=0.00s Real=0.00s</span><br><span class="line">[1.013s][info   ][gc,start       ] GC(72) Pause Young (Allocation Failure)</span><br><span class="line">[1.015s][info   ][gc,heap        ] GC(72) PSYoungGen: 190464K(269824K)-&gt;64261K(269824K) Eden: 190464K(190464K)-&gt;0K(190464K) From: 0K(79360K)-&gt;64261K(79360K)</span><br><span class="line">[1.015s][info   ][gc,heap        ] GC(72) ParOldGen: 349547K(699392K)-&gt;349547K(699392K)</span><br><span class="line">[1.015s][info   ][gc,metaspace   ] GC(72) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.015s][info   ][gc             ] GC(72) Pause Young (Allocation Failure) 527M-&gt;404M(946M) 2.106ms</span><br><span class="line">[1.015s][info   ][gc,cpu         ] GC(72) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">counter:50304</span><br><span class="line">[1.025s][info   ][gc,heap,exit   ] Heap</span><br><span class="line">[1.025s][info   ][gc,heap,exit   ]  PSYoungGen      total 269824K, used 174317K [0x00000007eab00000, 0x0000000800000000, 0x0000000800000000)</span><br><span class="line">[1.025s][info   ][gc,heap,exit   ]   eden space 190464K, 57% used [0x00000007eab00000,0x00000007f167a1d0,0x00000007f6500000)</span><br><span class="line">[1.025s][info   ][gc,heap,exit   ]   from space 79360K, 80% used [0x00000007f6500000,0x00000007fa3c1450,0x00000007fb280000)</span><br><span class="line">[1.025s][info   ][gc,heap,exit   ]   to   space 78336K, 0% used [0x00000007fb380000,0x00000007fb380000,0x0000000800000000)</span><br><span class="line">[1.025s][info   ][gc,heap,exit   ]  ParOldGen       total 699392K, used 349547K [0x00000007c0000000, 0x00000007eab00000, 0x00000007eab00000)</span><br><span class="line">[1.025s][info   ][gc,heap,exit   ]   object space 699392K, 49% used [0x00000007c0000000,0x00000007d555ad30,0x00000007eab00000)</span><br><span class="line">[1.025s][info   ][gc,heap,exit   ]  Metaspace       used 233K, committed 448K, reserved 1114112K</span><br><span class="line">[1.025s][info   ][gc,heap,exit   ]   class space    used 9K, committed 128K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>在试试2g内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+UseParallelGC -Xms2g -Xmx2g -XX:+PrintGCDetails -Xlog:gc\*:file=gc.log:time,uptime,level,tags GCLogAnalysis</span><br></pre></td></tr></table></figure>

<p>可以发现跟1g内存相比，GC次数大大减少，但是吞吐量并没有明显增加。仅仅生成了55000多个对象。但是性能依然比串行GC强大</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0.001s][warning][gc] -XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.</span><br><span class="line">[0.008s][info   ][gc,init] CardTable entry size: 512</span><br><span class="line">[0.008s][info   ][gc     ] Using Parallel</span><br><span class="line">[0.009s][info   ][gc,init] Version: 19.0.2+7-44 (release)</span><br><span class="line">[0.009s][info   ][gc,init] CPUs: 8 total, 8 available</span><br><span class="line">[0.009s][info   ][gc,init] Memory: 16384M</span><br><span class="line">[0.009s][info   ][gc,init] Large Page Support: Disabled</span><br><span class="line">[0.009s][info   ][gc,init] NUMA Support: Disabled</span><br><span class="line">[0.009s][info   ][gc,init] Compressed Oops: Enabled (Zero based)</span><br><span class="line">[0.009s][info   ][gc,init] Alignments: Space 512K, Generation 512K, Heap 8M</span><br><span class="line">[0.009s][info   ][gc,init] Heap Min Capacity: 2G</span><br><span class="line">[0.009s][info   ][gc,init] Heap Initial Capacity: 2G</span><br><span class="line">[0.009s][info   ][gc,init] Heap Max Capacity: 2G</span><br><span class="line">[0.009s][info   ][gc,init] Pre-touch: Disabled</span><br><span class="line">[0.009s][info   ][gc,init] Parallel Workers: 8</span><br><span class="line">[0.009s][info   ][gc,metaspace] CDS archive(s) mapped at: [0x0000000800000000-0x0000000800c44000-0x0000000800c44000), size 12861440, SharedBaseAddress: 0x0000000800000000, ArchiveRelocationMode: 0.</span><br><span class="line">[0.009s][info   ][gc,metaspace] Compressed class space mapped at: 0x0000000801000000-0x0000000841000000, reserved size: 1073741824</span><br><span class="line">[0.010s][info   ][gc,metaspace] Narrow klass base: 0x0000000800000000, Narrow klass shift: 0, Narrow klass range: 0x100000000</span><br><span class="line">gc...</span><br><span class="line">[0.090s][info   ][gc,start    ] GC(0) Pause Young (Allocation Failure)</span><br><span class="line">[0.112s][info   ][gc,heap     ] GC(0) PSYoungGen: 524800K(611840K)-&gt;87031K(611840K) Eden: 524800K(524800K)-&gt;0K(524800K) From: 0K(87040K)-&gt;87031K(87040K)</span><br><span class="line">[0.112s][info   ][gc,heap     ] GC(0) ParOldGen: 992K(1398272K)-&gt;61286K(1398272K)</span><br><span class="line">[0.112s][info   ][gc,metaspace] GC(0) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.112s][info   ][gc          ] GC(0) Pause Young (Allocation Failure) 513M-&gt;144M(1963M) 22.679ms</span><br><span class="line">[0.112s][info   ][gc,cpu      ] GC(0) User=0.01s Sys=0.10s Real=0.03s</span><br><span class="line">[0.140s][info   ][gc,start    ] GC(1) Pause Young (Allocation Failure)</span><br><span class="line">[0.173s][info   ][gc,heap     ] GC(1) PSYoungGen: 611831K(611840K)-&gt;87036K(611840K) Eden: 524800K(524800K)-&gt;0K(524800K) From: 87031K(87040K)-&gt;87036K(87040K)</span><br><span class="line">[0.173s][info   ][gc,heap     ] GC(1) ParOldGen: 61286K(1398272K)-&gt;191982K(1398272K)</span><br><span class="line">[0.173s][info   ][gc,metaspace] GC(1) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.173s][info   ][gc          ] GC(1) Pause Young (Allocation Failure) 657M-&gt;272M(1963M) 32.979ms</span><br><span class="line">[0.173s][info   ][gc,cpu      ] GC(1) User=0.01s Sys=0.15s Real=0.04s</span><br><span class="line">[0.199s][info   ][gc,start    ] GC(2) Pause Young (Allocation Failure)</span><br><span class="line">[0.221s][info   ][gc,heap     ] GC(2) PSYoungGen: 611836K(611840K)-&gt;87029K(611840K) Eden: 524800K(524800K)-&gt;0K(524800K) From: 87036K(87040K)-&gt;87029K(87040K)</span><br><span class="line">[0.221s][info   ][gc,heap     ] GC(2) ParOldGen: 191982K(1398272K)-&gt;317206K(1398272K)</span><br><span class="line">[0.221s][info   ][gc,metaspace] GC(2) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.221s][info   ][gc          ] GC(2) Pause Young (Allocation Failure) 784M-&gt;394M(1963M) 21.600ms</span><br><span class="line">[0.221s][info   ][gc,cpu      ] GC(2) User=0.02s Sys=0.09s Real=0.02s</span><br><span class="line">[0.246s][info   ][gc,start    ] GC(3) Pause Young (Allocation Failure)</span><br><span class="line">[0.267s][info   ][gc,heap     ] GC(3) PSYoungGen: 611829K(611840K)-&gt;87039K(611840K) Eden: 524800K(524800K)-&gt;0K(524800K) From: 87029K(87040K)-&gt;87039K(87040K)</span><br><span class="line">[0.267s][info   ][gc,heap     ] GC(3) ParOldGen: 317206K(1398272K)-&gt;438522K(1398272K)</span><br><span class="line">[0.267s][info   ][gc,metaspace] GC(3) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.267s][info   ][gc          ] GC(3) Pause Young (Allocation Failure) 907M-&gt;513M(1963M) 20.535ms</span><br><span class="line">[0.267s][info   ][gc,cpu      ] GC(3) User=0.02s Sys=0.09s Real=0.02s</span><br><span class="line">[0.292s][info   ][gc,start    ] GC(4) Pause Young (Allocation Failure)</span><br><span class="line">[0.311s][info   ][gc,heap     ] GC(4) PSYoungGen: 611839K(611840K)-&gt;87030K(611840K) Eden: 524800K(524800K)-&gt;0K(524800K) From: 87039K(87040K)-&gt;87030K(87040K)</span><br><span class="line">[0.311s][info   ][gc,heap     ] GC(4) ParOldGen: 438522K(1398272K)-&gt;552672K(1398272K)</span><br><span class="line">[0.311s][info   ][gc,metaspace] GC(4) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.311s][info   ][gc          ] GC(4) Pause Young (Allocation Failure) 1025M-&gt;624M(1963M) 18.904ms</span><br><span class="line">[0.311s][info   ][gc,cpu      ] GC(4) User=0.02s Sys=0.07s Real=0.01s</span><br><span class="line">[0.337s][info   ][gc,start    ] GC(5) Pause Young (Allocation Failure)</span><br><span class="line">[0.357s][info   ][gc,heap     ] GC(5) PSYoungGen: 611830K(611840K)-&gt;87039K(320000K) Eden: 524800K(524800K)-&gt;0K(232960K) From: 87030K(87040K)-&gt;87039K(87040K)</span><br><span class="line">[0.357s][info   ][gc,heap     ] GC(5) ParOldGen: 552672K(1398272K)-&gt;674964K(1398272K)</span><br><span class="line">[0.357s][info   ][gc,metaspace] GC(5) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.357s][info   ][gc          ] GC(5) Pause Young (Allocation Failure) 1137M-&gt;744M(1678M) 20.775ms</span><br><span class="line">[0.357s][info   ][gc,cpu      ] GC(5) User=0.02s Sys=0.08s Real=0.02s</span><br><span class="line">[0.368s][info   ][gc,start    ] GC(6) Pause Young (Allocation Failure)</span><br><span class="line">[0.372s][info   ][gc,heap     ] GC(6) PSYoungGen: 319999K(320000K)-&gt;146545K(465920K) Eden: 232960K(232960K)-&gt;0K(232960K) From: 87039K(87040K)-&gt;146545K(232960K)</span><br><span class="line">[0.372s][info   ][gc,heap     ] GC(6) ParOldGen: 674964K(1398272K)-&gt;677669K(1398272K)</span><br><span class="line">[0.372s][info   ][gc,metaspace] GC(6) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.372s][info   ][gc          ] GC(6) Pause Young (Allocation Failure) 971M-&gt;804M(1820M) 4.059ms</span><br><span class="line">[0.372s][info   ][gc,cpu      ] GC(6) User=0.01s Sys=0.01s Real=0.01s</span><br><span class="line">[0.382s][info   ][gc,start    ] GC(7) Pause Young (Allocation Failure)</span><br><span class="line">[0.387s][info   ][gc,heap     ] GC(7) PSYoungGen: 379505K(465920K)-&gt;184215K(465920K) Eden: 232960K(232960K)-&gt;0K(232960K) From: 146545K(232960K)-&gt;184215K(232960K)</span><br><span class="line">[0.387s][info   ][gc,heap     ] GC(7) ParOldGen: 677669K(1398272K)-&gt;684801K(1398272K)</span><br><span class="line">[0.387s][info   ][gc,metaspace] GC(7) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.387s][info   ][gc          ] GC(7) Pause Young (Allocation Failure) 1032M-&gt;848M(1820M) 4.360ms</span><br><span class="line">[0.387s][info   ][gc,cpu      ] GC(7) User=0.02s Sys=0.00s Real=0.00s</span><br><span class="line">[0.398s][info   ][gc,start    ] GC(8) Pause Young (Allocation Failure)</span><br><span class="line">[0.405s][info   ][gc,heap     ] GC(8) PSYoungGen: 417175K(465920K)-&gt;189133K(465920K) Eden: 232960K(232960K)-&gt;0K(232960K) From: 184215K(232960K)-&gt;189133K(232960K)</span><br><span class="line">[0.405s][info   ][gc,heap     ] GC(8) ParOldGen: 684801K(1398272K)-&gt;712032K(1398272K)</span><br><span class="line">[0.406s][info   ][gc,metaspace] GC(8) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.406s][info   ][gc          ] GC(8) Pause Young (Allocation Failure) 1076M-&gt;880M(1820M) 7.531ms</span><br><span class="line">[0.406s][info   ][gc,cpu      ] GC(8) User=0.03s Sys=0.01s Real=0.01s</span><br><span class="line">[0.416s][info   ][gc,start    ] GC(9) Pause Young (Allocation Failure)</span><br><span class="line">[0.429s][info   ][gc,heap     ] GC(9) PSYoungGen: 422093K(465920K)-&gt;141865K(465920K) Eden: 232960K(232960K)-&gt;0K(232960K) From: 189133K(232960K)-&gt;141865K(232960K)</span><br><span class="line">[0.429s][info   ][gc,heap     ] GC(9) ParOldGen: 712032K(1398272K)-&gt;794384K(1398272K)</span><br><span class="line">[0.429s][info   ][gc,metaspace] GC(9) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.429s][info   ][gc          ] GC(9) Pause Young (Allocation Failure) 1107M-&gt;914M(1820M) 12.835ms</span><br><span class="line">[0.429s][info   ][gc,cpu      ] GC(9) User=0.01s Sys=0.05s Real=0.01s</span><br><span class="line">[0.441s][info   ][gc,start    ] GC(10) Pause Young (Allocation Failure)</span><br><span class="line">[0.458s][info   ][gc,heap     ] GC(10) PSYoungGen: 374825K(465920K)-&gt;76198K(465920K) Eden: 232960K(232960K)-&gt;0K(232960K) From: 141865K(232960K)-&gt;76198K(232960K)</span><br><span class="line">[0.458s][info   ][gc,heap     ] GC(10) ParOldGen: 794384K(1398272K)-&gt;904007K(1398272K)</span><br><span class="line">[0.458s][info   ][gc,metaspace] GC(10) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.458s][info   ][gc          ] GC(10) Pause Young (Allocation Failure) 1141M-&gt;957M(1820M) 17.027ms</span><br><span class="line">[0.458s][info   ][gc,cpu      ] GC(10) User=0.02s Sys=0.05s Real=0.02s</span><br><span class="line">[0.469s][info   ][gc,start    ] GC(11) Pause Young (Allocation Failure)</span><br><span class="line">[0.478s][info   ][gc,heap     ] GC(11) PSYoungGen: 309158K(465920K)-&gt;84341K(465920K) Eden: 232960K(232960K)-&gt;0K(232960K) From: 76198K(232960K)-&gt;84341K(232960K)</span><br><span class="line">[0.478s][info   ][gc,heap     ] GC(11) ParOldGen: 904007K(1398272K)-&gt;961218K(1398272K)</span><br><span class="line">[0.478s][info   ][gc,metaspace] GC(11) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.478s][info   ][gc          ] GC(11) Pause Young (Allocation Failure) 1184M-&gt;1021M(1820M) 8.948ms</span><br><span class="line">[0.478s][info   ][gc,cpu      ] GC(11) User=0.01s Sys=0.03s Real=0.01s</span><br><span class="line">[0.489s][info   ][gc,start    ] GC(12) Pause Young (Allocation Failure)</span><br><span class="line">[0.499s][info   ][gc,heap     ] GC(12) PSYoungGen: 317301K(465920K)-&gt;91409K(465920K) Eden: 232960K(232960K)-&gt;0K(232960K) From: 84341K(232960K)-&gt;91409K(232960K)</span><br><span class="line">[0.499s][info   ][gc,heap     ] GC(12) ParOldGen: 961218K(1398272K)-&gt;1024078K(1398272K)</span><br><span class="line">[0.499s][info   ][gc,metaspace] GC(12) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.499s][info   ][gc          ] GC(12) Pause Young (Allocation Failure) 1248M-&gt;1089M(1820M) 10.357ms</span><br><span class="line">[0.499s][info   ][gc,cpu      ] GC(12) User=0.01s Sys=0.03s Real=0.01s</span><br><span class="line">[0.511s][info   ][gc,start    ] GC(13) Pause Young (Allocation Failure)</span><br><span class="line">[0.522s][info   ][gc,heap     ] GC(13) PSYoungGen: 324369K(465920K)-&gt;86160K(465920K) Eden: 232960K(232960K)-&gt;0K(232960K) From: 91409K(232960K)-&gt;86160K(232960K)</span><br><span class="line">[0.522s][info   ][gc,heap     ] GC(13) ParOldGen: 1024078K(1398272K)-&gt;1090071K(1398272K)</span><br><span class="line">[0.522s][info   ][gc,metaspace] GC(13) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.522s][info   ][gc          ] GC(13) Pause Young (Allocation Failure) 1316M-&gt;1148M(1820M) 10.590ms</span><br><span class="line">[0.522s][info   ][gc,cpu      ] GC(13) User=0.02s Sys=0.04s Real=0.02s</span><br><span class="line">[0.534s][info   ][gc,start    ] GC(14) Pause Young (Allocation Failure)</span><br><span class="line">[0.545s][info   ][gc,heap     ] GC(14) PSYoungGen: 319120K(465920K)-&gt;84397K(465920K) Eden: 232960K(232960K)-&gt;0K(232960K) From: 86160K(232960K)-&gt;84397K(232960K)</span><br><span class="line">[0.545s][info   ][gc,heap     ] GC(14) ParOldGen: 1090071K(1398272K)-&gt;1154089K(1398272K)</span><br><span class="line">[0.545s][info   ][gc,metaspace] GC(14) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.545s][info   ][gc          ] GC(14) Pause Young (Allocation Failure) 1376M-&gt;1209M(1820M) 11.072ms</span><br><span class="line">[0.545s][info   ][gc,cpu      ] GC(14) User=0.01s Sys=0.03s Real=0.01s</span><br><span class="line">[0.556s][info   ][gc,start    ] GC(15) Pause Young (Allocation Failure)</span><br><span class="line">[0.571s][info   ][gc,heap     ] GC(15) PSYoungGen: 317357K(465920K)-&gt;82614K(465920K) Eden: 232960K(232960K)-&gt;0K(232960K) From: 84397K(232960K)-&gt;82614K(232960K)</span><br><span class="line">[0.571s][info   ][gc,heap     ] GC(15) ParOldGen: 1154089K(1398272K)-&gt;1218247K(1398272K)</span><br><span class="line">[0.571s][info   ][gc,metaspace] GC(15) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.571s][info   ][gc          ] GC(15) Pause Young (Allocation Failure) 1436M-&gt;1270M(1820M) 15.289ms</span><br><span class="line">[0.571s][info   ][gc,cpu      ] GC(15) User=0.02s Sys=0.02s Real=0.02s</span><br><span class="line">[0.582s][info   ][gc,start    ] GC(16) Pause Young (Allocation Failure)</span><br><span class="line">[0.593s][info   ][gc,heap     ] GC(16) PSYoungGen: 315458K(465920K)-&gt;86317K(465920K) Eden: 232843K(232960K)-&gt;0K(232960K) From: 82614K(232960K)-&gt;86317K(232960K)</span><br><span class="line">[0.593s][info   ][gc,heap     ] GC(16) ParOldGen: 1218247K(1398272K)-&gt;1282310K(1398272K)</span><br><span class="line">[0.593s][info   ][gc,metaspace] GC(16) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.593s][info   ][gc          ] GC(16) Pause Young (Allocation Failure) 1497M-&gt;1336M(1820M) 10.896ms</span><br><span class="line">[0.593s][info   ][gc,cpu      ] GC(16) User=0.02s Sys=0.04s Real=0.01s</span><br><span class="line">[0.593s][info   ][gc,start    ] GC(17) Pause Full (Ergonomics)</span><br><span class="line">[0.593s][info   ][gc,phases,start] GC(17) Marking Phase</span><br><span class="line">[0.598s][info   ][gc,phases      ] GC(17) Marking Phase 4.460ms</span><br><span class="line">[0.598s][info   ][gc,phases,start] GC(17) Summary Phase</span><br><span class="line">[0.598s][info   ][gc,phases      ] GC(17) Summary Phase 0.032ms</span><br><span class="line">[0.598s][info   ][gc,phases,start] GC(17) Adjust Roots</span><br><span class="line">[0.598s][info   ][gc,phases      ] GC(17) Adjust Roots 0.291ms</span><br><span class="line">[0.598s][info   ][gc,phases,start] GC(17) Compaction Phase</span><br><span class="line">[0.613s][info   ][gc,phases      ] GC(17) Compaction Phase 14.951ms</span><br><span class="line">[0.613s][info   ][gc,phases,start] GC(17) Post Compact</span><br><span class="line">[0.615s][info   ][gc,phases      ] GC(17) Post Compact 1.997ms</span><br><span class="line">[0.617s][info   ][gc,heap        ] GC(17) PSYoungGen: 86317K(465920K)-&gt;0K(465920K) Eden: 0K(232960K)-&gt;0K(232960K) From: 86317K(232960K)-&gt;0K(232960K)</span><br><span class="line">[0.617s][info   ][gc,heap        ] GC(17) ParOldGen: 1282310K(1398272K)-&gt;354109K(1055744K)</span><br><span class="line">[0.617s][info   ][gc,metaspace   ] GC(17) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.617s][info   ][gc             ] GC(17) Pause Full (Ergonomics) 1336M-&gt;345M(1486M) 24.063ms</span><br><span class="line">[0.617s][info   ][gc,cpu         ] GC(17) User=0.04s Sys=0.04s Real=0.02s</span><br><span class="line">[0.629s][info   ][gc,start       ] GC(18) Pause Young (Allocation Failure)</span><br><span class="line">[0.631s][info   ][gc,heap        ] GC(18) PSYoungGen: 232960K(465920K)-&gt;81182K(465920K) Eden: 232960K(232960K)-&gt;0K(232960K) From: 0K(232960K)-&gt;81182K(232960K)</span><br><span class="line">[0.631s][info   ][gc,heap        ] GC(18) ParOldGen: 354109K(1055744K)-&gt;354109K(1055744K)</span><br><span class="line">[0.631s][info   ][gc,metaspace   ] GC(18) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.631s][info   ][gc             ] GC(18) Pause Young (Allocation Failure) 573M-&gt;425M(1486M) 2.269ms</span><br><span class="line">[0.631s][info   ][gc,cpu         ] GC(18) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.643s][info   ][gc,start       ] GC(19) Pause Young (Allocation Failure)</span><br><span class="line">[0.646s][info   ][gc,heap        ] GC(19) PSYoungGen: 314142K(465920K)-&gt;88267K(465920K) Eden: 232960K(232960K)-&gt;0K(232960K) From: 81182K(232960K)-&gt;88267K(232960K)</span><br><span class="line">[0.646s][info   ][gc,heap        ] GC(19) ParOldGen: 354109K(1055744K)-&gt;416374K(1055744K)</span><br><span class="line">[0.646s][info   ][gc,metaspace   ] GC(19) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.646s][info   ][gc             ] GC(19) Pause Young (Allocation Failure) 652M-&gt;492M(1486M) 3.236ms</span><br><span class="line">[0.646s][info   ][gc,cpu         ] GC(19) User=0.01s Sys=0.01s Real=0.00s</span><br><span class="line">[0.657s][info   ][gc,start       ] GC(20) Pause Young (Allocation Failure)</span><br><span class="line">[0.660s][info   ][gc,heap        ] GC(20) PSYoungGen: 321227K(465920K)-&gt;79763K(465920K) Eden: 232960K(232960K)-&gt;0K(232960K) From: 88267K(232960K)-&gt;79763K(232960K)</span><br><span class="line">[0.660s][info   ][gc,heap        ] GC(20) ParOldGen: 416374K(1055744K)-&gt;480706K(1055744K)</span><br><span class="line">[0.660s][info   ][gc,metaspace   ] GC(20) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.660s][info   ][gc             ] GC(20) Pause Young (Allocation Failure) 720M-&gt;547M(1486M) 3.221ms</span><br><span class="line">[0.660s][info   ][gc,cpu         ] GC(20) User=0.02s Sys=0.00s Real=0.00s</span><br><span class="line">[0.671s][info   ][gc,start       ] GC(21) Pause Young (Allocation Failure)</span><br><span class="line">[0.674s][info   ][gc,heap        ] GC(21) PSYoungGen: 312723K(465920K)-&gt;86716K(465920K) Eden: 232960K(232960K)-&gt;0K(232960K) From: 79763K(232960K)-&gt;86716K(232960K)</span><br><span class="line">[0.675s][info   ][gc,heap        ] GC(21) ParOldGen: 480706K(1055744K)-&gt;539008K(1055744K)</span><br><span class="line">[0.675s][info   ][gc,metaspace   ] GC(21) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.675s][info   ][gc             ] GC(21) Pause Young (Allocation Failure) 774M-&gt;611M(1486M) 3.790ms</span><br><span class="line">[0.675s][info   ][gc,cpu         ] GC(21) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.686s][info   ][gc,start       ] GC(22) Pause Young (Allocation Failure)</span><br><span class="line">[0.690s][info   ][gc,heap        ] GC(22) PSYoungGen: 319676K(465920K)-&gt;86769K(465920K) Eden: 232960K(232960K)-&gt;0K(232960K) From: 86716K(232960K)-&gt;86769K(232960K)</span><br><span class="line">[0.690s][info   ][gc,heap        ] GC(22) ParOldGen: 539008K(1055744K)-&gt;606035K(1055744K)</span><br><span class="line">[0.690s][info   ][gc,metaspace   ] GC(22) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.690s][info   ][gc             ] GC(22) Pause Young (Allocation Failure) 838M-&gt;676M(1486M) 3.756ms</span><br><span class="line">[0.690s][info   ][gc,cpu         ] GC(22) User=0.02s Sys=0.00s Real=0.00s</span><br><span class="line">[0.701s][info   ][gc,start       ] GC(23) Pause Young (Allocation Failure)</span><br><span class="line">[0.706s][info   ][gc,heap        ] GC(23) PSYoungGen: 319729K(465920K)-&gt;84737K(474624K) Eden: 232960K(232960K)-&gt;0K(243712K) From: 86769K(232960K)-&gt;84737K(230912K)</span><br><span class="line">[0.706s][info   ][gc,heap        ] GC(23) ParOldGen: 606035K(1055744K)-&gt;673967K(1055744K)</span><br><span class="line">[0.706s][info   ][gc,metaspace   ] GC(23) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.706s][info   ][gc             ] GC(23) Pause Young (Allocation Failure) 904M-&gt;740M(1494M) 4.809ms</span><br><span class="line">[0.706s][info   ][gc,cpu         ] GC(23) User=0.02s Sys=0.01s Real=0.00s</span><br><span class="line">[0.718s][info   ][gc,start       ] GC(24) Pause Young (Allocation Failure)</span><br><span class="line">[0.722s][info   ][gc,heap        ] GC(24) PSYoungGen: 328339K(474624K)-&gt;89229K(467968K) Eden: 243602K(243712K)-&gt;0K(243712K) From: 84737K(230912K)-&gt;89229K(224256K)</span><br><span class="line">[0.722s][info   ][gc,heap        ] GC(24) ParOldGen: 673967K(1055744K)-&gt;736386K(1055744K)</span><br><span class="line">[0.722s][info   ][gc,metaspace   ] GC(24) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.722s][info   ][gc             ] GC(24) Pause Young (Allocation Failure) 978M-&gt;806M(1488M) 4.306ms</span><br><span class="line">[0.722s][info   ][gc,cpu         ] GC(24) User=0.02s Sys=0.00s Real=0.01s</span><br><span class="line">[0.734s][info   ][gc,start       ] GC(25) Pause Young (Allocation Failure)</span><br><span class="line">[0.739s][info   ][gc,heap        ] GC(25) PSYoungGen: 332941K(467968K)-&gt;90960K(490496K) Eden: 243712K(243712K)-&gt;0K(273920K) From: 89229K(224256K)-&gt;90960K(216576K)</span><br><span class="line">[0.739s][info   ][gc,heap        ] GC(25) ParOldGen: 736386K(1055744K)-&gt;802595K(1055744K)</span><br><span class="line">[0.739s][info   ][gc,metaspace   ] GC(25) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.739s][info   ][gc             ] GC(25) Pause Young (Allocation Failure) 1044M-&gt;872M(1510M) 5.029ms</span><br><span class="line">[0.739s][info   ][gc,cpu         ] GC(25) User=0.02s Sys=0.01s Real=0.00s</span><br><span class="line">[0.752s][info   ][gc,start       ] GC(26) Pause Young (Allocation Failure)</span><br><span class="line">[0.757s][info   ][gc,heap        ] GC(26) PSYoungGen: 364880K(490496K)-&gt;100075K(482304K) Eden: 273920K(273920K)-&gt;0K(273920K) From: 90960K(216576K)-&gt;100075K(208384K)</span><br><span class="line">[0.757s][info   ][gc,heap        ] GC(26) ParOldGen: 802595K(1055744K)-&gt;864645K(1055744K)</span><br><span class="line">[0.757s][info   ][gc,metaspace   ] GC(26) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.757s][info   ][gc             ] GC(26) Pause Young (Allocation Failure) 1140M-&gt;942M(1502M) 4.670ms</span><br><span class="line">[0.757s][info   ][gc,cpu         ] GC(26) User=0.02s Sys=0.00s Real=0.00s</span><br><span class="line">[0.771s][info   ][gc,start       ] GC(27) Pause Young (Allocation Failure)</span><br><span class="line">[0.777s][info   ][gc,heap        ] GC(27) PSYoungGen: 373995K(482304K)-&gt;92740K(506368K) Eden: 273920K(273920K)-&gt;0K(306688K) From: 100075K(208384K)-&gt;92740K(199680K)</span><br><span class="line">[0.777s][info   ][gc,heap        ] GC(27) ParOldGen: 864645K(1055744K)-&gt;931036K(1055744K)</span><br><span class="line">[0.777s][info   ][gc,metaspace   ] GC(27) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.777s][info   ][gc             ] GC(27) Pause Young (Allocation Failure) 1209M-&gt;999M(1525M) 5.561ms</span><br><span class="line">[0.777s][info   ][gc,cpu         ] GC(27) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.791s][info   ][gc,start       ] GC(28) Pause Young (Allocation Failure)</span><br><span class="line">[0.796s][info   ][gc,heap        ] GC(28) PSYoungGen: 399198K(506368K)-&gt;109395K(499200K) Eden: 306457K(306688K)-&gt;0K(306688K) From: 92740K(199680K)-&gt;109395K(192512K)</span><br><span class="line">[0.796s][info   ][gc,heap        ] GC(28) ParOldGen: 931036K(1055744K)-&gt;988954K(1055744K)</span><br><span class="line">[0.796s][info   ][gc,metaspace   ] GC(28) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.796s][info   ][gc             ] GC(28) Pause Young (Allocation Failure) 1299M-&gt;1072M(1518M) 5.066ms</span><br><span class="line">[0.796s][info   ][gc,cpu         ] GC(28) User=0.02s Sys=0.01s Real=0.00s</span><br><span class="line">[0.796s][info   ][gc,start       ] GC(29) Pause Full (Ergonomics)</span><br><span class="line">[0.796s][info   ][gc,phases,start] GC(29) Marking Phase</span><br><span class="line">[0.799s][info   ][gc,phases      ] GC(29) Marking Phase 2.435ms</span><br><span class="line">[0.799s][info   ][gc,phases,start] GC(29) Summary Phase</span><br><span class="line">[0.799s][info   ][gc,phases      ] GC(29) Summary Phase 0.026ms</span><br><span class="line">[0.799s][info   ][gc,phases,start] GC(29) Adjust Roots</span><br><span class="line">[0.799s][info   ][gc,phases      ] GC(29) Adjust Roots 0.177ms</span><br><span class="line">[0.799s][info   ][gc,phases,start] GC(29) Compaction Phase</span><br><span class="line">[0.806s][info   ][gc,phases      ] GC(29) Compaction Phase 6.812ms</span><br><span class="line">[0.806s][info   ][gc,phases,start] GC(29) Post Compact</span><br><span class="line">[0.807s][info   ][gc,phases      ] GC(29) Post Compact 1.197ms</span><br><span class="line">[0.807s][info   ][gc,heap        ] GC(29) PSYoungGen: 109395K(499200K)-&gt;0K(513536K) Eden: 0K(306688K)-&gt;0K(328192K) From: 109395K(192512K)-&gt;0K(185344K)</span><br><span class="line">[0.807s][info   ][gc,heap        ] GC(29) ParOldGen: 988954K(1055744K)-&gt;356192K(1094144K)</span><br><span class="line">[0.807s][info   ][gc,metaspace   ] GC(29) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.807s][info   ][gc             ] GC(29) Pause Full (Ergonomics) 1072M-&gt;347M(1570M) 10.854ms</span><br><span class="line">[0.807s][info   ][gc,cpu         ] GC(29) User=0.04s Sys=0.00s Real=0.01s</span><br><span class="line">[0.822s][info   ][gc,start       ] GC(30) Pause Young (Allocation Failure)</span><br><span class="line">[0.825s][info   ][gc,heap        ] GC(30) PSYoungGen: 327511K(513536K)-&gt;118904K(513536K) Eden: 327511K(328192K)-&gt;0K(328192K) From: 0K(185344K)-&gt;118904K(185344K)</span><br><span class="line">[0.825s][info   ][gc,heap        ] GC(30) ParOldGen: 356192K(1094144K)-&gt;356192K(1094144K)</span><br><span class="line">[0.825s][info   ][gc,metaspace   ] GC(30) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.825s][info   ][gc             ] GC(30) Pause Young (Allocation Failure) 667M-&gt;463M(1570M) 2.847ms</span><br><span class="line">[0.825s][info   ][gc,cpu         ] GC(30) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.841s][info   ][gc,start       ] GC(31) Pause Young (Allocation Failure)</span><br><span class="line">[0.845s][info   ][gc,heap        ] GC(31) PSYoungGen: 447096K(513536K)-&gt;109238K(522752K) Eden: 328192K(328192K)-&gt;0K(339968K) From: 118904K(185344K)-&gt;109238K(182784K)</span><br><span class="line">[0.845s][info   ][gc,heap        ] GC(31) ParOldGen: 356192K(1094144K)-&gt;436555K(1094144K)</span><br><span class="line">[0.846s][info   ][gc,metaspace   ] GC(31) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.846s][info   ][gc             ] GC(31) Pause Young (Allocation Failure) 784M-&gt;533M(1579M) 4.302ms</span><br><span class="line">[0.846s][info   ][gc,cpu         ] GC(31) User=0.02s Sys=0.00s Real=0.00s</span><br><span class="line">[0.862s][info   ][gc,start       ] GC(32) Pause Young (Allocation Failure)</span><br><span class="line">[0.867s][info   ][gc,heap        ] GC(32) PSYoungGen: 449206K(522752K)-&gt;122327K(516096K) Eden: 339968K(339968K)-&gt;0K(339968K) From: 109238K(182784K)-&gt;122327K(176128K)</span><br><span class="line">[0.867s][info   ][gc,heap        ] GC(32) ParOldGen: 436555K(1094144K)-&gt;507874K(1094144K)</span><br><span class="line">[0.867s][info   ][gc,metaspace   ] GC(32) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.867s][info   ][gc             ] GC(32) Pause Young (Allocation Failure) 865M-&gt;615M(1572M) 4.370ms</span><br><span class="line">[0.867s][info   ][gc,cpu         ] GC(32) User=0.02s Sys=0.01s Real=0.00s</span><br><span class="line">[0.884s][info   ][gc,start       ] GC(33) Pause Young (Allocation Failure)</span><br><span class="line">[0.887s][info   ][gc,heap        ] GC(33) PSYoungGen: 462295K(516096K)-&gt;114844K(528384K) Eden: 339968K(339968K)-&gt;0K(353280K) From: 122327K(176128K)-&gt;114844K(175104K)</span><br><span class="line">[0.888s][info   ][gc,heap        ] GC(33) ParOldGen: 507874K(1094144K)-&gt;589433K(1094144K)</span><br><span class="line">[0.888s][info   ][gc,metaspace   ] GC(33) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.888s][info   ][gc             ] GC(33) Pause Young (Allocation Failure) 947M-&gt;687M(1584M) 3.693ms</span><br><span class="line">[0.888s][info   ][gc,cpu         ] GC(33) User=0.03s Sys=0.00s Real=0.00s</span><br><span class="line">[0.905s][info   ][gc,start       ] GC(34) Pause Young (Allocation Failure)</span><br><span class="line">[0.909s][info   ][gc,heap        ] GC(34) PSYoungGen: 468124K(528384K)-&gt;116811K(523776K) Eden: 353280K(353280K)-&gt;0K(353280K) From: 114844K(175104K)-&gt;116811K(170496K)</span><br><span class="line">[0.909s][info   ][gc,heap        ] GC(34) ParOldGen: 589433K(1094144K)-&gt;668986K(1094144K)</span><br><span class="line">[0.909s][info   ][gc,metaspace   ] GC(34) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.909s][info   ][gc             ] GC(34) Pause Young (Allocation Failure) 1032M-&gt;767M(1580M) 3.912ms</span><br><span class="line">[0.909s][info   ][gc,cpu         ] GC(34) User=0.02s Sys=0.00s Real=0.00s</span><br><span class="line">[0.927s][info   ][gc,start       ] GC(35) Pause Young (Allocation Failure)</span><br><span class="line">[0.931s][info   ][gc,heap        ] GC(35) PSYoungGen: 470091K(523776K)-&gt;105742K(536576K) Eden: 353280K(353280K)-&gt;0K(369152K) From: 116811K(170496K)-&gt;105742K(167424K)</span><br><span class="line">[0.931s][info   ][gc,heap        ] GC(35) ParOldGen: 668986K(1094144K)-&gt;749228K(1094144K)</span><br><span class="line">[0.931s][info   ][gc,metaspace   ] GC(35) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.931s][info   ][gc             ] GC(35) Pause Young (Allocation Failure) 1112M-&gt;834M(1592M) 4.281ms</span><br><span class="line">[0.931s][info   ][gc,cpu         ] GC(35) User=0.02s Sys=0.00s Real=0.01s</span><br><span class="line">[0.949s][info   ][gc,start       ] GC(36) Pause Young (Allocation Failure)</span><br><span class="line">[0.953s][info   ][gc,heap        ] GC(36) PSYoungGen: 474894K(536576K)-&gt;111211K(531456K) Eden: 369152K(369152K)-&gt;0K(369152K) From: 105742K(167424K)-&gt;111211K(162304K)</span><br><span class="line">[0.953s][info   ][gc,heap        ] GC(36) ParOldGen: 749228K(1094144K)-&gt;816076K(1094144K)</span><br><span class="line">[0.953s][info   ][gc,metaspace   ] GC(36) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.953s][info   ][gc             ] GC(36) Pause Young (Allocation Failure) 1195M-&gt;905M(1587M) 4.001ms</span><br><span class="line">[0.953s][info   ][gc,cpu         ] GC(36) User=0.02s Sys=0.00s Real=0.01s</span><br><span class="line">[0.972s][info   ][gc,start       ] GC(37) Pause Young (Allocation Failure)</span><br><span class="line">[0.976s][info   ][gc,heap        ] GC(37) PSYoungGen: 480363K(531456K)-&gt;115482K(543744K) Eden: 369152K(369152K)-&gt;0K(386048K) From: 111211K(162304K)-&gt;115482K(157696K)</span><br><span class="line">[0.976s][info   ][gc,heap        ] GC(37) ParOldGen: 816076K(1094144K)-&gt;889667K(1094144K)</span><br><span class="line">[0.976s][info   ][gc,metaspace   ] GC(37) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.976s][info   ][gc             ] GC(37) Pause Young (Allocation Failure) 1266M-&gt;981M(1599M) 4.116ms</span><br><span class="line">[0.976s][info   ][gc,cpu         ] GC(37) User=0.02s Sys=0.00s Real=0.00s</span><br><span class="line">[0.997s][info   ][gc,start       ] GC(38) Pause Young (Allocation Failure)</span><br><span class="line">[1.002s][info   ][gc,heap        ] GC(38) PSYoungGen: 501526K(543744K)-&gt;129272K(541184K) Eden: 386044K(386048K)-&gt;0K(386048K) From: 115482K(157696K)-&gt;129272K(155136K)</span><br><span class="line">[1.002s][info   ][gc,heap        ] GC(38) ParOldGen: 889667K(1094144K)-&gt;958781K(1094144K)</span><br><span class="line">[1.002s][info   ][gc,metaspace   ] GC(38) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.002s][info   ][gc             ] GC(38) Pause Young (Allocation Failure) 1358M-&gt;1062M(1597M) 4.907ms</span><br><span class="line">[1.002s][info   ][gc,cpu         ] GC(38) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[1.020s][info   ][gc,start       ] GC(39) Pause Young (Allocation Failure)</span><br><span class="line">[1.027s][info   ][gc,heap        ] GC(39) PSYoungGen: 515320K(541184K)-&gt;131431K(536064K) Eden: 386048K(386048K)-&gt;0K(378368K) From: 129272K(155136K)-&gt;131431K(157696K)</span><br><span class="line">[1.027s][info   ][gc,heap        ] GC(39) ParOldGen: 958781K(1094144K)-&gt;1039401K(1094144K)</span><br><span class="line">[1.027s][info   ][gc,metaspace   ] GC(39) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.027s][info   ][gc             ] GC(39) Pause Young (Allocation Failure) 1439M-&gt;1143M(1592M) 6.384ms</span><br><span class="line">[1.027s][info   ][gc,cpu         ] GC(39) User=0.03s Sys=0.00s Real=0.01s</span><br><span class="line">[1.027s][info   ][gc,start       ] GC(40) Pause Full (Ergonomics)</span><br><span class="line">[1.027s][info   ][gc,phases,start] GC(40) Marking Phase</span><br><span class="line">[1.029s][info   ][gc,phases      ] GC(40) Marking Phase 2.024ms</span><br><span class="line">[1.029s][info   ][gc,phases,start] GC(40) Summary Phase</span><br><span class="line">[1.029s][info   ][gc,phases      ] GC(40) Summary Phase 0.020ms</span><br><span class="line">[1.029s][info   ][gc,phases,start] GC(40) Adjust Roots</span><br><span class="line">[1.029s][info   ][gc,phases      ] GC(40) Adjust Roots 0.393ms</span><br><span class="line">[1.029s][info   ][gc,phases,start] GC(40) Compaction Phase</span><br><span class="line">[1.036s][info   ][gc,phases      ] GC(40) Compaction Phase 6.420ms</span><br><span class="line">[1.036s][info   ][gc,phases,start] GC(40) Post Compact</span><br><span class="line">[1.036s][info   ][gc,phases      ] GC(40) Post Compact 0.476ms</span><br><span class="line">[1.036s][info   ][gc,heap        ] GC(40) PSYoungGen: 131431K(536064K)-&gt;0K(538624K) Eden: 0K(378368K)-&gt;0K(378368K) From: 131431K(157696K)-&gt;0K(160256K)</span><br><span class="line">[1.036s][info   ][gc,heap        ] GC(40) ParOldGen: 1039401K(1094144K)-&gt;358721K(1170944K)</span><br><span class="line">[1.036s][info   ][gc,metaspace   ] GC(40) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.036s][info   ][gc             ] GC(40) Pause Full (Ergonomics) 1143M-&gt;350M(1669M) 9.603ms</span><br><span class="line">[1.036s][info   ][gc,cpu         ] GC(40) User=0.03s Sys=0.01s Real=0.01s</span><br><span class="line">counter:55949</span><br><span class="line">[1.042s][info   ][gc,heap,exit   ] Heap</span><br><span class="line">[1.042s][info   ][gc,heap,exit   ]  PSYoungGen      total 538624K, used 15448K [0x00000007d5580000, 0x0000000800000000, 0x0000000800000000)</span><br><span class="line">[1.042s][info   ][gc,heap,exit   ]   eden space 378368K, 4% used [0x00000007d5580000,0x00000007d64962c0,0x00000007ec700000)</span><br><span class="line">[1.042s][info   ][gc,heap,exit   ]   from space 160256K, 0% used [0x00000007ec700000,0x00000007ec700000,0x00000007f6380000)</span><br><span class="line">[1.042s][info   ][gc,heap,exit   ]   to   space 160256K, 0% used [0x00000007f6380000,0x00000007f6380000,0x0000000800000000)</span><br><span class="line">[1.042s][info   ][gc,heap,exit   ]  ParOldGen       total 1170944K, used 358721K [0x0000000780000000, 0x00000007c7780000, 0x00000007d5580000)</span><br><span class="line">[1.042s][info   ][gc,heap,exit   ]   object space 1170944K, 30% used [0x0000000780000000,0x0000000795e50400,0x00000007c7780000)</span><br><span class="line">[1.042s][info   ][gc,heap,exit   ]  Metaspace       used 231K, committed 448K, reserved 1114112K</span><br><span class="line">[1.042s][info   ][gc,heap,exit   ]   class space    used 9K, committed 128K, reserved 1048576K</span><br></pre></td></tr></table></figure>


<h4 id="CMS-GC"><a href="#CMS-GC" class="headerlink" title="CMS GC"></a>CMS GC</h4><p>-XX: +UseConcMarkSweepGC</p>
<p>对年轻代使用STW的mark-copy算法，对老年代主要使用并发的mark-sweep算法。这个GC已经在java14版本被移除了。</p>
<p>设计目标:专为老年代设计，目标是最小化 GC 停顿时间。</p>
<ol>
<li>不对老年代进行整理，而是使用空闲列表来管理内存空间的回收</li>
<li>在mark-and-sweep的工作和业务线程并发执行。</li>
</ol>
<p>默认并发线程数等于CPU核心数的1&#x2F;4</p>
<p>6个阶段</p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>并发预清理</li>
<li>最终标记</li>
<li>并发清楚</li>
<li>并发重制</li>
</ol>
<p>MaxHeapSize是系统的1&#x2F;4内存<br>MaxNewSize是MaxHeapSize的1&#x2F;3<br>NewSize是系统的1&#x2F;64</p>
<p>优点：</p>
<ul>
<li>只有yongGC暂停业务。GC 停顿时间短，适合延迟敏感的应用。</li>
<li>并发回收利用多核资源减少 STW 时间。</li>
</ul>
<p>缺点：</p>
<ul>
<li>内存碎片化：CMS 不会整理内存，可能导致分配大对象失败（触发 Full GC）。</li>
<li>CPU 开销较高：并发阶段可能与用户线程争抢资源。</li>
<li>容易产生 “Concurrent Mode Failure”：若老年代空间不足，回退到 Serial GC。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>延迟敏感的应用（如 Web 服务、在线交易系统）。</li>
<li>多核环境下的中大型应用。</li>
</ul>
<h4 id="G1-GC"><a href="#G1-GC" class="headerlink" title="G1 GC"></a>G1 GC</h4><p>分区堆内存：将堆划分为若干独立的固定大小的区域（Region），每个 Region 可充当年轻代、老年代或其他用途。混合回收：通过优先回收包含最多垃圾的 Region（Garbage-First）。并行和并发回收：减少 STW 时间。内置碎片整理机制，避免了 CMS 的碎片化问题。一般一个Region是1M。一部分 Region 保留为 Humongous（H） 区，用于存储超过单个 Region 大小一半的巨型对象。</p>
<p>-XX: +UseG1GC -XX: MaxGCPauseMillis&#x3D;50</p>
<p>将STW的时间和分布变成可预期和可配置的，可设置某项特定的性能指标，为了达成可预期的指标，有独特的实现。增量方式，每次处理一部分，称为回收集合，每次处理所有的年轻代和部分老年代。能看到哪个块的垃圾多，优先回收他们</p>
<p>处理步骤</p>
<ol>
<li>年轻代模式转移暂停</li>
<li>并发标记</li>
<li>转移暂停：混合模式</li>
</ol>
<p>G1GC可能退化成串行GC</p>
<ol>
<li>并发模式失败：增加堆大小</li>
<li>晋升失败：</li>
<li>巨型对象分配失败：增加内存或增大Region大小</li>
</ol>
<p>优点：</p>
<ul>
<li>减少内存碎片化。</li>
<li>更好地控制 GC 停顿时间，可通过 -XX:MaxGCPauseMillis 调整。</li>
<li>自动调节年轻代和老年代的大小。</li>
</ul>
<p>缺点：</p>
<ul>
<li>实现复杂，配置选项多。</li>
<li>内存占用较高，CPU 开销大。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>需要低延迟的中大型应用。</li>
<li>堆内存较大的环境（如 &gt;4GB）。</li>
<li>替代 CMS 的推荐选择。</li>
</ul>
<p>Mixed GC</p>
<ul>
<li>老年代内存使用率达到一定阈值（默认 45%，可通过 -XX:InitiatingHeapOccupancyPercent 调整）。</li>
<li>同时回收年轻代和部分老年代。</li>
<li>执行<ul>
<li>标记 GC Roots 直接引用的对象。</li>
<li>并发扫描老年代，标记存活对象。</li>
<li>处理标记期间新产生的引用变化。</li>
</ul>
</li>
<li>根据垃圾优先（Garbage-First）的原则，优先选择包含最多垃圾的 Region。</li>
</ul>
<p>接下来试试G1 GC 128m内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+UseG1GC -Xms128m -Xmx128m -XX:+PrintGCDetails -Xlog:gc\*:file=gc.log:time,uptime,level,tags GCLogAnalysis</span><br></pre></td></tr></table></figure>

<p>同样GC了103次后发生了OOM，可以看到GC次数很多。时间也很长，花了0.136s</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0.094s][info   ][gc             ] GC(36) Pause Young (Normal) (G1 Preventive Collection) 115M-&gt;115M(128M) 0.243ms</span><br><span class="line">[0.094s][info   ][gc,cpu         ] GC(36) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.094s][info   ][gc,start       ] GC(37) Pause Young (Normal) (G1 Humongous Allocation)</span><br><span class="line">[0.094s][info   ][gc,task        ] GC(37) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.094s][info   ][gc,phases      ] GC(37)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.094s][info   ][gc,phases      ] GC(37)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.094s][info   ][gc,phases      ] GC(37)   Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.094s][info   ][gc,phases      ] GC(37)   Post Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.094s][info   ][gc,phases      ] GC(37)   Other: 0.0ms</span><br><span class="line">[0.094s][info   ][gc,heap        ] GC(37) Eden regions: 1-&gt;0(6)</span><br><span class="line">[0.094s][info   ][gc,heap        ] GC(37) Survivor regions: 1-&gt;0(0)</span><br><span class="line">[0.094s][info   ][gc,heap        ] GC(37) Old regions: 77-&gt;79</span><br><span class="line">[0.094s][info   ][gc,heap        ] GC(37) Archive regions: 2-&gt;2</span><br><span class="line">[0.094s][info   ][gc,heap        ] GC(37) Humongous regions: 47-&gt;47</span><br><span class="line">[0.094s][info   ][gc,metaspace   ] GC(37) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.094s][info   ][gc             ] GC(37) Pause Young (Normal) (G1 Humongous Allocation) (Evacuation Failure) 116M-&gt;117M(128M) 0.219ms</span><br><span class="line">[0.094s][info   ][gc,cpu         ] GC(37) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.094s][info   ][gc,ergo        ] Attempting full compaction</span><br><span class="line">[0.094s][info   ][gc,start       ] GC(38) Pause Full (G1 Compaction Pause)</span><br><span class="line">[0.094s][info   ][gc,task        ] GC(38) Using 3 workers of 8 for full compaction</span><br><span class="line">[0.094s][info   ][gc,phases,start] GC(38) Phase 1: Mark live objects</span><br><span class="line">[0.095s][info   ][gc,phases      ] GC(38) Phase 1: Mark live objects 0.306ms</span><br><span class="line">[0.095s][info   ][gc,phases,start] GC(38) Phase 2: Prepare compaction</span><br><span class="line">[0.095s][info   ][gc,phases      ] GC(38) Phase 2: Prepare compaction 0.075ms</span><br><span class="line">[0.095s][info   ][gc,phases,start] GC(38) Phase 3: Adjust pointers</span><br><span class="line">[0.095s][info   ][gc,phases      ] GC(38) Phase 3: Adjust pointers 0.192ms</span><br><span class="line">[0.095s][info   ][gc,phases,start] GC(38) Phase 4: Compact heap</span><br><span class="line">[0.096s][info   ][gc,phases      ] GC(38) Phase 4: Compact heap 0.523ms</span><br><span class="line">[0.096s][info   ][gc,heap        ] GC(38) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.096s][info   ][gc,heap        ] GC(38) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.096s][info   ][gc,heap        ] GC(38) Old regions: 79-&gt;75</span><br><span class="line">[0.096s][info   ][gc,heap        ] GC(38) Archive regions: 2-&gt;2</span><br><span class="line">[0.096s][info   ][gc,heap        ] GC(38) Humongous regions: 47-&gt;47</span><br><span class="line">[0.096s][info   ][gc,metaspace   ] GC(38) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.096s][info   ][gc             ] GC(38) Pause Full (G1 Compaction Pause) 117M-&gt;115M(128M) 1.529ms</span><br><span class="line">[0.096s][info   ][gc,cpu         ] GC(38) User=0.00s Sys=0.01s Real=0.00s</span><br><span class="line">[0.096s][info   ][gc,marking     ] GC(32) Concurrent Mark From Roots 3.526ms</span><br><span class="line">[0.096s][info   ][gc,marking     ] GC(32) Concurrent Mark Abort</span><br><span class="line">[0.096s][info   ][gc             ] GC(32) Concurrent Mark Cycle 3.602ms</span><br><span class="line">[0.096s][info   ][gc,start       ] GC(39) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.096s][info   ][gc,task        ] GC(39) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.096s][info   ][gc,phases      ] GC(39)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.096s][info   ][gc,phases      ] GC(39)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.096s][info   ][gc,phases      ] GC(39)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.096s][info   ][gc,phases      ] GC(39)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.096s][info   ][gc,phases      ] GC(39)   Other: 0.0ms</span><br><span class="line">[0.096s][info   ][gc,heap        ] GC(39) Eden regions: 1-&gt;0(5)</span><br><span class="line">[0.096s][info   ][gc,heap        ] GC(39) Survivor regions: 0-&gt;1(1)</span><br><span class="line">[0.096s][info   ][gc,heap        ] GC(39) Old regions: 75-&gt;75</span><br><span class="line">[0.096s][info   ][gc,heap        ] GC(39) Archive regions: 2-&gt;2</span><br><span class="line">[0.096s][info   ][gc,heap        ] GC(39) Humongous regions: 48-&gt;47</span><br><span class="line">[0.096s][info   ][gc,metaspace   ] GC(39) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.096s][info   ][gc             ] GC(39) Pause Young (Concurrent Start) (G1 Humongous Allocation) 117M-&gt;116M(128M) 0.322ms</span><br><span class="line">[0.096s][info   ][gc,cpu         ] GC(39) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.096s][info   ][gc             ] GC(40) Concurrent Mark Cycle</span><br><span class="line">[0.096s][info   ][gc,marking     ] GC(40) Concurrent Clear Claimed Marks</span><br><span class="line">[0.096s][info   ][gc,marking     ] GC(40) Concurrent Clear Claimed Marks 0.008ms</span><br><span class="line">[0.096s][info   ][gc,marking     ] GC(40) Concurrent Scan Root Regions</span><br><span class="line">[0.096s][info   ][gc,marking     ] GC(40) Concurrent Scan Root Regions 0.016ms</span><br><span class="line">[0.096s][info   ][gc,marking     ] GC(40) Concurrent Mark</span><br><span class="line">[0.096s][info   ][gc,marking     ] GC(40) Concurrent Mark From Roots</span><br><span class="line">[0.096s][info   ][gc,start       ] GC(41) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.096s][info   ][gc,task        ] GC(40) Using 2 workers of 2 for marking</span><br><span class="line">[0.096s][info   ][gc,task        ] GC(41) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.097s][info   ][gc,phases      ] GC(41)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.097s][info   ][gc,phases      ] GC(41)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.097s][info   ][gc,phases      ] GC(41)   Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.097s][info   ][gc,phases      ] GC(41)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.097s][info   ][gc,phases      ] GC(41)   Other: 0.0ms</span><br><span class="line">[0.097s][info   ][gc,heap        ] GC(41) Eden regions: 1-&gt;0(5)</span><br><span class="line">[0.097s][info   ][gc,heap        ] GC(41) Survivor regions: 1-&gt;1(1)</span><br><span class="line">[0.097s][info   ][gc,heap        ] GC(41) Old regions: 75-&gt;76</span><br><span class="line">[0.097s][info   ][gc,heap        ] GC(41) Archive regions: 2-&gt;2</span><br><span class="line">[0.097s][info   ][gc,heap        ] GC(41) Humongous regions: 48-&gt;48</span><br><span class="line">[0.097s][info   ][gc,metaspace   ] GC(41) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.097s][info   ][gc             ] GC(41) Pause Young (Normal) (G1 Preventive Collection) (Evacuation Failure) 118M-&gt;118M(128M) 0.308ms</span><br><span class="line">[0.097s][info   ][gc,cpu         ] GC(41) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.097s][info   ][gc,start       ] GC(42) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.097s][info   ][gc,task        ] GC(42) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.097s][info   ][gc,phases      ] GC(42)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.097s][info   ][gc,phases      ] GC(42)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.097s][info   ][gc,phases      ] GC(42)   Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.097s][info   ][gc,phases      ] GC(42)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.097s][info   ][gc,phases      ] GC(42)   Other: 0.0ms</span><br><span class="line">[0.097s][info   ][gc,heap        ] GC(42) Eden regions: 1-&gt;0(6)</span><br><span class="line">[0.097s][info   ][gc,heap        ] GC(42) Survivor regions: 1-&gt;0(0)</span><br><span class="line">[0.097s][info   ][gc,heap        ] GC(42) Old regions: 76-&gt;78</span><br><span class="line">[0.097s][info   ][gc,heap        ] GC(42) Archive regions: 2-&gt;2</span><br><span class="line">[0.097s][info   ][gc,heap        ] GC(42) Humongous regions: 48-&gt;48</span><br><span class="line">[0.097s][info   ][gc,metaspace   ] GC(42) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.097s][info   ][gc             ] GC(42) Pause Young (Normal) (G1 Evacuation Pause) (Evacuation Failure) 119M-&gt;119M(128M) 0.272ms</span><br><span class="line">[0.097s][info   ][gc,cpu         ] GC(42) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.097s][info   ][gc,ergo        ] Attempting full compaction</span><br><span class="line">[0.097s][info   ][gc,start       ] GC(43) Pause Full (G1 Compaction Pause)</span><br><span class="line">[0.097s][info   ][gc,task        ] GC(43) Using 3 workers of 8 for full compaction</span><br><span class="line">[0.097s][info   ][gc,phases,start] GC(43) Phase 1: Mark live objects</span><br><span class="line">[0.098s][info   ][gc,phases      ] GC(43) Phase 1: Mark live objects 0.289ms</span><br><span class="line">[0.098s][info   ][gc,phases,start] GC(43) Phase 2: Prepare compaction</span><br><span class="line">[0.098s][info   ][gc,phases      ] GC(43) Phase 2: Prepare compaction 0.080ms</span><br><span class="line">[0.098s][info   ][gc,phases,start] GC(43) Phase 3: Adjust pointers</span><br><span class="line">[0.098s][info   ][gc,phases      ] GC(43) Phase 3: Adjust pointers 0.208ms</span><br><span class="line">[0.098s][info   ][gc,phases,start] GC(43) Phase 4: Compact heap</span><br><span class="line">[0.098s][info   ][gc,phases      ] GC(43) Phase 4: Compact heap 0.200ms</span><br><span class="line">[0.098s][info   ][gc,heap        ] GC(43) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.098s][info   ][gc,heap        ] GC(43) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.098s][info   ][gc,heap        ] GC(43) Old regions: 78-&gt;76</span><br><span class="line">[0.098s][info   ][gc,heap        ] GC(43) Archive regions: 2-&gt;2</span><br><span class="line">[0.098s][info   ][gc,heap        ] GC(43) Humongous regions: 48-&gt;48</span><br><span class="line">[0.098s][info   ][gc,metaspace   ] GC(43) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.098s][info   ][gc             ] GC(43) Pause Full (G1 Compaction Pause) 119M-&gt;117M(128M) 1.131ms</span><br><span class="line">[0.098s][info   ][gc,cpu         ] GC(43) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.098s][info   ][gc,marking     ] GC(40) Concurrent Mark From Roots 2.025ms</span><br><span class="line">[0.098s][info   ][gc,marking     ] GC(40) Concurrent Mark Abort</span><br><span class="line">[0.098s][info   ][gc             ] GC(40) Concurrent Mark Cycle 2.138ms</span><br><span class="line">[0.098s][info   ][gc,start       ] GC(44) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.098s][info   ][gc,task        ] GC(44) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.099s][info   ][gc,phases      ] GC(44)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.099s][info   ][gc,phases      ] GC(44)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.099s][info   ][gc,phases      ] GC(44)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.099s][info   ][gc,phases      ] GC(44)   Post Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.099s][info   ][gc,phases      ] GC(44)   Other: 0.0ms</span><br><span class="line">[0.099s][info   ][gc,heap        ] GC(44) Eden regions: 1-&gt;0(5)</span><br><span class="line">[0.099s][info   ][gc,heap        ] GC(44) Survivor regions: 0-&gt;1(1)</span><br><span class="line">[0.099s][info   ][gc,heap        ] GC(44) Old regions: 76-&gt;76</span><br><span class="line">[0.099s][info   ][gc,heap        ] GC(44) Archive regions: 2-&gt;2</span><br><span class="line">[0.099s][info   ][gc,heap        ] GC(44) Humongous regions: 48-&gt;48</span><br><span class="line">[0.099s][info   ][gc,metaspace   ] GC(44) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.099s][info   ][gc             ] GC(44) Pause Young (Normal) (G1 Preventive Collection) 118M-&gt;118M(128M) 0.248ms</span><br><span class="line">[0.099s][info   ][gc,cpu         ] GC(44) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.099s][info   ][gc,start       ] GC(45) Pause Young (Concurrent Start) (G1 Evacuation Pause)</span><br><span class="line">[0.099s][info   ][gc,task        ] GC(45) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.099s][info   ][gc,phases      ] GC(45)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.099s][info   ][gc,phases      ] GC(45)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.099s][info   ][gc,phases      ] GC(45)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.099s][info   ][gc,phases      ] GC(45)   Post Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.099s][info   ][gc,phases      ] GC(45)   Other: 0.0ms</span><br><span class="line">[0.099s][info   ][gc,heap        ] GC(45) Eden regions: 1-&gt;0(6)</span><br><span class="line">[0.099s][info   ][gc,heap        ] GC(45) Survivor regions: 1-&gt;0(0)</span><br><span class="line">[0.099s][info   ][gc,heap        ] GC(45) Old regions: 76-&gt;78</span><br><span class="line">[0.099s][info   ][gc,heap        ] GC(45) Archive regions: 2-&gt;2</span><br><span class="line">[0.099s][info   ][gc,heap        ] GC(45) Humongous regions: 48-&gt;48</span><br><span class="line">[0.099s][info   ][gc,metaspace   ] GC(45) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.099s][info   ][gc             ] GC(45) Pause Young (Concurrent Start) (G1 Evacuation Pause) (Evacuation Failure) 118M-&gt;118M(128M) 0.237ms</span><br><span class="line">[0.099s][info   ][gc,cpu         ] GC(45) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.099s][info   ][gc,ergo        ] Attempting full compaction</span><br><span class="line">[0.099s][info   ][gc,start       ] GC(46) Pause Full (G1 Compaction Pause)</span><br><span class="line">[0.099s][info   ][gc,task        ] GC(46) Using 3 workers of 8 for full compaction</span><br><span class="line">[0.099s][info   ][gc             ] GC(47) Concurrent Mark Cycle</span><br><span class="line">[0.099s][info   ][gc,marking     ] GC(47) Concurrent Clear Claimed Marks</span><br><span class="line">[0.099s][info   ][gc,marking     ] GC(47) Concurrent Clear Claimed Marks 0.006ms</span><br><span class="line">[0.099s][info   ][gc,marking     ] GC(47) Concurrent Scan Root Regions</span><br><span class="line">[0.099s][info   ][gc,marking     ] GC(47) Concurrent Scan Root Regions 0.006ms</span><br><span class="line">[0.099s][info   ][gc,marking     ] GC(47) Concurrent Mark</span><br><span class="line">[0.099s][info   ][gc,marking     ] GC(47) Concurrent Mark From Roots</span><br><span class="line">[0.099s][info   ][gc,task        ] GC(47) Using 2 workers of 2 for marking</span><br><span class="line">[0.099s][info   ][gc,phases,start] GC(46) Phase 1: Mark live objects</span><br><span class="line">[0.099s][info   ][gc,phases      ] GC(46) Phase 1: Mark live objects 0.304ms</span><br><span class="line">[0.100s][info   ][gc,phases,start] GC(46) Phase 2: Prepare compaction</span><br><span class="line">[0.100s][info   ][gc,phases      ] GC(46) Phase 2: Prepare compaction 0.058ms</span><br><span class="line">[0.100s][info   ][gc,phases,start] GC(46) Phase 3: Adjust pointers</span><br><span class="line">[0.100s][info   ][gc,phases      ] GC(46) Phase 3: Adjust pointers 0.221ms</span><br><span class="line">[0.100s][info   ][gc,phases,start] GC(46) Phase 4: Compact heap</span><br><span class="line">[0.100s][info   ][gc,phases      ] GC(46) Phase 4: Compact heap 0.236ms</span><br><span class="line">[0.100s][info   ][gc,heap        ] GC(46) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.100s][info   ][gc,heap        ] GC(46) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.100s][info   ][gc,heap        ] GC(46) Old regions: 78-&gt;77</span><br><span class="line">[0.100s][info   ][gc,heap        ] GC(46) Archive regions: 2-&gt;2</span><br><span class="line">[0.100s][info   ][gc,heap        ] GC(46) Humongous regions: 48-&gt;47</span><br><span class="line">[0.100s][info   ][gc,metaspace   ] GC(46) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.100s][info   ][gc             ] GC(46) Pause Full (G1 Compaction Pause) 118M-&gt;117M(128M) 1.197ms</span><br><span class="line">[0.100s][info   ][gc,cpu         ] GC(46) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.100s][info   ][gc,marking     ] GC(47) Concurrent Mark From Roots 1.169ms</span><br><span class="line">[0.100s][info   ][gc,marking     ] GC(47) Concurrent Mark Abort</span><br><span class="line">[0.100s][info   ][gc             ] GC(47) Concurrent Mark Cycle 1.230ms</span><br><span class="line">[0.100s][info   ][gc,start       ] GC(48) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.100s][info   ][gc,task        ] GC(48) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.101s][info   ][gc,phases      ] GC(48)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.101s][info   ][gc,phases      ] GC(48)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.101s][info   ][gc,phases      ] GC(48)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.101s][info   ][gc,phases      ] GC(48)   Post Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.101s][info   ][gc,phases      ] GC(48)   Other: 0.0ms</span><br><span class="line">[0.101s][info   ][gc,heap        ] GC(48) Eden regions: 1-&gt;0(5)</span><br><span class="line">[0.101s][info   ][gc,heap        ] GC(48) Survivor regions: 0-&gt;1(1)</span><br><span class="line">[0.101s][info   ][gc,heap        ] GC(48) Old regions: 77-&gt;77</span><br><span class="line">[0.101s][info   ][gc,heap        ] GC(48) Archive regions: 2-&gt;2</span><br><span class="line">[0.101s][info   ][gc,heap        ] GC(48) Humongous regions: 47-&gt;47</span><br><span class="line">[0.101s][info   ][gc,metaspace   ] GC(48) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.101s][info   ][gc             ] GC(48) Pause Young (Normal) (G1 Preventive Collection) 118M-&gt;117M(128M) 0.264ms</span><br><span class="line">[0.101s][info   ][gc,cpu         ] GC(48) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.101s][info   ][gc,start       ] GC(49) Pause Young (Concurrent Start) (G1 Evacuation Pause)</span><br><span class="line">[0.101s][info   ][gc,task        ] GC(49) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.101s][info   ][gc,phases      ] GC(49)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.101s][info   ][gc,phases      ] GC(49)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.101s][info   ][gc,phases      ] GC(49)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.101s][info   ][gc,phases      ] GC(49)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.101s][info   ][gc,phases      ] GC(49)   Other: 0.0ms</span><br><span class="line">[0.101s][info   ][gc,heap        ] GC(49) Eden regions: 1-&gt;0(6)</span><br><span class="line">[0.101s][info   ][gc,heap        ] GC(49) Survivor regions: 1-&gt;0(0)</span><br><span class="line">[0.101s][info   ][gc,heap        ] GC(49) Old regions: 77-&gt;79</span><br><span class="line">[0.101s][info   ][gc,heap        ] GC(49) Archive regions: 2-&gt;2</span><br><span class="line">[0.101s][info   ][gc,heap        ] GC(49) Humongous regions: 47-&gt;47</span><br><span class="line">[0.101s][info   ][gc,metaspace   ] GC(49) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.101s][info   ][gc             ] GC(49) Pause Young (Concurrent Start) (G1 Evacuation Pause) (Evacuation Failure) 118M-&gt;118M(128M) 0.281ms</span><br><span class="line">[0.101s][info   ][gc,cpu         ] GC(49) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.101s][info   ][gc,ergo        ] Attempting full compaction</span><br><span class="line">[0.101s][info   ][gc,start       ] GC(50) Pause Full (G1 Compaction Pause)</span><br><span class="line">[0.101s][info   ][gc,task        ] GC(50) Using 3 workers of 8 for full compaction</span><br><span class="line">[0.101s][info   ][gc             ] GC(51) Concurrent Mark Cycle</span><br><span class="line">[0.101s][info   ][gc,marking     ] GC(51) Concurrent Clear Claimed Marks</span><br><span class="line">[0.101s][info   ][gc,marking     ] GC(51) Concurrent Clear Claimed Marks 0.006ms</span><br><span class="line">[0.101s][info   ][gc,marking     ] GC(51) Concurrent Scan Root Regions</span><br><span class="line">[0.101s][info   ][gc,marking     ] GC(51) Concurrent Scan Root Regions 0.006ms</span><br><span class="line">[0.101s][info   ][gc,marking     ] GC(51) Concurrent Mark</span><br><span class="line">[0.101s][info   ][gc,marking     ] GC(51) Concurrent Mark From Roots</span><br><span class="line">[0.101s][info   ][gc,task        ] GC(51) Using 2 workers of 2 for marking</span><br><span class="line">[0.101s][info   ][gc,phases,start] GC(50) Phase 1: Mark live objects</span><br><span class="line">[0.101s][info   ][gc,phases      ] GC(50) Phase 1: Mark live objects 0.309ms</span><br><span class="line">[0.102s][info   ][gc,phases,start] GC(50) Phase 2: Prepare compaction</span><br><span class="line">[0.102s][info   ][gc,phases      ] GC(50) Phase 2: Prepare compaction 0.070ms</span><br><span class="line">[0.102s][info   ][gc,phases,start] GC(50) Phase 3: Adjust pointers</span><br><span class="line">[0.102s][info   ][gc,phases      ] GC(50) Phase 3: Adjust pointers 0.203ms</span><br><span class="line">[0.102s][info   ][gc,phases,start] GC(50) Phase 4: Compact heap</span><br><span class="line">[0.102s][info   ][gc,phases      ] GC(50) Phase 4: Compact heap 0.416ms</span><br><span class="line">[0.102s][info   ][gc,heap        ] GC(50) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.102s][info   ][gc,heap        ] GC(50) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.102s][info   ][gc,heap        ] GC(50) Old regions: 79-&gt;76</span><br><span class="line">[0.102s][info   ][gc,heap        ] GC(50) Archive regions: 2-&gt;2</span><br><span class="line">[0.102s][info   ][gc,heap        ] GC(50) Humongous regions: 47-&gt;47</span><br><span class="line">[0.102s][info   ][gc,metaspace   ] GC(50) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.102s][info   ][gc             ] GC(50) Pause Full (G1 Compaction Pause) 118M-&gt;117M(128M) 1.406ms</span><br><span class="line">[0.102s][info   ][gc,cpu         ] GC(50) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.102s][info   ][gc,marking     ] GC(51) Concurrent Mark From Roots 1.345ms</span><br><span class="line">[0.102s][info   ][gc,marking     ] GC(51) Concurrent Mark Abort</span><br><span class="line">[0.103s][info   ][gc             ] GC(51) Concurrent Mark Cycle 1.406ms</span><br><span class="line">[0.103s][info   ][gc,start       ] GC(52) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.103s][info   ][gc,task        ] GC(52) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.103s][info   ][gc,phases      ] GC(52)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.103s][info   ][gc,phases      ] GC(52)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.103s][info   ][gc,phases      ] GC(52)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.103s][info   ][gc,phases      ] GC(52)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.103s][info   ][gc,phases      ] GC(52)   Other: 0.0ms</span><br><span class="line">[0.103s][info   ][gc,heap        ] GC(52) Eden regions: 1-&gt;0(6)</span><br><span class="line">[0.103s][info   ][gc,heap        ] GC(52) Survivor regions: 0-&gt;0(1)</span><br><span class="line">[0.103s][info   ][gc,heap        ] GC(52) Old regions: 76-&gt;76</span><br><span class="line">[0.103s][info   ][gc,heap        ] GC(52) Archive regions: 2-&gt;2</span><br><span class="line">[0.103s][info   ][gc,heap        ] GC(52) Humongous regions: 47-&gt;47</span><br><span class="line">[0.103s][info   ][gc,metaspace   ] GC(52) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.103s][info   ][gc             ] GC(52) Pause Young (Concurrent Start) (G1 Humongous Allocation) 118M-&gt;117M(128M) 0.342ms</span><br><span class="line">[0.103s][info   ][gc,cpu         ] GC(52) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.103s][info   ][gc             ] GC(53) Concurrent Mark Cycle</span><br><span class="line">[0.103s][info   ][gc,marking     ] GC(53) Concurrent Clear Claimed Marks</span><br><span class="line">[0.103s][info   ][gc,marking     ] GC(53) Concurrent Clear Claimed Marks 0.009ms</span><br><span class="line">[0.103s][info   ][gc,marking     ] GC(53) Concurrent Scan Root Regions</span><br><span class="line">[0.103s][info   ][gc,marking     ] GC(53) Concurrent Scan Root Regions 0.007ms</span><br><span class="line">[0.103s][info   ][gc,marking     ] GC(53) Concurrent Mark</span><br><span class="line">[0.103s][info   ][gc,marking     ] GC(53) Concurrent Mark From Roots</span><br><span class="line">[0.103s][info   ][gc,task        ] GC(53) Using 2 workers of 2 for marking</span><br><span class="line">[0.103s][info   ][gc,start       ] GC(54) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.103s][info   ][gc,task        ] GC(54) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.103s][info   ][gc,phases      ] GC(54)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.103s][info   ][gc,phases      ] GC(54)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.103s][info   ][gc,phases      ] GC(54)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.103s][info   ][gc,phases      ] GC(54)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.103s][info   ][gc,phases      ] GC(54)   Other: 0.0ms</span><br><span class="line">[0.103s][info   ][gc,heap        ] GC(54) Eden regions: 1-&gt;0(5)</span><br><span class="line">[0.103s][info   ][gc,heap        ] GC(54) Survivor regions: 0-&gt;1(1)</span><br><span class="line">[0.103s][info   ][gc,heap        ] GC(54) Old regions: 76-&gt;76</span><br><span class="line">[0.103s][info   ][gc,heap        ] GC(54) Archive regions: 2-&gt;2</span><br><span class="line">[0.103s][info   ][gc,heap        ] GC(54) Humongous regions: 48-&gt;47</span><br><span class="line">[0.103s][info   ][gc,metaspace   ] GC(54) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.103s][info   ][gc             ] GC(54) Pause Young (Normal) (G1 Preventive Collection) 119M-&gt;117M(128M) 0.299ms</span><br><span class="line">[0.103s][info   ][gc,cpu         ] GC(54) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">[0.104s][info   ][gc,start       ] GC(55) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.104s][info   ][gc,task        ] GC(55) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.104s][info   ][gc,phases      ] GC(55)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.104s][info   ][gc,phases      ] GC(55)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.104s][info   ][gc,phases      ] GC(55)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.104s][info   ][gc,phases      ] GC(55)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.104s][info   ][gc,phases      ] GC(55)   Other: 0.0ms</span><br><span class="line">[0.104s][info   ][gc,heap        ] GC(55) Eden regions: 1-&gt;0(5)</span><br><span class="line">[0.104s][info   ][gc,heap        ] GC(55) Survivor regions: 1-&gt;1(1)</span><br><span class="line">[0.104s][info   ][gc,heap        ] GC(55) Old regions: 76-&gt;76</span><br><span class="line">[0.104s][info   ][gc,heap        ] GC(55) Archive regions: 2-&gt;2</span><br><span class="line">[0.104s][info   ][gc,heap        ] GC(55) Humongous regions: 47-&gt;47</span><br><span class="line">[0.104s][info   ][gc,metaspace   ] GC(55) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.104s][info   ][gc             ] GC(55) Pause Young (Normal) (G1 Preventive Collection) 118M-&gt;117M(128M) 0.390ms</span><br><span class="line">[0.104s][info   ][gc,cpu         ] GC(55) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.104s][info   ][gc,start       ] GC(56) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.104s][info   ][gc,task        ] GC(56) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.104s][info   ][gc,phases      ] GC(56)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.104s][info   ][gc,phases      ] GC(56)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.104s][info   ][gc,phases      ] GC(56)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.104s][info   ][gc,phases      ] GC(56)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.104s][info   ][gc,phases      ] GC(56)   Other: 0.0ms</span><br><span class="line">[0.104s][info   ][gc,heap        ] GC(56) Eden regions: 0-&gt;0(5)</span><br><span class="line">[0.104s][info   ][gc,heap        ] GC(56) Survivor regions: 1-&gt;1(1)</span><br><span class="line">[0.104s][info   ][gc,heap        ] GC(56) Old regions: 76-&gt;76</span><br><span class="line">[0.104s][info   ][gc,heap        ] GC(56) Archive regions: 2-&gt;2</span><br><span class="line">[0.104s][info   ][gc,heap        ] GC(56) Humongous regions: 48-&gt;47</span><br><span class="line">[0.104s][info   ][gc,metaspace   ] GC(56) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.105s][info   ][gc             ] GC(56) Pause Young (Normal) (G1 Preventive Collection) 118M-&gt;117M(128M) 0.383ms</span><br><span class="line">[0.105s][info   ][gc,cpu         ] GC(56) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.105s][info   ][gc,start       ] GC(57) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.105s][info   ][gc,task        ] GC(57) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.105s][info   ][gc,phases      ] GC(57)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.105s][info   ][gc,phases      ] GC(57)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.105s][info   ][gc,phases      ] GC(57)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.105s][info   ][gc,phases      ] GC(57)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.105s][info   ][gc,phases      ] GC(57)   Other: 0.0ms</span><br><span class="line">[0.105s][info   ][gc,heap        ] GC(57) Eden regions: 1-&gt;0(5)</span><br><span class="line">[0.105s][info   ][gc,heap        ] GC(57) Survivor regions: 1-&gt;1(1)</span><br><span class="line">[0.105s][info   ][gc,heap        ] GC(57) Old regions: 76-&gt;76</span><br><span class="line">[0.105s][info   ][gc,heap        ] GC(57) Archive regions: 2-&gt;2</span><br><span class="line">[0.105s][info   ][gc,heap        ] GC(57) Humongous regions: 47-&gt;47</span><br><span class="line">[0.105s][info   ][gc,metaspace   ] GC(57) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.105s][info   ][gc             ] GC(57) Pause Young (Normal) (G1 Preventive Collection) 118M-&gt;118M(128M) 0.410ms</span><br><span class="line">[0.105s][info   ][gc,cpu         ] GC(57) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.105s][info   ][gc,start       ] GC(58) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.105s][info   ][gc,task        ] GC(58) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.106s][info   ][gc,phases      ] GC(58)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.106s][info   ][gc,phases      ] GC(58)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.106s][info   ][gc,phases      ] GC(58)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.106s][info   ][gc,phases      ] GC(58)   Post Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.106s][info   ][gc,phases      ] GC(58)   Other: 0.0ms</span><br><span class="line">[0.106s][info   ][gc,heap        ] GC(58) Eden regions: 1-&gt;0(5)</span><br><span class="line">[0.106s][info   ][gc,heap        ] GC(58) Survivor regions: 1-&gt;1(1)</span><br><span class="line">[0.106s][info   ][gc,heap        ] GC(58) Old regions: 76-&gt;77</span><br><span class="line">[0.106s][info   ][gc,heap        ] GC(58) Archive regions: 2-&gt;2</span><br><span class="line">[0.106s][info   ][gc,heap        ] GC(58) Humongous regions: 47-&gt;47</span><br><span class="line">[0.106s][info   ][gc,metaspace   ] GC(58) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.106s][info   ][gc             ] GC(58) Pause Young (Normal) (G1 Preventive Collection) (Evacuation Failure) 119M-&gt;118M(128M) 0.268ms</span><br><span class="line">[0.106s][info   ][gc,cpu         ] GC(58) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.106s][info   ][gc,start       ] GC(59) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.106s][info   ][gc,task        ] GC(59) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.106s][info   ][gc,phases      ] GC(59)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.106s][info   ][gc,phases      ] GC(59)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.106s][info   ][gc,phases      ] GC(59)   Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.106s][info   ][gc,phases      ] GC(59)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.106s][info   ][gc,phases      ] GC(59)   Other: 0.0ms</span><br><span class="line">[0.106s][info   ][gc,heap        ] GC(59) Eden regions: 1-&gt;0(6)</span><br><span class="line">[0.106s][info   ][gc,heap        ] GC(59) Survivor regions: 1-&gt;0(0)</span><br><span class="line">[0.106s][info   ][gc,heap        ] GC(59) Old regions: 77-&gt;79</span><br><span class="line">[0.106s][info   ][gc,heap        ] GC(59) Archive regions: 2-&gt;2</span><br><span class="line">[0.106s][info   ][gc,heap        ] GC(59) Humongous regions: 47-&gt;47</span><br><span class="line">[0.106s][info   ][gc,metaspace   ] GC(59) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.106s][info   ][gc             ] GC(59) Pause Young (Normal) (G1 Evacuation Pause) (Evacuation Failure) 119M-&gt;119M(128M) 0.234ms</span><br><span class="line">[0.106s][info   ][gc,cpu         ] GC(59) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.106s][info   ][gc,ergo        ] Attempting full compaction</span><br><span class="line">[0.106s][info   ][gc,start       ] GC(60) Pause Full (G1 Compaction Pause)</span><br><span class="line">[0.106s][info   ][gc,task        ] GC(60) Using 3 workers of 8 for full compaction</span><br><span class="line">[0.106s][info   ][gc,phases,start] GC(60) Phase 1: Mark live objects</span><br><span class="line">[0.106s][info   ][gc,phases      ] GC(60) Phase 1: Mark live objects 0.265ms</span><br><span class="line">[0.106s][info   ][gc,phases,start] GC(60) Phase 2: Prepare compaction</span><br><span class="line">[0.106s][info   ][gc,phases      ] GC(60) Phase 2: Prepare compaction 0.058ms</span><br><span class="line">[0.106s][info   ][gc,phases,start] GC(60) Phase 3: Adjust pointers</span><br><span class="line">[0.107s][info   ][gc,phases      ] GC(60) Phase 3: Adjust pointers 0.191ms</span><br><span class="line">[0.107s][info   ][gc,phases,start] GC(60) Phase 4: Compact heap</span><br><span class="line">[0.107s][info   ][gc,phases      ] GC(60) Phase 4: Compact heap 0.402ms</span><br><span class="line">[0.107s][info   ][gc,heap        ] GC(60) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.107s][info   ][gc,heap        ] GC(60) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.107s][info   ][gc,heap        ] GC(60) Old regions: 79-&gt;75</span><br><span class="line">[0.107s][info   ][gc,heap        ] GC(60) Archive regions: 2-&gt;2</span><br><span class="line">[0.107s][info   ][gc,heap        ] GC(60) Humongous regions: 47-&gt;46</span><br><span class="line">[0.107s][info   ][gc,metaspace   ] GC(60) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.107s][info   ][gc             ] GC(60) Pause Full (G1 Compaction Pause) 119M-&gt;117M(128M) 1.422ms</span><br><span class="line">[0.107s][info   ][gc,cpu         ] GC(60) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.107s][info   ][gc,marking     ] GC(53) Concurrent Mark From Roots 4.478ms</span><br><span class="line">[0.107s][info   ][gc,marking     ] GC(53) Concurrent Mark Abort</span><br><span class="line">[0.107s][info   ][gc             ] GC(53) Concurrent Mark Cycle 4.589ms</span><br><span class="line">[0.108s][info   ][gc,start       ] GC(61) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.108s][info   ][gc,task        ] GC(61) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.108s][info   ][gc,phases      ] GC(61)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.108s][info   ][gc,phases      ] GC(61)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.108s][info   ][gc,phases      ] GC(61)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.108s][info   ][gc,phases      ] GC(61)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.108s][info   ][gc,phases      ] GC(61)   Other: 0.0ms</span><br><span class="line">[0.108s][info   ][gc,heap        ] GC(61) Eden regions: 1-&gt;0(5)</span><br><span class="line">[0.108s][info   ][gc,heap        ] GC(61) Survivor regions: 0-&gt;1(1)</span><br><span class="line">[0.108s][info   ][gc,heap        ] GC(61) Old regions: 75-&gt;75</span><br><span class="line">[0.108s][info   ][gc,heap        ] GC(61) Archive regions: 2-&gt;2</span><br><span class="line">[0.108s][info   ][gc,heap        ] GC(61) Humongous regions: 49-&gt;48</span><br><span class="line">[0.108s][info   ][gc,metaspace   ] GC(61) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.108s][info   ][gc             ] GC(61) Pause Young (Normal) (G1 Preventive Collection) 121M-&gt;120M(128M) 0.379ms</span><br><span class="line">[0.108s][info   ][gc,cpu         ] GC(61) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.108s][info   ][gc,start       ] GC(62) Pause Young (Concurrent Start) (G1 Preventive Collection)</span><br><span class="line">[0.108s][info   ][gc,task        ] GC(62) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.108s][info   ][gc,phases      ] GC(62)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.108s][info   ][gc,phases      ] GC(62)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.108s][info   ][gc,phases      ] GC(62)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.108s][info   ][gc,phases      ] GC(62)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.108s][info   ][gc,phases      ] GC(62)   Other: 0.1ms</span><br><span class="line">[0.108s][info   ][gc,heap        ] GC(62) Eden regions: 1-&gt;0(6)</span><br><span class="line">[0.108s][info   ][gc,heap        ] GC(62) Survivor regions: 1-&gt;0(1)</span><br><span class="line">[0.108s][info   ][gc,heap        ] GC(62) Old regions: 75-&gt;76</span><br><span class="line">[0.108s][info   ][gc,heap        ] GC(62) Archive regions: 2-&gt;2</span><br><span class="line">[0.108s][info   ][gc,heap        ] GC(62) Humongous regions: 48-&gt;48</span><br><span class="line">[0.108s][info   ][gc,metaspace   ] GC(62) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.108s][info   ][gc             ] GC(62) Pause Young (Concurrent Start) (G1 Preventive Collection) 121M-&gt;120M(128M) 0.371ms</span><br><span class="line">[0.108s][info   ][gc,cpu         ] GC(62) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.108s][info   ][gc             ] GC(63) Concurrent Mark Cycle</span><br><span class="line">[0.109s][info   ][gc,marking     ] GC(63) Concurrent Clear Claimed Marks</span><br><span class="line">[0.109s][info   ][gc,marking     ] GC(63) Concurrent Clear Claimed Marks 0.009ms</span><br><span class="line">[0.109s][info   ][gc,marking     ] GC(63) Concurrent Scan Root Regions</span><br><span class="line">[0.109s][info   ][gc,start       ] GC(64) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.109s][info   ][gc,marking     ] GC(63) Concurrent Scan Root Regions 0.048ms</span><br><span class="line">[0.109s][info   ][gc,task        ] GC(64) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.109s][info   ][gc,marking     ] GC(63) Concurrent Mark</span><br><span class="line">[0.109s][info   ][gc,marking     ] GC(63) Concurrent Mark From Roots</span><br><span class="line">[0.109s][info   ][gc,task        ] GC(63) Using 2 workers of 2 for marking</span><br><span class="line">[0.109s][info   ][gc,phases      ] GC(64)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.109s][info   ][gc,phases      ] GC(64)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.109s][info   ][gc,phases      ] GC(64)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.109s][info   ][gc,phases      ] GC(64)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.109s][info   ][gc,phases      ] GC(64)   Other: 0.0ms</span><br><span class="line">[0.109s][info   ][gc,heap        ] GC(64) Eden regions: 1-&gt;0(5)</span><br><span class="line">[0.109s][info   ][gc,heap        ] GC(64) Survivor regions: 0-&gt;1(1)</span><br><span class="line">[0.109s][info   ][gc,heap        ] GC(64) Old regions: 76-&gt;76</span><br><span class="line">[0.109s][info   ][gc,heap        ] GC(64) Archive regions: 2-&gt;2</span><br><span class="line">[0.109s][info   ][gc,heap        ] GC(64) Humongous regions: 48-&gt;48</span><br><span class="line">[0.109s][info   ][gc,metaspace   ] GC(64) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.109s][info   ][gc             ] GC(64) Pause Young (Normal) (G1 Preventive Collection) 121M-&gt;120M(128M) 0.433ms</span><br><span class="line">[0.109s][info   ][gc,cpu         ] GC(64) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.109s][info   ][gc,start       ] GC(65) Pause Young (Normal) (G1 Humongous Allocation)</span><br><span class="line">[0.109s][info   ][gc,task        ] GC(65) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.109s][info   ][gc,phases      ] GC(65)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.109s][info   ][gc,phases      ] GC(65)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.109s][info   ][gc,phases      ] GC(65)   Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.109s][info   ][gc,phases      ] GC(65)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.109s][info   ][gc,phases      ] GC(65)   Other: 0.0ms</span><br><span class="line">[0.109s][info   ][gc,heap        ] GC(65) Eden regions: 1-&gt;0(6)</span><br><span class="line">[0.109s][info   ][gc,heap        ] GC(65) Survivor regions: 1-&gt;0(0)</span><br><span class="line">[0.109s][info   ][gc,heap        ] GC(65) Old regions: 76-&gt;78</span><br><span class="line">[0.109s][info   ][gc,heap        ] GC(65) Archive regions: 2-&gt;2</span><br><span class="line">[0.109s][info   ][gc,heap        ] GC(65) Humongous regions: 48-&gt;48</span><br><span class="line">[0.109s][info   ][gc,metaspace   ] GC(65) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.109s][info   ][gc             ] GC(65) Pause Young (Normal) (G1 Humongous Allocation) (Evacuation Failure) 121M-&gt;121M(128M) 0.306ms</span><br><span class="line">[0.109s][info   ][gc,cpu         ] GC(65) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.109s][info   ][gc,ergo        ] Attempting full compaction</span><br><span class="line">[0.109s][info   ][gc,start       ] GC(66) Pause Full (G1 Compaction Pause)</span><br><span class="line">[0.110s][info   ][gc,task        ] GC(66) Using 3 workers of 8 for full compaction</span><br><span class="line">[0.110s][info   ][gc,phases,start] GC(66) Phase 1: Mark live objects</span><br><span class="line">[0.110s][info   ][gc,phases      ] GC(66) Phase 1: Mark live objects 0.459ms</span><br><span class="line">[0.110s][info   ][gc,phases,start] GC(66) Phase 2: Prepare compaction</span><br><span class="line">[0.110s][info   ][gc,phases      ] GC(66) Phase 2: Prepare compaction 0.057ms</span><br><span class="line">[0.110s][info   ][gc,phases,start] GC(66) Phase 3: Adjust pointers</span><br><span class="line">[0.110s][info   ][gc,phases      ] GC(66) Phase 3: Adjust pointers 0.223ms</span><br><span class="line">[0.110s][info   ][gc,phases,start] GC(66) Phase 4: Compact heap</span><br><span class="line">[0.111s][info   ][gc,phases      ] GC(66) Phase 4: Compact heap 0.178ms</span><br><span class="line">[0.111s][info   ][gc,heap        ] GC(66) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.111s][info   ][gc,heap        ] GC(66) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.111s][info   ][gc,heap        ] GC(66) Old regions: 78-&gt;76</span><br><span class="line">[0.111s][info   ][gc,heap        ] GC(66) Archive regions: 2-&gt;2</span><br><span class="line">[0.111s][info   ][gc,heap        ] GC(66) Humongous regions: 48-&gt;48</span><br><span class="line">[0.111s][info   ][gc,metaspace   ] GC(66) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.111s][info   ][gc             ] GC(66) Pause Full (G1 Compaction Pause) 121M-&gt;120M(128M) 1.353ms</span><br><span class="line">[0.111s][info   ][gc,cpu         ] GC(66) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.111s][info   ][gc,marking     ] GC(63) Concurrent Mark From Roots 2.212ms</span><br><span class="line">[0.111s][info   ][gc,marking     ] GC(63) Concurrent Mark Abort</span><br><span class="line">[0.111s][info   ][gc             ] GC(63) Concurrent Mark Cycle 2.447ms</span><br><span class="line">[0.111s][info   ][gc,start       ] GC(67) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.111s][info   ][gc,task        ] GC(67) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.111s][info   ][gc,phases      ] GC(67)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.111s][info   ][gc,phases      ] GC(67)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.111s][info   ][gc,phases      ] GC(67)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.111s][info   ][gc,phases      ] GC(67)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.111s][info   ][gc,phases      ] GC(67)   Other: 0.0ms</span><br><span class="line">[0.111s][info   ][gc,heap        ] GC(67) Eden regions: 1-&gt;0(6)</span><br><span class="line">[0.111s][info   ][gc,heap        ] GC(67) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.111s][info   ][gc,heap        ] GC(67) Old regions: 76-&gt;77</span><br><span class="line">[0.111s][info   ][gc,heap        ] GC(67) Archive regions: 2-&gt;2</span><br><span class="line">[0.111s][info   ][gc,heap        ] GC(67) Humongous regions: 49-&gt;48</span><br><span class="line">[0.111s][info   ][gc,metaspace   ] GC(67) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.111s][info   ][gc             ] GC(67) Pause Young (Concurrent Start) (G1 Humongous Allocation) (Evacuation Failure) 122M-&gt;121M(128M) 0.341ms</span><br><span class="line">[0.111s][info   ][gc,cpu         ] GC(67) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.111s][info   ][gc             ] GC(68) Concurrent Mark Cycle</span><br><span class="line">[0.111s][info   ][gc,marking     ] GC(68) Concurrent Clear Claimed Marks</span><br><span class="line">[0.111s][info   ][gc,marking     ] GC(68) Concurrent Clear Claimed Marks 0.007ms</span><br><span class="line">[0.111s][info   ][gc,marking     ] GC(68) Concurrent Scan Root Regions</span><br><span class="line">[0.111s][info   ][gc,marking     ] GC(68) Concurrent Scan Root Regions 0.008ms</span><br><span class="line">[0.111s][info   ][gc,marking     ] GC(68) Concurrent Mark</span><br><span class="line">[0.111s][info   ][gc,marking     ] GC(68) Concurrent Mark From Roots</span><br><span class="line">[0.111s][info   ][gc,task        ] GC(68) Using 2 workers of 2 for marking</span><br><span class="line">[0.111s][info   ][gc,start       ] GC(69) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.111s][info   ][gc,task        ] GC(69) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.112s][info   ][gc,phases      ] GC(69)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.112s][info   ][gc,phases      ] GC(69)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.112s][info   ][gc,phases      ] GC(69)   Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.112s][info   ][gc,phases      ] GC(69)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.112s][info   ][gc,phases      ] GC(69)   Other: 0.0ms</span><br><span class="line">[0.112s][info   ][gc,heap        ] GC(69) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.112s][info   ][gc,heap        ] GC(69) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.112s][info   ][gc,heap        ] GC(69) Old regions: 77-&gt;77</span><br><span class="line">[0.112s][info   ][gc,heap        ] GC(69) Archive regions: 2-&gt;2</span><br><span class="line">[0.112s][info   ][gc,heap        ] GC(69) Humongous regions: 49-&gt;48</span><br><span class="line">[0.112s][info   ][gc,metaspace   ] GC(69) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.112s][info   ][gc             ] GC(69) Pause Young (Normal) (G1 Evacuation Pause) 122M-&gt;121M(128M) 0.268ms</span><br><span class="line">[0.112s][info   ][gc,cpu         ] GC(69) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.112s][info   ][gc,marking     ] GC(68) Concurrent Mark From Roots 0.698ms</span><br><span class="line">[0.112s][info   ][gc,marking     ] GC(68) Concurrent Preclean</span><br><span class="line">[0.112s][info   ][gc,start       ] GC(70) Pause Young (Normal) (G1 Humongous Allocation)</span><br><span class="line">[0.112s][info   ][gc,task        ] GC(70) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.112s][info   ][gc,phases      ] GC(70)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.112s][info   ][gc,phases      ] GC(70)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.112s][info   ][gc,phases      ] GC(70)   Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.112s][info   ][gc,phases      ] GC(70)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.112s][info   ][gc,phases      ] GC(70)   Other: 0.0ms</span><br><span class="line">[0.112s][info   ][gc,heap        ] GC(70) Eden regions: 1-&gt;0(6)</span><br><span class="line">[0.112s][info   ][gc,heap        ] GC(70) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.112s][info   ][gc,heap        ] GC(70) Old regions: 77-&gt;77</span><br><span class="line">[0.112s][info   ][gc,heap        ] GC(70) Archive regions: 2-&gt;2</span><br><span class="line">[0.112s][info   ][gc,heap        ] GC(70) Humongous regions: 48-&gt;48</span><br><span class="line">[0.112s][info   ][gc,metaspace   ] GC(70) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.113s][info   ][gc             ] GC(70) Pause Young (Normal) (G1 Humongous Allocation) 122M-&gt;121M(128M) 0.799ms</span><br><span class="line">[0.113s][info   ][gc,cpu         ] GC(70) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.113s][info   ][gc,marking     ] GC(68) Concurrent Preclean 0.870ms</span><br><span class="line">[0.113s][info   ][gc,start       ] GC(71) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.113s][info   ][gc,task        ] GC(71) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.113s][info   ][gc,phases      ] GC(71)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.113s][info   ][gc,phases      ] GC(71)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.113s][info   ][gc,phases      ] GC(71)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.113s][info   ][gc,phases      ] GC(71)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.113s][info   ][gc,phases      ] GC(71)   Other: 0.0ms</span><br><span class="line">[0.113s][info   ][gc,heap        ] GC(71) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.113s][info   ][gc,heap        ] GC(71) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.113s][info   ][gc,heap        ] GC(71) Old regions: 77-&gt;77</span><br><span class="line">[0.113s][info   ][gc,heap        ] GC(71) Archive regions: 2-&gt;2</span><br><span class="line">[0.113s][info   ][gc,heap        ] GC(71) Humongous regions: 49-&gt;49</span><br><span class="line">[0.113s][info   ][gc,metaspace   ] GC(71) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.114s][info   ][gc             ] GC(71) Pause Young (Normal) (G1 Evacuation Pause) 122M-&gt;122M(128M) 0.466ms</span><br><span class="line">[0.114s][info   ][gc,cpu         ] GC(71) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">[0.114s][info   ][gc,ergo        ] Attempting full compaction</span><br><span class="line">[0.114s][info   ][gc,start       ] GC(72) Pause Full (G1 Compaction Pause)</span><br><span class="line">[0.114s][info   ][gc,task        ] GC(72) Using 3 workers of 8 for full compaction</span><br><span class="line">[0.114s][info   ][gc,phases,start] GC(72) Phase 1: Mark live objects</span><br><span class="line">[0.114s][info   ][gc,phases      ] GC(72) Phase 1: Mark live objects 0.493ms</span><br><span class="line">[0.118s][info   ][gc,phases,start] GC(72) Phase 2: Prepare compaction</span><br><span class="line">[0.118s][info   ][gc,phases      ] GC(72) Phase 2: Prepare compaction 0.124ms</span><br><span class="line">[0.118s][info   ][gc,phases,start] GC(72) Phase 3: Adjust pointers</span><br><span class="line">[0.118s][info   ][gc,phases      ] GC(72) Phase 3: Adjust pointers 0.228ms</span><br><span class="line">[0.118s][info   ][gc,phases,start] GC(72) Phase 4: Compact heap</span><br><span class="line">[0.118s][info   ][gc,phases      ] GC(72) Phase 4: Compact heap 0.159ms</span><br><span class="line">[0.119s][info   ][gc,heap        ] GC(72) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.119s][info   ][gc,heap        ] GC(72) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.119s][info   ][gc,heap        ] GC(72) Old regions: 77-&gt;75</span><br><span class="line">[0.119s][info   ][gc,heap        ] GC(72) Archive regions: 2-&gt;2</span><br><span class="line">[0.119s][info   ][gc,heap        ] GC(72) Humongous regions: 49-&gt;49</span><br><span class="line">[0.119s][info   ][gc,metaspace   ] GC(72) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.119s][info   ][gc             ] GC(72) Pause Full (G1 Compaction Pause) 122M-&gt;122M(128M) 5.242ms</span><br><span class="line">[0.119s][info   ][gc,cpu         ] GC(72) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.119s][info   ][gc,marking     ] GC(68) Concurrent Mark Abort</span><br><span class="line">[0.119s][info   ][gc             ] GC(68) Concurrent Mark Cycle 7.491ms</span><br><span class="line">[0.119s][info   ][gc,start       ] GC(73) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.119s][info   ][gc,task        ] GC(73) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.119s][info   ][gc,phases      ] GC(73)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.119s][info   ][gc,phases      ] GC(73)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.119s][info   ][gc,phases      ] GC(73)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.119s][info   ][gc,phases      ] GC(73)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.119s][info   ][gc,phases      ] GC(73)   Other: 0.0ms</span><br><span class="line">[0.119s][info   ][gc,heap        ] GC(73) Eden regions: 1-&gt;0(5)</span><br><span class="line">[0.119s][info   ][gc,heap        ] GC(73) Survivor regions: 0-&gt;1(1)</span><br><span class="line">[0.119s][info   ][gc,heap        ] GC(73) Old regions: 75-&gt;75</span><br><span class="line">[0.119s][info   ][gc,heap        ] GC(73) Archive regions: 2-&gt;2</span><br><span class="line">[0.119s][info   ][gc,heap        ] GC(73) Humongous regions: 49-&gt;49</span><br><span class="line">[0.119s][info   ][gc,metaspace   ] GC(73) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.119s][info   ][gc             ] GC(73) Pause Young (Concurrent Start) (G1 Humongous Allocation) 122M-&gt;122M(128M) 0.367ms</span><br><span class="line">[0.119s][info   ][gc,cpu         ] GC(73) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.119s][info   ][gc             ] GC(74) Concurrent Mark Cycle</span><br><span class="line">[0.119s][info   ][gc,marking     ] GC(74) Concurrent Clear Claimed Marks</span><br><span class="line">[0.119s][info   ][gc,marking     ] GC(74) Concurrent Clear Claimed Marks 0.007ms</span><br><span class="line">[0.119s][info   ][gc,marking     ] GC(74) Concurrent Scan Root Regions</span><br><span class="line">[0.119s][info   ][gc,start       ] GC(75) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.119s][info   ][gc,task        ] GC(75) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.119s][info   ][gc,marking     ] GC(74) Concurrent Scan Root Regions 0.035ms</span><br><span class="line">[0.119s][info   ][gc,marking     ] GC(74) Concurrent Mark</span><br><span class="line">[0.119s][info   ][gc,marking     ] GC(74) Concurrent Mark From Roots</span><br><span class="line">[0.119s][info   ][gc,task        ] GC(74) Using 2 workers of 2 for marking</span><br><span class="line">[0.120s][info   ][gc,phases      ] GC(75)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.120s][info   ][gc,phases      ] GC(75)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.120s][info   ][gc,phases      ] GC(75)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.120s][info   ][gc,phases      ] GC(75)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.120s][info   ][gc,phases      ] GC(75)   Other: 0.0ms</span><br><span class="line">[0.120s][info   ][gc,heap        ] GC(75) Eden regions: 0-&gt;0(5)</span><br><span class="line">[0.120s][info   ][gc,heap        ] GC(75) Survivor regions: 1-&gt;1(1)</span><br><span class="line">[0.120s][info   ][gc,heap        ] GC(75) Old regions: 75-&gt;75</span><br><span class="line">[0.120s][info   ][gc,heap        ] GC(75) Archive regions: 2-&gt;2</span><br><span class="line">[0.120s][info   ][gc,heap        ] GC(75) Humongous regions: 49-&gt;49</span><br><span class="line">[0.120s][info   ][gc,metaspace   ] GC(75) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.120s][info   ][gc             ] GC(75) Pause Young (Normal) (G1 Preventive Collection) 122M-&gt;122M(128M) 0.262ms</span><br><span class="line">[0.120s][info   ][gc,cpu         ] GC(75) User=0.00s Sys=0.01s Real=0.00s</span><br><span class="line">[0.120s][info   ][gc,start       ] GC(76) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.120s][info   ][gc,task        ] GC(76) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.120s][info   ][gc,phases      ] GC(76)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.120s][info   ][gc,phases      ] GC(76)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.120s][info   ][gc,phases      ] GC(76)   Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.120s][info   ][gc,phases      ] GC(76)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.120s][info   ][gc,phases      ] GC(76)   Other: 0.0ms</span><br><span class="line">[0.120s][info   ][gc,heap        ] GC(76) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.120s][info   ][gc,heap        ] GC(76) Survivor regions: 1-&gt;0(0)</span><br><span class="line">[0.120s][info   ][gc,heap        ] GC(76) Old regions: 75-&gt;76</span><br><span class="line">[0.120s][info   ][gc,heap        ] GC(76) Archive regions: 2-&gt;2</span><br><span class="line">[0.120s][info   ][gc,heap        ] GC(76) Humongous regions: 50-&gt;49</span><br><span class="line">[0.120s][info   ][gc,metaspace   ] GC(76) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.120s][info   ][gc             ] GC(76) Pause Young (Normal) (G1 Evacuation Pause) (Evacuation Failure) 123M-&gt;122M(128M) 0.255ms</span><br><span class="line">[0.120s][info   ][gc,cpu         ] GC(76) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.120s][info   ][gc,start       ] GC(77) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.120s][info   ][gc,task        ] GC(77) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.120s][info   ][gc,phases      ] GC(77)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.120s][info   ][gc,phases      ] GC(77)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.120s][info   ][gc,phases      ] GC(77)   Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.120s][info   ][gc,phases      ] GC(77)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.120s][info   ][gc,phases      ] GC(77)   Other: 0.0ms</span><br><span class="line">[0.120s][info   ][gc,heap        ] GC(77) Eden regions: 1-&gt;0(6)</span><br><span class="line">[0.120s][info   ][gc,heap        ] GC(77) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.120s][info   ][gc,heap        ] GC(77) Old regions: 76-&gt;77</span><br><span class="line">[0.120s][info   ][gc,heap        ] GC(77) Archive regions: 2-&gt;2</span><br><span class="line">[0.120s][info   ][gc,heap        ] GC(77) Humongous regions: 49-&gt;49</span><br><span class="line">[0.120s][info   ][gc,metaspace   ] GC(77) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.120s][info   ][gc             ] GC(77) Pause Young (Normal) (G1 Evacuation Pause) (Evacuation Failure) 123M-&gt;123M(128M) 0.258ms</span><br><span class="line">[0.120s][info   ][gc,cpu         ] GC(77) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.120s][info   ][gc,ergo        ] Attempting full compaction</span><br><span class="line">[0.120s][info   ][gc,start       ] GC(78) Pause Full (G1 Compaction Pause)</span><br><span class="line">[0.120s][info   ][gc,task        ] GC(78) Using 3 workers of 8 for full compaction</span><br><span class="line">[0.120s][info   ][gc,phases,start] GC(78) Phase 1: Mark live objects</span><br><span class="line">[0.121s][info   ][gc,phases      ] GC(78) Phase 1: Mark live objects 0.272ms</span><br><span class="line">[0.121s][info   ][gc,phases,start] GC(78) Phase 2: Prepare compaction</span><br><span class="line">[0.121s][info   ][gc,phases      ] GC(78) Phase 2: Prepare compaction 0.079ms</span><br><span class="line">[0.121s][info   ][gc,phases,start] GC(78) Phase 3: Adjust pointers</span><br><span class="line">[0.121s][info   ][gc,phases      ] GC(78) Phase 3: Adjust pointers 0.203ms</span><br><span class="line">[0.121s][info   ][gc,phases,start] GC(78) Phase 4: Compact heap</span><br><span class="line">[0.121s][info   ][gc,phases      ] GC(78) Phase 4: Compact heap 0.067ms</span><br><span class="line">[0.121s][info   ][gc,heap        ] GC(78) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.121s][info   ][gc,heap        ] GC(78) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.121s][info   ][gc,heap        ] GC(78) Old regions: 77-&gt;76</span><br><span class="line">[0.121s][info   ][gc,heap        ] GC(78) Archive regions: 2-&gt;2</span><br><span class="line">[0.121s][info   ][gc,heap        ] GC(78) Humongous regions: 49-&gt;49</span><br><span class="line">[0.121s][info   ][gc,metaspace   ] GC(78) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.121s][info   ][gc             ] GC(78) Pause Full (G1 Compaction Pause) 123M-&gt;122M(128M) 0.956ms</span><br><span class="line">[0.121s][info   ][gc,cpu         ] GC(78) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.121s][info   ][gc,marking     ] GC(74) Concurrent Mark From Roots 1.986ms</span><br><span class="line">[0.121s][info   ][gc,marking     ] GC(74) Concurrent Mark Abort</span><br><span class="line">[0.121s][info   ][gc             ] GC(74) Concurrent Mark Cycle 2.084ms</span><br><span class="line">[0.121s][info   ][gc,start       ] GC(79) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.121s][info   ][gc,task        ] GC(79) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.122s][info   ][gc,phases      ] GC(79)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.122s][info   ][gc,phases      ] GC(79)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.122s][info   ][gc,phases      ] GC(79)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.122s][info   ][gc,phases      ] GC(79)   Post Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.122s][info   ][gc,phases      ] GC(79)   Other: 0.0ms</span><br><span class="line">[0.122s][info   ][gc,heap        ] GC(79) Eden regions: 1-&gt;0(6)</span><br><span class="line">[0.122s][info   ][gc,heap        ] GC(79) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.122s][info   ][gc,heap        ] GC(79) Old regions: 76-&gt;77</span><br><span class="line">[0.122s][info   ][gc,heap        ] GC(79) Archive regions: 2-&gt;2</span><br><span class="line">[0.122s][info   ][gc,heap        ] GC(79) Humongous regions: 49-&gt;49</span><br><span class="line">[0.122s][info   ][gc,metaspace   ] GC(79) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.122s][info   ][gc             ] GC(79) Pause Young (Concurrent Start) (G1 Humongous Allocation) (Evacuation Failure) 123M-&gt;123M(128M) 0.298ms</span><br><span class="line">[0.122s][info   ][gc,cpu         ] GC(79) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.122s][info   ][gc             ] GC(80) Concurrent Mark Cycle</span><br><span class="line">[0.122s][info   ][gc,ergo        ] Attempting full compaction clearing soft references</span><br><span class="line">[0.122s][info   ][gc,marking     ] GC(80) Concurrent Clear Claimed Marks</span><br><span class="line">[0.122s][info   ][gc,start       ] GC(81) Pause Full (G1 Compaction Pause)</span><br><span class="line">[0.122s][info   ][gc,marking     ] GC(80) Concurrent Clear Claimed Marks 0.035ms</span><br><span class="line">[0.122s][info   ][gc,task        ] GC(81) Using 3 workers of 8 for full compaction</span><br><span class="line">[0.122s][info   ][gc,marking     ] GC(80) Concurrent Scan Root Regions</span><br><span class="line">[0.122s][info   ][gc,marking     ] GC(80) Concurrent Scan Root Regions 0.049ms</span><br><span class="line">[0.122s][info   ][gc,marking     ] GC(80) Concurrent Mark</span><br><span class="line">[0.122s][info   ][gc,marking     ] GC(80) Concurrent Mark From Roots</span><br><span class="line">[0.122s][info   ][gc,task        ] GC(80) Using 2 workers of 2 for marking</span><br><span class="line">[0.122s][info   ][gc,phases,start] GC(81) Phase 1: Mark live objects</span><br><span class="line">[0.122s][info   ][gc,phases      ] GC(81) Phase 1: Mark live objects 0.317ms</span><br><span class="line">[0.122s][info   ][gc,phases,start] GC(81) Phase 2: Prepare compaction</span><br><span class="line">[0.122s][info   ][gc,phases      ] GC(81) Phase 2: Prepare compaction 0.062ms</span><br><span class="line">[0.122s][info   ][gc,phases,start] GC(81) Phase 3: Adjust pointers</span><br><span class="line">[0.123s][info   ][gc,phases      ] GC(81) Phase 3: Adjust pointers 0.217ms</span><br><span class="line">[0.123s][info   ][gc,phases,start] GC(81) Phase 4: Compact heap</span><br><span class="line">[0.123s][info   ][gc,phases      ] GC(81) Phase 4: Compact heap 0.056ms</span><br><span class="line">[0.123s][info   ][gc,heap        ] GC(81) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.123s][info   ][gc,heap        ] GC(81) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.123s][info   ][gc,heap        ] GC(81) Old regions: 77-&gt;76</span><br><span class="line">[0.123s][info   ][gc,heap        ] GC(81) Archive regions: 2-&gt;2</span><br><span class="line">[0.123s][info   ][gc,heap        ] GC(81) Humongous regions: 49-&gt;49</span><br><span class="line">[0.123s][info   ][gc,metaspace   ] GC(81) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.123s][info   ][gc             ] GC(81) Pause Full (G1 Compaction Pause) 123M-&gt;122M(128M) 1.094ms</span><br><span class="line">[0.123s][info   ][gc,cpu         ] GC(81) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.123s][info   ][gc,marking     ] GC(80) Concurrent Mark From Roots 1.100ms</span><br><span class="line">[0.123s][info   ][gc,marking     ] GC(80) Concurrent Mark Abort</span><br><span class="line">[0.123s][info   ][gc             ] GC(80) Concurrent Mark Cycle 1.273ms</span><br><span class="line">[0.123s][info   ][gc,start       ] GC(82) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.123s][info   ][gc,task        ] GC(82) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.123s][info   ][gc,phases      ] GC(82)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.123s][info   ][gc,phases      ] GC(82)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.123s][info   ][gc,phases      ] GC(82)   Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.123s][info   ][gc,phases      ] GC(82)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.123s][info   ][gc,phases      ] GC(82)   Other: 0.1ms</span><br><span class="line">[0.123s][info   ][gc,heap        ] GC(82) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.123s][info   ][gc,heap        ] GC(82) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.123s][info   ][gc,heap        ] GC(82) Old regions: 76-&gt;76</span><br><span class="line">[0.123s][info   ][gc,heap        ] GC(82) Archive regions: 2-&gt;2</span><br><span class="line">[0.123s][info   ][gc,heap        ] GC(82) Humongous regions: 50-&gt;49</span><br><span class="line">[0.123s][info   ][gc,metaspace   ] GC(82) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.123s][info   ][gc             ] GC(82) Pause Young (Normal) (G1 Evacuation Pause) 123M-&gt;122M(128M) 0.400ms</span><br><span class="line">[0.123s][info   ][gc,cpu         ] GC(82) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">[0.124s][info   ][gc,start       ] GC(83) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.124s][info   ][gc,task        ] GC(83) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.124s][info   ][gc,phases      ] GC(83)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.124s][info   ][gc,phases      ] GC(83)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.124s][info   ][gc,phases      ] GC(83)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.124s][info   ][gc,phases      ] GC(83)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.124s][info   ][gc,phases      ] GC(83)   Other: 0.0ms</span><br><span class="line">[0.124s][info   ][gc,heap        ] GC(83) Eden regions: 1-&gt;0(6)</span><br><span class="line">[0.124s][info   ][gc,heap        ] GC(83) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.124s][info   ][gc,heap        ] GC(83) Old regions: 76-&gt;76</span><br><span class="line">[0.124s][info   ][gc,heap        ] GC(83) Archive regions: 2-&gt;2</span><br><span class="line">[0.124s][info   ][gc,heap        ] GC(83) Humongous regions: 49-&gt;49</span><br><span class="line">[0.124s][info   ][gc,metaspace   ] GC(83) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.124s][info   ][gc             ] GC(83) Pause Young (Concurrent Start) (G1 Humongous Allocation) 122M-&gt;122M(128M) 0.410ms</span><br><span class="line">[0.124s][info   ][gc,cpu         ] GC(83) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.124s][info   ][gc             ] GC(84) Concurrent Mark Cycle</span><br><span class="line">[0.124s][info   ][gc,marking     ] GC(84) Concurrent Clear Claimed Marks</span><br><span class="line">[0.124s][info   ][gc,marking     ] GC(84) Concurrent Clear Claimed Marks 0.007ms</span><br><span class="line">[0.124s][info   ][gc,marking     ] GC(84) Concurrent Scan Root Regions</span><br><span class="line">[0.124s][info   ][gc,marking     ] GC(84) Concurrent Scan Root Regions 0.007ms</span><br><span class="line">[0.124s][info   ][gc,marking     ] GC(84) Concurrent Mark</span><br><span class="line">[0.124s][info   ][gc,marking     ] GC(84) Concurrent Mark From Roots</span><br><span class="line">[0.124s][info   ][gc,task        ] GC(84) Using 2 workers of 2 for marking</span><br><span class="line">[0.124s][info   ][gc,start       ] GC(85) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.124s][info   ][gc,task        ] GC(85) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.124s][info   ][gc,phases      ] GC(85)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.124s][info   ][gc,phases      ] GC(85)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.124s][info   ][gc,phases      ] GC(85)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.124s][info   ][gc,phases      ] GC(85)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.124s][info   ][gc,phases      ] GC(85)   Other: 0.0ms</span><br><span class="line">[0.124s][info   ][gc,heap        ] GC(85) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.124s][info   ][gc,heap        ] GC(85) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.124s][info   ][gc,heap        ] GC(85) Old regions: 76-&gt;76</span><br><span class="line">[0.124s][info   ][gc,heap        ] GC(85) Archive regions: 2-&gt;2</span><br><span class="line">[0.124s][info   ][gc,heap        ] GC(85) Humongous regions: 50-&gt;49</span><br><span class="line">[0.124s][info   ][gc,metaspace   ] GC(85) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.124s][info   ][gc             ] GC(85) Pause Young (Normal) (G1 Evacuation Pause) 123M-&gt;122M(128M) 0.290ms</span><br><span class="line">[0.124s][info   ][gc,cpu         ] GC(85) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.124s][info   ][gc,start       ] GC(86) Pause Young (Normal) (G1 Humongous Allocation)</span><br><span class="line">[0.125s][info   ][gc,task        ] GC(86) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.125s][info   ][gc,phases      ] GC(86)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.125s][info   ][gc,phases      ] GC(86)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.125s][info   ][gc,phases      ] GC(86)   Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.125s][info   ][gc,phases      ] GC(86)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.125s][info   ][gc,phases      ] GC(86)   Other: 0.0ms</span><br><span class="line">[0.125s][info   ][gc,heap        ] GC(86) Eden regions: 1-&gt;0(6)</span><br><span class="line">[0.125s][info   ][gc,heap        ] GC(86) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.125s][info   ][gc,heap        ] GC(86) Old regions: 76-&gt;76</span><br><span class="line">[0.125s][info   ][gc,heap        ] GC(86) Archive regions: 2-&gt;2</span><br><span class="line">[0.125s][info   ][gc,heap        ] GC(86) Humongous regions: 49-&gt;49</span><br><span class="line">[0.125s][info   ][gc,metaspace   ] GC(86) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.125s][info   ][gc             ] GC(86) Pause Young (Normal) (G1 Humongous Allocation) 122M-&gt;122M(128M) 0.351ms</span><br><span class="line">[0.125s][info   ][gc,cpu         ] GC(86) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.125s][info   ][gc,start       ] GC(87) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.125s][info   ][gc,task        ] GC(87) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.125s][info   ][gc,phases      ] GC(87)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.125s][info   ][gc,phases      ] GC(87)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.125s][info   ][gc,phases      ] GC(87)   Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.125s][info   ][gc,phases      ] GC(87)   Post Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.125s][info   ][gc,phases      ] GC(87)   Other: 0.0ms</span><br><span class="line">[0.125s][info   ][gc,heap        ] GC(87) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.125s][info   ][gc,heap        ] GC(87) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.125s][info   ][gc,heap        ] GC(87) Old regions: 76-&gt;76</span><br><span class="line">[0.125s][info   ][gc,heap        ] GC(87) Archive regions: 2-&gt;2</span><br><span class="line">[0.125s][info   ][gc,heap        ] GC(87) Humongous regions: 50-&gt;50</span><br><span class="line">[0.125s][info   ][gc,metaspace   ] GC(87) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.125s][info   ][gc             ] GC(87) Pause Young (Normal) (G1 Evacuation Pause) 123M-&gt;123M(128M) 0.208ms</span><br><span class="line">[0.125s][info   ][gc,cpu         ] GC(87) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.125s][info   ][gc,ergo        ] Attempting full compaction</span><br><span class="line">[0.125s][info   ][gc,start       ] GC(88) Pause Full (G1 Compaction Pause)</span><br><span class="line">[0.125s][info   ][gc,task        ] GC(88) Using 3 workers of 8 for full compaction</span><br><span class="line">[0.125s][info   ][gc,phases,start] GC(88) Phase 1: Mark live objects</span><br><span class="line">[0.126s][info   ][gc,phases      ] GC(88) Phase 1: Mark live objects 0.361ms</span><br><span class="line">[0.126s][info   ][gc,phases,start] GC(88) Phase 2: Prepare compaction</span><br><span class="line">[0.126s][info   ][gc,phases      ] GC(88) Phase 2: Prepare compaction 0.086ms</span><br><span class="line">[0.126s][info   ][gc,phases,start] GC(88) Phase 3: Adjust pointers</span><br><span class="line">[0.126s][info   ][gc,phases      ] GC(88) Phase 3: Adjust pointers 0.191ms</span><br><span class="line">[0.126s][info   ][gc,phases,start] GC(88) Phase 4: Compact heap</span><br><span class="line">[0.126s][info   ][gc,phases      ] GC(88) Phase 4: Compact heap 0.058ms</span><br><span class="line">[0.126s][info   ][gc,heap        ] GC(88) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.126s][info   ][gc,heap        ] GC(88) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.126s][info   ][gc,heap        ] GC(88) Old regions: 76-&gt;75</span><br><span class="line">[0.126s][info   ][gc,heap        ] GC(88) Archive regions: 2-&gt;2</span><br><span class="line">[0.126s][info   ][gc,heap        ] GC(88) Humongous regions: 50-&gt;50</span><br><span class="line">[0.126s][info   ][gc,metaspace   ] GC(88) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.126s][info   ][gc             ] GC(88) Pause Full (G1 Compaction Pause) 123M-&gt;123M(128M) 1.086ms</span><br><span class="line">[0.126s][info   ][gc,cpu         ] GC(88) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.126s][info   ][gc,marking     ] GC(84) Concurrent Mark From Roots 2.316ms</span><br><span class="line">[0.126s][info   ][gc,start       ] GC(89) Pause Young (Normal) (G1 Humongous Allocation)</span><br><span class="line">[0.126s][info   ][gc,task        ] GC(89) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.127s][info   ][gc,phases      ] GC(89)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.127s][info   ][gc,phases      ] GC(89)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.127s][info   ][gc,phases      ] GC(89)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.127s][info   ][gc,phases      ] GC(89)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.127s][info   ][gc,phases      ] GC(89)   Other: 0.0ms</span><br><span class="line">[0.127s][info   ][gc,heap        ] GC(89) Eden regions: 1-&gt;0(6)</span><br><span class="line">[0.127s][info   ][gc,heap        ] GC(89) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.127s][info   ][gc,heap        ] GC(89) Old regions: 75-&gt;76</span><br><span class="line">[0.127s][info   ][gc,heap        ] GC(89) Archive regions: 2-&gt;2</span><br><span class="line">[0.127s][info   ][gc,heap        ] GC(89) Humongous regions: 50-&gt;50</span><br><span class="line">[0.127s][info   ][gc,metaspace   ] GC(89) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.127s][info   ][gc             ] GC(89) Pause Young (Normal) (G1 Humongous Allocation) (Evacuation Failure) 123M-&gt;123M(128M) 0.300ms</span><br><span class="line">[0.127s][info   ][gc,cpu         ] GC(89) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.127s][info   ][gc,ergo        ] Attempting full compaction</span><br><span class="line">[0.127s][info   ][gc,start       ] GC(90) Pause Full (G1 Compaction Pause)</span><br><span class="line">[0.127s][info   ][gc,task        ] GC(90) Using 3 workers of 8 for full compaction</span><br><span class="line">[0.127s][info   ][gc,phases,start] GC(90) Phase 1: Mark live objects</span><br><span class="line">[0.127s][info   ][gc,phases      ] GC(90) Phase 1: Mark live objects 0.310ms</span><br><span class="line">[0.127s][info   ][gc,phases,start] GC(90) Phase 2: Prepare compaction</span><br><span class="line">[0.127s][info   ][gc,phases      ] GC(90) Phase 2: Prepare compaction 0.100ms</span><br><span class="line">[0.127s][info   ][gc,phases,start] GC(90) Phase 3: Adjust pointers</span><br><span class="line">[0.127s][info   ][gc,phases      ] GC(90) Phase 3: Adjust pointers 0.195ms</span><br><span class="line">[0.127s][info   ][gc,phases,start] GC(90) Phase 4: Compact heap</span><br><span class="line">[0.127s][info   ][gc,phases      ] GC(90) Phase 4: Compact heap 0.047ms</span><br><span class="line">[0.128s][info   ][gc,heap        ] GC(90) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.128s][info   ][gc,heap        ] GC(90) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.128s][info   ][gc,heap        ] GC(90) Old regions: 76-&gt;75</span><br><span class="line">[0.128s][info   ][gc,heap        ] GC(90) Archive regions: 2-&gt;2</span><br><span class="line">[0.128s][info   ][gc,heap        ] GC(90) Humongous regions: 50-&gt;50</span><br><span class="line">[0.128s][info   ][gc,metaspace   ] GC(90) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.128s][info   ][gc             ] GC(90) Pause Full (G1 Compaction Pause) 123M-&gt;123M(128M) 0.996ms</span><br><span class="line">[0.128s][info   ][gc,cpu         ] GC(90) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.128s][info   ][gc,marking     ] GC(84) Concurrent Mark Abort</span><br><span class="line">[0.128s][info   ][gc             ] GC(84) Concurrent Mark Cycle 3.785ms</span><br><span class="line">[0.128s][info   ][gc,start       ] GC(91) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.128s][info   ][gc,task        ] GC(91) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.128s][info   ][gc,phases      ] GC(91)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.128s][info   ][gc,phases      ] GC(91)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.128s][info   ][gc,phases      ] GC(91)   Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.128s][info   ][gc,phases      ] GC(91)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.128s][info   ][gc,phases      ] GC(91)   Other: 0.0ms</span><br><span class="line">[0.128s][info   ][gc,heap        ] GC(91) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.128s][info   ][gc,heap        ] GC(91) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.128s][info   ][gc,heap        ] GC(91) Old regions: 75-&gt;75</span><br><span class="line">[0.128s][info   ][gc,heap        ] GC(91) Archive regions: 2-&gt;2</span><br><span class="line">[0.128s][info   ][gc,heap        ] GC(91) Humongous regions: 51-&gt;50</span><br><span class="line">[0.128s][info   ][gc,metaspace   ] GC(91) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.128s][info   ][gc             ] GC(91) Pause Young (Normal) (G1 Evacuation Pause) 124M-&gt;123M(128M) 0.285ms</span><br><span class="line">[0.128s][info   ][gc,cpu         ] GC(91) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.128s][info   ][gc,start       ] GC(92) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.128s][info   ][gc,task        ] GC(92) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.128s][info   ][gc,phases      ] GC(92)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.128s][info   ][gc,phases      ] GC(92)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.128s][info   ][gc,phases      ] GC(92)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.128s][info   ][gc,phases      ] GC(92)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.128s][info   ][gc,phases      ] GC(92)   Other: 0.0ms</span><br><span class="line">[0.128s][info   ][gc,heap        ] GC(92) Eden regions: 1-&gt;0(6)</span><br><span class="line">[0.128s][info   ][gc,heap        ] GC(92) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.129s][info   ][gc,heap        ] GC(92) Old regions: 75-&gt;76</span><br><span class="line">[0.129s][info   ][gc,heap        ] GC(92) Archive regions: 2-&gt;2</span><br><span class="line">[0.129s][info   ][gc,heap        ] GC(92) Humongous regions: 50-&gt;50</span><br><span class="line">[0.129s][info   ][gc,metaspace   ] GC(92) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.129s][info   ][gc             ] GC(92) Pause Young (Concurrent Start) (G1 Humongous Allocation) (Evacuation Failure) 123M-&gt;123M(128M) 0.325ms</span><br><span class="line">[0.129s][info   ][gc,cpu         ] GC(92) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.129s][info   ][gc,ergo        ] Attempting full compaction clearing soft references</span><br><span class="line">[0.129s][info   ][gc,start       ] GC(93) Pause Full (G1 Compaction Pause)</span><br><span class="line">[0.129s][info   ][gc,task        ] GC(93) Using 3 workers of 8 for full compaction</span><br><span class="line">[0.129s][info   ][gc             ] GC(94) Concurrent Mark Cycle</span><br><span class="line">[0.129s][info   ][gc,marking     ] GC(94) Concurrent Clear Claimed Marks</span><br><span class="line">[0.129s][info   ][gc,marking     ] GC(94) Concurrent Clear Claimed Marks 0.007ms</span><br><span class="line">[0.129s][info   ][gc,marking     ] GC(94) Concurrent Scan Root Regions</span><br><span class="line">[0.129s][info   ][gc,marking     ] GC(94) Concurrent Scan Root Regions 0.006ms</span><br><span class="line">[0.129s][info   ][gc,marking     ] GC(94) Concurrent Mark</span><br><span class="line">[0.129s][info   ][gc,marking     ] GC(94) Concurrent Mark From Roots</span><br><span class="line">[0.129s][info   ][gc,task        ] GC(94) Using 2 workers of 2 for marking</span><br><span class="line">[0.129s][info   ][gc,phases,start] GC(93) Phase 1: Mark live objects</span><br><span class="line">[0.129s][info   ][gc,phases      ] GC(93) Phase 1: Mark live objects 0.309ms</span><br><span class="line">[0.129s][info   ][gc,phases,start] GC(93) Phase 2: Prepare compaction</span><br><span class="line">[0.129s][info   ][gc,phases      ] GC(93) Phase 2: Prepare compaction 0.065ms</span><br><span class="line">[0.129s][info   ][gc,phases,start] GC(93) Phase 3: Adjust pointers</span><br><span class="line">[0.129s][info   ][gc,phases      ] GC(93) Phase 3: Adjust pointers 0.217ms</span><br><span class="line">[0.129s][info   ][gc,phases,start] GC(93) Phase 4: Compact heap</span><br><span class="line">[0.129s][info   ][gc,phases      ] GC(93) Phase 4: Compact heap 0.032ms</span><br><span class="line">[0.130s][info   ][gc,heap        ] GC(93) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.130s][info   ][gc,heap        ] GC(93) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.130s][info   ][gc,heap        ] GC(93) Old regions: 76-&gt;75</span><br><span class="line">[0.130s][info   ][gc,heap        ] GC(93) Archive regions: 2-&gt;2</span><br><span class="line">[0.130s][info   ][gc,heap        ] GC(93) Humongous regions: 50-&gt;50</span><br><span class="line">[0.130s][info   ][gc,metaspace   ] GC(93) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.130s][info   ][gc             ] GC(93) Pause Full (G1 Compaction Pause) 123M-&gt;123M(128M) 1.008ms</span><br><span class="line">[0.130s][info   ][gc,cpu         ] GC(93) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.130s][info   ][gc,marking     ] GC(94) Concurrent Mark From Roots 0.978ms</span><br><span class="line">[0.130s][info   ][gc,start       ] GC(95) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.130s][info   ][gc,task        ] GC(95) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.130s][info   ][gc,phases      ] GC(95)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.130s][info   ][gc,phases      ] GC(95)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.130s][info   ][gc,phases      ] GC(95)   Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.130s][info   ][gc,phases      ] GC(95)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.130s][info   ][gc,phases      ] GC(95)   Other: 0.0ms</span><br><span class="line">[0.130s][info   ][gc,heap        ] GC(95) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.130s][info   ][gc,heap        ] GC(95) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.130s][info   ][gc,heap        ] GC(95) Old regions: 75-&gt;75</span><br><span class="line">[0.130s][info   ][gc,heap        ] GC(95) Archive regions: 2-&gt;2</span><br><span class="line">[0.130s][info   ][gc,heap        ] GC(95) Humongous regions: 51-&gt;51</span><br><span class="line">[0.130s][info   ][gc,metaspace   ] GC(95) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.130s][info   ][gc             ] GC(95) Pause Young (Normal) (G1 Evacuation Pause) 124M-&gt;124M(128M) 0.266ms</span><br><span class="line">[0.130s][info   ][gc,cpu         ] GC(95) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.130s][info   ][gc,ergo        ] Attempting full compaction</span><br><span class="line">[0.130s][info   ][gc,start       ] GC(96) Pause Full (G1 Compaction Pause)</span><br><span class="line">[0.130s][info   ][gc,task        ] GC(96) Using 3 workers of 8 for full compaction</span><br><span class="line">[0.130s][info   ][gc,phases,start] GC(96) Phase 1: Mark live objects</span><br><span class="line">[0.130s][info   ][gc,phases      ] GC(96) Phase 1: Mark live objects 0.279ms</span><br><span class="line">[0.130s][info   ][gc,phases,start] GC(96) Phase 2: Prepare compaction</span><br><span class="line">[0.130s][info   ][gc,phases      ] GC(96) Phase 2: Prepare compaction 0.081ms</span><br><span class="line">[0.130s][info   ][gc,phases,start] GC(96) Phase 3: Adjust pointers</span><br><span class="line">[0.131s][info   ][gc,phases      ] GC(96) Phase 3: Adjust pointers 0.189ms</span><br><span class="line">[0.131s][info   ][gc,phases,start] GC(96) Phase 4: Compact heap</span><br><span class="line">[0.131s][info   ][gc,phases      ] GC(96) Phase 4: Compact heap 0.061ms</span><br><span class="line">[0.131s][info   ][gc,heap        ] GC(96) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.131s][info   ][gc,heap        ] GC(96) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.131s][info   ][gc,heap        ] GC(96) Old regions: 75-&gt;75</span><br><span class="line">[0.131s][info   ][gc,heap        ] GC(96) Archive regions: 2-&gt;2</span><br><span class="line">[0.131s][info   ][gc,heap        ] GC(96) Humongous regions: 51-&gt;51</span><br><span class="line">[0.131s][info   ][gc,metaspace   ] GC(96) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.131s][info   ][gc             ] GC(96) Pause Full (G1 Compaction Pause) 124M-&gt;124M(128M) 0.982ms</span><br><span class="line">[0.131s][info   ][gc,cpu         ] GC(96) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.131s][info   ][gc,ergo        ] Attempting maximal full compaction clearing soft references</span><br><span class="line">[0.131s][info   ][gc,start       ] GC(97) Pause Full (G1 Compaction Pause)</span><br><span class="line">[0.131s][info   ][gc,task        ] GC(97) Using 3 workers of 8 for full compaction</span><br><span class="line">[0.131s][info   ][gc,phases,start] GC(97) Phase 1: Mark live objects</span><br><span class="line">[0.131s][info   ][gc,phases      ] GC(97) Phase 1: Mark live objects 0.362ms</span><br><span class="line">[0.131s][info   ][gc,phases,start] GC(97) Phase 2: Prepare compaction</span><br><span class="line">[0.131s][info   ][gc,phases      ] GC(97) Phase 2: Prepare compaction 0.080ms</span><br><span class="line">[0.132s][info   ][gc,phases,start] GC(97) Phase 3: Adjust pointers</span><br><span class="line">[0.132s][info   ][gc,phases      ] GC(97) Phase 3: Adjust pointers 0.247ms</span><br><span class="line">[0.132s][info   ][gc,phases,start] GC(97) Phase 4: Compact heap</span><br><span class="line">[0.132s][info   ][gc,phases      ] GC(97) Phase 4: Compact heap 0.171ms</span><br><span class="line">[0.132s][info   ][gc,heap        ] GC(97) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.132s][info   ][gc,heap        ] GC(97) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.132s][info   ][gc,heap        ] GC(97) Old regions: 75-&gt;75</span><br><span class="line">[0.132s][info   ][gc,heap        ] GC(97) Archive regions: 2-&gt;2</span><br><span class="line">[0.132s][info   ][gc,heap        ] GC(97) Humongous regions: 51-&gt;51</span><br><span class="line">[0.132s][info   ][gc,metaspace   ] GC(97) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.132s][info   ][gc             ] GC(97) Pause Full (G1 Compaction Pause) 124M-&gt;123M(128M) 1.263ms</span><br><span class="line">[0.132s][info   ][gc,cpu         ] GC(97) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.132s][info   ][gc,marking     ] GC(94) Concurrent Mark Abort</span><br><span class="line">[0.132s][info   ][gc             ] GC(94) Concurrent Mark Cycle 3.715ms</span><br><span class="line">[0.132s][info   ][gc,start       ] GC(98) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.132s][info   ][gc,task        ] GC(98) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.133s][info   ][gc,phases      ] GC(98)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.133s][info   ][gc,phases      ] GC(98)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.133s][info   ][gc,phases      ] GC(98)   Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.133s][info   ][gc,phases      ] GC(98)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.133s][info   ][gc,phases      ] GC(98)   Other: 0.0ms</span><br><span class="line">[0.133s][info   ][gc,heap        ] GC(98) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.133s][info   ][gc,heap        ] GC(98) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.133s][info   ][gc,heap        ] GC(98) Old regions: 75-&gt;75</span><br><span class="line">[0.133s][info   ][gc,heap        ] GC(98) Archive regions: 2-&gt;2</span><br><span class="line">[0.133s][info   ][gc,heap        ] GC(98) Humongous regions: 51-&gt;51</span><br><span class="line">[0.133s][info   ][gc,metaspace   ] GC(98) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.133s][info   ][gc             ] GC(98) Pause Young (Normal) (G1 Evacuation Pause) 123M-&gt;123M(128M) 0.305ms</span><br><span class="line">[0.133s][info   ][gc,cpu         ] GC(98) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.133s][info   ][gc,ergo        ] Attempting full compaction</span><br><span class="line">[0.133s][info   ][gc,start       ] GC(99) Pause Full (G1 Compaction Pause)</span><br><span class="line">[0.133s][info   ][gc,task        ] GC(99) Using 3 workers of 8 for full compaction</span><br><span class="line">[0.133s][info   ][gc,phases,start] GC(99) Phase 1: Mark live objects</span><br><span class="line">[0.133s][info   ][gc,phases      ] GC(99) Phase 1: Mark live objects 0.334ms</span><br><span class="line">[0.133s][info   ][gc,phases,start] GC(99) Phase 2: Prepare compaction</span><br><span class="line">[0.133s][info   ][gc,phases      ] GC(99) Phase 2: Prepare compaction 0.051ms</span><br><span class="line">[0.133s][info   ][gc,phases,start] GC(99) Phase 3: Adjust pointers</span><br><span class="line">[0.133s][info   ][gc,phases      ] GC(99) Phase 3: Adjust pointers 0.205ms</span><br><span class="line">[0.133s][info   ][gc,phases,start] GC(99) Phase 4: Compact heap</span><br><span class="line">[0.133s][info   ][gc,phases      ] GC(99) Phase 4: Compact heap 0.035ms</span><br><span class="line">[0.134s][info   ][gc,heap        ] GC(99) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.134s][info   ][gc,heap        ] GC(99) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.134s][info   ][gc,heap        ] GC(99) Old regions: 75-&gt;75</span><br><span class="line">[0.134s][info   ][gc,heap        ] GC(99) Archive regions: 2-&gt;2</span><br><span class="line">[0.134s][info   ][gc,heap        ] GC(99) Humongous regions: 51-&gt;51</span><br><span class="line">[0.134s][info   ][gc,metaspace   ] GC(99) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.134s][info   ][gc             ] GC(99) Pause Full (G1 Compaction Pause) 123M-&gt;123M(128M) 0.932ms</span><br><span class="line">[0.134s][info   ][gc,cpu         ] GC(99) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.134s][info   ][gc,ergo        ] Attempting maximal full compaction clearing soft references</span><br><span class="line">[0.134s][info   ][gc,start       ] GC(100) Pause Full (G1 Compaction Pause)</span><br><span class="line">[0.134s][info   ][gc,task        ] GC(100) Using 3 workers of 8 for full compaction</span><br><span class="line">[0.134s][info   ][gc,phases,start] GC(100) Phase 1: Mark live objects</span><br><span class="line">[0.134s][info   ][gc,phases      ] GC(100) Phase 1: Mark live objects 0.287ms</span><br><span class="line">[0.134s][info   ][gc,phases,start] GC(100) Phase 2: Prepare compaction</span><br><span class="line">[0.134s][info   ][gc,phases      ] GC(100) Phase 2: Prepare compaction 0.121ms</span><br><span class="line">[0.134s][info   ][gc,phases,start] GC(100) Phase 3: Adjust pointers</span><br><span class="line">[0.134s][info   ][gc,phases      ] GC(100) Phase 3: Adjust pointers 0.203ms</span><br><span class="line">[0.134s][info   ][gc,phases,start] GC(100) Phase 4: Compact heap</span><br><span class="line">[0.134s][info   ][gc,phases      ] GC(100) Phase 4: Compact heap 0.045ms</span><br><span class="line">[0.134s][info   ][gc,heap        ] GC(100) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.135s][info   ][gc,heap        ] GC(100) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.135s][info   ][gc,heap        ] GC(100) Old regions: 75-&gt;75</span><br><span class="line">[0.135s][info   ][gc,heap        ] GC(100) Archive regions: 2-&gt;2</span><br><span class="line">[0.135s][info   ][gc,heap        ] GC(100) Humongous regions: 51-&gt;51</span><br><span class="line">[0.135s][info   ][gc,metaspace   ] GC(100) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.135s][info   ][gc             ] GC(100) Pause Full (G1 Compaction Pause) 123M-&gt;123M(128M) 0.932ms</span><br><span class="line">[0.135s][info   ][gc,cpu         ] GC(100) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.135s][info   ][gc,start       ] GC(101) Pause Young (Concurrent Start) (G1 Evacuation Pause)</span><br><span class="line">[0.135s][info   ][gc,task        ] GC(101) Using 3 workers of 8 for evacuation</span><br><span class="line">[0.135s][info   ][gc,phases      ] GC(101)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.135s][info   ][gc,phases      ] GC(101)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.135s][info   ][gc,phases      ] GC(101)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.135s][info   ][gc,phases      ] GC(101)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.135s][info   ][gc,phases      ] GC(101)   Other: 0.0ms</span><br><span class="line">[0.135s][info   ][gc,heap        ] GC(101) Eden regions: 0-&gt;0(6)</span><br><span class="line">[0.135s][info   ][gc,heap        ] GC(101) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.135s][info   ][gc,heap        ] GC(101) Old regions: 75-&gt;75</span><br><span class="line">[0.135s][info   ][gc,heap        ] GC(101) Archive regions: 2-&gt;2</span><br><span class="line">[0.135s][info   ][gc,heap        ] GC(101) Humongous regions: 51-&gt;51</span><br><span class="line">[0.135s][info   ][gc,metaspace   ] GC(101) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 151K(256K)-&gt;151K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.135s][info   ][gc             ] GC(101) Pause Young (Concurrent Start) (G1 Evacuation Pause) 123M-&gt;123M(128M) 0.309ms</span><br><span class="line">[0.135s][info   ][gc,cpu         ] GC(101) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.135s][info   ][gc,ergo        ] Attempting full compaction</span><br><span class="line">[0.135s][info   ][gc             ] GC(102) Concurrent Mark Cycle</span><br><span class="line">[0.135s][info   ][gc,start       ] GC(103) Pause Full (G1 Compaction Pause)</span><br><span class="line">[0.135s][info   ][gc,marking     ] GC(102) Concurrent Clear Claimed Marks</span><br><span class="line">[0.135s][info   ][gc,task        ] GC(103) Using 3 workers of 8 for full compaction</span><br><span class="line">[0.135s][info   ][gc,marking     ] GC(102) Concurrent Clear Claimed Marks 0.039ms</span><br><span class="line">[0.135s][info   ][gc,marking     ] GC(102) Concurrent Scan Root Regions</span><br><span class="line">[0.135s][info   ][gc,marking     ] GC(102) Concurrent Scan Root Regions 0.015ms</span><br><span class="line">[0.135s][info   ][gc,marking     ] GC(102) Concurrent Mark</span><br><span class="line">[0.135s][info   ][gc,marking     ] GC(102) Concurrent Mark From Roots</span><br><span class="line">[0.135s][info   ][gc,task        ] GC(102) Using 2 workers of 2 for marking</span><br><span class="line">[0.135s][info   ][gc,phases,start] GC(103) Phase 1: Mark live objects</span><br><span class="line">[0.135s][info   ][gc,phases      ] GC(103) Phase 1: Mark live objects 0.282ms</span><br><span class="line">[0.135s][info   ][gc,phases,start] GC(103) Phase 2: Prepare compaction</span><br><span class="line">[0.136s][info   ][gc,phases      ] GC(103) Phase 2: Prepare compaction 0.083ms</span><br><span class="line">[0.136s][info   ][gc,phases,start] GC(103) Phase 3: Adjust pointers</span><br><span class="line">[0.136s][info   ][gc,phases      ] GC(103) Phase 3: Adjust pointers 0.190ms</span><br><span class="line">[0.136s][info   ][gc,phases,start] GC(103) Phase 4: Compact heap</span><br><span class="line">[0.136s][info   ][gc,phases      ] GC(103) Phase 4: Compact heap 0.067ms</span><br><span class="line">[0.136s][info   ][gc,heap        ] GC(103) Eden regions: 0-&gt;0(76)</span><br><span class="line">[0.136s][info   ][gc,heap        ] GC(103) Survivor regions: 0-&gt;0(0)</span><br><span class="line">[0.136s][info   ][gc,heap        ] GC(103) Old regions: 75-&gt;3</span><br><span class="line">[0.136s][info   ][gc,heap        ] GC(103) Archive regions: 2-&gt;2</span><br><span class="line">[0.136s][info   ][gc,heap        ] GC(103) Humongous regions: 51-&gt;0</span><br><span class="line">[0.136s][info   ][gc,metaspace   ] GC(103) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 151K(256K)-&gt;151K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.136s][info   ][gc             ] GC(103) Pause Full (G1 Compaction Pause) 123M-&gt;1M(128M) 1.088ms</span><br><span class="line">[0.136s][info   ][gc,cpu         ] GC(103) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.136s][info   ][gc,marking     ] GC(102) Concurrent Mark From Roots 0.993ms</span><br><span class="line">[0.136s][info   ][gc,marking     ] GC(102) Concurrent Mark Abort</span><br><span class="line">[0.136s][info   ][gc             ] GC(102) Concurrent Mark Cycle 1.161ms</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at GCLogAnalysis.generateGarbage(GCLogAnalysis.java:42)</span><br><span class="line">	at GCLogAnalysis.main(GCLogAnalysis.java:20)</span><br><span class="line">[0.137s][info   ][gc,heap,exit   ] Heap</span><br><span class="line">[0.137s][info   ][gc,heap,exit   ]  garbage-first heap   total 131072K, used 1717K [0x00000007f8000000, 0x0000000800000000)</span><br><span class="line">[0.137s][info   ][gc,heap,exit   ]   region size 1024K, 1 young (1024K), 0 survivors (0K)</span><br><span class="line">[0.137s][info   ][gc,heap,exit   ]  Metaspace       used 163K, committed 384K, reserved 1114112K</span><br><span class="line">[0.137s][info   ][gc,heap,exit   ]   class space    used 7K, committed 128K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>接下来试试512m内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+UseG1GC -Xms512m -Xmx512m -XX:+PrintGCDetails -Xlog:gc\*:file=gc.log:time,uptime,level,tags GCLogAnalysis</span><br></pre></td></tr></table></figure>

<p>可以看到GC了600多次，才生成了29000多个对象。效率很低。但是比并行GC还是要好一些。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0.944s][info   ][gc,task        ] GC(590) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.945s][info   ][gc,phases      ] GC(590)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.945s][info   ][gc,phases      ] GC(590)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.945s][info   ][gc,phases      ] GC(590)   Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.945s][info   ][gc,phases      ] GC(590)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.945s][info   ][gc,phases      ] GC(590)   Other: 0.0ms</span><br><span class="line">[0.945s][info   ][gc,heap        ] GC(590) Eden regions: 24-&gt;0(21)</span><br><span class="line">[0.945s][info   ][gc,heap        ] GC(590) Survivor regions: 1-&gt;4(4)</span><br><span class="line">[0.945s][info   ][gc,heap        ] GC(590) Old regions: 275-&gt;280</span><br><span class="line">[0.945s][info   ][gc,heap        ] GC(590) Archive regions: 2-&gt;2</span><br><span class="line">[0.945s][info   ][gc,heap        ] GC(590) Humongous regions: 178-&gt;170</span><br><span class="line">[0.945s][info   ][gc,metaspace   ] GC(590) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.945s][info   ][gc             ] GC(590) Pause Young (Prepare Mixed) (G1 Evacuation Pause) 453M-&gt;429M(512M) 0.711ms</span><br><span class="line">[0.945s][info   ][gc,cpu         ] GC(590) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.947s][info   ][gc,start       ] GC(591) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.947s][info   ][gc,task        ] GC(591) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.947s][info   ][gc,phases      ] GC(591)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.947s][info   ][gc,phases      ] GC(591)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.947s][info   ][gc,phases      ] GC(591)   Evacuate Collection Set: 0.5ms</span><br><span class="line">[0.947s][info   ][gc,phases      ] GC(591)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.947s][info   ][gc,phases      ] GC(591)   Other: 0.0ms</span><br><span class="line">[0.947s][info   ][gc,heap        ] GC(591) Eden regions: 21-&gt;0(21)</span><br><span class="line">[0.947s][info   ][gc,heap        ] GC(591) Survivor regions: 4-&gt;4(4)</span><br><span class="line">[0.947s][info   ][gc,heap        ] GC(591) Old regions: 280-&gt;281</span><br><span class="line">[0.947s][info   ][gc,heap        ] GC(591) Archive regions: 2-&gt;2</span><br><span class="line">[0.947s][info   ][gc,heap        ] GC(591) Humongous regions: 178-&gt;167</span><br><span class="line">[0.947s][info   ][gc,metaspace   ] GC(591) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.947s][info   ][gc             ] GC(591) Pause Young (Mixed) (G1 Evacuation Pause) 458M-&gt;430M(512M) 0.889ms</span><br><span class="line">[0.947s][info   ][gc,cpu         ] GC(591) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.948s][info   ][gc,start       ] GC(592) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.948s][info   ][gc,task        ] GC(592) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.948s][info   ][gc,phases      ] GC(592)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.948s][info   ][gc,phases      ] GC(592)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.948s][info   ][gc,phases      ] GC(592)   Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.948s][info   ][gc,phases      ] GC(592)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.948s][info   ][gc,phases      ] GC(592)   Other: 0.0ms</span><br><span class="line">[0.948s][info   ][gc,heap        ] GC(592) Eden regions: 4-&gt;0(23)</span><br><span class="line">[0.948s][info   ][gc,heap        ] GC(592) Survivor regions: 4-&gt;2(4)</span><br><span class="line">[0.948s][info   ][gc,heap        ] GC(592) Old regions: 281-&gt;284</span><br><span class="line">[0.948s][info   ][gc,heap        ] GC(592) Archive regions: 2-&gt;2</span><br><span class="line">[0.948s][info   ][gc,heap        ] GC(592) Humongous regions: 167-&gt;167</span><br><span class="line">[0.949s][info   ][gc,metaspace   ] GC(592) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.949s][info   ][gc             ] GC(592) Pause Young (Concurrent Start) (G1 Humongous Allocation) 433M-&gt;431M(512M) 0.703ms</span><br><span class="line">[0.949s][info   ][gc,cpu         ] GC(592) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.949s][info   ][gc             ] GC(593) Concurrent Mark Cycle</span><br><span class="line">[0.949s][info   ][gc,marking     ] GC(593) Concurrent Clear Claimed Marks</span><br><span class="line">[0.949s][info   ][gc,marking     ] GC(593) Concurrent Clear Claimed Marks 0.009ms</span><br><span class="line">[0.949s][info   ][gc,marking     ] GC(593) Concurrent Scan Root Regions</span><br><span class="line">[0.949s][info   ][gc,marking     ] GC(593) Concurrent Scan Root Regions 0.032ms</span><br><span class="line">[0.949s][info   ][gc,marking     ] GC(593) Concurrent Mark</span><br><span class="line">[0.949s][info   ][gc,marking     ] GC(593) Concurrent Mark From Roots</span><br><span class="line">[0.949s][info   ][gc,task        ] GC(593) Using 2 workers of 2 for marking</span><br><span class="line">[0.950s][info   ][gc,marking     ] GC(593) Concurrent Mark From Roots 0.869ms</span><br><span class="line">[0.950s][info   ][gc,marking     ] GC(593) Concurrent Preclean</span><br><span class="line">[0.950s][info   ][gc,marking     ] GC(593) Concurrent Preclean 0.008ms</span><br><span class="line">[0.950s][info   ][gc,start       ] GC(593) Pause Remark</span><br><span class="line">[0.950s][info   ][gc             ] GC(593) Pause Remark 458M-&gt;458M(512M) 0.282ms</span><br><span class="line">[0.950s][info   ][gc,cpu         ] GC(593) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.950s][info   ][gc,marking     ] GC(593) Concurrent Mark 1.361ms</span><br><span class="line">[0.950s][info   ][gc,marking     ] GC(593) Concurrent Rebuild Remembered Sets</span><br><span class="line">[0.950s][info   ][gc,marking     ] GC(593) Concurrent Rebuild Remembered Sets 0.487ms</span><br><span class="line">[0.951s][info   ][gc,start       ] GC(593) Pause Cleanup</span><br><span class="line">[0.951s][info   ][gc             ] GC(593) Pause Cleanup 467M-&gt;467M(512M) 0.215ms</span><br><span class="line">[0.951s][info   ][gc,cpu         ] GC(593) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.951s][info   ][gc,marking     ] GC(593) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.951s][info   ][gc,marking     ] GC(593) Concurrent Cleanup for Next Mark 0.277ms</span><br><span class="line">[0.951s][info   ][gc             ] GC(593) Concurrent Mark Cycle 2.642ms</span><br><span class="line">[0.951s][info   ][gc,start       ] GC(594) Pause Young (Prepare Mixed) (G1 Preventive Collection)</span><br><span class="line">[0.951s][info   ][gc,task        ] GC(594) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.952s][info   ][gc,phases      ] GC(594)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.952s][info   ][gc,phases      ] GC(594)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.952s][info   ][gc,phases      ] GC(594)   Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.952s][info   ][gc,phases      ] GC(594)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.952s][info   ][gc,phases      ] GC(594)   Other: 0.0ms</span><br><span class="line">[0.952s][info   ][gc,heap        ] GC(594) Eden regions: 22-&gt;0(21)</span><br><span class="line">[0.952s][info   ][gc,heap        ] GC(594) Survivor regions: 2-&gt;4(4)</span><br><span class="line">[0.952s][info   ][gc,heap        ] GC(594) Old regions: 284-&gt;290</span><br><span class="line">[0.952s][info   ][gc,heap        ] GC(594) Archive regions: 2-&gt;2</span><br><span class="line">[0.952s][info   ][gc,heap        ] GC(594) Humongous regions: 189-&gt;174</span><br><span class="line">[0.952s][info   ][gc,metaspace   ] GC(594) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.952s][info   ][gc             ] GC(594) Pause Young (Prepare Mixed) (G1 Preventive Collection) 475M-&gt;446M(512M) 0.786ms</span><br><span class="line">[0.952s][info   ][gc,cpu         ] GC(594) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.954s][info   ][gc,start       ] GC(595) Pause Young (Mixed) (G1 Preventive Collection)</span><br><span class="line">[0.954s][info   ][gc,task        ] GC(595) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.955s][info   ][gc,phases      ] GC(595)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.955s][info   ][gc,phases      ] GC(595)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.955s][info   ][gc,phases      ] GC(595)   Evacuate Collection Set: 0.5ms</span><br><span class="line">[0.955s][info   ][gc,phases      ] GC(595)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.955s][info   ][gc,phases      ] GC(595)   Other: 0.0ms</span><br><span class="line">[0.955s][info   ][gc,heap        ] GC(595) Eden regions: 19-&gt;0(21)</span><br><span class="line">[0.955s][info   ][gc,heap        ] GC(595) Survivor regions: 4-&gt;4(4)</span><br><span class="line">[0.955s][info   ][gc,heap        ] GC(595) Old regions: 290-&gt;314</span><br><span class="line">[0.955s][info   ][gc,heap        ] GC(595) Archive regions: 2-&gt;2</span><br><span class="line">[0.955s][info   ][gc,heap        ] GC(595) Humongous regions: 181-&gt;173</span><br><span class="line">[0.955s][info   ][gc,metaspace   ] GC(595) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.955s][info   ][gc             ] GC(595) Pause Young (Mixed) (G1 Preventive Collection) (Evacuation Failure) 471M-&gt;469M(512M) 1.102ms</span><br><span class="line">[0.955s][info   ][gc,cpu         ] GC(595) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.955s][info   ][gc,start       ] GC(596) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.955s][info   ][gc,task        ] GC(596) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.955s][info   ][gc,phases      ] GC(596)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.955s][info   ][gc,phases      ] GC(596)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.955s][info   ][gc,phases      ] GC(596)   Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.955s][info   ][gc,phases      ] GC(596)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.955s][info   ][gc,phases      ] GC(596)   Other: 0.0ms</span><br><span class="line">[0.955s][info   ][gc,heap        ] GC(596) Eden regions: 1-&gt;0(24)</span><br><span class="line">[0.955s][info   ][gc,heap        ] GC(596) Survivor regions: 4-&gt;1(4)</span><br><span class="line">[0.955s][info   ][gc,heap        ] GC(596) Old regions: 314-&gt;318</span><br><span class="line">[0.955s][info   ][gc,heap        ] GC(596) Archive regions: 2-&gt;2</span><br><span class="line">[0.955s][info   ][gc,heap        ] GC(596) Humongous regions: 174-&gt;174</span><br><span class="line">[0.955s][info   ][gc,metaspace   ] GC(596) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.955s][info   ][gc             ] GC(596) Pause Young (Concurrent Start) (G1 Humongous Allocation) 471M-&gt;470M(512M) 0.684ms</span><br><span class="line">[0.955s][info   ][gc,cpu         ] GC(596) User=0.00s Sys=0.01s Real=0.00s</span><br><span class="line">[0.956s][info   ][gc             ] GC(597) Concurrent Mark Cycle</span><br><span class="line">[0.956s][info   ][gc,marking     ] GC(597) Concurrent Clear Claimed Marks</span><br><span class="line">[0.956s][info   ][gc,marking     ] GC(597) Concurrent Clear Claimed Marks 0.007ms</span><br><span class="line">[0.956s][info   ][gc,marking     ] GC(597) Concurrent Scan Root Regions</span><br><span class="line">[0.956s][info   ][gc,marking     ] GC(597) Concurrent Scan Root Regions 0.068ms</span><br><span class="line">[0.956s][info   ][gc,marking     ] GC(597) Concurrent Mark</span><br><span class="line">[0.956s][info   ][gc,marking     ] GC(597) Concurrent Mark From Roots</span><br><span class="line">[0.956s][info   ][gc,task        ] GC(597) Using 2 workers of 2 for marking</span><br><span class="line">[0.956s][info   ][gc,start       ] GC(598) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.956s][info   ][gc,task        ] GC(598) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.957s][info   ][gc,phases      ] GC(598)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.957s][info   ][gc,phases      ] GC(598)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.957s][info   ][gc,phases      ] GC(598)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.957s][info   ][gc,phases      ] GC(598)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.957s][info   ][gc,phases      ] GC(598)   Other: 0.0ms</span><br><span class="line">[0.957s][info   ][gc,heap        ] GC(598) Eden regions: 9-&gt;0(22)</span><br><span class="line">[0.957s][info   ][gc,heap        ] GC(598) Survivor regions: 1-&gt;3(4)</span><br><span class="line">[0.957s][info   ][gc,heap        ] GC(598) Old regions: 318-&gt;318</span><br><span class="line">[0.957s][info   ][gc,heap        ] GC(598) Archive regions: 2-&gt;2</span><br><span class="line">[0.957s][info   ][gc,heap        ] GC(598) Humongous regions: 178-&gt;174</span><br><span class="line">[0.957s][info   ][gc,metaspace   ] GC(598) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.957s][info   ][gc             ] GC(598) Pause Young (Normal) (G1 Preventive Collection) 483M-&gt;473M(512M) 0.579ms</span><br><span class="line">[0.957s][info   ][gc,cpu         ] GC(598) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.957s][info   ][gc,marking     ] GC(597) Concurrent Mark From Roots 1.518ms</span><br><span class="line">[0.957s][info   ][gc,marking     ] GC(597) Concurrent Preclean</span><br><span class="line">[0.957s][info   ][gc,marking     ] GC(597) Concurrent Preclean 0.008ms</span><br><span class="line">[0.957s][info   ][gc,start       ] GC(597) Pause Remark</span><br><span class="line">[0.958s][info   ][gc             ] GC(597) Pause Remark 479M-&gt;479M(512M) 0.423ms</span><br><span class="line">[0.958s][info   ][gc,cpu         ] GC(597) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.958s][info   ][gc,marking     ] GC(597) Concurrent Mark 2.117ms</span><br><span class="line">[0.958s][info   ][gc,marking     ] GC(597) Concurrent Rebuild Remembered Sets</span><br><span class="line">[0.958s][info   ][gc,start       ] GC(599) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.958s][info   ][gc,task        ] GC(599) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.959s][info   ][gc,phases      ] GC(599)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.959s][info   ][gc,phases      ] GC(599)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.959s][info   ][gc,phases      ] GC(599)   Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.959s][info   ][gc,phases      ] GC(599)   Post Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.959s][info   ][gc,phases      ] GC(599)   Other: 0.0ms</span><br><span class="line">[0.959s][info   ][gc,heap        ] GC(599) Eden regions: 5-&gt;0(23)</span><br><span class="line">[0.959s][info   ][gc,heap        ] GC(599) Survivor regions: 3-&gt;2(4)</span><br><span class="line">[0.959s][info   ][gc,heap        ] GC(599) Old regions: 318-&gt;321</span><br><span class="line">[0.959s][info   ][gc,heap        ] GC(599) Archive regions: 2-&gt;2</span><br><span class="line">[0.959s][info   ][gc,heap        ] GC(599) Humongous regions: 179-&gt;175</span><br><span class="line">[0.959s][info   ][gc,metaspace   ] GC(599) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.959s][info   ][gc             ] GC(599) Pause Young (Normal) (G1 Preventive Collection) 482M-&gt;476M(512M) 0.965ms</span><br><span class="line">[0.959s][info   ][gc,cpu         ] GC(599) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.959s][info   ][gc,marking     ] GC(597) Concurrent Rebuild Remembered Sets 1.741ms</span><br><span class="line">[0.960s][info   ][gc,start       ] GC(597) Pause Cleanup</span><br><span class="line">[0.960s][info   ][gc             ] GC(597) Pause Cleanup 477M-&gt;477M(512M) 0.332ms</span><br><span class="line">[0.960s][info   ][gc,cpu         ] GC(597) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.960s][info   ][gc,marking     ] GC(597) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.960s][info   ][gc,marking     ] GC(597) Concurrent Cleanup for Next Mark 0.304ms</span><br><span class="line">[0.960s][info   ][gc             ] GC(597) Concurrent Mark Cycle 4.944ms</span><br><span class="line">[0.961s][info   ][gc,start       ] GC(600) Pause Young (Prepare Mixed) (G1 Preventive Collection)</span><br><span class="line">[0.961s][info   ][gc,task        ] GC(600) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.961s][info   ][gc,phases      ] GC(600)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.961s][info   ][gc,phases      ] GC(600)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.961s][info   ][gc,phases      ] GC(600)   Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.961s][info   ][gc,phases      ] GC(600)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.961s][info   ][gc,phases      ] GC(600)   Other: 0.0ms</span><br><span class="line">[0.961s][info   ][gc,heap        ] GC(600) Eden regions: 5-&gt;0(21)</span><br><span class="line">[0.961s][info   ][gc,heap        ] GC(600) Survivor regions: 2-&gt;4(4)</span><br><span class="line">[0.961s][info   ][gc,heap        ] GC(600) Old regions: 321-&gt;321</span><br><span class="line">[0.961s][info   ][gc,heap        ] GC(600) Archive regions: 2-&gt;2</span><br><span class="line">[0.961s][info   ][gc,heap        ] GC(600) Humongous regions: 177-&gt;174</span><br><span class="line">[0.961s][info   ][gc,metaspace   ] GC(600) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.961s][info   ][gc             ] GC(600) Pause Young (Prepare Mixed) (G1 Preventive Collection) 483M-&gt;477M(512M) 0.630ms</span><br><span class="line">[0.961s][info   ][gc,cpu         ] GC(600) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">[0.962s][info   ][gc,start       ] GC(601) Pause Young (Mixed) (G1 Preventive Collection)</span><br><span class="line">[0.962s][info   ][gc,task        ] GC(601) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.962s][info   ][gc,phases      ] GC(601)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.962s][info   ][gc,phases      ] GC(601)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.962s][info   ][gc,phases      ] GC(601)   Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.962s][info   ][gc,phases      ] GC(601)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.962s][info   ][gc,phases      ] GC(601)   Other: 0.0ms</span><br><span class="line">[0.962s][info   ][gc,heap        ] GC(601) Eden regions: 3-&gt;0(23)</span><br><span class="line">[0.962s][info   ][gc,heap        ] GC(601) Survivor regions: 4-&gt;2(4)</span><br><span class="line">[0.962s][info   ][gc,heap        ] GC(601) Old regions: 321-&gt;322</span><br><span class="line">[0.962s][info   ][gc,heap        ] GC(601) Archive regions: 2-&gt;2</span><br><span class="line">[0.962s][info   ][gc,heap        ] GC(601) Humongous regions: 175-&gt;175</span><br><span class="line">[0.962s][info   ][gc,metaspace   ] GC(601) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.962s][info   ][gc             ] GC(601) Pause Young (Mixed) (G1 Preventive Collection) (Evacuation Failure) 480M-&gt;477M(512M) 0.719ms</span><br><span class="line">[0.963s][info   ][gc,cpu         ] GC(601) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.963s][info   ][gc,start       ] GC(602) Pause Young (Mixed) (G1 Preventive Collection)</span><br><span class="line">[0.963s][info   ][gc,task        ] GC(602) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.964s][info   ][gc,phases      ] GC(602)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.964s][info   ][gc,phases      ] GC(602)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.964s][info   ][gc,phases      ] GC(602)   Evacuate Collection Set: 0.5ms</span><br><span class="line">[0.964s][info   ][gc,phases      ] GC(602)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.964s][info   ][gc,phases      ] GC(602)   Other: 0.0ms</span><br><span class="line">[0.964s][info   ][gc,heap        ] GC(602) Eden regions: 1-&gt;0(24)</span><br><span class="line">[0.964s][info   ][gc,heap        ] GC(602) Survivor regions: 2-&gt;1(4)</span><br><span class="line">[0.964s][info   ][gc,heap        ] GC(602) Old regions: 322-&gt;328</span><br><span class="line">[0.964s][info   ][gc,heap        ] GC(602) Archive regions: 2-&gt;2</span><br><span class="line">[0.964s][info   ][gc,heap        ] GC(602) Humongous regions: 175-&gt;175</span><br><span class="line">[0.964s][info   ][gc,metaspace   ] GC(602) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.964s][info   ][gc             ] GC(602) Pause Young (Mixed) (G1 Preventive Collection) (Evacuation Failure) 478M-&gt;483M(512M) 0.998ms</span><br><span class="line">[0.964s][info   ][gc,cpu         ] GC(602) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.964s][info   ][gc,start       ] GC(603) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.964s][info   ][gc,task        ] GC(603) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.964s][info   ][gc,phases      ] GC(603)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.964s][info   ][gc,phases      ] GC(603)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.964s][info   ][gc,phases      ] GC(603)   Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.964s][info   ][gc,phases      ] GC(603)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.964s][info   ][gc,phases      ] GC(603)   Other: 0.1ms</span><br><span class="line">[0.964s][info   ][gc,heap        ] GC(603) Eden regions: 1-&gt;0(23)</span><br><span class="line">[0.964s][info   ][gc,heap        ] GC(603) Survivor regions: 1-&gt;2(4)</span><br><span class="line">[0.964s][info   ][gc,heap        ] GC(603) Old regions: 328-&gt;328</span><br><span class="line">[0.964s][info   ][gc,heap        ] GC(603) Archive regions: 2-&gt;2</span><br><span class="line">[0.964s][info   ][gc,heap        ] GC(603) Humongous regions: 175-&gt;175</span><br><span class="line">[0.964s][info   ][gc,metaspace   ] GC(603) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.964s][info   ][gc             ] GC(603) Pause Young (Concurrent Start) (G1 Humongous Allocation) 484M-&gt;483M(512M) 0.629ms</span><br><span class="line">[0.964s][info   ][gc,cpu         ] GC(603) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.964s][info   ][gc             ] GC(604) Concurrent Mark Cycle</span><br><span class="line">[0.964s][info   ][gc,marking     ] GC(604) Concurrent Clear Claimed Marks</span><br><span class="line">[0.964s][info   ][gc,marking     ] GC(604) Concurrent Clear Claimed Marks 0.008ms</span><br><span class="line">[0.964s][info   ][gc,marking     ] GC(604) Concurrent Scan Root Regions</span><br><span class="line">[0.965s][info   ][gc,marking     ] GC(604) Concurrent Scan Root Regions 0.044ms</span><br><span class="line">[0.965s][info   ][gc,marking     ] GC(604) Concurrent Mark</span><br><span class="line">[0.965s][info   ][gc,marking     ] GC(604) Concurrent Mark From Roots</span><br><span class="line">[0.965s][info   ][gc,task        ] GC(604) Using 2 workers of 2 for marking</span><br><span class="line">[0.965s][info   ][gc,start       ] GC(605) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.965s][info   ][gc,task        ] GC(605) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.965s][info   ][gc,phases      ] GC(605)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.965s][info   ][gc,phases      ] GC(605)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.965s][info   ][gc,phases      ] GC(605)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.965s][info   ][gc,phases      ] GC(605)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.965s][info   ][gc,phases      ] GC(605)   Other: 0.0ms</span><br><span class="line">[0.965s][info   ][gc,heap        ] GC(605) Eden regions: 1-&gt;0(22)</span><br><span class="line">[0.965s][info   ][gc,heap        ] GC(605) Survivor regions: 2-&gt;3(3)</span><br><span class="line">[0.965s][info   ][gc,heap        ] GC(605) Old regions: 328-&gt;328</span><br><span class="line">[0.965s][info   ][gc,heap        ] GC(605) Archive regions: 2-&gt;2</span><br><span class="line">[0.965s][info   ][gc,heap        ] GC(605) Humongous regions: 176-&gt;174</span><br><span class="line">[0.965s][info   ][gc,metaspace   ] GC(605) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.965s][info   ][gc             ] GC(605) Pause Young (Normal) (G1 Preventive Collection) 485M-&gt;483M(512M) 0.488ms</span><br><span class="line">[0.965s][info   ][gc,cpu         ] GC(605) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.966s][info   ][gc,start       ] GC(606) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.966s][info   ][gc,task        ] GC(606) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.966s][info   ][gc,phases      ] GC(606)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.966s][info   ][gc,phases      ] GC(606)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.966s][info   ][gc,phases      ] GC(606)   Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.966s][info   ][gc,phases      ] GC(606)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.966s][info   ][gc,phases      ] GC(606)   Other: 0.0ms</span><br><span class="line">[0.966s][info   ][gc,heap        ] GC(606) Eden regions: 1-&gt;0(22)</span><br><span class="line">[0.966s][info   ][gc,heap        ] GC(606) Survivor regions: 3-&gt;3(4)</span><br><span class="line">[0.966s][info   ][gc,heap        ] GC(606) Old regions: 328-&gt;328</span><br><span class="line">[0.966s][info   ][gc,heap        ] GC(606) Archive regions: 2-&gt;2</span><br><span class="line">[0.966s][info   ][gc,heap        ] GC(606) Humongous regions: 174-&gt;174</span><br><span class="line">[0.966s][info   ][gc,metaspace   ] GC(606) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.966s][info   ][gc             ] GC(606) Pause Young (Normal) (G1 Preventive Collection) 484M-&gt;483M(512M) 0.554ms</span><br><span class="line">[0.966s][info   ][gc,cpu         ] GC(606) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.966s][info   ][gc,start       ] GC(607) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.966s][info   ][gc,task        ] GC(607) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.967s][info   ][gc,phases      ] GC(607)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.967s][info   ][gc,phases      ] GC(607)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.967s][info   ][gc,phases      ] GC(607)   Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.967s][info   ][gc,phases      ] GC(607)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.967s][info   ][gc,phases      ] GC(607)   Other: 0.0ms</span><br><span class="line">[0.967s][info   ][gc,heap        ] GC(607) Eden regions: 1-&gt;0(22)</span><br><span class="line">[0.967s][info   ][gc,heap        ] GC(607) Survivor regions: 3-&gt;3(4)</span><br><span class="line">[0.967s][info   ][gc,heap        ] GC(607) Old regions: 328-&gt;329</span><br><span class="line">[0.967s][info   ][gc,heap        ] GC(607) Archive regions: 2-&gt;2</span><br><span class="line">[0.967s][info   ][gc,heap        ] GC(607) Humongous regions: 174-&gt;174</span><br><span class="line">[0.967s][info   ][gc,metaspace   ] GC(607) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.967s][info   ][gc             ] GC(607) Pause Young (Normal) (G1 Preventive Collection) 484M-&gt;484M(512M) 0.457ms</span><br><span class="line">[0.967s][info   ][gc,cpu         ] GC(607) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.967s][info   ][gc,start       ] GC(608) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.967s][info   ][gc,task        ] GC(608) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.967s][info   ][gc,phases      ] GC(608)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.967s][info   ][gc,phases      ] GC(608)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.967s][info   ][gc,phases      ] GC(608)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.967s][info   ][gc,phases      ] GC(608)   Post Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.967s][info   ][gc,phases      ] GC(608)   Other: 0.0ms</span><br><span class="line">[0.967s][info   ][gc,heap        ] GC(608) Eden regions: 1-&gt;0(22)</span><br><span class="line">[0.967s][info   ][gc,heap        ] GC(608) Survivor regions: 3-&gt;3(3)</span><br><span class="line">[0.967s][info   ][gc,heap        ] GC(608) Old regions: 329-&gt;329</span><br><span class="line">[0.967s][info   ][gc,heap        ] GC(608) Archive regions: 2-&gt;2</span><br><span class="line">[0.967s][info   ][gc,heap        ] GC(608) Humongous regions: 174-&gt;174</span><br><span class="line">[0.967s][info   ][gc,metaspace   ] GC(608) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.968s][info   ][gc             ] GC(608) Pause Young (Normal) (G1 Preventive Collection) 484M-&gt;484M(512M) 0.361ms</span><br><span class="line">[0.968s][info   ][gc,cpu         ] GC(608) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.968s][info   ][gc,start       ] GC(609) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.968s][info   ][gc,task        ] GC(609) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.968s][info   ][gc,phases      ] GC(609)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.968s][info   ][gc,phases      ] GC(609)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.968s][info   ][gc,phases      ] GC(609)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.968s][info   ][gc,phases      ] GC(609)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.968s][info   ][gc,phases      ] GC(609)   Other: 0.0ms</span><br><span class="line">[0.968s][info   ][gc,heap        ] GC(609) Eden regions: 0-&gt;0(23)</span><br><span class="line">[0.968s][info   ][gc,heap        ] GC(609) Survivor regions: 3-&gt;2(3)</span><br><span class="line">[0.968s][info   ][gc,heap        ] GC(609) Old regions: 329-&gt;329</span><br><span class="line">[0.968s][info   ][gc,heap        ] GC(609) Archive regions: 2-&gt;2</span><br><span class="line">[0.968s][info   ][gc,heap        ] GC(609) Humongous regions: 175-&gt;174</span><br><span class="line">[0.968s][info   ][gc,metaspace   ] GC(609) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.968s][info   ][gc             ] GC(609) Pause Young (Normal) (G1 Preventive Collection) 485M-&gt;483M(512M) 0.351ms</span><br><span class="line">[0.968s][info   ][gc,cpu         ] GC(609) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.968s][info   ][gc,marking     ] GC(604) Concurrent Mark From Roots 3.586ms</span><br><span class="line">[0.968s][info   ][gc,marking     ] GC(604) Concurrent Preclean</span><br><span class="line">[0.968s][info   ][gc,marking     ] GC(604) Concurrent Preclean 0.009ms</span><br><span class="line">[0.968s][info   ][gc,start       ] GC(604) Pause Remark</span><br><span class="line">[0.968s][info   ][gc             ] GC(604) Pause Remark 484M-&gt;483M(512M) 0.174ms</span><br><span class="line">[0.968s][info   ][gc,cpu         ] GC(604) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.968s][info   ][gc,marking     ] GC(604) Concurrent Mark 3.928ms</span><br><span class="line">[0.968s][info   ][gc,marking     ] GC(604) Concurrent Rebuild Remembered Sets</span><br><span class="line">[0.969s][info   ][gc,start       ] GC(610) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.969s][info   ][gc,task        ] GC(610) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.969s][info   ][gc,phases      ] GC(610)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.969s][info   ][gc,phases      ] GC(610)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.969s][info   ][gc,phases      ] GC(610)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.969s][info   ][gc,phases      ] GC(610)   Post Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.969s][info   ][gc,phases      ] GC(610)   Other: 0.0ms</span><br><span class="line">[0.969s][info   ][gc,heap        ] GC(610) Eden regions: 2-&gt;0(22)</span><br><span class="line">[0.969s][info   ][gc,heap        ] GC(610) Survivor regions: 2-&gt;3(3)</span><br><span class="line">[0.969s][info   ][gc,heap        ] GC(610) Old regions: 328-&gt;328</span><br><span class="line">[0.969s][info   ][gc,heap        ] GC(610) Archive regions: 2-&gt;2</span><br><span class="line">[0.969s][info   ][gc,heap        ] GC(610) Humongous regions: 175-&gt;173</span><br><span class="line">[0.969s][info   ][gc,metaspace   ] GC(610) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.969s][info   ][gc             ] GC(610) Pause Young (Normal) (G1 Preventive Collection) 485M-&gt;482M(512M) 0.428ms</span><br><span class="line">[0.969s][info   ][gc,cpu         ] GC(610) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.970s][info   ][gc,start       ] GC(611) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.970s][info   ][gc,task        ] GC(611) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.970s][info   ][gc,phases      ] GC(611)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.970s][info   ][gc,phases      ] GC(611)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.970s][info   ][gc,phases      ] GC(611)   Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.970s][info   ][gc,phases      ] GC(611)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.970s][info   ][gc,phases      ] GC(611)   Other: 0.0ms</span><br><span class="line">[0.970s][info   ][gc,heap        ] GC(611) Eden regions: 1-&gt;0(22)</span><br><span class="line">[0.970s][info   ][gc,heap        ] GC(611) Survivor regions: 3-&gt;3(4)</span><br><span class="line">[0.970s][info   ][gc,heap        ] GC(611) Old regions: 328-&gt;329</span><br><span class="line">[0.970s][info   ][gc,heap        ] GC(611) Archive regions: 2-&gt;2</span><br><span class="line">[0.970s][info   ][gc,heap        ] GC(611) Humongous regions: 174-&gt;172</span><br><span class="line">[0.970s][info   ][gc,metaspace   ] GC(611) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.970s][info   ][gc             ] GC(611) Pause Young (Normal) (G1 Preventive Collection) 484M-&gt;482M(512M) 0.494ms</span><br><span class="line">[0.970s][info   ][gc,cpu         ] GC(611) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.970s][info   ][gc,marking     ] GC(604) Concurrent Rebuild Remembered Sets 1.919ms</span><br><span class="line">[0.970s][info   ][gc,start       ] GC(604) Pause Cleanup</span><br><span class="line">[0.971s][info   ][gc             ] GC(604) Pause Cleanup 483M-&gt;483M(512M) 0.179ms</span><br><span class="line">[0.971s][info   ][gc,cpu         ] GC(604) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.971s][info   ][gc,marking     ] GC(604) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.971s][info   ][gc,start       ] GC(612) Pause Young (Prepare Mixed) (G1 Preventive Collection)</span><br><span class="line">[0.971s][info   ][gc,task        ] GC(612) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.971s][info   ][gc,phases      ] GC(612)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.971s][info   ][gc,phases      ] GC(612)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.971s][info   ][gc,phases      ] GC(612)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.971s][info   ][gc,phases      ] GC(612)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.971s][info   ][gc,phases      ] GC(612)   Other: 0.0ms</span><br><span class="line">[0.971s][info   ][gc,heap        ] GC(612) Eden regions: 2-&gt;0(22)</span><br><span class="line">[0.971s][info   ][gc,heap        ] GC(612) Survivor regions: 3-&gt;3(4)</span><br><span class="line">[0.971s][info   ][gc,heap        ] GC(612) Old regions: 329-&gt;330</span><br><span class="line">[0.971s][info   ][gc,heap        ] GC(612) Archive regions: 2-&gt;2</span><br><span class="line">[0.971s][info   ][gc,heap        ] GC(612) Humongous regions: 172-&gt;172</span><br><span class="line">[0.971s][info   ][gc,metaspace   ] GC(612) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.971s][info   ][gc             ] GC(612) Pause Young (Prepare Mixed) (G1 Preventive Collection) 483M-&gt;483M(512M) 0.414ms</span><br><span class="line">[0.971s][info   ][gc,cpu         ] GC(612) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">[0.971s][info   ][gc,start       ] GC(613) Pause Young (Mixed) (G1 Preventive Collection)</span><br><span class="line">[0.971s][info   ][gc,task        ] GC(613) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.972s][info   ][gc,phases      ] GC(613)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.972s][info   ][gc,phases      ] GC(613)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.972s][info   ][gc,phases      ] GC(613)   Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.972s][info   ][gc,phases      ] GC(613)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.972s][info   ][gc,phases      ] GC(613)   Other: 0.0ms</span><br><span class="line">[0.972s][info   ][gc,heap        ] GC(613) Eden regions: 0-&gt;0(24)</span><br><span class="line">[0.972s][info   ][gc,heap        ] GC(613) Survivor regions: 3-&gt;1(4)</span><br><span class="line">[0.972s][info   ][gc,heap        ] GC(613) Old regions: 330-&gt;319</span><br><span class="line">[0.972s][info   ][gc,heap        ] GC(613) Archive regions: 2-&gt;2</span><br><span class="line">[0.972s][info   ][gc,heap        ] GC(613) Humongous regions: 173-&gt;173</span><br><span class="line">[0.972s][info   ][gc,metaspace   ] GC(613) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.972s][info   ][gc             ] GC(613) Pause Young (Mixed) (G1 Preventive Collection) (Evacuation Failure) 484M-&gt;473M(512M) 0.594ms</span><br><span class="line">[0.972s][info   ][gc,cpu         ] GC(613) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.972s][info   ][gc,marking     ] GC(604) Concurrent Cleanup for Next Mark 1.462ms</span><br><span class="line">[0.972s][info   ][gc             ] GC(604) Concurrent Mark Cycle 7.720ms</span><br><span class="line">[0.972s][info   ][gc,start       ] GC(614) Pause Young (Mixed) (G1 Preventive Collection)</span><br><span class="line">[0.972s][info   ][gc,task        ] GC(614) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.973s][info   ][gc,phases      ] GC(614)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.973s][info   ][gc,phases      ] GC(614)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.973s][info   ][gc,phases      ] GC(614)   Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.973s][info   ][gc,phases      ] GC(614)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.973s][info   ][gc,phases      ] GC(614)   Other: 0.0ms</span><br><span class="line">[0.973s][info   ][gc,heap        ] GC(614) Eden regions: 5-&gt;0(23)</span><br><span class="line">[0.973s][info   ][gc,heap        ] GC(614) Survivor regions: 1-&gt;2(4)</span><br><span class="line">[0.973s][info   ][gc,heap        ] GC(614) Old regions: 319-&gt;330</span><br><span class="line">[0.973s][info   ][gc,heap        ] GC(614) Archive regions: 2-&gt;2</span><br><span class="line">[0.973s][info   ][gc,heap        ] GC(614) Humongous regions: 175-&gt;174</span><br><span class="line">[0.973s][info   ][gc,metaspace   ] GC(614) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.973s][info   ][gc             ] GC(614) Pause Young (Mixed) (G1 Preventive Collection) (Evacuation Failure) 480M-&gt;486M(512M) 0.763ms</span><br><span class="line">[0.973s][info   ][gc,cpu         ] GC(614) User=0.00s Sys=0.01s Real=0.00s</span><br><span class="line">[0.973s][info   ][gc,start       ] GC(615) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.973s][info   ][gc,task        ] GC(615) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.974s][info   ][gc,phases      ] GC(615)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.974s][info   ][gc,phases      ] GC(615)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.974s][info   ][gc,phases      ] GC(615)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.974s][info   ][gc,phases      ] GC(615)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.974s][info   ][gc,phases      ] GC(615)   Other: 0.0ms</span><br><span class="line">[0.974s][info   ][gc,heap        ] GC(615) Eden regions: 1-&gt;0(23)</span><br><span class="line">[0.974s][info   ][gc,heap        ] GC(615) Survivor regions: 2-&gt;2(3)</span><br><span class="line">[0.974s][info   ][gc,heap        ] GC(615) Old regions: 330-&gt;330</span><br><span class="line">[0.974s][info   ][gc,heap        ] GC(615) Archive regions: 2-&gt;2</span><br><span class="line">[0.974s][info   ][gc,heap        ] GC(615) Humongous regions: 174-&gt;174</span><br><span class="line">[0.974s][info   ][gc,metaspace   ] GC(615) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.974s][info   ][gc             ] GC(615) Pause Young (Concurrent Start) (G1 Humongous Allocation) 486M-&gt;486M(512M) 0.575ms</span><br><span class="line">[0.974s][info   ][gc,cpu         ] GC(615) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.974s][info   ][gc             ] GC(616) Concurrent Mark Cycle</span><br><span class="line">[0.974s][info   ][gc,marking     ] GC(616) Concurrent Clear Claimed Marks</span><br><span class="line">[0.974s][info   ][gc,marking     ] GC(616) Concurrent Clear Claimed Marks 0.006ms</span><br><span class="line">[0.974s][info   ][gc,marking     ] GC(616) Concurrent Scan Root Regions</span><br><span class="line">[0.974s][info   ][gc,marking     ] GC(616) Concurrent Scan Root Regions 0.054ms</span><br><span class="line">[0.974s][info   ][gc,marking     ] GC(616) Concurrent Mark</span><br><span class="line">[0.974s][info   ][gc,marking     ] GC(616) Concurrent Mark From Roots</span><br><span class="line">[0.974s][info   ][gc,task        ] GC(616) Using 2 workers of 2 for marking</span><br><span class="line">[0.974s][info   ][gc,start       ] GC(617) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.974s][info   ][gc,task        ] GC(617) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.974s][info   ][gc,phases      ] GC(617)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.974s][info   ][gc,phases      ] GC(617)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.974s][info   ][gc,phases      ] GC(617)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.974s][info   ][gc,phases      ] GC(617)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.974s][info   ][gc,phases      ] GC(617)   Other: 0.0ms</span><br><span class="line">[0.974s][info   ][gc,heap        ] GC(617) Eden regions: 0-&gt;0(22)</span><br><span class="line">[0.974s][info   ][gc,heap        ] GC(617) Survivor regions: 2-&gt;3(3)</span><br><span class="line">[0.974s][info   ][gc,heap        ] GC(617) Old regions: 330-&gt;330</span><br><span class="line">[0.974s][info   ][gc,heap        ] GC(617) Archive regions: 2-&gt;2</span><br><span class="line">[0.974s][info   ][gc,heap        ] GC(617) Humongous regions: 175-&gt;174</span><br><span class="line">[0.974s][info   ][gc,metaspace   ] GC(617) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.974s][info   ][gc             ] GC(617) Pause Young (Normal) (G1 Preventive Collection) 487M-&gt;486M(512M) 0.391ms</span><br><span class="line">[0.974s][info   ][gc,cpu         ] GC(617) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.974s][info   ][gc,start       ] GC(618) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.974s][info   ][gc,task        ] GC(618) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.975s][info   ][gc,phases      ] GC(618)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.975s][info   ][gc,phases      ] GC(618)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.975s][info   ][gc,phases      ] GC(618)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.975s][info   ][gc,phases      ] GC(618)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.975s][info   ][gc,phases      ] GC(618)   Other: 0.0ms</span><br><span class="line">[0.975s][info   ][gc,heap        ] GC(618) Eden regions: 1-&gt;0(23)</span><br><span class="line">[0.975s][info   ][gc,heap        ] GC(618) Survivor regions: 3-&gt;2(2)</span><br><span class="line">[0.975s][info   ][gc,heap        ] GC(618) Old regions: 330-&gt;332</span><br><span class="line">[0.975s][info   ][gc,heap        ] GC(618) Archive regions: 2-&gt;2</span><br><span class="line">[0.975s][info   ][gc,heap        ] GC(618) Humongous regions: 174-&gt;174</span><br><span class="line">[0.975s][info   ][gc,metaspace   ] GC(618) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.975s][info   ][gc             ] GC(618) Pause Young (Normal) (G1 Preventive Collection) (Evacuation Failure) 487M-&gt;488M(512M) 0.448ms</span><br><span class="line">[0.975s][info   ][gc,cpu         ] GC(618) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.975s][info   ][gc,start       ] GC(619) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.975s][info   ][gc,task        ] GC(619) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.975s][info   ][gc,phases      ] GC(619)   Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[0.975s][info   ][gc,phases      ] GC(619)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.975s][info   ][gc,phases      ] GC(619)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.975s][info   ][gc,phases      ] GC(619)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.975s][info   ][gc,phases      ] GC(619)   Other: 0.0ms</span><br><span class="line">[0.975s][info   ][gc,heap        ] GC(619) Eden regions: 1-&gt;0(24)</span><br><span class="line">[0.975s][info   ][gc,heap        ] GC(619) Survivor regions: 2-&gt;1(1)</span><br><span class="line">[0.975s][info   ][gc,heap        ] GC(619) Old regions: 332-&gt;335</span><br><span class="line">[0.975s][info   ][gc,heap        ] GC(619) Archive regions: 2-&gt;2</span><br><span class="line">[0.975s][info   ][gc,heap        ] GC(619) Humongous regions: 174-&gt;174</span><br><span class="line">[0.975s][info   ][gc,metaspace   ] GC(619) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.975s][info   ][gc             ] GC(619) Pause Young (Normal) (G1 Preventive Collection) (Evacuation Failure) 488M-&gt;489M(512M) 0.457ms</span><br><span class="line">[0.976s][info   ][gc,cpu         ] GC(619) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.976s][info   ][gc,ergo        ] Attempting full compaction</span><br><span class="line">[0.976s][info   ][gc,start       ] GC(620) Pause Full (G1 Compaction Pause)</span><br><span class="line">[0.976s][info   ][gc,task        ] GC(620) Using 8 workers of 8 for full compaction</span><br><span class="line">[0.976s][info   ][gc,phases,start] GC(620) Phase 1: Mark live objects</span><br><span class="line">[0.976s][info   ][gc,phases      ] GC(620) Phase 1: Mark live objects 0.537ms</span><br><span class="line">[0.976s][info   ][gc,phases,start] GC(620) Phase 2: Prepare compaction</span><br><span class="line">[0.976s][info   ][gc,phases      ] GC(620) Phase 2: Prepare compaction 0.255ms</span><br><span class="line">[0.977s][info   ][gc,phases,start] GC(620) Phase 3: Adjust pointers</span><br><span class="line">[0.977s][info   ][gc,phases      ] GC(620) Phase 3: Adjust pointers 0.276ms</span><br><span class="line">[0.977s][info   ][gc,phases,start] GC(620) Phase 4: Compact heap</span><br><span class="line">[0.980s][info   ][gc,phases      ] GC(620) Phase 4: Compact heap 2.877ms</span><br><span class="line">[0.980s][info   ][gc,heap        ] GC(620) Eden regions: 0-&gt;0(25)</span><br><span class="line">[0.980s][info   ][gc,heap        ] GC(620) Survivor regions: 1-&gt;0(1)</span><br><span class="line">[0.980s][info   ][gc,heap        ] GC(620) Old regions: 335-&gt;260</span><br><span class="line">[0.980s][info   ][gc,heap        ] GC(620) Archive regions: 2-&gt;2</span><br><span class="line">[0.980s][info   ][gc,heap        ] GC(620) Humongous regions: 174-&gt;174</span><br><span class="line">[0.980s][info   ][gc,metaspace   ] GC(620) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.980s][info   ][gc             ] GC(620) Pause Full (G1 Compaction Pause) 489M-&gt;404M(512M) 4.692ms</span><br><span class="line">[0.980s][info   ][gc,cpu         ] GC(620) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.980s][info   ][gc,marking     ] GC(616) Concurrent Mark From Roots 6.517ms</span><br><span class="line">[0.980s][info   ][gc,marking     ] GC(616) Concurrent Mark Abort</span><br><span class="line">[0.980s][info   ][gc             ] GC(616) Concurrent Mark Cycle 6.632ms</span><br><span class="line">[0.981s][info   ][gc,start       ] GC(621) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.981s][info   ][gc,task        ] GC(621) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.981s][info   ][gc,phases      ] GC(621)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.981s][info   ][gc,phases      ] GC(621)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.981s][info   ][gc,phases      ] GC(621)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.981s][info   ][gc,phases      ] GC(621)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.981s][info   ][gc,phases      ] GC(621)   Other: 0.0ms</span><br><span class="line">[0.981s][info   ][gc,heap        ] GC(621) Eden regions: 2-&gt;0(24)</span><br><span class="line">[0.981s][info   ][gc,heap        ] GC(621) Survivor regions: 0-&gt;1(4)</span><br><span class="line">[0.981s][info   ][gc,heap        ] GC(621) Old regions: 260-&gt;260</span><br><span class="line">[0.981s][info   ][gc,heap        ] GC(621) Archive regions: 2-&gt;2</span><br><span class="line">[0.981s][info   ][gc,heap        ] GC(621) Humongous regions: 175-&gt;175</span><br><span class="line">[0.981s][info   ][gc,metaspace   ] GC(621) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.981s][info   ][gc             ] GC(621) Pause Young (Concurrent Start) (G1 Humongous Allocation) 407M-&gt;406M(512M) 0.660ms</span><br><span class="line">[0.981s][info   ][gc,cpu         ] GC(621) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.981s][info   ][gc             ] GC(622) Concurrent Mark Cycle</span><br><span class="line">[0.981s][info   ][gc,marking     ] GC(622) Concurrent Clear Claimed Marks</span><br><span class="line">[0.981s][info   ][gc,marking     ] GC(622) Concurrent Clear Claimed Marks 0.007ms</span><br><span class="line">[0.981s][info   ][gc,marking     ] GC(622) Concurrent Scan Root Regions</span><br><span class="line">[0.981s][info   ][gc,marking     ] GC(622) Concurrent Scan Root Regions 0.040ms</span><br><span class="line">[0.981s][info   ][gc,marking     ] GC(622) Concurrent Mark</span><br><span class="line">[0.981s][info   ][gc,marking     ] GC(622) Concurrent Mark From Roots</span><br><span class="line">[0.981s][info   ][gc,task        ] GC(622) Using 2 workers of 2 for marking</span><br><span class="line">[0.982s][info   ][gc,marking     ] GC(622) Concurrent Mark From Roots 0.719ms</span><br><span class="line">[0.982s][info   ][gc,marking     ] GC(622) Concurrent Preclean</span><br><span class="line">[0.982s][info   ][gc,marking     ] GC(622) Concurrent Preclean 0.008ms</span><br><span class="line">[0.982s][info   ][gc,start       ] GC(622) Pause Remark</span><br><span class="line">[0.982s][info   ][gc             ] GC(622) Pause Remark 422M-&gt;421M(512M) 0.273ms</span><br><span class="line">[0.982s][info   ][gc,cpu         ] GC(622) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.983s][info   ][gc,marking     ] GC(622) Concurrent Mark 1.169ms</span><br><span class="line">[0.983s][info   ][gc,marking     ] GC(622) Concurrent Rebuild Remembered Sets</span><br><span class="line">[0.983s][info   ][gc,marking     ] GC(622) Concurrent Rebuild Remembered Sets 0.448ms</span><br><span class="line">[0.983s][info   ][gc,start       ] GC(622) Pause Cleanup</span><br><span class="line">[0.983s][info   ][gc             ] GC(622) Pause Cleanup 440M-&gt;440M(512M) 0.159ms</span><br><span class="line">[0.983s][info   ][gc,cpu         ] GC(622) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.983s][info   ][gc,marking     ] GC(622) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.984s][info   ][gc,marking     ] GC(622) Concurrent Cleanup for Next Mark 0.283ms</span><br><span class="line">[0.984s][info   ][gc             ] GC(622) Concurrent Mark Cycle 2.361ms</span><br><span class="line">[0.984s][info   ][gc,start       ] GC(623) Pause Young (Prepare Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.984s][info   ][gc,task        ] GC(623) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.984s][info   ][gc,phases      ] GC(623)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.984s][info   ][gc,phases      ] GC(623)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.985s][info   ][gc,phases      ] GC(623)   Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.985s][info   ][gc,phases      ] GC(623)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.985s][info   ][gc,phases      ] GC(623)   Other: 0.0ms</span><br><span class="line">[0.985s][info   ][gc,heap        ] GC(623) Eden regions: 24-&gt;0(21)</span><br><span class="line">[0.985s][info   ][gc,heap        ] GC(623) Survivor regions: 1-&gt;4(4)</span><br><span class="line">[0.985s][info   ][gc,heap        ] GC(623) Old regions: 260-&gt;271</span><br><span class="line">[0.985s][info   ][gc,heap        ] GC(623) Archive regions: 2-&gt;2</span><br><span class="line">[0.985s][info   ][gc,heap        ] GC(623) Humongous regions: 194-&gt;177</span><br><span class="line">[0.985s][info   ][gc,metaspace   ] GC(623) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.985s][info   ][gc             ] GC(623) Pause Young (Prepare Mixed) (G1 Evacuation Pause) 449M-&gt;421M(512M) 0.845ms</span><br><span class="line">[0.985s][info   ][gc,cpu         ] GC(623) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.986s][info   ][gc,start       ] GC(624) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.986s][info   ][gc,task        ] GC(624) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.987s][info   ][gc,phases      ] GC(624)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.987s][info   ][gc,phases      ] GC(624)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.987s][info   ][gc,phases      ] GC(624)   Evacuate Collection Set: 0.5ms</span><br><span class="line">[0.987s][info   ][gc,phases      ] GC(624)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.987s][info   ][gc,phases      ] GC(624)   Other: 0.0ms</span><br><span class="line">[0.987s][info   ][gc,heap        ] GC(624) Eden regions: 21-&gt;0(21)</span><br><span class="line">[0.987s][info   ][gc,heap        ] GC(624) Survivor regions: 4-&gt;4(4)</span><br><span class="line">[0.987s][info   ][gc,heap        ] GC(624) Old regions: 271-&gt;278</span><br><span class="line">[0.987s][info   ][gc,heap        ] GC(624) Archive regions: 2-&gt;2</span><br><span class="line">[0.987s][info   ][gc,heap        ] GC(624) Humongous regions: 185-&gt;172</span><br><span class="line">[0.987s][info   ][gc,metaspace   ] GC(624) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.987s][info   ][gc             ] GC(624) Pause Young (Mixed) (G1 Evacuation Pause) 450M-&gt;429M(512M) 0.957ms</span><br><span class="line">[0.987s][info   ][gc,cpu         ] GC(624) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.987s][info   ][gc,start       ] GC(625) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.987s][info   ][gc,task        ] GC(625) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.988s][info   ][gc,phases      ] GC(625)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.988s][info   ][gc,phases      ] GC(625)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.988s][info   ][gc,phases      ] GC(625)   Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.988s][info   ][gc,phases      ] GC(625)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.988s][info   ][gc,phases      ] GC(625)   Other: 0.0ms</span><br><span class="line">[0.988s][info   ][gc,heap        ] GC(625) Eden regions: 4-&gt;0(22)</span><br><span class="line">[0.988s][info   ][gc,heap        ] GC(625) Survivor regions: 4-&gt;3(4)</span><br><span class="line">[0.988s][info   ][gc,heap        ] GC(625) Old regions: 278-&gt;282</span><br><span class="line">[0.988s][info   ][gc,heap        ] GC(625) Archive regions: 2-&gt;2</span><br><span class="line">[0.988s][info   ][gc,heap        ] GC(625) Humongous regions: 172-&gt;172</span><br><span class="line">[0.988s][info   ][gc,metaspace   ] GC(625) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.988s][info   ][gc             ] GC(625) Pause Young (Concurrent Start) (G1 Humongous Allocation) 433M-&gt;431M(512M) 0.757ms</span><br><span class="line">[0.988s][info   ][gc,cpu         ] GC(625) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.988s][info   ][gc             ] GC(626) Concurrent Mark Cycle</span><br><span class="line">[0.988s][info   ][gc,marking     ] GC(626) Concurrent Clear Claimed Marks</span><br><span class="line">[0.988s][info   ][gc,marking     ] GC(626) Concurrent Clear Claimed Marks 0.007ms</span><br><span class="line">[0.988s][info   ][gc,marking     ] GC(626) Concurrent Scan Root Regions</span><br><span class="line">[0.988s][info   ][gc,marking     ] GC(626) Concurrent Scan Root Regions 0.062ms</span><br><span class="line">[0.988s][info   ][gc,marking     ] GC(626) Concurrent Mark</span><br><span class="line">[0.988s][info   ][gc,marking     ] GC(626) Concurrent Mark From Roots</span><br><span class="line">[0.988s][info   ][gc,task        ] GC(626) Using 2 workers of 2 for marking</span><br><span class="line">[0.989s][info   ][gc,marking     ] GC(626) Concurrent Mark From Roots 0.805ms</span><br><span class="line">[0.989s][info   ][gc,marking     ] GC(626) Concurrent Preclean</span><br><span class="line">[0.989s][info   ][gc,marking     ] GC(626) Concurrent Preclean 0.008ms</span><br><span class="line">[0.989s][info   ][gc,start       ] GC(626) Pause Remark</span><br><span class="line">[0.990s][info   ][gc             ] GC(626) Pause Remark 450M-&gt;450M(512M) 0.283ms</span><br><span class="line">[0.990s][info   ][gc,cpu         ] GC(626) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.990s][info   ][gc,marking     ] GC(626) Concurrent Mark 1.321ms</span><br><span class="line">[0.990s][info   ][gc,marking     ] GC(626) Concurrent Rebuild Remembered Sets</span><br><span class="line">[0.990s][info   ][gc,marking     ] GC(626) Concurrent Rebuild Remembered Sets 0.453ms</span><br><span class="line">[0.990s][info   ][gc,start       ] GC(626) Pause Cleanup</span><br><span class="line">[0.990s][info   ][gc             ] GC(626) Pause Cleanup 457M-&gt;457M(512M) 0.140ms</span><br><span class="line">[0.990s][info   ][gc,cpu         ] GC(626) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.990s][info   ][gc,marking     ] GC(626) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.991s][info   ][gc,marking     ] GC(626) Concurrent Cleanup for Next Mark 0.270ms</span><br><span class="line">[0.991s][info   ][gc             ] GC(626) Concurrent Mark Cycle 2.515ms</span><br><span class="line">[0.991s][info   ][gc,start       ] GC(627) Pause Young (Prepare Mixed) (G1 Preventive Collection)</span><br><span class="line">[0.991s][info   ][gc,task        ] GC(627) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.992s][info   ][gc,phases      ] GC(627)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.992s][info   ][gc,phases      ] GC(627)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.992s][info   ][gc,phases      ] GC(627)   Evacuate Collection Set: 0.4ms</span><br><span class="line">[0.992s][info   ][gc,phases      ] GC(627)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.992s][info   ][gc,phases      ] GC(627)   Other: 0.0ms</span><br><span class="line">[0.992s][info   ][gc,heap        ] GC(627) Eden regions: 21-&gt;0(21)</span><br><span class="line">[0.992s][info   ][gc,heap        ] GC(627) Survivor regions: 3-&gt;4(4)</span><br><span class="line">[0.992s][info   ][gc,heap        ] GC(627) Old regions: 282-&gt;290</span><br><span class="line">[0.992s][info   ][gc,heap        ] GC(627) Archive regions: 2-&gt;2</span><br><span class="line">[0.992s][info   ][gc,heap        ] GC(627) Humongous regions: 187-&gt;173</span><br><span class="line">[0.992s][info   ][gc,metaspace   ] GC(627) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.992s][info   ][gc             ] GC(627) Pause Young (Prepare Mixed) (G1 Preventive Collection) 467M-&gt;442M(512M) 0.887ms</span><br><span class="line">[0.992s][info   ][gc,cpu         ] GC(627) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">[0.993s][info   ][gc,start       ] GC(628) Pause Young (Mixed) (G1 Preventive Collection)</span><br><span class="line">[0.993s][info   ][gc,task        ] GC(628) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.994s][info   ][gc,phases      ] GC(628)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.994s][info   ][gc,phases      ] GC(628)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.994s][info   ][gc,phases      ] GC(628)   Evacuate Collection Set: 0.6ms</span><br><span class="line">[0.994s][info   ][gc,phases      ] GC(628)   Post Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.994s][info   ][gc,phases      ] GC(628)   Other: 0.0ms</span><br><span class="line">[0.994s][info   ][gc,heap        ] GC(628) Eden regions: 16-&gt;0(21)</span><br><span class="line">[0.994s][info   ][gc,heap        ] GC(628) Survivor regions: 4-&gt;4(4)</span><br><span class="line">[0.994s][info   ][gc,heap        ] GC(628) Old regions: 290-&gt;299</span><br><span class="line">[0.994s][info   ][gc,heap        ] GC(628) Archive regions: 2-&gt;2</span><br><span class="line">[0.994s][info   ][gc,heap        ] GC(628) Humongous regions: 182-&gt;169</span><br><span class="line">[0.994s][info   ][gc,metaspace   ] GC(628) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.994s][info   ][gc             ] GC(628) Pause Young (Mixed) (G1 Preventive Collection) (Evacuation Failure) 466M-&gt;449M(512M) 1.372ms</span><br><span class="line">[0.994s][info   ][gc,cpu         ] GC(628) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.995s][info   ][gc,start       ] GC(629) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.995s][info   ][gc,task        ] GC(629) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.995s][info   ][gc,phases      ] GC(629)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.995s][info   ][gc,phases      ] GC(629)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.995s][info   ][gc,phases      ] GC(629)   Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.995s][info   ][gc,phases      ] GC(629)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.995s][info   ][gc,phases      ] GC(629)   Other: 0.1ms</span><br><span class="line">[0.995s][info   ][gc,heap        ] GC(629) Eden regions: 2-&gt;0(24)</span><br><span class="line">[0.995s][info   ][gc,heap        ] GC(629) Survivor regions: 4-&gt;1(4)</span><br><span class="line">[0.995s][info   ][gc,heap        ] GC(629) Old regions: 299-&gt;304</span><br><span class="line">[0.995s][info   ][gc,heap        ] GC(629) Archive regions: 2-&gt;2</span><br><span class="line">[0.995s][info   ][gc,heap        ] GC(629) Humongous regions: 170-&gt;169</span><br><span class="line">[0.995s][info   ][gc,metaspace   ] GC(629) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.995s][info   ][gc             ] GC(629) Pause Young (Concurrent Start) (G1 Humongous Allocation) 451M-&gt;450M(512M) 0.767ms</span><br><span class="line">[0.995s][info   ][gc,cpu         ] GC(629) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.995s][info   ][gc             ] GC(630) Concurrent Mark Cycle</span><br><span class="line">[0.996s][info   ][gc,marking     ] GC(630) Concurrent Clear Claimed Marks</span><br><span class="line">[0.996s][info   ][gc,marking     ] GC(630) Concurrent Clear Claimed Marks 0.020ms</span><br><span class="line">[0.996s][info   ][gc,marking     ] GC(630) Concurrent Scan Root Regions</span><br><span class="line">[0.996s][info   ][gc,marking     ] GC(630) Concurrent Scan Root Regions 0.046ms</span><br><span class="line">[0.996s][info   ][gc,marking     ] GC(630) Concurrent Mark</span><br><span class="line">[0.996s][info   ][gc,marking     ] GC(630) Concurrent Mark From Roots</span><br><span class="line">[0.996s][info   ][gc,task        ] GC(630) Using 2 workers of 2 for marking</span><br><span class="line">[0.996s][info   ][gc,marking     ] GC(630) Concurrent Mark From Roots 0.878ms</span><br><span class="line">[0.997s][info   ][gc,marking     ] GC(630) Concurrent Preclean</span><br><span class="line">[0.997s][info   ][gc,marking     ] GC(630) Concurrent Preclean 0.011ms</span><br><span class="line">[0.997s][info   ][gc,start       ] GC(630) Pause Remark</span><br><span class="line">[0.997s][info   ][gc             ] GC(630) Pause Remark 471M-&gt;471M(512M) 0.266ms</span><br><span class="line">[0.997s][info   ][gc,cpu         ] GC(630) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.997s][info   ][gc,marking     ] GC(630) Concurrent Mark 1.368ms</span><br><span class="line">[0.997s][info   ][gc,marking     ] GC(630) Concurrent Rebuild Remembered Sets</span><br><span class="line">[0.997s][info   ][gc,start       ] GC(631) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[0.997s][info   ][gc,task        ] GC(631) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.998s][info   ][gc,phases      ] GC(631)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.998s][info   ][gc,phases      ] GC(631)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.998s][info   ][gc,phases      ] GC(631)   Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.998s][info   ][gc,phases      ] GC(631)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.998s][info   ][gc,phases      ] GC(631)   Other: 0.0ms</span><br><span class="line">[0.998s][info   ][gc,heap        ] GC(631) Eden regions: 15-&gt;0(21)</span><br><span class="line">[0.998s][info   ][gc,heap        ] GC(631) Survivor regions: 1-&gt;4(4)</span><br><span class="line">[0.998s][info   ][gc,heap        ] GC(631) Old regions: 304-&gt;308</span><br><span class="line">[0.998s][info   ][gc,heap        ] GC(631) Archive regions: 2-&gt;2</span><br><span class="line">[0.998s][info   ][gc,heap        ] GC(631) Humongous regions: 177-&gt;171</span><br><span class="line">[0.998s][info   ][gc,metaspace   ] GC(631) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.998s][info   ][gc             ] GC(631) Pause Young (Normal) (G1 Preventive Collection) 473M-&gt;459M(512M) 0.590ms</span><br><span class="line">[0.998s][info   ][gc,cpu         ] GC(631) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.998s][info   ][gc,marking     ] GC(630) Concurrent Rebuild Remembered Sets 1.352ms</span><br><span class="line">[0.998s][info   ][gc,start       ] GC(630) Pause Cleanup</span><br><span class="line">[0.999s][info   ][gc             ] GC(630) Pause Cleanup 469M-&gt;469M(512M) 0.192ms</span><br><span class="line">[0.999s][info   ][gc,cpu         ] GC(630) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.999s][info   ][gc,marking     ] GC(630) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.999s][info   ][gc,marking     ] GC(630) Concurrent Cleanup for Next Mark 0.278ms</span><br><span class="line">[0.999s][info   ][gc             ] GC(630) Concurrent Mark Cycle 3.542ms</span><br><span class="line">[0.999s][info   ][gc,start       ] GC(632) Pause Young (Prepare Mixed) (G1 Preventive Collection)</span><br><span class="line">[0.999s][info   ][gc,task        ] GC(632) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.000s][info   ][gc,phases      ] GC(632)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.000s][info   ][gc,phases      ] GC(632)   Merge Heap Roots: 0.0ms</span><br><span class="line">[1.000s][info   ][gc,phases      ] GC(632)   Evacuate Collection Set: 0.2ms</span><br><span class="line">[1.000s][info   ][gc,phases      ] GC(632)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.000s][info   ][gc,phases      ] GC(632)   Other: 0.0ms</span><br><span class="line">[1.000s][info   ][gc,heap        ] GC(632) Eden regions: 11-&gt;0(21)</span><br><span class="line">[1.000s][info   ][gc,heap        ] GC(632) Survivor regions: 4-&gt;4(4)</span><br><span class="line">[1.000s][info   ][gc,heap        ] GC(632) Old regions: 308-&gt;312</span><br><span class="line">[1.000s][info   ][gc,heap        ] GC(632) Archive regions: 2-&gt;2</span><br><span class="line">[1.000s][info   ][gc,heap        ] GC(632) Humongous regions: 175-&gt;168</span><br><span class="line">[1.000s][info   ][gc,metaspace   ] GC(632) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.000s][info   ][gc             ] GC(632) Pause Young (Prepare Mixed) (G1 Preventive Collection) 474M-&gt;461M(512M) 0.683ms</span><br><span class="line">[1.000s][info   ][gc,cpu         ] GC(632) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[1.001s][info   ][gc,start       ] GC(633) Pause Young (Mixed) (G1 Preventive Collection)</span><br><span class="line">[1.001s][info   ][gc,task        ] GC(633) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.001s][info   ][gc,phases      ] GC(633)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.001s][info   ][gc,phases      ] GC(633)   Merge Heap Roots: 0.1ms</span><br><span class="line">[1.001s][info   ][gc,phases      ] GC(633)   Evacuate Collection Set: 0.3ms</span><br><span class="line">[1.001s][info   ][gc,phases      ] GC(633)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.001s][info   ][gc,phases      ] GC(633)   Other: 0.0ms</span><br><span class="line">[1.001s][info   ][gc,heap        ] GC(633) Eden regions: 10-&gt;0(23)</span><br><span class="line">[1.001s][info   ][gc,heap        ] GC(633) Survivor regions: 4-&gt;2(4)</span><br><span class="line">[1.001s][info   ][gc,heap        ] GC(633) Old regions: 312-&gt;319</span><br><span class="line">[1.001s][info   ][gc,heap        ] GC(633) Archive regions: 2-&gt;2</span><br><span class="line">[1.001s][info   ][gc,heap        ] GC(633) Humongous regions: 172-&gt;170</span><br><span class="line">[1.001s][info   ][gc,metaspace   ] GC(633) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.001s][info   ][gc             ] GC(633) Pause Young (Mixed) (G1 Preventive Collection) (Evacuation Failure) 475M-&gt;469M(512M) 0.874ms</span><br><span class="line">[1.001s][info   ][gc,cpu         ] GC(633) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">[1.002s][info   ][gc,start       ] GC(634) Pause Young (Mixed) (G1 Preventive Collection)</span><br><span class="line">[1.002s][info   ][gc,task        ] GC(634) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.003s][info   ][gc,phases      ] GC(634)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.003s][info   ][gc,phases      ] GC(634)   Merge Heap Roots: 0.1ms</span><br><span class="line">[1.003s][info   ][gc,phases      ] GC(634)   Evacuate Collection Set: 0.3ms</span><br><span class="line">[1.003s][info   ][gc,phases      ] GC(634)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.003s][info   ][gc,phases      ] GC(634)   Other: 0.0ms</span><br><span class="line">[1.003s][info   ][gc,heap        ] GC(634) Eden regions: 4-&gt;0(21)</span><br><span class="line">[1.003s][info   ][gc,heap        ] GC(634) Survivor regions: 2-&gt;4(4)</span><br><span class="line">[1.003s][info   ][gc,heap        ] GC(634) Old regions: 319-&gt;319</span><br><span class="line">[1.003s][info   ][gc,heap        ] GC(634) Archive regions: 2-&gt;2</span><br><span class="line">[1.003s][info   ][gc,heap        ] GC(634) Humongous regions: 173-&gt;168</span><br><span class="line">[1.003s][info   ][gc,metaspace   ] GC(634) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.003s][info   ][gc             ] GC(634) Pause Young (Mixed) (G1 Preventive Collection) (Evacuation Failure) 476M-&gt;469M(512M) 0.781ms</span><br><span class="line">[1.003s][info   ][gc,cpu         ] GC(634) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[1.003s][info   ][gc,start       ] GC(635) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[1.003s][info   ][gc,task        ] GC(635) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.003s][info   ][gc,phases      ] GC(635)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.003s][info   ][gc,phases      ] GC(635)   Merge Heap Roots: 0.0ms</span><br><span class="line">[1.003s][info   ][gc,phases      ] GC(635)   Evacuate Collection Set: 0.2ms</span><br><span class="line">[1.003s][info   ][gc,phases      ] GC(635)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.003s][info   ][gc,phases      ] GC(635)   Other: 0.0ms</span><br><span class="line">[1.003s][info   ][gc,heap        ] GC(635) Eden regions: 1-&gt;0(23)</span><br><span class="line">[1.003s][info   ][gc,heap        ] GC(635) Survivor regions: 4-&gt;2(4)</span><br><span class="line">[1.003s][info   ][gc,heap        ] GC(635) Old regions: 319-&gt;322</span><br><span class="line">[1.003s][info   ][gc,heap        ] GC(635) Archive regions: 2-&gt;2</span><br><span class="line">[1.003s][info   ][gc,heap        ] GC(635) Humongous regions: 168-&gt;168</span><br><span class="line">[1.003s][info   ][gc,metaspace   ] GC(635) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.003s][info   ][gc             ] GC(635) Pause Young (Concurrent Start) (G1 Humongous Allocation) 469M-&gt;469M(512M) 0.544ms</span><br><span class="line">[1.003s][info   ][gc             ] GC(636) Concurrent Mark Cycle</span><br><span class="line">[1.003s][info   ][gc,cpu         ] GC(635) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[1.003s][info   ][gc,marking     ] GC(636) Concurrent Clear Claimed Marks</span><br><span class="line">[1.003s][info   ][gc,marking     ] GC(636) Concurrent Clear Claimed Marks 0.024ms</span><br><span class="line">[1.003s][info   ][gc,marking     ] GC(636) Concurrent Scan Root Regions</span><br><span class="line">[1.003s][info   ][gc,marking     ] GC(636) Concurrent Scan Root Regions 0.041ms</span><br><span class="line">[1.003s][info   ][gc,marking     ] GC(636) Concurrent Mark</span><br><span class="line">[1.003s][info   ][gc,marking     ] GC(636) Concurrent Mark From Roots</span><br><span class="line">[1.003s][info   ][gc,task        ] GC(636) Using 2 workers of 2 for marking</span><br><span class="line">[1.004s][info   ][gc,start       ] GC(637) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[1.004s][info   ][gc,task        ] GC(637) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.004s][info   ][gc,phases      ] GC(637)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.004s][info   ][gc,phases      ] GC(637)   Merge Heap Roots: 0.0ms</span><br><span class="line">[1.004s][info   ][gc,phases      ] GC(637)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.004s][info   ][gc,phases      ] GC(637)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.004s][info   ][gc,phases      ] GC(637)   Other: 0.0ms</span><br><span class="line">[1.004s][info   ][gc,heap        ] GC(637) Eden regions: 6-&gt;0(21)</span><br><span class="line">[1.004s][info   ][gc,heap        ] GC(637) Survivor regions: 2-&gt;4(4)</span><br><span class="line">[1.004s][info   ][gc,heap        ] GC(637) Old regions: 322-&gt;322</span><br><span class="line">[1.004s][info   ][gc,heap        ] GC(637) Archive regions: 2-&gt;2</span><br><span class="line">[1.004s][info   ][gc,heap        ] GC(637) Humongous regions: 175-&gt;170</span><br><span class="line">[1.004s][info   ][gc,metaspace   ] GC(637) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.004s][info   ][gc             ] GC(637) Pause Young (Normal) (G1 Preventive Collection) 481M-&gt;474M(512M) 0.489ms</span><br><span class="line">[1.004s][info   ][gc,cpu         ] GC(637) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[1.005s][info   ][gc,start       ] GC(638) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[1.005s][info   ][gc,task        ] GC(638) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.005s][info   ][gc,phases      ] GC(638)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.005s][info   ][gc,phases      ] GC(638)   Merge Heap Roots: 0.0ms</span><br><span class="line">[1.005s][info   ][gc,phases      ] GC(638)   Evacuate Collection Set: 0.2ms</span><br><span class="line">[1.005s][info   ][gc,phases      ] GC(638)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.005s][info   ][gc,phases      ] GC(638)   Other: 0.0ms</span><br><span class="line">[1.005s][info   ][gc,heap        ] GC(638) Eden regions: 4-&gt;0(24)</span><br><span class="line">[1.005s][info   ][gc,heap        ] GC(638) Survivor regions: 4-&gt;1(4)</span><br><span class="line">[1.005s][info   ][gc,heap        ] GC(638) Old regions: 322-&gt;326</span><br><span class="line">[1.005s][info   ][gc,heap        ] GC(638) Archive regions: 2-&gt;2</span><br><span class="line">[1.005s][info   ][gc,heap        ] GC(638) Humongous regions: 173-&gt;170</span><br><span class="line">[1.005s][info   ][gc,metaspace   ] GC(638) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.005s][info   ][gc             ] GC(638) Pause Young (Normal) (G1 Preventive Collection) 480M-&gt;475M(512M) 0.494ms</span><br><span class="line">[1.005s][info   ][gc,cpu         ] GC(638) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[1.005s][info   ][gc,marking     ] GC(636) Concurrent Mark From Roots 1.901ms</span><br><span class="line">[1.005s][info   ][gc,marking     ] GC(636) Concurrent Preclean</span><br><span class="line">[1.005s][info   ][gc,marking     ] GC(636) Concurrent Preclean 0.008ms</span><br><span class="line">[1.005s][info   ][gc,start       ] GC(636) Pause Remark</span><br><span class="line">[1.006s][info   ][gc             ] GC(636) Pause Remark 479M-&gt;479M(512M) 0.224ms</span><br><span class="line">[1.006s][info   ][gc,cpu         ] GC(636) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[1.006s][info   ][gc,marking     ] GC(636) Concurrent Mark 2.274ms</span><br><span class="line">[1.006s][info   ][gc,marking     ] GC(636) Concurrent Rebuild Remembered Sets</span><br><span class="line">[1.006s][info   ][gc,start       ] GC(639) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[1.006s][info   ][gc,task        ] GC(639) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.007s][info   ][gc,phases      ] GC(639)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.007s][info   ][gc,phases      ] GC(639)   Merge Heap Roots: 0.1ms</span><br><span class="line">[1.007s][info   ][gc,phases      ] GC(639)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.007s][info   ][gc,phases      ] GC(639)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.007s][info   ][gc,phases      ] GC(639)   Other: 0.0ms</span><br><span class="line">[1.007s][info   ][gc,heap        ] GC(639) Eden regions: 5-&gt;0(22)</span><br><span class="line">[1.007s][info   ][gc,heap        ] GC(639) Survivor regions: 1-&gt;3(4)</span><br><span class="line">[1.007s][info   ][gc,heap        ] GC(639) Old regions: 326-&gt;326</span><br><span class="line">[1.007s][info   ][gc,heap        ] GC(639) Archive regions: 2-&gt;2</span><br><span class="line">[1.007s][info   ][gc,heap        ] GC(639) Humongous regions: 174-&gt;169</span><br><span class="line">[1.007s][info   ][gc,metaspace   ] GC(639) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.007s][info   ][gc             ] GC(639) Pause Young (Normal) (G1 Preventive Collection) 483M-&gt;475M(512M) 0.597ms</span><br><span class="line">[1.007s][info   ][gc,cpu         ] GC(639) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[1.007s][info   ][gc,start       ] GC(640) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[1.007s][info   ][gc,task        ] GC(640) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.007s][info   ][gc,phases      ] GC(640)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.007s][info   ][gc,phases      ] GC(640)   Merge Heap Roots: 0.0ms</span><br><span class="line">[1.007s][info   ][gc,phases      ] GC(640)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.007s][info   ][gc,phases      ] GC(640)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.007s][info   ][gc,phases      ] GC(640)   Other: 0.0ms</span><br><span class="line">[1.007s][info   ][gc,heap        ] GC(640) Eden regions: 4-&gt;0(22)</span><br><span class="line">[1.007s][info   ][gc,heap        ] GC(640) Survivor regions: 3-&gt;3(4)</span><br><span class="line">[1.007s][info   ][gc,heap        ] GC(640) Old regions: 326-&gt;327</span><br><span class="line">[1.007s][info   ][gc,heap        ] GC(640) Archive regions: 2-&gt;2</span><br><span class="line">[1.007s][info   ][gc,heap        ] GC(640) Humongous regions: 172-&gt;168</span><br><span class="line">[1.007s][info   ][gc,metaspace   ] GC(640) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.007s][info   ][gc             ] GC(640) Pause Young (Normal) (G1 Preventive Collection) 481M-&gt;475M(512M) 0.497ms</span><br><span class="line">[1.007s][info   ][gc,cpu         ] GC(640) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[1.008s][info   ][gc,marking     ] GC(636) Concurrent Rebuild Remembered Sets 2.104ms</span><br><span class="line">[1.008s][info   ][gc,start       ] GC(636) Pause Cleanup</span><br><span class="line">[1.008s][info   ][gc             ] GC(636) Pause Cleanup 481M-&gt;481M(512M) 0.139ms</span><br><span class="line">[1.008s][info   ][gc,cpu         ] GC(636) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[1.008s][info   ][gc,marking     ] GC(636) Concurrent Cleanup for Next Mark</span><br><span class="line">[1.008s][info   ][gc,start       ] GC(641) Pause Young (Prepare Mixed) (G1 Preventive Collection)</span><br><span class="line">[1.008s][info   ][gc,task        ] GC(641) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.009s][info   ][gc,phases      ] GC(641)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.009s][info   ][gc,phases      ] GC(641)   Merge Heap Roots: 0.0ms</span><br><span class="line">[1.009s][info   ][gc,phases      ] GC(641)   Evacuate Collection Set: 0.2ms</span><br><span class="line">[1.009s][info   ][gc,phases      ] GC(641)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.009s][info   ][gc,phases      ] GC(641)   Other: 0.0ms</span><br><span class="line">[1.009s][info   ][gc,heap        ] GC(641) Eden regions: 3-&gt;0(22)</span><br><span class="line">[1.009s][info   ][gc,heap        ] GC(641) Survivor regions: 3-&gt;3(4)</span><br><span class="line">[1.009s][info   ][gc,heap        ] GC(641) Old regions: 327-&gt;328</span><br><span class="line">[1.009s][info   ][gc,heap        ] GC(641) Archive regions: 2-&gt;2</span><br><span class="line">[1.009s][info   ][gc,heap        ] GC(641) Humongous regions: 172-&gt;169</span><br><span class="line">[1.009s][info   ][gc,metaspace   ] GC(641) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.009s][info   ][gc             ] GC(641) Pause Young (Prepare Mixed) (G1 Preventive Collection) 482M-&gt;478M(512M) 0.489ms</span><br><span class="line">[1.009s][info   ][gc,cpu         ] GC(641) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[1.009s][info   ][gc,start       ] GC(642) Pause Young (Mixed) (G1 Preventive Collection)</span><br><span class="line">[1.009s][info   ][gc,task        ] GC(642) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.009s][info   ][gc,phases      ] GC(642)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.009s][info   ][gc,phases      ] GC(642)   Merge Heap Roots: 0.0ms</span><br><span class="line">[1.009s][info   ][gc,phases      ] GC(642)   Evacuate Collection Set: 0.2ms</span><br><span class="line">[1.009s][info   ][gc,phases      ] GC(642)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[1.009s][info   ][gc,phases      ] GC(642)   Other: 0.0ms</span><br><span class="line">[1.009s][info   ][gc,heap        ] GC(642) Eden regions: 1-&gt;0(24)</span><br><span class="line">[1.009s][info   ][gc,heap        ] GC(642) Survivor regions: 3-&gt;1(4)</span><br><span class="line">[1.009s][info   ][gc,heap        ] GC(642) Old regions: 328-&gt;322</span><br><span class="line">[1.009s][info   ][gc,heap        ] GC(642) Archive regions: 2-&gt;2</span><br><span class="line">[1.009s][info   ][gc,heap        ] GC(642) Humongous regions: 173-&gt;170</span><br><span class="line">[1.009s][info   ][gc,metaspace   ] GC(642) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.009s][info   ][gc             ] GC(642) Pause Young (Mixed) (G1 Preventive Collection) (Evacuation Failure) 483M-&gt;472M(512M) 0.697ms</span><br><span class="line">[1.009s][info   ][gc,cpu         ] GC(642) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[1.010s][info   ][gc,marking     ] GC(636) Concurrent Cleanup for Next Mark 1.582ms</span><br><span class="line">[1.010s][info   ][gc             ] GC(636) Concurrent Mark Cycle 6.365ms</span><br><span class="line">[1.010s][info   ][gc,start       ] GC(643) Pause Young (Mixed) (G1 Preventive Collection)</span><br><span class="line">[1.010s][info   ][gc,task        ] GC(643) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.011s][info   ][gc,phases      ] GC(643)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.011s][info   ][gc,phases      ] GC(643)   Merge Heap Roots: 0.0ms</span><br><span class="line">[1.011s][info   ][gc,phases      ] GC(643)   Evacuate Collection Set: 0.3ms</span><br><span class="line">[1.011s][info   ][gc,phases      ] GC(643)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[1.011s][info   ][gc,phases      ] GC(643)   Other: 0.0ms</span><br><span class="line">[1.011s][info   ][gc,heap        ] GC(643) Eden regions: 4-&gt;0(23)</span><br><span class="line">[1.011s][info   ][gc,heap        ] GC(643) Survivor regions: 1-&gt;2(4)</span><br><span class="line">[1.011s][info   ][gc,heap        ] GC(643) Old regions: 322-&gt;330</span><br><span class="line">[1.011s][info   ][gc,heap        ] GC(643) Archive regions: 2-&gt;2</span><br><span class="line">[1.011s][info   ][gc,heap        ] GC(643) Humongous regions: 171-&gt;169</span><br><span class="line">[1.011s][info   ][gc,metaspace   ] GC(643) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.011s][info   ][gc             ] GC(643) Pause Young (Mixed) (G1 Preventive Collection) (Evacuation Failure) 476M-&gt;481M(512M) 0.768ms</span><br><span class="line">[1.011s][info   ][gc,cpu         ] GC(643) User=0.01s Sys=0.01s Real=0.00s</span><br><span class="line">[1.011s][info   ][gc,start       ] GC(644) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[1.011s][info   ][gc,task        ] GC(644) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.011s][info   ][gc,phases      ] GC(644)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[1.011s][info   ][gc,phases      ] GC(644)   Merge Heap Roots: 0.0ms</span><br><span class="line">[1.011s][info   ][gc,phases      ] GC(644)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.011s][info   ][gc,phases      ] GC(644)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.011s][info   ][gc,phases      ] GC(644)   Other: 0.1ms</span><br><span class="line">[1.011s][info   ][gc,heap        ] GC(644) Eden regions: 1-&gt;0(23)</span><br><span class="line">[1.011s][info   ][gc,heap        ] GC(644) Survivor regions: 2-&gt;2(4)</span><br><span class="line">[1.011s][info   ][gc,heap        ] GC(644) Old regions: 330-&gt;330</span><br><span class="line">[1.011s][info   ][gc,heap        ] GC(644) Archive regions: 2-&gt;2</span><br><span class="line">[1.011s][info   ][gc,heap        ] GC(644) Humongous regions: 170-&gt;169</span><br><span class="line">[1.011s][info   ][gc,metaspace   ] GC(644) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.011s][info   ][gc             ] GC(644) Pause Young (Concurrent Start) (G1 Humongous Allocation) 482M-&gt;480M(512M) 0.598ms</span><br><span class="line">[1.011s][info   ][gc,cpu         ] GC(644) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">[1.011s][info   ][gc             ] GC(645) Concurrent Mark Cycle</span><br><span class="line">[1.011s][info   ][gc,marking     ] GC(645) Concurrent Clear Claimed Marks</span><br><span class="line">[1.011s][info   ][gc,marking     ] GC(645) Concurrent Clear Claimed Marks 0.006ms</span><br><span class="line">[1.011s][info   ][gc,marking     ] GC(645) Concurrent Scan Root Regions</span><br><span class="line">[1.011s][info   ][gc,marking     ] GC(645) Concurrent Scan Root Regions 0.021ms</span><br><span class="line">[1.011s][info   ][gc,marking     ] GC(645) Concurrent Mark</span><br><span class="line">[1.011s][info   ][gc,marking     ] GC(645) Concurrent Mark From Roots</span><br><span class="line">[1.011s][info   ][gc,task        ] GC(645) Using 2 workers of 2 for marking</span><br><span class="line">[1.012s][info   ][gc,start       ] GC(646) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[1.012s][info   ][gc,task        ] GC(646) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.012s][info   ][gc,phases      ] GC(646)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.012s][info   ][gc,phases      ] GC(646)   Merge Heap Roots: 0.0ms</span><br><span class="line">[1.012s][info   ][gc,phases      ] GC(646)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.012s][info   ][gc,phases      ] GC(646)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.012s][info   ][gc,phases      ] GC(646)   Other: 0.0ms</span><br><span class="line">[1.012s][info   ][gc,heap        ] GC(646) Eden regions: 3-&gt;0(21)</span><br><span class="line">[1.012s][info   ][gc,heap        ] GC(646) Survivor regions: 2-&gt;4(4)</span><br><span class="line">[1.012s][info   ][gc,heap        ] GC(646) Old regions: 330-&gt;330</span><br><span class="line">[1.012s][info   ][gc,heap        ] GC(646) Archive regions: 2-&gt;2</span><br><span class="line">[1.012s][info   ][gc,heap        ] GC(646) Humongous regions: 171-&gt;169</span><br><span class="line">[1.012s][info   ][gc,metaspace   ] GC(646) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.012s][info   ][gc             ] GC(646) Pause Young (Normal) (G1 Preventive Collection) 485M-&gt;482M(512M) 0.549ms</span><br><span class="line">[1.012s][info   ][gc,cpu         ] GC(646) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[1.012s][info   ][gc,start       ] GC(647) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[1.012s][info   ][gc,task        ] GC(647) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.013s][info   ][gc,phases      ] GC(647)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.013s][info   ][gc,phases      ] GC(647)   Merge Heap Roots: 0.0ms</span><br><span class="line">[1.013s][info   ][gc,phases      ] GC(647)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.013s][info   ][gc,phases      ] GC(647)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.013s][info   ][gc,phases      ] GC(647)   Other: 0.0ms</span><br><span class="line">[1.013s][info   ][gc,heap        ] GC(647) Eden regions: 1-&gt;0(23)</span><br><span class="line">[1.013s][info   ][gc,heap        ] GC(647) Survivor regions: 4-&gt;2(4)</span><br><span class="line">[1.013s][info   ][gc,heap        ] GC(647) Old regions: 330-&gt;332</span><br><span class="line">[1.013s][info   ][gc,heap        ] GC(647) Archive regions: 2-&gt;2</span><br><span class="line">[1.013s][info   ][gc,heap        ] GC(647) Humongous regions: 170-&gt;170</span><br><span class="line">[1.013s][info   ][gc,metaspace   ] GC(647) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.013s][info   ][gc             ] GC(647) Pause Young (Normal) (G1 Preventive Collection) 484M-&gt;483M(512M) 0.494ms</span><br><span class="line">[1.013s][info   ][gc,cpu         ] GC(647) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[1.013s][info   ][gc,start       ] GC(648) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[1.013s][info   ][gc,task        ] GC(648) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.014s][info   ][gc,phases      ] GC(648)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.014s][info   ][gc,phases      ] GC(648)   Merge Heap Roots: 0.0ms</span><br><span class="line">[1.014s][info   ][gc,phases      ] GC(648)   Evacuate Collection Set: 0.2ms</span><br><span class="line">[1.014s][info   ][gc,phases      ] GC(648)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.014s][info   ][gc,phases      ] GC(648)   Other: 0.0ms</span><br><span class="line">[1.014s][info   ][gc,heap        ] GC(648) Eden regions: 3-&gt;0(22)</span><br><span class="line">[1.014s][info   ][gc,heap        ] GC(648) Survivor regions: 2-&gt;3(3)</span><br><span class="line">[1.014s][info   ][gc,heap        ] GC(648) Old regions: 332-&gt;332</span><br><span class="line">[1.014s][info   ][gc,heap        ] GC(648) Archive regions: 2-&gt;2</span><br><span class="line">[1.014s][info   ][gc,heap        ] GC(648) Humongous regions: 170-&gt;170</span><br><span class="line">[1.014s][info   ][gc,metaspace   ] GC(648) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.014s][info   ][gc             ] GC(648) Pause Young (Normal) (G1 Preventive Collection) 486M-&gt;484M(512M) 0.535ms</span><br><span class="line">[1.014s][info   ][gc,cpu         ] GC(648) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[1.014s][info   ][gc,start       ] GC(649) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[1.014s][info   ][gc,task        ] GC(649) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.014s][info   ][gc,phases      ] GC(649)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.014s][info   ][gc,phases      ] GC(649)   Merge Heap Roots: 0.0ms</span><br><span class="line">[1.014s][info   ][gc,phases      ] GC(649)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.014s][info   ][gc,phases      ] GC(649)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.014s][info   ][gc,phases      ] GC(649)   Other: 0.0ms</span><br><span class="line">[1.014s][info   ][gc,heap        ] GC(649) Eden regions: 1-&gt;0(23)</span><br><span class="line">[1.014s][info   ][gc,heap        ] GC(649) Survivor regions: 3-&gt;2(4)</span><br><span class="line">[1.014s][info   ][gc,heap        ] GC(649) Old regions: 332-&gt;334</span><br><span class="line">[1.014s][info   ][gc,heap        ] GC(649) Archive regions: 2-&gt;2</span><br><span class="line">[1.014s][info   ][gc,heap        ] GC(649) Humongous regions: 170-&gt;170</span><br><span class="line">[1.014s][info   ][gc,metaspace   ] GC(649) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.014s][info   ][gc             ] GC(649) Pause Young (Normal) (G1 Preventive Collection) 485M-&gt;484M(512M) 0.500ms</span><br><span class="line">[1.014s][info   ][gc,cpu         ] GC(649) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[1.015s][info   ][gc,start       ] GC(650) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[1.015s][info   ][gc,task        ] GC(650) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.015s][info   ][gc,phases      ] GC(650)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.015s][info   ][gc,phases      ] GC(650)   Merge Heap Roots: 0.1ms</span><br><span class="line">[1.015s][info   ][gc,phases      ] GC(650)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.015s][info   ][gc,phases      ] GC(650)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.015s][info   ][gc,phases      ] GC(650)   Other: 0.0ms</span><br><span class="line">[1.015s][info   ][gc,heap        ] GC(650) Eden regions: 2-&gt;0(23)</span><br><span class="line">[1.015s][info   ][gc,heap        ] GC(650) Survivor regions: 2-&gt;2(2)</span><br><span class="line">[1.015s][info   ][gc,heap        ] GC(650) Old regions: 334-&gt;334</span><br><span class="line">[1.015s][info   ][gc,heap        ] GC(650) Archive regions: 2-&gt;2</span><br><span class="line">[1.015s][info   ][gc,heap        ] GC(650) Humongous regions: 170-&gt;170</span><br><span class="line">[1.015s][info   ][gc,metaspace   ] GC(650) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.015s][info   ][gc             ] GC(650) Pause Young (Normal) (G1 Preventive Collection) 486M-&gt;485M(512M) 0.448ms</span><br><span class="line">[1.015s][info   ][gc,cpu         ] GC(650) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[1.015s][info   ][gc,marking     ] GC(645) Concurrent Mark From Roots 3.787ms</span><br><span class="line">[1.015s][info   ][gc,marking     ] GC(645) Concurrent Preclean</span><br><span class="line">[1.015s][info   ][gc,marking     ] GC(645) Concurrent Preclean 0.009ms</span><br><span class="line">[1.015s][info   ][gc,start       ] GC(645) Pause Remark</span><br><span class="line">[1.016s][info   ][gc             ] GC(645) Pause Remark 486M-&gt;485M(512M) 0.236ms</span><br><span class="line">[1.016s][info   ][gc,cpu         ] GC(645) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[1.016s][info   ][gc,marking     ] GC(645) Concurrent Mark 4.231ms</span><br><span class="line">[1.016s][info   ][gc,marking     ] GC(645) Concurrent Rebuild Remembered Sets</span><br><span class="line">[1.016s][info   ][gc,start       ] GC(651) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[1.016s][info   ][gc,task        ] GC(651) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.016s][info   ][gc,phases      ] GC(651)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.016s][info   ][gc,phases      ] GC(651)   Merge Heap Roots: 0.0ms</span><br><span class="line">[1.016s][info   ][gc,phases      ] GC(651)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.016s][info   ][gc,phases      ] GC(651)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.016s][info   ][gc,phases      ] GC(651)   Other: 0.0ms</span><br><span class="line">[1.016s][info   ][gc,heap        ] GC(651) Eden regions: 2-&gt;0(22)</span><br><span class="line">[1.016s][info   ][gc,heap        ] GC(651) Survivor regions: 2-&gt;3(3)</span><br><span class="line">[1.016s][info   ][gc,heap        ] GC(651) Old regions: 333-&gt;333</span><br><span class="line">[1.016s][info   ][gc,heap        ] GC(651) Archive regions: 2-&gt;2</span><br><span class="line">[1.016s][info   ][gc,heap        ] GC(651) Humongous regions: 170-&gt;170</span><br><span class="line">[1.016s][info   ][gc,metaspace   ] GC(651) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.016s][info   ][gc             ] GC(651) Pause Young (Normal) (G1 Preventive Collection) 486M-&gt;485M(512M) 0.538ms</span><br><span class="line">[1.016s][info   ][gc,cpu         ] GC(651) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[1.016s][info   ][gc,start       ] GC(652) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[1.016s][info   ][gc,task        ] GC(652) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.017s][info   ][gc,phases      ] GC(652)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.017s][info   ][gc,phases      ] GC(652)   Merge Heap Roots: 0.0ms</span><br><span class="line">[1.017s][info   ][gc,phases      ] GC(652)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.017s][info   ][gc,phases      ] GC(652)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.017s][info   ][gc,phases      ] GC(652)   Other: 0.0ms</span><br><span class="line">[1.017s][info   ][gc,heap        ] GC(652) Eden regions: 0-&gt;0(23)</span><br><span class="line">[1.017s][info   ][gc,heap        ] GC(652) Survivor regions: 3-&gt;2(3)</span><br><span class="line">[1.017s][info   ][gc,heap        ] GC(652) Old regions: 333-&gt;333</span><br><span class="line">[1.017s][info   ][gc,heap        ] GC(652) Archive regions: 2-&gt;2</span><br><span class="line">[1.017s][info   ][gc,heap        ] GC(652) Humongous regions: 171-&gt;171</span><br><span class="line">[1.017s][info   ][gc,metaspace   ] GC(652) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.017s][info   ][gc             ] GC(652) Pause Young (Normal) (G1 Preventive Collection) 486M-&gt;485M(512M) 0.497ms</span><br><span class="line">[1.017s][info   ][gc,cpu         ] GC(652) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[1.017s][info   ][gc,start       ] GC(653) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[1.017s][info   ][gc,task        ] GC(653) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.018s][info   ][gc,phases      ] GC(653)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.018s][info   ][gc,phases      ] GC(653)   Merge Heap Roots: 0.1ms</span><br><span class="line">[1.018s][info   ][gc,phases      ] GC(653)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.018s][info   ][gc,phases      ] GC(653)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.018s][info   ][gc,phases      ] GC(653)   Other: 0.0ms</span><br><span class="line">[1.018s][info   ][gc,heap        ] GC(653) Eden regions: 1-&gt;0(22)</span><br><span class="line">[1.018s][info   ][gc,heap        ] GC(653) Survivor regions: 2-&gt;3(3)</span><br><span class="line">[1.018s][info   ][gc,heap        ] GC(653) Old regions: 333-&gt;333</span><br><span class="line">[1.018s][info   ][gc,heap        ] GC(653) Archive regions: 2-&gt;2</span><br><span class="line">[1.018s][info   ][gc,heap        ] GC(653) Humongous regions: 171-&gt;170</span><br><span class="line">[1.018s][info   ][gc,metaspace   ] GC(653) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.018s][info   ][gc             ] GC(653) Pause Young (Normal) (G1 Preventive Collection) 486M-&gt;485M(512M) 0.465ms</span><br><span class="line">[1.018s][info   ][gc,cpu         ] GC(653) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[1.018s][info   ][gc,start       ] GC(654) Pause Young (Normal) (G1 Preventive Collection)</span><br><span class="line">[1.018s][info   ][gc,task        ] GC(654) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.018s][info   ][gc,phases      ] GC(654)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.018s][info   ][gc,phases      ] GC(654)   Merge Heap Roots: 0.0ms</span><br><span class="line">[1.018s][info   ][gc,phases      ] GC(654)   Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.018s][info   ][gc,phases      ] GC(654)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.018s][info   ][gc,phases      ] GC(654)   Other: 0.0ms</span><br><span class="line">[1.018s][info   ][gc,heap        ] GC(654) Eden regions: 1-&gt;0(23)</span><br><span class="line">[1.018s][info   ][gc,heap        ] GC(654) Survivor regions: 3-&gt;2(3)</span><br><span class="line">[1.018s][info   ][gc,heap        ] GC(654) Old regions: 333-&gt;334</span><br><span class="line">[1.018s][info   ][gc,heap        ] GC(654) Archive regions: 2-&gt;2</span><br><span class="line">[1.018s][info   ][gc,heap        ] GC(654) Humongous regions: 170-&gt;170</span><br><span class="line">[1.018s][info   ][gc,metaspace   ] GC(654) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.018s][info   ][gc             ] GC(654) Pause Young (Normal) (G1 Preventive Collection) 486M-&gt;485M(512M) 0.411ms</span><br><span class="line">[1.018s][info   ][gc,cpu         ] GC(654) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[1.019s][info   ][gc,marking     ] GC(645) Concurrent Rebuild Remembered Sets 3.122ms</span><br><span class="line">[1.019s][info   ][gc,start       ] GC(645) Pause Cleanup</span><br><span class="line">[1.019s][info   ][gc             ] GC(645) Pause Cleanup 487M-&gt;487M(512M) 0.243ms</span><br><span class="line">[1.019s][info   ][gc,cpu         ] GC(645) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[1.019s][info   ][gc,marking     ] GC(645) Concurrent Cleanup for Next Mark</span><br><span class="line">[1.019s][info   ][gc,marking     ] GC(645) Concurrent Cleanup for Next Mark 0.282ms</span><br><span class="line">[1.020s][info   ][gc             ] GC(645) Concurrent Mark Cycle 8.118ms</span><br><span class="line">counter:29048</span><br><span class="line">[1.025s][info   ][gc,heap,exit   ] Heap</span><br><span class="line">[1.025s][info   ][gc,heap,exit   ]  garbage-first heap   total 524288K, used 499181K [0x00000007e0000000, 0x0000000800000000)</span><br><span class="line">[1.025s][info   ][gc,heap,exit   ]   region size 1024K, 3 young (3072K), 2 survivors (2048K)</span><br><span class="line">[1.025s][info   ][gc,heap,exit   ]  Metaspace       used 233K, committed 448K, reserved 1114112K</span><br><span class="line">[1.025s][info   ][gc,heap,exit   ]   class space    used 9K, committed 128K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>接下来试试1g内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+UseG1GC -Xms1g -Xmx1g -XX:+PrintGCDetails -Xlog:gc\*:file=gc.log:time,uptime,level,tags GCLogAnalysis</span><br></pre></td></tr></table></figure>

<p>可以发现效率大大提升，生成了56000多个对象。GC了174次。其吞吐量相比并行GC稍微提升，GC次数却很多，说明GC期间很少影响业务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0.628s][info   ][gc,phases   ] GC(92)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.628s][info   ][gc,phases   ] GC(92)   Other: 0.1ms</span><br><span class="line">[0.628s][info   ][gc,heap     ] GC(92) Eden regions: 74-&gt;0(67)</span><br><span class="line">[0.628s][info   ][gc,heap     ] GC(92) Survivor regions: 15-&gt;12(12)</span><br><span class="line">[0.628s][info   ][gc,heap     ] GC(92) Old regions: 545-&gt;579</span><br><span class="line">[0.628s][info   ][gc,heap     ] GC(92) Archive regions: 2-&gt;2</span><br><span class="line">[0.628s][info   ][gc,heap     ] GC(92) Humongous regions: 209-&gt;180</span><br><span class="line">[0.628s][info   ][gc,metaspace] GC(92) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.628s][info   ][gc          ] GC(92) Pause Young (Concurrent Start) (G1 Humongous Allocation) 843M-&gt;771M(1024M) 1.601ms</span><br><span class="line">[0.628s][info   ][gc,cpu      ] GC(92) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.628s][info   ][gc          ] GC(93) Concurrent Mark Cycle</span><br><span class="line">[0.628s][info   ][gc,marking  ] GC(93) Concurrent Clear Claimed Marks</span><br><span class="line">[0.628s][info   ][gc,marking  ] GC(93) Concurrent Clear Claimed Marks 0.021ms</span><br><span class="line">[0.628s][info   ][gc,marking  ] GC(93) Concurrent Scan Root Regions</span><br><span class="line">[0.628s][info   ][gc,marking  ] GC(93) Concurrent Scan Root Regions 0.063ms</span><br><span class="line">[0.628s][info   ][gc,marking  ] GC(93) Concurrent Mark</span><br><span class="line">[0.628s][info   ][gc,marking  ] GC(93) Concurrent Mark From Roots</span><br><span class="line">[0.628s][info   ][gc,task     ] GC(93) Using 2 workers of 2 for marking</span><br><span class="line">[0.629s][info   ][gc,marking  ] GC(93) Concurrent Mark From Roots 1.243ms</span><br><span class="line">[0.629s][info   ][gc,marking  ] GC(93) Concurrent Preclean</span><br><span class="line">[0.629s][info   ][gc,marking  ] GC(93) Concurrent Preclean 0.012ms</span><br><span class="line">[0.629s][info   ][gc,start    ] GC(93) Pause Remark</span><br><span class="line">[0.630s][info   ][gc          ] GC(93) Pause Remark 798M-&gt;729M(1024M) 0.345ms</span><br><span class="line">[0.630s][info   ][gc,cpu      ] GC(93) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.630s][info   ][gc,marking  ] GC(93) Concurrent Mark 1.879ms</span><br><span class="line">[0.630s][info   ][gc,marking  ] GC(93) Concurrent Rebuild Remembered Sets</span><br><span class="line">[0.631s][info   ][gc,marking  ] GC(93) Concurrent Rebuild Remembered Sets 0.920ms</span><br><span class="line">[0.631s][info   ][gc,start    ] GC(93) Pause Cleanup</span><br><span class="line">[0.631s][info   ][gc          ] GC(93) Pause Cleanup 744M-&gt;744M(1024M) 0.167ms</span><br><span class="line">[0.631s][info   ][gc,cpu      ] GC(93) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.631s][info   ][gc,marking  ] GC(93) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.632s][info   ][gc,marking  ] GC(93) Concurrent Cleanup for Next Mark 0.507ms</span><br><span class="line">[0.632s][info   ][gc          ] GC(93) Concurrent Mark Cycle 3.847ms</span><br><span class="line">[0.634s][info   ][gc,start    ] GC(94) Pause Young (Prepare Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.634s][info   ][gc,task     ] GC(94) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.635s][info   ][gc,phases   ] GC(94)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.635s][info   ][gc,phases   ] GC(94)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.635s][info   ][gc,phases   ] GC(94)   Evacuate Collection Set: 1.0ms</span><br><span class="line">[0.635s][info   ][gc,phases   ] GC(94)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.635s][info   ][gc,phases   ] GC(94)   Other: 0.0ms</span><br><span class="line">[0.635s][info   ][gc,heap     ] GC(94) Eden regions: 67-&gt;0(41)</span><br><span class="line">[0.635s][info   ][gc,heap     ] GC(94) Survivor regions: 12-&gt;10(10)</span><br><span class="line">[0.635s][info   ][gc,heap     ] GC(94) Old regions: 510-&gt;542</span><br><span class="line">[0.635s][info   ][gc,heap     ] GC(94) Archive regions: 2-&gt;2</span><br><span class="line">[0.635s][info   ][gc,heap     ] GC(94) Humongous regions: 206-&gt;173</span><br><span class="line">[0.635s][info   ][gc,metaspace] GC(94) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.635s][info   ][gc          ] GC(94) Pause Young (Prepare Mixed) (G1 Evacuation Pause) 795M-&gt;725M(1024M) 1.636ms</span><br><span class="line">[0.635s][info   ][gc,cpu      ] GC(94) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.639s][info   ][gc,start    ] GC(95) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.639s][info   ][gc,task     ] GC(95) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.640s][info   ][gc,phases   ] GC(95)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.640s][info   ][gc,phases   ] GC(95)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.640s][info   ][gc,phases   ] GC(95)   Evacuate Collection Set: 0.8ms</span><br><span class="line">[0.640s][info   ][gc,phases   ] GC(95)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.640s][info   ][gc,phases   ] GC(95)   Other: 0.0ms</span><br><span class="line">[0.640s][info   ][gc,heap     ] GC(95) Eden regions: 41-&gt;0(44)</span><br><span class="line">[0.640s][info   ][gc,heap     ] GC(95) Survivor regions: 10-&gt;7(7)</span><br><span class="line">[0.640s][info   ][gc,heap     ] GC(95) Old regions: 542-&gt;463</span><br><span class="line">[0.640s][info   ][gc,heap     ] GC(95) Archive regions: 2-&gt;2</span><br><span class="line">[0.640s][info   ][gc,heap     ] GC(95) Humongous regions: 191-&gt;174</span><br><span class="line">[0.640s][info   ][gc,metaspace] GC(95) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.640s][info   ][gc          ] GC(95) Pause Young (Mixed) (G1 Evacuation Pause) 784M-&gt;644M(1024M) 1.392ms</span><br><span class="line">[0.640s][info   ][gc,cpu      ] GC(95) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.644s][info   ][gc,start    ] GC(96) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.644s][info   ][gc,task     ] GC(96) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.645s][info   ][gc,phases   ] GC(96)   Pre Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.645s][info   ][gc,phases   ] GC(96)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.645s][info   ][gc,phases   ] GC(96)   Evacuate Collection Set: 1.1ms</span><br><span class="line">[0.645s][info   ][gc,phases   ] GC(96)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.645s][info   ][gc,phases   ] GC(96)   Other: 0.0ms</span><br><span class="line">[0.645s][info   ][gc,heap     ] GC(96) Eden regions: 44-&gt;0(44)</span><br><span class="line">[0.645s][info   ][gc,heap     ] GC(96) Survivor regions: 7-&gt;7(7)</span><br><span class="line">[0.645s][info   ][gc,heap     ] GC(96) Old regions: 463-&gt;402</span><br><span class="line">[0.645s][info   ][gc,heap     ] GC(96) Archive regions: 2-&gt;2</span><br><span class="line">[0.645s][info   ][gc,heap     ] GC(96) Humongous regions: 195-&gt;176</span><br><span class="line">[0.645s][info   ][gc,metaspace] GC(96) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.645s][info   ][gc          ] GC(96) Pause Young (Mixed) (G1 Evacuation Pause) 709M-&gt;585M(1024M) 1.900ms</span><br><span class="line">[0.645s][info   ][gc,cpu      ] GC(96) User=0.01s Sys=0.01s Real=0.00s</span><br><span class="line">[0.649s][info   ][gc,start    ] GC(97) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.649s][info   ][gc,task     ] GC(97) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.650s][info   ][gc,phases   ] GC(97)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.651s][info   ][gc,phases   ] GC(97)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.651s][info   ][gc,phases   ] GC(97)   Evacuate Collection Set: 1.2ms</span><br><span class="line">[0.651s][info   ][gc,phases   ] GC(97)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.651s][info   ][gc,phases   ] GC(97)   Other: 0.1ms</span><br><span class="line">[0.651s][info   ][gc,heap     ] GC(97) Eden regions: 44-&gt;0(44)</span><br><span class="line">[0.651s][info   ][gc,heap     ] GC(97) Survivor regions: 7-&gt;7(7)</span><br><span class="line">[0.651s][info   ][gc,heap     ] GC(97) Old regions: 402-&gt;349</span><br><span class="line">[0.651s][info   ][gc,heap     ] GC(97) Archive regions: 2-&gt;2</span><br><span class="line">[0.651s][info   ][gc,heap     ] GC(97) Humongous regions: 202-&gt;170</span><br><span class="line">[0.651s][info   ][gc,metaspace] GC(97) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.651s][info   ][gc          ] GC(97) Pause Young (Mixed) (G1 Evacuation Pause) 655M-&gt;526M(1024M) 1.993ms</span><br><span class="line">[0.651s][info   ][gc,cpu      ] GC(97) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.654s][info   ][gc,start    ] GC(98) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.654s][info   ][gc,task     ] GC(98) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.655s][info   ][gc,phases   ] GC(98)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.655s][info   ][gc,phases   ] GC(98)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.655s][info   ][gc,phases   ] GC(98)   Evacuate Collection Set: 0.5ms</span><br><span class="line">[0.655s][info   ][gc,phases   ] GC(98)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.655s][info   ][gc,phases   ] GC(98)   Other: 0.0ms</span><br><span class="line">[0.655s][info   ][gc,heap     ] GC(98) Eden regions: 44-&gt;0(182)</span><br><span class="line">[0.655s][info   ][gc,heap     ] GC(98) Survivor regions: 7-&gt;7(7)</span><br><span class="line">[0.655s][info   ][gc,heap     ] GC(98) Old regions: 349-&gt;367</span><br><span class="line">[0.655s][info   ][gc,heap     ] GC(98) Archive regions: 2-&gt;2</span><br><span class="line">[0.655s][info   ][gc,heap     ] GC(98) Humongous regions: 199-&gt;175</span><br><span class="line">[0.655s][info   ][gc,metaspace] GC(98) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.655s][info   ][gc          ] GC(98) Pause Young (Mixed) (G1 Evacuation Pause) 599M-&gt;549M(1024M) 0.986ms</span><br><span class="line">[0.655s][info   ][gc,cpu      ] GC(98) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.669s][info   ][gc,start    ] GC(99) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.669s][info   ][gc,task     ] GC(99) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.672s][info   ][gc,phases   ] GC(99)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.672s][info   ][gc,phases   ] GC(99)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.672s][info   ][gc,phases   ] GC(99)   Evacuate Collection Set: 1.8ms</span><br><span class="line">[0.672s][info   ][gc,phases   ] GC(99)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.672s][info   ][gc,phases   ] GC(99)   Other: 0.0ms</span><br><span class="line">[0.672s][info   ][gc,heap     ] GC(99) Eden regions: 182-&gt;0(156)</span><br><span class="line">[0.672s][info   ][gc,heap     ] GC(99) Survivor regions: 7-&gt;24(24)</span><br><span class="line">[0.672s][info   ][gc,heap     ] GC(99) Old regions: 367-&gt;413</span><br><span class="line">[0.672s][info   ][gc,heap     ] GC(99) Archive regions: 2-&gt;2</span><br><span class="line">[0.672s][info   ][gc,heap     ] GC(99) Humongous regions: 298-&gt;169</span><br><span class="line">[0.672s][info   ][gc,metaspace] GC(99) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.672s][info   ][gc          ] GC(99) Pause Young (Normal) (G1 Evacuation Pause) 854M-&gt;606M(1024M) 2.417ms</span><br><span class="line">[0.672s][info   ][gc,cpu      ] GC(99) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">[0.681s][info   ][gc,start    ] GC(100) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.681s][info   ][gc,task     ] GC(100) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.683s][info   ][gc,phases   ] GC(100)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.683s][info   ][gc,phases   ] GC(100)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.683s][info   ][gc,phases   ] GC(100)   Evacuate Collection Set: 1.3ms</span><br><span class="line">[0.683s][info   ][gc,phases   ] GC(100)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.683s][info   ][gc,phases   ] GC(100)   Other: 0.1ms</span><br><span class="line">[0.683s][info   ][gc,heap     ] GC(100) Eden regions: 128-&gt;0(134)</span><br><span class="line">[0.683s][info   ][gc,heap     ] GC(100) Survivor regions: 24-&gt;23(23)</span><br><span class="line">[0.683s][info   ][gc,heap     ] GC(100) Old regions: 413-&gt;455</span><br><span class="line">[0.683s][info   ][gc,heap     ] GC(100) Archive regions: 2-&gt;2</span><br><span class="line">[0.683s][info   ][gc,heap     ] GC(100) Humongous regions: 258-&gt;172</span><br><span class="line">[0.683s][info   ][gc,metaspace] GC(100) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.683s][info   ][gc          ] GC(100) Pause Young (Concurrent Start) (G1 Humongous Allocation) 822M-&gt;650M(1024M) 2.140ms</span><br><span class="line">[0.683s][info   ][gc,cpu      ] GC(100) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.683s][info   ][gc          ] GC(101) Concurrent Undo Cycle</span><br><span class="line">[0.683s][info   ][gc,marking  ] GC(101) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.683s][info   ][gc,marking  ] GC(101) Concurrent Cleanup for Next Mark 0.047ms</span><br><span class="line">[0.684s][info   ][gc          ] GC(101) Concurrent Undo Cycle 0.114ms</span><br><span class="line">[0.692s][info   ][gc,start    ] GC(102) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.692s][info   ][gc,task     ] GC(102) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.694s][info   ][gc,phases   ] GC(102)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.694s][info   ][gc,phases   ] GC(102)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.694s][info   ][gc,phases   ] GC(102)   Evacuate Collection Set: 1.6ms</span><br><span class="line">[0.694s][info   ][gc,phases   ] GC(102)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.694s][info   ][gc,phases   ] GC(102)   Other: 0.1ms</span><br><span class="line">[0.694s][info   ][gc,heap     ] GC(102) Eden regions: 111-&gt;0(116)</span><br><span class="line">[0.694s][info   ][gc,heap     ] GC(102) Survivor regions: 23-&gt;20(20)</span><br><span class="line">[0.694s][info   ][gc,heap     ] GC(102) Old regions: 455-&gt;495</span><br><span class="line">[0.694s][info   ][gc,heap     ] GC(102) Archive regions: 2-&gt;2</span><br><span class="line">[0.694s][info   ][gc,heap     ] GC(102) Humongous regions: 240-&gt;172</span><br><span class="line">[0.694s][info   ][gc,metaspace] GC(102) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.694s][info   ][gc          ] GC(102) Pause Young (Concurrent Start) (G1 Humongous Allocation) 828M-&gt;687M(1024M) 2.197ms</span><br><span class="line">[0.694s][info   ][gc,cpu      ] GC(102) User=0.01s Sys=0.01s Real=0.00s</span><br><span class="line">[0.694s][info   ][gc          ] GC(103) Concurrent Undo Cycle</span><br><span class="line">[0.694s][info   ][gc,marking  ] GC(103) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.694s][info   ][gc,marking  ] GC(103) Concurrent Cleanup for Next Mark 0.054ms</span><br><span class="line">[0.694s][info   ][gc          ] GC(103) Concurrent Undo Cycle 0.134ms</span><br><span class="line">[0.702s][info   ][gc,start    ] GC(104) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.702s][info   ][gc,task     ] GC(104) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.705s][info   ][gc,phases   ] GC(104)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.705s][info   ][gc,phases   ] GC(104)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.705s][info   ][gc,phases   ] GC(104)   Evacuate Collection Set: 1.9ms</span><br><span class="line">[0.705s][info   ][gc,phases   ] GC(104)   Post Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.705s][info   ][gc,phases   ] GC(104)   Other: 0.1ms</span><br><span class="line">[0.705s][info   ][gc,heap     ] GC(104) Eden regions: 107-&gt;0(99)</span><br><span class="line">[0.705s][info   ][gc,heap     ] GC(104) Survivor regions: 20-&gt;17(17)</span><br><span class="line">[0.705s][info   ][gc,heap     ] GC(104) Old regions: 495-&gt;535</span><br><span class="line">[0.705s][info   ][gc,heap     ] GC(104) Archive regions: 2-&gt;2</span><br><span class="line">[0.705s][info   ][gc,heap     ] GC(104) Humongous regions: 221-&gt;168</span><br><span class="line">[0.705s][info   ][gc,metaspace] GC(104) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.705s][info   ][gc          ] GC(104) Pause Young (Concurrent Start) (G1 Humongous Allocation) 842M-&gt;720M(1024M) 2.767ms</span><br><span class="line">[0.705s][info   ][gc,cpu      ] GC(104) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.705s][info   ][gc          ] GC(105) Concurrent Undo Cycle</span><br><span class="line">[0.705s][info   ][gc,marking  ] GC(105) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.705s][info   ][gc,marking  ] GC(105) Concurrent Cleanup for Next Mark 0.047ms</span><br><span class="line">[0.705s][info   ][gc          ] GC(105) Concurrent Undo Cycle 0.123ms</span><br><span class="line">[0.709s][info   ][gc,start    ] GC(106) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.709s][info   ][gc,task     ] GC(106) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.711s][info   ][gc,phases   ] GC(106)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.711s][info   ][gc,phases   ] GC(106)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.711s][info   ][gc,phases   ] GC(106)   Evacuate Collection Set: 0.9ms</span><br><span class="line">[0.711s][info   ][gc,phases   ] GC(106)   Post Evacuate Collection Set: 0.4ms</span><br><span class="line">[0.711s][info   ][gc,phases   ] GC(106)   Other: 0.1ms</span><br><span class="line">[0.711s][info   ][gc,heap     ] GC(106) Eden regions: 45-&gt;0(90)</span><br><span class="line">[0.711s][info   ][gc,heap     ] GC(106) Survivor regions: 17-&gt;15(15)</span><br><span class="line">[0.711s][info   ][gc,heap     ] GC(106) Old regions: 535-&gt;552</span><br><span class="line">[0.711s][info   ][gc,heap     ] GC(106) Archive regions: 2-&gt;2</span><br><span class="line">[0.711s][info   ][gc,heap     ] GC(106) Humongous regions: 202-&gt;178</span><br><span class="line">[0.711s][info   ][gc,metaspace] GC(106) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.711s][info   ][gc          ] GC(106) Pause Young (Concurrent Start) (G1 Humongous Allocation) 799M-&gt;745M(1024M) 1.878ms</span><br><span class="line">[0.711s][info   ][gc,cpu      ] GC(106) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">[0.711s][info   ][gc          ] GC(107) Concurrent Undo Cycle</span><br><span class="line">[0.711s][info   ][gc,marking  ] GC(107) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.711s][info   ][gc,marking  ] GC(107) Concurrent Cleanup for Next Mark 0.062ms</span><br><span class="line">[0.711s][info   ][gc          ] GC(107) Concurrent Undo Cycle 0.104ms</span><br><span class="line">[0.714s][info   ][gc,start    ] GC(108) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.714s][info   ][gc,task     ] GC(108) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.716s][info   ][gc,phases   ] GC(108)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.716s][info   ][gc,phases   ] GC(108)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.716s][info   ][gc,phases   ] GC(108)   Evacuate Collection Set: 1.0ms</span><br><span class="line">[0.716s][info   ][gc,phases   ] GC(108)   Post Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.716s][info   ][gc,phases   ] GC(108)   Other: 0.1ms</span><br><span class="line">[0.716s][info   ][gc,heap     ] GC(108) Eden regions: 39-&gt;0(85)</span><br><span class="line">[0.716s][info   ][gc,heap     ] GC(108) Survivor regions: 15-&gt;14(14)</span><br><span class="line">[0.716s][info   ][gc,heap     ] GC(108) Old regions: 552-&gt;569</span><br><span class="line">[0.716s][info   ][gc,heap     ] GC(108) Archive regions: 2-&gt;2</span><br><span class="line">[0.716s][info   ][gc,heap     ] GC(108) Humongous regions: 192-&gt;171</span><br><span class="line">[0.716s][info   ][gc,metaspace] GC(108) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.716s][info   ][gc          ] GC(108) Pause Young (Concurrent Start) (G1 Humongous Allocation) 798M-&gt;754M(1024M) 1.897ms</span><br><span class="line">[0.716s][info   ][gc,cpu      ] GC(108) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.716s][info   ][gc          ] GC(109) Concurrent Undo Cycle</span><br><span class="line">[0.716s][info   ][gc,marking  ] GC(109) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.716s][info   ][gc,marking  ] GC(109) Concurrent Cleanup for Next Mark 0.080ms</span><br><span class="line">[0.716s][info   ][gc          ] GC(109) Concurrent Undo Cycle 0.328ms</span><br><span class="line">[0.718s][info   ][gc,start    ] GC(110) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.718s][info   ][gc,task     ] GC(110) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.719s][info   ][gc,phases   ] GC(110)   Pre Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.719s][info   ][gc,phases   ] GC(110)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.719s][info   ][gc,phases   ] GC(110)   Evacuate Collection Set: 0.6ms</span><br><span class="line">[0.719s][info   ][gc,phases   ] GC(110)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.719s][info   ][gc,phases   ] GC(110)   Other: 0.1ms</span><br><span class="line">[0.719s][info   ][gc,heap     ] GC(110) Eden regions: 20-&gt;0(81)</span><br><span class="line">[0.719s][info   ][gc,heap     ] GC(110) Survivor regions: 14-&gt;8(13)</span><br><span class="line">[0.719s][info   ][gc,heap     ] GC(110) Old regions: 569-&gt;583</span><br><span class="line">[0.719s][info   ][gc,heap     ] GC(110) Archive regions: 2-&gt;2</span><br><span class="line">[0.719s][info   ][gc,heap     ] GC(110) Humongous regions: 182-&gt;173</span><br><span class="line">[0.719s][info   ][gc,metaspace] GC(110) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.719s][info   ][gc          ] GC(110) Pause Young (Concurrent Start) (G1 Humongous Allocation) 785M-&gt;764M(1024M) 1.404ms</span><br><span class="line">[0.719s][info   ][gc,cpu      ] GC(110) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.719s][info   ][gc          ] GC(111) Concurrent Mark Cycle</span><br><span class="line">[0.719s][info   ][gc,marking  ] GC(111) Concurrent Clear Claimed Marks</span><br><span class="line">[0.719s][info   ][gc,marking  ] GC(111) Concurrent Clear Claimed Marks 0.013ms</span><br><span class="line">[0.719s][info   ][gc,marking  ] GC(111) Concurrent Scan Root Regions</span><br><span class="line">[0.719s][info   ][gc,marking  ] GC(111) Concurrent Scan Root Regions 0.061ms</span><br><span class="line">[0.719s][info   ][gc,marking  ] GC(111) Concurrent Mark</span><br><span class="line">[0.720s][info   ][gc,marking  ] GC(111) Concurrent Mark From Roots</span><br><span class="line">[0.720s][info   ][gc,task     ] GC(111) Using 2 workers of 2 for marking</span><br><span class="line">[0.721s][info   ][gc,marking  ] GC(111) Concurrent Mark From Roots 1.663ms</span><br><span class="line">[0.721s][info   ][gc,marking  ] GC(111) Concurrent Preclean</span><br><span class="line">[0.721s][info   ][gc,marking  ] GC(111) Concurrent Preclean 0.010ms</span><br><span class="line">[0.721s][info   ][gc,start    ] GC(111) Pause Remark</span><br><span class="line">[0.722s][info   ][gc          ] GC(111) Pause Remark 796M-&gt;733M(1024M) 0.479ms</span><br><span class="line">[0.722s][info   ][gc,cpu      ] GC(111) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.722s][info   ][gc,marking  ] GC(111) Concurrent Mark 2.338ms</span><br><span class="line">[0.722s][info   ][gc,marking  ] GC(111) Concurrent Rebuild Remembered Sets</span><br><span class="line">[0.723s][info   ][gc,marking  ] GC(111) Concurrent Rebuild Remembered Sets 1.199ms</span><br><span class="line">[0.723s][info   ][gc,start    ] GC(111) Pause Cleanup</span><br><span class="line">[0.724s][info   ][gc          ] GC(111) Pause Cleanup 768M-&gt;768M(1024M) 0.359ms</span><br><span class="line">[0.724s][info   ][gc,cpu      ] GC(111) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.724s][info   ][gc,marking  ] GC(111) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.724s][info   ][gc,marking  ] GC(111) Concurrent Cleanup for Next Mark 0.760ms</span><br><span class="line">[0.724s][info   ][gc          ] GC(111) Concurrent Mark Cycle 5.188ms</span><br><span class="line">[0.728s][info   ][gc,start    ] GC(112) Pause Young (Prepare Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.728s][info   ][gc,task     ] GC(112) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.730s][info   ][gc,phases   ] GC(112)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.730s][info   ][gc,phases   ] GC(112)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.730s][info   ][gc,phases   ] GC(112)   Evacuate Collection Set: 1.2ms</span><br><span class="line">[0.730s][info   ][gc,phases   ] GC(112)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.730s][info   ][gc,phases   ] GC(112)   Other: 0.0ms</span><br><span class="line">[0.730s][info   ][gc,heap     ] GC(112) Eden regions: 81-&gt;0(39)</span><br><span class="line">[0.730s][info   ][gc,heap     ] GC(112) Survivor regions: 8-&gt;12(12)</span><br><span class="line">[0.730s][info   ][gc,heap     ] GC(112) Old regions: 520-&gt;550</span><br><span class="line">[0.730s][info   ][gc,heap     ] GC(112) Archive regions: 2-&gt;2</span><br><span class="line">[0.730s][info   ][gc,heap     ] GC(112) Humongous regions: 230-&gt;171</span><br><span class="line">[0.730s][info   ][gc,metaspace] GC(112) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.730s][info   ][gc          ] GC(112) Pause Young (Prepare Mixed) (G1 Evacuation Pause) 839M-&gt;733M(1024M) 2.000ms</span><br><span class="line">[0.730s][info   ][gc,cpu      ] GC(112) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.733s][info   ][gc,start    ] GC(113) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.733s][info   ][gc,task     ] GC(113) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.734s][info   ][gc,phases   ] GC(113)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.735s][info   ][gc,phases   ] GC(113)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.735s][info   ][gc,phases   ] GC(113)   Evacuate Collection Set: 1.1ms</span><br><span class="line">[0.735s][info   ][gc,phases   ] GC(113)   Post Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.735s][info   ][gc,phases   ] GC(113)   Other: 0.0ms</span><br><span class="line">[0.735s][info   ][gc,heap     ] GC(113) Eden regions: 39-&gt;0(44)</span><br><span class="line">[0.735s][info   ][gc,heap     ] GC(113) Survivor regions: 12-&gt;7(7)</span><br><span class="line">[0.735s][info   ][gc,heap     ] GC(113) Old regions: 550-&gt;476</span><br><span class="line">[0.735s][info   ][gc,heap     ] GC(113) Archive regions: 2-&gt;2</span><br><span class="line">[0.735s][info   ][gc,heap     ] GC(113) Humongous regions: 191-&gt;171</span><br><span class="line">[0.735s][info   ][gc,metaspace] GC(113) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.735s][info   ][gc          ] GC(113) Pause Young (Mixed) (G1 Evacuation Pause) 792M-&gt;654M(1024M) 1.961ms</span><br><span class="line">[0.735s][info   ][gc,cpu      ] GC(113) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.738s][info   ][gc,start    ] GC(114) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.738s][info   ][gc,task     ] GC(114) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.740s][info   ][gc,phases   ] GC(114)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.740s][info   ][gc,phases   ] GC(114)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.740s][info   ][gc,phases   ] GC(114)   Evacuate Collection Set: 1.1ms</span><br><span class="line">[0.740s][info   ][gc,phases   ] GC(114)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.740s][info   ][gc,phases   ] GC(114)   Other: 0.0ms</span><br><span class="line">[0.740s][info   ][gc,heap     ] GC(114) Eden regions: 44-&gt;0(44)</span><br><span class="line">[0.740s][info   ][gc,heap     ] GC(114) Survivor regions: 7-&gt;7(7)</span><br><span class="line">[0.740s][info   ][gc,heap     ] GC(114) Old regions: 476-&gt;408</span><br><span class="line">[0.740s][info   ][gc,heap     ] GC(114) Archive regions: 2-&gt;2</span><br><span class="line">[0.740s][info   ][gc,heap     ] GC(114) Humongous regions: 202-&gt;170</span><br><span class="line">[0.740s][info   ][gc,metaspace] GC(114) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.740s][info   ][gc          ] GC(114) Pause Young (Mixed) (G1 Evacuation Pause) 729M-&gt;585M(1024M) 1.744ms</span><br><span class="line">[0.740s][info   ][gc,cpu      ] GC(114) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.743s][info   ][gc,start    ] GC(115) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.743s][info   ][gc,task     ] GC(115) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.745s][info   ][gc,phases   ] GC(115)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.745s][info   ][gc,phases   ] GC(115)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.745s][info   ][gc,phases   ] GC(115)   Evacuate Collection Set: 1.5ms</span><br><span class="line">[0.745s][info   ][gc,phases   ] GC(115)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.745s][info   ][gc,phases   ] GC(115)   Other: 0.0ms</span><br><span class="line">[0.745s][info   ][gc,heap     ] GC(115) Eden regions: 44-&gt;0(44)</span><br><span class="line">[0.745s][info   ][gc,heap     ] GC(115) Survivor regions: 7-&gt;7(7)</span><br><span class="line">[0.745s][info   ][gc,heap     ] GC(115) Old regions: 408-&gt;354</span><br><span class="line">[0.745s][info   ][gc,heap     ] GC(115) Archive regions: 2-&gt;2</span><br><span class="line">[0.745s][info   ][gc,heap     ] GC(115) Humongous regions: 191-&gt;164</span><br><span class="line">[0.745s][info   ][gc,metaspace] GC(115) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.745s][info   ][gc          ] GC(115) Pause Young (Mixed) (G1 Evacuation Pause) 650M-&gt;525M(1024M) 2.118ms</span><br><span class="line">[0.745s][info   ][gc,cpu      ] GC(115) User=0.00s Sys=0.01s Real=0.00s</span><br><span class="line">[0.748s][info   ][gc,start    ] GC(116) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.749s][info   ][gc,task     ] GC(116) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.750s][info   ][gc,phases   ] GC(116)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.750s][info   ][gc,phases   ] GC(116)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.750s][info   ][gc,phases   ] GC(116)   Evacuate Collection Set: 0.6ms</span><br><span class="line">[0.750s][info   ][gc,phases   ] GC(116)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.750s][info   ][gc,phases   ] GC(116)   Other: 0.0ms</span><br><span class="line">[0.750s][info   ][gc,heap     ] GC(116) Eden regions: 44-&gt;0(188)</span><br><span class="line">[0.750s][info   ][gc,heap     ] GC(116) Survivor regions: 7-&gt;7(7)</span><br><span class="line">[0.750s][info   ][gc,heap     ] GC(116) Old regions: 354-&gt;367</span><br><span class="line">[0.750s][info   ][gc,heap     ] GC(116) Archive regions: 2-&gt;2</span><br><span class="line">[0.750s][info   ][gc,heap     ] GC(116) Humongous regions: 194-&gt;175</span><br><span class="line">[0.750s][info   ][gc,metaspace] GC(116) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.750s][info   ][gc          ] GC(116) Pause Young (Mixed) (G1 Evacuation Pause) 599M-&gt;549M(1024M) 1.240ms</span><br><span class="line">[0.750s][info   ][gc,cpu      ] GC(116) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.767s][info   ][gc,start    ] GC(117) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.767s][info   ][gc,task     ] GC(117) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.769s][info   ][gc,phases   ] GC(117)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.769s][info   ][gc,phases   ] GC(117)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.769s][info   ][gc,phases   ] GC(117)   Evacuate Collection Set: 1.9ms</span><br><span class="line">[0.769s][info   ][gc,phases   ] GC(117)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.769s][info   ][gc,phases   ] GC(117)   Other: 0.1ms</span><br><span class="line">[0.769s][info   ][gc,heap     ] GC(117) Eden regions: 188-&gt;0(157)</span><br><span class="line">[0.769s][info   ][gc,heap     ] GC(117) Survivor regions: 7-&gt;25(25)</span><br><span class="line">[0.769s][info   ][gc,heap     ] GC(117) Old regions: 367-&gt;417</span><br><span class="line">[0.769s][info   ][gc,heap     ] GC(117) Archive regions: 2-&gt;2</span><br><span class="line">[0.769s][info   ][gc,heap     ] GC(117) Humongous regions: 280-&gt;170</span><br><span class="line">[0.769s][info   ][gc,metaspace] GC(117) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.770s][info   ][gc          ] GC(117) Pause Young (Normal) (G1 Evacuation Pause) 842M-&gt;612M(1024M) 2.656ms</span><br><span class="line">[0.770s][info   ][gc,cpu      ] GC(117) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.780s][info   ][gc,start    ] GC(118) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.780s][info   ][gc,task     ] GC(118) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.782s][info   ][gc,phases   ] GC(118)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.782s][info   ][gc,phases   ] GC(118)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.782s][info   ][gc,phases   ] GC(118)   Evacuate Collection Set: 1.4ms</span><br><span class="line">[0.782s][info   ][gc,phases   ] GC(118)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.782s][info   ][gc,phases   ] GC(118)   Other: 0.1ms</span><br><span class="line">[0.782s][info   ][gc,heap     ] GC(118) Eden regions: 127-&gt;0(139)</span><br><span class="line">[0.782s][info   ][gc,heap     ] GC(118) Survivor regions: 25-&gt;23(23)</span><br><span class="line">[0.782s][info   ][gc,heap     ] GC(118) Old regions: 417-&gt;458</span><br><span class="line">[0.782s][info   ][gc,heap     ] GC(118) Archive regions: 2-&gt;2</span><br><span class="line">[0.782s][info   ][gc,heap     ] GC(118) Humongous regions: 252-&gt;168</span><br><span class="line">[0.782s][info   ][gc,metaspace] GC(118) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.782s][info   ][gc          ] GC(118) Pause Young (Concurrent Start) (G1 Humongous Allocation) 821M-&gt;649M(1024M) 1.987ms</span><br><span class="line">[0.782s][info   ][gc,cpu      ] GC(118) User=0.01s Sys=0.01s Real=0.01s</span><br><span class="line">[0.782s][info   ][gc          ] GC(119) Concurrent Undo Cycle</span><br><span class="line">[0.782s][info   ][gc,marking  ] GC(119) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.782s][info   ][gc,marking  ] GC(119) Concurrent Cleanup for Next Mark 0.032ms</span><br><span class="line">[0.782s][info   ][gc          ] GC(119) Concurrent Undo Cycle 0.085ms</span><br><span class="line">[0.790s][info   ][gc,start    ] GC(120) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.790s][info   ][gc,task     ] GC(120) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.792s][info   ][gc,phases   ] GC(120)   Pre Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.792s][info   ][gc,phases   ] GC(120)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.792s][info   ][gc,phases   ] GC(120)   Evacuate Collection Set: 1.1ms</span><br><span class="line">[0.792s][info   ][gc,phases   ] GC(120)   Post Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.792s][info   ][gc,phases   ] GC(120)   Other: 0.1ms</span><br><span class="line">[0.792s][info   ][gc,heap     ] GC(120) Eden regions: 91-&gt;0(125)</span><br><span class="line">[0.792s][info   ][gc,heap     ] GC(120) Survivor regions: 23-&gt;21(21)</span><br><span class="line">[0.792s][info   ][gc,heap     ] GC(120) Old regions: 458-&gt;489</span><br><span class="line">[0.792s][info   ][gc,heap     ] GC(120) Archive regions: 2-&gt;2</span><br><span class="line">[0.792s][info   ][gc,heap     ] GC(120) Humongous regions: 232-&gt;172</span><br><span class="line">[0.792s][info   ][gc,metaspace] GC(120) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.792s][info   ][gc          ] GC(120) Pause Young (Concurrent Start) (G1 Humongous Allocation) 803M-&gt;682M(1024M) 1.953ms</span><br><span class="line">[0.792s][info   ][gc,cpu      ] GC(120) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">[0.792s][info   ][gc          ] GC(121) Concurrent Undo Cycle</span><br><span class="line">[0.792s][info   ][gc,marking  ] GC(121) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.792s][info   ][gc,marking  ] GC(121) Concurrent Cleanup for Next Mark 0.040ms</span><br><span class="line">[0.792s][info   ][gc          ] GC(121) Concurrent Undo Cycle 0.101ms</span><br><span class="line">[0.798s][info   ][gc,start    ] GC(122) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.798s][info   ][gc,task     ] GC(122) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.799s][info   ][gc,phases   ] GC(122)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.799s][info   ][gc,phases   ] GC(122)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.799s][info   ][gc,phases   ] GC(122)   Evacuate Collection Set: 1.0ms</span><br><span class="line">[0.799s][info   ][gc,phases   ] GC(122)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.799s][info   ][gc,phases   ] GC(122)   Other: 0.1ms</span><br><span class="line">[0.799s][info   ][gc,heap     ] GC(122) Eden regions: 72-&gt;0(105)</span><br><span class="line">[0.799s][info   ][gc,heap     ] GC(122) Survivor regions: 21-&gt;19(19)</span><br><span class="line">[0.799s][info   ][gc,heap     ] GC(122) Old regions: 489-&gt;522</span><br><span class="line">[0.799s][info   ][gc,heap     ] GC(122) Archive regions: 2-&gt;2</span><br><span class="line">[0.799s][info   ][gc,heap     ] GC(122) Humongous regions: 217-&gt;169</span><br><span class="line">[0.799s][info   ][gc,metaspace] GC(122) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.799s][info   ][gc          ] GC(122) Pause Young (Concurrent Start) (G1 Humongous Allocation) 799M-&gt;710M(1024M) 1.549ms</span><br><span class="line">[0.799s][info   ][gc,cpu      ] GC(122) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.799s][info   ][gc          ] GC(123) Concurrent Undo Cycle</span><br><span class="line">[0.799s][info   ][gc,marking  ] GC(123) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.799s][info   ][gc,marking  ] GC(123) Concurrent Cleanup for Next Mark 0.085ms</span><br><span class="line">[0.799s][info   ][gc          ] GC(123) Concurrent Undo Cycle 0.121ms</span><br><span class="line">[0.804s][info   ][gc,start    ] GC(124) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.804s][info   ][gc,task     ] GC(124) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.805s][info   ][gc,phases   ] GC(124)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.805s][info   ][gc,phases   ] GC(124)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.805s][info   ][gc,phases   ] GC(124)   Evacuate Collection Set: 0.8ms</span><br><span class="line">[0.805s][info   ][gc,phases   ] GC(124)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.805s][info   ][gc,phases   ] GC(124)   Other: 0.1ms</span><br><span class="line">[0.805s][info   ][gc,heap     ] GC(124) Eden regions: 57-&gt;0(96)</span><br><span class="line">[0.805s][info   ][gc,heap     ] GC(124) Survivor regions: 19-&gt;16(16)</span><br><span class="line">[0.805s][info   ][gc,heap     ] GC(124) Old regions: 522-&gt;545</span><br><span class="line">[0.805s][info   ][gc,heap     ] GC(124) Archive regions: 2-&gt;2</span><br><span class="line">[0.805s][info   ][gc,heap     ] GC(124) Humongous regions: 206-&gt;173</span><br><span class="line">[0.805s][info   ][gc,metaspace] GC(124) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.805s][info   ][gc          ] GC(124) Pause Young (Concurrent Start) (G1 Humongous Allocation) 804M-&gt;734M(1024M) 1.445ms</span><br><span class="line">[0.805s][info   ][gc,cpu      ] GC(124) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.805s][info   ][gc          ] GC(125) Concurrent Undo Cycle</span><br><span class="line">[0.805s][info   ][gc,marking  ] GC(125) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.805s][info   ][gc,marking  ] GC(125) Concurrent Cleanup for Next Mark 0.053ms</span><br><span class="line">[0.805s][info   ][gc          ] GC(125) Concurrent Undo Cycle 0.139ms</span><br><span class="line">[0.809s][info   ][gc,start    ] GC(126) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.809s][info   ][gc,task     ] GC(126) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.810s][info   ][gc,phases   ] GC(126)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.810s][info   ][gc,phases   ] GC(126)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.810s][info   ][gc,phases   ] GC(126)   Evacuate Collection Set: 0.8ms</span><br><span class="line">[0.810s][info   ][gc,phases   ] GC(126)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.810s][info   ][gc,phases   ] GC(126)   Other: 0.1ms</span><br><span class="line">[0.810s][info   ][gc,heap     ] GC(126) Eden regions: 55-&gt;0(84)</span><br><span class="line">[0.810s][info   ][gc,heap     ] GC(126) Survivor regions: 16-&gt;14(14)</span><br><span class="line">[0.810s][info   ][gc,heap     ] GC(126) Old regions: 545-&gt;569</span><br><span class="line">[0.810s][info   ][gc,heap     ] GC(126) Archive regions: 2-&gt;2</span><br><span class="line">[0.810s][info   ][gc,heap     ] GC(126) Humongous regions: 195-&gt;166</span><br><span class="line">[0.810s][info   ][gc,metaspace] GC(126) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.810s][info   ][gc          ] GC(126) Pause Young (Concurrent Start) (G1 Humongous Allocation) 811M-&gt;749M(1024M) 1.363ms</span><br><span class="line">[0.810s][info   ][gc,cpu      ] GC(126) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.810s][info   ][gc          ] GC(127) Concurrent Undo Cycle</span><br><span class="line">[0.810s][info   ][gc,marking  ] GC(127) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.811s][info   ][gc,marking  ] GC(127) Concurrent Cleanup for Next Mark 0.049ms</span><br><span class="line">[0.811s][info   ][gc          ] GC(127) Concurrent Undo Cycle 0.098ms</span><br><span class="line">[0.813s][info   ][gc,start    ] GC(128) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.813s][info   ][gc,task     ] GC(128) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.814s][info   ][gc,phases   ] GC(128)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.814s][info   ][gc,phases   ] GC(128)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.814s][info   ][gc,phases   ] GC(128)   Evacuate Collection Set: 0.6ms</span><br><span class="line">[0.814s][info   ][gc,phases   ] GC(128)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.814s][info   ][gc,phases   ] GC(128)   Other: 0.1ms</span><br><span class="line">[0.814s][info   ][gc,heap     ] GC(128) Eden regions: 29-&gt;0(75)</span><br><span class="line">[0.814s][info   ][gc,heap     ] GC(128) Survivor regions: 14-&gt;13(13)</span><br><span class="line">[0.814s][info   ][gc,heap     ] GC(128) Old regions: 569-&gt;583</span><br><span class="line">[0.814s][info   ][gc,heap     ] GC(128) Archive regions: 2-&gt;2</span><br><span class="line">[0.814s][info   ][gc,heap     ] GC(128) Humongous regions: 185-&gt;165</span><br><span class="line">[0.814s][info   ][gc,metaspace] GC(128) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.814s][info   ][gc          ] GC(128) Pause Young (Concurrent Start) (G1 Humongous Allocation) 796M-&gt;761M(1024M) 1.205ms</span><br><span class="line">[0.814s][info   ][gc,cpu      ] GC(128) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.814s][info   ][gc          ] GC(129) Concurrent Undo Cycle</span><br><span class="line">[0.814s][info   ][gc,marking  ] GC(129) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.814s][info   ][gc,marking  ] GC(129) Concurrent Cleanup for Next Mark 0.046ms</span><br><span class="line">[0.814s][info   ][gc          ] GC(129) Concurrent Undo Cycle 0.078ms</span><br><span class="line">[0.817s][info   ][gc,start    ] GC(130) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.817s][info   ][gc,task     ] GC(130) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.818s][info   ][gc,phases   ] GC(130)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.818s][info   ][gc,phases   ] GC(130)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.818s][info   ][gc,phases   ] GC(130)   Evacuate Collection Set: 0.6ms</span><br><span class="line">[0.818s][info   ][gc,phases   ] GC(130)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.818s][info   ][gc,phases   ] GC(130)   Other: 0.1ms</span><br><span class="line">[0.818s][info   ][gc,heap     ] GC(130) Eden regions: 32-&gt;0(74)</span><br><span class="line">[0.818s][info   ][gc,heap     ] GC(130) Survivor regions: 13-&gt;11(11)</span><br><span class="line">[0.818s][info   ][gc,heap     ] GC(130) Old regions: 583-&gt;596</span><br><span class="line">[0.818s][info   ][gc,heap     ] GC(130) Archive regions: 2-&gt;2</span><br><span class="line">[0.818s][info   ][gc,heap     ] GC(130) Humongous regions: 182-&gt;163</span><br><span class="line">[0.818s][info   ][gc,metaspace] GC(130) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.818s][info   ][gc          ] GC(130) Pause Young (Concurrent Start) (G1 Humongous Allocation) 809M-&gt;770M(1024M) 1.156ms</span><br><span class="line">[0.818s][info   ][gc,cpu      ] GC(130) User=0.00s Sys=0.01s Real=0.00s</span><br><span class="line">[0.818s][info   ][gc          ] GC(131) Concurrent Undo Cycle</span><br><span class="line">[0.818s][info   ][gc,marking  ] GC(131) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.818s][info   ][gc,marking  ] GC(131) Concurrent Cleanup for Next Mark 0.047ms</span><br><span class="line">[0.818s][info   ][gc          ] GC(131) Concurrent Undo Cycle 0.095ms</span><br><span class="line">[0.819s][info   ][gc,start    ] GC(132) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.819s][info   ][gc,task     ] GC(132) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.820s][info   ][gc,phases   ] GC(132)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.820s][info   ][gc,phases   ] GC(132)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.820s][info   ][gc,phases   ] GC(132)   Evacuate Collection Set: 0.5ms</span><br><span class="line">[0.820s][info   ][gc,phases   ] GC(132)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.820s][info   ][gc,phases   ] GC(132)   Other: 0.0ms</span><br><span class="line">[0.820s][info   ][gc,heap     ] GC(132) Eden regions: 13-&gt;0(71)</span><br><span class="line">[0.820s][info   ][gc,heap     ] GC(132) Survivor regions: 11-&gt;6(11)</span><br><span class="line">[0.820s][info   ][gc,heap     ] GC(132) Old regions: 596-&gt;606</span><br><span class="line">[0.820s][info   ][gc,heap     ] GC(132) Archive regions: 2-&gt;2</span><br><span class="line">[0.820s][info   ][gc,heap     ] GC(132) Humongous regions: 173-&gt;171</span><br><span class="line">[0.820s][info   ][gc,metaspace] GC(132) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.820s][info   ][gc          ] GC(132) Pause Young (Concurrent Start) (G1 Humongous Allocation) 793M-&gt;782M(1024M) 0.960ms</span><br><span class="line">[0.820s][info   ][gc,cpu      ] GC(132) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.820s][info   ][gc          ] GC(133) Concurrent Mark Cycle</span><br><span class="line">[0.820s][info   ][gc,marking  ] GC(133) Concurrent Clear Claimed Marks</span><br><span class="line">[0.820s][info   ][gc,marking  ] GC(133) Concurrent Clear Claimed Marks 0.008ms</span><br><span class="line">[0.820s][info   ][gc,marking  ] GC(133) Concurrent Scan Root Regions</span><br><span class="line">[0.820s][info   ][gc,marking  ] GC(133) Concurrent Scan Root Regions 0.049ms</span><br><span class="line">[0.820s][info   ][gc,marking  ] GC(133) Concurrent Mark</span><br><span class="line">[0.820s][info   ][gc,marking  ] GC(133) Concurrent Mark From Roots</span><br><span class="line">[0.820s][info   ][gc,task     ] GC(133) Using 2 workers of 2 for marking</span><br><span class="line">[0.821s][info   ][gc,marking  ] GC(133) Concurrent Mark From Roots 0.993ms</span><br><span class="line">[0.821s][info   ][gc,marking  ] GC(133) Concurrent Preclean</span><br><span class="line">[0.821s][info   ][gc,marking  ] GC(133) Concurrent Preclean 0.009ms</span><br><span class="line">[0.821s][info   ][gc,start    ] GC(133) Pause Remark</span><br><span class="line">[0.822s][info   ][gc          ] GC(133) Pause Remark 802M-&gt;725M(1024M) 0.449ms</span><br><span class="line">[0.822s][info   ][gc,cpu      ] GC(133) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.822s][info   ][gc,marking  ] GC(133) Concurrent Mark 1.735ms</span><br><span class="line">[0.822s][info   ][gc,marking  ] GC(133) Concurrent Rebuild Remembered Sets</span><br><span class="line">[0.823s][info   ][gc,marking  ] GC(133) Concurrent Rebuild Remembered Sets 1.137ms</span><br><span class="line">[0.823s][info   ][gc,start    ] GC(133) Pause Cleanup</span><br><span class="line">[0.823s][info   ][gc          ] GC(133) Pause Cleanup 752M-&gt;752M(1024M) 0.279ms</span><br><span class="line">[0.823s][info   ][gc,cpu      ] GC(133) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.823s][info   ][gc,marking  ] GC(133) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.824s][info   ][gc,marking  ] GC(133) Concurrent Cleanup for Next Mark 0.742ms</span><br><span class="line">[0.824s][info   ][gc          ] GC(133) Concurrent Mark Cycle 4.280ms</span><br><span class="line">[0.826s][info   ][gc,start    ] GC(134) Pause Young (Prepare Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.826s][info   ][gc,task     ] GC(134) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.828s][info   ][gc,phases   ] GC(134)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.828s][info   ][gc,phases   ] GC(134)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.828s][info   ][gc,phases   ] GC(134)   Evacuate Collection Set: 1.1ms</span><br><span class="line">[0.828s][info   ][gc,phases   ] GC(134)   Post Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.828s][info   ][gc,phases   ] GC(134)   Other: 0.0ms</span><br><span class="line">[0.828s][info   ][gc,heap     ] GC(134) Eden regions: 71-&gt;0(41)</span><br><span class="line">[0.828s][info   ][gc,heap     ] GC(134) Survivor regions: 6-&gt;10(10)</span><br><span class="line">[0.828s][info   ][gc,heap     ] GC(134) Old regions: 529-&gt;552</span><br><span class="line">[0.828s][info   ][gc,heap     ] GC(134) Archive regions: 2-&gt;2</span><br><span class="line">[0.828s][info   ][gc,heap     ] GC(134) Humongous regions: 218-&gt;167</span><br><span class="line">[0.828s][info   ][gc,metaspace] GC(134) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.828s][info   ][gc          ] GC(134) Pause Young (Prepare Mixed) (G1 Evacuation Pause) 823M-&gt;729M(1024M) 1.812ms</span><br><span class="line">[0.828s][info   ][gc,cpu      ] GC(134) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.832s][info   ][gc,start    ] GC(135) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.832s][info   ][gc,task     ] GC(135) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.833s][info   ][gc,phases   ] GC(135)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.833s][info   ][gc,phases   ] GC(135)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.833s][info   ][gc,phases   ] GC(135)   Evacuate Collection Set: 0.8ms</span><br><span class="line">[0.833s][info   ][gc,phases   ] GC(135)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.833s][info   ][gc,phases   ] GC(135)   Other: 0.0ms</span><br><span class="line">[0.833s][info   ][gc,heap     ] GC(135) Eden regions: 41-&gt;0(44)</span><br><span class="line">[0.833s][info   ][gc,heap     ] GC(135) Survivor regions: 10-&gt;7(7)</span><br><span class="line">[0.833s][info   ][gc,heap     ] GC(135) Old regions: 552-&gt;474</span><br><span class="line">[0.833s][info   ][gc,heap     ] GC(135) Archive regions: 2-&gt;2</span><br><span class="line">[0.833s][info   ][gc,heap     ] GC(135) Humongous regions: 194-&gt;168</span><br><span class="line">[0.833s][info   ][gc,metaspace] GC(135) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.833s][info   ][gc          ] GC(135) Pause Young (Mixed) (G1 Evacuation Pause) 797M-&gt;649M(1024M) 1.592ms</span><br><span class="line">[0.833s][info   ][gc,cpu      ] GC(135) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.836s][info   ][gc,start    ] GC(136) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.837s][info   ][gc,task     ] GC(136) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.838s][info   ][gc,phases   ] GC(136)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.838s][info   ][gc,phases   ] GC(136)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.838s][info   ][gc,phases   ] GC(136)   Evacuate Collection Set: 1.1ms</span><br><span class="line">[0.838s][info   ][gc,phases   ] GC(136)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.838s][info   ][gc,phases   ] GC(136)   Other: 0.1ms</span><br><span class="line">[0.838s][info   ][gc,heap     ] GC(136) Eden regions: 44-&gt;0(44)</span><br><span class="line">[0.838s][info   ][gc,heap     ] GC(136) Survivor regions: 7-&gt;7(7)</span><br><span class="line">[0.838s][info   ][gc,heap     ] GC(136) Old regions: 474-&gt;404</span><br><span class="line">[0.838s][info   ][gc,heap     ] GC(136) Archive regions: 2-&gt;2</span><br><span class="line">[0.838s][info   ][gc,heap     ] GC(136) Humongous regions: 190-&gt;166</span><br><span class="line">[0.838s][info   ][gc,metaspace] GC(136) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.838s][info   ][gc          ] GC(136) Pause Young (Mixed) (G1 Evacuation Pause) 715M-&gt;577M(1024M) 1.787ms</span><br><span class="line">[0.838s][info   ][gc,cpu      ] GC(136) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.841s][info   ][gc,start    ] GC(137) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.841s][info   ][gc,task     ] GC(137) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.843s][info   ][gc,phases   ] GC(137)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.843s][info   ][gc,phases   ] GC(137)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.843s][info   ][gc,phases   ] GC(137)   Evacuate Collection Set: 1.1ms</span><br><span class="line">[0.843s][info   ][gc,phases   ] GC(137)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.843s][info   ][gc,phases   ] GC(137)   Other: 0.0ms</span><br><span class="line">[0.843s][info   ][gc,heap     ] GC(137) Eden regions: 44-&gt;0(44)</span><br><span class="line">[0.843s][info   ][gc,heap     ] GC(137) Survivor regions: 7-&gt;7(7)</span><br><span class="line">[0.843s][info   ][gc,heap     ] GC(137) Old regions: 404-&gt;347</span><br><span class="line">[0.843s][info   ][gc,heap     ] GC(137) Archive regions: 2-&gt;2</span><br><span class="line">[0.843s][info   ][gc,heap     ] GC(137) Humongous regions: 186-&gt;167</span><br><span class="line">[0.843s][info   ][gc,metaspace] GC(137) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.843s][info   ][gc          ] GC(137) Pause Young (Mixed) (G1 Evacuation Pause) 641M-&gt;521M(1024M) 1.755ms</span><br><span class="line">[0.843s][info   ][gc,cpu      ] GC(137) User=0.00s Sys=0.01s Real=0.00s</span><br><span class="line">[0.847s][info   ][gc,start    ] GC(138) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.847s][info   ][gc,task     ] GC(138) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.848s][info   ][gc,phases   ] GC(138)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.848s][info   ][gc,phases   ] GC(138)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.848s][info   ][gc,phases   ] GC(138)   Evacuate Collection Set: 0.7ms</span><br><span class="line">[0.848s][info   ][gc,phases   ] GC(138)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.848s][info   ][gc,phases   ] GC(138)   Other: 0.0ms</span><br><span class="line">[0.848s][info   ][gc,heap     ] GC(138) Eden regions: 44-&gt;0(176)</span><br><span class="line">[0.848s][info   ][gc,heap     ] GC(138) Survivor regions: 7-&gt;7(7)</span><br><span class="line">[0.848s][info   ][gc,heap     ] GC(138) Old regions: 347-&gt;360</span><br><span class="line">[0.848s][info   ][gc,heap     ] GC(138) Archive regions: 2-&gt;2</span><br><span class="line">[0.848s][info   ][gc,heap     ] GC(138) Humongous regions: 200-&gt;166</span><br><span class="line">[0.848s][info   ][gc,metaspace] GC(138) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.848s][info   ][gc          ] GC(138) Pause Young (Mixed) (G1 Evacuation Pause) 598M-&gt;533M(1024M) 1.189ms</span><br><span class="line">[0.848s][info   ][gc,cpu      ] GC(138) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.862s][info   ][gc,start    ] GC(139) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.862s][info   ][gc,task     ] GC(139) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.864s][info   ][gc,phases   ] GC(139)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.864s][info   ][gc,phases   ] GC(139)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.864s][info   ][gc,phases   ] GC(139)   Evacuate Collection Set: 1.6ms</span><br><span class="line">[0.864s][info   ][gc,phases   ] GC(139)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.864s][info   ][gc,phases   ] GC(139)   Other: 0.0ms</span><br><span class="line">[0.864s][info   ][gc,heap     ] GC(139) Eden regions: 176-&gt;0(145)</span><br><span class="line">[0.864s][info   ][gc,heap     ] GC(139) Survivor regions: 7-&gt;23(23)</span><br><span class="line">[0.864s][info   ][gc,heap     ] GC(139) Old regions: 360-&gt;407</span><br><span class="line">[0.864s][info   ][gc,heap     ] GC(139) Archive regions: 2-&gt;2</span><br><span class="line">[0.864s][info   ][gc,heap     ] GC(139) Humongous regions: 265-&gt;182</span><br><span class="line">[0.864s][info   ][gc,metaspace] GC(139) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.864s][info   ][gc          ] GC(139) Pause Young (Normal) (G1 Evacuation Pause) 808M-&gt;612M(1024M) 2.272ms</span><br><span class="line">[0.864s][info   ][gc,cpu      ] GC(139) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.873s][info   ][gc,start    ] GC(140) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.873s][info   ][gc,task     ] GC(140) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.875s][info   ][gc,phases   ] GC(140)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.875s][info   ][gc,phases   ] GC(140)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.875s][info   ][gc,phases   ] GC(140)   Evacuate Collection Set: 1.1ms</span><br><span class="line">[0.875s][info   ][gc,phases   ] GC(140)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.875s][info   ][gc,phases   ] GC(140)   Other: 0.1ms</span><br><span class="line">[0.875s][info   ][gc,heap     ] GC(140) Eden regions: 119-&gt;0(123)</span><br><span class="line">[0.875s][info   ][gc,heap     ] GC(140) Survivor regions: 23-&gt;21(21)</span><br><span class="line">[0.875s][info   ][gc,heap     ] GC(140) Old regions: 407-&gt;445</span><br><span class="line">[0.875s][info   ][gc,heap     ] GC(140) Archive regions: 2-&gt;2</span><br><span class="line">[0.875s][info   ][gc,heap     ] GC(140) Humongous regions: 262-&gt;198</span><br><span class="line">[0.875s][info   ][gc,metaspace] GC(140) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.875s][info   ][gc          ] GC(140) Pause Young (Concurrent Start) (G1 Humongous Allocation) 811M-&gt;664M(1024M) 1.672ms</span><br><span class="line">[0.875s][info   ][gc,cpu      ] GC(140) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.875s][info   ][gc          ] GC(141) Concurrent Undo Cycle</span><br><span class="line">[0.875s][info   ][gc,marking  ] GC(141) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.875s][info   ][gc,marking  ] GC(141) Concurrent Cleanup for Next Mark 0.040ms</span><br><span class="line">[0.875s][info   ][gc          ] GC(141) Concurrent Undo Cycle 0.073ms</span><br><span class="line">[0.884s][info   ][gc,start    ] GC(142) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.884s][info   ][gc,task     ] GC(142) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.886s][info   ][gc,phases   ] GC(142)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.886s][info   ][gc,phases   ] GC(142)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.886s][info   ][gc,phases   ] GC(142)   Evacuate Collection Set: 1.3ms</span><br><span class="line">[0.886s][info   ][gc,phases   ] GC(142)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.886s][info   ][gc,phases   ] GC(142)   Other: 0.1ms</span><br><span class="line">[0.886s][info   ][gc,heap     ] GC(142) Eden regions: 123-&gt;0(111)</span><br><span class="line">[0.886s][info   ][gc,heap     ] GC(142) Survivor regions: 21-&gt;18(18)</span><br><span class="line">[0.886s][info   ][gc,heap     ] GC(142) Old regions: 445-&gt;491</span><br><span class="line">[0.886s][info   ][gc,heap     ] GC(142) Archive regions: 2-&gt;2</span><br><span class="line">[0.886s][info   ][gc,heap     ] GC(142) Humongous regions: 247-&gt;185</span><br><span class="line">[0.886s][info   ][gc,metaspace] GC(142) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.886s][info   ][gc          ] GC(142) Pause Young (Concurrent Start) (G1 Humongous Allocation) 835M-&gt;694M(1024M) 2.034ms</span><br><span class="line">[0.886s][info   ][gc,cpu      ] GC(142) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.886s][info   ][gc          ] GC(143) Concurrent Undo Cycle</span><br><span class="line">[0.886s][info   ][gc,marking  ] GC(143) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.886s][info   ][gc,marking  ] GC(143) Concurrent Cleanup for Next Mark 0.045ms</span><br><span class="line">[0.886s][info   ][gc          ] GC(143) Concurrent Undo Cycle 0.075ms</span><br><span class="line">[0.889s][info   ][gc,start    ] GC(144) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.889s][info   ][gc,task     ] GC(144) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.890s][info   ][gc,phases   ] GC(144)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.890s][info   ][gc,phases   ] GC(144)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.890s][info   ][gc,phases   ] GC(144)   Evacuate Collection Set: 0.8ms</span><br><span class="line">[0.890s][info   ][gc,phases   ] GC(144)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.890s][info   ][gc,phases   ] GC(144)   Other: 0.1ms</span><br><span class="line">[0.890s][info   ][gc,heap     ] GC(144) Eden regions: 47-&gt;0(105)</span><br><span class="line">[0.890s][info   ][gc,heap     ] GC(144) Survivor regions: 18-&gt;17(17)</span><br><span class="line">[0.890s][info   ][gc,heap     ] GC(144) Old regions: 491-&gt;510</span><br><span class="line">[0.890s][info   ][gc,heap     ] GC(144) Archive regions: 2-&gt;2</span><br><span class="line">[0.890s][info   ][gc,heap     ] GC(144) Humongous regions: 217-&gt;189</span><br><span class="line">[0.890s][info   ][gc,metaspace] GC(144) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.891s][info   ][gc          ] GC(144) Pause Young (Concurrent Start) (G1 Humongous Allocation) 773M-&gt;716M(1024M) 1.367ms</span><br><span class="line">[0.891s][info   ][gc,cpu      ] GC(144) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.891s][info   ][gc          ] GC(145) Concurrent Undo Cycle</span><br><span class="line">[0.891s][info   ][gc,marking  ] GC(145) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.891s][info   ][gc,marking  ] GC(145) Concurrent Cleanup for Next Mark 0.093ms</span><br><span class="line">[0.891s][info   ][gc          ] GC(145) Concurrent Undo Cycle 0.126ms</span><br><span class="line">[0.893s][info   ][gc,start    ] GC(146) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.893s][info   ][gc,task     ] GC(146) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.894s][info   ][gc,phases   ] GC(146)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.894s][info   ][gc,phases   ] GC(146)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.894s][info   ][gc,phases   ] GC(146)   Evacuate Collection Set: 0.8ms</span><br><span class="line">[0.894s][info   ][gc,phases   ] GC(146)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.894s][info   ][gc,phases   ] GC(146)   Other: 0.1ms</span><br><span class="line">[0.894s][info   ][gc,heap     ] GC(146) Eden regions: 26-&gt;0(95)</span><br><span class="line">[0.894s][info   ][gc,heap     ] GC(146) Survivor regions: 17-&gt;9(16)</span><br><span class="line">[0.894s][info   ][gc,heap     ] GC(146) Old regions: 510-&gt;526</span><br><span class="line">[0.894s][info   ][gc,heap     ] GC(146) Archive regions: 2-&gt;2</span><br><span class="line">[0.894s][info   ][gc,heap     ] GC(146) Humongous regions: 204-&gt;191</span><br><span class="line">[0.894s][info   ][gc,metaspace] GC(146) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.894s][info   ][gc          ] GC(146) Pause Young (Concurrent Start) (G1 Humongous Allocation) 756M-&gt;726M(1024M) 1.508ms</span><br><span class="line">[0.894s][info   ][gc,cpu      ] GC(146) User=0.00s Sys=0.01s Real=0.00s</span><br><span class="line">[0.894s][info   ][gc          ] GC(147) Concurrent Mark Cycle</span><br><span class="line">[0.894s][info   ][gc,marking  ] GC(147) Concurrent Clear Claimed Marks</span><br><span class="line">[0.894s][info   ][gc,marking  ] GC(147) Concurrent Clear Claimed Marks 0.007ms</span><br><span class="line">[0.894s][info   ][gc,marking  ] GC(147) Concurrent Scan Root Regions</span><br><span class="line">[0.894s][info   ][gc,marking  ] GC(147) Concurrent Scan Root Regions 0.058ms</span><br><span class="line">[0.894s][info   ][gc,marking  ] GC(147) Concurrent Mark</span><br><span class="line">[0.894s][info   ][gc,marking  ] GC(147) Concurrent Mark From Roots</span><br><span class="line">[0.894s][info   ][gc,task     ] GC(147) Using 2 workers of 2 for marking</span><br><span class="line">[0.896s][info   ][gc,marking  ] GC(147) Concurrent Mark From Roots 1.293ms</span><br><span class="line">[0.896s][info   ][gc,marking  ] GC(147) Concurrent Preclean</span><br><span class="line">[0.896s][info   ][gc,marking  ] GC(147) Concurrent Preclean 0.010ms</span><br><span class="line">[0.896s][info   ][gc,start    ] GC(147) Pause Remark</span><br><span class="line">[0.896s][info   ][gc          ] GC(147) Pause Remark 750M-&gt;708M(1024M) 0.582ms</span><br><span class="line">[0.896s][info   ][gc,cpu      ] GC(147) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.896s][info   ][gc,marking  ] GC(147) Concurrent Mark 2.116ms</span><br><span class="line">[0.896s][info   ][gc,marking  ] GC(147) Concurrent Rebuild Remembered Sets</span><br><span class="line">[0.898s][info   ][gc,marking  ] GC(147) Concurrent Rebuild Remembered Sets 1.063ms</span><br><span class="line">[0.898s][info   ][gc,start    ] GC(147) Pause Cleanup</span><br><span class="line">[0.898s][info   ][gc          ] GC(147) Pause Cleanup 736M-&gt;736M(1024M) 0.321ms</span><br><span class="line">[0.898s][info   ][gc,cpu      ] GC(147) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.898s][info   ][gc,marking  ] GC(147) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.899s][info   ][gc,marking  ] GC(147) Concurrent Cleanup for Next Mark 0.515ms</span><br><span class="line">[0.899s][info   ][gc          ] GC(147) Concurrent Mark Cycle 4.431ms</span><br><span class="line">[0.903s][info   ][gc,start    ] GC(148) Pause Young (Prepare Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.903s][info   ][gc,task     ] GC(148) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.905s][info   ][gc,phases   ] GC(148)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.905s][info   ][gc,phases   ] GC(148)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.905s][info   ][gc,phases   ] GC(148)   Evacuate Collection Set: 1.0ms</span><br><span class="line">[0.905s][info   ][gc,phases   ] GC(148)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.905s][info   ][gc,phases   ] GC(148)   Other: 0.0ms</span><br><span class="line">[0.905s][info   ][gc,heap     ] GC(148) Eden regions: 95-&gt;0(38)</span><br><span class="line">[0.905s][info   ][gc,heap     ] GC(148) Survivor regions: 9-&gt;13(13)</span><br><span class="line">[0.905s][info   ][gc,heap     ] GC(148) Old regions: 484-&gt;516</span><br><span class="line">[0.905s][info   ][gc,heap     ] GC(148) Archive regions: 2-&gt;2</span><br><span class="line">[0.905s][info   ][gc,heap     ] GC(148) Humongous regions: 256-&gt;194</span><br><span class="line">[0.905s][info   ][gc,metaspace] GC(148) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.905s][info   ][gc          ] GC(148) Pause Young (Prepare Mixed) (G1 Evacuation Pause) 844M-&gt;723M(1024M) 1.620ms</span><br><span class="line">[0.905s][info   ][gc,cpu      ] GC(148) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.908s][info   ][gc,start    ] GC(149) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.908s][info   ][gc,task     ] GC(149) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.909s][info   ][gc,phases   ] GC(149)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.909s][info   ][gc,phases   ] GC(149)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.909s][info   ][gc,phases   ] GC(149)   Evacuate Collection Set: 0.8ms</span><br><span class="line">[0.909s][info   ][gc,phases   ] GC(149)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.909s][info   ][gc,phases   ] GC(149)   Other: 0.0ms</span><br><span class="line">[0.909s][info   ][gc,heap     ] GC(149) Eden regions: 38-&gt;0(44)</span><br><span class="line">[0.909s][info   ][gc,heap     ] GC(149) Survivor regions: 13-&gt;7(7)</span><br><span class="line">[0.909s][info   ][gc,heap     ] GC(149) Old regions: 516-&gt;437</span><br><span class="line">[0.909s][info   ][gc,heap     ] GC(149) Archive regions: 2-&gt;2</span><br><span class="line">[0.909s][info   ][gc,heap     ] GC(149) Humongous regions: 218-&gt;190</span><br><span class="line">[0.909s][info   ][gc,metaspace] GC(149) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.909s][info   ][gc          ] GC(149) Pause Young (Mixed) (G1 Evacuation Pause) 785M-&gt;634M(1024M) 1.521ms</span><br><span class="line">[0.909s][info   ][gc,cpu      ] GC(149) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.913s][info   ][gc,start    ] GC(150) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.913s][info   ][gc,task     ] GC(150) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.914s][info   ][gc,phases   ] GC(150)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.914s][info   ][gc,phases   ] GC(150)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.914s][info   ][gc,phases   ] GC(150)   Evacuate Collection Set: 1.0ms</span><br><span class="line">[0.914s][info   ][gc,phases   ] GC(150)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.914s][info   ][gc,phases   ] GC(150)   Other: 0.1ms</span><br><span class="line">[0.914s][info   ][gc,heap     ] GC(150) Eden regions: 44-&gt;0(44)</span><br><span class="line">[0.914s][info   ][gc,heap     ] GC(150) Survivor regions: 7-&gt;7(7)</span><br><span class="line">[0.914s][info   ][gc,heap     ] GC(150) Old regions: 437-&gt;372</span><br><span class="line">[0.914s][info   ][gc,heap     ] GC(150) Archive regions: 2-&gt;2</span><br><span class="line">[0.914s][info   ][gc,heap     ] GC(150) Humongous regions: 211-&gt;189</span><br><span class="line">[0.914s][info   ][gc,metaspace] GC(150) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.914s][info   ][gc          ] GC(150) Pause Young (Mixed) (G1 Evacuation Pause) 699M-&gt;568M(1024M) 1.610ms</span><br><span class="line">[0.914s][info   ][gc,cpu      ] GC(150) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.918s][info   ][gc,start    ] GC(151) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.918s][info   ][gc,task     ] GC(151) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.919s][info   ][gc,phases   ] GC(151)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.919s][info   ][gc,phases   ] GC(151)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.919s][info   ][gc,phases   ] GC(151)   Evacuate Collection Set: 1.0ms</span><br><span class="line">[0.919s][info   ][gc,phases   ] GC(151)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.919s][info   ][gc,phases   ] GC(151)   Other: 0.0ms</span><br><span class="line">[0.919s][info   ][gc,heap     ] GC(151) Eden regions: 44-&gt;0(204)</span><br><span class="line">[0.919s][info   ][gc,heap     ] GC(151) Survivor regions: 7-&gt;7(7)</span><br><span class="line">[0.919s][info   ][gc,heap     ] GC(151) Old regions: 372-&gt;333</span><br><span class="line">[0.919s][info   ][gc,heap     ] GC(151) Archive regions: 2-&gt;2</span><br><span class="line">[0.919s][info   ][gc,heap     ] GC(151) Humongous regions: 212-&gt;189</span><br><span class="line">[0.919s][info   ][gc,metaspace] GC(151) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.919s][info   ][gc          ] GC(151) Pause Young (Mixed) (G1 Evacuation Pause) 635M-&gt;529M(1024M) 1.554ms</span><br><span class="line">[0.919s][info   ][gc,cpu      ] GC(151) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.934s][info   ][gc,start    ] GC(152) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.934s][info   ][gc,task     ] GC(152) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.936s][info   ][gc,phases   ] GC(152)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.936s][info   ][gc,phases   ] GC(152)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.936s][info   ][gc,phases   ] GC(152)   Evacuate Collection Set: 1.9ms</span><br><span class="line">[0.936s][info   ][gc,phases   ] GC(152)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.936s][info   ][gc,phases   ] GC(152)   Other: 0.0ms</span><br><span class="line">[0.937s][info   ][gc,heap     ] GC(152) Eden regions: 204-&gt;0(163)</span><br><span class="line">[0.937s][info   ][gc,heap     ] GC(152) Survivor regions: 7-&gt;27(27)</span><br><span class="line">[0.937s][info   ][gc,heap     ] GC(152) Old regions: 333-&gt;390</span><br><span class="line">[0.937s][info   ][gc,heap     ] GC(152) Archive regions: 2-&gt;2</span><br><span class="line">[0.937s][info   ][gc,heap     ] GC(152) Humongous regions: 297-&gt;186</span><br><span class="line">[0.937s][info   ][gc,metaspace] GC(152) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.937s][info   ][gc          ] GC(152) Pause Young (Normal) (G1 Evacuation Pause) 841M-&gt;603M(1024M) 2.583ms</span><br><span class="line">[0.937s][info   ][gc,cpu      ] GC(152) User=0.00s Sys=0.01s Real=0.00s</span><br><span class="line">[0.946s][info   ][gc,start    ] GC(153) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.946s][info   ][gc,task     ] GC(153) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.947s][info   ][gc,phases   ] GC(153)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.947s][info   ][gc,phases   ] GC(153)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.947s][info   ][gc,phases   ] GC(153)   Evacuate Collection Set: 1.4ms</span><br><span class="line">[0.947s][info   ][gc,phases   ] GC(153)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.947s][info   ][gc,phases   ] GC(153)   Other: 0.1ms</span><br><span class="line">[0.948s][info   ][gc,heap     ] GC(153) Eden regions: 118-&gt;0(136)</span><br><span class="line">[0.948s][info   ][gc,heap     ] GC(153) Survivor regions: 27-&gt;24(24)</span><br><span class="line">[0.948s][info   ][gc,heap     ] GC(153) Old regions: 390-&gt;436</span><br><span class="line">[0.948s][info   ][gc,heap     ] GC(153) Archive regions: 2-&gt;2</span><br><span class="line">[0.948s][info   ][gc,heap     ] GC(153) Humongous regions: 259-&gt;183</span><br><span class="line">[0.948s][info   ][gc,metaspace] GC(153) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.948s][info   ][gc          ] GC(153) Pause Young (Concurrent Start) (G1 Humongous Allocation) 793M-&gt;643M(1024M) 1.973ms</span><br><span class="line">[0.948s][info   ][gc,cpu      ] GC(153) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.948s][info   ][gc          ] GC(154) Concurrent Undo Cycle</span><br><span class="line">[0.948s][info   ][gc,marking  ] GC(154) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.948s][info   ][gc,marking  ] GC(154) Concurrent Cleanup for Next Mark 0.041ms</span><br><span class="line">[0.948s][info   ][gc          ] GC(154) Concurrent Undo Cycle 0.109ms</span><br><span class="line">[0.954s][info   ][gc,start    ] GC(155) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.954s][info   ][gc,task     ] GC(155) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.956s][info   ][gc,phases   ] GC(155)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.956s][info   ][gc,phases   ] GC(155)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.956s][info   ][gc,phases   ] GC(155)   Evacuate Collection Set: 1.1ms</span><br><span class="line">[0.956s][info   ][gc,phases   ] GC(155)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.956s][info   ][gc,phases   ] GC(155)   Other: 0.1ms</span><br><span class="line">[0.956s][info   ][gc,heap     ] GC(155) Eden regions: 88-&gt;0(113)</span><br><span class="line">[0.956s][info   ][gc,heap     ] GC(155) Survivor regions: 24-&gt;20(20)</span><br><span class="line">[0.956s][info   ][gc,heap     ] GC(155) Old regions: 436-&gt;476</span><br><span class="line">[0.956s][info   ][gc,heap     ] GC(155) Archive regions: 2-&gt;2</span><br><span class="line">[0.956s][info   ][gc,heap     ] GC(155) Humongous regions: 244-&gt;185</span><br><span class="line">[0.956s][info   ][gc,metaspace] GC(155) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.956s][info   ][gc          ] GC(155) Pause Young (Concurrent Start) (G1 Humongous Allocation) 791M-&gt;681M(1024M) 1.816ms</span><br><span class="line">[0.956s][info   ][gc,cpu      ] GC(155) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.956s][info   ][gc          ] GC(156) Concurrent Undo Cycle</span><br><span class="line">[0.956s][info   ][gc,marking  ] GC(156) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.956s][info   ][gc,marking  ] GC(156) Concurrent Cleanup for Next Mark 0.060ms</span><br><span class="line">[0.956s][info   ][gc          ] GC(156) Concurrent Undo Cycle 0.201ms</span><br><span class="line">[0.961s][info   ][gc,start    ] GC(157) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.961s][info   ][gc,task     ] GC(157) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.963s][info   ][gc,phases   ] GC(157)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.963s][info   ][gc,phases   ] GC(157)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.963s][info   ][gc,phases   ] GC(157)   Evacuate Collection Set: 1.2ms</span><br><span class="line">[0.963s][info   ][gc,phases   ] GC(157)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.963s][info   ][gc,phases   ] GC(157)   Other: 0.1ms</span><br><span class="line">[0.963s][info   ][gc,heap     ] GC(157) Eden regions: 66-&gt;0(102)</span><br><span class="line">[0.963s][info   ][gc,heap     ] GC(157) Survivor regions: 20-&gt;17(17)</span><br><span class="line">[0.963s][info   ][gc,heap     ] GC(157) Old regions: 476-&gt;507</span><br><span class="line">[0.963s][info   ][gc,heap     ] GC(157) Archive regions: 2-&gt;2</span><br><span class="line">[0.963s][info   ][gc,heap     ] GC(157) Humongous regions: 232-&gt;180</span><br><span class="line">[0.963s][info   ][gc,metaspace] GC(157) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.963s][info   ][gc          ] GC(157) Pause Young (Concurrent Start) (G1 Humongous Allocation) 793M-&gt;704M(1024M) 2.021ms</span><br><span class="line">[0.963s][info   ][gc,cpu      ] GC(157) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.963s][info   ][gc          ] GC(158) Concurrent Undo Cycle</span><br><span class="line">[0.963s][info   ][gc,marking  ] GC(158) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.963s][info   ][gc,marking  ] GC(158) Concurrent Cleanup for Next Mark 0.053ms</span><br><span class="line">[0.963s][info   ][gc          ] GC(158) Concurrent Undo Cycle 0.146ms</span><br><span class="line">[0.967s][info   ][gc,start    ] GC(159) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.967s][info   ][gc,task     ] GC(159) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.968s][info   ][gc,phases   ] GC(159)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.969s][info   ][gc,phases   ] GC(159)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.969s][info   ][gc,phases   ] GC(159)   Evacuate Collection Set: 0.8ms</span><br><span class="line">[0.969s][info   ][gc,phases   ] GC(159)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.969s][info   ][gc,phases   ] GC(159)   Other: 0.1ms</span><br><span class="line">[0.969s][info   ][gc,heap     ] GC(159) Eden regions: 57-&gt;0(93)</span><br><span class="line">[0.969s][info   ][gc,heap     ] GC(159) Survivor regions: 17-&gt;15(15)</span><br><span class="line">[0.969s][info   ][gc,heap     ] GC(159) Old regions: 507-&gt;531</span><br><span class="line">[0.969s][info   ][gc,heap     ] GC(159) Archive regions: 2-&gt;2</span><br><span class="line">[0.969s][info   ][gc,heap     ] GC(159) Humongous regions: 216-&gt;184</span><br><span class="line">[0.969s][info   ][gc,metaspace] GC(159) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.969s][info   ][gc          ] GC(159) Pause Young (Concurrent Start) (G1 Humongous Allocation) 796M-&gt;730M(1024M) 1.457ms</span><br><span class="line">[0.969s][info   ][gc,cpu      ] GC(159) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.969s][info   ][gc          ] GC(160) Concurrent Undo Cycle</span><br><span class="line">[0.969s][info   ][gc,marking  ] GC(160) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.969s][info   ][gc,marking  ] GC(160) Concurrent Cleanup for Next Mark 0.037ms</span><br><span class="line">[0.969s][info   ][gc          ] GC(160) Concurrent Undo Cycle 0.115ms</span><br><span class="line">[0.972s][info   ][gc,start    ] GC(161) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.972s][info   ][gc,task     ] GC(161) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.973s][info   ][gc,phases   ] GC(161)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.973s][info   ][gc,phases   ] GC(161)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.973s][info   ][gc,phases   ] GC(161)   Evacuate Collection Set: 0.6ms</span><br><span class="line">[0.973s][info   ][gc,phases   ] GC(161)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.973s][info   ][gc,phases   ] GC(161)   Other: 0.1ms</span><br><span class="line">[0.973s][info   ][gc,heap     ] GC(161) Eden regions: 37-&gt;0(81)</span><br><span class="line">[0.973s][info   ][gc,heap     ] GC(161) Survivor regions: 15-&gt;14(14)</span><br><span class="line">[0.973s][info   ][gc,heap     ] GC(161) Old regions: 531-&gt;547</span><br><span class="line">[0.973s][info   ][gc,heap     ] GC(161) Archive regions: 2-&gt;2</span><br><span class="line">[0.973s][info   ][gc,heap     ] GC(161) Humongous regions: 203-&gt;183</span><br><span class="line">[0.973s][info   ][gc,metaspace] GC(161) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.973s][info   ][gc          ] GC(161) Pause Young (Concurrent Start) (G1 Humongous Allocation) 785M-&gt;744M(1024M) 1.255ms</span><br><span class="line">[0.973s][info   ][gc,cpu      ] GC(161) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.973s][info   ][gc          ] GC(162) Concurrent Undo Cycle</span><br><span class="line">[0.973s][info   ][gc,marking  ] GC(162) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.973s][info   ][gc,marking  ] GC(162) Concurrent Cleanup for Next Mark 0.038ms</span><br><span class="line">[0.973s][info   ][gc          ] GC(162) Concurrent Undo Cycle 0.068ms</span><br><span class="line">[0.975s][info   ][gc,start    ] GC(163) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.975s][info   ][gc,task     ] GC(163) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.976s][info   ][gc,phases   ] GC(163)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.976s][info   ][gc,phases   ] GC(163)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.976s][info   ][gc,phases   ] GC(163)   Evacuate Collection Set: 0.5ms</span><br><span class="line">[0.976s][info   ][gc,phases   ] GC(163)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.976s][info   ][gc,phases   ] GC(163)   Other: 0.1ms</span><br><span class="line">[0.976s][info   ][gc,heap     ] GC(163) Eden regions: 26-&gt;0(81)</span><br><span class="line">[0.976s][info   ][gc,heap     ] GC(163) Survivor regions: 14-&gt;10(12)</span><br><span class="line">[0.976s][info   ][gc,heap     ] GC(163) Old regions: 547-&gt;561</span><br><span class="line">[0.976s][info   ][gc,heap     ] GC(163) Archive regions: 2-&gt;2</span><br><span class="line">[0.976s][info   ][gc,heap     ] GC(163) Humongous regions: 201-&gt;182</span><br><span class="line">[0.976s][info   ][gc,metaspace] GC(163) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.976s][info   ][gc          ] GC(163) Pause Young (Concurrent Start) (G1 Humongous Allocation) 788M-&gt;752M(1024M) 1.022ms</span><br><span class="line">[0.976s][info   ][gc,cpu      ] GC(163) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.976s][info   ][gc          ] GC(164) Concurrent Undo Cycle</span><br><span class="line">[0.976s][info   ][gc,marking  ] GC(164) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.976s][info   ][gc,marking  ] GC(164) Concurrent Cleanup for Next Mark 0.064ms</span><br><span class="line">[0.976s][info   ][gc          ] GC(164) Concurrent Undo Cycle 0.119ms</span><br><span class="line">[0.978s][info   ][gc,start    ] GC(165) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.978s][info   ][gc,task     ] GC(165) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.979s][info   ][gc,phases   ] GC(165)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.979s][info   ][gc,phases   ] GC(165)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.979s][info   ][gc,phases   ] GC(165)   Evacuate Collection Set: 0.4ms</span><br><span class="line">[0.979s][info   ][gc,phases   ] GC(165)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.979s][info   ][gc,phases   ] GC(165)   Other: 0.1ms</span><br><span class="line">[0.979s][info   ][gc,heap     ] GC(165) Eden regions: 26-&gt;0(86)</span><br><span class="line">[0.979s][info   ][gc,heap     ] GC(165) Survivor regions: 10-&gt;9(12)</span><br><span class="line">[0.979s][info   ][gc,heap     ] GC(165) Old regions: 561-&gt;570</span><br><span class="line">[0.979s][info   ][gc,heap     ] GC(165) Archive regions: 2-&gt;2</span><br><span class="line">[0.979s][info   ][gc,heap     ] GC(165) Humongous regions: 191-&gt;177</span><br><span class="line">[0.979s][info   ][gc,metaspace] GC(165) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.979s][info   ][gc          ] GC(165) Pause Young (Concurrent Start) (G1 Humongous Allocation) 786M-&gt;756M(1024M) 0.976ms</span><br><span class="line">[0.979s][info   ][gc,cpu      ] GC(165) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.979s][info   ][gc          ] GC(166) Concurrent Undo Cycle</span><br><span class="line">[0.979s][info   ][gc,marking  ] GC(166) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.979s][info   ][gc,marking  ] GC(166) Concurrent Cleanup for Next Mark 0.037ms</span><br><span class="line">[0.979s][info   ][gc          ] GC(166) Concurrent Undo Cycle 0.086ms</span><br><span class="line">[0.979s][info   ][gc,start    ] GC(167) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.979s][info   ][gc,task     ] GC(167) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.980s][info   ][gc,phases   ] GC(167)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.980s][info   ][gc,phases   ] GC(167)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.980s][info   ][gc,phases   ] GC(167)   Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.980s][info   ][gc,phases   ] GC(167)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.980s][info   ][gc,phases   ] GC(167)   Other: 0.0ms</span><br><span class="line">[0.980s][info   ][gc,heap     ] GC(167) Eden regions: 2-&gt;0(80)</span><br><span class="line">[0.980s][info   ][gc,heap     ] GC(167) Survivor regions: 9-&gt;1(12)</span><br><span class="line">[0.980s][info   ][gc,heap     ] GC(167) Old regions: 570-&gt;580</span><br><span class="line">[0.980s][info   ][gc,heap     ] GC(167) Archive regions: 2-&gt;2</span><br><span class="line">[0.980s][info   ][gc,heap     ] GC(167) Humongous regions: 179-&gt;177</span><br><span class="line">[0.980s][info   ][gc,metaspace] GC(167) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.980s][info   ][gc          ] GC(167) Pause Young (Concurrent Start) (G1 Humongous Allocation) 759M-&gt;757M(1024M) 0.656ms</span><br><span class="line">[0.980s][info   ][gc,cpu      ] GC(167) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.980s][info   ][gc          ] GC(168) Concurrent Mark Cycle</span><br><span class="line">[0.980s][info   ][gc,marking  ] GC(168) Concurrent Clear Claimed Marks</span><br><span class="line">[0.980s][info   ][gc,marking  ] GC(168) Concurrent Clear Claimed Marks 0.008ms</span><br><span class="line">[0.980s][info   ][gc,marking  ] GC(168) Concurrent Scan Root Regions</span><br><span class="line">[0.980s][info   ][gc,marking  ] GC(168) Concurrent Scan Root Regions 0.047ms</span><br><span class="line">[0.980s][info   ][gc,marking  ] GC(168) Concurrent Mark</span><br><span class="line">[0.980s][info   ][gc,marking  ] GC(168) Concurrent Mark From Roots</span><br><span class="line">[0.980s][info   ][gc,task     ] GC(168) Using 2 workers of 2 for marking</span><br><span class="line">[0.981s][info   ][gc,marking  ] GC(168) Concurrent Mark From Roots 1.036ms</span><br><span class="line">[0.981s][info   ][gc,marking  ] GC(168) Concurrent Preclean</span><br><span class="line">[0.981s][info   ][gc,marking  ] GC(168) Concurrent Preclean 0.009ms</span><br><span class="line">[0.981s][info   ][gc,start    ] GC(168) Pause Remark</span><br><span class="line">[0.982s][info   ][gc          ] GC(168) Pause Remark 783M-&gt;737M(1024M) 0.352ms</span><br><span class="line">[0.982s][info   ][gc,cpu      ] GC(168) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.982s][info   ][gc,marking  ] GC(168) Concurrent Mark 1.575ms</span><br><span class="line">[0.982s][info   ][gc,marking  ] GC(168) Concurrent Rebuild Remembered Sets</span><br><span class="line">[0.983s][info   ][gc,marking  ] GC(168) Concurrent Rebuild Remembered Sets 0.925ms</span><br><span class="line">[0.983s][info   ][gc,start    ] GC(168) Pause Cleanup</span><br><span class="line">[0.983s][info   ][gc          ] GC(168) Pause Cleanup 759M-&gt;759M(1024M) 0.247ms</span><br><span class="line">[0.983s][info   ][gc,cpu      ] GC(168) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.983s][info   ][gc,marking  ] GC(168) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.984s][info   ][gc,marking  ] GC(168) Concurrent Cleanup for Next Mark 0.534ms</span><br><span class="line">[0.984s][info   ][gc          ] GC(168) Concurrent Mark Cycle 3.744ms</span><br><span class="line">[0.987s][info   ][gc,start    ] GC(169) Pause Young (Prepare Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.987s][info   ][gc,task     ] GC(169) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.989s][info   ][gc,phases   ] GC(169)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.989s][info   ][gc,phases   ] GC(169)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.989s][info   ][gc,phases   ] GC(169)   Evacuate Collection Set: 0.9ms</span><br><span class="line">[0.989s][info   ][gc,phases   ] GC(169)   Post Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.989s][info   ][gc,phases   ] GC(169)   Other: 0.0ms</span><br><span class="line">[0.989s][info   ][gc,heap     ] GC(169) Eden regions: 80-&gt;0(40)</span><br><span class="line">[0.989s][info   ][gc,heap     ] GC(169) Survivor regions: 1-&gt;11(11)</span><br><span class="line">[0.989s][info   ][gc,heap     ] GC(169) Old regions: 534-&gt;559</span><br><span class="line">[0.989s][info   ][gc,heap     ] GC(169) Archive regions: 2-&gt;2</span><br><span class="line">[0.989s][info   ][gc,heap     ] GC(169) Humongous regions: 229-&gt;184</span><br><span class="line">[0.989s][info   ][gc,metaspace] GC(169) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.989s][info   ][gc          ] GC(169) Pause Young (Prepare Mixed) (G1 Evacuation Pause) 843M-&gt;754M(1024M) 1.649ms</span><br><span class="line">[0.989s][info   ][gc,cpu      ] GC(169) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.992s][info   ][gc,start    ] GC(170) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.992s][info   ][gc,task     ] GC(170) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.993s][info   ][gc,phases   ] GC(170)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.993s][info   ][gc,phases   ] GC(170)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.993s][info   ][gc,phases   ] GC(170)   Evacuate Collection Set: 0.8ms</span><br><span class="line">[0.993s][info   ][gc,phases   ] GC(170)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.993s][info   ][gc,phases   ] GC(170)   Other: 0.0ms</span><br><span class="line">[0.993s][info   ][gc,heap     ] GC(170) Eden regions: 40-&gt;0(44)</span><br><span class="line">[0.993s][info   ][gc,heap     ] GC(170) Survivor regions: 11-&gt;7(7)</span><br><span class="line">[0.993s][info   ][gc,heap     ] GC(170) Old regions: 559-&gt;481</span><br><span class="line">[0.993s][info   ][gc,heap     ] GC(170) Archive regions: 2-&gt;2</span><br><span class="line">[0.993s][info   ][gc,heap     ] GC(170) Humongous regions: 208-&gt;186</span><br><span class="line">[0.993s][info   ][gc,metaspace] GC(170) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.993s][info   ][gc          ] GC(170) Pause Young (Mixed) (G1 Evacuation Pause) 818M-&gt;674M(1024M) 1.536ms</span><br><span class="line">[0.993s][info   ][gc,cpu      ] GC(170) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.997s][info   ][gc,start    ] GC(171) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.997s][info   ][gc,task     ] GC(171) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.999s][info   ][gc,phases   ] GC(171)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.999s][info   ][gc,phases   ] GC(171)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.999s][info   ][gc,phases   ] GC(171)   Evacuate Collection Set: 1.1ms</span><br><span class="line">[0.999s][info   ][gc,phases   ] GC(171)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.999s][info   ][gc,phases   ] GC(171)   Other: 0.1ms</span><br><span class="line">[0.999s][info   ][gc,heap     ] GC(171) Eden regions: 44-&gt;0(44)</span><br><span class="line">[0.999s][info   ][gc,heap     ] GC(171) Survivor regions: 7-&gt;7(7)</span><br><span class="line">[0.999s][info   ][gc,heap     ] GC(171) Old regions: 481-&gt;415</span><br><span class="line">[0.999s][info   ][gc,heap     ] GC(171) Archive regions: 2-&gt;2</span><br><span class="line">[0.999s][info   ][gc,heap     ] GC(171) Humongous regions: 205-&gt;182</span><br><span class="line">[0.999s][info   ][gc,metaspace] GC(171) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.999s][info   ][gc          ] GC(171) Pause Young (Mixed) (G1 Evacuation Pause) 737M-&gt;604M(1024M) 1.811ms</span><br><span class="line">[0.999s][info   ][gc,cpu      ] GC(171) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[1.002s][info   ][gc,start    ] GC(172) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[1.002s][info   ][gc,task     ] GC(172) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.004s][info   ][gc,phases   ] GC(172)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[1.004s][info   ][gc,phases   ] GC(172)   Merge Heap Roots: 0.1ms</span><br><span class="line">[1.004s][info   ][gc,phases   ] GC(172)   Evacuate Collection Set: 1.1ms</span><br><span class="line">[1.004s][info   ][gc,phases   ] GC(172)   Post Evacuate Collection Set: 0.3ms</span><br><span class="line">[1.004s][info   ][gc,phases   ] GC(172)   Other: 0.0ms</span><br><span class="line">[1.004s][info   ][gc,heap     ] GC(172) Eden regions: 44-&gt;0(44)</span><br><span class="line">[1.004s][info   ][gc,heap     ] GC(172) Survivor regions: 7-&gt;7(7)</span><br><span class="line">[1.004s][info   ][gc,heap     ] GC(172) Old regions: 415-&gt;361</span><br><span class="line">[1.004s][info   ][gc,heap     ] GC(172) Archive regions: 2-&gt;2</span><br><span class="line">[1.004s][info   ][gc,heap     ] GC(172) Humongous regions: 211-&gt;182</span><br><span class="line">[1.004s][info   ][gc,metaspace] GC(172) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.004s][info   ][gc          ] GC(172) Pause Young (Mixed) (G1 Evacuation Pause) 676M-&gt;550M(1024M) 1.933ms</span><br><span class="line">[1.004s][info   ][gc,cpu      ] GC(172) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[1.007s][info   ][gc,start    ] GC(173) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[1.007s][info   ][gc,task     ] GC(173) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.008s][info   ][gc,phases   ] GC(173)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[1.008s][info   ][gc,phases   ] GC(173)   Merge Heap Roots: 0.0ms</span><br><span class="line">[1.008s][info   ][gc,phases   ] GC(173)   Evacuate Collection Set: 0.7ms</span><br><span class="line">[1.008s][info   ][gc,phases   ] GC(173)   Post Evacuate Collection Set: 0.1ms</span><br><span class="line">[1.008s][info   ][gc,phases   ] GC(173)   Other: 0.0ms</span><br><span class="line">[1.008s][info   ][gc,heap     ] GC(173) Eden regions: 44-&gt;0(165)</span><br><span class="line">[1.008s][info   ][gc,heap     ] GC(173) Survivor regions: 7-&gt;7(7)</span><br><span class="line">[1.008s][info   ][gc,heap     ] GC(173) Old regions: 361-&gt;373</span><br><span class="line">[1.008s][info   ][gc,heap     ] GC(173) Archive regions: 2-&gt;2</span><br><span class="line">[1.008s][info   ][gc,heap     ] GC(173) Humongous regions: 203-&gt;187</span><br><span class="line">[1.008s][info   ][gc,metaspace] GC(173) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.008s][info   ][gc          ] GC(173) Pause Young (Mixed) (G1 Evacuation Pause) 615M-&gt;567M(1024M) 1.325ms</span><br><span class="line">[1.008s][info   ][gc,cpu      ] GC(173) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[1.020s][info   ][gc,start    ] GC(174) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[1.021s][info   ][gc,task     ] GC(174) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.022s][info   ][gc,phases   ] GC(174)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[1.022s][info   ][gc,phases   ] GC(174)   Merge Heap Roots: 0.1ms</span><br><span class="line">[1.022s][info   ][gc,phases   ] GC(174)   Evacuate Collection Set: 1.4ms</span><br><span class="line">[1.022s][info   ][gc,phases   ] GC(174)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[1.022s][info   ][gc,phases   ] GC(174)   Other: 0.0ms</span><br><span class="line">[1.022s][info   ][gc,heap     ] GC(174) Eden regions: 165-&gt;0(139)</span><br><span class="line">[1.022s][info   ][gc,heap     ] GC(174) Survivor regions: 7-&gt;22(22)</span><br><span class="line">[1.022s][info   ][gc,heap     ] GC(174) Old regions: 373-&gt;422</span><br><span class="line">[1.022s][info   ][gc,heap     ] GC(174) Archive regions: 2-&gt;2</span><br><span class="line">[1.022s][info   ][gc,heap     ] GC(174) Humongous regions: 288-&gt;183</span><br><span class="line">[1.022s][info   ][gc,metaspace] GC(174) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.023s][info   ][gc          ] GC(174) Pause Young (Normal) (G1 Evacuation Pause) 833M-&gt;627M(1024M) 2.066ms</span><br><span class="line">[1.023s][info   ][gc,cpu      ] GC(174) User=0.01s Sys=0.00s Real=0.01s</span><br><span class="line">counter:56917</span><br><span class="line">[1.029s][info   ][gc,heap,exit] Heap</span><br><span class="line">[1.029s][info   ][gc,heap,exit]  garbage-first heap   total 1048576K, used 643781K [0x00000007c0000000, 0x0000000800000000)</span><br><span class="line">[1.029s][info   ][gc,heap,exit]   region size 1024K, 23 young (23552K), 22 survivors (22528K)</span><br><span class="line">[1.029s][info   ][gc,heap,exit]  Metaspace       used 233K, committed 448K, reserved 1114112K</span><br><span class="line">[1.029s][info   ][gc,heap,exit]   class space    used 9K, committed 128K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>再试试2g内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+UseG1GC -Xms2g -Xmx2g -XX:+PrintGCDetails -Xlog:gc\*:file=gc.log:time,uptime,level,tags GCLogAnalysis</span><br></pre></td></tr></table></figure>

<p>可以看到GC次数减少，但是性能并没有什么提升，这也说明了GC对于性能的影响开始减少</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0.002s][warning][gc] -XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.</span><br><span class="line">[0.005s][info   ][gc,init] CardTable entry size: 512</span><br><span class="line">[0.005s][info   ][gc     ] Using G1</span><br><span class="line">[0.007s][info   ][gc,init] Version: 19.0.2+7-44 (release)</span><br><span class="line">[0.008s][info   ][gc,init] CPUs: 8 total, 8 available</span><br><span class="line">[0.008s][info   ][gc,init] Memory: 16384M</span><br><span class="line">[0.008s][info   ][gc,init] Large Page Support: Disabled</span><br><span class="line">[0.008s][info   ][gc,init] NUMA Support: Disabled</span><br><span class="line">[0.008s][info   ][gc,init] Compressed Oops: Enabled (Zero based)</span><br><span class="line">[0.008s][info   ][gc,init] Heap Region Size: 1M</span><br><span class="line">[0.008s][info   ][gc,init] Heap Min Capacity: 2G</span><br><span class="line">[0.008s][info   ][gc,init] Heap Initial Capacity: 2G</span><br><span class="line">[0.008s][info   ][gc,init] Heap Max Capacity: 2G</span><br><span class="line">[0.008s][info   ][gc,init] Pre-touch: Disabled</span><br><span class="line">[0.008s][info   ][gc,init] Parallel Workers: 8</span><br><span class="line">[0.008s][info   ][gc,init] Concurrent Workers: 2</span><br><span class="line">[0.008s][info   ][gc,init] Concurrent Refinement Workers: 8</span><br><span class="line">[0.008s][info   ][gc,init] Periodic GC: Disabled</span><br><span class="line">[0.008s][info   ][gc,metaspace] CDS archive(s) mapped at: [0x0000000800000000-0x0000000800c44000-0x0000000800c44000), size 12861440, SharedBaseAddress: 0x0000000800000000, ArchiveRelocationMode: 0.</span><br><span class="line">[0.008s][info   ][gc,metaspace] Compressed class space mapped at: 0x0000000801000000-0x0000000841000000, reserved size: 1073741824</span><br><span class="line">[0.008s][info   ][gc,metaspace] Narrow klass base: 0x0000000800000000, Narrow klass shift: 0, Narrow klass range: 0x100000000</span><br><span class="line">gc...</span><br><span class="line">[0.047s][info   ][gc,start    ] GC(0) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.047s][info   ][gc,task     ] GC(0) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.054s][info   ][gc,phases   ] GC(0)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.054s][info   ][gc,phases   ] GC(0)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.054s][info   ][gc,phases   ] GC(0)   Evacuate Collection Set: 5.8ms</span><br><span class="line">[0.054s][info   ][gc,phases   ] GC(0)   Post Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.054s][info   ][gc,phases   ] GC(0)   Other: 0.3ms</span><br><span class="line">[0.054s][info   ][gc,heap     ] GC(0) Eden regions: 102-&gt;0(89)</span><br><span class="line">[0.054s][info   ][gc,heap     ] GC(0) Survivor regions: 0-&gt;13(13)</span><br><span class="line">[0.054s][info   ][gc,heap     ] GC(0) Old regions: 0-&gt;30</span><br><span class="line">[0.054s][info   ][gc,heap     ] GC(0) Archive regions: 2-&gt;2</span><br><span class="line">[0.054s][info   ][gc,heap     ] GC(0) Humongous regions: 57-&gt;22</span><br><span class="line">[0.054s][info   ][gc,metaspace] GC(0) Metaspace: 155K(384K)-&gt;155K(384K) NonClass: 149K(256K)-&gt;149K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.054s][info   ][gc          ] GC(0) Pause Young (Normal) (G1 Evacuation Pause) 159M-&gt;65M(2048M) 6.974ms</span><br><span class="line">[0.054s][info   ][gc,cpu      ] GC(0) User=0.01s Sys=0.02s Real=0.01s</span><br><span class="line">[0.066s][info   ][gc,start    ] GC(1) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.066s][info   ][gc,task     ] GC(1) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.071s][info   ][gc,phases   ] GC(1)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.071s][info   ][gc,phases   ] GC(1)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.071s][info   ][gc,phases   ] GC(1)   Evacuate Collection Set: 4.8ms</span><br><span class="line">[0.071s][info   ][gc,phases   ] GC(1)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.071s][info   ][gc,phases   ] GC(1)   Other: 0.0ms</span><br><span class="line">[0.071s][info   ][gc,heap     ] GC(1) Eden regions: 89-&gt;0(89)</span><br><span class="line">[0.072s][info   ][gc,heap     ] GC(1) Survivor regions: 13-&gt;13(13)</span><br><span class="line">[0.072s][info   ][gc,heap     ] GC(1) Old regions: 30-&gt;63</span><br><span class="line">[0.072s][info   ][gc,heap     ] GC(1) Archive regions: 2-&gt;2</span><br><span class="line">[0.072s][info   ][gc,heap     ] GC(1) Humongous regions: 72-&gt;47</span><br><span class="line">[0.072s][info   ][gc,metaspace] GC(1) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.072s][info   ][gc          ] GC(1) Pause Young (Normal) (G1 Evacuation Pause) 204M-&gt;123M(2048M) 5.455ms</span><br><span class="line">[0.072s][info   ][gc,cpu      ] GC(1) User=0.01s Sys=0.02s Real=0.01s</span><br><span class="line">[0.083s][info   ][gc,start    ] GC(2) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.083s][info   ][gc,task     ] GC(2) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.089s][info   ][gc,phases   ] GC(2)   Pre Evacuate Collection Set: 0.4ms</span><br><span class="line">[0.089s][info   ][gc,phases   ] GC(2)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.089s][info   ][gc,phases   ] GC(2)   Evacuate Collection Set: 4.7ms</span><br><span class="line">[0.089s][info   ][gc,phases   ] GC(2)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.089s][info   ][gc,phases   ] GC(2)   Other: 0.0ms</span><br><span class="line">[0.089s][info   ][gc,heap     ] GC(2) Eden regions: 89-&gt;0(89)</span><br><span class="line">[0.089s][info   ][gc,heap     ] GC(2) Survivor regions: 13-&gt;13(13)</span><br><span class="line">[0.089s][info   ][gc,heap     ] GC(2) Old regions: 63-&gt;95</span><br><span class="line">[0.089s][info   ][gc,heap     ] GC(2) Archive regions: 2-&gt;2</span><br><span class="line">[0.089s][info   ][gc,heap     ] GC(2) Humongous regions: 100-&gt;62</span><br><span class="line">[0.089s][info   ][gc,metaspace] GC(2) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.089s][info   ][gc          ] GC(2) Pause Young (Normal) (G1 Evacuation Pause) 265M-&gt;170M(2048M) 5.613ms</span><br><span class="line">[0.089s][info   ][gc,cpu      ] GC(2) User=0.00s Sys=0.02s Real=0.01s</span><br><span class="line">[0.096s][info   ][gc,start    ] GC(3) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.096s][info   ][gc,task     ] GC(3) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.101s][info   ][gc,phases   ] GC(3)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.101s][info   ][gc,phases   ] GC(3)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.102s][info   ][gc,phases   ] GC(3)   Evacuate Collection Set: 5.0ms</span><br><span class="line">[0.102s][info   ][gc,phases   ] GC(3)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.102s][info   ][gc,phases   ] GC(3)   Other: 0.1ms</span><br><span class="line">[0.102s][info   ][gc,heap     ] GC(3) Eden regions: 89-&gt;0(89)</span><br><span class="line">[0.102s][info   ][gc,heap     ] GC(3) Survivor regions: 13-&gt;13(13)</span><br><span class="line">[0.102s][info   ][gc,heap     ] GC(3) Old regions: 95-&gt;131</span><br><span class="line">[0.102s][info   ][gc,heap     ] GC(3) Archive regions: 2-&gt;2</span><br><span class="line">[0.102s][info   ][gc,heap     ] GC(3) Humongous regions: 103-&gt;72</span><br><span class="line">[0.102s][info   ][gc,metaspace] GC(3) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.102s][info   ][gc          ] GC(3) Pause Young (Normal) (G1 Evacuation Pause) 300M-&gt;216M(2048M) 5.680ms</span><br><span class="line">[0.102s][info   ][gc,cpu      ] GC(3) User=0.01s Sys=0.02s Real=0.01s</span><br><span class="line">[0.110s][info   ][gc,start    ] GC(4) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.110s][info   ][gc,task     ] GC(4) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.115s][info   ][gc,phases   ] GC(4)   Pre Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.116s][info   ][gc,phases   ] GC(4)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.116s][info   ][gc,phases   ] GC(4)   Evacuate Collection Set: 5.1ms</span><br><span class="line">[0.116s][info   ][gc,phases   ] GC(4)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.116s][info   ][gc,phases   ] GC(4)   Other: 0.1ms</span><br><span class="line">[0.116s][info   ][gc,heap     ] GC(4) Eden regions: 89-&gt;0(94)</span><br><span class="line">[0.116s][info   ][gc,heap     ] GC(4) Survivor regions: 13-&gt;13(13)</span><br><span class="line">[0.116s][info   ][gc,heap     ] GC(4) Old regions: 131-&gt;168</span><br><span class="line">[0.116s][info   ][gc,heap     ] GC(4) Archive regions: 2-&gt;2</span><br><span class="line">[0.116s][info   ][gc,heap     ] GC(4) Humongous regions: 133-&gt;86</span><br><span class="line">[0.116s][info   ][gc,metaspace] GC(4) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.116s][info   ][gc          ] GC(4) Pause Young (Normal) (G1 Evacuation Pause) 366M-&gt;267M(2048M) 5.949ms</span><br><span class="line">[0.116s][info   ][gc,cpu      ] GC(4) User=0.01s Sys=0.02s Real=0.00s</span><br><span class="line">[0.123s][info   ][gc,start    ] GC(5) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.123s][info   ][gc,task     ] GC(5) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.129s][info   ][gc,phases   ] GC(5)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.129s][info   ][gc,phases   ] GC(5)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.129s][info   ][gc,phases   ] GC(5)   Evacuate Collection Set: 5.4ms</span><br><span class="line">[0.129s][info   ][gc,phases   ] GC(5)   Post Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.129s][info   ][gc,phases   ] GC(5)   Other: 0.0ms</span><br><span class="line">[0.129s][info   ][gc,heap     ] GC(5) Eden regions: 94-&gt;0(132)</span><br><span class="line">[0.129s][info   ][gc,heap     ] GC(5) Survivor regions: 13-&gt;14(14)</span><br><span class="line">[0.129s][info   ][gc,heap     ] GC(5) Old regions: 168-&gt;200</span><br><span class="line">[0.129s][info   ][gc,heap     ] GC(5) Archive regions: 2-&gt;2</span><br><span class="line">[0.129s][info   ][gc,heap     ] GC(5) Humongous regions: 139-&gt;107</span><br><span class="line">[0.129s][info   ][gc,metaspace] GC(5) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.129s][info   ][gc          ] GC(5) Pause Young (Normal) (G1 Evacuation Pause) 414M-&gt;321M(2048M) 6.092ms</span><br><span class="line">[0.129s][info   ][gc,cpu      ] GC(5) User=0.00s Sys=0.03s Real=0.01s</span><br><span class="line">[0.143s][info   ][gc,start    ] GC(6) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.143s][info   ][gc,task     ] GC(6) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.151s][info   ][gc,phases   ] GC(6)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.151s][info   ][gc,phases   ] GC(6)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.151s][info   ][gc,phases   ] GC(6)   Evacuate Collection Set: 7.3ms</span><br><span class="line">[0.151s][info   ][gc,phases   ] GC(6)   Post Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.151s][info   ][gc,phases   ] GC(6)   Other: 0.1ms</span><br><span class="line">[0.151s][info   ][gc,heap     ] GC(6) Eden regions: 132-&gt;0(161)</span><br><span class="line">[0.151s][info   ][gc,heap     ] GC(6) Survivor regions: 14-&gt;19(19)</span><br><span class="line">[0.151s][info   ][gc,heap     ] GC(6) Old regions: 200-&gt;245</span><br><span class="line">[0.151s][info   ][gc,heap     ] GC(6) Archive regions: 2-&gt;2</span><br><span class="line">[0.151s][info   ][gc,heap     ] GC(6) Humongous regions: 191-&gt;124</span><br><span class="line">[0.151s][info   ][gc,metaspace] GC(6) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.151s][info   ][gc          ] GC(6) Pause Young (Normal) (G1 Evacuation Pause) 537M-&gt;388M(2048M) 8.018ms</span><br><span class="line">[0.151s][info   ][gc,cpu      ] GC(6) User=0.01s Sys=0.03s Real=0.01s</span><br><span class="line">[0.165s][info   ][gc,start    ] GC(7) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.165s][info   ][gc,task     ] GC(7) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.174s][info   ][gc,phases   ] GC(7)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.174s][info   ][gc,phases   ] GC(7)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.174s][info   ][gc,phases   ] GC(7)   Evacuate Collection Set: 8.3ms</span><br><span class="line">[0.174s][info   ][gc,phases   ] GC(7)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.174s][info   ][gc,phases   ] GC(7)   Other: 0.0ms</span><br><span class="line">[0.174s][info   ][gc,heap     ] GC(7) Eden regions: 161-&gt;0(211)</span><br><span class="line">[0.174s][info   ][gc,heap     ] GC(7) Survivor regions: 19-&gt;23(23)</span><br><span class="line">[0.174s][info   ][gc,heap     ] GC(7) Old regions: 245-&gt;296</span><br><span class="line">[0.174s][info   ][gc,heap     ] GC(7) Archive regions: 2-&gt;2</span><br><span class="line">[0.174s][info   ][gc,heap     ] GC(7) Humongous regions: 212-&gt;133</span><br><span class="line">[0.174s][info   ][gc,metaspace] GC(7) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.174s][info   ][gc          ] GC(7) Pause Young (Normal) (G1 Evacuation Pause) 637M-&gt;452M(2048M) 9.020ms</span><br><span class="line">[0.174s][info   ][gc,cpu      ] GC(7) User=0.00s Sys=0.04s Real=0.01s</span><br><span class="line">[0.194s][info   ][gc,start    ] GC(8) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.194s][info   ][gc,task     ] GC(8) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.205s][info   ][gc,phases   ] GC(8)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.205s][info   ][gc,phases   ] GC(8)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.205s][info   ][gc,phases   ] GC(8)   Evacuate Collection Set: 10.3ms</span><br><span class="line">[0.205s][info   ][gc,phases   ] GC(8)   Post Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.205s][info   ][gc,phases   ] GC(8)   Other: 0.1ms</span><br><span class="line">[0.205s][info   ][gc,heap     ] GC(8) Eden regions: 211-&gt;0(323)</span><br><span class="line">[0.205s][info   ][gc,heap     ] GC(8) Survivor regions: 23-&gt;30(30)</span><br><span class="line">[0.205s][info   ][gc,heap     ] GC(8) Old regions: 296-&gt;356</span><br><span class="line">[0.205s][info   ][gc,heap     ] GC(8) Archive regions: 2-&gt;2</span><br><span class="line">[0.205s][info   ][gc,heap     ] GC(8) Humongous regions: 236-&gt;131</span><br><span class="line">[0.205s][info   ][gc,metaspace] GC(8) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.205s][info   ][gc          ] GC(8) Pause Young (Normal) (G1 Evacuation Pause) 765M-&gt;517M(2048M) 11.131ms</span><br><span class="line">[0.205s][info   ][gc,cpu      ] GC(8) User=0.01s Sys=0.04s Real=0.01s</span><br><span class="line">[0.239s][info   ][gc,start    ] GC(9) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.239s][info   ][gc,task     ] GC(9) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.253s][info   ][gc,phases   ] GC(9)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.253s][info   ][gc,phases   ] GC(9)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.253s][info   ][gc,phases   ] GC(9)   Evacuate Collection Set: 12.9ms</span><br><span class="line">[0.253s][info   ][gc,phases   ] GC(9)   Post Evacuate Collection Set: 0.4ms</span><br><span class="line">[0.253s][info   ][gc,phases   ] GC(9)   Other: 0.1ms</span><br><span class="line">[0.253s][info   ][gc,heap     ] GC(9) Eden regions: 323-&gt;0(333)</span><br><span class="line">[0.253s][info   ][gc,heap     ] GC(9) Survivor regions: 30-&gt;45(45)</span><br><span class="line">[0.253s][info   ][gc,heap     ] GC(9) Old regions: 356-&gt;432</span><br><span class="line">[0.253s][info   ][gc,heap     ] GC(9) Archive regions: 2-&gt;2</span><br><span class="line">[0.253s][info   ][gc,heap     ] GC(9) Humongous regions: 299-&gt;157</span><br><span class="line">[0.253s][info   ][gc,metaspace] GC(9) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.253s][info   ][gc          ] GC(9) Pause Young (Normal) (G1 Evacuation Pause) 1008M-&gt;634M(2048M) 13.849ms</span><br><span class="line">[0.253s][info   ][gc,cpu      ] GC(9) User=0.01s Sys=0.05s Real=0.01s</span><br><span class="line">[0.282s][info   ][gc,start    ] GC(10) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.282s][info   ][gc,task     ] GC(10) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.295s][info   ][gc,phases   ] GC(10)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.295s][info   ][gc,phases   ] GC(10)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.295s][info   ][gc,phases   ] GC(10)   Evacuate Collection Set: 12.3ms</span><br><span class="line">[0.295s][info   ][gc,phases   ] GC(10)   Post Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.295s][info   ][gc,phases   ] GC(10)   Other: 0.1ms</span><br><span class="line">[0.295s][info   ][gc,heap     ] GC(10) Eden regions: 333-&gt;0(639)</span><br><span class="line">[0.295s][info   ][gc,heap     ] GC(10) Survivor regions: 45-&gt;48(48)</span><br><span class="line">[0.295s][info   ][gc,heap     ] GC(10) Old regions: 432-&gt;512</span><br><span class="line">[0.295s][info   ][gc,heap     ] GC(10) Archive regions: 2-&gt;2</span><br><span class="line">[0.295s][info   ][gc,heap     ] GC(10) Humongous regions: 323-&gt;156</span><br><span class="line">[0.295s][info   ][gc,metaspace] GC(10) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.295s][info   ][gc          ] GC(10) Pause Young (Normal) (G1 Evacuation Pause) 1133M-&gt;716M(2048M) 13.062ms</span><br><span class="line">[0.295s][info   ][gc,cpu      ] GC(10) User=0.01s Sys=0.05s Real=0.01s</span><br><span class="line">[0.335s][info   ][gc,start    ] GC(11) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.335s][info   ][gc,task     ] GC(11) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.357s][info   ][gc,phases   ] GC(11)   Pre Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.357s][info   ][gc,phases   ] GC(11)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.357s][info   ][gc,phases   ] GC(11)   Evacuate Collection Set: 20.3ms</span><br><span class="line">[0.357s][info   ][gc,phases   ] GC(11)   Post Evacuate Collection Set: 0.5ms</span><br><span class="line">[0.357s][info   ][gc,phases   ] GC(11)   Other: 0.1ms</span><br><span class="line">[0.357s][info   ][gc,heap     ] GC(11) Eden regions: 438-&gt;0(554)</span><br><span class="line">[0.357s][info   ][gc,heap     ] GC(11) Survivor regions: 48-&gt;86(86)</span><br><span class="line">[0.357s][info   ][gc,heap     ] GC(11) Old regions: 512-&gt;582</span><br><span class="line">[0.357s][info   ][gc,heap     ] GC(11) Archive regions: 2-&gt;2</span><br><span class="line">[0.357s][info   ][gc,heap     ] GC(11) Humongous regions: 407-&gt;166</span><br><span class="line">[0.357s][info   ][gc,metaspace] GC(11) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.357s][info   ][gc          ] GC(11) Pause Young (Concurrent Start) (G1 Humongous Allocation) 1404M-&gt;834M(2048M) 21.423ms</span><br><span class="line">[0.357s][info   ][gc,cpu      ] GC(11) User=0.01s Sys=0.09s Real=0.02s</span><br><span class="line">[0.357s][info   ][gc          ] GC(12) Concurrent Undo Cycle</span><br><span class="line">[0.357s][info   ][gc,marking  ] GC(12) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.357s][info   ][gc,marking  ] GC(12) Concurrent Cleanup for Next Mark 0.051ms</span><br><span class="line">[0.357s][info   ][gc          ] GC(12) Concurrent Undo Cycle 0.074ms</span><br><span class="line">[0.380s][info   ][gc,start    ] GC(13) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.380s][info   ][gc,task     ] GC(13) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.386s][info   ][gc,phases   ] GC(13)   Pre Evacuate Collection Set: 0.5ms</span><br><span class="line">[0.386s][info   ][gc,phases   ] GC(13)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.386s][info   ][gc,phases   ] GC(13)   Evacuate Collection Set: 4.8ms</span><br><span class="line">[0.386s][info   ][gc,phases   ] GC(13)   Post Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.386s][info   ][gc,phases   ] GC(13)   Other: 0.1ms</span><br><span class="line">[0.386s][info   ][gc,heap     ] GC(13) Eden regions: 298-&gt;0(559)</span><br><span class="line">[0.386s][info   ][gc,heap     ] GC(13) Survivor regions: 86-&gt;80(80)</span><br><span class="line">[0.386s][info   ][gc,heap     ] GC(13) Old regions: 582-&gt;657</span><br><span class="line">[0.386s][info   ][gc,heap     ] GC(13) Archive regions: 2-&gt;2</span><br><span class="line">[0.386s][info   ][gc,heap     ] GC(13) Humongous regions: 337-&gt;164</span><br><span class="line">[0.386s][info   ][gc,metaspace] GC(13) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.386s][info   ][gc          ] GC(13) Pause Young (Concurrent Start) (G1 Humongous Allocation) 1302M-&gt;901M(2048M) 6.106ms</span><br><span class="line">[0.386s][info   ][gc,cpu      ] GC(13) User=0.02s Sys=0.01s Real=0.00s</span><br><span class="line">[0.386s][info   ][gc          ] GC(14) Concurrent Undo Cycle</span><br><span class="line">[0.386s][info   ][gc,marking  ] GC(14) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.386s][info   ][gc,marking  ] GC(14) Concurrent Cleanup for Next Mark 0.036ms</span><br><span class="line">[0.386s][info   ][gc          ] GC(14) Concurrent Undo Cycle 0.088ms</span><br><span class="line">[0.399s][info   ][gc,start    ] GC(15) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.399s][info   ][gc,task     ] GC(15) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.403s][info   ][gc,phases   ] GC(15)   Pre Evacuate Collection Set: 0.4ms</span><br><span class="line">[0.403s][info   ][gc,phases   ] GC(15)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.403s][info   ][gc,phases   ] GC(15)   Evacuate Collection Set: 3.2ms</span><br><span class="line">[0.403s][info   ][gc,phases   ] GC(15)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.403s][info   ][gc,phases   ] GC(15)   Other: 0.1ms</span><br><span class="line">[0.403s][info   ][gc,heap     ] GC(15) Eden regions: 168-&gt;0(532)</span><br><span class="line">[0.403s][info   ][gc,heap     ] GC(15) Survivor regions: 80-&gt;65(80)</span><br><span class="line">[0.403s][info   ][gc,heap     ] GC(15) Old regions: 657-&gt;719</span><br><span class="line">[0.403s][info   ][gc,heap     ] GC(15) Archive regions: 2-&gt;2</span><br><span class="line">[0.403s][info   ][gc,heap     ] GC(15) Humongous regions: 262-&gt;172</span><br><span class="line">[0.403s][info   ][gc,metaspace] GC(15) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.403s][info   ][gc          ] GC(15) Pause Young (Concurrent Start) (G1 Humongous Allocation) 1166M-&gt;955M(2048M) 4.199ms</span><br><span class="line">[0.403s][info   ][gc,cpu      ] GC(15) User=0.01s Sys=0.01s Real=0.00s</span><br><span class="line">[0.403s][info   ][gc          ] GC(16) Concurrent Undo Cycle</span><br><span class="line">[0.403s][info   ][gc,marking  ] GC(16) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.403s][info   ][gc,marking  ] GC(16) Concurrent Cleanup for Next Mark 0.040ms</span><br><span class="line">[0.403s][info   ][gc          ] GC(16) Concurrent Undo Cycle 0.103ms</span><br><span class="line">[0.407s][info   ][gc,start    ] GC(17) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.407s][info   ][gc,task     ] GC(17) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.410s][info   ][gc,phases   ] GC(17)   Pre Evacuate Collection Set: 0.4ms</span><br><span class="line">[0.410s][info   ][gc,phases   ] GC(17)   Merge Heap Roots: 0.0ms</span><br><span class="line">[0.410s][info   ][gc,phases   ] GC(17)   Evacuate Collection Set: 2.3ms</span><br><span class="line">[0.410s][info   ][gc,phases   ] GC(17)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.410s][info   ][gc,phases   ] GC(17)   Other: 0.1ms</span><br><span class="line">[0.410s][info   ][gc,heap     ] GC(17) Eden regions: 50-&gt;0(480)</span><br><span class="line">[0.410s][info   ][gc,heap     ] GC(17) Survivor regions: 65-&gt;21(75)</span><br><span class="line">[0.410s][info   ][gc,heap     ] GC(17) Old regions: 719-&gt;781</span><br><span class="line">[0.410s][info   ][gc,heap     ] GC(17) Archive regions: 2-&gt;2</span><br><span class="line">[0.410s][info   ][gc,heap     ] GC(17) Humongous regions: 201-&gt;168</span><br><span class="line">[0.410s][info   ][gc,metaspace] GC(17) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.410s][info   ][gc          ] GC(17) Pause Young (Concurrent Start) (G1 Humongous Allocation) 1034M-&gt;969M(2048M) 3.196ms</span><br><span class="line">[0.410s][info   ][gc,cpu      ] GC(17) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">[0.411s][info   ][gc          ] GC(18) Concurrent Mark Cycle</span><br><span class="line">[0.411s][info   ][gc,marking  ] GC(18) Concurrent Clear Claimed Marks</span><br><span class="line">[0.411s][info   ][gc,marking  ] GC(18) Concurrent Clear Claimed Marks 0.010ms</span><br><span class="line">[0.411s][info   ][gc,marking  ] GC(18) Concurrent Scan Root Regions</span><br><span class="line">[0.411s][info   ][gc,marking  ] GC(18) Concurrent Scan Root Regions 0.201ms</span><br><span class="line">[0.411s][info   ][gc,marking  ] GC(18) Concurrent Mark</span><br><span class="line">[0.411s][info   ][gc,marking  ] GC(18) Concurrent Mark From Roots</span><br><span class="line">[0.411s][info   ][gc,task     ] GC(18) Using 2 workers of 2 for marking</span><br><span class="line">[0.413s][info   ][gc,marking  ] GC(18) Concurrent Mark From Roots 2.107ms</span><br><span class="line">[0.413s][info   ][gc,marking  ] GC(18) Concurrent Preclean</span><br><span class="line">[0.413s][info   ][gc,marking  ] GC(18) Concurrent Preclean 0.012ms</span><br><span class="line">[0.413s][info   ][gc,start    ] GC(18) Pause Remark</span><br><span class="line">[0.414s][info   ][gc          ] GC(18) Pause Remark 1023M-&gt;718M(2048M) 0.519ms</span><br><span class="line">[0.414s][info   ][gc,cpu      ] GC(18) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.414s][info   ][gc,marking  ] GC(18) Concurrent Mark 2.960ms</span><br><span class="line">[0.414s][info   ][gc,marking  ] GC(18) Concurrent Rebuild Remembered Sets</span><br><span class="line">[0.415s][info   ][gc,marking  ] GC(18) Concurrent Rebuild Remembered Sets 1.016ms</span><br><span class="line">[0.415s][info   ][gc,start    ] GC(18) Pause Cleanup</span><br><span class="line">[0.415s][info   ][gc          ] GC(18) Pause Cleanup 734M-&gt;734M(2048M) 0.311ms</span><br><span class="line">[0.415s][info   ][gc,cpu      ] GC(18) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.415s][info   ][gc,marking  ] GC(18) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.420s][info   ][gc,marking  ] GC(18) Concurrent Cleanup for Next Mark 4.259ms</span><br><span class="line">[0.420s][info   ][gc          ] GC(18) Concurrent Mark Cycle 9.130ms</span><br><span class="line">[0.450s][info   ][gc,start    ] GC(19) Pause Young (Prepare Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.450s][info   ][gc,task     ] GC(19) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.459s][info   ][gc,phases   ] GC(19)   Pre Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.459s][info   ][gc,phases   ] GC(19)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.459s][info   ][gc,phases   ] GC(19)   Evacuate Collection Set: 7.8ms</span><br><span class="line">[0.459s][info   ][gc,phases   ] GC(19)   Post Evacuate Collection Set: 0.8ms</span><br><span class="line">[0.459s][info   ][gc,phases   ] GC(19)   Other: 0.1ms</span><br><span class="line">[0.459s][info   ][gc,heap     ] GC(19) Eden regions: 480-&gt;0(39)</span><br><span class="line">[0.459s][info   ][gc,heap     ] GC(19) Survivor regions: 21-&gt;63(63)</span><br><span class="line">[0.459s][info   ][gc,heap     ] GC(19) Old regions: 476-&gt;561</span><br><span class="line">[0.459s][info   ][gc,heap     ] GC(19) Archive regions: 2-&gt;2</span><br><span class="line">[0.459s][info   ][gc,heap     ] GC(19) Humongous regions: 466-&gt;178</span><br><span class="line">[0.459s][info   ][gc,metaspace] GC(19) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.459s][info   ][gc          ] GC(19) Pause Young (Prepare Mixed) (G1 Evacuation Pause) 1442M-&gt;802M(2048M) 9.293ms</span><br><span class="line">[0.459s][info   ][gc,cpu      ] GC(19) User=0.01s Sys=0.03s Real=0.01s</span><br><span class="line">[0.462s][info   ][gc,start    ] GC(20) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.463s][info   ][gc,task     ] GC(20) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.466s][info   ][gc,phases   ] GC(20)   Pre Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.466s][info   ][gc,phases   ] GC(20)   Merge Heap Roots: 0.3ms</span><br><span class="line">[0.466s][info   ][gc,phases   ] GC(20)   Evacuate Collection Set: 2.4ms</span><br><span class="line">[0.466s][info   ][gc,phases   ] GC(20)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.466s][info   ][gc,phases   ] GC(20)   Other: 0.0ms</span><br><span class="line">[0.466s][info   ][gc,heap     ] GC(20) Eden regions: 39-&gt;0(781)</span><br><span class="line">[0.466s][info   ][gc,heap     ] GC(20) Survivor regions: 63-&gt;13(13)</span><br><span class="line">[0.466s][info   ][gc,heap     ] GC(20) Old regions: 561-&gt;475</span><br><span class="line">[0.466s][info   ][gc,heap     ] GC(20) Archive regions: 2-&gt;2</span><br><span class="line">[0.466s][info   ][gc,heap     ] GC(20) Humongous regions: 206-&gt;186</span><br><span class="line">[0.466s][info   ][gc,metaspace] GC(20) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.466s][info   ][gc          ] GC(20) Pause Young (Mixed) (G1 Evacuation Pause) 869M-&gt;674M(2048M) 3.500ms</span><br><span class="line">[0.466s][info   ][gc,cpu      ] GC(20) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.499s][info   ][gc,start    ] GC(21) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.500s][info   ][gc,task     ] GC(21) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.504s][info   ][gc,phases   ] GC(21)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.504s][info   ][gc,phases   ] GC(21)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.504s][info   ][gc,phases   ] GC(21)   Evacuate Collection Set: 3.2ms</span><br><span class="line">[0.504s][info   ][gc,phases   ] GC(21)   Post Evacuate Collection Set: 0.5ms</span><br><span class="line">[0.504s][info   ][gc,phases   ] GC(21)   Other: 0.1ms</span><br><span class="line">[0.504s][info   ][gc,heap     ] GC(21) Eden regions: 443-&gt;0(595)</span><br><span class="line">[0.504s][info   ][gc,heap     ] GC(21) Survivor regions: 13-&gt;100(100)</span><br><span class="line">[0.504s][info   ][gc,heap     ] GC(21) Old regions: 475-&gt;511</span><br><span class="line">[0.504s][info   ][gc,heap     ] GC(21) Archive regions: 2-&gt;2</span><br><span class="line">[0.504s][info   ][gc,heap     ] GC(21) Humongous regions: 444-&gt;198</span><br><span class="line">[0.504s][info   ][gc,metaspace] GC(21) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.504s][info   ][gc          ] GC(21) Pause Young (Concurrent Start) (G1 Humongous Allocation) 1374M-&gt;809M(2048M) 4.400ms</span><br><span class="line">[0.504s][info   ][gc,cpu      ] GC(21) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.504s][info   ][gc          ] GC(22) Concurrent Undo Cycle</span><br><span class="line">[0.504s][info   ][gc,marking  ] GC(22) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.504s][info   ][gc,marking  ] GC(22) Concurrent Cleanup for Next Mark 0.055ms</span><br><span class="line">[0.504s][info   ][gc          ] GC(22) Concurrent Undo Cycle 0.096ms</span><br><span class="line">[0.529s][info   ][gc,start    ] GC(23) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.529s][info   ][gc,task     ] GC(23) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.533s][info   ][gc,phases   ] GC(23)   Pre Evacuate Collection Set: 0.4ms</span><br><span class="line">[0.533s][info   ][gc,phases   ] GC(23)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.533s][info   ][gc,phases   ] GC(23)   Evacuate Collection Set: 3.4ms</span><br><span class="line">[0.533s][info   ][gc,phases   ] GC(23)   Post Evacuate Collection Set: 0.4ms</span><br><span class="line">[0.533s][info   ][gc,phases   ] GC(23)   Other: 0.1ms</span><br><span class="line">[0.533s][info   ][gc,heap     ] GC(23) Eden regions: 318-&gt;0(575)</span><br><span class="line">[0.533s][info   ][gc,heap     ] GC(23) Survivor regions: 100-&gt;87(87)</span><br><span class="line">[0.534s][info   ][gc,heap     ] GC(23) Old regions: 511-&gt;582</span><br><span class="line">[0.534s][info   ][gc,heap     ] GC(23) Archive regions: 2-&gt;2</span><br><span class="line">[0.534s][info   ][gc,heap     ] GC(23) Humongous regions: 408-&gt;210</span><br><span class="line">[0.534s][info   ][gc,metaspace] GC(23) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.534s][info   ][gc          ] GC(23) Pause Young (Concurrent Start) (G1 Humongous Allocation) 1336M-&gt;879M(2048M) 4.439ms</span><br><span class="line">[0.534s][info   ][gc,cpu      ] GC(23) User=0.02s Sys=0.01s Real=0.00s</span><br><span class="line">[0.534s][info   ][gc          ] GC(24) Concurrent Undo Cycle</span><br><span class="line">[0.534s][info   ][gc,marking  ] GC(24) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.534s][info   ][gc,marking  ] GC(24) Concurrent Cleanup for Next Mark 0.045ms</span><br><span class="line">[0.534s][info   ][gc          ] GC(24) Concurrent Undo Cycle 0.111ms</span><br><span class="line">[0.550s][info   ][gc,start    ] GC(25) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.550s][info   ][gc,task     ] GC(25) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.553s][info   ][gc,phases   ] GC(25)   Pre Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.553s][info   ][gc,phases   ] GC(25)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.553s][info   ][gc,phases   ] GC(25)   Evacuate Collection Set: 2.6ms</span><br><span class="line">[0.553s][info   ][gc,phases   ] GC(25)   Post Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.553s][info   ][gc,phases   ] GC(25)   Other: 0.1ms</span><br><span class="line">[0.553s][info   ][gc,heap     ] GC(25) Eden regions: 208-&gt;0(481)</span><br><span class="line">[0.553s][info   ][gc,heap     ] GC(25) Survivor regions: 87-&gt;74(83)</span><br><span class="line">[0.553s][info   ][gc,heap     ] GC(25) Old regions: 582-&gt;642</span><br><span class="line">[0.553s][info   ][gc,heap     ] GC(25) Archive regions: 2-&gt;2</span><br><span class="line">[0.553s][info   ][gc,heap     ] GC(25) Humongous regions: 337-&gt;194</span><br><span class="line">[0.553s][info   ][gc,metaspace] GC(25) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.553s][info   ][gc          ] GC(25) Pause Young (Concurrent Start) (G1 Humongous Allocation) 1214M-&gt;909M(2048M) 3.585ms</span><br><span class="line">[0.553s][info   ][gc,cpu      ] GC(25) User=0.02s Sys=0.00s Real=0.00s</span><br><span class="line">[0.553s][info   ][gc          ] GC(26) Concurrent Undo Cycle</span><br><span class="line">[0.553s][info   ][gc,marking  ] GC(26) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.553s][info   ][gc,marking  ] GC(26) Concurrent Cleanup for Next Mark 0.045ms</span><br><span class="line">[0.553s][info   ][gc          ] GC(26) Concurrent Undo Cycle 0.128ms</span><br><span class="line">[0.565s][info   ][gc,start    ] GC(27) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.565s][info   ][gc,task     ] GC(27) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.568s][info   ][gc,phases   ] GC(27)   Pre Evacuate Collection Set: 0.4ms</span><br><span class="line">[0.568s][info   ][gc,phases   ] GC(27)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.568s][info   ][gc,phases   ] GC(27)   Evacuate Collection Set: 2.2ms</span><br><span class="line">[0.568s][info   ][gc,phases   ] GC(27)   Post Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.568s][info   ][gc,phases   ] GC(27)   Other: 0.1ms</span><br><span class="line">[0.568s][info   ][gc,heap     ] GC(27) Eden regions: 156-&gt;0(503)</span><br><span class="line">[0.568s][info   ][gc,heap     ] GC(27) Survivor regions: 74-&gt;59(70)</span><br><span class="line">[0.568s][info   ][gc,heap     ] GC(27) Old regions: 642-&gt;699</span><br><span class="line">[0.568s][info   ][gc,heap     ] GC(27) Archive regions: 2-&gt;2</span><br><span class="line">[0.568s][info   ][gc,heap     ] GC(27) Humongous regions: 277-&gt;176</span><br><span class="line">[0.568s][info   ][gc,metaspace] GC(27) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.568s][info   ][gc          ] GC(27) Pause Young (Concurrent Start) (G1 Humongous Allocation) 1148M-&gt;934M(2048M) 3.315ms</span><br><span class="line">[0.568s][info   ][gc,cpu      ] GC(27) User=0.01s Sys=0.01s Real=0.01s</span><br><span class="line">[0.568s][info   ][gc          ] GC(28) Concurrent Undo Cycle</span><br><span class="line">[0.568s][info   ][gc,marking  ] GC(28) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.568s][info   ][gc,marking  ] GC(28) Concurrent Cleanup for Next Mark 0.045ms</span><br><span class="line">[0.568s][info   ][gc          ] GC(28) Concurrent Undo Cycle 0.075ms</span><br><span class="line">[0.573s][info   ][gc,start    ] GC(29) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.573s][info   ][gc,task     ] GC(29) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.576s][info   ][gc,phases   ] GC(29)   Pre Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.576s][info   ][gc,phases   ] GC(29)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.576s][info   ][gc,phases   ] GC(29)   Evacuate Collection Set: 1.8ms</span><br><span class="line">[0.576s][info   ][gc,phases   ] GC(29)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.576s][info   ][gc,phases   ] GC(29)   Other: 0.1ms</span><br><span class="line">[0.576s][info   ][gc,heap     ] GC(29) Eden regions: 76-&gt;0(497)</span><br><span class="line">[0.576s][info   ][gc,heap     ] GC(29) Survivor regions: 59-&gt;31(71)</span><br><span class="line">[0.576s][info   ][gc,heap     ] GC(29) Old regions: 699-&gt;752</span><br><span class="line">[0.576s][info   ][gc,heap     ] GC(29) Archive regions: 2-&gt;2</span><br><span class="line">[0.576s][info   ][gc,heap     ] GC(29) Humongous regions: 221-&gt;180</span><br><span class="line">[0.576s][info   ][gc,metaspace] GC(29) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.576s][info   ][gc          ] GC(29) Pause Young (Concurrent Start) (G1 Humongous Allocation) 1055M-&gt;963M(2048M) 2.640ms</span><br><span class="line">[0.576s][info   ][gc,cpu      ] GC(29) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.576s][info   ][gc          ] GC(30) Concurrent Mark Cycle</span><br><span class="line">[0.576s][info   ][gc,marking  ] GC(30) Concurrent Clear Claimed Marks</span><br><span class="line">[0.576s][info   ][gc,marking  ] GC(30) Concurrent Clear Claimed Marks 0.016ms</span><br><span class="line">[0.576s][info   ][gc,marking  ] GC(30) Concurrent Scan Root Regions</span><br><span class="line">[0.576s][info   ][gc,marking  ] GC(30) Concurrent Scan Root Regions 0.091ms</span><br><span class="line">[0.576s][info   ][gc,marking  ] GC(30) Concurrent Mark</span><br><span class="line">[0.576s][info   ][gc,marking  ] GC(30) Concurrent Mark From Roots</span><br><span class="line">[0.576s][info   ][gc,task     ] GC(30) Using 2 workers of 2 for marking</span><br><span class="line">[0.577s][info   ][gc,marking  ] GC(30) Concurrent Mark From Roots 1.154ms</span><br><span class="line">[0.577s][info   ][gc,marking  ] GC(30) Concurrent Preclean</span><br><span class="line">[0.577s][info   ][gc,marking  ] GC(30) Concurrent Preclean 0.010ms</span><br><span class="line">[0.578s][info   ][gc,start    ] GC(30) Pause Remark</span><br><span class="line">[0.578s][info   ][gc          ] GC(30) Pause Remark 991M-&gt;706M(2048M) 0.534ms</span><br><span class="line">[0.578s][info   ][gc,cpu      ] GC(30) User=0.00s Sys=0.00s Real=0.01s</span><br><span class="line">[0.578s][info   ][gc,marking  ] GC(30) Concurrent Mark 1.971ms</span><br><span class="line">[0.578s][info   ][gc,marking  ] GC(30) Concurrent Rebuild Remembered Sets</span><br><span class="line">[0.579s][info   ][gc,marking  ] GC(30) Concurrent Rebuild Remembered Sets 1.040ms</span><br><span class="line">[0.579s][info   ][gc,start    ] GC(30) Pause Cleanup</span><br><span class="line">[0.580s][info   ][gc          ] GC(30) Pause Cleanup 721M-&gt;721M(2048M) 0.344ms</span><br><span class="line">[0.580s][info   ][gc,cpu      ] GC(30) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.580s][info   ][gc,marking  ] GC(30) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.582s][info   ][gc,marking  ] GC(30) Concurrent Cleanup for Next Mark 2.087ms</span><br><span class="line">[0.582s][info   ][gc          ] GC(30) Concurrent Mark Cycle 5.913ms</span><br><span class="line">[0.617s][info   ][gc,start    ] GC(31) Pause Young (Prepare Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.617s][info   ][gc,task     ] GC(31) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.625s][info   ][gc,phases   ] GC(31)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.625s][info   ][gc,phases   ] GC(31)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.625s][info   ][gc,phases   ] GC(31)   Evacuate Collection Set: 7.3ms</span><br><span class="line">[0.625s][info   ][gc,phases   ] GC(31)   Post Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.625s][info   ][gc,phases   ] GC(31)   Other: 0.1ms</span><br><span class="line">[0.625s][info   ][gc,heap     ] GC(31) Eden regions: 497-&gt;0(36)</span><br><span class="line">[0.625s][info   ][gc,heap     ] GC(31) Survivor regions: 31-&gt;66(66)</span><br><span class="line">[0.625s][info   ][gc,heap     ] GC(31) Old regions: 467-&gt;556</span><br><span class="line">[0.625s][info   ][gc,heap     ] GC(31) Archive regions: 2-&gt;2</span><br><span class="line">[0.625s][info   ][gc,heap     ] GC(31) Humongous regions: 467-&gt;177</span><br><span class="line">[0.625s][info   ][gc,metaspace] GC(31) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.625s][info   ][gc          ] GC(31) Pause Young (Prepare Mixed) (G1 Evacuation Pause) 1462M-&gt;799M(2048M) 8.309ms</span><br><span class="line">[0.625s][info   ][gc,cpu      ] GC(31) User=0.02s Sys=0.03s Real=0.01s</span><br><span class="line">[0.628s][info   ][gc,start    ] GC(32) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.628s][info   ][gc,task     ] GC(32) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.631s][info   ][gc,phases   ] GC(32)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.631s][info   ][gc,phases   ] GC(32)   Merge Heap Roots: 0.2ms</span><br><span class="line">[0.631s][info   ][gc,phases   ] GC(32)   Evacuate Collection Set: 2.5ms</span><br><span class="line">[0.631s][info   ][gc,phases   ] GC(32)   Post Evacuate Collection Set: 0.4ms</span><br><span class="line">[0.631s][info   ][gc,phases   ] GC(32)   Other: 0.1ms</span><br><span class="line">[0.631s][info   ][gc,heap     ] GC(32) Eden regions: 36-&gt;0(820)</span><br><span class="line">[0.631s][info   ][gc,heap     ] GC(32) Survivor regions: 66-&gt;13(13)</span><br><span class="line">[0.631s][info   ][gc,heap     ] GC(32) Old regions: 556-&gt;459</span><br><span class="line">[0.631s][info   ][gc,heap     ] GC(32) Archive regions: 2-&gt;2</span><br><span class="line">[0.631s][info   ][gc,heap     ] GC(32) Humongous regions: 193-&gt;172</span><br><span class="line">[0.631s][info   ][gc,metaspace] GC(32) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.632s][info   ][gc          ] GC(32) Pause Young (Mixed) (G1 Evacuation Pause) 851M-&gt;644M(2048M) 3.482ms</span><br><span class="line">[0.632s][info   ][gc,cpu      ] GC(32) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.666s][info   ][gc,start    ] GC(33) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.666s][info   ][gc,task     ] GC(33) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.670s][info   ][gc,phases   ] GC(33)   Pre Evacuate Collection Set: 0.4ms</span><br><span class="line">[0.670s][info   ][gc,phases   ] GC(33)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.670s][info   ][gc,phases   ] GC(33)   Evacuate Collection Set: 2.9ms</span><br><span class="line">[0.670s][info   ][gc,phases   ] GC(33)   Post Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.670s][info   ][gc,phases   ] GC(33)   Other: 0.1ms</span><br><span class="line">[0.670s][info   ][gc,heap     ] GC(33) Eden regions: 462-&gt;0(690)</span><br><span class="line">[0.670s][info   ][gc,heap     ] GC(33) Survivor regions: 13-&gt;105(105)</span><br><span class="line">[0.670s][info   ][gc,heap     ] GC(33) Old regions: 459-&gt;500</span><br><span class="line">[0.670s][info   ][gc,heap     ] GC(33) Archive regions: 2-&gt;2</span><br><span class="line">[0.670s][info   ][gc,heap     ] GC(33) Humongous regions: 461-&gt;174</span><br><span class="line">[0.670s][info   ][gc,metaspace] GC(33) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.670s][info   ][gc          ] GC(33) Pause Young (Concurrent Start) (G1 Humongous Allocation) 1395M-&gt;779M(2048M) 3.997ms</span><br><span class="line">[0.670s][info   ][gc,cpu      ] GC(33) User=0.02s Sys=0.01s Real=0.01s</span><br><span class="line">[0.670s][info   ][gc          ] GC(34) Concurrent Undo Cycle</span><br><span class="line">[0.670s][info   ][gc,marking  ] GC(34) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.670s][info   ][gc,marking  ] GC(34) Concurrent Cleanup for Next Mark 0.061ms</span><br><span class="line">[0.670s][info   ][gc          ] GC(34) Concurrent Undo Cycle 0.166ms</span><br><span class="line">[0.705s][info   ][gc,start    ] GC(35) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.705s][info   ][gc,task     ] GC(35) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.716s][info   ][gc,phases   ] GC(35)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.716s][info   ][gc,phases   ] GC(35)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.716s][info   ][gc,phases   ] GC(35)   Evacuate Collection Set: 10.9ms</span><br><span class="line">[0.716s][info   ][gc,phases   ] GC(35)   Post Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.716s][info   ][gc,phases   ] GC(35)   Other: 0.1ms</span><br><span class="line">[0.716s][info   ][gc,heap     ] GC(35) Eden regions: 445-&gt;0(576)</span><br><span class="line">[0.717s][info   ][gc,heap     ] GC(35) Survivor regions: 105-&gt;100(100)</span><br><span class="line">[0.717s][info   ][gc,heap     ] GC(35) Old regions: 500-&gt;573</span><br><span class="line">[0.717s][info   ][gc,heap     ] GC(35) Archive regions: 2-&gt;2</span><br><span class="line">[0.717s][info   ][gc,heap     ] GC(35) Humongous regions: 419-&gt;187</span><br><span class="line">[0.717s][info   ][gc,metaspace] GC(35) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.717s][info   ][gc          ] GC(35) Pause Young (Concurrent Start) (G1 Humongous Allocation) 1469M-&gt;860M(2048M) 11.856ms</span><br><span class="line">[0.717s][info   ][gc,cpu      ] GC(35) User=0.02s Sys=0.03s Real=0.01s</span><br><span class="line">[0.717s][info   ][gc          ] GC(36) Concurrent Undo Cycle</span><br><span class="line">[0.717s][info   ][gc,marking  ] GC(36) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.717s][info   ][gc,marking  ] GC(36) Concurrent Cleanup for Next Mark 0.094ms</span><br><span class="line">[0.717s][info   ][gc          ] GC(36) Concurrent Undo Cycle 0.193ms</span><br><span class="line">[0.742s][info   ][gc,start    ] GC(37) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.742s][info   ][gc,task     ] GC(37) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.746s][info   ][gc,phases   ] GC(37)   Pre Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.746s][info   ][gc,phases   ] GC(37)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.746s][info   ][gc,phases   ] GC(37)   Evacuate Collection Set: 3.7ms</span><br><span class="line">[0.746s][info   ][gc,phases   ] GC(37)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.746s][info   ][gc,phases   ] GC(37)   Other: 0.1ms</span><br><span class="line">[0.746s][info   ][gc,heap     ] GC(37) Eden regions: 261-&gt;0(567)</span><br><span class="line">[0.746s][info   ][gc,heap     ] GC(37) Survivor regions: 100-&gt;85(85)</span><br><span class="line">[0.746s][info   ][gc,heap     ] GC(37) Old regions: 573-&gt;640</span><br><span class="line">[0.746s][info   ][gc,heap     ] GC(37) Archive regions: 2-&gt;2</span><br><span class="line">[0.746s][info   ][gc,heap     ] GC(37) Humongous regions: 346-&gt;184</span><br><span class="line">[0.746s][info   ][gc,metaspace] GC(37) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.746s][info   ][gc          ] GC(37) Pause Young (Concurrent Start) (G1 Humongous Allocation) 1280M-&gt;909M(2048M) 4.706ms</span><br><span class="line">[0.746s][info   ][gc,cpu      ] GC(37) User=0.02s Sys=0.01s Real=0.00s</span><br><span class="line">[0.746s][info   ][gc          ] GC(38) Concurrent Undo Cycle</span><br><span class="line">[0.747s][info   ][gc,marking  ] GC(38) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.747s][info   ][gc,marking  ] GC(38) Concurrent Cleanup for Next Mark 0.063ms</span><br><span class="line">[0.747s][info   ][gc          ] GC(38) Concurrent Undo Cycle 0.109ms</span><br><span class="line">[0.759s][info   ][gc,start    ] GC(39) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.760s][info   ][gc,task     ] GC(39) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.763s][info   ][gc,phases   ] GC(39)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.763s][info   ][gc,phases   ] GC(39)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.763s][info   ][gc,phases   ] GC(39)   Evacuate Collection Set: 2.5ms</span><br><span class="line">[0.763s][info   ][gc,phases   ] GC(39)   Post Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.763s][info   ][gc,phases   ] GC(39)   Other: 0.1ms</span><br><span class="line">[0.763s][info   ][gc,heap     ] GC(39) Eden regions: 180-&gt;0(564)</span><br><span class="line">[0.763s][info   ][gc,heap     ] GC(39) Survivor regions: 85-&gt;66(82)</span><br><span class="line">[0.763s][info   ][gc,heap     ] GC(39) Old regions: 640-&gt;698</span><br><span class="line">[0.763s][info   ][gc,heap     ] GC(39) Archive regions: 2-&gt;2</span><br><span class="line">[0.763s][info   ][gc,heap     ] GC(39) Humongous regions: 279-&gt;173</span><br><span class="line">[0.763s][info   ][gc,metaspace] GC(39) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.763s][info   ][gc          ] GC(39) Pause Young (Concurrent Start) (G1 Humongous Allocation) 1183M-&gt;937M(2048M) 3.421ms</span><br><span class="line">[0.763s][info   ][gc,cpu      ] GC(39) User=0.01s Sys=0.00s Real=0.00s</span><br><span class="line">[0.763s][info   ][gc          ] GC(40) Concurrent Undo Cycle</span><br><span class="line">[0.763s][info   ][gc,marking  ] GC(40) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.763s][info   ][gc,marking  ] GC(40) Concurrent Cleanup for Next Mark 0.043ms</span><br><span class="line">[0.763s][info   ][gc          ] GC(40) Concurrent Undo Cycle 0.118ms</span><br><span class="line">[0.770s][info   ][gc,start    ] GC(41) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.770s][info   ][gc,task     ] GC(41) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.773s][info   ][gc,phases   ] GC(41)   Pre Evacuate Collection Set: 0.4ms</span><br><span class="line">[0.773s][info   ][gc,phases   ] GC(41)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.773s][info   ][gc,phases   ] GC(41)   Evacuate Collection Set: 2.3ms</span><br><span class="line">[0.773s][info   ][gc,phases   ] GC(41)   Post Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.773s][info   ][gc,phases   ] GC(41)   Other: 0.1ms</span><br><span class="line">[0.773s][info   ][gc,heap     ] GC(41) Eden regions: 96-&gt;0(449)</span><br><span class="line">[0.773s][info   ][gc,heap     ] GC(41) Survivor regions: 66-&gt;38(79)</span><br><span class="line">[0.773s][info   ][gc,heap     ] GC(41) Old regions: 698-&gt;757</span><br><span class="line">[0.773s][info   ][gc,heap     ] GC(41) Archive regions: 2-&gt;2</span><br><span class="line">[0.773s][info   ][gc,heap     ] GC(41) Humongous regions: 221-&gt;164</span><br><span class="line">[0.773s][info   ][gc,metaspace] GC(41) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.773s][info   ][gc          ] GC(41) Pause Young (Concurrent Start) (G1 Humongous Allocation) 1080M-&gt;958M(2048M) 3.213ms</span><br><span class="line">[0.773s][info   ][gc,cpu      ] GC(41) User=0.00s Sys=0.01s Real=0.00s</span><br><span class="line">[0.773s][info   ][gc          ] GC(42) Concurrent Mark Cycle</span><br><span class="line">[0.773s][info   ][gc,marking  ] GC(42) Concurrent Clear Claimed Marks</span><br><span class="line">[0.773s][info   ][gc,marking  ] GC(42) Concurrent Clear Claimed Marks 0.022ms</span><br><span class="line">[0.774s][info   ][gc,marking  ] GC(42) Concurrent Scan Root Regions</span><br><span class="line">[0.774s][info   ][gc,marking  ] GC(42) Concurrent Scan Root Regions 0.137ms</span><br><span class="line">[0.774s][info   ][gc,marking  ] GC(42) Concurrent Mark</span><br><span class="line">[0.774s][info   ][gc,marking  ] GC(42) Concurrent Mark From Roots</span><br><span class="line">[0.774s][info   ][gc,task     ] GC(42) Using 2 workers of 2 for marking</span><br><span class="line">[0.775s][info   ][gc,marking  ] GC(42) Concurrent Mark From Roots 1.130ms</span><br><span class="line">[0.775s][info   ][gc,marking  ] GC(42) Concurrent Preclean</span><br><span class="line">[0.775s][info   ][gc,marking  ] GC(42) Concurrent Preclean 0.008ms</span><br><span class="line">[0.775s][info   ][gc,start    ] GC(42) Pause Remark</span><br><span class="line">[0.775s][info   ][gc          ] GC(42) Pause Remark 991M-&gt;661M(2048M) 0.501ms</span><br><span class="line">[0.775s][info   ][gc,cpu      ] GC(42) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.775s][info   ][gc,marking  ] GC(42) Concurrent Mark 1.819ms</span><br><span class="line">[0.775s][info   ][gc,marking  ] GC(42) Concurrent Rebuild Remembered Sets</span><br><span class="line">[0.776s][info   ][gc,marking  ] GC(42) Concurrent Rebuild Remembered Sets 0.885ms</span><br><span class="line">[0.776s][info   ][gc,start    ] GC(42) Pause Cleanup</span><br><span class="line">[0.777s][info   ][gc          ] GC(42) Pause Cleanup 683M-&gt;683M(2048M) 0.310ms</span><br><span class="line">[0.777s][info   ][gc,cpu      ] GC(42) User=0.00s Sys=0.00s Real=0.00s</span><br><span class="line">[0.777s][info   ][gc,marking  ] GC(42) Concurrent Cleanup for Next Mark</span><br><span class="line">[0.778s][info   ][gc,marking  ] GC(42) Concurrent Cleanup for Next Mark 1.485ms</span><br><span class="line">[0.778s][info   ][gc          ] GC(42) Concurrent Mark Cycle 4.979ms</span><br><span class="line">[0.807s][info   ][gc,start    ] GC(43) Pause Young (Prepare Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.807s][info   ][gc,task     ] GC(43) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.811s][info   ][gc,phases   ] GC(43)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.811s][info   ][gc,phases   ] GC(43)   Merge Heap Roots: 0.2ms</span><br><span class="line">[0.811s][info   ][gc,phases   ] GC(43)   Evacuate Collection Set: 3.1ms</span><br><span class="line">[0.811s][info   ][gc,phases   ] GC(43)   Post Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.811s][info   ][gc,phases   ] GC(43)   Other: 0.1ms</span><br><span class="line">[0.811s][info   ][gc,heap     ] GC(43) Eden regions: 449-&gt;0(41)</span><br><span class="line">[0.811s][info   ][gc,heap     ] GC(43) Survivor regions: 38-&gt;61(61)</span><br><span class="line">[0.811s][info   ][gc,heap     ] GC(43) Old regions: 427-&gt;520</span><br><span class="line">[0.811s][info   ][gc,heap     ] GC(43) Archive regions: 2-&gt;2</span><br><span class="line">[0.811s][info   ][gc,heap     ] GC(43) Humongous regions: 398-&gt;163</span><br><span class="line">[0.811s][info   ][gc,metaspace] GC(43) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.811s][info   ][gc          ] GC(43) Pause Young (Prepare Mixed) (G1 Evacuation Pause) 1311M-&gt;744M(2048M) 4.128ms</span><br><span class="line">[0.811s][info   ][gc,cpu      ] GC(43) User=0.02s Sys=0.00s Real=0.01s</span><br><span class="line">[0.814s][info   ][gc,start    ] GC(44) Pause Young (Mixed) (G1 Evacuation Pause)</span><br><span class="line">[0.814s][info   ][gc,task     ] GC(44) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.817s][info   ][gc,phases   ] GC(44)   Pre Evacuate Collection Set: 0.1ms</span><br><span class="line">[0.817s][info   ][gc,phases   ] GC(44)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.817s][info   ][gc,phases   ] GC(44)   Evacuate Collection Set: 1.9ms</span><br><span class="line">[0.817s][info   ][gc,phases   ] GC(44)   Post Evacuate Collection Set: 0.3ms</span><br><span class="line">[0.817s][info   ][gc,phases   ] GC(44)   Other: 0.0ms</span><br><span class="line">[0.817s][info   ][gc,heap     ] GC(44) Eden regions: 41-&gt;0(622)</span><br><span class="line">[0.817s][info   ][gc,heap     ] GC(44) Survivor regions: 61-&gt;13(13)</span><br><span class="line">[0.817s][info   ][gc,heap     ] GC(44) Old regions: 520-&gt;456</span><br><span class="line">[0.817s][info   ][gc,heap     ] GC(44) Archive regions: 2-&gt;2</span><br><span class="line">[0.817s][info   ][gc,heap     ] GC(44) Humongous regions: 181-&gt;162</span><br><span class="line">[0.817s][info   ][gc,metaspace] GC(44) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.817s][info   ][gc          ] GC(44) Pause Young (Mixed) (G1 Evacuation Pause) 803M-&gt;631M(2048M) 2.566ms</span><br><span class="line">[0.817s][info   ][gc,cpu      ] GC(44) User=0.01s Sys=0.01s Real=0.00s</span><br><span class="line">[0.865s][info   ][gc,start    ] GC(45) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.865s][info   ][gc,task     ] GC(45) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.888s][info   ][gc,phases   ] GC(45)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.888s][info   ][gc,phases   ] GC(45)   Merge Heap Roots: 0.2ms</span><br><span class="line">[0.888s][info   ][gc,phases   ] GC(45)   Evacuate Collection Set: 21.7ms</span><br><span class="line">[0.888s][info   ][gc,phases   ] GC(45)   Post Evacuate Collection Set: 0.5ms</span><br><span class="line">[0.888s][info   ][gc,phases   ] GC(45)   Other: 0.1ms</span><br><span class="line">[0.888s][info   ][gc,heap     ] GC(45) Eden regions: 622-&gt;0(566)</span><br><span class="line">[0.888s][info   ][gc,heap     ] GC(45) Survivor regions: 13-&gt;80(80)</span><br><span class="line">[0.888s][info   ][gc,heap     ] GC(45) Old regions: 456-&gt;547</span><br><span class="line">[0.888s][info   ][gc,heap     ] GC(45) Archive regions: 2-&gt;2</span><br><span class="line">[0.888s][info   ][gc,heap     ] GC(45) Humongous regions: 525-&gt;168</span><br><span class="line">[0.888s][info   ][gc,metaspace] GC(45) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.888s][info   ][gc          ] GC(45) Pause Young (Normal) (G1 Evacuation Pause) 1616M-&gt;795M(2048M) 22.840ms</span><br><span class="line">[0.888s][info   ][gc,cpu      ] GC(45) User=0.02s Sys=0.05s Real=0.02s</span><br><span class="line">[0.936s][info   ][gc,start    ] GC(46) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[0.936s][info   ][gc,task     ] GC(46) Using 8 workers of 8 for evacuation</span><br><span class="line">[0.953s][info   ][gc,phases   ] GC(46)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[0.953s][info   ][gc,phases   ] GC(46)   Merge Heap Roots: 0.1ms</span><br><span class="line">[0.953s][info   ][gc,phases   ] GC(46)   Evacuate Collection Set: 16.1ms</span><br><span class="line">[0.953s][info   ][gc,phases   ] GC(46)   Post Evacuate Collection Set: 0.6ms</span><br><span class="line">[0.953s][info   ][gc,phases   ] GC(46)   Other: 0.1ms</span><br><span class="line">[0.953s][info   ][gc,heap     ] GC(46) Eden regions: 566-&gt;0(506)</span><br><span class="line">[0.953s][info   ][gc,heap     ] GC(46) Survivor regions: 80-&gt;81(81)</span><br><span class="line">[0.953s][info   ][gc,heap     ] GC(46) Old regions: 547-&gt;653</span><br><span class="line">[0.953s][info   ][gc,heap     ] GC(46) Archive regions: 2-&gt;2</span><br><span class="line">[0.953s][info   ][gc,heap     ] GC(46) Humongous regions: 487-&gt;173</span><br><span class="line">[0.953s][info   ][gc,metaspace] GC(46) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[0.953s][info   ][gc          ] GC(46) Pause Young (Normal) (G1 Evacuation Pause) 1680M-&gt;907M(2048M) 17.409ms</span><br><span class="line">[0.953s][info   ][gc,cpu      ] GC(46) User=0.02s Sys=0.05s Real=0.02s</span><br><span class="line">[0.993s][info   ][gc,start    ] GC(47) Pause Young (Concurrent Start) (G1 Humongous Allocation)</span><br><span class="line">[0.993s][info   ][gc,task     ] GC(47) Using 8 workers of 8 for evacuation</span><br><span class="line">[1.008s][info   ][gc,phases   ] GC(47)   Pre Evacuate Collection Set: 0.2ms</span><br><span class="line">[1.008s][info   ][gc,phases   ] GC(47)   Merge Heap Roots: 0.1ms</span><br><span class="line">[1.008s][info   ][gc,phases   ] GC(47)   Evacuate Collection Set: 13.5ms</span><br><span class="line">[1.008s][info   ][gc,phases   ] GC(47)   Post Evacuate Collection Set: 0.4ms</span><br><span class="line">[1.008s][info   ][gc,phases   ] GC(47)   Other: 0.1ms</span><br><span class="line">[1.008s][info   ][gc,heap     ] GC(47) Eden regions: 489-&gt;0(441)</span><br><span class="line">[1.008s][info   ][gc,heap     ] GC(47) Survivor regions: 81-&gt;74(74)</span><br><span class="line">[1.008s][info   ][gc,heap     ] GC(47) Old regions: 653-&gt;755</span><br><span class="line">[1.008s][info   ][gc,heap     ] GC(47) Archive regions: 2-&gt;2</span><br><span class="line">[1.008s][info   ][gc,heap     ] GC(47) Humongous regions: 460-&gt;205</span><br><span class="line">[1.008s][info   ][gc,metaspace] GC(47) Metaspace: 156K(384K)-&gt;156K(384K) NonClass: 150K(256K)-&gt;150K(256K) Class: 5K(128K)-&gt;5K(128K)</span><br><span class="line">[1.008s][info   ][gc          ] GC(47) Pause Young (Concurrent Start) (G1 Humongous Allocation) 1683M-&gt;1034M(2048M) 14.430ms</span><br><span class="line">[1.008s][info   ][gc,cpu      ] GC(47) User=0.01s Sys=0.04s Real=0.01s</span><br><span class="line">[1.008s][info   ][gc          ] GC(48) Concurrent Undo Cycle</span><br><span class="line">[1.008s][info   ][gc,marking  ] GC(48) Concurrent Cleanup for Next Mark</span><br><span class="line">[1.008s][info   ][gc,marking  ] GC(48) Concurrent Cleanup for Next Mark 0.182ms</span><br><span class="line">[1.008s][info   ][gc          ] GC(48) Concurrent Undo Cycle 0.325ms</span><br><span class="line">counter:56583</span><br><span class="line">[1.025s][info   ][gc,heap,exit] Heap</span><br><span class="line">[1.025s][info   ][gc,heap,exit]  garbage-first heap   total 2097152K, used 1275412K [0x0000000780000000, 0x0000000800000000)</span><br><span class="line">[1.025s][info   ][gc,heap,exit]   region size 1024K, 211 young (216064K), 74 survivors (75776K)</span><br><span class="line">[1.025s][info   ][gc,heap,exit]  Metaspace       used 236K, committed 448K, reserved 1114112K</span><br><span class="line">[1.025s][info   ][gc,heap,exit]   class space    used 9K, committed 128K, reserved 1048576K</span><br></pre></td></tr></table></figure>


<h4 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h4><p>专注于低延迟，目标是将 GC 停顿时间控制在 10ms 以下。支持非常大的堆内存（TB 级）。使用多线程并发回收，避免长时间的 STW。基于标记-整理算法，避免内存碎片化。使用指针染色（Pointer Coloring）来实现并发标记和引用更新。</p>
<p>-XX: +UnlockExpermentalVMOptions<br>-XX: +UseZGC<br>-XX: -Xmx16g</p>
<p>优点：</p>
<ul>
<li>极低的 GC 停顿时间。</li>
<li>支持超大堆，扩展性好。</li>
<li>减少内存碎片。</li>
<li>与G1相比，应用吞吐量下降不超过15%</li>
</ul>
<p>缺点：</p>
<ul>
<li>内存占用较高：由于需要染色指针和写屏障。</li>
<li>不适合资源紧张的环境。</li>
</ul>
<p>-XX: +UseShenandoahGC</p>
<p>立项比ZGC早，暂停时间与堆大小无关</p>
<p>适用场景：</p>
<ul>
<li>延迟敏感的大型应用（如金融交易、高并发系统）。</li>
<li>超大堆应用（TB 级别内存）。</li>
</ul>
<p>接下来试试 ZGC 128m内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+UseZGC -Xms128m -Xmx128m -XX:+PrintGCDetails -Xlog:gc\*:file=gc.log:time,uptime,level,tags GCLogAnalysis</span><br></pre></td></tr></table></figure>

<p>可以看到GC12次就出现了OOM，花了0.157s。和并行GC接近，比G1GC的GC次数少</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0.002s][warning][gc] -XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.</span><br><span class="line">[0.005s][info   ][gc,init] Initializing The Z Garbage Collector</span><br><span class="line">[0.006s][info   ][gc,init] Version: 19.0.2+7-44 (release)</span><br><span class="line">[0.006s][info   ][gc,init] NUMA Support: Disabled</span><br><span class="line">[0.006s][info   ][gc,init] CPUs: 8 total, 8 available</span><br><span class="line">[0.006s][info   ][gc,init] Memory: 16384M</span><br><span class="line">[0.006s][info   ][gc,init] Large Page Support: Disabled</span><br><span class="line">[0.006s][info   ][gc,init] GC Workers: 1 (dynamic)</span><br><span class="line">[0.006s][info   ][gc,init] Address Space Type: Contiguous/Unrestricted/Complete</span><br><span class="line">[0.006s][info   ][gc,init] Address Space Size: 2048M x 3 = 6144M</span><br><span class="line">[0.006s][info   ][gc,init] Min Capacity: 128M</span><br><span class="line">[0.006s][info   ][gc,init] Initial Capacity: 128M</span><br><span class="line">[0.006s][info   ][gc,init] Max Capacity: 128M</span><br><span class="line">[0.006s][info   ][gc,init] Medium Page Size: 4M</span><br><span class="line">[0.006s][info   ][gc,init] Pre-touch: Disabled</span><br><span class="line">[0.006s][info   ][gc,init] Uncommit: Implicitly Disabled (-Xms equals -Xmx)</span><br><span class="line">[0.006s][info   ][gc,init] Runtime Workers: 1</span><br><span class="line">[0.006s][info   ][gc     ] Using The Z Garbage Collector</span><br><span class="line">[0.006s][info   ][gc,metaspace] CDS archive(s) mapped at: [0x0000000800000000-0x0000000800c44000-0x0000000800c44000), size 12861440, SharedBaseAddress: 0x0000000800000000, ArchiveRelocationMode: 0.</span><br><span class="line">[0.006s][info   ][gc,metaspace] Compressed class space mapped at: 0x0000000801000000-0x0000000841000000, reserved size: 1073741824</span><br><span class="line">[0.006s][info   ][gc,metaspace] Narrow klass base: 0x0000000800000000, Narrow klass shift: 0, Narrow klass range: 0x100000000</span><br><span class="line">gc...</span><br><span class="line">[0.083s][info   ][gc,start    ] GC(0) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.083s][info   ][gc,ref      ] GC(0) Clearing All SoftReferences</span><br><span class="line">[0.083s][info   ][gc,task     ] GC(0) Using 1 workers</span><br><span class="line">[0.084s][info   ][gc,phases   ] GC(0) Pause Mark Start 0.012ms</span><br><span class="line">[0.087s][info   ][gc,phases   ] GC(0) Concurrent Mark 3.476ms</span><br><span class="line">[0.088s][info   ][gc,phases   ] GC(0) Pause Mark End 0.012ms</span><br><span class="line">[0.088s][info   ][gc,phases   ] GC(0) Concurrent Mark Free 0.001ms</span><br><span class="line">[0.088s][info   ][gc,phases   ] GC(0) Concurrent Process Non-Strong References 0.411ms</span><br><span class="line">[0.088s][info   ][gc,phases   ] GC(0) Concurrent Reset Relocation Set 0.000ms</span><br><span class="line">[0.095s][info   ][gc          ] Allocation Stall (main) 11.982ms</span><br><span class="line">[0.095s][info   ][gc,phases   ] GC(0) Concurrent Select Relocation Set 7.184ms</span><br><span class="line">[0.096s][info   ][gc,phases   ] GC(0) Pause Relocate Start 0.006ms</span><br><span class="line">[0.103s][info   ][gc,phases   ] GC(0) Concurrent Relocate 6.950ms</span><br><span class="line">[0.103s][info   ][gc,load     ] GC(0) Load: 4.33/4.72/4.91</span><br><span class="line">[0.103s][info   ][gc,mmu      ] GC(0) MMU: 2ms/99.4%, 5ms/99.5%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/100.0%</span><br><span class="line">[0.103s][info   ][gc,marking  ] GC(0) Mark: 1 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.103s][info   ][gc,marking  ] GC(0) Mark Stack Usage: 32M</span><br><span class="line">[0.103s][info   ][gc,nmethod  ] GC(0) NMethods: 112 registered, 0 unregistered</span><br><span class="line">[0.103s][info   ][gc,metaspace] GC(0) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.103s][info   ][gc,ref      ] GC(0) Soft: 5 encountered, 3 discovered, 2 enqueued</span><br><span class="line">[0.103s][info   ][gc,ref      ] GC(0) Weak: 26 encountered, 19 discovered, 3 enqueued</span><br><span class="line">[0.103s][info   ][gc,ref      ] GC(0) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.103s][info   ][gc,ref      ] GC(0) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.103s][info   ][gc,reloc    ] GC(0) Small Pages: 20 / 40M, Empty: 0M, Relocated: 12M, In-Place: 0</span><br><span class="line">[0.103s][info   ][gc,reloc    ] GC(0) Medium Pages: 5 / 20M, Empty: 0M, Relocated: 5M, In-Place: 0</span><br><span class="line">[0.103s][info   ][gc,reloc    ] GC(0) Large Pages: 34 / 68M, Empty: 38M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.103s][info   ][gc,reloc    ] GC(0) Forwarding Usage: 0M</span><br><span class="line">[0.103s][info   ][gc,heap     ] GC(0) Min Capacity: 128M(100%)</span><br><span class="line">[0.103s][info   ][gc,heap     ] GC(0) Max Capacity: 128M(100%)</span><br><span class="line">[0.103s][info   ][gc,heap     ] GC(0) Soft Max Capacity: 128M(100%)</span><br><span class="line">[0.103s][info   ][gc,heap     ] GC(0)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.103s][info   ][gc,heap     ] GC(0)  Capacity:      128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)</span><br><span class="line">[0.103s][info   ][gc,heap     ] GC(0)      Free:        0M (0%)            0M (0%)           36M (28%)          18M (14%)          42M (33%)           0M (0%)</span><br><span class="line">[0.103s][info   ][gc,heap     ] GC(0)      Used:      128M (100%)        128M (100%)         92M (72%)         110M (86%)         128M (100%)         86M (67%)</span><br><span class="line">[0.103s][info   ][gc,heap     ] GC(0)      Live:         -                49M (39%)          49M (39%)          49M (39%)            -                  -</span><br><span class="line">[0.103s][info   ][gc,heap     ] GC(0) Allocated:         -                 0M (0%)            2M (2%)           53M (42%)            -                  -</span><br><span class="line">[0.103s][info   ][gc,heap     ] GC(0)   Garbage:         -                78M (61%)          40M (31%)           6M (5%)             -                  -</span><br><span class="line">[0.103s][info   ][gc,heap     ] GC(0) Reclaimed:         -                  -                38M (30%)          71M (56%)            -                  -</span><br><span class="line">[0.103s][info   ][gc          ] GC(0) Garbage Collection (Allocation Stall) 128M(100%)-&gt;110M(86%)</span><br><span class="line">[0.105s][info   ][gc,start    ] GC(1) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.105s][info   ][gc,ref      ] GC(1) Clearing All SoftReferences</span><br><span class="line">[0.105s][info   ][gc,task     ] GC(1) Using 1 workers</span><br><span class="line">[0.105s][info   ][gc,phases   ] GC(1) Pause Mark Start 0.003ms</span><br><span class="line">[0.107s][info   ][gc,phases   ] GC(1) Concurrent Mark 2.000ms</span><br><span class="line">[0.107s][info   ][gc,phases   ] GC(1) Pause Mark End 0.005ms</span><br><span class="line">[0.107s][info   ][gc,phases   ] GC(1) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.108s][info   ][gc,phases   ] GC(1) Concurrent Process Non-Strong References 0.234ms</span><br><span class="line">[0.108s][info   ][gc,phases   ] GC(1) Concurrent Reset Relocation Set 0.001ms</span><br><span class="line">[0.111s][info   ][gc,phases   ] GC(1) Concurrent Select Relocation Set 3.769ms</span><br><span class="line">[0.111s][info   ][gc          ] Allocation Stall (main) 6.277ms</span><br><span class="line">[0.112s][info   ][gc,phases   ] GC(1) Pause Relocate Start 0.006ms</span><br><span class="line">[0.113s][info   ][gc,phases   ] GC(1) Concurrent Relocate 1.459ms</span><br><span class="line">[0.113s][info   ][gc,load     ] GC(1) Load: 4.33/4.72/4.91</span><br><span class="line">[0.113s][info   ][gc,mmu      ] GC(1) MMU: 2ms/99.4%, 5ms/99.5%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/100.0%</span><br><span class="line">[0.113s][info   ][gc,marking  ] GC(1) Mark: 1 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.113s][info   ][gc,marking  ] GC(1) Mark Stack Usage: 32M</span><br><span class="line">[0.113s][info   ][gc,nmethod  ] GC(1) NMethods: 112 registered, 0 unregistered</span><br><span class="line">[0.113s][info   ][gc,metaspace] GC(1) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.113s][info   ][gc,ref      ] GC(1) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.113s][info   ][gc,ref      ] GC(1) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.113s][info   ][gc,ref      ] GC(1) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.113s][info   ][gc,ref      ] GC(1) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.113s][info   ][gc,reloc    ] GC(1) Small Pages: 16 / 32M, Empty: 0M, Relocated: 6M, In-Place: 0</span><br><span class="line">[0.113s][info   ][gc,reloc    ] GC(1) Medium Pages: 6 / 24M, Empty: 4M, Relocated: 5M, In-Place: 0</span><br><span class="line">[0.113s][info   ][gc,reloc    ] GC(1) Large Pages: 36 / 72M, Empty: 26M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.113s][info   ][gc,reloc    ] GC(1) Forwarding Usage: 0M</span><br><span class="line">[0.113s][info   ][gc,heap     ] GC(1) Min Capacity: 128M(100%)</span><br><span class="line">[0.113s][info   ][gc,heap     ] GC(1) Max Capacity: 128M(100%)</span><br><span class="line">[0.113s][info   ][gc,heap     ] GC(1) Soft Max Capacity: 128M(100%)</span><br><span class="line">[0.113s][info   ][gc,heap     ] GC(1)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.113s][info   ][gc,heap     ] GC(1)  Capacity:      128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)</span><br><span class="line">[0.113s][info   ][gc,heap     ] GC(1)      Free:        0M (0%)            0M (0%)           28M (22%)          24M (19%)          30M (23%)           0M (0%)</span><br><span class="line">[0.113s][info   ][gc,heap     ] GC(1)      Used:      128M (100%)        128M (100%)        100M (78%)         104M (81%)         128M (100%)         98M (77%)</span><br><span class="line">[0.114s][info   ][gc,heap     ] GC(1)      Live:         -                75M (59%)          75M (59%)          75M (59%)            -                  -</span><br><span class="line">[0.114s][info   ][gc,heap     ] GC(1) Allocated:         -                 0M (0%)            2M (2%)           21M (17%)            -                  -</span><br><span class="line">[0.114s][info   ][gc,heap     ] GC(1)   Garbage:         -                52M (41%)          22M (17%)           6M (5%)             -                  -</span><br><span class="line">[0.114s][info   ][gc,heap     ] GC(1) Reclaimed:         -                  -                30M (23%)          45M (36%)            -                  -</span><br><span class="line">[0.114s][info   ][gc          ] GC(1) Garbage Collection (Allocation Stall) 128M(100%)-&gt;104M(81%)</span><br><span class="line">[0.115s][info   ][gc,start    ] GC(2) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.115s][info   ][gc,ref      ] GC(2) Clearing All SoftReferences</span><br><span class="line">[0.115s][info   ][gc,task     ] GC(2) Using 1 workers</span><br><span class="line">[0.115s][info   ][gc,phases   ] GC(2) Pause Mark Start 0.003ms</span><br><span class="line">[0.116s][info   ][gc,phases   ] GC(2) Concurrent Mark 1.023ms</span><br><span class="line">[0.116s][info   ][gc,phases   ] GC(2) Pause Mark End 0.007ms</span><br><span class="line">[0.116s][info   ][gc,phases   ] GC(2) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.116s][info   ][gc,phases   ] GC(2) Concurrent Process Non-Strong References 0.207ms</span><br><span class="line">[0.116s][info   ][gc,phases   ] GC(2) Concurrent Reset Relocation Set 0.001ms</span><br><span class="line">[0.118s][info   ][gc          ] Allocation Stall (main) 2.970ms</span><br><span class="line">[0.118s][info   ][gc,phases   ] GC(2) Concurrent Select Relocation Set 1.470ms</span><br><span class="line">[0.118s][info   ][gc,phases   ] GC(2) Pause Relocate Start 0.005ms</span><br><span class="line">[0.119s][info   ][gc,phases   ] GC(2) Concurrent Relocate 1.146ms</span><br><span class="line">[0.119s][info   ][gc,load     ] GC(2) Load: 4.33/4.72/4.91</span><br><span class="line">[0.119s][info   ][gc,mmu      ] GC(2) MMU: 2ms/99.4%, 5ms/99.5%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/99.9%</span><br><span class="line">[0.119s][info   ][gc,marking  ] GC(2) Mark: 1 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.119s][info   ][gc,marking  ] GC(2) Mark Stack Usage: 32M</span><br><span class="line">[0.119s][info   ][gc,nmethod  ] GC(2) NMethods: 115 registered, 0 unregistered</span><br><span class="line">[0.119s][info   ][gc,metaspace] GC(2) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.119s][info   ][gc,ref      ] GC(2) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.119s][info   ][gc,ref      ] GC(2) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.119s][info   ][gc,ref      ] GC(2) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.120s][info   ][gc,ref      ] GC(2) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.120s][info   ][gc,reloc    ] GC(2) Small Pages: 15 / 30M, Empty: 0M, Relocated: 2M, In-Place: 0</span><br><span class="line">[0.120s][info   ][gc,reloc    ] GC(2) Medium Pages: 5 / 20M, Empty: 0M, Relocated: 6M, In-Place: 0</span><br><span class="line">[0.120s][info   ][gc,reloc    ] GC(2) Large Pages: 39 / 78M, Empty: 20M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.120s][info   ][gc,reloc    ] GC(2) Forwarding Usage: 0M</span><br><span class="line">[0.120s][info   ][gc,heap     ] GC(2) Min Capacity: 128M(100%)</span><br><span class="line">[0.120s][info   ][gc,heap     ] GC(2) Max Capacity: 128M(100%)</span><br><span class="line">[0.120s][info   ][gc,heap     ] GC(2) Soft Max Capacity: 128M(100%)</span><br><span class="line">[0.120s][info   ][gc,heap     ] GC(2)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.120s][info   ][gc,heap     ] GC(2)  Capacity:      128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)</span><br><span class="line">[0.120s][info   ][gc,heap     ] GC(2)      Free:        0M (0%)            0M (0%)           14M (11%)          22M (17%)          22M (17%)           0M (0%)</span><br><span class="line">[0.120s][info   ][gc,heap     ] GC(2)      Used:      128M (100%)        128M (100%)        114M (89%)         106M (83%)         128M (100%)        106M (83%)</span><br><span class="line">[0.120s][info   ][gc,heap     ] GC(2)      Live:         -                92M (72%)          92M (72%)          92M (72%)            -                  -</span><br><span class="line">[0.120s][info   ][gc,heap     ] GC(2) Allocated:         -                 0M (0%)            6M (5%)            7M (6%)             -                  -</span><br><span class="line">[0.120s][info   ][gc,heap     ] GC(2)   Garbage:         -                35M (28%)          15M (12%)           5M (4%)             -                  -</span><br><span class="line">[0.120s][info   ][gc,heap     ] GC(2) Reclaimed:         -                  -                20M (16%)          29M (23%)            -                  -</span><br><span class="line">[0.120s][info   ][gc          ] GC(2) Garbage Collection (Allocation Stall) 128M(100%)-&gt;106M(83%)</span><br><span class="line">[0.121s][info   ][gc,start    ] GC(3) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.121s][info   ][gc,ref      ] GC(3) Clearing All SoftReferences</span><br><span class="line">[0.121s][info   ][gc,task     ] GC(3) Using 1 workers</span><br><span class="line">[0.121s][info   ][gc,phases   ] GC(3) Pause Mark Start 0.002ms</span><br><span class="line">[0.122s][info   ][gc,phases   ] GC(3) Concurrent Mark 1.059ms</span><br><span class="line">[0.122s][info   ][gc,phases   ] GC(3) Pause Mark End 0.008ms</span><br><span class="line">[0.122s][info   ][gc,phases   ] GC(3) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.122s][info   ][gc,phases   ] GC(3) Concurrent Process Non-Strong References 0.210ms</span><br><span class="line">[0.122s][info   ][gc,phases   ] GC(3) Concurrent Reset Relocation Set 0.001ms</span><br><span class="line">[0.124s][info   ][gc          ] Allocation Stall (main) 2.902ms</span><br><span class="line">[0.124s][info   ][gc,phases   ] GC(3) Concurrent Select Relocation Set 1.414ms</span><br><span class="line">[0.124s][info   ][gc,phases   ] GC(3) Pause Relocate Start 0.007ms</span><br><span class="line">[0.124s][info   ][gc          ] Allocation Stall (main) 0.077ms</span><br><span class="line">[0.124s][info   ][gc,phases   ] GC(3) Concurrent Relocate 0.774ms</span><br><span class="line">[0.125s][info   ][gc,load     ] GC(3) Load: 4.33/4.72/4.91</span><br><span class="line">[0.125s][info   ][gc,mmu      ] GC(3) MMU: 2ms/99.3%, 5ms/99.5%, 10ms/99.7%, 20ms/99.8%, 50ms/99.8%, 100ms/99.9%</span><br><span class="line">[0.125s][info   ][gc,marking  ] GC(3) Mark: 1 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.125s][info   ][gc,marking  ] GC(3) Mark Stack Usage: 32M</span><br><span class="line">[0.125s][info   ][gc,nmethod  ] GC(3) NMethods: 117 registered, 0 unregistered</span><br><span class="line">[0.125s][info   ][gc,metaspace] GC(3) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.125s][info   ][gc,ref      ] GC(3) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.125s][info   ][gc,ref      ] GC(3) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.125s][info   ][gc,ref      ] GC(3) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.125s][info   ][gc,ref      ] GC(3) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.125s][info   ][gc,reloc    ] GC(3) Small Pages: 18 / 36M, Empty: 0M, Relocated: 3M, In-Place: 0</span><br><span class="line">[0.125s][info   ][gc,reloc    ] GC(3) Medium Pages: 6 / 24M, Empty: 0M, Relocated: 2M, In-Place: 0</span><br><span class="line">[0.125s][info   ][gc,reloc    ] GC(3) Large Pages: 34 / 68M, Empty: 8M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.125s][info   ][gc,reloc    ] GC(3) Forwarding Usage: 0M</span><br><span class="line">[0.125s][info   ][gc,heap     ] GC(3) Min Capacity: 128M(100%)</span><br><span class="line">[0.125s][info   ][gc,heap     ] GC(3) Max Capacity: 128M(100%)</span><br><span class="line">[0.125s][info   ][gc,heap     ] GC(3) Soft Max Capacity: 128M(100%)</span><br><span class="line">[0.125s][info   ][gc,heap     ] GC(3)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.125s][info   ][gc,heap     ] GC(3)  Capacity:      128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)</span><br><span class="line">[0.125s][info   ][gc,heap     ] GC(3)      Free:        0M (0%)            0M (0%)            6M (5%)            6M (5%)            8M (6%)            0M (0%)</span><br><span class="line">[0.125s][info   ][gc,heap     ] GC(3)      Used:      128M (100%)        128M (100%)        122M (95%)         122M (95%)         128M (100%)        120M (94%)</span><br><span class="line">[0.125s][info   ][gc,heap     ] GC(3)      Live:         -                99M (78%)          99M (78%)          99M (78%)            -                  -</span><br><span class="line">[0.125s][info   ][gc,heap     ] GC(3) Allocated:         -                 0M (0%)            2M (2%)           15M (12%)            -                  -</span><br><span class="line">[0.125s][info   ][gc,heap     ] GC(3)   Garbage:         -                28M (22%)          20M (16%)           6M (5%)             -                  -</span><br><span class="line">[0.125s][info   ][gc,heap     ] GC(3) Reclaimed:         -                  -                 8M (6%)           21M (17%)            -                  -</span><br><span class="line">[0.125s][info   ][gc          ] GC(3) Garbage Collection (Allocation Stall) 128M(100%)-&gt;122M(95%)</span><br><span class="line">[0.125s][info   ][gc,start    ] GC(4) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.125s][info   ][gc,ref      ] GC(4) Clearing All SoftReferences</span><br><span class="line">[0.125s][info   ][gc,task     ] GC(4) Using 1 workers</span><br><span class="line">[0.125s][info   ][gc,phases   ] GC(4) Pause Mark Start 0.002ms</span><br><span class="line">[0.126s][info   ][gc,phases   ] GC(4) Concurrent Mark 0.862ms</span><br><span class="line">[0.126s][info   ][gc,phases   ] GC(4) Pause Mark End 0.003ms</span><br><span class="line">[0.126s][info   ][gc,phases   ] GC(4) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.126s][info   ][gc,phases   ] GC(4) Concurrent Process Non-Strong References 0.253ms</span><br><span class="line">[0.126s][info   ][gc,phases   ] GC(4) Concurrent Reset Relocation Set 0.001ms</span><br><span class="line">[0.128s][info   ][gc          ] Allocation Stall (main) 2.716ms</span><br><span class="line">[0.128s][info   ][gc,phases   ] GC(4) Concurrent Select Relocation Set 1.445ms</span><br><span class="line">[0.128s][info   ][gc,phases   ] GC(4) Pause Relocate Start 0.005ms</span><br><span class="line">[0.128s][info   ][gc,phases   ] GC(4) Concurrent Relocate 0.679ms</span><br><span class="line">[0.128s][info   ][gc,load     ] GC(4) Load: 4.33/4.72/4.91</span><br><span class="line">[0.128s][info   ][gc,mmu      ] GC(4) MMU: 2ms/99.3%, 5ms/99.5%, 10ms/99.7%, 20ms/99.8%, 50ms/99.8%, 100ms/99.9%</span><br><span class="line">[0.128s][info   ][gc,marking  ] GC(4) Mark: 1 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.128s][info   ][gc,marking  ] GC(4) Mark Stack Usage: 32M</span><br><span class="line">[0.128s][info   ][gc,nmethod  ] GC(4) NMethods: 117 registered, 0 unregistered</span><br><span class="line">[0.129s][info   ][gc,metaspace] GC(4) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.129s][info   ][gc,ref      ] GC(4) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.129s][info   ][gc,ref      ] GC(4) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.129s][info   ][gc,ref      ] GC(4) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.129s][info   ][gc,ref      ] GC(4) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.129s][info   ][gc,reloc    ] GC(4) Small Pages: 15 / 30M, Empty: 0M, Relocated: 1M, In-Place: 0</span><br><span class="line">[0.129s][info   ][gc,reloc    ] GC(4) Medium Pages: 6 / 24M, Empty: 0M, Relocated: 3M, In-Place: 0</span><br><span class="line">[0.129s][info   ][gc,reloc    ] GC(4) Large Pages: 37 / 74M, Empty: 12M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.129s][info   ][gc,reloc    ] GC(4) Forwarding Usage: 0M</span><br><span class="line">[0.129s][info   ][gc,heap     ] GC(4) Min Capacity: 128M(100%)</span><br><span class="line">[0.129s][info   ][gc,heap     ] GC(4) Max Capacity: 128M(100%)</span><br><span class="line">[0.129s][info   ][gc,heap     ] GC(4) Soft Max Capacity: 128M(100%)</span><br><span class="line">[0.129s][info   ][gc,heap     ] GC(4)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.129s][info   ][gc,heap     ] GC(4)  Capacity:      128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)</span><br><span class="line">[0.129s][info   ][gc,heap     ] GC(4)      Free:        0M (0%)            0M (0%)           10M (8%)           10M (8%)           12M (9%)            0M (0%)</span><br><span class="line">[0.129s][info   ][gc,heap     ] GC(4)      Used:      128M (100%)        128M (100%)        118M (92%)         118M (92%)         128M (100%)        116M (91%)</span><br><span class="line">[0.129s][info   ][gc,heap     ] GC(4)      Live:         -               102M (80%)         102M (80%)         102M (80%)            -                  -</span><br><span class="line">[0.129s][info   ][gc,heap     ] GC(4) Allocated:         -                 0M (0%)            2M (2%)            7M (6%)             -                  -</span><br><span class="line">[0.129s][info   ][gc,heap     ] GC(4)   Garbage:         -                25M (20%)          13M (10%)           7M (6%)             -                  -</span><br><span class="line">[0.129s][info   ][gc,heap     ] GC(4) Reclaimed:         -                  -                12M (9%)           17M (14%)            -                  -</span><br><span class="line">[0.129s][info   ][gc          ] GC(4) Garbage Collection (Allocation Stall) 128M(100%)-&gt;118M(92%)</span><br><span class="line">[0.129s][info   ][gc,start    ] GC(5) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.129s][info   ][gc,ref      ] GC(5) Clearing All SoftReferences</span><br><span class="line">[0.129s][info   ][gc,task     ] GC(5) Using 1 workers</span><br><span class="line">[0.129s][info   ][gc,phases   ] GC(5) Pause Mark Start 0.002ms</span><br><span class="line">[0.130s][info   ][gc,phases   ] GC(5) Concurrent Mark 0.898ms</span><br><span class="line">[0.130s][info   ][gc,phases   ] GC(5) Pause Mark End 0.003ms</span><br><span class="line">[0.130s][info   ][gc,phases   ] GC(5) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.130s][info   ][gc,phases   ] GC(5) Concurrent Process Non-Strong References 0.200ms</span><br><span class="line">[0.130s][info   ][gc,phases   ] GC(5) Concurrent Reset Relocation Set 0.001ms</span><br><span class="line">[0.132s][info   ][gc          ] Allocation Stall (main) 2.735ms</span><br><span class="line">[0.132s][info   ][gc,phases   ] GC(5) Concurrent Select Relocation Set 1.510ms</span><br><span class="line">[0.132s][info   ][gc,phases   ] GC(5) Pause Relocate Start 0.004ms</span><br><span class="line">[0.132s][info   ][gc,phases   ] GC(5) Concurrent Relocate 0.195ms</span><br><span class="line">[0.132s][info   ][gc,load     ] GC(5) Load: 4.33/4.72/4.91</span><br><span class="line">[0.132s][info   ][gc,mmu      ] GC(5) MMU: 2ms/99.3%, 5ms/99.5%, 10ms/99.7%, 20ms/99.7%, 50ms/99.8%, 100ms/99.9%</span><br><span class="line">[0.132s][info   ][gc,marking  ] GC(5) Mark: 1 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.132s][info   ][gc,marking  ] GC(5) Mark Stack Usage: 32M</span><br><span class="line">[0.132s][info   ][gc,nmethod  ] GC(5) NMethods: 117 registered, 0 unregistered</span><br><span class="line">[0.132s][info   ][gc,metaspace] GC(5) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.132s][info   ][gc,ref      ] GC(5) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.132s][info   ][gc,ref      ] GC(5) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.132s][info   ][gc,ref      ] GC(5) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.132s][info   ][gc,ref      ] GC(5) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.132s][info   ][gc,reloc    ] GC(5) Small Pages: 17 / 34M, Empty: 0M, Relocated: 1M, In-Place: 0</span><br><span class="line">[0.132s][info   ][gc,reloc    ] GC(5) Medium Pages: 6 / 24M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.132s][info   ][gc,reloc    ] GC(5) Large Pages: 35 / 70M, Empty: 10M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.132s][info   ][gc,reloc    ] GC(5) Forwarding Usage: 0M</span><br><span class="line">[0.133s][info   ][gc,heap     ] GC(5) Min Capacity: 128M(100%)</span><br><span class="line">[0.133s][info   ][gc,heap     ] GC(5) Max Capacity: 128M(100%)</span><br><span class="line">[0.133s][info   ][gc,heap     ] GC(5) Soft Max Capacity: 128M(100%)</span><br><span class="line">[0.133s][info   ][gc,heap     ] GC(5)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.133s][info   ][gc,heap     ] GC(5)  Capacity:      128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)</span><br><span class="line">[0.133s][info   ][gc,heap     ] GC(5)      Free:        0M (0%)            0M (0%)            8M (6%)            6M (5%)           10M (8%)            0M (0%)</span><br><span class="line">[0.133s][info   ][gc,heap     ] GC(5)      Used:      128M (100%)        128M (100%)        120M (94%)         122M (95%)         128M (100%)        118M (92%)</span><br><span class="line">[0.133s][info   ][gc,heap     ] GC(5)      Live:         -               104M (82%)         104M (82%)         104M (82%)            -                  -</span><br><span class="line">[0.133s][info   ][gc,heap     ] GC(5) Allocated:         -                 0M (0%)            2M (2%)            7M (6%)             -                  -</span><br><span class="line">[0.133s][info   ][gc,heap     ] GC(5)   Garbage:         -                23M (18%)          13M (10%)           9M (7%)             -                  -</span><br><span class="line">[0.133s][info   ][gc,heap     ] GC(5) Reclaimed:         -                  -                10M (8%)           13M (11%)            -                  -</span><br><span class="line">[0.133s][info   ][gc          ] GC(5) Garbage Collection (Allocation Stall) 128M(100%)-&gt;122M(95%)</span><br><span class="line">[0.133s][info   ][gc,start    ] GC(6) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.133s][info   ][gc,ref      ] GC(6) Clearing All SoftReferences</span><br><span class="line">[0.133s][info   ][gc,task     ] GC(6) Using 1 workers</span><br><span class="line">[0.133s][info   ][gc,phases   ] GC(6) Pause Mark Start 0.002ms</span><br><span class="line">[0.134s][info   ][gc,phases   ] GC(6) Concurrent Mark 0.775ms</span><br><span class="line">[0.134s][info   ][gc,phases   ] GC(6) Pause Mark End 0.003ms</span><br><span class="line">[0.134s][info   ][gc,phases   ] GC(6) Concurrent Mark Free 0.001ms</span><br><span class="line">[0.134s][info   ][gc,phases   ] GC(6) Concurrent Process Non-Strong References 0.216ms</span><br><span class="line">[0.134s][info   ][gc,phases   ] GC(6) Concurrent Reset Relocation Set 0.001ms</span><br><span class="line">[0.135s][info   ][gc          ] Allocation Stall (main) 2.571ms</span><br><span class="line">[0.135s][info   ][gc,phases   ] GC(6) Concurrent Select Relocation Set 1.416ms</span><br><span class="line">[0.135s][info   ][gc,phases   ] GC(6) Pause Relocate Start 0.005ms</span><br><span class="line">[0.136s][info   ][gc          ] Relocation Stall (main) 0.345ms</span><br><span class="line">[0.136s][info   ][gc,phases   ] GC(6) Concurrent Relocate 0.479ms</span><br><span class="line">[0.136s][info   ][gc,load     ] GC(6) Load: 4.33/4.72/4.91</span><br><span class="line">[0.136s][info   ][gc,mmu      ] GC(6) MMU: 2ms/99.3%, 5ms/99.5%, 10ms/99.7%, 20ms/99.7%, 50ms/99.8%, 100ms/99.9%</span><br><span class="line">[0.136s][info   ][gc,marking  ] GC(6) Mark: 1 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.136s][info   ][gc,marking  ] GC(6) Mark Stack Usage: 32M</span><br><span class="line">[0.136s][info   ][gc,nmethod  ] GC(6) NMethods: 117 registered, 0 unregistered</span><br><span class="line">[0.136s][info   ][gc,metaspace] GC(6) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.136s][info   ][gc,ref      ] GC(6) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.136s][info   ][gc,ref      ] GC(6) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.136s][info   ][gc,ref      ] GC(6) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.136s][info   ][gc,ref      ] GC(6) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.136s][info   ][gc,reloc    ] GC(6) Small Pages: 16 / 32M, Empty: 0M, Relocated: 1M, In-Place: 0</span><br><span class="line">[0.136s][info   ][gc,reloc    ] GC(6) Medium Pages: 7 / 28M, Empty: 0M, Relocated: 3M, In-Place: 1</span><br><span class="line">[0.136s][info   ][gc,reloc    ] GC(6) Large Pages: 34 / 68M, Empty: 2M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.136s][info   ][gc,reloc    ] GC(6) Forwarding Usage: 0M</span><br><span class="line">[0.136s][info   ][gc,heap     ] GC(6) Min Capacity: 128M(100%)</span><br><span class="line">[0.136s][info   ][gc,heap     ] GC(6) Max Capacity: 128M(100%)</span><br><span class="line">[0.136s][info   ][gc,heap     ] GC(6) Soft Max Capacity: 128M(100%)</span><br><span class="line">[0.136s][info   ][gc,heap     ] GC(6)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.136s][info   ][gc,heap     ] GC(6)  Capacity:      128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)</span><br><span class="line">[0.136s][info   ][gc,heap     ] GC(6)      Free:        0M (0%)            0M (0%)            0M (0%)            6M (5%)            6M (5%)            0M (0%)</span><br><span class="line">[0.136s][info   ][gc,heap     ] GC(6)      Used:      128M (100%)        128M (100%)        128M (100%)        122M (95%)         128M (100%)        122M (95%)</span><br><span class="line">[0.136s][info   ][gc,heap     ] GC(6)      Live:         -               111M (87%)         111M (87%)         111M (87%)            -                  -</span><br><span class="line">[0.136s][info   ][gc,heap     ] GC(6) Allocated:         -                 0M (0%)            2M (2%)            2M (2%)             -                  -</span><br><span class="line">[0.136s][info   ][gc,heap     ] GC(6)   Garbage:         -                16M (13%)          14M (11%)           8M (7%)             -                  -</span><br><span class="line">[0.136s][info   ][gc,heap     ] GC(6) Reclaimed:         -                  -                 2M (2%)            8M (6%)             -                  -</span><br><span class="line">[0.136s][info   ][gc          ] GC(6) Garbage Collection (Allocation Stall) 128M(100%)-&gt;122M(95%)</span><br><span class="line">[0.136s][info   ][gc,start    ] GC(7) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.136s][info   ][gc,ref      ] GC(7) Clearing All SoftReferences</span><br><span class="line">[0.136s][info   ][gc,task     ] GC(7) Using 1 workers</span><br><span class="line">[0.136s][info   ][gc,phases   ] GC(7) Pause Mark Start 0.002ms</span><br><span class="line">[0.137s][info   ][gc,phases   ] GC(7) Concurrent Mark 0.866ms</span><br><span class="line">[0.137s][info   ][gc,phases   ] GC(7) Pause Mark End 0.005ms</span><br><span class="line">[0.137s][info   ][gc,phases   ] GC(7) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.138s][info   ][gc,phases   ] GC(7) Concurrent Process Non-Strong References 0.238ms</span><br><span class="line">[0.138s][info   ][gc,phases   ] GC(7) Concurrent Reset Relocation Set 0.001ms</span><br><span class="line">[0.139s][info   ][gc          ] Allocation Stall (main) 2.866ms</span><br><span class="line">[0.139s][info   ][gc,phases   ] GC(7) Concurrent Select Relocation Set 1.510ms</span><br><span class="line">[0.139s][info   ][gc,phases   ] GC(7) Pause Relocate Start 0.003ms</span><br><span class="line">[0.140s][info   ][gc          ] Allocation Stall (main) 0.201ms</span><br><span class="line">[0.140s][info   ][gc,phases   ] GC(7) Concurrent Relocate 0.292ms</span><br><span class="line">[0.140s][info   ][gc,load     ] GC(7) Load: 4.33/4.72/4.91</span><br><span class="line">[0.140s][info   ][gc,mmu      ] GC(7) MMU: 2ms/99.3%, 5ms/99.5%, 10ms/99.7%, 20ms/99.7%, 50ms/99.8%, 100ms/99.9%</span><br><span class="line">[0.140s][info   ][gc,marking  ] GC(7) Mark: 1 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.140s][info   ][gc,marking  ] GC(7) Mark Stack Usage: 32M</span><br><span class="line">[0.140s][info   ][gc,nmethod  ] GC(7) NMethods: 117 registered, 0 unregistered</span><br><span class="line">[0.140s][info   ][gc,metaspace] GC(7) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.140s][info   ][gc,ref      ] GC(7) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.140s][info   ][gc,ref      ] GC(7) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.140s][info   ][gc,ref      ] GC(7) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.140s][info   ][gc,ref      ] GC(7) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.140s][info   ][gc,reloc    ] GC(7) Small Pages: 16 / 32M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.140s][info   ][gc,reloc    ] GC(7) Medium Pages: 7 / 28M, Empty: 0M, Relocated: 3M, In-Place: 1</span><br><span class="line">[0.140s][info   ][gc,reloc    ] GC(7) Large Pages: 34 / 68M, Empty: 2M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.140s][info   ][gc,reloc    ] GC(7) Forwarding Usage: 0M</span><br><span class="line">[0.140s][info   ][gc,heap     ] GC(7) Min Capacity: 128M(100%)</span><br><span class="line">[0.140s][info   ][gc,heap     ] GC(7) Max Capacity: 128M(100%)</span><br><span class="line">[0.140s][info   ][gc,heap     ] GC(7) Soft Max Capacity: 128M(100%)</span><br><span class="line">[0.140s][info   ][gc,heap     ] GC(7)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.140s][info   ][gc,heap     ] GC(7)  Capacity:      128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)</span><br><span class="line">[0.140s][info   ][gc,heap     ] GC(7)      Free:        0M (0%)            0M (0%)            0M (0%)            2M (2%)            4M (3%)            0M (0%)</span><br><span class="line">[0.140s][info   ][gc,heap     ] GC(7)      Used:      128M (100%)        128M (100%)        128M (100%)        126M (98%)         128M (100%)        124M (97%)</span><br><span class="line">[0.140s][info   ][gc,heap     ] GC(7)      Live:         -               112M (88%)         112M (88%)         112M (88%)            -                  -</span><br><span class="line">[0.140s][info   ][gc,heap     ] GC(7) Allocated:         -                 0M (0%)            2M (2%)            4M (3%)             -                  -</span><br><span class="line">[0.140s][info   ][gc,heap     ] GC(7)   Garbage:         -                15M (12%)          13M (11%)           9M (8%)             -                  -</span><br><span class="line">[0.140s][info   ][gc,heap     ] GC(7) Reclaimed:         -                  -                 2M (2%)            6M (5%)             -                  -</span><br><span class="line">[0.140s][info   ][gc          ] GC(7) Garbage Collection (Allocation Stall) 128M(100%)-&gt;126M(98%)</span><br><span class="line">[0.140s][info   ][gc,start    ] GC(8) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.140s][info   ][gc,ref      ] GC(8) Clearing All SoftReferences</span><br><span class="line">[0.140s][info   ][gc,task     ] GC(8) Using 1 workers</span><br><span class="line">[0.140s][info   ][gc,phases   ] GC(8) Pause Mark Start 0.002ms</span><br><span class="line">[0.141s][info   ][gc,phases   ] GC(8) Concurrent Mark 0.721ms</span><br><span class="line">[0.141s][info   ][gc,phases   ] GC(8) Pause Mark End 0.002ms</span><br><span class="line">[0.141s][info   ][gc,phases   ] GC(8) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.141s][info   ][gc,phases   ] GC(8) Concurrent Process Non-Strong References 0.211ms</span><br><span class="line">[0.141s][info   ][gc,phases   ] GC(8) Concurrent Reset Relocation Set 0.000ms</span><br><span class="line">[0.142s][info   ][gc          ] Allocation Stall (main) 2.726ms</span><br><span class="line">[0.142s][info   ][gc,phases   ] GC(8) Concurrent Select Relocation Set 1.367ms</span><br><span class="line">[0.142s][info   ][gc,phases   ] GC(8) Pause Relocate Start 0.003ms</span><br><span class="line">[0.143s][info   ][gc,phases   ] GC(8) Concurrent Relocate 0.074ms</span><br><span class="line">[0.143s][info   ][gc,load     ] GC(8) Load: 4.33/4.72/4.91</span><br><span class="line">[0.143s][info   ][gc,mmu      ] GC(8) MMU: 2ms/99.3%, 5ms/99.5%, 10ms/99.7%, 20ms/99.7%, 50ms/99.8%, 100ms/99.9%</span><br><span class="line">[0.143s][info   ][gc,marking  ] GC(8) Mark: 1 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.143s][info   ][gc,marking  ] GC(8) Mark Stack Usage: 32M</span><br><span class="line">[0.143s][info   ][gc,nmethod  ] GC(8) NMethods: 117 registered, 0 unregistered</span><br><span class="line">[0.143s][info   ][gc,metaspace] GC(8) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.143s][info   ][gc,ref      ] GC(8) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.143s][info   ][gc,ref      ] GC(8) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.143s][info   ][gc,ref      ] GC(8) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.143s][info   ][gc,ref      ] GC(8) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.143s][info   ][gc,reloc    ] GC(8) Small Pages: 17 / 34M, Empty: 0M, Relocated: 0M, In-Place: 1</span><br><span class="line">[0.143s][info   ][gc,reloc    ] GC(8) Medium Pages: 6 / 24M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.143s][info   ][gc,reloc    ] GC(8) Large Pages: 34 / 68M, Empty: 2M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.143s][info   ][gc,reloc    ] GC(8) Forwarding Usage: 0M</span><br><span class="line">[0.143s][info   ][gc,heap     ] GC(8) Min Capacity: 128M(100%)</span><br><span class="line">[0.143s][info   ][gc,heap     ] GC(8) Max Capacity: 128M(100%)</span><br><span class="line">[0.143s][info   ][gc,heap     ] GC(8) Soft Max Capacity: 128M(100%)</span><br><span class="line">[0.143s][info   ][gc,heap     ] GC(8)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.143s][info   ][gc,heap     ] GC(8)  Capacity:      128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)</span><br><span class="line">[0.143s][info   ][gc,heap     ] GC(8)      Free:        2M (2%)            2M (2%)            0M (0%)            2M (2%)            4M (3%)            0M (0%)</span><br><span class="line">[0.143s][info   ][gc,heap     ] GC(8)      Used:      126M (98%)         126M (98%)         128M (100%)        126M (98%)         128M (100%)        124M (97%)</span><br><span class="line">[0.143s][info   ][gc,heap     ] GC(8)      Live:         -               112M (88%)         112M (88%)         112M (88%)            -                  -</span><br><span class="line">[0.143s][info   ][gc,heap     ] GC(8) Allocated:         -                 0M (0%)            4M (3%)            4M (3%)             -                  -</span><br><span class="line">[0.143s][info   ][gc,heap     ] GC(8)   Garbage:         -                13M (11%)          11M (9%)            9M (8%)             -                  -</span><br><span class="line">[0.143s][info   ][gc,heap     ] GC(8) Reclaimed:         -                  -                 2M (2%)            4M (3%)             -                  -</span><br><span class="line">[0.143s][info   ][gc          ] GC(8) Garbage Collection (Allocation Stall) 126M(98%)-&gt;126M(98%)</span><br><span class="line">[0.143s][info   ][gc,start    ] GC(9) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.143s][info   ][gc,ref      ] GC(9) Clearing All SoftReferences</span><br><span class="line">[0.143s][info   ][gc,task     ] GC(9) Using 1 workers</span><br><span class="line">[0.143s][info   ][gc,phases   ] GC(9) Pause Mark Start 0.001ms</span><br><span class="line">[0.144s][info   ][gc,phases   ] GC(9) Concurrent Mark 0.790ms</span><br><span class="line">[0.144s][info   ][gc,phases   ] GC(9) Pause Mark End 0.003ms</span><br><span class="line">[0.144s][info   ][gc,phases   ] GC(9) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.144s][info   ][gc,phases   ] GC(9) Concurrent Process Non-Strong References 0.246ms</span><br><span class="line">[0.144s][info   ][gc,phases   ] GC(9) Concurrent Reset Relocation Set 0.000ms</span><br><span class="line">[0.146s][info   ][gc,phases   ] GC(9) Concurrent Select Relocation Set 1.427ms</span><br><span class="line">[0.146s][info   ][gc,phases   ] GC(9) Pause Relocate Start 0.006ms</span><br><span class="line">[0.146s][info   ][gc,phases   ] GC(9) Concurrent Relocate 0.099ms</span><br><span class="line">[0.146s][info   ][gc,load     ] GC(9) Load: 4.33/4.72/4.91</span><br><span class="line">[0.146s][info   ][gc,mmu      ] GC(9) MMU: 2ms/99.3%, 5ms/99.5%, 10ms/99.7%, 20ms/99.7%, 50ms/99.8%, 100ms/99.9%</span><br><span class="line">[0.146s][info   ][gc,marking  ] GC(9) Mark: 1 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.146s][info   ][gc,marking  ] GC(9) Mark Stack Usage: 32M</span><br><span class="line">[0.146s][info   ][gc          ] Allocation Stall (main) 3.072ms</span><br><span class="line">[0.146s][info   ][gc,nmethod  ] GC(9) NMethods: 117 registered, 0 unregistered</span><br><span class="line">[0.146s][info   ][gc,metaspace] GC(9) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.146s][info   ][gc,ref      ] GC(9) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.146s][info   ][gc,ref      ] GC(9) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.146s][info   ][gc,ref      ] GC(9) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.146s][info   ][gc,ref      ] GC(9) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.146s][info   ][gc,reloc    ] GC(9) Small Pages: 17 / 34M, Empty: 0M, Relocated: 1M, In-Place: 1</span><br><span class="line">[0.146s][info   ][gc,reloc    ] GC(9) Medium Pages: 7 / 28M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.146s][info   ][gc,reloc    ] GC(9) Large Pages: 33 / 66M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.146s][info   ][gc,reloc    ] GC(9) Forwarding Usage: 0M</span><br><span class="line">[0.146s][info   ][gc,heap     ] GC(9) Min Capacity: 128M(100%)</span><br><span class="line">[0.146s][info   ][gc,heap     ] GC(9) Max Capacity: 128M(100%)</span><br><span class="line">[0.146s][info   ][gc,heap     ] GC(9) Soft Max Capacity: 128M(100%)</span><br><span class="line">[0.146s][info   ][gc,heap     ] GC(9)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.146s][info   ][gc,heap     ] GC(9)  Capacity:      128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)</span><br><span class="line">[0.146s][info   ][gc,heap     ] GC(9)      Free:        0M (0%)            0M (0%)            0M (0%)            0M (0%)            2M (2%)            0M (0%)</span><br><span class="line">[0.146s][info   ][gc,heap     ] GC(9)      Used:      128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)        126M (98%)</span><br><span class="line">[0.146s][info   ][gc,heap     ] GC(9)      Live:         -               114M (89%)         114M (89%)         114M (89%)            -                  -</span><br><span class="line">[0.146s][info   ][gc,heap     ] GC(9) Allocated:         -                 0M (0%)            0M (0%)            2M (2%)             -                  -</span><br><span class="line">[0.146s][info   ][gc,heap     ] GC(9)   Garbage:         -                13M (11%)          13M (11%)          11M (9%)             -                  -</span><br><span class="line">[0.146s][info   ][gc,heap     ] GC(9) Reclaimed:         -                  -                 0M (0%)            2M (2%)             -                  -</span><br><span class="line">[0.146s][info   ][gc          ] GC(9) Garbage Collection (Allocation Stall) 128M(100%)-&gt;128M(100%)</span><br><span class="line">[0.146s][info   ][gc,start    ] GC(10) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.146s][info   ][gc,ref      ] GC(10) Clearing All SoftReferences</span><br><span class="line">[0.146s][info   ][gc,task     ] GC(10) Using 1 workers</span><br><span class="line">[0.146s][info   ][gc,phases   ] GC(10) Pause Mark Start 0.002ms</span><br><span class="line">[0.147s][info   ][gc,phases   ] GC(10) Concurrent Mark 0.773ms</span><br><span class="line">[0.147s][info   ][gc,phases   ] GC(10) Pause Mark End 0.003ms</span><br><span class="line">[0.147s][info   ][gc,phases   ] GC(10) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.147s][info   ][gc,phases   ] GC(10) Concurrent Process Non-Strong References 0.245ms</span><br><span class="line">[0.147s][info   ][gc,phases   ] GC(10) Concurrent Reset Relocation Set 0.000ms</span><br><span class="line">[0.149s][info   ][gc,phases   ] GC(10) Concurrent Select Relocation Set 1.374ms</span><br><span class="line">[0.149s][info   ][gc,phases   ] GC(10) Pause Relocate Start 0.004ms</span><br><span class="line">[0.149s][info   ][gc,phases   ] GC(10) Concurrent Relocate 0.005ms</span><br><span class="line">[0.149s][info   ][gc,load     ] GC(10) Load: 4.33/4.72/4.91</span><br><span class="line">[0.149s][info   ][gc,mmu      ] GC(10) MMU: 2ms/99.3%, 5ms/99.5%, 10ms/99.7%, 20ms/99.7%, 50ms/99.8%, 100ms/99.9%</span><br><span class="line">[0.149s][info   ][gc,marking  ] GC(10) Mark: 1 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.149s][info   ][gc,marking  ] GC(10) Mark Stack Usage: 32M</span><br><span class="line">[0.149s][info   ][gc,nmethod  ] GC(10) NMethods: 117 registered, 0 unregistered</span><br><span class="line">[0.149s][info   ][gc,metaspace] GC(10) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.149s][info   ][gc,ref      ] GC(10) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.149s][info   ][gc,ref      ] GC(10) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.149s][info   ][gc,ref      ] GC(10) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.149s][info   ][gc,ref      ] GC(10) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.149s][info   ][gc,reloc    ] GC(10) Small Pages: 16 / 32M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.149s][info   ][gc,reloc    ] GC(10) Medium Pages: 7 / 28M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.149s][info   ][gc,reloc    ] GC(10) Large Pages: 34 / 68M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.149s][info   ][gc,reloc    ] GC(10) Forwarding Usage: 0M</span><br><span class="line">[0.149s][info   ][gc,heap     ] GC(10) Min Capacity: 128M(100%)</span><br><span class="line">[0.149s][info   ][gc,heap     ] GC(10) Max Capacity: 128M(100%)</span><br><span class="line">[0.149s][info   ][gc,heap     ] GC(10) Soft Max Capacity: 128M(100%)</span><br><span class="line">[0.149s][info   ][gc,heap     ] GC(10)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.149s][info   ][gc,heap     ] GC(10)  Capacity:      128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)</span><br><span class="line">[0.149s][info   ][gc,heap     ] GC(10)      Free:        0M (0%)            0M (0%)            0M (0%)            0M (0%)            0M (0%)            0M (0%)</span><br><span class="line">[0.149s][info   ][gc,heap     ] GC(10)      Used:      128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)</span><br><span class="line">[0.149s][info   ][gc,heap     ] GC(10)      Live:         -               116M (91%)         116M (91%)         116M (91%)            -                  -</span><br><span class="line">[0.149s][info   ][gc,heap     ] GC(10) Allocated:         -                 0M (0%)            0M (0%)            0M (0%)             -                  -</span><br><span class="line">[0.149s][info   ][gc,heap     ] GC(10)   Garbage:         -                11M (9%)           11M (9%)           11M (9%)             -                  -</span><br><span class="line">[0.149s][info   ][gc,heap     ] GC(10) Reclaimed:         -                  -                 0M (0%)            0M (0%)             -                  -</span><br><span class="line">[0.149s][info   ][gc          ] GC(10) Garbage Collection (Allocation Stall) 128M(100%)-&gt;128M(100%)</span><br><span class="line">[0.149s][info   ][gc          ] Allocation Stall (main) 3.065ms</span><br><span class="line">[0.149s][info   ][gc,start    ] GC(11) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.149s][info   ][gc,ref      ] GC(11) Clearing All SoftReferences</span><br><span class="line">[0.149s][info   ][gc,task     ] GC(11) Using 1 workers</span><br><span class="line">[0.149s][info   ][gc,phases   ] GC(11) Pause Mark Start 0.001ms</span><br><span class="line">[0.150s][info   ][gc,phases   ] GC(11) Concurrent Mark 0.766ms</span><br><span class="line">[0.150s][info   ][gc,phases   ] GC(11) Pause Mark End 0.005ms</span><br><span class="line">[0.150s][info   ][gc,phases   ] GC(11) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.150s][info   ][gc,phases   ] GC(11) Concurrent Process Non-Strong References 0.219ms</span><br><span class="line">[0.150s][info   ][gc,phases   ] GC(11) Concurrent Reset Relocation Set 0.000ms</span><br><span class="line">[0.152s][info   ][gc,phases   ] GC(11) Concurrent Select Relocation Set 1.443ms</span><br><span class="line">[0.152s][info   ][gc,phases   ] GC(11) Pause Relocate Start 0.004ms</span><br><span class="line">[0.152s][info   ][gc,phases   ] GC(11) Concurrent Relocate 0.021ms</span><br><span class="line">[0.152s][info   ][gc,load     ] GC(11) Load: 4.33/4.72/4.91</span><br><span class="line">[0.152s][info   ][gc,mmu      ] GC(11) MMU: 2ms/99.3%, 5ms/99.5%, 10ms/99.7%, 20ms/99.7%, 50ms/99.8%, 100ms/99.8%</span><br><span class="line">[0.152s][info   ][gc,marking  ] GC(11) Mark: 1 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.152s][info   ][gc,marking  ] GC(11) Mark Stack Usage: 32M</span><br><span class="line">[0.152s][info   ][gc,nmethod  ] GC(11) NMethods: 117 registered, 0 unregistered</span><br><span class="line">[0.152s][info   ][gc,metaspace] GC(11) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.152s][info   ][gc,ref      ] GC(11) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.152s][info   ][gc,ref      ] GC(11) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.152s][info   ][gc,ref      ] GC(11) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.152s][info   ][gc,ref      ] GC(11) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.152s][info   ][gc,reloc    ] GC(11) Small Pages: 16 / 32M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.152s][info   ][gc,reloc    ] GC(11) Medium Pages: 7 / 28M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.152s][info   ][gc,reloc    ] GC(11) Large Pages: 34 / 68M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.152s][info   ][gc,reloc    ] GC(11) Forwarding Usage: 0M</span><br><span class="line">[0.152s][info   ][gc,heap     ] GC(11) Min Capacity: 128M(100%)</span><br><span class="line">[0.152s][info   ][gc,heap     ] GC(11) Max Capacity: 128M(100%)</span><br><span class="line">[0.152s][info   ][gc,heap     ] GC(11) Soft Max Capacity: 128M(100%)</span><br><span class="line">[0.152s][info   ][gc,heap     ] GC(11)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.152s][info   ][gc,heap     ] GC(11)  Capacity:      128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)</span><br><span class="line">[0.152s][info   ][gc,heap     ] GC(11)      Free:        0M (0%)            0M (0%)            0M (0%)            0M (0%)            0M (0%)            0M (0%)</span><br><span class="line">[0.152s][info   ][gc,heap     ] GC(11)      Used:      128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)</span><br><span class="line">[0.152s][info   ][gc,heap     ] GC(11)      Live:         -               116M (91%)         116M (91%)         116M (91%)            -                  -</span><br><span class="line">[0.152s][info   ][gc,heap     ] GC(11) Allocated:         -                 0M (0%)            0M (0%)            0M (0%)             -                  -</span><br><span class="line">[0.152s][info   ][gc,heap     ] GC(11)   Garbage:         -                11M (9%)           11M (9%)           11M (9%)             -                  -</span><br><span class="line">[0.152s][info   ][gc,heap     ] GC(11) Reclaimed:         -                  -                 0M (0%)            0M (0%)             -                  -</span><br><span class="line">[0.152s][info   ][gc          ] GC(11) Garbage Collection (Allocation Stall) 128M(100%)-&gt;128M(100%)</span><br><span class="line">[0.152s][info   ][gc          ] Allocation Stall (main) 3.102ms</span><br><span class="line">[0.152s][info   ][gc          ] Out Of Memory (main)</span><br><span class="line">[0.152s][info   ][gc,start    ] GC(12) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.152s][info   ][gc,ref      ] GC(12) Clearing All SoftReferences</span><br><span class="line">[0.152s][info   ][gc,task     ] GC(12) Using 1 workers</span><br><span class="line">[0.152s][info   ][gc,phases   ] GC(12) Pause Mark Start 0.003ms</span><br><span class="line">[0.153s][info   ][gc,phases   ] GC(12) Concurrent Mark 0.594ms</span><br><span class="line">[0.153s][info   ][gc,phases   ] GC(12) Pause Mark End 0.004ms</span><br><span class="line">[0.153s][info   ][gc,phases   ] GC(12) Concurrent Mark Free 0.001ms</span><br><span class="line">[0.153s][info   ][gc,phases   ] GC(12) Concurrent Process Non-Strong References 0.233ms</span><br><span class="line">[0.153s][info   ][gc,phases   ] GC(12) Concurrent Reset Relocation Set 0.000ms</span><br><span class="line">[0.155s][info   ][gc          ] Allocation Stall (main) 2.616ms</span><br><span class="line">[0.155s][info   ][gc,phases   ] GC(12) Concurrent Select Relocation Set 1.484ms</span><br><span class="line">[0.155s][info   ][gc,phases   ] GC(12) Pause Relocate Start 0.004ms</span><br><span class="line">Exception in thread &quot;main&quot; [0.155s][info   ][gc,phases   ] GC(12) Concurrent Relocate 0.334ms</span><br><span class="line">[0.155s][info   ][gc,load     ] GC(12) Load: 4.33/4.72/4.91</span><br><span class="line">[0.155s][info   ][gc,mmu      ] GC(12) MMU: 2ms/99.3%, 5ms/99.5%, 10ms/99.6%, 20ms/99.7%, 50ms/99.7%, 100ms/99.8%</span><br><span class="line">[0.155s][info   ][gc,marking  ] GC(12) Mark: 1 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.155s][info   ][gc,marking  ] GC(12) Mark Stack Usage: 32M</span><br><span class="line">[0.156s][info   ][gc,nmethod  ] GC(12) NMethods: 117 registered, 0 unregistered</span><br><span class="line">[0.156s][info   ][gc,metaspace] GC(12) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.156s][info   ][gc,ref      ] GC(12) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.156s][info   ][gc,ref      ] GC(12) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.156s][info   ][gc,ref      ] GC(12) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.156s][info   ][gc,ref      ] GC(12) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.156s][info   ][gc,reloc    ] GC(12) Small Pages: 16 / 32M, Empty: 16M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.156s][info   ][gc,reloc    ] GC(12) Medium Pages: 7 / 28M, Empty: 28M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.156s][info   ][gc,reloc    ] GC(12) Large Pages: 34 / 68M, Empty: 68M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.156s][info   ][gc,reloc    ] GC(12) Forwarding Usage: 0M</span><br><span class="line">[0.156s][info   ][gc,heap     ] GC(12) Min Capacity: 128M(100%)</span><br><span class="line">[0.156s][info   ][gc,heap     ] GC(12) Max Capacity: 128M(100%)</span><br><span class="line">[0.156s][info   ][gc,heap     ] GC(12) Soft Max Capacity: 128M(100%)</span><br><span class="line">[0.156s][info   ][gc,heap     ] GC(12)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.156s][info   ][gc,heap     ] GC(12)  Capacity:      128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)        128M (100%)</span><br><span class="line">[0.156s][info   ][gc,heap     ] GC(12)      Free:        0M (0%)            0M (0%)          110M (86%)         124M (97%)         124M (97%)           0M (0%)</span><br><span class="line">[0.156s][info   ][gc,heap     ] GC(12)      Used:      128M (100%)        128M (100%)         18M (14%)           4M (3%)          128M (100%)          4M (3%)</span><br><span class="line">[0.156s][info   ][gc,heap     ] GC(12)      Live:         -                 0M (0%)            0M (0%)            0M (0%)             -                  -</span><br><span class="line">[0.156s][info   ][gc,heap     ] GC(12) Allocated:         -                 0M (0%)            2M (2%)            1M (2%)             -                  -</span><br><span class="line">[0.156s][info   ][gc,heap     ] GC(12)   Garbage:         -               127M (100%)         15M (12%)           1M (1%)             -                  -</span><br><span class="line">[0.156s][info   ][gc,heap     ] GC(12) Reclaimed:         -                  -               112M (88%)         125M (98%)            -                  -</span><br><span class="line">[0.156s][info   ][gc          ] GC(12) Garbage Collection (Allocation Stall) 128M(100%)-&gt;4M(3%)</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at GCLogAnalysis.generateGarbage(GCLogAnalysis.java:36)</span><br><span class="line">	at GCLogAnalysis.main(GCLogAnalysis.java:20)</span><br><span class="line">[0.157s][info   ][gc,heap,exit] Heap</span><br><span class="line">[0.157s][info   ][gc,heap,exit]  ZHeap           used 4M, capacity 128M, max capacity 128M</span><br><span class="line">[0.157s][info   ][gc,heap,exit]  Metaspace       used 215K, committed 448K, reserved 1114112K</span><br><span class="line">[0.157s][info   ][gc,heap,exit]   class space    used 7K, committed 128K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>试试512m内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+UseZGC -Xms512m -Xmx512m -XX:+PrintGCDetails -Xlog:gc\*:file=gc.log:time,uptime,level,tags GCLogAnalysis</span><br></pre></td></tr></table></figure>

<p>79次GC,生成了35000多个对象。可以看到效果比G1GC要好一些。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0.757s][info   ][gc,ref      ] GC(53) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.757s][info   ][gc,reloc    ] GC(53) Small Pages: 83 / 166M, Empty: 0M, Relocated: 22M, In-Place: 0</span><br><span class="line">[0.757s][info   ][gc,reloc    ] GC(53) Medium Pages: 21 / 336M, Empty: 0M, Relocated: 40M, In-Place: 3</span><br><span class="line">[0.757s][info   ][gc,reloc    ] GC(53) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.757s][info   ][gc,reloc    ] GC(53) Forwarding Usage: 0M</span><br><span class="line">[0.757s][info   ][gc,heap     ] GC(53) Min Capacity: 512M(100%)</span><br><span class="line">[0.757s][info   ][gc,heap     ] GC(53) Max Capacity: 512M(100%)</span><br><span class="line">[0.757s][info   ][gc,heap     ] GC(53) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.757s][info   ][gc,heap     ] GC(53)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.758s][info   ][gc,heap     ] GC(53)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.758s][info   ][gc,heap     ] GC(53)      Free:       10M (2%)           10M (2%)           10M (2%)           46M (9%)           46M (9%)            6M (1%)</span><br><span class="line">[0.758s][info   ][gc,heap     ] GC(53)      Used:      502M (98%)         502M (98%)         502M (98%)         466M (91%)         506M (99%)         466M (91%)</span><br><span class="line">[0.758s][info   ][gc,heap     ] GC(53)      Live:         -               348M (68%)         348M (68%)         348M (68%)            -                  -</span><br><span class="line">[0.758s][info   ][gc,heap     ] GC(53) Allocated:         -                 0M (0%)            0M (0%)           25M (5%)             -                  -</span><br><span class="line">[0.758s][info   ][gc,heap     ] GC(53)   Garbage:         -               153M (30%)         153M (30%)          91M (18%)            -                  -</span><br><span class="line">[0.758s][info   ][gc,heap     ] GC(53) Reclaimed:         -                  -                 0M (0%)           61M (12%)            -                  -</span><br><span class="line">[0.758s][info   ][gc          ] GC(53) Garbage Collection (Allocation Stall) 502M(98%)-&gt;466M(91%)</span><br><span class="line">[0.760s][info   ][gc,start    ] GC(54) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.760s][info   ][gc,ref      ] GC(54) Clearing All SoftReferences</span><br><span class="line">[0.760s][info   ][gc,task     ] GC(54) Using 2 workers</span><br><span class="line">[0.760s][info   ][gc,phases   ] GC(54) Pause Mark Start 0.003ms</span><br><span class="line">[0.762s][info   ][gc,phases   ] GC(54) Concurrent Mark 1.819ms</span><br><span class="line">[0.762s][info   ][gc,phases   ] GC(54) Pause Mark End 0.007ms</span><br><span class="line">[0.762s][info   ][gc,phases   ] GC(54) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.762s][info   ][gc,phases   ] GC(54) Concurrent Process Non-Strong References 0.287ms</span><br><span class="line">[0.762s][info   ][gc,phases   ] GC(54) Concurrent Reset Relocation Set 0.001ms</span><br><span class="line">[0.764s][info   ][gc,phases   ] GC(54) Concurrent Select Relocation Set 1.488ms</span><br><span class="line">[0.764s][info   ][gc,phases   ] GC(54) Pause Relocate Start 0.006ms</span><br><span class="line">[0.765s][info   ][gc          ] Allocation Stall (main) 4.888ms</span><br><span class="line">[0.767s][info   ][gc,phases   ] GC(54) Concurrent Relocate 2.941ms</span><br><span class="line">[0.767s][info   ][gc,load     ] GC(54) Load: 4.02/4.33/4.71</span><br><span class="line">[0.767s][info   ][gc,mmu      ] GC(54) MMU: 2ms/98.7%, 5ms/99.4%, 10ms/99.6%, 20ms/99.7%, 50ms/99.8%, 100ms/99.8%</span><br><span class="line">[0.767s][info   ][gc,marking  ] GC(54) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.767s][info   ][gc,marking  ] GC(54) Mark Stack Usage: 32M</span><br><span class="line">[0.767s][info   ][gc,nmethod  ] GC(54) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.767s][info   ][gc,metaspace] GC(54) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.767s][info   ][gc,ref      ] GC(54) Soft: 3 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.767s][info   ][gc,ref      ] GC(54) Weak: 23 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.767s][info   ][gc,ref      ] GC(54) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.767s][info   ][gc,ref      ] GC(54) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.767s][info   ][gc,reloc    ] GC(54) Small Pages: 86 / 172M, Empty: 0M, Relocated: 19M, In-Place: 0</span><br><span class="line">[0.767s][info   ][gc,reloc    ] GC(54) Medium Pages: 21 / 336M, Empty: 0M, Relocated: 69M, In-Place: 3</span><br><span class="line">[0.767s][info   ][gc,reloc    ] GC(54) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.767s][info   ][gc,reloc    ] GC(54) Forwarding Usage: 0M</span><br><span class="line">[0.767s][info   ][gc,heap     ] GC(54) Min Capacity: 512M(100%)</span><br><span class="line">[0.767s][info   ][gc,heap     ] GC(54) Max Capacity: 512M(100%)</span><br><span class="line">[0.767s][info   ][gc,heap     ] GC(54) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.767s][info   ][gc,heap     ] GC(54)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.767s][info   ][gc,heap     ] GC(54)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.767s][info   ][gc,heap     ] GC(54)      Free:        4M (1%)            4M (1%)            4M (1%)           58M (11%)          58M (11%)           0M (0%)</span><br><span class="line">[0.767s][info   ][gc,heap     ] GC(54)      Used:      508M (99%)         508M (99%)         508M (99%)         454M (89%)         512M (100%)        454M (89%)</span><br><span class="line">[0.767s][info   ][gc,heap     ] GC(54)      Live:         -               346M (68%)         346M (68%)         346M (68%)            -                  -</span><br><span class="line">[0.767s][info   ][gc,heap     ] GC(54) Allocated:         -                 0M (0%)            0M (0%)           27M (5%)             -                  -</span><br><span class="line">[0.767s][info   ][gc,heap     ] GC(54)   Garbage:         -               161M (32%)         161M (32%)          79M (16%)            -                  -</span><br><span class="line">[0.767s][info   ][gc,heap     ] GC(54) Reclaimed:         -                  -                 0M (0%)           81M (16%)            -                  -</span><br><span class="line">[0.767s][info   ][gc          ] GC(54) Garbage Collection (Allocation Stall) 508M(99%)-&gt;454M(89%)</span><br><span class="line">[0.771s][info   ][gc,start    ] GC(55) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.771s][info   ][gc,ref      ] GC(55) Clearing All SoftReferences</span><br><span class="line">[0.771s][info   ][gc,task     ] GC(55) Using 2 workers</span><br><span class="line">[0.771s][info   ][gc,phases   ] GC(55) Pause Mark Start 0.004ms</span><br><span class="line">[0.774s][info   ][gc,phases   ] GC(55) Concurrent Mark 2.284ms</span><br><span class="line">[0.774s][info   ][gc,phases   ] GC(55) Pause Mark End 0.005ms</span><br><span class="line">[0.774s][info   ][gc,phases   ] GC(55) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.774s][info   ][gc,phases   ] GC(55) Concurrent Process Non-Strong References 0.211ms</span><br><span class="line">[0.774s][info   ][gc,phases   ] GC(55) Concurrent Reset Relocation Set 0.006ms</span><br><span class="line">[0.776s][info   ][gc,phases   ] GC(55) Concurrent Select Relocation Set 1.482ms</span><br><span class="line">[0.776s][info   ][gc,phases   ] GC(55) Pause Relocate Start 0.006ms</span><br><span class="line">[0.777s][info   ][gc          ] Allocation Stall (main) 5.454ms</span><br><span class="line">[0.777s][info   ][gc          ] Allocation Stall (main) 0.170ms</span><br><span class="line">[0.778s][info   ][gc,phases   ] GC(55) Concurrent Relocate 2.125ms</span><br><span class="line">[0.778s][info   ][gc,load     ] GC(55) Load: 4.02/4.33/4.71</span><br><span class="line">[0.778s][info   ][gc,mmu      ] GC(55) MMU: 2ms/98.7%, 5ms/99.4%, 10ms/99.6%, 20ms/99.7%, 50ms/99.8%, 100ms/99.8%</span><br><span class="line">[0.778s][info   ][gc,marking  ] GC(55) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.778s][info   ][gc,marking  ] GC(55) Mark Stack Usage: 32M</span><br><span class="line">[0.778s][info   ][gc,nmethod  ] GC(55) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.778s][info   ][gc,metaspace] GC(55) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.778s][info   ][gc,ref      ] GC(55) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.778s][info   ][gc,ref      ] GC(55) Weak: 23 encountered, 3 discovered, 0 enqueued</span><br><span class="line">[0.778s][info   ][gc,ref      ] GC(55) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.778s][info   ][gc,ref      ] GC(55) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.778s][info   ][gc,reloc    ] GC(55) Small Pages: 88 / 176M, Empty: 0M, Relocated: 27M, In-Place: 0</span><br><span class="line">[0.778s][info   ][gc,reloc    ] GC(55) Medium Pages: 21 / 336M, Empty: 0M, Relocated: 38M, In-Place: 3</span><br><span class="line">[0.778s][info   ][gc,reloc    ] GC(55) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.778s][info   ][gc,reloc    ] GC(55) Forwarding Usage: 0M</span><br><span class="line">[0.778s][info   ][gc,heap     ] GC(55) Min Capacity: 512M(100%)</span><br><span class="line">[0.778s][info   ][gc,heap     ] GC(55) Max Capacity: 512M(100%)</span><br><span class="line">[0.778s][info   ][gc,heap     ] GC(55) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.778s][info   ][gc,heap     ] GC(55)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.778s][info   ][gc,heap     ] GC(55)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.778s][info   ][gc,heap     ] GC(55)      Free:        0M (0%)            0M (0%)            0M (0%)           46M (9%)           46M (9%)            0M (0%)</span><br><span class="line">[0.778s][info   ][gc,heap     ] GC(55)      Used:      512M (100%)        512M (100%)        512M (100%)        466M (91%)         512M (100%)        466M (91%)</span><br><span class="line">[0.778s][info   ][gc,heap     ] GC(55)      Live:         -               348M (68%)         348M (68%)         348M (68%)            -                  -</span><br><span class="line">[0.778s][info   ][gc,heap     ] GC(55) Allocated:         -                 0M (0%)            0M (0%)           21M (4%)             -                  -</span><br><span class="line">[0.778s][info   ][gc,heap     ] GC(55)   Garbage:         -               163M (32%)         163M (32%)          95M (19%)            -                  -</span><br><span class="line">[0.778s][info   ][gc,heap     ] GC(55) Reclaimed:         -                  -                 0M (0%)           67M (13%)            -                  -</span><br><span class="line">[0.778s][info   ][gc          ] GC(55) Garbage Collection (Allocation Stall) 512M(100%)-&gt;466M(91%)</span><br><span class="line">[0.782s][info   ][gc,start    ] GC(56) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.782s][info   ][gc,ref      ] GC(56) Clearing All SoftReferences</span><br><span class="line">[0.782s][info   ][gc,task     ] GC(56) Using 2 workers</span><br><span class="line">[0.782s][info   ][gc,phases   ] GC(56) Pause Mark Start 0.004ms</span><br><span class="line">[0.784s][info   ][gc,phases   ] GC(56) Concurrent Mark 1.837ms</span><br><span class="line">[0.784s][info   ][gc,phases   ] GC(56) Pause Mark End 0.005ms</span><br><span class="line">[0.784s][info   ][gc,phases   ] GC(56) Concurrent Mark Free 0.001ms</span><br><span class="line">[0.784s][info   ][gc,phases   ] GC(56) Concurrent Process Non-Strong References 0.185ms</span><br><span class="line">[0.784s][info   ][gc,phases   ] GC(56) Concurrent Reset Relocation Set 0.002ms</span><br><span class="line">[0.786s][info   ][gc,phases   ] GC(56) Concurrent Select Relocation Set 1.407ms</span><br><span class="line">[0.786s][info   ][gc,phases   ] GC(56) Pause Relocate Start 0.006ms</span><br><span class="line">[0.787s][info   ][gc          ] Allocation Stall (main) 4.687ms</span><br><span class="line">[0.788s][info   ][gc,phases   ] GC(56) Concurrent Relocate 1.760ms</span><br><span class="line">[0.788s][info   ][gc,load     ] GC(56) Load: 4.02/4.33/4.71</span><br><span class="line">[0.788s][info   ][gc,mmu      ] GC(56) MMU: 2ms/98.7%, 5ms/99.4%, 10ms/99.6%, 20ms/99.7%, 50ms/99.8%, 100ms/99.8%</span><br><span class="line">[0.788s][info   ][gc,marking  ] GC(56) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.788s][info   ][gc,marking  ] GC(56) Mark Stack Usage: 32M</span><br><span class="line">[0.788s][info   ][gc,nmethod  ] GC(56) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.788s][info   ][gc,metaspace] GC(56) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.788s][info   ][gc,ref      ] GC(56) Soft: 3 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.788s][info   ][gc,ref      ] GC(56) Weak: 23 encountered, 2 discovered, 0 enqueued</span><br><span class="line">[0.788s][info   ][gc,ref      ] GC(56) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.788s][info   ][gc,ref      ] GC(56) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.788s][info   ][gc,reloc    ] GC(56) Small Pages: 85 / 170M, Empty: 0M, Relocated: 26M, In-Place: 0</span><br><span class="line">[0.788s][info   ][gc,reloc    ] GC(56) Medium Pages: 21 / 336M, Empty: 0M, Relocated: 41M, In-Place: 3</span><br><span class="line">[0.788s][info   ][gc,reloc    ] GC(56) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.788s][info   ][gc,reloc    ] GC(56) Forwarding Usage: 0M</span><br><span class="line">[0.788s][info   ][gc,heap     ] GC(56) Min Capacity: 512M(100%)</span><br><span class="line">[0.788s][info   ][gc,heap     ] GC(56) Max Capacity: 512M(100%)</span><br><span class="line">[0.788s][info   ][gc,heap     ] GC(56) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.788s][info   ][gc,heap     ] GC(56)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.788s][info   ][gc,heap     ] GC(56)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.788s][info   ][gc,heap     ] GC(56)      Free:        6M (1%)            6M (1%)            6M (1%)           48M (9%)           48M (9%)            2M (0%)</span><br><span class="line">[0.788s][info   ][gc,heap     ] GC(56)      Used:      506M (99%)         506M (99%)         506M (99%)         464M (91%)         510M (100%)        464M (91%)</span><br><span class="line">[0.788s][info   ][gc,heap     ] GC(56)      Live:         -               350M (68%)         350M (68%)         350M (68%)            -                  -</span><br><span class="line">[0.788s][info   ][gc,heap     ] GC(56) Allocated:         -                 0M (0%)            0M (0%)           23M (5%)             -                  -</span><br><span class="line">[0.788s][info   ][gc,heap     ] GC(56)   Garbage:         -               155M (30%)         155M (30%)          89M (18%)            -                  -</span><br><span class="line">[0.788s][info   ][gc,heap     ] GC(56) Reclaimed:         -                  -                 0M (0%)           65M (13%)            -                  -</span><br><span class="line">[0.788s][info   ][gc          ] GC(56) Garbage Collection (Allocation Stall) 506M(99%)-&gt;464M(91%)</span><br><span class="line">[0.790s][info   ][gc,start    ] GC(57) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.790s][info   ][gc,ref      ] GC(57) Clearing All SoftReferences</span><br><span class="line">[0.790s][info   ][gc,task     ] GC(57) Using 2 workers</span><br><span class="line">[0.790s][info   ][gc,phases   ] GC(57) Pause Mark Start 0.003ms</span><br><span class="line">[0.793s][info   ][gc,phases   ] GC(57) Concurrent Mark 2.162ms</span><br><span class="line">[0.793s][info   ][gc,phases   ] GC(57) Pause Mark End 0.006ms</span><br><span class="line">[0.793s][info   ][gc,phases   ] GC(57) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.793s][info   ][gc,phases   ] GC(57) Concurrent Process Non-Strong References 0.280ms</span><br><span class="line">[0.793s][info   ][gc,phases   ] GC(57) Concurrent Reset Relocation Set 0.002ms</span><br><span class="line">[0.794s][info   ][gc,phases   ] GC(57) Concurrent Select Relocation Set 1.411ms</span><br><span class="line">[0.794s][info   ][gc,phases   ] GC(57) Pause Relocate Start 0.004ms</span><br><span class="line">[0.796s][info   ][gc          ] Allocation Stall (main) 5.518ms</span><br><span class="line">[0.796s][info   ][gc          ] Allocation Stall (main) 0.207ms</span><br><span class="line">[0.798s][info   ][gc,phases   ] GC(57) Concurrent Relocate 3.403ms</span><br><span class="line">[0.798s][info   ][gc,load     ] GC(57) Load: 4.02/4.33/4.71</span><br><span class="line">[0.798s][info   ][gc,mmu      ] GC(57) MMU: 2ms/98.7%, 5ms/99.4%, 10ms/99.6%, 20ms/99.7%, 50ms/99.8%, 100ms/99.8%</span><br><span class="line">[0.798s][info   ][gc,marking  ] GC(57) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.798s][info   ][gc,marking  ] GC(57) Mark Stack Usage: 32M</span><br><span class="line">[0.798s][info   ][gc,nmethod  ] GC(57) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.798s][info   ][gc,metaspace] GC(57) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.798s][info   ][gc,ref      ] GC(57) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.798s][info   ][gc,ref      ] GC(57) Weak: 23 encountered, 3 discovered, 0 enqueued</span><br><span class="line">[0.798s][info   ][gc,ref      ] GC(57) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.798s][info   ][gc,ref      ] GC(57) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.798s][info   ][gc,reloc    ] GC(57) Small Pages: 80 / 160M, Empty: 0M, Relocated: 22M, In-Place: 0</span><br><span class="line">[0.798s][info   ][gc,reloc    ] GC(57) Medium Pages: 22 / 352M, Empty: 0M, Relocated: 67M, In-Place: 5</span><br><span class="line">[0.798s][info   ][gc,reloc    ] GC(57) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.798s][info   ][gc,reloc    ] GC(57) Forwarding Usage: 0M</span><br><span class="line">[0.798s][info   ][gc,heap     ] GC(57) Min Capacity: 512M(100%)</span><br><span class="line">[0.798s][info   ][gc,heap     ] GC(57) Max Capacity: 512M(100%)</span><br><span class="line">[0.798s][info   ][gc,heap     ] GC(57) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.798s][info   ][gc,heap     ] GC(57)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.798s][info   ][gc,heap     ] GC(57)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.798s][info   ][gc,heap     ] GC(57)      Free:        0M (0%)            0M (0%)            0M (0%)           30M (6%)           46M (9%)            0M (0%)</span><br><span class="line">[0.798s][info   ][gc,heap     ] GC(57)      Used:      512M (100%)        512M (100%)        512M (100%)        482M (94%)         512M (100%)        466M (91%)</span><br><span class="line">[0.798s][info   ][gc,heap     ] GC(57)      Live:         -               357M (70%)         357M (70%)         357M (70%)            -                  -</span><br><span class="line">[0.798s][info   ][gc,heap     ] GC(57) Allocated:         -                 0M (0%)            0M (0%)           41M (8%)             -                  -</span><br><span class="line">[0.798s][info   ][gc,heap     ] GC(57)   Garbage:         -               154M (30%)         154M (30%)          82M (16%)            -                  -</span><br><span class="line">[0.798s][info   ][gc,heap     ] GC(57) Reclaimed:         -                  -                 0M (0%)           71M (14%)            -                  -</span><br><span class="line">[0.798s][info   ][gc          ] GC(57) Garbage Collection (Allocation Stall) 512M(100%)-&gt;482M(94%)</span><br><span class="line">[0.802s][info   ][gc,start    ] GC(58) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.802s][info   ][gc,ref      ] GC(58) Clearing All SoftReferences</span><br><span class="line">[0.802s][info   ][gc,task     ] GC(58) Using 2 workers</span><br><span class="line">[0.802s][info   ][gc,phases   ] GC(58) Pause Mark Start 0.006ms</span><br><span class="line">[0.804s][info   ][gc,phases   ] GC(58) Concurrent Mark 1.870ms</span><br><span class="line">[0.804s][info   ][gc,phases   ] GC(58) Pause Mark End 0.004ms</span><br><span class="line">[0.804s][info   ][gc,phases   ] GC(58) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.804s][info   ][gc,phases   ] GC(58) Concurrent Process Non-Strong References 0.230ms</span><br><span class="line">[0.804s][info   ][gc,phases   ] GC(58) Concurrent Reset Relocation Set 0.002ms</span><br><span class="line">[0.806s][info   ][gc,phases   ] GC(58) Concurrent Select Relocation Set 1.448ms</span><br><span class="line">[0.806s][info   ][gc,phases   ] GC(58) Pause Relocate Start 0.005ms</span><br><span class="line">[0.807s][info   ][gc          ] Allocation Stall (main) 5.039ms</span><br><span class="line">[0.808s][info   ][gc,phases   ] GC(58) Concurrent Relocate 2.126ms</span><br><span class="line">[0.808s][info   ][gc,load     ] GC(58) Load: 4.02/4.33/4.71</span><br><span class="line">[0.808s][info   ][gc,mmu      ] GC(58) MMU: 2ms/98.7%, 5ms/99.4%, 10ms/99.6%, 20ms/99.7%, 50ms/99.8%, 100ms/99.8%</span><br><span class="line">[0.808s][info   ][gc,marking  ] GC(58) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.808s][info   ][gc,marking  ] GC(58) Mark Stack Usage: 32M</span><br><span class="line">[0.808s][info   ][gc,nmethod  ] GC(58) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.808s][info   ][gc,metaspace] GC(58) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.808s][info   ][gc,ref      ] GC(58) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.808s][info   ][gc,ref      ] GC(58) Weak: 23 encountered, 2 discovered, 0 enqueued</span><br><span class="line">[0.808s][info   ][gc,ref      ] GC(58) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.808s][info   ][gc,ref      ] GC(58) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.808s][info   ][gc,reloc    ] GC(58) Small Pages: 80 / 160M, Empty: 0M, Relocated: 22M, In-Place: 0</span><br><span class="line">[0.808s][info   ][gc,reloc    ] GC(58) Medium Pages: 22 / 352M, Empty: 0M, Relocated: 13M, In-Place: 1</span><br><span class="line">[0.808s][info   ][gc,reloc    ] GC(58) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.808s][info   ][gc,reloc    ] GC(58) Forwarding Usage: 0M</span><br><span class="line">[0.808s][info   ][gc,heap     ] GC(58) Min Capacity: 512M(100%)</span><br><span class="line">[0.808s][info   ][gc,heap     ] GC(58) Max Capacity: 512M(100%)</span><br><span class="line">[0.808s][info   ][gc,heap     ] GC(58) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.808s][info   ][gc,heap     ] GC(58)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.808s][info   ][gc,heap     ] GC(58)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.808s][info   ][gc,heap     ] GC(58)      Free:        0M (0%)            0M (0%)            0M (0%)           40M (8%)           40M (8%)            0M (0%)</span><br><span class="line">[0.808s][info   ][gc,heap     ] GC(58)      Used:      512M (100%)        512M (100%)        512M (100%)        472M (92%)         512M (100%)        472M (92%)</span><br><span class="line">[0.808s][info   ][gc,heap     ] GC(58)      Live:         -               360M (70%)         360M (70%)         360M (70%)            -                  -</span><br><span class="line">[0.808s][info   ][gc,heap     ] GC(58) Allocated:         -                 0M (0%)            0M (0%)           19M (4%)             -                  -</span><br><span class="line">[0.808s][info   ][gc,heap     ] GC(58)   Garbage:         -               151M (30%)         151M (30%)          91M (18%)            -                  -</span><br><span class="line">[0.808s][info   ][gc,heap     ] GC(58) Reclaimed:         -                  -                 0M (0%)           59M (12%)            -                  -</span><br><span class="line">[0.808s][info   ][gc          ] GC(58) Garbage Collection (Allocation Stall) 512M(100%)-&gt;472M(92%)</span><br><span class="line">[0.812s][info   ][gc,start    ] GC(59) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.812s][info   ][gc,ref      ] GC(59) Clearing All SoftReferences</span><br><span class="line">[0.812s][info   ][gc,task     ] GC(59) Using 2 workers</span><br><span class="line">[0.812s][info   ][gc,phases   ] GC(59) Pause Mark Start 0.004ms</span><br><span class="line">[0.814s][info   ][gc,phases   ] GC(59) Concurrent Mark 1.838ms</span><br><span class="line">[0.814s][info   ][gc,phases   ] GC(59) Pause Mark End 0.005ms</span><br><span class="line">[0.814s][info   ][gc,phases   ] GC(59) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.814s][info   ][gc,phases   ] GC(59) Concurrent Process Non-Strong References 0.191ms</span><br><span class="line">[0.814s][info   ][gc,phases   ] GC(59) Concurrent Reset Relocation Set 0.002ms</span><br><span class="line">[0.816s][info   ][gc,phases   ] GC(59) Concurrent Select Relocation Set 1.544ms</span><br><span class="line">[0.816s][info   ][gc,phases   ] GC(59) Pause Relocate Start 0.005ms</span><br><span class="line">[0.817s][info   ][gc          ] Allocation Stall (main) 5.187ms</span><br><span class="line">[0.818s][info   ][gc,phases   ] GC(59) Concurrent Relocate 2.015ms</span><br><span class="line">[0.818s][info   ][gc,load     ] GC(59) Load: 4.02/4.33/4.71</span><br><span class="line">[0.818s][info   ][gc,mmu      ] GC(59) MMU: 2ms/98.7%, 5ms/99.4%, 10ms/99.6%, 20ms/99.7%, 50ms/99.8%, 100ms/99.8%</span><br><span class="line">[0.818s][info   ][gc,marking  ] GC(59) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.818s][info   ][gc,marking  ] GC(59) Mark Stack Usage: 32M</span><br><span class="line">[0.818s][info   ][gc,nmethod  ] GC(59) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.818s][info   ][gc,metaspace] GC(59) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.818s][info   ][gc,ref      ] GC(59) Soft: 3 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.818s][info   ][gc,ref      ] GC(59) Weak: 23 encountered, 3 discovered, 0 enqueued</span><br><span class="line">[0.818s][info   ][gc,ref      ] GC(59) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.818s][info   ][gc,ref      ] GC(59) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.818s][info   ][gc,reloc    ] GC(59) Small Pages: 80 / 160M, Empty: 0M, Relocated: 17M, In-Place: 0</span><br><span class="line">[0.818s][info   ][gc,reloc    ] GC(59) Medium Pages: 22 / 352M, Empty: 0M, Relocated: 41M, In-Place: 3</span><br><span class="line">[0.818s][info   ][gc,reloc    ] GC(59) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.818s][info   ][gc,reloc    ] GC(59) Forwarding Usage: 0M</span><br><span class="line">[0.818s][info   ][gc,heap     ] GC(59) Min Capacity: 512M(100%)</span><br><span class="line">[0.818s][info   ][gc,heap     ] GC(59) Max Capacity: 512M(100%)</span><br><span class="line">[0.818s][info   ][gc,heap     ] GC(59) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.818s][info   ][gc,heap     ] GC(59)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.818s][info   ][gc,heap     ] GC(59)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.818s][info   ][gc,heap     ] GC(59)      Free:        0M (0%)            0M (0%)            0M (0%)           34M (7%)           36M (7%)            0M (0%)</span><br><span class="line">[0.818s][info   ][gc,heap     ] GC(59)      Used:      512M (100%)        512M (100%)        512M (100%)        478M (93%)         512M (100%)        476M (93%)</span><br><span class="line">[0.818s][info   ][gc,heap     ] GC(59)      Live:         -               354M (69%)         354M (69%)         354M (69%)            -                  -</span><br><span class="line">[0.818s][info   ][gc,heap     ] GC(59) Allocated:         -                 0M (0%)            0M (0%)           21M (4%)             -                  -</span><br><span class="line">[0.818s][info   ][gc,heap     ] GC(59)   Garbage:         -               157M (31%)         157M (31%)         101M (20%)            -                  -</span><br><span class="line">[0.818s][info   ][gc,heap     ] GC(59) Reclaimed:         -                  -                 0M (0%)           55M (11%)            -                  -</span><br><span class="line">[0.818s][info   ][gc          ] GC(59) Garbage Collection (Allocation Stall) 512M(100%)-&gt;478M(93%)</span><br><span class="line">[0.820s][info   ][gc,start    ] GC(60) Garbage Collection (Warmup)</span><br><span class="line">[0.820s][info   ][gc,task     ] GC(60) Using 2 workers</span><br><span class="line">[0.820s][info   ][gc,phases   ] GC(60) Pause Mark Start 0.003ms</span><br><span class="line">[0.822s][info   ][gc,phases   ] GC(60) Concurrent Mark 1.774ms</span><br><span class="line">[0.822s][info   ][gc,phases   ] GC(60) Pause Mark End 0.005ms</span><br><span class="line">[0.822s][info   ][gc,phases   ] GC(60) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.822s][info   ][gc,phases   ] GC(60) Concurrent Process Non-Strong References 0.228ms</span><br><span class="line">[0.822s][info   ][gc,phases   ] GC(60) Concurrent Reset Relocation Set 0.002ms</span><br><span class="line">[0.824s][info   ][gc,phases   ] GC(60) Concurrent Select Relocation Set 1.419ms</span><br><span class="line">[0.824s][info   ][gc,phases   ] GC(60) Pause Relocate Start 0.002ms</span><br><span class="line">[0.825s][info   ][gc          ] Allocation Stall (main) 4.701ms</span><br><span class="line">[0.826s][info   ][gc,phases   ] GC(60) Concurrent Relocate 2.090ms</span><br><span class="line">[0.826s][info   ][gc,load     ] GC(60) Load: 4.02/4.33/4.71</span><br><span class="line">[0.826s][info   ][gc,mmu      ] GC(60) MMU: 2ms/98.7%, 5ms/99.4%, 10ms/99.6%, 20ms/99.7%, 50ms/99.8%, 100ms/99.8%</span><br><span class="line">[0.826s][info   ][gc,marking  ] GC(60) Mark: 2 stripe(s), 2 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.826s][info   ][gc,marking  ] GC(60) Mark Stack Usage: 32M</span><br><span class="line">[0.826s][info   ][gc,nmethod  ] GC(60) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.826s][info   ][gc,metaspace] GC(60) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.826s][info   ][gc,ref      ] GC(60) Soft: 3 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.826s][info   ][gc,ref      ] GC(60) Weak: 23 encountered, 2 discovered, 0 enqueued</span><br><span class="line">[0.826s][info   ][gc,ref      ] GC(60) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.826s][info   ][gc,ref      ] GC(60) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.826s][info   ][gc,reloc    ] GC(60) Small Pages: 78 / 156M, Empty: 0M, Relocated: 12M, In-Place: 1</span><br><span class="line">[0.826s][info   ][gc,reloc    ] GC(60) Medium Pages: 22 / 352M, Empty: 0M, Relocated: 39M, In-Place: 3</span><br><span class="line">[0.826s][info   ][gc,reloc    ] GC(60) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.826s][info   ][gc,reloc    ] GC(60) Forwarding Usage: 0M</span><br><span class="line">[0.826s][info   ][gc,heap     ] GC(60) Min Capacity: 512M(100%)</span><br><span class="line">[0.826s][info   ][gc,heap     ] GC(60) Max Capacity: 512M(100%)</span><br><span class="line">[0.826s][info   ][gc,heap     ] GC(60) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.826s][info   ][gc,heap     ] GC(60)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.826s][info   ][gc,heap     ] GC(60)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.826s][info   ][gc,heap     ] GC(60)      Free:        4M (1%)            2M (0%)            2M (0%)           32M (6%)           32M (6%)            0M (0%)</span><br><span class="line">[0.826s][info   ][gc,heap     ] GC(60)      Used:      508M (99%)         510M (100%)        510M (100%)        480M (94%)         512M (100%)        480M (94%)</span><br><span class="line">[0.826s][info   ][gc,heap     ] GC(60)      Live:         -               355M (69%)         355M (69%)         355M (69%)            -                  -</span><br><span class="line">[0.826s][info   ][gc,heap     ] GC(60) Allocated:         -                 2M (0%)            2M (0%)           23M (5%)             -                  -</span><br><span class="line">[0.826s][info   ][gc,heap     ] GC(60)   Garbage:         -               152M (30%)         152M (30%)         100M (20%)            -                  -</span><br><span class="line">[0.826s][info   ][gc,heap     ] GC(60) Reclaimed:         -                  -                 0M (0%)           51M (10%)            -                  -</span><br><span class="line">[0.826s][info   ][gc          ] GC(60) Garbage Collection (Warmup) 508M(99%)-&gt;480M(94%)</span><br><span class="line">[0.827s][info   ][gc,start    ] GC(61) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.827s][info   ][gc,ref      ] GC(61) Clearing All SoftReferences</span><br><span class="line">[0.827s][info   ][gc,task     ] GC(61) Using 2 workers</span><br><span class="line">[0.827s][info   ][gc,phases   ] GC(61) Pause Mark Start 0.004ms</span><br><span class="line">[0.829s][info   ][gc,phases   ] GC(61) Concurrent Mark 1.789ms</span><br><span class="line">[0.829s][info   ][gc,phases   ] GC(61) Pause Mark End 0.003ms</span><br><span class="line">[0.829s][info   ][gc,phases   ] GC(61) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.829s][info   ][gc,phases   ] GC(61) Concurrent Process Non-Strong References 0.189ms</span><br><span class="line">[0.829s][info   ][gc,phases   ] GC(61) Concurrent Reset Relocation Set 0.004ms</span><br><span class="line">[0.831s][info   ][gc,phases   ] GC(61) Concurrent Select Relocation Set 1.448ms</span><br><span class="line">[0.831s][info   ][gc,phases   ] GC(61) Pause Relocate Start 0.006ms</span><br><span class="line">[0.832s][info   ][gc          ] Allocation Stall (main) 4.986ms</span><br><span class="line">[0.833s][info   ][gc,phases   ] GC(61) Concurrent Relocate 2.043ms</span><br><span class="line">[0.833s][info   ][gc,load     ] GC(61) Load: 4.02/4.33/4.71</span><br><span class="line">[0.833s][info   ][gc,mmu      ] GC(61) MMU: 2ms/98.7%, 5ms/99.4%, 10ms/99.6%, 20ms/99.7%, 50ms/99.8%, 100ms/99.8%</span><br><span class="line">[0.833s][info   ][gc,marking  ] GC(61) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.833s][info   ][gc,marking  ] GC(61) Mark Stack Usage: 32M</span><br><span class="line">[0.833s][info   ][gc,nmethod  ] GC(61) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.833s][info   ][gc,metaspace] GC(61) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.833s][info   ][gc,ref      ] GC(61) Soft: 3 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.833s][info   ][gc,ref      ] GC(61) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.833s][info   ][gc,ref      ] GC(61) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.833s][info   ][gc,ref      ] GC(61) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.833s][info   ][gc,reloc    ] GC(61) Small Pages: 77 / 154M, Empty: 0M, Relocated: 12M, In-Place: 0</span><br><span class="line">[0.833s][info   ][gc,reloc    ] GC(61) Medium Pages: 22 / 352M, Empty: 0M, Relocated: 41M, In-Place: 3</span><br><span class="line">[0.833s][info   ][gc,reloc    ] GC(61) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.833s][info   ][gc,reloc    ] GC(61) Forwarding Usage: 0M</span><br><span class="line">[0.833s][info   ][gc,heap     ] GC(61) Min Capacity: 512M(100%)</span><br><span class="line">[0.834s][info   ][gc,heap     ] GC(61) Max Capacity: 512M(100%)</span><br><span class="line">[0.834s][info   ][gc,heap     ] GC(61) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.834s][info   ][gc,heap     ] GC(61)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.834s][info   ][gc,heap     ] GC(61)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.834s][info   ][gc,heap     ] GC(61)      Free:        6M (1%)            6M (1%)            6M (1%)           38M (7%)           38M (7%)            2M (0%)</span><br><span class="line">[0.834s][info   ][gc,heap     ] GC(61)      Used:      506M (99%)         506M (99%)         506M (99%)         474M (93%)         510M (100%)        474M (93%)</span><br><span class="line">[0.834s][info   ][gc,heap     ] GC(61)      Live:         -               358M (70%)         358M (70%)         358M (70%)            -                  -</span><br><span class="line">[0.834s][info   ][gc,heap     ] GC(61) Allocated:         -                 0M (0%)            0M (0%)           19M (4%)             -                  -</span><br><span class="line">[0.834s][info   ][gc,heap     ] GC(61)   Garbage:         -               147M (29%)         147M (29%)          95M (19%)            -                  -</span><br><span class="line">[0.834s][info   ][gc,heap     ] GC(61) Reclaimed:         -                  -                 0M (0%)           51M (10%)            -                  -</span><br><span class="line">[0.834s][info   ][gc          ] GC(61) Garbage Collection (Allocation Stall) 506M(99%)-&gt;474M(93%)</span><br><span class="line">[0.835s][info   ][gc,start    ] GC(62) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.835s][info   ][gc,ref      ] GC(62) Clearing All SoftReferences</span><br><span class="line">[0.835s][info   ][gc,task     ] GC(62) Using 2 workers</span><br><span class="line">[0.835s][info   ][gc,phases   ] GC(62) Pause Mark Start 0.004ms</span><br><span class="line">[0.837s][info   ][gc,phases   ] GC(62) Concurrent Mark 1.927ms</span><br><span class="line">[0.837s][info   ][gc,phases   ] GC(62) Pause Mark End 0.008ms</span><br><span class="line">[0.837s][info   ][gc,phases   ] GC(62) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.838s][info   ][gc,phases   ] GC(62) Concurrent Process Non-Strong References 0.228ms</span><br><span class="line">[0.838s][info   ][gc,phases   ] GC(62) Concurrent Reset Relocation Set 0.001ms</span><br><span class="line">[0.839s][info   ][gc,phases   ] GC(62) Concurrent Select Relocation Set 1.485ms</span><br><span class="line">[0.839s][info   ][gc,phases   ] GC(62) Pause Relocate Start 0.002ms</span><br><span class="line">[0.840s][info   ][gc          ] Allocation Stall (main) 4.752ms</span><br><span class="line">[0.841s][info   ][gc,phases   ] GC(62) Concurrent Relocate 1.532ms</span><br><span class="line">[0.841s][info   ][gc,load     ] GC(62) Load: 4.02/4.33/4.71</span><br><span class="line">[0.841s][info   ][gc,mmu      ] GC(62) MMU: 2ms/98.7%, 5ms/99.4%, 10ms/99.6%, 20ms/99.7%, 50ms/99.8%, 100ms/99.8%</span><br><span class="line">[0.841s][info   ][gc,marking  ] GC(62) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.841s][info   ][gc,marking  ] GC(62) Mark Stack Usage: 32M</span><br><span class="line">[0.841s][info   ][gc,nmethod  ] GC(62) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.841s][info   ][gc,metaspace] GC(62) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.841s][info   ][gc,ref      ] GC(62) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.841s][info   ][gc,ref      ] GC(62) Weak: 23 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.841s][info   ][gc,ref      ] GC(62) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.841s][info   ][gc,ref      ] GC(62) Phantom: 1 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.841s][info   ][gc,reloc    ] GC(62) Small Pages: 78 / 156M, Empty: 0M, Relocated: 20M, In-Place: 0</span><br><span class="line">[0.841s][info   ][gc,reloc    ] GC(62) Medium Pages: 22 / 352M, Empty: 0M, Relocated: 41M, In-Place: 3</span><br><span class="line">[0.841s][info   ][gc,reloc    ] GC(62) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.841s][info   ][gc,reloc    ] GC(62) Forwarding Usage: 0M</span><br><span class="line">[0.841s][info   ][gc,heap     ] GC(62) Min Capacity: 512M(100%)</span><br><span class="line">[0.841s][info   ][gc,heap     ] GC(62) Max Capacity: 512M(100%)</span><br><span class="line">[0.841s][info   ][gc,heap     ] GC(62) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.841s][info   ][gc,heap     ] GC(62)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.841s][info   ][gc,heap     ] GC(62)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.841s][info   ][gc,heap     ] GC(62)      Free:        4M (1%)            4M (1%)            4M (1%)           40M (8%)           40M (8%)            0M (0%)</span><br><span class="line">[0.841s][info   ][gc,heap     ] GC(62)      Used:      508M (99%)         508M (99%)         508M (99%)         472M (92%)         512M (100%)        472M (92%)</span><br><span class="line">[0.841s][info   ][gc,heap     ] GC(62)      Live:         -               360M (70%)         360M (70%)         360M (70%)            -                  -</span><br><span class="line">[0.841s][info   ][gc,heap     ] GC(62) Allocated:         -                 0M (0%)            0M (0%)           21M (4%)             -                  -</span><br><span class="line">[0.841s][info   ][gc,heap     ] GC(62)   Garbage:         -               147M (29%)         147M (29%)          89M (17%)            -                  -</span><br><span class="line">[0.841s][info   ][gc,heap     ] GC(62) Reclaimed:         -                  -                 0M (0%)           57M (11%)            -                  -</span><br><span class="line">[0.841s][info   ][gc          ] GC(62) Garbage Collection (Allocation Stall) 508M(99%)-&gt;472M(92%)</span><br><span class="line">[0.843s][info   ][gc,start    ] GC(63) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.843s][info   ][gc,ref      ] GC(63) Clearing All SoftReferences</span><br><span class="line">[0.843s][info   ][gc,task     ] GC(63) Using 2 workers</span><br><span class="line">[0.843s][info   ][gc,phases   ] GC(63) Pause Mark Start 0.004ms</span><br><span class="line">[0.845s][info   ][gc,phases   ] GC(63) Concurrent Mark 1.763ms</span><br><span class="line">[0.845s][info   ][gc,phases   ] GC(63) Pause Mark End 0.004ms</span><br><span class="line">[0.845s][info   ][gc,phases   ] GC(63) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.845s][info   ][gc,phases   ] GC(63) Concurrent Process Non-Strong References 0.198ms</span><br><span class="line">[0.845s][info   ][gc,phases   ] GC(63) Concurrent Reset Relocation Set 0.002ms</span><br><span class="line">[0.847s][info   ][gc,phases   ] GC(63) Concurrent Select Relocation Set 1.399ms</span><br><span class="line">[0.847s][info   ][gc,phases   ] GC(63) Pause Relocate Start 0.002ms</span><br><span class="line">[0.848s][info   ][gc          ] Allocation Stall (main) 4.651ms</span><br><span class="line">[0.849s][info   ][gc          ] Allocation Stall (main) 0.808ms</span><br><span class="line">[0.849s][info   ][gc,phases   ] GC(63) Concurrent Relocate 2.375ms</span><br><span class="line">[0.849s][info   ][gc,load     ] GC(63) Load: 4.02/4.33/4.71</span><br><span class="line">[0.849s][info   ][gc,mmu      ] GC(63) MMU: 2ms/98.7%, 5ms/99.4%, 10ms/99.6%, 20ms/99.7%, 50ms/99.8%, 100ms/99.8%</span><br><span class="line">[0.849s][info   ][gc,marking  ] GC(63) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.849s][info   ][gc,marking  ] GC(63) Mark Stack Usage: 32M</span><br><span class="line">[0.849s][info   ][gc,nmethod  ] GC(63) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.849s][info   ][gc,metaspace] GC(63) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.849s][info   ][gc,ref      ] GC(63) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.849s][info   ][gc,ref      ] GC(63) Weak: 23 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.849s][info   ][gc,ref      ] GC(63) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.849s][info   ][gc,ref      ] GC(63) Phantom: 1 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.849s][info   ][gc,reloc    ] GC(63) Small Pages: 78 / 156M, Empty: 0M, Relocated: 19M, In-Place: 1</span><br><span class="line">[0.850s][info   ][gc,reloc    ] GC(63) Medium Pages: 22 / 352M, Empty: 0M, Relocated: 53M, In-Place: 4</span><br><span class="line">[0.850s][info   ][gc,reloc    ] GC(63) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.850s][info   ][gc,reloc    ] GC(63) Forwarding Usage: 0M</span><br><span class="line">[0.850s][info   ][gc,heap     ] GC(63) Min Capacity: 512M(100%)</span><br><span class="line">[0.850s][info   ][gc,heap     ] GC(63) Max Capacity: 512M(100%)</span><br><span class="line">[0.850s][info   ][gc,heap     ] GC(63) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.850s][info   ][gc,heap     ] GC(63)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.850s][info   ][gc,heap     ] GC(63)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.850s][info   ][gc,heap     ] GC(63)      Free:        4M (1%)            4M (1%)            4M (1%)           38M (7%)           38M (7%)            0M (0%)</span><br><span class="line">[0.850s][info   ][gc,heap     ] GC(63)      Used:      508M (99%)         508M (99%)         508M (99%)         474M (93%)         512M (100%)        474M (93%)</span><br><span class="line">[0.850s][info   ][gc,heap     ] GC(63)      Live:         -               361M (71%)         361M (71%)         361M (71%)            -                  -</span><br><span class="line">[0.850s][info   ][gc,heap     ] GC(63) Allocated:         -                 0M (0%)            0M (0%)           21M (4%)             -                  -</span><br><span class="line">[0.850s][info   ][gc,heap     ] GC(63)   Garbage:         -               146M (29%)         146M (29%)          90M (18%)            -                  -</span><br><span class="line">[0.850s][info   ][gc,heap     ] GC(63) Reclaimed:         -                  -                 0M (0%)           55M (11%)            -                  -</span><br><span class="line">[0.850s][info   ][gc          ] GC(63) Garbage Collection (Allocation Stall) 508M(99%)-&gt;474M(93%)</span><br><span class="line">[0.852s][info   ][gc,start    ] GC(64) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.852s][info   ][gc,ref      ] GC(64) Clearing All SoftReferences</span><br><span class="line">[0.852s][info   ][gc,task     ] GC(64) Using 2 workers</span><br><span class="line">[0.852s][info   ][gc,phases   ] GC(64) Pause Mark Start 0.004ms</span><br><span class="line">[0.854s][info   ][gc,phases   ] GC(64) Concurrent Mark 2.055ms</span><br><span class="line">[0.854s][info   ][gc,phases   ] GC(64) Pause Mark End 0.003ms</span><br><span class="line">[0.854s][info   ][gc,phases   ] GC(64) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.855s][info   ][gc,phases   ] GC(64) Concurrent Process Non-Strong References 0.175ms</span><br><span class="line">[0.855s][info   ][gc,phases   ] GC(64) Concurrent Reset Relocation Set 0.002ms</span><br><span class="line">[0.856s][info   ][gc,phases   ] GC(64) Concurrent Select Relocation Set 1.444ms</span><br><span class="line">[0.856s][info   ][gc,phases   ] GC(64) Pause Relocate Start 0.006ms</span><br><span class="line">[0.859s][info   ][gc          ] Relocation Stall (main) 1.560ms</span><br><span class="line">[0.859s][info   ][gc          ] Allocation Stall (main) 6.522ms</span><br><span class="line">[0.859s][info   ][gc,phases   ] GC(64) Concurrent Relocate 3.196ms</span><br><span class="line">[0.859s][info   ][gc,load     ] GC(64) Load: 4.02/4.33/4.71</span><br><span class="line">[0.859s][info   ][gc,mmu      ] GC(64) MMU: 2ms/98.7%, 5ms/99.4%, 10ms/99.6%, 20ms/99.7%, 50ms/99.8%, 100ms/99.8%</span><br><span class="line">[0.859s][info   ][gc,marking  ] GC(64) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.859s][info   ][gc,marking  ] GC(64) Mark Stack Usage: 32M</span><br><span class="line">[0.859s][info   ][gc,nmethod  ] GC(64) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.859s][info   ][gc,metaspace] GC(64) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.859s][info   ][gc,ref      ] GC(64) Soft: 3 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.859s][info   ][gc,ref      ] GC(64) Weak: 23 encountered, 12 discovered, 0 enqueued</span><br><span class="line">[0.859s][info   ][gc,ref      ] GC(64) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.859s][info   ][gc,ref      ] GC(64) Phantom: 1 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.859s][info   ][gc,reloc    ] GC(64) Small Pages: 80 / 160M, Empty: 0M, Relocated: 15M, In-Place: 0</span><br><span class="line">[0.860s][info   ][gc,reloc    ] GC(64) Medium Pages: 22 / 352M, Empty: 0M, Relocated: 69M, In-Place: 3</span><br><span class="line">[0.860s][info   ][gc,reloc    ] GC(64) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.860s][info   ][gc,reloc    ] GC(64) Forwarding Usage: 0M</span><br><span class="line">[0.860s][info   ][gc,heap     ] GC(64) Min Capacity: 512M(100%)</span><br><span class="line">[0.860s][info   ][gc,heap     ] GC(64) Max Capacity: 512M(100%)</span><br><span class="line">[0.860s][info   ][gc,heap     ] GC(64) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.860s][info   ][gc,heap     ] GC(64)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.860s][info   ][gc,heap     ] GC(64)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.860s][info   ][gc,heap     ] GC(64)      Free:        0M (0%)            0M (0%)            0M (0%)           54M (11%)          54M (11%)           0M (0%)</span><br><span class="line">[0.860s][info   ][gc,heap     ] GC(64)      Used:      512M (100%)        512M (100%)        512M (100%)        458M (89%)         512M (100%)        458M (89%)</span><br><span class="line">[0.860s][info   ][gc,heap     ] GC(64)      Live:         -               359M (70%)         359M (70%)         359M (70%)            -                  -</span><br><span class="line">[0.860s][info   ][gc,heap     ] GC(64) Allocated:         -                 0M (0%)            0M (0%)           20M (4%)             -                  -</span><br><span class="line">[0.860s][info   ][gc,heap     ] GC(64)   Garbage:         -               152M (30%)         152M (30%)          78M (15%)            -                  -</span><br><span class="line">[0.860s][info   ][gc,heap     ] GC(64) Reclaimed:         -                  -                 0M (0%)           74M (14%)            -                  -</span><br><span class="line">[0.860s][info   ][gc          ] GC(64) Garbage Collection (Allocation Stall) 512M(100%)-&gt;458M(89%)</span><br><span class="line">[0.863s][info   ][gc,start    ] GC(65) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.863s][info   ][gc,ref      ] GC(65) Clearing All SoftReferences</span><br><span class="line">[0.863s][info   ][gc,task     ] GC(65) Using 2 workers</span><br><span class="line">[0.863s][info   ][gc,phases   ] GC(65) Pause Mark Start 0.006ms</span><br><span class="line">[0.866s][info   ][gc,phases   ] GC(65) Concurrent Mark 2.956ms</span><br><span class="line">[0.866s][info   ][gc,phases   ] GC(65) Pause Mark End 0.004ms</span><br><span class="line">[0.866s][info   ][gc,phases   ] GC(65) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.866s][info   ][gc,phases   ] GC(65) Concurrent Process Non-Strong References 0.228ms</span><br><span class="line">[0.866s][info   ][gc,phases   ] GC(65) Concurrent Reset Relocation Set 0.002ms</span><br><span class="line">[0.868s][info   ][gc,phases   ] GC(65) Concurrent Select Relocation Set 1.485ms</span><br><span class="line">[0.868s][info   ][gc,phases   ] GC(65) Pause Relocate Start 0.005ms</span><br><span class="line">[0.869s][info   ][gc          ] Allocation Stall (main) 5.988ms</span><br><span class="line">[0.869s][info   ][gc          ] Allocation Stall (main) 0.179ms</span><br><span class="line">[0.870s][info   ][gc,phases   ] GC(65) Concurrent Relocate 2.007ms</span><br><span class="line">[0.870s][info   ][gc,load     ] GC(65) Load: 4.02/4.33/4.71</span><br><span class="line">[0.870s][info   ][gc,mmu      ] GC(65) MMU: 2ms/98.7%, 5ms/99.4%, 10ms/99.6%, 20ms/99.7%, 50ms/99.8%, 100ms/99.8%</span><br><span class="line">[0.870s][info   ][gc,marking  ] GC(65) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.870s][info   ][gc,marking  ] GC(65) Mark Stack Usage: 32M</span><br><span class="line">[0.870s][info   ][gc,nmethod  ] GC(65) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.870s][info   ][gc,metaspace] GC(65) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.870s][info   ][gc,ref      ] GC(65) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.870s][info   ][gc,ref      ] GC(65) Weak: 23 encountered, 7 discovered, 0 enqueued</span><br><span class="line">[0.870s][info   ][gc,ref      ] GC(65) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.870s][info   ][gc,ref      ] GC(65) Phantom: 1 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.870s][info   ][gc,reloc    ] GC(65) Small Pages: 80 / 160M, Empty: 0M, Relocated: 12M, In-Place: 0</span><br><span class="line">[0.870s][info   ][gc,reloc    ] GC(65) Medium Pages: 22 / 352M, Empty: 0M, Relocated: 27M, In-Place: 2</span><br><span class="line">[0.870s][info   ][gc,reloc    ] GC(65) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.870s][info   ][gc,reloc    ] GC(65) Forwarding Usage: 0M</span><br><span class="line">[0.870s][info   ][gc,heap     ] GC(65) Min Capacity: 512M(100%)</span><br><span class="line">[0.870s][info   ][gc,heap     ] GC(65) Max Capacity: 512M(100%)</span><br><span class="line">[0.870s][info   ][gc,heap     ] GC(65) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.870s][info   ][gc,heap     ] GC(65)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.870s][info   ][gc,heap     ] GC(65)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.870s][info   ][gc,heap     ] GC(65)      Free:        0M (0%)            0M (0%)            0M (0%)           50M (10%)          50M (10%)           0M (0%)</span><br><span class="line">[0.870s][info   ][gc,heap     ] GC(65)      Used:      512M (100%)        512M (100%)        512M (100%)        462M (90%)         512M (100%)        462M (90%)</span><br><span class="line">[0.870s][info   ][gc,heap     ] GC(65)      Live:         -               355M (69%)         355M (69%)         355M (69%)            -                  -</span><br><span class="line">[0.870s][info   ][gc,heap     ] GC(65) Allocated:         -                 0M (0%)            0M (0%)           22M (4%)             -                  -</span><br><span class="line">[0.870s][info   ][gc,heap     ] GC(65)   Garbage:         -               156M (31%)         156M (31%)          84M (17%)            -                  -</span><br><span class="line">[0.870s][info   ][gc,heap     ] GC(65) Reclaimed:         -                  -                 0M (0%)           72M (14%)            -                  -</span><br><span class="line">[0.870s][info   ][gc          ] GC(65) Garbage Collection (Allocation Stall) 512M(100%)-&gt;462M(90%)</span><br><span class="line">[0.873s][info   ][gc,start    ] GC(66) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.873s][info   ][gc,ref      ] GC(66) Clearing All SoftReferences</span><br><span class="line">[0.873s][info   ][gc,task     ] GC(66) Using 2 workers</span><br><span class="line">[0.873s][info   ][gc,phases   ] GC(66) Pause Mark Start 0.003ms</span><br><span class="line">[0.875s][info   ][gc,phases   ] GC(66) Concurrent Mark 2.275ms</span><br><span class="line">[0.875s][info   ][gc,phases   ] GC(66) Pause Mark End 0.004ms</span><br><span class="line">[0.875s][info   ][gc,phases   ] GC(66) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.876s][info   ][gc,phases   ] GC(66) Concurrent Process Non-Strong References 0.204ms</span><br><span class="line">[0.876s][info   ][gc,phases   ] GC(66) Concurrent Reset Relocation Set 0.002ms</span><br><span class="line">[0.877s][info   ][gc,phases   ] GC(66) Concurrent Select Relocation Set 1.384ms</span><br><span class="line">[0.877s][info   ][gc,phases   ] GC(66) Pause Relocate Start 0.003ms</span><br><span class="line">[0.878s][info   ][gc          ] Allocation Stall (main) 5.086ms</span><br><span class="line">[0.879s][info   ][gc,phases   ] GC(66) Concurrent Relocate 2.002ms</span><br><span class="line">[0.879s][info   ][gc,load     ] GC(66) Load: 4.02/4.33/4.71</span><br><span class="line">[0.879s][info   ][gc,mmu      ] GC(66) MMU: 2ms/98.7%, 5ms/99.4%, 10ms/99.6%, 20ms/99.7%, 50ms/99.8%, 100ms/99.8%</span><br><span class="line">[0.879s][info   ][gc,marking  ] GC(66) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.879s][info   ][gc,marking  ] GC(66) Mark Stack Usage: 32M</span><br><span class="line">[0.879s][info   ][gc,nmethod  ] GC(66) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.879s][info   ][gc,metaspace] GC(66) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.879s][info   ][gc,ref      ] GC(66) Soft: 3 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.879s][info   ][gc,ref      ] GC(66) Weak: 23 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.879s][info   ][gc,ref      ] GC(66) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.879s][info   ][gc,ref      ] GC(66) Phantom: 1 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.879s][info   ][gc,reloc    ] GC(66) Small Pages: 83 / 166M, Empty: 0M, Relocated: 20M, In-Place: 0</span><br><span class="line">[0.879s][info   ][gc,reloc    ] GC(66) Medium Pages: 21 / 336M, Empty: 0M, Relocated: 41M, In-Place: 3</span><br><span class="line">[0.879s][info   ][gc,reloc    ] GC(66) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.879s][info   ][gc,reloc    ] GC(66) Forwarding Usage: 0M</span><br><span class="line">[0.879s][info   ][gc,heap     ] GC(66) Min Capacity: 512M(100%)</span><br><span class="line">[0.879s][info   ][gc,heap     ] GC(66) Max Capacity: 512M(100%)</span><br><span class="line">[0.879s][info   ][gc,heap     ] GC(66) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.879s][info   ][gc,heap     ] GC(66)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.879s][info   ][gc,heap     ] GC(66)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.879s][info   ][gc,heap     ] GC(66)      Free:       10M (2%)           10M (2%)           10M (2%)           46M (9%)           46M (9%)            6M (1%)</span><br><span class="line">[0.879s][info   ][gc,heap     ] GC(66)      Used:      502M (98%)         502M (98%)         502M (98%)         466M (91%)         506M (99%)         466M (91%)</span><br><span class="line">[0.879s][info   ][gc,heap     ] GC(66)      Live:         -               354M (69%)         354M (69%)         354M (69%)            -                  -</span><br><span class="line">[0.879s][info   ][gc,heap     ] GC(66) Allocated:         -                 0M (0%)            0M (0%)           22M (4%)             -                  -</span><br><span class="line">[0.879s][info   ][gc,heap     ] GC(66)   Garbage:         -               147M (29%)         147M (29%)          89M (17%)            -                  -</span><br><span class="line">[0.879s][info   ][gc,heap     ] GC(66) Reclaimed:         -                  -                 0M (0%)           58M (11%)            -                  -</span><br><span class="line">[0.880s][info   ][gc          ] GC(66) Garbage Collection (Allocation Stall) 502M(98%)-&gt;466M(91%)</span><br><span class="line">[0.882s][info   ][gc,start    ] GC(67) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.882s][info   ][gc,ref      ] GC(67) Clearing All SoftReferences</span><br><span class="line">[0.882s][info   ][gc,task     ] GC(67) Using 2 workers</span><br><span class="line">[0.882s][info   ][gc,phases   ] GC(67) Pause Mark Start 0.003ms</span><br><span class="line">[0.884s][info   ][gc,phases   ] GC(67) Concurrent Mark 2.133ms</span><br><span class="line">[0.884s][info   ][gc,phases   ] GC(67) Pause Mark End 0.005ms</span><br><span class="line">[0.884s][info   ][gc,phases   ] GC(67) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.884s][info   ][gc,phases   ] GC(67) Concurrent Process Non-Strong References 0.203ms</span><br><span class="line">[0.884s][info   ][gc,phases   ] GC(67) Concurrent Reset Relocation Set 0.002ms</span><br><span class="line">[0.886s][info   ][gc,phases   ] GC(67) Concurrent Select Relocation Set 1.421ms</span><br><span class="line">[0.886s][info   ][gc,phases   ] GC(67) Pause Relocate Start 0.005ms</span><br><span class="line">[0.887s][info   ][gc          ] Allocation Stall (main) 5.415ms</span><br><span class="line">[0.888s][info   ][gc,phases   ] GC(67) Concurrent Relocate 2.096ms</span><br><span class="line">[0.888s][info   ][gc,load     ] GC(67) Load: 4.02/4.33/4.71</span><br><span class="line">[0.888s][info   ][gc,mmu      ] GC(67) MMU: 2ms/98.7%, 5ms/99.4%, 10ms/99.6%, 20ms/99.7%, 50ms/99.8%, 100ms/99.8%</span><br><span class="line">[0.888s][info   ][gc,marking  ] GC(67) Mark: 2 stripe(s), 2 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.888s][info   ][gc,marking  ] GC(67) Mark Stack Usage: 32M</span><br><span class="line">[0.888s][info   ][gc,nmethod  ] GC(67) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.888s][info   ][gc,metaspace] GC(67) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.888s][info   ][gc,ref      ] GC(67) Soft: 3 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.888s][info   ][gc,ref      ] GC(67) Weak: 23 encountered, 3 discovered, 0 enqueued</span><br><span class="line">[0.888s][info   ][gc,ref      ] GC(67) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.888s][info   ][gc,ref      ] GC(67) Phantom: 1 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.888s][info   ][gc,reloc    ] GC(67) Small Pages: 84 / 168M, Empty: 0M, Relocated: 20M, In-Place: 0</span><br><span class="line">[0.888s][info   ][gc,reloc    ] GC(67) Medium Pages: 21 / 336M, Empty: 0M, Relocated: 54M, In-Place: 4</span><br><span class="line">[0.888s][info   ][gc,reloc    ] GC(67) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.888s][info   ][gc,reloc    ] GC(67) Forwarding Usage: 0M</span><br><span class="line">[0.888s][info   ][gc,heap     ] GC(67) Min Capacity: 512M(100%)</span><br><span class="line">[0.888s][info   ][gc,heap     ] GC(67) Max Capacity: 512M(100%)</span><br><span class="line">[0.888s][info   ][gc,heap     ] GC(67) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.888s][info   ][gc,heap     ] GC(67)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.888s][info   ][gc,heap     ] GC(67)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.888s][info   ][gc,heap     ] GC(67)      Free:        8M (2%)            8M (2%)            8M (2%)           46M (9%)           46M (9%)            4M (1%)</span><br><span class="line">[0.888s][info   ][gc,heap     ] GC(67)      Used:      504M (98%)         504M (98%)         504M (98%)         466M (91%)         508M (99%)         466M (91%)</span><br><span class="line">[0.888s][info   ][gc,heap     ] GC(67)      Live:         -               346M (68%)         346M (68%)         346M (68%)            -                  -</span><br><span class="line">[0.888s][info   ][gc,heap     ] GC(67) Allocated:         -                 0M (0%)            0M (0%)           24M (5%)             -                  -</span><br><span class="line">[0.888s][info   ][gc,heap     ] GC(67)   Garbage:         -               157M (31%)         157M (31%)          95M (19%)            -                  -</span><br><span class="line">[0.888s][info   ][gc,heap     ] GC(67) Reclaimed:         -                  -                 0M (0%)           62M (12%)            -                  -</span><br><span class="line">[0.888s][info   ][gc          ] GC(67) Garbage Collection (Allocation Stall) 504M(98%)-&gt;466M(91%)</span><br><span class="line">[0.891s][info   ][gc,start    ] GC(68) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.891s][info   ][gc,ref      ] GC(68) Clearing All SoftReferences</span><br><span class="line">[0.891s][info   ][gc,task     ] GC(68) Using 2 workers</span><br><span class="line">[0.891s][info   ][gc,phases   ] GC(68) Pause Mark Start 0.003ms</span><br><span class="line">[0.893s][info   ][gc,phases   ] GC(68) Concurrent Mark 1.826ms</span><br><span class="line">[0.893s][info   ][gc,phases   ] GC(68) Pause Mark End 0.006ms</span><br><span class="line">[0.893s][info   ][gc,phases   ] GC(68) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.893s][info   ][gc,phases   ] GC(68) Concurrent Process Non-Strong References 0.193ms</span><br><span class="line">[0.893s][info   ][gc,phases   ] GC(68) Concurrent Reset Relocation Set 0.002ms</span><br><span class="line">[0.895s][info   ][gc,phases   ] GC(68) Concurrent Select Relocation Set 1.413ms</span><br><span class="line">[0.895s][info   ][gc,phases   ] GC(68) Pause Relocate Start 0.004ms</span><br><span class="line">[0.897s][info   ][gc,phases   ] GC(68) Concurrent Relocate 1.760ms</span><br><span class="line">[0.897s][info   ][gc          ] Allocation Stall (main) 5.686ms</span><br><span class="line">[0.897s][info   ][gc,load     ] GC(68) Load: 4.02/4.33/4.71</span><br><span class="line">[0.897s][info   ][gc,mmu      ] GC(68) MMU: 2ms/98.7%, 5ms/99.4%, 10ms/99.6%, 20ms/99.7%, 50ms/99.8%, 100ms/99.8%</span><br><span class="line">[0.897s][info   ][gc,marking  ] GC(68) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.897s][info   ][gc,marking  ] GC(68) Mark Stack Usage: 32M</span><br><span class="line">[0.897s][info   ][gc,nmethod  ] GC(68) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.897s][info   ][gc,metaspace] GC(68) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.897s][info   ][gc,ref      ] GC(68) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.897s][info   ][gc,ref      ] GC(68) Weak: 23 encountered, 11 discovered, 0 enqueued</span><br><span class="line">[0.897s][info   ][gc,ref      ] GC(68) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.897s][info   ][gc,ref      ] GC(68) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.897s][info   ][gc,reloc    ] GC(68) Small Pages: 85 / 170M, Empty: 0M, Relocated: 36M, In-Place: 0</span><br><span class="line">[0.897s][info   ][gc,reloc    ] GC(68) Medium Pages: 21 / 336M, Empty: 0M, Relocated: 40M, In-Place: 3</span><br><span class="line">[0.897s][info   ][gc,reloc    ] GC(68) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.897s][info   ][gc,reloc    ] GC(68) Forwarding Usage: 0M</span><br><span class="line">[0.897s][info   ][gc,heap     ] GC(68) Min Capacity: 512M(100%)</span><br><span class="line">[0.897s][info   ][gc,heap     ] GC(68) Max Capacity: 512M(100%)</span><br><span class="line">[0.897s][info   ][gc,heap     ] GC(68) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.897s][info   ][gc,heap     ] GC(68)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.897s][info   ][gc,heap     ] GC(68)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.897s][info   ][gc,heap     ] GC(68)      Free:        6M (1%)            6M (1%)            6M (1%)           62M (12%)          62M (12%)           4M (1%)</span><br><span class="line">[0.897s][info   ][gc,heap     ] GC(68)      Used:      506M (99%)         506M (99%)         506M (99%)         450M (88%)         508M (99%)         450M (88%)</span><br><span class="line">[0.897s][info   ][gc,heap     ] GC(68)      Live:         -               341M (67%)         341M (67%)         341M (67%)            -                  -</span><br><span class="line">[0.897s][info   ][gc,heap     ] GC(68) Allocated:         -                 0M (0%)            0M (0%)           16M (3%)             -                  -</span><br><span class="line">[0.897s][info   ][gc,heap     ] GC(68)   Garbage:         -               164M (32%)         164M (32%)          92M (18%)            -                  -</span><br><span class="line">[0.897s][info   ][gc,heap     ] GC(68) Reclaimed:         -                  -                 0M (0%)           72M (14%)            -                  -</span><br><span class="line">[0.897s][info   ][gc          ] GC(68) Garbage Collection (Allocation Stall) 506M(99%)-&gt;450M(88%)</span><br><span class="line">[0.901s][info   ][gc,start    ] GC(69) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.901s][info   ][gc,ref      ] GC(69) Clearing All SoftReferences</span><br><span class="line">[0.901s][info   ][gc,task     ] GC(69) Using 2 workers</span><br><span class="line">[0.901s][info   ][gc,phases   ] GC(69) Pause Mark Start 0.004ms</span><br><span class="line">[0.903s][info   ][gc,phases   ] GC(69) Concurrent Mark 1.786ms</span><br><span class="line">[0.903s][info   ][gc,phases   ] GC(69) Pause Mark End 0.003ms</span><br><span class="line">[0.903s][info   ][gc,phases   ] GC(69) Concurrent Mark Free 0.001ms</span><br><span class="line">[0.903s][info   ][gc,phases   ] GC(69) Concurrent Process Non-Strong References 0.233ms</span><br><span class="line">[0.903s][info   ][gc,phases   ] GC(69) Concurrent Reset Relocation Set 0.003ms</span><br><span class="line">[0.905s][info   ][gc,phases   ] GC(69) Concurrent Select Relocation Set 1.398ms</span><br><span class="line">[0.905s][info   ][gc,phases   ] GC(69) Pause Relocate Start 0.005ms</span><br><span class="line">[0.906s][info   ][gc          ] Allocation Stall (main) 5.233ms</span><br><span class="line">[0.907s][info   ][gc          ] Allocation Stall (main) 0.244ms</span><br><span class="line">[0.909s][info   ][gc,phases   ] GC(69) Concurrent Relocate 3.941ms</span><br><span class="line">[0.909s][info   ][gc,load     ] GC(69) Load: 4.02/4.33/4.71</span><br><span class="line">[0.909s][info   ][gc,mmu      ] GC(69) MMU: 2ms/98.7%, 5ms/99.4%, 10ms/99.6%, 20ms/99.7%, 50ms/99.8%, 100ms/99.8%</span><br><span class="line">[0.909s][info   ][gc,marking  ] GC(69) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.909s][info   ][gc,marking  ] GC(69) Mark Stack Usage: 32M</span><br><span class="line">[0.909s][info   ][gc,nmethod  ] GC(69) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.909s][info   ][gc,metaspace] GC(69) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.909s][info   ][gc,ref      ] GC(69) Soft: 3 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.909s][info   ][gc,ref      ] GC(69) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.909s][info   ][gc,ref      ] GC(69) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.909s][info   ][gc,ref      ] GC(69) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.909s][info   ][gc,reloc    ] GC(69) Small Pages: 80 / 160M, Empty: 0M, Relocated: 26M, In-Place: 0</span><br><span class="line">[0.909s][info   ][gc,reloc    ] GC(69) Medium Pages: 22 / 352M, Empty: 0M, Relocated: 82M, In-Place: 4</span><br><span class="line">[0.909s][info   ][gc,reloc    ] GC(69) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.909s][info   ][gc,reloc    ] GC(69) Forwarding Usage: 0M</span><br><span class="line">[0.909s][info   ][gc,heap     ] GC(69) Min Capacity: 512M(100%)</span><br><span class="line">[0.909s][info   ][gc,heap     ] GC(69) Max Capacity: 512M(100%)</span><br><span class="line">[0.909s][info   ][gc,heap     ] GC(69) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.909s][info   ][gc,heap     ] GC(69)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.909s][info   ][gc,heap     ] GC(69)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.909s][info   ][gc,heap     ] GC(69)      Free:        0M (0%)            0M (0%)            0M (0%)           70M (14%)          70M (14%)           0M (0%)</span><br><span class="line">[0.909s][info   ][gc,heap     ] GC(69)      Used:      512M (100%)        512M (100%)        512M (100%)        442M (86%)         512M (100%)        442M (86%)</span><br><span class="line">[0.909s][info   ][gc,heap     ] GC(69)      Live:         -               336M (66%)         336M (66%)         336M (66%)            -                  -</span><br><span class="line">[0.909s][info   ][gc,heap     ] GC(69) Allocated:         -                 0M (0%)            0M (0%)           27M (5%)             -                  -</span><br><span class="line">[0.909s][info   ][gc,heap     ] GC(69)   Garbage:         -               175M (34%)         175M (34%)          77M (15%)            -                  -</span><br><span class="line">[0.909s][info   ][gc,heap     ] GC(69) Reclaimed:         -                  -                 0M (0%)           97M (19%)            -                  -</span><br><span class="line">[0.909s][info   ][gc          ] GC(69) Garbage Collection (Allocation Stall) 512M(100%)-&gt;442M(86%)</span><br><span class="line">[0.911s][info   ][gc,start    ] GC(70) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.911s][info   ][gc,ref      ] GC(70) Clearing All SoftReferences</span><br><span class="line">[0.911s][info   ][gc,task     ] GC(70) Using 2 workers</span><br><span class="line">[0.911s][info   ][gc,phases   ] GC(70) Pause Mark Start 0.006ms</span><br><span class="line">[0.913s][info   ][gc,phases   ] GC(70) Concurrent Mark 1.793ms</span><br><span class="line">[0.913s][info   ][gc,phases   ] GC(70) Pause Mark End 0.004ms</span><br><span class="line">[0.913s][info   ][gc,phases   ] GC(70) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.914s][info   ][gc,phases   ] GC(70) Concurrent Process Non-Strong References 0.233ms</span><br><span class="line">[0.914s][info   ][gc,phases   ] GC(70) Concurrent Reset Relocation Set 0.003ms</span><br><span class="line">[0.915s][info   ][gc,phases   ] GC(70) Concurrent Select Relocation Set 1.419ms</span><br><span class="line">[0.915s][info   ][gc,phases   ] GC(70) Pause Relocate Start 0.004ms</span><br><span class="line">[0.916s][info   ][gc          ] Allocation Stall (main) 4.290ms</span><br><span class="line">[0.918s][info   ][gc,phases   ] GC(70) Concurrent Relocate 2.218ms</span><br><span class="line">[0.918s][info   ][gc,load     ] GC(70) Load: 4.02/4.33/4.71</span><br><span class="line">[0.918s][info   ][gc,mmu      ] GC(70) MMU: 2ms/98.7%, 5ms/99.4%, 10ms/99.6%, 20ms/99.7%, 50ms/99.8%, 100ms/99.8%</span><br><span class="line">[0.918s][info   ][gc,marking  ] GC(70) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.918s][info   ][gc,marking  ] GC(70) Mark Stack Usage: 32M</span><br><span class="line">[0.918s][info   ][gc,nmethod  ] GC(70) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.918s][info   ][gc,metaspace] GC(70) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.918s][info   ][gc,ref      ] GC(70) Soft: 3 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.918s][info   ][gc,ref      ] GC(70) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.918s][info   ][gc,ref      ] GC(70) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.918s][info   ][gc,ref      ] GC(70) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.918s][info   ][gc,reloc    ] GC(70) Small Pages: 81 / 162M, Empty: 0M, Relocated: 17M, In-Place: 0</span><br><span class="line">[0.918s][info   ][gc,reloc    ] GC(70) Medium Pages: 21 / 336M, Empty: 0M, Relocated: 69M, In-Place: 2</span><br><span class="line">[0.918s][info   ][gc,reloc    ] GC(70) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.918s][info   ][gc,reloc    ] GC(70) Forwarding Usage: 0M</span><br><span class="line">[0.918s][info   ][gc,heap     ] GC(70) Min Capacity: 512M(100%)</span><br><span class="line">[0.918s][info   ][gc,heap     ] GC(70) Max Capacity: 512M(100%)</span><br><span class="line">[0.918s][info   ][gc,heap     ] GC(70) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.918s][info   ][gc,heap     ] GC(70)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.918s][info   ][gc,heap     ] GC(70)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.918s][info   ][gc,heap     ] GC(70)      Free:       14M (3%)           14M (3%)           14M (3%)           82M (16%)          82M (16%)          10M (2%)</span><br><span class="line">[0.918s][info   ][gc,heap     ] GC(70)      Used:      498M (97%)         498M (97%)         498M (97%)         430M (84%)         502M (98%)         430M (84%)</span><br><span class="line">[0.918s][info   ][gc,heap     ] GC(70)      Live:         -               337M (66%)         337M (66%)         337M (66%)            -                  -</span><br><span class="line">[0.918s][info   ][gc,heap     ] GC(70) Allocated:         -                 0M (0%)            0M (0%)           25M (5%)             -                  -</span><br><span class="line">[0.918s][info   ][gc,heap     ] GC(70)   Garbage:         -               160M (31%)         160M (31%)          66M (13%)            -                  -</span><br><span class="line">[0.918s][info   ][gc,heap     ] GC(70) Reclaimed:         -                  -                 0M (0%)           93M (18%)            -                  -</span><br><span class="line">[0.918s][info   ][gc          ] GC(70) Garbage Collection (Allocation Stall) 498M(97%)-&gt;430M(84%)</span><br><span class="line">[0.922s][info   ][gc,start    ] GC(71) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.922s][info   ][gc,ref      ] GC(71) Clearing All SoftReferences</span><br><span class="line">[0.922s][info   ][gc,task     ] GC(71) Using 2 workers</span><br><span class="line">[0.922s][info   ][gc,phases   ] GC(71) Pause Mark Start 0.012ms</span><br><span class="line">[0.926s][info   ][gc,phases   ] GC(71) Concurrent Mark 3.452ms</span><br><span class="line">[0.926s][info   ][gc,phases   ] GC(71) Pause Mark End 0.012ms</span><br><span class="line">[0.926s][info   ][gc,phases   ] GC(71) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.927s][info   ][gc,phases   ] GC(71) Concurrent Process Non-Strong References 0.274ms</span><br><span class="line">[0.927s][info   ][gc,phases   ] GC(71) Concurrent Reset Relocation Set 0.002ms</span><br><span class="line">[0.928s][info   ][gc,phases   ] GC(71) Concurrent Select Relocation Set 1.449ms</span><br><span class="line">[0.928s][info   ][gc,phases   ] GC(71) Pause Relocate Start 0.007ms</span><br><span class="line">[0.930s][info   ][gc          ] Allocation Stall (main) 7.966ms</span><br><span class="line">[0.932s][info   ][gc,phases   ] GC(71) Concurrent Relocate 4.215ms</span><br><span class="line">[0.933s][info   ][gc,load     ] GC(71) Load: 4.02/4.33/4.71</span><br><span class="line">[0.933s][info   ][gc,mmu      ] GC(71) MMU: 2ms/98.7%, 5ms/99.4%, 10ms/99.6%, 20ms/99.7%, 50ms/99.8%, 100ms/99.8%</span><br><span class="line">[0.933s][info   ][gc,marking  ] GC(71) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.933s][info   ][gc,marking  ] GC(71) Mark Stack Usage: 32M</span><br><span class="line">[0.933s][info   ][gc,nmethod  ] GC(71) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.933s][info   ][gc,metaspace] GC(71) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.933s][info   ][gc,ref      ] GC(71) Soft: 3 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.933s][info   ][gc,ref      ] GC(71) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.933s][info   ][gc,ref      ] GC(71) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.933s][info   ][gc,ref      ] GC(71) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.933s][info   ][gc,reloc    ] GC(71) Small Pages: 88 / 176M, Empty: 0M, Relocated: 31M, In-Place: 0</span><br><span class="line">[0.933s][info   ][gc,reloc    ] GC(71) Medium Pages: 21 / 336M, Empty: 0M, Relocated: 54M, In-Place: 2</span><br><span class="line">[0.933s][info   ][gc,reloc    ] GC(71) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.933s][info   ][gc,reloc    ] GC(71) Forwarding Usage: 0M</span><br><span class="line">[0.933s][info   ][gc,heap     ] GC(71) Min Capacity: 512M(100%)</span><br><span class="line">[0.933s][info   ][gc,heap     ] GC(71) Max Capacity: 512M(100%)</span><br><span class="line">[0.933s][info   ][gc,heap     ] GC(71) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.933s][info   ][gc,heap     ] GC(71)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.933s][info   ][gc,heap     ] GC(71)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.933s][info   ][gc,heap     ] GC(71)      Free:        0M (0%)            0M (0%)            0M (0%)           60M (12%)          60M (12%)           0M (0%)</span><br><span class="line">[0.933s][info   ][gc,heap     ] GC(71)      Used:      512M (100%)        512M (100%)        512M (100%)        452M (88%)         512M (100%)        452M (88%)</span><br><span class="line">[0.933s][info   ][gc,heap     ] GC(71)      Live:         -               341M (67%)         341M (67%)         341M (67%)            -                  -</span><br><span class="line">[0.933s][info   ][gc,heap     ] GC(71) Allocated:         -                 0M (0%)            0M (0%)           31M (6%)             -                  -</span><br><span class="line">[0.933s][info   ][gc,heap     ] GC(71)   Garbage:         -               170M (33%)         170M (33%)          78M (15%)            -                  -</span><br><span class="line">[0.933s][info   ][gc,heap     ] GC(71) Reclaimed:         -                  -                 0M (0%)           91M (18%)            -                  -</span><br><span class="line">[0.933s][info   ][gc          ] GC(71) Garbage Collection (Allocation Stall) 512M(100%)-&gt;452M(88%)</span><br><span class="line">[0.937s][info   ][gc,start    ] GC(72) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.937s][info   ][gc,ref      ] GC(72) Clearing All SoftReferences</span><br><span class="line">[0.937s][info   ][gc,task     ] GC(72) Using 2 workers</span><br><span class="line">[0.937s][info   ][gc,phases   ] GC(72) Pause Mark Start 0.007ms</span><br><span class="line">[0.940s][info   ][gc,phases   ] GC(72) Concurrent Mark 2.289ms</span><br><span class="line">[0.941s][info   ][gc,phases   ] GC(72) Pause Mark End 0.007ms</span><br><span class="line">[0.941s][info   ][gc,phases   ] GC(72) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.941s][info   ][gc,phases   ] GC(72) Concurrent Process Non-Strong References 0.264ms</span><br><span class="line">[0.941s][info   ][gc,phases   ] GC(72) Concurrent Reset Relocation Set 0.003ms</span><br><span class="line">[0.943s][info   ][gc,phases   ] GC(72) Concurrent Select Relocation Set 1.734ms</span><br><span class="line">[0.943s][info   ][gc,phases   ] GC(72) Pause Relocate Start 0.005ms</span><br><span class="line">[0.945s][info   ][gc,phases   ] GC(72) Concurrent Relocate 2.002ms</span><br><span class="line">[0.945s][info   ][gc,load     ] GC(72) Load: 4.02/4.33/4.71</span><br><span class="line">[0.945s][info   ][gc,mmu      ] GC(72) MMU: 2ms/98.7%, 5ms/99.4%, 10ms/99.6%, 20ms/99.7%, 50ms/99.8%, 100ms/99.8%</span><br><span class="line">[0.945s][info   ][gc,marking  ] GC(72) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.945s][info   ][gc,marking  ] GC(72) Mark Stack Usage: 32M</span><br><span class="line">[0.945s][info   ][gc,nmethod  ] GC(72) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.945s][info   ][gc,metaspace] GC(72) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.945s][info   ][gc,ref      ] GC(72) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.945s][info   ][gc          ] Allocation Stall (main) 8.139ms</span><br><span class="line">[0.945s][info   ][gc,ref      ] GC(72) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.946s][info   ][gc,ref      ] GC(72) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.946s][info   ][gc,ref      ] GC(72) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.946s][info   ][gc,reloc    ] GC(72) Small Pages: 88 / 176M, Empty: 0M, Relocated: 31M, In-Place: 1</span><br><span class="line">[0.946s][info   ][gc,reloc    ] GC(72) Medium Pages: 21 / 336M, Empty: 0M, Relocated: 39M, In-Place: 3</span><br><span class="line">[0.946s][info   ][gc,reloc    ] GC(72) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.946s][info   ][gc,reloc    ] GC(72) Forwarding Usage: 0M</span><br><span class="line">[0.946s][info   ][gc,heap     ] GC(72) Min Capacity: 512M(100%)</span><br><span class="line">[0.946s][info   ][gc,heap     ] GC(72) Max Capacity: 512M(100%)</span><br><span class="line">[0.946s][info   ][gc,heap     ] GC(72) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.946s][info   ][gc,heap     ] GC(72)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.946s][info   ][gc,heap     ] GC(72)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.946s][info   ][gc,heap     ] GC(72)      Free:        0M (0%)            0M (0%)            0M (0%)           60M (12%)          60M (12%)           0M (0%)</span><br><span class="line">[0.946s][info   ][gc,heap     ] GC(72)      Used:      512M (100%)        512M (100%)        512M (100%)        452M (88%)         512M (100%)        452M (88%)</span><br><span class="line">[0.946s][info   ][gc,heap     ] GC(72)      Live:         -               347M (68%)         347M (68%)         347M (68%)            -                  -</span><br><span class="line">[0.946s][info   ][gc,heap     ] GC(72) Allocated:         -                 0M (0%)            0M (0%)           16M (3%)             -                  -</span><br><span class="line">[0.946s][info   ][gc,heap     ] GC(72)   Garbage:         -               164M (32%)         164M (32%)          88M (17%)            -                  -</span><br><span class="line">[0.947s][info   ][gc,heap     ] GC(72) Reclaimed:         -                  -                 0M (0%)           76M (15%)            -                  -</span><br><span class="line">[0.947s][info   ][gc          ] GC(72) Garbage Collection (Allocation Stall) 512M(100%)-&gt;452M(88%)</span><br><span class="line">[0.949s][info   ][gc,start    ] GC(73) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.950s][info   ][gc,ref      ] GC(73) Clearing All SoftReferences</span><br><span class="line">[0.950s][info   ][gc,task     ] GC(73) Using 2 workers</span><br><span class="line">[0.950s][info   ][gc,phases   ] GC(73) Pause Mark Start 0.004ms</span><br><span class="line">[0.952s][info   ][gc,phases   ] GC(73) Concurrent Mark 2.526ms</span><br><span class="line">[0.952s][info   ][gc,phases   ] GC(73) Pause Mark End 0.024ms</span><br><span class="line">[0.952s][info   ][gc,phases   ] GC(73) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.953s][info   ][gc,phases   ] GC(73) Concurrent Process Non-Strong References 0.739ms</span><br><span class="line">[0.953s][info   ][gc,phases   ] GC(73) Concurrent Reset Relocation Set 0.003ms</span><br><span class="line">[0.955s][info   ][gc,phases   ] GC(73) Concurrent Select Relocation Set 1.491ms</span><br><span class="line">[0.955s][info   ][gc,phases   ] GC(73) Pause Relocate Start 0.008ms</span><br><span class="line">[0.956s][info   ][gc          ] Allocation Stall (main) 6.990ms</span><br><span class="line">[0.958s][info   ][gc,phases   ] GC(73) Concurrent Relocate 2.941ms</span><br><span class="line">[0.958s][info   ][gc,load     ] GC(73) Load: 4.02/4.33/4.71</span><br><span class="line">[0.958s][info   ][gc,mmu      ] GC(73) MMU: 2ms/98.7%, 5ms/99.4%, 10ms/99.6%, 20ms/99.7%, 50ms/99.8%, 100ms/99.8%</span><br><span class="line">[0.958s][info   ][gc,marking  ] GC(73) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.958s][info   ][gc,marking  ] GC(73) Mark Stack Usage: 32M</span><br><span class="line">[0.958s][info   ][gc,nmethod  ] GC(73) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.958s][info   ][gc,metaspace] GC(73) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.958s][info   ][gc,ref      ] GC(73) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.958s][info   ][gc,ref      ] GC(73) Weak: 23 encountered, 3 discovered, 0 enqueued</span><br><span class="line">[0.958s][info   ][gc,ref      ] GC(73) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.958s][info   ][gc,ref      ] GC(73) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.958s][info   ][gc,reloc    ] GC(73) Small Pages: 80 / 160M, Empty: 0M, Relocated: 17M, In-Place: 0</span><br><span class="line">[0.958s][info   ][gc,reloc    ] GC(73) Medium Pages: 22 / 352M, Empty: 0M, Relocated: 41M, In-Place: 3</span><br><span class="line">[0.958s][info   ][gc,reloc    ] GC(73) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.958s][info   ][gc,reloc    ] GC(73) Forwarding Usage: 0M</span><br><span class="line">[0.958s][info   ][gc,heap     ] GC(73) Min Capacity: 512M(100%)</span><br><span class="line">[0.958s][info   ][gc,heap     ] GC(73) Max Capacity: 512M(100%)</span><br><span class="line">[0.958s][info   ][gc,heap     ] GC(73) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.958s][info   ][gc,heap     ] GC(73)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.958s][info   ][gc,heap     ] GC(73)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.958s][info   ][gc,heap     ] GC(73)      Free:        0M (0%)            0M (0%)            0M (0%)           48M (9%)           48M (9%)            0M (0%)</span><br><span class="line">[0.959s][info   ][gc,heap     ] GC(73)      Used:      512M (100%)        512M (100%)        512M (100%)        464M (91%)         512M (100%)        464M (91%)</span><br><span class="line">[0.959s][info   ][gc,heap     ] GC(73)      Live:         -               345M (67%)         345M (67%)         345M (67%)            -                  -</span><br><span class="line">[0.959s][info   ][gc,heap     ] GC(73) Allocated:         -                 0M (0%)            0M (0%)           24M (5%)             -                  -</span><br><span class="line">[0.959s][info   ][gc,heap     ] GC(73)   Garbage:         -               166M (33%)         166M (33%)          94M (19%)            -                  -</span><br><span class="line">[0.959s][info   ][gc,heap     ] GC(73) Reclaimed:         -                  -                 0M (0%)           72M (14%)            -                  -</span><br><span class="line">[0.959s][info   ][gc          ] GC(73) Garbage Collection (Allocation Stall) 512M(100%)-&gt;464M(91%)</span><br><span class="line">[0.962s][info   ][gc,start    ] GC(74) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.962s][info   ][gc,ref      ] GC(74) Clearing All SoftReferences</span><br><span class="line">[0.962s][info   ][gc,task     ] GC(74) Using 2 workers</span><br><span class="line">[0.962s][info   ][gc,phases   ] GC(74) Pause Mark Start 0.006ms</span><br><span class="line">[0.965s][info   ][gc,phases   ] GC(74) Concurrent Mark 3.067ms</span><br><span class="line">[0.965s][info   ][gc,phases   ] GC(74) Pause Mark End 0.058ms</span><br><span class="line">[0.965s][info   ][gc,phases   ] GC(74) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.966s][info   ][gc,phases   ] GC(74) Concurrent Process Non-Strong References 0.555ms</span><br><span class="line">[0.966s][info   ][gc,phases   ] GC(74) Concurrent Reset Relocation Set 0.002ms</span><br><span class="line">[0.968s][info   ][gc,phases   ] GC(74) Concurrent Select Relocation Set 1.962ms</span><br><span class="line">[0.968s][info   ][gc,phases   ] GC(74) Pause Relocate Start 0.007ms</span><br><span class="line">[0.969s][info   ][gc          ] Allocation Stall (main) 7.516ms</span><br><span class="line">[0.971s][info   ][gc,phases   ] GC(74) Concurrent Relocate 3.156ms</span><br><span class="line">[0.971s][info   ][gc,load     ] GC(74) Load: 4.02/4.33/4.71</span><br><span class="line">[0.971s][info   ][gc,mmu      ] GC(74) MMU: 2ms/97.1%, 5ms/98.7%, 10ms/99.3%, 20ms/99.5%, 50ms/99.7%, 100ms/99.8%</span><br><span class="line">[0.972s][info   ][gc,marking  ] GC(74) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.972s][info   ][gc,marking  ] GC(74) Mark Stack Usage: 32M</span><br><span class="line">[0.972s][info   ][gc,nmethod  ] GC(74) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.972s][info   ][gc,metaspace] GC(74) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.972s][info   ][gc,ref      ] GC(74) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.972s][info   ][gc,ref      ] GC(74) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.972s][info   ][gc,ref      ] GC(74) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.972s][info   ][gc,ref      ] GC(74) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.972s][info   ][gc,reloc    ] GC(74) Small Pages: 86 / 172M, Empty: 0M, Relocated: 29M, In-Place: 0</span><br><span class="line">[0.972s][info   ][gc,reloc    ] GC(74) Medium Pages: 21 / 336M, Empty: 0M, Relocated: 69M, In-Place: 4</span><br><span class="line">[0.972s][info   ][gc,reloc    ] GC(74) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.972s][info   ][gc,reloc    ] GC(74) Forwarding Usage: 0M</span><br><span class="line">[0.972s][info   ][gc,heap     ] GC(74) Min Capacity: 512M(100%)</span><br><span class="line">[0.972s][info   ][gc,heap     ] GC(74) Max Capacity: 512M(100%)</span><br><span class="line">[0.972s][info   ][gc,heap     ] GC(74) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.972s][info   ][gc,heap     ] GC(74)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.972s][info   ][gc,heap     ] GC(74)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.972s][info   ][gc,heap     ] GC(74)      Free:        4M (1%)            4M (1%)            4M (1%)           46M (9%)           58M (11%)           0M (0%)</span><br><span class="line">[0.972s][info   ][gc,heap     ] GC(74)      Used:      508M (99%)         508M (99%)         508M (99%)         466M (91%)         512M (100%)        454M (89%)</span><br><span class="line">[0.972s][info   ][gc,heap     ] GC(74)      Live:         -               343M (67%)         343M (67%)         343M (67%)            -                  -</span><br><span class="line">[0.972s][info   ][gc,heap     ] GC(74) Allocated:         -                 0M (0%)            0M (0%)           46M (9%)             -                  -</span><br><span class="line">[0.972s][info   ][gc,heap     ] GC(74)   Garbage:         -               164M (32%)         164M (32%)          76M (15%)            -                  -</span><br><span class="line">[0.972s][info   ][gc,heap     ] GC(74) Reclaimed:         -                  -                 0M (0%)           88M (17%)            -                  -</span><br><span class="line">[0.972s][info   ][gc          ] GC(74) Garbage Collection (Allocation Stall) 508M(99%)-&gt;466M(91%)</span><br><span class="line">[0.976s][info   ][gc,start    ] GC(75) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.976s][info   ][gc,ref      ] GC(75) Clearing All SoftReferences</span><br><span class="line">[0.976s][info   ][gc,task     ] GC(75) Using 2 workers</span><br><span class="line">[0.976s][info   ][gc,phases   ] GC(75) Pause Mark Start 0.006ms</span><br><span class="line">[0.978s][info   ][gc,phases   ] GC(75) Concurrent Mark 2.190ms</span><br><span class="line">[0.978s][info   ][gc,phases   ] GC(75) Pause Mark End 0.004ms</span><br><span class="line">[0.978s][info   ][gc,phases   ] GC(75) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.979s][info   ][gc,phases   ] GC(75) Concurrent Process Non-Strong References 0.189ms</span><br><span class="line">[0.979s][info   ][gc,phases   ] GC(75) Concurrent Reset Relocation Set 0.003ms</span><br><span class="line">[0.980s][info   ][gc,phases   ] GC(75) Concurrent Select Relocation Set 1.407ms</span><br><span class="line">[0.980s][info   ][gc,phases   ] GC(75) Pause Relocate Start 0.002ms</span><br><span class="line">[0.981s][info   ][gc          ] Allocation Stall (main) 4.963ms</span><br><span class="line">[0.981s][info   ][gc          ] Allocation Stall (main) 0.518ms</span><br><span class="line">[0.983s][info   ][gc,phases   ] GC(75) Concurrent Relocate 3.130ms</span><br><span class="line">[0.983s][info   ][gc,load     ] GC(75) Load: 4.02/4.33/4.71</span><br><span class="line">[0.983s][info   ][gc,mmu      ] GC(75) MMU: 2ms/97.1%, 5ms/98.7%, 10ms/99.3%, 20ms/99.5%, 50ms/99.7%, 100ms/99.8%</span><br><span class="line">[0.983s][info   ][gc,marking  ] GC(75) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.983s][info   ][gc,marking  ] GC(75) Mark Stack Usage: 32M</span><br><span class="line">[0.983s][info   ][gc,nmethod  ] GC(75) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.983s][info   ][gc,metaspace] GC(75) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.983s][info   ][gc,ref      ] GC(75) Soft: 3 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.983s][info   ][gc,ref      ] GC(75) Weak: 23 encountered, 6 discovered, 0 enqueued</span><br><span class="line">[0.983s][info   ][gc,ref      ] GC(75) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.983s][info   ][gc,ref      ] GC(75) Phantom: 1 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.983s][info   ][gc,reloc    ] GC(75) Small Pages: 88 / 176M, Empty: 0M, Relocated: 26M, In-Place: 0</span><br><span class="line">[0.983s][info   ][gc,reloc    ] GC(75) Medium Pages: 21 / 336M, Empty: 0M, Relocated: 69M, In-Place: 5</span><br><span class="line">[0.983s][info   ][gc,reloc    ] GC(75) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.983s][info   ][gc,reloc    ] GC(75) Forwarding Usage: 0M</span><br><span class="line">[0.983s][info   ][gc,heap     ] GC(75) Min Capacity: 512M(100%)</span><br><span class="line">[0.983s][info   ][gc,heap     ] GC(75) Max Capacity: 512M(100%)</span><br><span class="line">[0.983s][info   ][gc,heap     ] GC(75) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.983s][info   ][gc,heap     ] GC(75)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.983s][info   ][gc,heap     ] GC(75)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.983s][info   ][gc,heap     ] GC(75)      Free:        0M (0%)            0M (0%)            0M (0%)           62M (12%)          62M (12%)           0M (0%)</span><br><span class="line">[0.983s][info   ][gc,heap     ] GC(75)      Used:      512M (100%)        512M (100%)        512M (100%)        450M (88%)         512M (100%)        450M (88%)</span><br><span class="line">[0.983s][info   ][gc,heap     ] GC(75)      Live:         -               343M (67%)         343M (67%)         343M (67%)            -                  -</span><br><span class="line">[0.984s][info   ][gc,heap     ] GC(75) Allocated:         -                 0M (0%)            0M (0%)           26M (5%)             -                  -</span><br><span class="line">[0.984s][info   ][gc,heap     ] GC(75)   Garbage:         -               168M (33%)         168M (33%)          80M (16%)            -                  -</span><br><span class="line">[0.984s][info   ][gc,heap     ] GC(75) Reclaimed:         -                  -                 0M (0%)           88M (17%)            -                  -</span><br><span class="line">[0.984s][info   ][gc          ] GC(75) Garbage Collection (Allocation Stall) 512M(100%)-&gt;450M(88%)</span><br><span class="line">[0.988s][info   ][gc,start    ] GC(76) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.988s][info   ][gc,ref      ] GC(76) Clearing All SoftReferences</span><br><span class="line">[0.988s][info   ][gc,task     ] GC(76) Using 2 workers</span><br><span class="line">[0.988s][info   ][gc,phases   ] GC(76) Pause Mark Start 0.007ms</span><br><span class="line">[0.990s][info   ][gc,phases   ] GC(76) Concurrent Mark 2.313ms</span><br><span class="line">[0.990s][info   ][gc,phases   ] GC(76) Pause Mark End 0.004ms</span><br><span class="line">[0.990s][info   ][gc,phases   ] GC(76) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.991s][info   ][gc,phases   ] GC(76) Concurrent Process Non-Strong References 0.274ms</span><br><span class="line">[0.991s][info   ][gc,phases   ] GC(76) Concurrent Reset Relocation Set 0.002ms</span><br><span class="line">[0.992s][info   ][gc,phases   ] GC(76) Concurrent Select Relocation Set 1.449ms</span><br><span class="line">[0.992s][info   ][gc,phases   ] GC(76) Pause Relocate Start 0.006ms</span><br><span class="line">[0.993s][info   ][gc          ] Allocation Stall (main) 5.269ms</span><br><span class="line">[0.993s][info   ][gc          ] Allocation Stall (main) 0.297ms</span><br><span class="line">[0.994s][info   ][gc,phases   ] GC(76) Concurrent Relocate 2.334ms</span><br><span class="line">[0.995s][info   ][gc,load     ] GC(76) Load: 4.02/4.33/4.71</span><br><span class="line">[0.995s][info   ][gc,mmu      ] GC(76) MMU: 2ms/97.1%, 5ms/98.7%, 10ms/99.3%, 20ms/99.5%, 50ms/99.7%, 100ms/99.8%</span><br><span class="line">[0.995s][info   ][gc,marking  ] GC(76) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.995s][info   ][gc,marking  ] GC(76) Mark Stack Usage: 32M</span><br><span class="line">[0.995s][info   ][gc,nmethod  ] GC(76) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.995s][info   ][gc,metaspace] GC(76) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.995s][info   ][gc,ref      ] GC(76) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.995s][info   ][gc,ref      ] GC(76) Weak: 23 encountered, 3 discovered, 0 enqueued</span><br><span class="line">[0.995s][info   ][gc,ref      ] GC(76) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.995s][info   ][gc,ref      ] GC(76) Phantom: 1 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.995s][info   ][gc,reloc    ] GC(76) Small Pages: 88 / 176M, Empty: 0M, Relocated: 22M, In-Place: 0</span><br><span class="line">[0.995s][info   ][gc,reloc    ] GC(76) Medium Pages: 21 / 336M, Empty: 0M, Relocated: 53M, In-Place: 3</span><br><span class="line">[0.995s][info   ][gc,reloc    ] GC(76) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.995s][info   ][gc,reloc    ] GC(76) Forwarding Usage: 0M</span><br><span class="line">[0.995s][info   ][gc,heap     ] GC(76) Min Capacity: 512M(100%)</span><br><span class="line">[0.995s][info   ][gc,heap     ] GC(76) Max Capacity: 512M(100%)</span><br><span class="line">[0.995s][info   ][gc,heap     ] GC(76) Soft Max Capacity: 512M(100%)</span><br><span class="line">[0.995s][info   ][gc,heap     ] GC(76)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.995s][info   ][gc,heap     ] GC(76)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[0.995s][info   ][gc,heap     ] GC(76)      Free:        0M (0%)            0M (0%)            0M (0%)           62M (12%)          62M (12%)           0M (0%)</span><br><span class="line">[0.995s][info   ][gc,heap     ] GC(76)      Used:      512M (100%)        512M (100%)        512M (100%)        450M (88%)         512M (100%)        450M (88%)</span><br><span class="line">[0.995s][info   ][gc,heap     ] GC(76)      Live:         -               341M (67%)         341M (67%)         341M (67%)            -                  -</span><br><span class="line">[0.995s][info   ][gc,heap     ] GC(76) Allocated:         -                 0M (0%)            0M (0%)           24M (5%)             -                  -</span><br><span class="line">[0.995s][info   ][gc,heap     ] GC(76)   Garbage:         -               170M (33%)         170M (33%)          84M (16%)            -                  -</span><br><span class="line">[0.995s][info   ][gc,heap     ] GC(76) Reclaimed:         -                  -                 0M (0%)           86M (17%)            -                  -</span><br><span class="line">[0.995s][info   ][gc          ] GC(76) Garbage Collection (Allocation Stall) 512M(100%)-&gt;450M(88%)</span><br><span class="line">[0.999s][info   ][gc,start    ] GC(77) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.999s][info   ][gc,ref      ] GC(77) Clearing All SoftReferences</span><br><span class="line">[0.999s][info   ][gc,task     ] GC(77) Using 2 workers</span><br><span class="line">[0.999s][info   ][gc,phases   ] GC(77) Pause Mark Start 0.005ms</span><br><span class="line">[1.002s][info   ][gc,phases   ] GC(77) Concurrent Mark 2.347ms</span><br><span class="line">[1.002s][info   ][gc,phases   ] GC(77) Pause Mark End 0.006ms</span><br><span class="line">[1.002s][info   ][gc,phases   ] GC(77) Concurrent Mark Free 0.000ms</span><br><span class="line">[1.002s][info   ][gc,phases   ] GC(77) Concurrent Process Non-Strong References 0.229ms</span><br><span class="line">[1.002s][info   ][gc,phases   ] GC(77) Concurrent Reset Relocation Set 0.003ms</span><br><span class="line">[1.003s][info   ][gc,phases   ] GC(77) Concurrent Select Relocation Set 1.404ms</span><br><span class="line">[1.003s][info   ][gc,phases   ] GC(77) Pause Relocate Start 0.002ms</span><br><span class="line">[1.004s][info   ][gc          ] Allocation Stall (main) 4.928ms</span><br><span class="line">[1.004s][info   ][gc          ] Allocation Stall (main) 0.043ms</span><br><span class="line">[1.006s][info   ][gc,phases   ] GC(77) Concurrent Relocate 2.666ms</span><br><span class="line">[1.006s][info   ][gc,load     ] GC(77) Load: 4.02/4.33/4.71</span><br><span class="line">[1.006s][info   ][gc,mmu      ] GC(77) MMU: 2ms/97.1%, 5ms/98.7%, 10ms/99.3%, 20ms/99.5%, 50ms/99.7%, 100ms/99.8%</span><br><span class="line">[1.006s][info   ][gc,marking  ] GC(77) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[1.006s][info   ][gc,marking  ] GC(77) Mark Stack Usage: 32M</span><br><span class="line">[1.006s][info   ][gc,nmethod  ] GC(77) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[1.006s][info   ][gc,metaspace] GC(77) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[1.006s][info   ][gc,ref      ] GC(77) Soft: 3 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[1.006s][info   ][gc,ref      ] GC(77) Weak: 23 encountered, 17 discovered, 0 enqueued</span><br><span class="line">[1.006s][info   ][gc,ref      ] GC(77) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[1.006s][info   ][gc,ref      ] GC(77) Phantom: 1 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[1.006s][info   ][gc,reloc    ] GC(77) Small Pages: 87 / 174M, Empty: 0M, Relocated: 22M, In-Place: 0</span><br><span class="line">[1.006s][info   ][gc,reloc    ] GC(77) Medium Pages: 21 / 336M, Empty: 0M, Relocated: 69M, In-Place: 5</span><br><span class="line">[1.006s][info   ][gc,reloc    ] GC(77) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[1.006s][info   ][gc,reloc    ] GC(77) Forwarding Usage: 0M</span><br><span class="line">[1.006s][info   ][gc,heap     ] GC(77) Min Capacity: 512M(100%)</span><br><span class="line">[1.006s][info   ][gc,heap     ] GC(77) Max Capacity: 512M(100%)</span><br><span class="line">[1.006s][info   ][gc,heap     ] GC(77) Soft Max Capacity: 512M(100%)</span><br><span class="line">[1.006s][info   ][gc,heap     ] GC(77)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[1.006s][info   ][gc,heap     ] GC(77)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[1.006s][info   ][gc,heap     ] GC(77)      Free:        2M (0%)            2M (0%)            2M (0%)           56M (11%)          58M (11%)           0M (0%)</span><br><span class="line">[1.006s][info   ][gc,heap     ] GC(77)      Used:      510M (100%)        510M (100%)        510M (100%)        456M (89%)         512M (100%)        454M (89%)</span><br><span class="line">[1.006s][info   ][gc,heap     ] GC(77)      Live:         -               350M (69%)         350M (69%)         350M (69%)            -                  -</span><br><span class="line">[1.007s][info   ][gc,heap     ] GC(77) Allocated:         -                 0M (0%)            0M (0%)           28M (5%)             -                  -</span><br><span class="line">[1.007s][info   ][gc,heap     ] GC(77)   Garbage:         -               159M (31%)         159M (31%)          77M (15%)            -                  -</span><br><span class="line">[1.007s][info   ][gc,heap     ] GC(77) Reclaimed:         -                  -                 0M (0%)           82M (16%)            -                  -</span><br><span class="line">[1.007s][info   ][gc          ] GC(77) Garbage Collection (Allocation Stall) 510M(100%)-&gt;456M(89%)</span><br><span class="line">[1.010s][info   ][gc,start    ] GC(78) Garbage Collection (Allocation Stall)</span><br><span class="line">[1.010s][info   ][gc,ref      ] GC(78) Clearing All SoftReferences</span><br><span class="line">[1.010s][info   ][gc,task     ] GC(78) Using 2 workers</span><br><span class="line">[1.010s][info   ][gc,phases   ] GC(78) Pause Mark Start 0.003ms</span><br><span class="line">[1.012s][info   ][gc,phases   ] GC(78) Concurrent Mark 2.156ms</span><br><span class="line">[1.012s][info   ][gc,phases   ] GC(78) Pause Mark End 0.003ms</span><br><span class="line">[1.012s][info   ][gc,phases   ] GC(78) Concurrent Mark Free 0.000ms</span><br><span class="line">[1.012s][info   ][gc,phases   ] GC(78) Concurrent Process Non-Strong References 0.220ms</span><br><span class="line">[1.012s][info   ][gc,phases   ] GC(78) Concurrent Reset Relocation Set 0.003ms</span><br><span class="line">[1.014s][info   ][gc,phases   ] GC(78) Concurrent Select Relocation Set 1.407ms</span><br><span class="line">[1.014s][info   ][gc,phases   ] GC(78) Pause Relocate Start 0.006ms</span><br><span class="line">[1.015s][info   ][gc          ] Allocation Stall (main) 5.070ms</span><br><span class="line">[1.016s][info   ][gc,phases   ] GC(78) Concurrent Relocate 1.897ms</span><br><span class="line">[1.016s][info   ][gc,load     ] GC(78) Load: 4.02/4.33/4.71</span><br><span class="line">[1.016s][info   ][gc,mmu      ] GC(78) MMU: 2ms/97.1%, 5ms/98.7%, 10ms/99.3%, 20ms/99.5%, 50ms/99.7%, 100ms/99.8%</span><br><span class="line">[1.016s][info   ][gc,marking  ] GC(78) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[1.016s][info   ][gc,marking  ] GC(78) Mark Stack Usage: 32M</span><br><span class="line">[1.016s][info   ][gc,nmethod  ] GC(78) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[1.016s][info   ][gc,metaspace] GC(78) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[1.016s][info   ][gc,ref      ] GC(78) Soft: 3 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[1.016s][info   ][gc,ref      ] GC(78) Weak: 23 encountered, 3 discovered, 0 enqueued</span><br><span class="line">[1.016s][info   ][gc,ref      ] GC(78) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[1.016s][info   ][gc,ref      ] GC(78) Phantom: 1 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[1.016s][info   ][gc,reloc    ] GC(78) Small Pages: 88 / 176M, Empty: 0M, Relocated: 26M, In-Place: 0</span><br><span class="line">[1.016s][info   ][gc,reloc    ] GC(78) Medium Pages: 21 / 336M, Empty: 0M, Relocated: 13M, In-Place: 1</span><br><span class="line">[1.016s][info   ][gc,reloc    ] GC(78) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[1.016s][info   ][gc,reloc    ] GC(78) Forwarding Usage: 0M</span><br><span class="line">[1.016s][info   ][gc,heap     ] GC(78) Min Capacity: 512M(100%)</span><br><span class="line">[1.016s][info   ][gc,heap     ] GC(78) Max Capacity: 512M(100%)</span><br><span class="line">[1.016s][info   ][gc,heap     ] GC(78) Soft Max Capacity: 512M(100%)</span><br><span class="line">[1.016s][info   ][gc,heap     ] GC(78)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[1.016s][info   ][gc,heap     ] GC(78)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[1.016s][info   ][gc,heap     ] GC(78)      Free:        0M (0%)            0M (0%)            0M (0%)           50M (10%)          50M (10%)           0M (0%)</span><br><span class="line">[1.016s][info   ][gc,heap     ] GC(78)      Used:      512M (100%)        512M (100%)        512M (100%)        462M (90%)         512M (100%)        462M (90%)</span><br><span class="line">[1.016s][info   ][gc,heap     ] GC(78)      Live:         -               348M (68%)         348M (68%)         348M (68%)            -                  -</span><br><span class="line">[1.016s][info   ][gc,heap     ] GC(78) Allocated:         -                 0M (0%)            0M (0%)           21M (4%)             -                  -</span><br><span class="line">[1.016s][info   ][gc,heap     ] GC(78)   Garbage:         -               163M (32%)         163M (32%)          91M (18%)            -                  -</span><br><span class="line">[1.016s][info   ][gc,heap     ] GC(78) Reclaimed:         -                  -                 0M (0%)           71M (14%)            -                  -</span><br><span class="line">[1.016s][info   ][gc          ] GC(78) Garbage Collection (Allocation Stall) 512M(100%)-&gt;462M(90%)</span><br><span class="line">[1.019s][info   ][gc,start    ] GC(79) Garbage Collection (Warmup)</span><br><span class="line">[1.019s][info   ][gc,task     ] GC(79) Using 2 workers</span><br><span class="line">[1.019s][info   ][gc,phases   ] GC(79) Pause Mark Start 0.003ms</span><br><span class="line">[1.021s][info   ][gc,phases   ] GC(79) Concurrent Mark 1.778ms</span><br><span class="line">[1.021s][info   ][gc,phases   ] GC(79) Pause Mark End 0.004ms</span><br><span class="line">[1.021s][info   ][gc,phases   ] GC(79) Concurrent Mark Free 0.001ms</span><br><span class="line">[1.021s][info   ][gc,phases   ] GC(79) Concurrent Process Non-Strong References 0.283ms</span><br><span class="line">[1.021s][info   ][gc,phases   ] GC(79) Concurrent Reset Relocation Set 0.002ms</span><br><span class="line">[1.023s][info   ][gc          ] Allocation Stall (main) 2.728ms</span><br><span class="line">[1.024s][info   ][gc,phases   ] GC(79) Concurrent Select Relocation Set 2.969ms</span><br><span class="line">[1.024s][info   ][gc,phases   ] GC(79) Pause Relocate Start 0.003ms</span><br><span class="line">[1.028s][info   ][gc          ] Relocation Stall (main) 2.880ms</span><br><span class="line">[1.028s][info   ][gc,phases   ] GC(79) Concurrent Relocate 3.598ms</span><br><span class="line">[1.028s][info   ][gc,load     ] GC(79) Load: 4.02/4.33/4.71</span><br><span class="line">[1.028s][info   ][gc,mmu      ] GC(79) MMU: 2ms/97.1%, 5ms/98.7%, 10ms/99.3%, 20ms/99.5%, 50ms/99.7%, 100ms/99.8%</span><br><span class="line">[1.028s][info   ][gc,marking  ] GC(79) Mark: 2 stripe(s), 2 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[1.028s][info   ][gc,marking  ] GC(79) Mark Stack Usage: 32M</span><br><span class="line">[1.028s][info   ][gc,nmethod  ] GC(79) NMethods: 124 registered, 0 unregistered</span><br><span class="line">[1.028s][info   ][gc,metaspace] GC(79) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[1.028s][info   ][gc,ref      ] GC(79) Soft: 3 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[1.028s][info   ][gc,ref      ] GC(79) Weak: 23 encountered, 13 discovered, 0 enqueued</span><br><span class="line">[1.028s][info   ][gc,ref      ] GC(79) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[1.028s][info   ][gc,ref      ] GC(79) Phantom: 1 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[1.028s][info   ][gc,reloc    ] GC(79) Small Pages: 79 / 158M, Empty: 2M, Relocated: 13M, In-Place: 0</span><br><span class="line">[1.028s][info   ][gc,reloc    ] GC(79) Medium Pages: 21 / 336M, Empty: 0M, Relocated: 82M, In-Place: 2</span><br><span class="line">[1.028s][info   ][gc,reloc    ] GC(79) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[1.028s][info   ][gc,reloc    ] GC(79) Forwarding Usage: 0M</span><br><span class="line">[1.028s][info   ][gc,heap     ] GC(79) Min Capacity: 512M(100%)</span><br><span class="line">[1.028s][info   ][gc,heap     ] GC(79) Max Capacity: 512M(100%)</span><br><span class="line">[1.028s][info   ][gc,heap     ] GC(79) Soft Max Capacity: 512M(100%)</span><br><span class="line">[1.028s][info   ][gc,heap     ] GC(79)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[1.028s][info   ][gc,heap     ] GC(79)  Capacity:      512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)        512M (100%)</span><br><span class="line">[1.028s][info   ][gc,heap     ] GC(79)      Free:       18M (4%)            0M (0%)            0M (0%)           66M (13%)          66M (13%)           0M (0%)</span><br><span class="line">[1.028s][info   ][gc,heap     ] GC(79)      Used:      494M (96%)         512M (100%)        512M (100%)        446M (87%)         512M (100%)        446M (87%)</span><br><span class="line">[1.028s][info   ][gc,heap     ] GC(79)      Live:         -               348M (68%)         348M (68%)         348M (68%)            -                  -</span><br><span class="line">[1.028s][info   ][gc,heap     ] GC(79) Allocated:         -                18M (4%)           20M (4%)           19M (4%)             -                  -</span><br><span class="line">[1.028s][info   ][gc,heap     ] GC(79)   Garbage:         -               145M (28%)         143M (28%)          77M (15%)            -                  -</span><br><span class="line">[1.028s][info   ][gc,heap     ] GC(79) Reclaimed:         -                  -                 2M (0%)           67M (13%)            -                  -</span><br><span class="line">[1.028s][info   ][gc          ] GC(79) Garbage Collection (Warmup) 494M(96%)-&gt;446M(87%)</span><br><span class="line">counter:35431</span><br><span class="line">[1.033s][info   ][gc,heap,exit] Heap</span><br><span class="line">[1.033s][info   ][gc,heap,exit]  ZHeap           used 448M, capacity 512M, max capacity 512M</span><br><span class="line">[1.033s][info   ][gc,heap,exit]  Metaspace       used 274K, committed 448K, reserved 1114112K</span><br><span class="line">[1.033s][info   ][gc,heap,exit]   class space    used 9K, committed 128K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>再看看1g内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+UseZGC -Xms1g -Xmx1g -XX:+PrintGCDetails -Xlog:gc\*:file=gc.log:time,uptime,level,tags GCLogAnalysis</span><br></pre></td></tr></table></figure>

<p>结果22次GC,生成了57000多个对象,GC次数相比G1减少了很多，性能也差不多。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0.003s][warning][gc] -XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.</span><br><span class="line">[0.006s][info   ][gc,init] Initializing The Z Garbage Collector</span><br><span class="line">[0.006s][info   ][gc,init] Version: 19.0.2+7-44 (release)</span><br><span class="line">[0.006s][info   ][gc,init] NUMA Support: Disabled</span><br><span class="line">[0.006s][info   ][gc,init] CPUs: 8 total, 8 available</span><br><span class="line">[0.006s][info   ][gc,init] Memory: 16384M</span><br><span class="line">[0.006s][info   ][gc,init] Large Page Support: Disabled</span><br><span class="line">[0.006s][info   ][gc,init] GC Workers: 2 (dynamic)</span><br><span class="line">[0.006s][info   ][gc,init] Address Space Type: Contiguous/Unrestricted/Complete</span><br><span class="line">[0.006s][info   ][gc,init] Address Space Size: 16384M x 3 = 49152M</span><br><span class="line">[0.006s][info   ][gc,init] Min Capacity: 1024M</span><br><span class="line">[0.006s][info   ][gc,init] Initial Capacity: 1024M</span><br><span class="line">[0.006s][info   ][gc,init] Max Capacity: 1024M</span><br><span class="line">[0.006s][info   ][gc,init] Medium Page Size: 32M</span><br><span class="line">[0.006s][info   ][gc,init] Pre-touch: Disabled</span><br><span class="line">[0.006s][info   ][gc,init] Uncommit: Implicitly Disabled (-Xms equals -Xmx)</span><br><span class="line">[0.006s][info   ][gc,init] Runtime Workers: 5</span><br><span class="line">[0.007s][info   ][gc     ] Using The Z Garbage Collector</span><br><span class="line">[0.007s][info   ][gc,metaspace] CDS archive(s) mapped at: [0x0000000800000000-0x0000000800c44000-0x0000000800c44000), size 12861440, SharedBaseAddress: 0x0000000800000000, ArchiveRelocationMode: 0.</span><br><span class="line">[0.007s][info   ][gc,metaspace] Compressed class space mapped at: 0x0000000801000000-0x0000000841000000, reserved size: 1073741824</span><br><span class="line">[0.007s][info   ][gc,metaspace] Narrow klass base: 0x0000000800000000, Narrow klass shift: 0, Narrow klass range: 0x100000000</span><br><span class="line">gc...</span><br><span class="line">[0.119s][info   ][gc,start    ] GC(0) Garbage Collection (Warmup)</span><br><span class="line">[0.119s][info   ][gc,task     ] GC(0) Using 2 workers</span><br><span class="line">[0.119s][info   ][gc,phases   ] GC(0) Pause Mark Start 0.007ms</span><br><span class="line">[0.123s][info   ][gc,phases   ] GC(0) Concurrent Mark 3.747ms</span><br><span class="line">[0.123s][info   ][gc,phases   ] GC(0) Pause Mark End 0.004ms</span><br><span class="line">[0.123s][info   ][gc,phases   ] GC(0) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.124s][info   ][gc,phases   ] GC(0) Concurrent Process Non-Strong References 0.224ms</span><br><span class="line">[0.124s][info   ][gc,phases   ] GC(0) Concurrent Reset Relocation Set 0.000ms</span><br><span class="line">[0.128s][info   ][gc,phases   ] GC(0) Concurrent Select Relocation Set 3.728ms</span><br><span class="line">[0.128s][info   ][gc,phases   ] GC(0) Pause Relocate Start 0.002ms</span><br><span class="line">[0.137s][info   ][gc,phases   ] GC(0) Concurrent Relocate 9.685ms</span><br><span class="line">[0.138s][info   ][gc,load     ] GC(0) Load: 3.49/3.80/4.40</span><br><span class="line">[0.138s][info   ][gc,mmu      ] GC(0) MMU: 2ms/99.6%, 5ms/99.8%, 10ms/99.9%, 20ms/99.9%, 50ms/100.0%, 100ms/100.0%</span><br><span class="line">[0.138s][info   ][gc,marking  ] GC(0) Mark: 2 stripe(s), 2 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.138s][info   ][gc,marking  ] GC(0) Mark Stack Usage: 32M</span><br><span class="line">[0.138s][info   ][gc,nmethod  ] GC(0) NMethods: 118 registered, 0 unregistered</span><br><span class="line">[0.138s][info   ][gc,metaspace] GC(0) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.138s][info   ][gc,ref      ] GC(0) Soft: 5 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.138s][info   ][gc,ref      ] GC(0) Weak: 26 encountered, 19 discovered, 3 enqueued</span><br><span class="line">[0.138s][info   ][gc,ref      ] GC(0) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.138s][info   ][gc,ref      ] GC(0) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.138s][info   ][gc,reloc    ] GC(0) Small Pages: 158 / 316M, Empty: 0M, Relocated: 57M, In-Place: 0</span><br><span class="line">[0.138s][info   ][gc,reloc    ] GC(0) Medium Pages: 13 / 416M, Empty: 0M, Relocated: 133M, In-Place: 0</span><br><span class="line">[0.138s][info   ][gc,reloc    ] GC(0) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.138s][info   ][gc,reloc    ] GC(0) Forwarding Usage: 0M</span><br><span class="line">[0.138s][info   ][gc,heap     ] GC(0) Min Capacity: 1024M(100%)</span><br><span class="line">[0.138s][info   ][gc,heap     ] GC(0) Max Capacity: 1024M(100%)</span><br><span class="line">[0.138s][info   ][gc,heap     ] GC(0) Soft Max Capacity: 1024M(100%)</span><br><span class="line">[0.138s][info   ][gc,heap     ] GC(0)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.138s][info   ][gc,heap     ] GC(0)  Capacity:     1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)</span><br><span class="line">[0.138s][info   ][gc,heap     ] GC(0)      Free:      292M (29%)         248M (24%)         202M (20%)         690M (67%)         690M (67%)         168M (16%)</span><br><span class="line">[0.138s][info   ][gc,heap     ] GC(0)      Used:      732M (71%)         776M (76%)         822M (80%)         334M (33%)         856M (84%)         334M (33%)</span><br><span class="line">[0.138s][info   ][gc,heap     ] GC(0)      Live:         -               191M (19%)         191M (19%)         191M (19%)            -                  -</span><br><span class="line">[0.138s][info   ][gc,heap     ] GC(0) Allocated:         -                44M (4%)           90M (9%)          111M (11%)            -                  -</span><br><span class="line">[0.138s][info   ][gc,heap     ] GC(0)   Garbage:         -               540M (53%)         540M (53%)          30M (3%)             -                  -</span><br><span class="line">[0.138s][info   ][gc,heap     ] GC(0) Reclaimed:         -                  -                 0M (0%)          509M (50%)            -                  -</span><br><span class="line">[0.138s][info   ][gc          ] GC(0) Garbage Collection (Warmup) 732M(71%)-&gt;334M(33%)</span><br><span class="line">[0.195s][info   ][gc,start    ] GC(1) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.195s][info   ][gc,ref      ] GC(1) Clearing All SoftReferences</span><br><span class="line">[0.195s][info   ][gc,task     ] GC(1) Using 2 workers</span><br><span class="line">[0.195s][info   ][gc,phases   ] GC(1) Pause Mark Start 0.003ms</span><br><span class="line">[0.199s][info   ][gc,phases   ] GC(1) Concurrent Mark 4.635ms</span><br><span class="line">[0.200s][info   ][gc,phases   ] GC(1) Pause Mark End 0.006ms</span><br><span class="line">[0.200s][info   ][gc,phases   ] GC(1) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.200s][info   ][gc,phases   ] GC(1) Concurrent Process Non-Strong References 0.235ms</span><br><span class="line">[0.200s][info   ][gc,phases   ] GC(1) Concurrent Reset Relocation Set 0.005ms</span><br><span class="line">[0.202s][info   ][gc          ] Allocation Stall (main) 7.946ms</span><br><span class="line">[0.203s][info   ][gc,phases   ] GC(1) Concurrent Select Relocation Set 2.682ms</span><br><span class="line">[0.203s][info   ][gc,phases   ] GC(1) Pause Relocate Start 0.015ms</span><br><span class="line">[0.204s][info   ][gc          ] Allocation Stall (main) 1.001ms</span><br><span class="line">[0.204s][info   ][gc          ] Allocation Stall (main) 0.366ms</span><br><span class="line">[0.221s][info   ][gc,phases   ] GC(1) Concurrent Relocate 18.012ms</span><br><span class="line">[0.221s][info   ][gc,load     ] GC(1) Load: 3.49/3.80/4.40</span><br><span class="line">[0.221s][info   ][gc,mmu      ] GC(1) MMU: 2ms/99.3%, 5ms/99.6%, 10ms/99.8%, 20ms/99.9%, 50ms/100.0%, 100ms/100.0%</span><br><span class="line">[0.221s][info   ][gc,marking  ] GC(1) Mark: 2 stripe(s), 2 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.221s][info   ][gc,marking  ] GC(1) Mark Stack Usage: 32M</span><br><span class="line">[0.221s][info   ][gc,nmethod  ] GC(1) NMethods: 120 registered, 0 unregistered</span><br><span class="line">[0.221s][info   ][gc,metaspace] GC(1) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.221s][info   ][gc,ref      ] GC(1) Soft: 5 encountered, 2 discovered, 2 enqueued</span><br><span class="line">[0.221s][info   ][gc,ref      ] GC(1) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.221s][info   ][gc,ref      ] GC(1) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.221s][info   ][gc,ref      ] GC(1) Phantom: 1 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.221s][info   ][gc,reloc    ] GC(1) Small Pages: 208 / 416M, Empty: 2M, Relocated: 88M, In-Place: 0</span><br><span class="line">[0.221s][info   ][gc,reloc    ] GC(1) Medium Pages: 19 / 608M, Empty: 0M, Relocated: 191M, In-Place: 1</span><br><span class="line">[0.221s][info   ][gc,reloc    ] GC(1) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.221s][info   ][gc,reloc    ] GC(1) Forwarding Usage: 0M</span><br><span class="line">[0.221s][info   ][gc,heap     ] GC(1) Min Capacity: 1024M(100%)</span><br><span class="line">[0.221s][info   ][gc,heap     ] GC(1) Max Capacity: 1024M(100%)</span><br><span class="line">[0.221s][info   ][gc,heap     ] GC(1) Soft Max Capacity: 1024M(100%)</span><br><span class="line">[0.221s][info   ][gc,heap     ] GC(1)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.221s][info   ][gc,heap     ] GC(1)  Capacity:     1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)</span><br><span class="line">[0.221s][info   ][gc,heap     ] GC(1)      Free:        0M (0%)            0M (0%)            0M (0%)          426M (42%)         426M (42%)           0M (0%)</span><br><span class="line">[0.221s][info   ][gc,heap     ] GC(1)      Used:     1024M (100%)       1024M (100%)       1024M (100%)        598M (58%)        1024M (100%)        598M (58%)</span><br><span class="line">[0.221s][info   ][gc,heap     ] GC(1)      Live:         -               282M (28%)         282M (28%)         282M (28%)            -                  -</span><br><span class="line">[0.221s][info   ][gc,heap     ] GC(1) Allocated:         -                 0M (0%)            2M (0%)          277M (27%)            -                  -</span><br><span class="line">[0.221s][info   ][gc,heap     ] GC(1)   Garbage:         -               741M (72%)         739M (72%)          37M (4%)             -                  -</span><br><span class="line">[0.221s][info   ][gc,heap     ] GC(1) Reclaimed:         -                  -                 2M (0%)          703M (69%)            -                  -</span><br><span class="line">[0.221s][info   ][gc          ] GC(1) Garbage Collection (Allocation Stall) 1024M(100%)-&gt;598M(58%)</span><br><span class="line">[0.254s][info   ][gc,start    ] GC(2) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.254s][info   ][gc,ref      ] GC(2) Clearing All SoftReferences</span><br><span class="line">[0.254s][info   ][gc,task     ] GC(2) Using 2 workers</span><br><span class="line">[0.254s][info   ][gc,phases   ] GC(2) Pause Mark Start 0.004ms</span><br><span class="line">[0.258s][info   ][gc,phases   ] GC(2) Concurrent Mark 3.659ms</span><br><span class="line">[0.258s][info   ][gc,phases   ] GC(2) Pause Mark End 0.006ms</span><br><span class="line">[0.258s][info   ][gc,phases   ] GC(2) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.258s][info   ][gc,phases   ] GC(2) Concurrent Process Non-Strong References 0.229ms</span><br><span class="line">[0.258s][info   ][gc,phases   ] GC(2) Concurrent Reset Relocation Set 0.007ms</span><br><span class="line">[0.260s][info   ][gc,phases   ] GC(2) Concurrent Select Relocation Set 1.598ms</span><br><span class="line">[0.260s][info   ][gc,phases   ] GC(2) Pause Relocate Start 0.002ms</span><br><span class="line">[0.262s][info   ][gc          ] Allocation Stall (main) 7.645ms</span><br><span class="line">[0.267s][info   ][gc,phases   ] GC(2) Concurrent Relocate 6.951ms</span><br><span class="line">[0.267s][info   ][gc,load     ] GC(2) Load: 3.49/3.80/4.40</span><br><span class="line">[0.267s][info   ][gc,mmu      ] GC(2) MMU: 2ms/99.3%, 5ms/99.6%, 10ms/99.8%, 20ms/99.9%, 50ms/100.0%, 100ms/100.0%</span><br><span class="line">[0.267s][info   ][gc,marking  ] GC(2) Mark: 2 stripe(s), 2 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.267s][info   ][gc,marking  ] GC(2) Mark Stack Usage: 32M</span><br><span class="line">[0.267s][info   ][gc,nmethod  ] GC(2) NMethods: 120 registered, 0 unregistered</span><br><span class="line">[0.267s][info   ][gc,metaspace] GC(2) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.267s][info   ][gc,ref      ] GC(2) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.267s][info   ][gc,ref      ] GC(2) Weak: 23 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.267s][info   ][gc,ref      ] GC(2) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.267s][info   ][gc,ref      ] GC(2) Phantom: 1 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.267s][info   ][gc,reloc    ] GC(2) Small Pages: 200 / 400M, Empty: 2M, Relocated: 95M, In-Place: 0</span><br><span class="line">[0.267s][info   ][gc,reloc    ] GC(2) Medium Pages: 19 / 608M, Empty: 0M, Relocated: 214M, In-Place: 1</span><br><span class="line">[0.267s][info   ][gc,reloc    ] GC(2) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.267s][info   ][gc,reloc    ] GC(2) Forwarding Usage: 0M</span><br><span class="line">[0.267s][info   ][gc,heap     ] GC(2) Min Capacity: 1024M(100%)</span><br><span class="line">[0.267s][info   ][gc,heap     ] GC(2) Max Capacity: 1024M(100%)</span><br><span class="line">[0.267s][info   ][gc,heap     ] GC(2) Soft Max Capacity: 1024M(100%)</span><br><span class="line">[0.267s][info   ][gc,heap     ] GC(2)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.267s][info   ][gc,heap     ] GC(2)  Capacity:     1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)</span><br><span class="line">[0.267s][info   ][gc,heap     ] GC(2)      Free:       16M (2%)           16M (2%)           18M (2%)          596M (58%)         596M (58%)          16M (2%)</span><br><span class="line">[0.267s][info   ][gc,heap     ] GC(2)      Used:     1008M (98%)        1008M (98%)        1006M (98%)         428M (42%)        1008M (98%)         428M (42%)</span><br><span class="line">[0.267s][info   ][gc,heap     ] GC(2)      Live:         -               314M (31%)         314M (31%)         314M (31%)            -                  -</span><br><span class="line">[0.267s][info   ][gc,heap     ] GC(2) Allocated:         -                 0M (0%)            0M (0%)           97M (10%)            -                  -</span><br><span class="line">[0.267s][info   ][gc,heap     ] GC(2)   Garbage:         -               693M (68%)         691M (68%)          15M (2%)             -                  -</span><br><span class="line">[0.267s][info   ][gc,heap     ] GC(2) Reclaimed:         -                  -                 2M (0%)          677M (66%)            -                  -</span><br><span class="line">[0.267s][info   ][gc          ] GC(2) Garbage Collection (Allocation Stall) 1008M(98%)-&gt;428M(42%)</span><br><span class="line">[0.305s][info   ][gc,start    ] GC(3) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.305s][info   ][gc,ref      ] GC(3) Clearing All SoftReferences</span><br><span class="line">[0.305s][info   ][gc,task     ] GC(3) Using 2 workers</span><br><span class="line">[0.305s][info   ][gc,phases   ] GC(3) Pause Mark Start 0.004ms</span><br><span class="line">[0.308s][info   ][gc,phases   ] GC(3) Concurrent Mark 3.224ms</span><br><span class="line">[0.309s][info   ][gc,phases   ] GC(3) Pause Mark End 0.005ms</span><br><span class="line">[0.309s][info   ][gc,phases   ] GC(3) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.309s][info   ][gc,phases   ] GC(3) Concurrent Process Non-Strong References 0.223ms</span><br><span class="line">[0.309s][info   ][gc,phases   ] GC(3) Concurrent Reset Relocation Set 0.006ms</span><br><span class="line">[0.310s][info   ][gc,phases   ] GC(3) Concurrent Select Relocation Set 1.487ms</span><br><span class="line">[0.310s][info   ][gc,phases   ] GC(3) Pause Relocate Start 0.002ms</span><br><span class="line">[0.311s][info   ][gc          ] Allocation Stall (main) 5.924ms</span><br><span class="line">[0.318s][info   ][gc,phases   ] GC(3) Concurrent Relocate 7.081ms</span><br><span class="line">[0.318s][info   ][gc,load     ] GC(3) Load: 3.49/3.80/4.40</span><br><span class="line">[0.318s][info   ][gc,mmu      ] GC(3) MMU: 2ms/99.3%, 5ms/99.6%, 10ms/99.8%, 20ms/99.9%, 50ms/100.0%, 100ms/100.0%</span><br><span class="line">[0.318s][info   ][gc,marking  ] GC(3) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.318s][info   ][gc,marking  ] GC(3) Mark Stack Usage: 32M</span><br><span class="line">[0.318s][info   ][gc,nmethod  ] GC(3) NMethods: 120 registered, 0 unregistered</span><br><span class="line">[0.318s][info   ][gc,metaspace] GC(3) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.318s][info   ][gc,ref      ] GC(3) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.318s][info   ][gc,ref      ] GC(3) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.318s][info   ][gc,ref      ] GC(3) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.318s][info   ][gc,ref      ] GC(3) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.318s][info   ][gc,reloc    ] GC(3) Small Pages: 202 / 404M, Empty: 0M, Relocated: 92M, In-Place: 0</span><br><span class="line">[0.318s][info   ][gc,reloc    ] GC(3) Medium Pages: 19 / 608M, Empty: 0M, Relocated: 215M, In-Place: 1</span><br><span class="line">[0.318s][info   ][gc,reloc    ] GC(3) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.318s][info   ][gc,reloc    ] GC(3) Forwarding Usage: 0M</span><br><span class="line">[0.318s][info   ][gc,heap     ] GC(3) Min Capacity: 1024M(100%)</span><br><span class="line">[0.318s][info   ][gc,heap     ] GC(3) Max Capacity: 1024M(100%)</span><br><span class="line">[0.318s][info   ][gc,heap     ] GC(3) Soft Max Capacity: 1024M(100%)</span><br><span class="line">[0.318s][info   ][gc,heap     ] GC(3)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.318s][info   ][gc,heap     ] GC(3)  Capacity:     1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)</span><br><span class="line">[0.318s][info   ][gc,heap     ] GC(3)      Free:       12M (1%)           12M (1%)           12M (1%)          550M (54%)         550M (54%)          10M (1%)</span><br><span class="line">[0.318s][info   ][gc,heap     ] GC(3)      Used:     1012M (99%)        1012M (99%)        1012M (99%)         474M (46%)        1014M (99%)         474M (46%)</span><br><span class="line">[0.318s][info   ][gc,heap     ] GC(3)      Live:         -               338M (33%)         338M (33%)         338M (33%)            -                  -</span><br><span class="line">[0.318s][info   ][gc,heap     ] GC(3) Allocated:         -                 0M (0%)            0M (0%)          103M (10%)            -                  -</span><br><span class="line">[0.318s][info   ][gc,heap     ] GC(3)   Garbage:         -               673M (66%)         673M (66%)          31M (3%)             -                  -</span><br><span class="line">[0.318s][info   ][gc,heap     ] GC(3) Reclaimed:         -                  -                 0M (0%)          641M (63%)            -                  -</span><br><span class="line">[0.318s][info   ][gc          ] GC(3) Garbage Collection (Allocation Stall) 1012M(99%)-&gt;474M(46%)</span><br><span class="line">[0.319s][info   ][gc,start    ] GC(4) Garbage Collection (Warmup)</span><br><span class="line">[0.319s][info   ][gc,task     ] GC(4) Using 2 workers</span><br><span class="line">[0.319s][info   ][gc,phases   ] GC(4) Pause Mark Start 0.003ms</span><br><span class="line">[0.324s][info   ][gc,phases   ] GC(4) Concurrent Mark 4.527ms</span><br><span class="line">[0.324s][info   ][gc,phases   ] GC(4) Pause Mark End 0.009ms</span><br><span class="line">[0.324s][info   ][gc,phases   ] GC(4) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.324s][info   ][gc,phases   ] GC(4) Concurrent Process Non-Strong References 0.270ms</span><br><span class="line">[0.324s][info   ][gc,phases   ] GC(4) Concurrent Reset Relocation Set 0.006ms</span><br><span class="line">[0.326s][info   ][gc,phases   ] GC(4) Concurrent Select Relocation Set 1.490ms</span><br><span class="line">[0.326s][info   ][gc,phases   ] GC(4) Pause Relocate Start 0.003ms</span><br><span class="line">[0.328s][info   ][gc,phases   ] GC(4) Concurrent Relocate 1.424ms</span><br><span class="line">[0.328s][info   ][gc,load     ] GC(4) Load: 3.49/3.80/4.40</span><br><span class="line">[0.328s][info   ][gc,mmu      ] GC(4) MMU: 2ms/99.3%, 5ms/99.6%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/100.0%</span><br><span class="line">[0.328s][info   ][gc,marking  ] GC(4) Mark: 2 stripe(s), 2 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.328s][info   ][gc,marking  ] GC(4) Mark Stack Usage: 32M</span><br><span class="line">[0.328s][info   ][gc,nmethod  ] GC(4) NMethods: 120 registered, 0 unregistered</span><br><span class="line">[0.328s][info   ][gc,metaspace] GC(4) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.328s][info   ][gc,ref      ] GC(4) Soft: 3 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.328s][info   ][gc,ref      ] GC(4) Weak: 23 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.328s][info   ][gc,ref      ] GC(4) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.328s][info   ][gc,ref      ] GC(4) Phantom: 1 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.328s][info   ][gc,reloc    ] GC(4) Small Pages: 85 / 170M, Empty: 0M, Relocated: 20M, In-Place: 0</span><br><span class="line">[0.328s][info   ][gc,reloc    ] GC(4) Medium Pages: 11 / 352M, Empty: 0M, Relocated: 48M, In-Place: 0</span><br><span class="line">[0.328s][info   ][gc,reloc    ] GC(4) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.328s][info   ][gc,reloc    ] GC(4) Forwarding Usage: 0M</span><br><span class="line">[0.328s][info   ][gc,heap     ] GC(4) Min Capacity: 1024M(100%)</span><br><span class="line">[0.328s][info   ][gc,heap     ] GC(4) Max Capacity: 1024M(100%)</span><br><span class="line">[0.328s][info   ][gc,heap     ] GC(4) Soft Max Capacity: 1024M(100%)</span><br><span class="line">[0.328s][info   ][gc,heap     ] GC(4)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.328s][info   ][gc,heap     ] GC(4)  Capacity:     1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)</span><br><span class="line">[0.328s][info   ][gc,heap     ] GC(4)      Free:      502M (49%)         456M (45%)         446M (44%)         514M (50%)         540M (53%)         414M (40%)</span><br><span class="line">[0.328s][info   ][gc,heap     ] GC(4)      Used:      522M (51%)         568M (55%)         578M (56%)         510M (50%)         610M (60%)         484M (47%)</span><br><span class="line">[0.328s][info   ][gc,heap     ] GC(4)      Live:         -               329M (32%)         329M (32%)         329M (32%)            -                  -</span><br><span class="line">[0.328s][info   ][gc,heap     ] GC(4) Allocated:         -                46M (4%)           56M (5%)           97M (10%)            -                  -</span><br><span class="line">[0.328s][info   ][gc,heap     ] GC(4)   Garbage:         -               192M (19%)         192M (19%)          82M (8%)             -                  -</span><br><span class="line">[0.328s][info   ][gc,heap     ] GC(4) Reclaimed:         -                  -                 0M (0%)          109M (11%)            -                  -</span><br><span class="line">[0.328s][info   ][gc          ] GC(4) Garbage Collection (Warmup) 522M(51%)-&gt;510M(50%)</span><br><span class="line">[0.366s][info   ][gc,start    ] GC(5) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.366s][info   ][gc,ref      ] GC(5) Clearing All SoftReferences</span><br><span class="line">[0.366s][info   ][gc,task     ] GC(5) Using 2 workers</span><br><span class="line">[0.366s][info   ][gc,phases   ] GC(5) Pause Mark Start 0.011ms</span><br><span class="line">[0.369s][info   ][gc,phases   ] GC(5) Concurrent Mark 2.923ms</span><br><span class="line">[0.369s][info   ][gc,phases   ] GC(5) Pause Mark End 0.006ms</span><br><span class="line">[0.369s][info   ][gc,phases   ] GC(5) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.369s][info   ][gc,phases   ] GC(5) Concurrent Process Non-Strong References 0.372ms</span><br><span class="line">[0.370s][info   ][gc,phases   ] GC(5) Concurrent Reset Relocation Set 0.002ms</span><br><span class="line">[0.372s][info   ][gc,phases   ] GC(5) Concurrent Select Relocation Set 2.464ms</span><br><span class="line">[0.372s][info   ][gc,phases   ] GC(5) Pause Relocate Start 0.006ms</span><br><span class="line">[0.373s][info   ][gc          ] Allocation Stall (main) 7.172ms</span><br><span class="line">[0.380s][info   ][gc,phases   ] GC(5) Concurrent Relocate 7.684ms</span><br><span class="line">[0.380s][info   ][gc,load     ] GC(5) Load: 3.49/3.80/4.40</span><br><span class="line">[0.380s][info   ][gc,mmu      ] GC(5) MMU: 2ms/99.3%, 5ms/99.6%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/100.0%</span><br><span class="line">[0.380s][info   ][gc,marking  ] GC(5) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.380s][info   ][gc,marking  ] GC(5) Mark Stack Usage: 32M</span><br><span class="line">[0.380s][info   ][gc,nmethod  ] GC(5) NMethods: 120 registered, 0 unregistered</span><br><span class="line">[0.380s][info   ][gc,metaspace] GC(5) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.380s][info   ][gc,ref      ] GC(5) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.380s][info   ][gc,ref      ] GC(5) Weak: 23 encountered, 3 discovered, 0 enqueued</span><br><span class="line">[0.380s][info   ][gc,ref      ] GC(5) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.380s][info   ][gc,ref      ] GC(5) Phantom: 1 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.380s][info   ][gc,reloc    ] GC(5) Small Pages: 199 / 398M, Empty: 2M, Relocated: 104M, In-Place: 0</span><br><span class="line">[0.380s][info   ][gc,reloc    ] GC(5) Medium Pages: 19 / 608M, Empty: 0M, Relocated: 220M, In-Place: 1</span><br><span class="line">[0.380s][info   ][gc,reloc    ] GC(5) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.380s][info   ][gc,reloc    ] GC(5) Forwarding Usage: 0M</span><br><span class="line">[0.380s][info   ][gc,heap     ] GC(5) Min Capacity: 1024M(100%)</span><br><span class="line">[0.380s][info   ][gc,heap     ] GC(5) Max Capacity: 1024M(100%)</span><br><span class="line">[0.380s][info   ][gc,heap     ] GC(5) Soft Max Capacity: 1024M(100%)</span><br><span class="line">[0.380s][info   ][gc,heap     ] GC(5)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.380s][info   ][gc,heap     ] GC(5)  Capacity:     1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)</span><br><span class="line">[0.380s][info   ][gc,heap     ] GC(5)      Free:       18M (2%)           18M (2%)           20M (2%)          510M (50%)         542M (53%)          18M (2%)</span><br><span class="line">[0.380s][info   ][gc,heap     ] GC(5)      Used:     1006M (98%)        1006M (98%)        1004M (98%)         514M (50%)        1006M (98%)         482M (47%)</span><br><span class="line">[0.380s][info   ][gc,heap     ] GC(5)      Live:         -               344M (34%)         344M (34%)         344M (34%)            -                  -</span><br><span class="line">[0.380s][info   ][gc,heap     ] GC(5) Allocated:         -                 0M (0%)            0M (0%)          143M (14%)            -                  -</span><br><span class="line">[0.380s][info   ][gc,heap     ] GC(5)   Garbage:         -               661M (65%)         659M (64%)          25M (2%)             -                  -</span><br><span class="line">[0.380s][info   ][gc,heap     ] GC(5) Reclaimed:         -                  -                 2M (0%)          635M (62%)            -                  -</span><br><span class="line">[0.380s][info   ][gc          ] GC(5) Garbage Collection (Allocation Stall) 1006M(98%)-&gt;514M(50%)</span><br><span class="line">[0.411s][info   ][gc,start    ] GC(6) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.411s][info   ][gc,ref      ] GC(6) Clearing All SoftReferences</span><br><span class="line">[0.411s][info   ][gc,task     ] GC(6) Using 2 workers</span><br><span class="line">[0.411s][info   ][gc,phases   ] GC(6) Pause Mark Start 0.004ms</span><br><span class="line">[0.415s][info   ][gc,phases   ] GC(6) Concurrent Mark 3.951ms</span><br><span class="line">[0.415s][info   ][gc,phases   ] GC(6) Pause Mark End 0.008ms</span><br><span class="line">[0.415s][info   ][gc,phases   ] GC(6) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.416s][info   ][gc,phases   ] GC(6) Concurrent Process Non-Strong References 0.294ms</span><br><span class="line">[0.416s][info   ][gc,phases   ] GC(6) Concurrent Reset Relocation Set 0.008ms</span><br><span class="line">[0.417s][info   ][gc,phases   ] GC(6) Concurrent Select Relocation Set 1.586ms</span><br><span class="line">[0.418s][info   ][gc,phases   ] GC(6) Pause Relocate Start 0.005ms</span><br><span class="line">[0.418s][info   ][gc          ] Allocation Stall (main) 6.804ms</span><br><span class="line">[0.426s][info   ][gc,phases   ] GC(6) Concurrent Relocate 8.405ms</span><br><span class="line">[0.426s][info   ][gc,load     ] GC(6) Load: 3.49/3.80/4.40</span><br><span class="line">[0.426s][info   ][gc,mmu      ] GC(6) MMU: 2ms/99.3%, 5ms/99.6%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/99.9%</span><br><span class="line">[0.426s][info   ][gc,marking  ] GC(6) Mark: 2 stripe(s), 2 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.426s][info   ][gc,marking  ] GC(6) Mark Stack Usage: 32M</span><br><span class="line">[0.426s][info   ][gc,nmethod  ] GC(6) NMethods: 120 registered, 0 unregistered</span><br><span class="line">[0.426s][info   ][gc,metaspace] GC(6) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.426s][info   ][gc,ref      ] GC(6) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.426s][info   ][gc,ref      ] GC(6) Weak: 23 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.426s][info   ][gc,ref      ] GC(6) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.426s][info   ][gc,ref      ] GC(6) Phantom: 1 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.426s][info   ][gc,reloc    ] GC(6) Small Pages: 195 / 390M, Empty: 2M, Relocated: 103M, In-Place: 0</span><br><span class="line">[0.426s][info   ][gc,reloc    ] GC(6) Medium Pages: 19 / 608M, Empty: 0M, Relocated: 190M, In-Place: 1</span><br><span class="line">[0.426s][info   ][gc,reloc    ] GC(6) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.426s][info   ][gc,reloc    ] GC(6) Forwarding Usage: 0M</span><br><span class="line">[0.426s][info   ][gc,heap     ] GC(6) Min Capacity: 1024M(100%)</span><br><span class="line">[0.426s][info   ][gc,heap     ] GC(6) Max Capacity: 1024M(100%)</span><br><span class="line">[0.426s][info   ][gc,heap     ] GC(6) Soft Max Capacity: 1024M(100%)</span><br><span class="line">[0.426s][info   ][gc,heap     ] GC(6)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.426s][info   ][gc,heap     ] GC(6)  Capacity:     1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)</span><br><span class="line">[0.426s][info   ][gc,heap     ] GC(6)      Free:       26M (3%)           26M (3%)           28M (3%)          502M (49%)         512M (50%)          26M (3%)</span><br><span class="line">[0.426s][info   ][gc,heap     ] GC(6)      Used:      998M (97%)         998M (97%)         996M (97%)         522M (51%)         998M (97%)         512M (50%)</span><br><span class="line">[0.426s][info   ][gc,heap     ] GC(6)      Live:         -               332M (32%)         332M (32%)         332M (32%)            -                  -</span><br><span class="line">[0.426s][info   ][gc,heap     ] GC(6) Allocated:         -                 0M (0%)            0M (0%)          151M (15%)            -                  -</span><br><span class="line">[0.426s][info   ][gc,heap     ] GC(6)   Garbage:         -               665M (65%)         663M (65%)          37M (4%)             -                  -</span><br><span class="line">[0.426s][info   ][gc,heap     ] GC(6) Reclaimed:         -                  -                 2M (0%)          627M (61%)            -                  -</span><br><span class="line">[0.426s][info   ][gc          ] GC(6) Garbage Collection (Allocation Stall) 998M(97%)-&gt;522M(51%)</span><br><span class="line">[0.460s][info   ][gc,start    ] GC(7) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.460s][info   ][gc,ref      ] GC(7) Clearing All SoftReferences</span><br><span class="line">[0.460s][info   ][gc,task     ] GC(7) Using 2 workers</span><br><span class="line">[0.460s][info   ][gc,phases   ] GC(7) Pause Mark Start 0.004ms</span><br><span class="line">[0.464s][info   ][gc,phases   ] GC(7) Concurrent Mark 4.091ms</span><br><span class="line">[0.464s][info   ][gc,phases   ] GC(7) Pause Mark End 0.005ms</span><br><span class="line">[0.464s][info   ][gc,phases   ] GC(7) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.465s][info   ][gc,phases   ] GC(7) Concurrent Process Non-Strong References 0.269ms</span><br><span class="line">[0.465s][info   ][gc,phases   ] GC(7) Concurrent Reset Relocation Set 0.006ms</span><br><span class="line">[0.466s][info   ][gc          ] Allocation Stall (main) 6.220ms</span><br><span class="line">[0.466s][info   ][gc,phases   ] GC(7) Concurrent Select Relocation Set 1.452ms</span><br><span class="line">[0.466s][info   ][gc,phases   ] GC(7) Pause Relocate Start 0.002ms</span><br><span class="line">[0.467s][info   ][gc          ] Allocation Stall (main) 0.467ms</span><br><span class="line">[0.475s][info   ][gc,phases   ] GC(7) Concurrent Relocate 7.966ms</span><br><span class="line">[0.475s][info   ][gc,load     ] GC(7) Load: 3.49/3.80/4.40</span><br><span class="line">[0.475s][info   ][gc,mmu      ] GC(7) MMU: 2ms/99.3%, 5ms/99.6%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/99.9%</span><br><span class="line">[0.475s][info   ][gc,marking  ] GC(7) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.475s][info   ][gc,marking  ] GC(7) Mark Stack Usage: 32M</span><br><span class="line">[0.475s][info   ][gc,nmethod  ] GC(7) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.475s][info   ][gc,metaspace] GC(7) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.475s][info   ][gc,ref      ] GC(7) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.475s][info   ][gc,ref      ] GC(7) Weak: 23 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.475s][info   ][gc,ref      ] GC(7) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.475s][info   ][gc,ref      ] GC(7) Phantom: 1 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.475s][info   ][gc,reloc    ] GC(7) Small Pages: 208 / 416M, Empty: 2M, Relocated: 103M, In-Place: 0</span><br><span class="line">[0.475s][info   ][gc,reloc    ] GC(7) Medium Pages: 19 / 608M, Empty: 0M, Relocated: 216M, In-Place: 1</span><br><span class="line">[0.475s][info   ][gc,reloc    ] GC(7) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.475s][info   ][gc,reloc    ] GC(7) Forwarding Usage: 0M</span><br><span class="line">[0.475s][info   ][gc,heap     ] GC(7) Min Capacity: 1024M(100%)</span><br><span class="line">[0.475s][info   ][gc,heap     ] GC(7) Max Capacity: 1024M(100%)</span><br><span class="line">[0.475s][info   ][gc,heap     ] GC(7) Soft Max Capacity: 1024M(100%)</span><br><span class="line">[0.475s][info   ][gc,heap     ] GC(7)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.475s][info   ][gc,heap     ] GC(7)  Capacity:     1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)</span><br><span class="line">[0.475s][info   ][gc,heap     ] GC(7)      Free:        0M (0%)            0M (0%)            0M (0%)          588M (57%)         588M (57%)           0M (0%)</span><br><span class="line">[0.475s][info   ][gc,heap     ] GC(7)      Used:     1024M (100%)       1024M (100%)       1024M (100%)        436M (43%)        1024M (100%)        436M (43%)</span><br><span class="line">[0.475s][info   ][gc,heap     ] GC(7)      Live:         -               343M (34%)         343M (34%)         343M (34%)            -                  -</span><br><span class="line">[0.475s][info   ][gc,heap     ] GC(7) Allocated:         -                 0M (0%)            2M (0%)           63M (6%)             -                  -</span><br><span class="line">[0.475s][info   ][gc,heap     ] GC(7)   Garbage:         -               680M (66%)         678M (66%)          28M (3%)             -                  -</span><br><span class="line">[0.475s][info   ][gc,heap     ] GC(7) Reclaimed:         -                  -                 2M (0%)          651M (64%)            -                  -</span><br><span class="line">[0.475s][info   ][gc          ] GC(7) Garbage Collection (Allocation Stall) 1024M(100%)-&gt;436M(43%)</span><br><span class="line">[0.512s][info   ][gc,start    ] GC(8) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.512s][info   ][gc,ref      ] GC(8) Clearing All SoftReferences</span><br><span class="line">[0.512s][info   ][gc,task     ] GC(8) Using 2 workers</span><br><span class="line">[0.512s][info   ][gc,phases   ] GC(8) Pause Mark Start 0.006ms</span><br><span class="line">[0.515s][info   ][gc,phases   ] GC(8) Concurrent Mark 3.516ms</span><br><span class="line">[0.515s][info   ][gc,phases   ] GC(8) Pause Mark End 0.005ms</span><br><span class="line">[0.515s][info   ][gc,phases   ] GC(8) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.516s][info   ][gc,phases   ] GC(8) Concurrent Process Non-Strong References 0.217ms</span><br><span class="line">[0.516s][info   ][gc,phases   ] GC(8) Concurrent Reset Relocation Set 0.008ms</span><br><span class="line">[0.517s][info   ][gc,phases   ] GC(8) Concurrent Select Relocation Set 1.398ms</span><br><span class="line">[0.517s][info   ][gc,phases   ] GC(8) Pause Relocate Start 0.005ms</span><br><span class="line">[0.519s][info   ][gc          ] Allocation Stall (main) 7.862ms</span><br><span class="line">[0.525s][info   ][gc,phases   ] GC(8) Concurrent Relocate 7.640ms</span><br><span class="line">[0.525s][info   ][gc,load     ] GC(8) Load: 3.49/3.80/4.40</span><br><span class="line">[0.525s][info   ][gc,mmu      ] GC(8) MMU: 2ms/99.3%, 5ms/99.6%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/99.9%</span><br><span class="line">[0.525s][info   ][gc,marking  ] GC(8) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.525s][info   ][gc,marking  ] GC(8) Mark Stack Usage: 32M</span><br><span class="line">[0.525s][info   ][gc,nmethod  ] GC(8) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.525s][info   ][gc,metaspace] GC(8) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.525s][info   ][gc,ref      ] GC(8) Soft: 3 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.525s][info   ][gc,ref      ] GC(8) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.525s][info   ][gc,ref      ] GC(8) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.525s][info   ][gc,ref      ] GC(8) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.525s][info   ][gc,reloc    ] GC(8) Small Pages: 207 / 414M, Empty: 0M, Relocated: 96M, In-Place: 0</span><br><span class="line">[0.525s][info   ][gc,reloc    ] GC(8) Medium Pages: 19 / 608M, Empty: 0M, Relocated: 245M, In-Place: 1</span><br><span class="line">[0.525s][info   ][gc,reloc    ] GC(8) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.525s][info   ][gc,reloc    ] GC(8) Forwarding Usage: 0M</span><br><span class="line">[0.525s][info   ][gc,heap     ] GC(8) Min Capacity: 1024M(100%)</span><br><span class="line">[0.525s][info   ][gc,heap     ] GC(8) Max Capacity: 1024M(100%)</span><br><span class="line">[0.525s][info   ][gc,heap     ] GC(8) Soft Max Capacity: 1024M(100%)</span><br><span class="line">[0.525s][info   ][gc,heap     ] GC(8)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.525s][info   ][gc,heap     ] GC(8)  Capacity:     1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)</span><br><span class="line">[0.525s][info   ][gc,heap     ] GC(8)      Free:        2M (0%)            2M (0%)            2M (0%)          548M (54%)         550M (54%)           2M (0%)</span><br><span class="line">[0.525s][info   ][gc,heap     ] GC(8)      Used:     1022M (100%)       1022M (100%)       1022M (100%)        476M (46%)        1022M (100%)        474M (46%)</span><br><span class="line">[0.525s][info   ][gc,heap     ] GC(8)      Live:         -               352M (34%)         352M (34%)         352M (34%)            -                  -</span><br><span class="line">[0.525s][info   ][gc,heap     ] GC(8) Allocated:         -                 0M (0%)            0M (0%)          101M (10%)            -                  -</span><br><span class="line">[0.525s][info   ][gc,heap     ] GC(8)   Garbage:         -               669M (65%)         669M (65%)          21M (2%)             -                  -</span><br><span class="line">[0.525s][info   ][gc,heap     ] GC(8) Reclaimed:         -                  -                 0M (0%)          647M (63%)            -                  -</span><br><span class="line">[0.525s][info   ][gc          ] GC(8) Garbage Collection (Allocation Stall) 1022M(100%)-&gt;476M(46%)</span><br><span class="line">[0.558s][info   ][gc,start    ] GC(9) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.559s][info   ][gc,ref      ] GC(9) Clearing All SoftReferences</span><br><span class="line">[0.559s][info   ][gc,task     ] GC(9) Using 2 workers</span><br><span class="line">[0.559s][info   ][gc,phases   ] GC(9) Pause Mark Start 0.003ms</span><br><span class="line">[0.562s][info   ][gc,phases   ] GC(9) Concurrent Mark 3.252ms</span><br><span class="line">[0.562s][info   ][gc,phases   ] GC(9) Pause Mark End 0.006ms</span><br><span class="line">[0.562s][info   ][gc,phases   ] GC(9) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.562s][info   ][gc,phases   ] GC(9) Concurrent Process Non-Strong References 0.204ms</span><br><span class="line">[0.562s][info   ][gc,phases   ] GC(9) Concurrent Reset Relocation Set 0.008ms</span><br><span class="line">[0.564s][info   ][gc,phases   ] GC(9) Concurrent Select Relocation Set 1.407ms</span><br><span class="line">[0.564s][info   ][gc,phases   ] GC(9) Pause Relocate Start 0.002ms</span><br><span class="line">[0.564s][info   ][gc          ] Allocation Stall (main) 5.988ms</span><br><span class="line">[0.573s][info   ][gc,phases   ] GC(9) Concurrent Relocate 9.026ms</span><br><span class="line">[0.573s][info   ][gc,load     ] GC(9) Load: 3.49/3.80/4.40</span><br><span class="line">[0.573s][info   ][gc,mmu      ] GC(9) MMU: 2ms/99.3%, 5ms/99.6%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/99.9%</span><br><span class="line">[0.573s][info   ][gc,marking  ] GC(9) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.573s][info   ][gc,marking  ] GC(9) Mark Stack Usage: 32M</span><br><span class="line">[0.573s][info   ][gc,nmethod  ] GC(9) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.573s][info   ][gc,metaspace] GC(9) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.573s][info   ][gc,ref      ] GC(9) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.573s][info   ][gc,ref      ] GC(9) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.573s][info   ][gc,ref      ] GC(9) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.573s][info   ][gc,ref      ] GC(9) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.573s][info   ][gc,reloc    ] GC(9) Small Pages: 198 / 396M, Empty: 4M, Relocated: 103M, In-Place: 0</span><br><span class="line">[0.573s][info   ][gc,reloc    ] GC(9) Medium Pages: 19 / 608M, Empty: 0M, Relocated: 250M, In-Place: 1</span><br><span class="line">[0.573s][info   ][gc,reloc    ] GC(9) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.573s][info   ][gc,reloc    ] GC(9) Forwarding Usage: 0M</span><br><span class="line">[0.573s][info   ][gc,heap     ] GC(9) Min Capacity: 1024M(100%)</span><br><span class="line">[0.573s][info   ][gc,heap     ] GC(9) Max Capacity: 1024M(100%)</span><br><span class="line">[0.573s][info   ][gc,heap     ] GC(9) Soft Max Capacity: 1024M(100%)</span><br><span class="line">[0.573s][info   ][gc,heap     ] GC(9)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.573s][info   ][gc,heap     ] GC(9)  Capacity:     1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)</span><br><span class="line">[0.573s][info   ][gc,heap     ] GC(9)      Free:       20M (2%)           20M (2%)           24M (2%)          540M (53%)         540M (53%)          20M (2%)</span><br><span class="line">[0.573s][info   ][gc,heap     ] GC(9)      Used:     1004M (98%)        1004M (98%)        1000M (98%)         484M (47%)        1004M (98%)         484M (47%)</span><br><span class="line">[0.573s][info   ][gc,heap     ] GC(9)      Live:         -               357M (35%)         357M (35%)         357M (35%)            -                  -</span><br><span class="line">[0.573s][info   ][gc,heap     ] GC(9) Allocated:         -                 0M (0%)            0M (0%)          115M (11%)            -                  -</span><br><span class="line">[0.573s][info   ][gc,heap     ] GC(9)   Garbage:         -               646M (63%)         642M (63%)          10M (1%)             -                  -</span><br><span class="line">[0.573s][info   ][gc,heap     ] GC(9) Reclaimed:         -                  -                 4M (0%)          635M (62%)            -                  -</span><br><span class="line">[0.573s][info   ][gc          ] GC(9) Garbage Collection (Allocation Stall) 1004M(98%)-&gt;484M(47%)</span><br><span class="line">[0.606s][info   ][gc,start    ] GC(10) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.606s][info   ][gc,ref      ] GC(10) Clearing All SoftReferences</span><br><span class="line">[0.606s][info   ][gc,task     ] GC(10) Using 2 workers</span><br><span class="line">[0.606s][info   ][gc,phases   ] GC(10) Pause Mark Start 0.004ms</span><br><span class="line">[0.609s][info   ][gc,phases   ] GC(10) Concurrent Mark 3.487ms</span><br><span class="line">[0.610s][info   ][gc,phases   ] GC(10) Pause Mark End 0.004ms</span><br><span class="line">[0.610s][info   ][gc,phases   ] GC(10) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.610s][info   ][gc,phases   ] GC(10) Concurrent Process Non-Strong References 0.206ms</span><br><span class="line">[0.610s][info   ][gc,phases   ] GC(10) Concurrent Reset Relocation Set 0.007ms</span><br><span class="line">[0.611s][info   ][gc,phases   ] GC(10) Concurrent Select Relocation Set 1.478ms</span><br><span class="line">[0.611s][info   ][gc,phases   ] GC(10) Pause Relocate Start 0.004ms</span><br><span class="line">[0.613s][info   ][gc          ] Allocation Stall (main) 6.895ms</span><br><span class="line">[0.619s][info   ][gc,phases   ] GC(10) Concurrent Relocate 7.578ms</span><br><span class="line">[0.619s][info   ][gc,load     ] GC(10) Load: 3.49/3.80/4.40</span><br><span class="line">[0.619s][info   ][gc,mmu      ] GC(10) MMU: 2ms/99.3%, 5ms/99.6%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/99.9%</span><br><span class="line">[0.619s][info   ][gc,marking  ] GC(10) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.619s][info   ][gc,marking  ] GC(10) Mark Stack Usage: 32M</span><br><span class="line">[0.619s][info   ][gc,nmethod  ] GC(10) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.619s][info   ][gc,metaspace] GC(10) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.619s][info   ][gc,ref      ] GC(10) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.619s][info   ][gc,ref      ] GC(10) Weak: 23 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.619s][info   ][gc,ref      ] GC(10) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.619s][info   ][gc,ref      ] GC(10) Phantom: 1 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.619s][info   ][gc,reloc    ] GC(10) Small Pages: 205 / 410M, Empty: 6M, Relocated: 108M, In-Place: 0</span><br><span class="line">[0.619s][info   ][gc,reloc    ] GC(10) Medium Pages: 19 / 608M, Empty: 0M, Relocated: 215M, In-Place: 1</span><br><span class="line">[0.619s][info   ][gc,reloc    ] GC(10) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.619s][info   ][gc,reloc    ] GC(10) Forwarding Usage: 0M</span><br><span class="line">[0.619s][info   ][gc,heap     ] GC(10) Min Capacity: 1024M(100%)</span><br><span class="line">[0.619s][info   ][gc,heap     ] GC(10) Max Capacity: 1024M(100%)</span><br><span class="line">[0.619s][info   ][gc,heap     ] GC(10) Soft Max Capacity: 1024M(100%)</span><br><span class="line">[0.619s][info   ][gc,heap     ] GC(10)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.619s][info   ][gc,heap     ] GC(10)  Capacity:     1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)</span><br><span class="line">[0.619s][info   ][gc,heap     ] GC(10)      Free:        6M (1%)            6M (1%)           12M (1%)          548M (54%)         548M (54%)           6M (1%)</span><br><span class="line">[0.619s][info   ][gc,heap     ] GC(10)      Used:     1018M (99%)        1018M (99%)        1012M (99%)         476M (46%)        1018M (99%)         476M (46%)</span><br><span class="line">[0.619s][info   ][gc,heap     ] GC(10)      Live:         -               341M (33%)         341M (33%)         341M (33%)            -                  -</span><br><span class="line">[0.619s][info   ][gc,heap     ] GC(10) Allocated:         -                 0M (0%)            0M (0%)          103M (10%)            -                  -</span><br><span class="line">[0.619s][info   ][gc,heap     ] GC(10)   Garbage:         -               676M (66%)         670M (65%)          30M (3%)             -                  -</span><br><span class="line">[0.619s][info   ][gc,heap     ] GC(10) Reclaimed:         -                  -                 6M (1%)          645M (63%)            -                  -</span><br><span class="line">[0.619s][info   ][gc          ] GC(10) Garbage Collection (Allocation Stall) 1018M(99%)-&gt;476M(46%)</span><br><span class="line">[0.620s][info   ][gc,start    ] GC(11) Garbage Collection (Warmup)</span><br><span class="line">[0.620s][info   ][gc,task     ] GC(11) Using 2 workers</span><br><span class="line">[0.620s][info   ][gc,phases   ] GC(11) Pause Mark Start 0.003ms</span><br><span class="line">[0.624s][info   ][gc,phases   ] GC(11) Concurrent Mark 4.084ms</span><br><span class="line">[0.624s][info   ][gc,phases   ] GC(11) Pause Mark End 0.005ms</span><br><span class="line">[0.624s][info   ][gc,phases   ] GC(11) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.629s][info   ][gc,phases   ] GC(11) Concurrent Process Non-Strong References 4.673ms</span><br><span class="line">[0.629s][info   ][gc,phases   ] GC(11) Concurrent Reset Relocation Set 0.008ms</span><br><span class="line">[0.631s][info   ][gc,phases   ] GC(11) Concurrent Select Relocation Set 2.151ms</span><br><span class="line">[0.631s][info   ][gc,phases   ] GC(11) Pause Relocate Start 0.007ms</span><br><span class="line">[0.634s][info   ][gc,phases   ] GC(11) Concurrent Relocate 2.506ms</span><br><span class="line">[0.634s][info   ][gc,load     ] GC(11) Load: 3.49/3.80/4.40</span><br><span class="line">[0.634s][info   ][gc,mmu      ] GC(11) MMU: 2ms/99.3%, 5ms/99.6%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/99.9%</span><br><span class="line">[0.634s][info   ][gc,marking  ] GC(11) Mark: 2 stripe(s), 2 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.634s][info   ][gc,marking  ] GC(11) Mark Stack Usage: 32M</span><br><span class="line">[0.634s][info   ][gc,nmethod  ] GC(11) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.634s][info   ][gc,metaspace] GC(11) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.634s][info   ][gc,ref      ] GC(11) Soft: 3 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.634s][info   ][gc,ref      ] GC(11) Weak: 23 encountered, 2 discovered, 0 enqueued</span><br><span class="line">[0.634s][info   ][gc,ref      ] GC(11) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.634s][info   ][gc,ref      ] GC(11) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.634s][info   ][gc,reloc    ] GC(11) Small Pages: 81 / 162M, Empty: 0M, Relocated: 15M, In-Place: 0</span><br><span class="line">[0.634s][info   ][gc,reloc    ] GC(11) Medium Pages: 11 / 352M, Empty: 0M, Relocated: 46M, In-Place: 0</span><br><span class="line">[0.634s][info   ][gc,reloc    ] GC(11) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.634s][info   ][gc,reloc    ] GC(11) Forwarding Usage: 0M</span><br><span class="line">[0.634s][info   ][gc,heap     ] GC(11) Min Capacity: 1024M(100%)</span><br><span class="line">[0.634s][info   ][gc,heap     ] GC(11) Max Capacity: 1024M(100%)</span><br><span class="line">[0.634s][info   ][gc,heap     ] GC(11) Soft Max Capacity: 1024M(100%)</span><br><span class="line">[0.634s][info   ][gc,heap     ] GC(11)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.634s][info   ][gc,heap     ] GC(11)  Capacity:     1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)</span><br><span class="line">[0.634s][info   ][gc,heap     ] GC(11)      Free:      510M (50%)         462M (45%)         402M (39%)         454M (44%)         510M (50%)         360M (35%)</span><br><span class="line">[0.634s][info   ][gc,heap     ] GC(11)      Used:      514M (50%)         562M (55%)         622M (61%)         570M (56%)         664M (65%)         514M (50%)</span><br><span class="line">[0.634s][info   ][gc,heap     ] GC(11)      Live:         -               343M (34%)         343M (34%)         343M (34%)            -                  -</span><br><span class="line">[0.634s][info   ][gc,heap     ] GC(11) Allocated:         -                48M (5%)          108M (11%)         155M (15%)            -                  -</span><br><span class="line">[0.634s][info   ][gc,heap     ] GC(11)   Garbage:         -               170M (17%)         170M (17%)          70M (7%)             -                  -</span><br><span class="line">[0.634s][info   ][gc,heap     ] GC(11) Reclaimed:         -                  -                 0M (0%)           99M (10%)            -                  -</span><br><span class="line">[0.634s][info   ][gc          ] GC(11) Garbage Collection (Warmup) 514M(50%)-&gt;570M(56%)</span><br><span class="line">[0.661s][info   ][gc,start    ] GC(12) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.661s][info   ][gc,ref      ] GC(12) Clearing All SoftReferences</span><br><span class="line">[0.661s][info   ][gc,task     ] GC(12) Using 2 workers</span><br><span class="line">[0.661s][info   ][gc,phases   ] GC(12) Pause Mark Start 0.006ms</span><br><span class="line">[0.665s][info   ][gc,phases   ] GC(12) Concurrent Mark 3.750ms</span><br><span class="line">[0.665s][info   ][gc,phases   ] GC(12) Pause Mark End 0.008ms</span><br><span class="line">[0.665s][info   ][gc,phases   ] GC(12) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.665s][info   ][gc,phases   ] GC(12) Concurrent Process Non-Strong References 0.466ms</span><br><span class="line">[0.665s][info   ][gc,phases   ] GC(12) Concurrent Reset Relocation Set 0.002ms</span><br><span class="line">[0.667s][info   ][gc,phases   ] GC(12) Concurrent Select Relocation Set 1.557ms</span><br><span class="line">[0.667s][info   ][gc,phases   ] GC(12) Pause Relocate Start 0.004ms</span><br><span class="line">[0.667s][info   ][gc          ] Allocation Stall (main) 6.807ms</span><br><span class="line">[0.674s][info   ][gc,phases   ] GC(12) Concurrent Relocate 7.056ms</span><br><span class="line">[0.674s][info   ][gc,load     ] GC(12) Load: 3.49/3.80/4.40</span><br><span class="line">[0.674s][info   ][gc,mmu      ] GC(12) MMU: 2ms/99.3%, 5ms/99.6%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/99.9%</span><br><span class="line">[0.674s][info   ][gc,marking  ] GC(12) Mark: 2 stripe(s), 2 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.674s][info   ][gc,marking  ] GC(12) Mark Stack Usage: 32M</span><br><span class="line">[0.674s][info   ][gc,nmethod  ] GC(12) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.674s][info   ][gc,metaspace] GC(12) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.674s][info   ][gc,ref      ] GC(12) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.674s][info   ][gc,ref      ] GC(12) Weak: 23 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.674s][info   ][gc,ref      ] GC(12) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.674s][info   ][gc,ref      ] GC(12) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.674s][info   ][gc,reloc    ] GC(12) Small Pages: 194 / 388M, Empty: 0M, Relocated: 102M, In-Place: 0</span><br><span class="line">[0.674s][info   ][gc,reloc    ] GC(12) Medium Pages: 19 / 608M, Empty: 0M, Relocated: 194M, In-Place: 1</span><br><span class="line">[0.674s][info   ][gc,reloc    ] GC(12) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.674s][info   ][gc,reloc    ] GC(12) Forwarding Usage: 0M</span><br><span class="line">[0.674s][info   ][gc,heap     ] GC(12) Min Capacity: 1024M(100%)</span><br><span class="line">[0.674s][info   ][gc,heap     ] GC(12) Max Capacity: 1024M(100%)</span><br><span class="line">[0.674s][info   ][gc,heap     ] GC(12) Soft Max Capacity: 1024M(100%)</span><br><span class="line">[0.674s][info   ][gc,heap     ] GC(12)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.674s][info   ][gc,heap     ] GC(12)  Capacity:     1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)</span><br><span class="line">[0.674s][info   ][gc,heap     ] GC(12)      Free:       28M (3%)           28M (3%)           28M (3%)          518M (51%)         520M (51%)          26M (3%)</span><br><span class="line">[0.674s][info   ][gc,heap     ] GC(12)      Used:      996M (97%)         996M (97%)         996M (97%)         506M (49%)         998M (97%)         504M (49%)</span><br><span class="line">[0.674s][info   ][gc,heap     ] GC(12)      Live:         -               335M (33%)         335M (33%)         335M (33%)            -                  -</span><br><span class="line">[0.674s][info   ][gc,heap     ] GC(12) Allocated:         -                 0M (0%)            0M (0%)          103M (10%)            -                  -</span><br><span class="line">[0.674s][info   ][gc,heap     ] GC(12)   Garbage:         -               660M (64%)         660M (64%)          66M (6%)             -                  -</span><br><span class="line">[0.674s][info   ][gc,heap     ] GC(12) Reclaimed:         -                  -                 0M (0%)          593M (58%)            -                  -</span><br><span class="line">[0.674s][info   ][gc          ] GC(12) Garbage Collection (Allocation Stall) 996M(97%)-&gt;506M(49%)</span><br><span class="line">[0.704s][info   ][gc,start    ] GC(13) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.704s][info   ][gc,ref      ] GC(13) Clearing All SoftReferences</span><br><span class="line">[0.704s][info   ][gc,task     ] GC(13) Using 2 workers</span><br><span class="line">[0.704s][info   ][gc,phases   ] GC(13) Pause Mark Start 0.004ms</span><br><span class="line">[0.708s][info   ][gc,phases   ] GC(13) Concurrent Mark 3.456ms</span><br><span class="line">[0.708s][info   ][gc,phases   ] GC(13) Pause Mark End 0.007ms</span><br><span class="line">[0.708s][info   ][gc,phases   ] GC(13) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.708s][info   ][gc,phases   ] GC(13) Concurrent Process Non-Strong References 0.226ms</span><br><span class="line">[0.708s][info   ][gc,phases   ] GC(13) Concurrent Reset Relocation Set 0.007ms</span><br><span class="line">[0.710s][info   ][gc,phases   ] GC(13) Concurrent Select Relocation Set 1.469ms</span><br><span class="line">[0.710s][info   ][gc,phases   ] GC(13) Pause Relocate Start 0.002ms</span><br><span class="line">[0.713s][info   ][gc          ] Allocation Stall (main) 8.956ms</span><br><span class="line">[0.716s][info   ][gc,phases   ] GC(13) Concurrent Relocate 6.298ms</span><br><span class="line">[0.716s][info   ][gc,load     ] GC(13) Load: 3.45/3.79/4.40</span><br><span class="line">[0.716s][info   ][gc,mmu      ] GC(13) MMU: 2ms/99.3%, 5ms/99.6%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/99.9%</span><br><span class="line">[0.716s][info   ][gc,marking  ] GC(13) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.716s][info   ][gc,marking  ] GC(13) Mark Stack Usage: 32M</span><br><span class="line">[0.716s][info   ][gc,nmethod  ] GC(13) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.716s][info   ][gc,metaspace] GC(13) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.716s][info   ][gc,ref      ] GC(13) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.716s][info   ][gc,ref      ] GC(13) Weak: 23 encountered, 2 discovered, 0 enqueued</span><br><span class="line">[0.716s][info   ][gc,ref      ] GC(13) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.716s][info   ][gc,ref      ] GC(13) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.716s][info   ][gc,reloc    ] GC(13) Small Pages: 192 / 384M, Empty: 0M, Relocated: 101M, In-Place: 0</span><br><span class="line">[0.716s][info   ][gc,reloc    ] GC(13) Medium Pages: 20 / 640M, Empty: 0M, Relocated: 193M, In-Place: 1</span><br><span class="line">[0.716s][info   ][gc,reloc    ] GC(13) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.716s][info   ][gc,reloc    ] GC(13) Forwarding Usage: 0M</span><br><span class="line">[0.716s][info   ][gc,heap     ] GC(13) Min Capacity: 1024M(100%)</span><br><span class="line">[0.716s][info   ][gc,heap     ] GC(13) Max Capacity: 1024M(100%)</span><br><span class="line">[0.716s][info   ][gc,heap     ] GC(13) Soft Max Capacity: 1024M(100%)</span><br><span class="line">[0.716s][info   ][gc,heap     ] GC(13)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.716s][info   ][gc,heap     ] GC(13)  Capacity:     1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)</span><br><span class="line">[0.716s][info   ][gc,heap     ] GC(13)      Free:        0M (0%)            0M (0%)            0M (0%)          568M (55%)         570M (56%)           0M (0%)</span><br><span class="line">[0.716s][info   ][gc,heap     ] GC(13)      Used:     1024M (100%)       1024M (100%)       1024M (100%)        456M (45%)        1024M (100%)        454M (44%)</span><br><span class="line">[0.716s][info   ][gc,heap     ] GC(13)      Live:         -               337M (33%)         337M (33%)         337M (33%)            -                  -</span><br><span class="line">[0.716s][info   ][gc,heap     ] GC(13) Allocated:         -                 0M (0%)            0M (0%)           51M (5%)             -                  -</span><br><span class="line">[0.716s][info   ][gc,heap     ] GC(13)   Garbage:         -               686M (67%)         686M (67%)          66M (7%)             -                  -</span><br><span class="line">[0.716s][info   ][gc,heap     ] GC(13) Reclaimed:         -                  -                 0M (0%)          619M (61%)            -                  -</span><br><span class="line">[0.716s][info   ][gc          ] GC(13) Garbage Collection (Allocation Stall) 1024M(100%)-&gt;456M(45%)</span><br><span class="line">[0.720s][info   ][gc,start    ] GC(14) Garbage Collection (Allocation Rate)</span><br><span class="line">[0.720s][info   ][gc,task     ] GC(14) Using 2 workers</span><br><span class="line">[0.720s][info   ][gc,phases   ] GC(14) Pause Mark Start 0.004ms</span><br><span class="line">[0.724s][info   ][gc,phases   ] GC(14) Concurrent Mark 4.310ms</span><br><span class="line">[0.724s][info   ][gc,phases   ] GC(14) Pause Mark End 0.007ms</span><br><span class="line">[0.724s][info   ][gc,phases   ] GC(14) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.725s][info   ][gc,phases   ] GC(14) Concurrent Process Non-Strong References 0.277ms</span><br><span class="line">[0.725s][info   ][gc,phases   ] GC(14) Concurrent Reset Relocation Set 0.006ms</span><br><span class="line">[0.726s][info   ][gc,phases   ] GC(14) Concurrent Select Relocation Set 1.429ms</span><br><span class="line">[0.726s][info   ][gc,phases   ] GC(14) Pause Relocate Start 0.005ms</span><br><span class="line">[0.727s][info   ][gc,phases   ] GC(14) Concurrent Relocate 0.958ms</span><br><span class="line">[0.727s][info   ][gc,load     ] GC(14) Load: 3.45/3.79/4.40</span><br><span class="line">[0.727s][info   ][gc,mmu      ] GC(14) MMU: 2ms/99.3%, 5ms/99.6%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/99.9%</span><br><span class="line">[0.727s][info   ][gc,marking  ] GC(14) Mark: 2 stripe(s), 2 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.727s][info   ][gc,marking  ] GC(14) Mark Stack Usage: 32M</span><br><span class="line">[0.727s][info   ][gc,nmethod  ] GC(14) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.727s][info   ][gc,metaspace] GC(14) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.727s][info   ][gc,ref      ] GC(14) Soft: 3 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.728s][info   ][gc,ref      ] GC(14) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.728s][info   ][gc,ref      ] GC(14) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.728s][info   ][gc,ref      ] GC(14) Phantom: 1 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.728s][info   ][gc,reloc    ] GC(14) Small Pages: 82 / 164M, Empty: 0M, Relocated: 17M, In-Place: 0</span><br><span class="line">[0.728s][info   ][gc,reloc    ] GC(14) Medium Pages: 11 / 352M, Empty: 0M, Relocated: 27M, In-Place: 0</span><br><span class="line">[0.728s][info   ][gc,reloc    ] GC(14) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.728s][info   ][gc,reloc    ] GC(14) Forwarding Usage: 0M</span><br><span class="line">[0.728s][info   ][gc,heap     ] GC(14) Min Capacity: 1024M(100%)</span><br><span class="line">[0.728s][info   ][gc,heap     ] GC(14) Max Capacity: 1024M(100%)</span><br><span class="line">[0.728s][info   ][gc,heap     ] GC(14) Soft Max Capacity: 1024M(100%)</span><br><span class="line">[0.728s][info   ][gc,heap     ] GC(14)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.728s][info   ][gc,heap     ] GC(14)  Capacity:     1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)</span><br><span class="line">[0.728s][info   ][gc,heap     ] GC(14)      Free:      508M (50%)         458M (45%)         450M (44%)         512M (50%)         512M (50%)         416M (41%)</span><br><span class="line">[0.728s][info   ][gc,heap     ] GC(14)      Used:      516M (50%)         566M (55%)         574M (56%)         512M (50%)         608M (59%)         512M (50%)</span><br><span class="line">[0.728s][info   ][gc,heap     ] GC(14)      Live:         -               331M (32%)         331M (32%)         331M (32%)            -                  -</span><br><span class="line">[0.728s][info   ][gc,heap     ] GC(14) Allocated:         -                50M (5%)           58M (6%)           97M (10%)            -                  -</span><br><span class="line">[0.728s][info   ][gc,heap     ] GC(14)   Garbage:         -               184M (18%)         184M (18%)          82M (8%)             -                  -</span><br><span class="line">[0.728s][info   ][gc,heap     ] GC(14) Reclaimed:         -                  -                 0M (0%)          101M (10%)            -                  -</span><br><span class="line">[0.728s][info   ][gc          ] GC(14) Garbage Collection (Allocation Rate) 516M(50%)-&gt;512M(50%)</span><br><span class="line">[0.757s][info   ][gc,start    ] GC(15) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.757s][info   ][gc,ref      ] GC(15) Clearing All SoftReferences</span><br><span class="line">[0.757s][info   ][gc,task     ] GC(15) Using 2 workers</span><br><span class="line">[0.757s][info   ][gc,phases   ] GC(15) Pause Mark Start 0.007ms</span><br><span class="line">[0.760s][info   ][gc,phases   ] GC(15) Concurrent Mark 3.584ms</span><br><span class="line">[0.761s][info   ][gc,phases   ] GC(15) Pause Mark End 0.005ms</span><br><span class="line">[0.761s][info   ][gc,phases   ] GC(15) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.761s][info   ][gc,phases   ] GC(15) Concurrent Process Non-Strong References 0.224ms</span><br><span class="line">[0.761s][info   ][gc,phases   ] GC(15) Concurrent Reset Relocation Set 0.002ms</span><br><span class="line">[0.762s][info   ][gc,phases   ] GC(15) Concurrent Select Relocation Set 1.453ms</span><br><span class="line">[0.762s][info   ][gc,phases   ] GC(15) Pause Relocate Start 0.004ms</span><br><span class="line">[0.764s][info   ][gc          ] Allocation Stall (main) 7.591ms</span><br><span class="line">[0.769s][info   ][gc,phases   ] GC(15) Concurrent Relocate 6.677ms</span><br><span class="line">[0.769s][info   ][gc,load     ] GC(15) Load: 3.45/3.79/4.40</span><br><span class="line">[0.769s][info   ][gc,mmu      ] GC(15) MMU: 2ms/99.3%, 5ms/99.6%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/99.9%</span><br><span class="line">[0.769s][info   ][gc,marking  ] GC(15) Mark: 2 stripe(s), 2 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.769s][info   ][gc,marking  ] GC(15) Mark Stack Usage: 32M</span><br><span class="line">[0.769s][info   ][gc,nmethod  ] GC(15) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.769s][info   ][gc,metaspace] GC(15) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.769s][info   ][gc,ref      ] GC(15) Soft: 3 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.769s][info   ][gc,ref      ] GC(15) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.769s][info   ][gc,ref      ] GC(15) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.769s][info   ][gc,ref      ] GC(15) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.769s][info   ][gc,reloc    ] GC(15) Small Pages: 195 / 390M, Empty: 2M, Relocated: 99M, In-Place: 0</span><br><span class="line">[0.769s][info   ][gc,reloc    ] GC(15) Medium Pages: 19 / 608M, Empty: 0M, Relocated: 211M, In-Place: 1</span><br><span class="line">[0.769s][info   ][gc,reloc    ] GC(15) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.769s][info   ][gc,reloc    ] GC(15) Forwarding Usage: 0M</span><br><span class="line">[0.769s][info   ][gc,heap     ] GC(15) Min Capacity: 1024M(100%)</span><br><span class="line">[0.769s][info   ][gc,heap     ] GC(15) Max Capacity: 1024M(100%)</span><br><span class="line">[0.769s][info   ][gc,heap     ] GC(15) Soft Max Capacity: 1024M(100%)</span><br><span class="line">[0.769s][info   ][gc,heap     ] GC(15)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.769s][info   ][gc,heap     ] GC(15)  Capacity:     1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)</span><br><span class="line">[0.769s][info   ][gc,heap     ] GC(15)      Free:       26M (3%)           26M (3%)           28M (3%)          554M (54%)         560M (55%)          26M (3%)</span><br><span class="line">[0.769s][info   ][gc,heap     ] GC(15)      Used:      998M (97%)         998M (97%)         996M (97%)         470M (46%)         998M (97%)         464M (45%)</span><br><span class="line">[0.769s][info   ][gc,heap     ] GC(15)      Live:         -               339M (33%)         339M (33%)         339M (33%)            -                  -</span><br><span class="line">[0.769s][info   ][gc,heap     ] GC(15) Allocated:         -                 0M (0%)            0M (0%)           95M (9%)             -                  -</span><br><span class="line">[0.769s][info   ][gc,heap     ] GC(15)   Garbage:         -               658M (64%)         656M (64%)          34M (3%)             -                  -</span><br><span class="line">[0.769s][info   ][gc,heap     ] GC(15) Reclaimed:         -                  -                 2M (0%)          623M (61%)            -                  -</span><br><span class="line">[0.769s][info   ][gc          ] GC(15) Garbage Collection (Allocation Stall) 998M(97%)-&gt;470M(46%)</span><br><span class="line">[0.800s][info   ][gc,start    ] GC(16) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.800s][info   ][gc,ref      ] GC(16) Clearing All SoftReferences</span><br><span class="line">[0.800s][info   ][gc,task     ] GC(16) Using 2 workers</span><br><span class="line">[0.800s][info   ][gc,phases   ] GC(16) Pause Mark Start 0.003ms</span><br><span class="line">[0.804s][info   ][gc,phases   ] GC(16) Concurrent Mark 3.066ms</span><br><span class="line">[0.804s][info   ][gc,phases   ] GC(16) Pause Mark End 0.005ms</span><br><span class="line">[0.804s][info   ][gc,phases   ] GC(16) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.804s][info   ][gc,phases   ] GC(16) Concurrent Process Non-Strong References 0.245ms</span><br><span class="line">[0.804s][info   ][gc,phases   ] GC(16) Concurrent Reset Relocation Set 0.006ms</span><br><span class="line">[0.805s][info   ][gc,phases   ] GC(16) Concurrent Select Relocation Set 1.477ms</span><br><span class="line">[0.806s][info   ][gc,phases   ] GC(16) Pause Relocate Start 0.005ms</span><br><span class="line">[0.806s][info   ][gc          ] Allocation Stall (main) 5.740ms</span><br><span class="line">[0.812s][info   ][gc,phases   ] GC(16) Concurrent Relocate 6.476ms</span><br><span class="line">[0.812s][info   ][gc,load     ] GC(16) Load: 3.45/3.79/4.40</span><br><span class="line">[0.812s][info   ][gc,mmu      ] GC(16) MMU: 2ms/99.3%, 5ms/99.6%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/99.9%</span><br><span class="line">[0.812s][info   ][gc,marking  ] GC(16) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.812s][info   ][gc,marking  ] GC(16) Mark Stack Usage: 32M</span><br><span class="line">[0.812s][info   ][gc,nmethod  ] GC(16) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.812s][info   ][gc,metaspace] GC(16) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.812s][info   ][gc,ref      ] GC(16) Soft: 3 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.812s][info   ][gc,ref      ] GC(16) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.812s][info   ][gc,ref      ] GC(16) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.812s][info   ][gc,ref      ] GC(16) Phantom: 1 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.812s][info   ][gc,reloc    ] GC(16) Small Pages: 199 / 398M, Empty: 0M, Relocated: 103M, In-Place: 0</span><br><span class="line">[0.812s][info   ][gc,reloc    ] GC(16) Medium Pages: 19 / 608M, Empty: 0M, Relocated: 195M, In-Place: 1</span><br><span class="line">[0.812s][info   ][gc,reloc    ] GC(16) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.812s][info   ][gc,reloc    ] GC(16) Forwarding Usage: 0M</span><br><span class="line">[0.812s][info   ][gc,heap     ] GC(16) Min Capacity: 1024M(100%)</span><br><span class="line">[0.812s][info   ][gc,heap     ] GC(16) Max Capacity: 1024M(100%)</span><br><span class="line">[0.812s][info   ][gc,heap     ] GC(16) Soft Max Capacity: 1024M(100%)</span><br><span class="line">[0.812s][info   ][gc,heap     ] GC(16)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.812s][info   ][gc,heap     ] GC(16)  Capacity:     1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)</span><br><span class="line">[0.812s][info   ][gc,heap     ] GC(16)      Free:       18M (2%)           18M (2%)           18M (2%)          522M (51%)         540M (53%)          16M (2%)</span><br><span class="line">[0.812s][info   ][gc,heap     ] GC(16)      Used:     1006M (98%)        1006M (98%)        1006M (98%)         502M (49%)        1008M (98%)         484M (47%)</span><br><span class="line">[0.812s][info   ][gc,heap     ] GC(16)      Live:         -               336M (33%)         336M (33%)         336M (33%)            -                  -</span><br><span class="line">[0.812s][info   ][gc,heap     ] GC(16) Allocated:         -                 0M (0%)            0M (0%)           97M (10%)            -                  -</span><br><span class="line">[0.812s][info   ][gc,heap     ] GC(16)   Garbage:         -               669M (65%)         669M (65%)          67M (7%)             -                  -</span><br><span class="line">[0.812s][info   ][gc,heap     ] GC(16) Reclaimed:         -                  -                 0M (0%)          601M (59%)            -                  -</span><br><span class="line">[0.812s][info   ][gc          ] GC(16) Garbage Collection (Allocation Stall) 1006M(98%)-&gt;502M(49%)</span><br><span class="line">[0.820s][info   ][gc,start    ] GC(17) Garbage Collection (Allocation Rate)</span><br><span class="line">[0.820s][info   ][gc,task     ] GC(17) Using 2 workers</span><br><span class="line">[0.820s][info   ][gc,phases   ] GC(17) Pause Mark Start 0.003ms</span><br><span class="line">[0.826s][info   ][gc,phases   ] GC(17) Concurrent Mark 6.329ms</span><br><span class="line">[0.826s][info   ][gc,phases   ] GC(17) Pause Mark End 0.008ms</span><br><span class="line">[0.827s][info   ][gc,phases   ] GC(17) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.827s][info   ][gc,phases   ] GC(17) Concurrent Process Non-Strong References 0.247ms</span><br><span class="line">[0.827s][info   ][gc,phases   ] GC(17) Concurrent Reset Relocation Set 0.008ms</span><br><span class="line">[0.828s][info   ][gc,phases   ] GC(17) Concurrent Select Relocation Set 1.442ms</span><br><span class="line">[0.828s][info   ][gc,phases   ] GC(17) Pause Relocate Start 0.005ms</span><br><span class="line">[0.831s][info   ][gc,phases   ] GC(17) Concurrent Relocate 2.171ms</span><br><span class="line">[0.831s][info   ][gc,load     ] GC(17) Load: 3.45/3.79/4.40</span><br><span class="line">[0.831s][info   ][gc,mmu      ] GC(17) MMU: 2ms/99.3%, 5ms/99.6%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/99.9%</span><br><span class="line">[0.831s][info   ][gc,marking  ] GC(17) Mark: 2 stripe(s), 2 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.831s][info   ][gc,marking  ] GC(17) Mark Stack Usage: 32M</span><br><span class="line">[0.831s][info   ][gc,nmethod  ] GC(17) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.831s][info   ][gc,metaspace] GC(17) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.831s][info   ][gc,ref      ] GC(17) Soft: 3 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.831s][info   ][gc,ref      ] GC(17) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.831s][info   ][gc,ref      ] GC(17) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.831s][info   ][gc,ref      ] GC(17) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.831s][info   ][gc,reloc    ] GC(17) Small Pages: 103 / 206M, Empty: 0M, Relocated: 24M, In-Place: 0</span><br><span class="line">[0.831s][info   ][gc,reloc    ] GC(17) Medium Pages: 13 / 416M, Empty: 0M, Relocated: 76M, In-Place: 0</span><br><span class="line">[0.831s][info   ][gc,reloc    ] GC(17) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.831s][info   ][gc,reloc    ] GC(17) Forwarding Usage: 0M</span><br><span class="line">[0.831s][info   ][gc,heap     ] GC(17) Min Capacity: 1024M(100%)</span><br><span class="line">[0.831s][info   ][gc,heap     ] GC(17) Max Capacity: 1024M(100%)</span><br><span class="line">[0.831s][info   ][gc,heap     ] GC(17) Soft Max Capacity: 1024M(100%)</span><br><span class="line">[0.831s][info   ][gc,heap     ] GC(17)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.831s][info   ][gc,heap     ] GC(17)  Capacity:     1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)</span><br><span class="line">[0.831s][info   ][gc,heap     ] GC(17)      Free:      402M (39%)         342M (33%)         302M (29%)         488M (48%)         490M (48%)         268M (26%)</span><br><span class="line">[0.831s][info   ][gc,heap     ] GC(17)      Used:      622M (61%)         682M (67%)         722M (71%)         536M (52%)         756M (74%)         534M (52%)</span><br><span class="line">[0.831s][info   ][gc,heap     ] GC(17)      Live:         -               328M (32%)         328M (32%)         328M (32%)            -                  -</span><br><span class="line">[0.831s][info   ][gc,heap     ] GC(17) Allocated:         -                60M (6%)          100M (10%)         117M (12%)            -                  -</span><br><span class="line">[0.831s][info   ][gc,heap     ] GC(17)   Garbage:         -               293M (29%)         293M (29%)          89M (9%)             -                  -</span><br><span class="line">[0.831s][info   ][gc,heap     ] GC(17) Reclaimed:         -                  -                 0M (0%)          203M (20%)            -                  -</span><br><span class="line">[0.831s][info   ][gc          ] GC(17) Garbage Collection (Allocation Rate) 622M(61%)-&gt;536M(52%)</span><br><span class="line">[0.858s][info   ][gc,start    ] GC(18) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.858s][info   ][gc,ref      ] GC(18) Clearing All SoftReferences</span><br><span class="line">[0.858s][info   ][gc,task     ] GC(18) Using 2 workers</span><br><span class="line">[0.858s][info   ][gc,phases   ] GC(18) Pause Mark Start 0.007ms</span><br><span class="line">[0.861s][info   ][gc,phases   ] GC(18) Concurrent Mark 2.957ms</span><br><span class="line">[0.861s][info   ][gc,phases   ] GC(18) Pause Mark End 0.004ms</span><br><span class="line">[0.861s][info   ][gc,phases   ] GC(18) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.862s][info   ][gc,phases   ] GC(18) Concurrent Process Non-Strong References 0.225ms</span><br><span class="line">[0.862s][info   ][gc,phases   ] GC(18) Concurrent Reset Relocation Set 0.003ms</span><br><span class="line">[0.863s][info   ][gc,phases   ] GC(18) Concurrent Select Relocation Set 1.466ms</span><br><span class="line">[0.863s][info   ][gc,phases   ] GC(18) Pause Relocate Start 0.005ms</span><br><span class="line">[0.865s][info   ][gc          ] Allocation Stall (main) 7.012ms</span><br><span class="line">[0.869s][info   ][gc,phases   ] GC(18) Concurrent Relocate 6.186ms</span><br><span class="line">[0.869s][info   ][gc,load     ] GC(18) Load: 3.45/3.79/4.40</span><br><span class="line">[0.869s][info   ][gc,mmu      ] GC(18) MMU: 2ms/99.3%, 5ms/99.6%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/99.9%</span><br><span class="line">[0.870s][info   ][gc,marking  ] GC(18) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.870s][info   ][gc,marking  ] GC(18) Mark Stack Usage: 32M</span><br><span class="line">[0.870s][info   ][gc,nmethod  ] GC(18) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.870s][info   ][gc,metaspace] GC(18) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.870s][info   ][gc,ref      ] GC(18) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.870s][info   ][gc,ref      ] GC(18) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.870s][info   ][gc,ref      ] GC(18) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.870s][info   ][gc,ref      ] GC(18) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.870s][info   ][gc,reloc    ] GC(18) Small Pages: 200 / 400M, Empty: 0M, Relocated: 99M, In-Place: 0</span><br><span class="line">[0.870s][info   ][gc,reloc    ] GC(18) Medium Pages: 19 / 608M, Empty: 0M, Relocated: 188M, In-Place: 1</span><br><span class="line">[0.870s][info   ][gc,reloc    ] GC(18) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.870s][info   ][gc,reloc    ] GC(18) Forwarding Usage: 0M</span><br><span class="line">[0.870s][info   ][gc,heap     ] GC(18) Min Capacity: 1024M(100%)</span><br><span class="line">[0.870s][info   ][gc,heap     ] GC(18) Max Capacity: 1024M(100%)</span><br><span class="line">[0.870s][info   ][gc,heap     ] GC(18) Soft Max Capacity: 1024M(100%)</span><br><span class="line">[0.870s][info   ][gc,heap     ] GC(18)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.870s][info   ][gc,heap     ] GC(18)  Capacity:     1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)</span><br><span class="line">[0.870s][info   ][gc,heap     ] GC(18)      Free:       16M (2%)           16M (2%)           16M (2%)          558M (54%)         586M (57%)          16M (2%)</span><br><span class="line">[0.870s][info   ][gc,heap     ] GC(18)      Used:     1008M (98%)        1008M (98%)        1008M (98%)         466M (46%)        1008M (98%)         438M (43%)</span><br><span class="line">[0.870s][info   ][gc,heap     ] GC(18)      Live:         -               333M (33%)         333M (33%)         333M (33%)            -                  -</span><br><span class="line">[0.870s][info   ][gc,heap     ] GC(18) Allocated:         -                 0M (0%)            0M (0%)           91M (9%)             -                  -</span><br><span class="line">[0.870s][info   ][gc,heap     ] GC(18)   Garbage:         -               674M (66%)         674M (66%)          40M (4%)             -                  -</span><br><span class="line">[0.870s][info   ][gc,heap     ] GC(18) Reclaimed:         -                  -                 0M (0%)          633M (62%)            -                  -</span><br><span class="line">[0.870s][info   ][gc          ] GC(18) Garbage Collection (Allocation Stall) 1008M(98%)-&gt;466M(46%)</span><br><span class="line">[0.901s][info   ][gc,start    ] GC(19) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.902s][info   ][gc,ref      ] GC(19) Clearing All SoftReferences</span><br><span class="line">[0.902s][info   ][gc,task     ] GC(19) Using 2 workers</span><br><span class="line">[0.902s][info   ][gc,phases   ] GC(19) Pause Mark Start 0.004ms</span><br><span class="line">[0.905s][info   ][gc,phases   ] GC(19) Concurrent Mark 2.959ms</span><br><span class="line">[0.905s][info   ][gc,phases   ] GC(19) Pause Mark End 0.006ms</span><br><span class="line">[0.905s][info   ][gc,phases   ] GC(19) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.905s][info   ][gc,phases   ] GC(19) Concurrent Process Non-Strong References 0.261ms</span><br><span class="line">[0.905s][info   ][gc,phases   ] GC(19) Concurrent Reset Relocation Set 0.007ms</span><br><span class="line">[0.907s][info   ][gc,phases   ] GC(19) Concurrent Select Relocation Set 1.605ms</span><br><span class="line">[0.907s][info   ][gc,phases   ] GC(19) Pause Relocate Start 0.005ms</span><br><span class="line">[0.907s][info   ][gc          ] Allocation Stall (main) 5.839ms</span><br><span class="line">[0.914s][info   ][gc,phases   ] GC(19) Concurrent Relocate 7.134ms</span><br><span class="line">[0.914s][info   ][gc,load     ] GC(19) Load: 3.45/3.79/4.40</span><br><span class="line">[0.914s][info   ][gc,mmu      ] GC(19) MMU: 2ms/99.3%, 5ms/99.6%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/99.9%</span><br><span class="line">[0.914s][info   ][gc,marking  ] GC(19) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.914s][info   ][gc,marking  ] GC(19) Mark Stack Usage: 32M</span><br><span class="line">[0.914s][info   ][gc,nmethod  ] GC(19) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.914s][info   ][gc,metaspace] GC(19) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.914s][info   ][gc,ref      ] GC(19) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.914s][info   ][gc,ref      ] GC(19) Weak: 23 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.914s][info   ][gc,ref      ] GC(19) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.914s][info   ][gc,ref      ] GC(19) Phantom: 1 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.914s][info   ][gc,reloc    ] GC(19) Small Pages: 204 / 408M, Empty: 0M, Relocated: 101M, In-Place: 0</span><br><span class="line">[0.914s][info   ][gc,reloc    ] GC(19) Medium Pages: 19 / 608M, Empty: 0M, Relocated: 193M, In-Place: 1</span><br><span class="line">[0.914s][info   ][gc,reloc    ] GC(19) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.914s][info   ][gc,reloc    ] GC(19) Forwarding Usage: 0M</span><br><span class="line">[0.914s][info   ][gc,heap     ] GC(19) Min Capacity: 1024M(100%)</span><br><span class="line">[0.914s][info   ][gc,heap     ] GC(19) Max Capacity: 1024M(100%)</span><br><span class="line">[0.914s][info   ][gc,heap     ] GC(19) Soft Max Capacity: 1024M(100%)</span><br><span class="line">[0.914s][info   ][gc,heap     ] GC(19)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.914s][info   ][gc,heap     ] GC(19)  Capacity:     1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)</span><br><span class="line">[0.914s][info   ][gc,heap     ] GC(19)      Free:        8M (1%)            8M (1%)            8M (1%)          512M (50%)         512M (50%)           6M (1%)</span><br><span class="line">[0.914s][info   ][gc,heap     ] GC(19)      Used:     1016M (99%)        1016M (99%)        1016M (99%)         512M (50%)        1018M (99%)         512M (50%)</span><br><span class="line">[0.914s][info   ][gc,heap     ] GC(19)      Live:         -               341M (33%)         341M (33%)         341M (33%)            -                  -</span><br><span class="line">[0.914s][info   ][gc,heap     ] GC(19) Allocated:         -                 0M (0%)            0M (0%)          103M (10%)            -                  -</span><br><span class="line">[0.914s][info   ][gc,heap     ] GC(19)   Garbage:         -               674M (66%)         674M (66%)          66M (7%)             -                  -</span><br><span class="line">[0.914s][info   ][gc,heap     ] GC(19) Reclaimed:         -                  -                 0M (0%)          607M (59%)            -                  -</span><br><span class="line">[0.914s][info   ][gc          ] GC(19) Garbage Collection (Allocation Stall) 1016M(99%)-&gt;512M(50%)</span><br><span class="line">[0.920s][info   ][gc,start    ] GC(20) Garbage Collection (Allocation Rate)</span><br><span class="line">[0.920s][info   ][gc,task     ] GC(20) Using 2 workers</span><br><span class="line">[0.920s][info   ][gc,phases   ] GC(20) Pause Mark Start 0.003ms</span><br><span class="line">[0.924s][info   ][gc,phases   ] GC(20) Concurrent Mark 4.449ms</span><br><span class="line">[0.925s][info   ][gc,phases   ] GC(20) Pause Mark End 0.008ms</span><br><span class="line">[0.925s][info   ][gc,phases   ] GC(20) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.925s][info   ][gc,phases   ] GC(20) Concurrent Process Non-Strong References 0.308ms</span><br><span class="line">[0.925s][info   ][gc,phases   ] GC(20) Concurrent Reset Relocation Set 0.007ms</span><br><span class="line">[0.926s][info   ][gc,phases   ] GC(20) Concurrent Select Relocation Set 1.432ms</span><br><span class="line">[0.927s][info   ][gc,phases   ] GC(20) Pause Relocate Start 0.005ms</span><br><span class="line">[0.929s][info   ][gc,phases   ] GC(20) Concurrent Relocate 2.234ms</span><br><span class="line">[0.929s][info   ][gc,load     ] GC(20) Load: 3.45/3.79/4.40</span><br><span class="line">[0.929s][info   ][gc,mmu      ] GC(20) MMU: 2ms/99.3%, 5ms/99.6%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/99.9%</span><br><span class="line">[0.929s][info   ][gc,marking  ] GC(20) Mark: 2 stripe(s), 2 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.929s][info   ][gc,marking  ] GC(20) Mark Stack Usage: 32M</span><br><span class="line">[0.929s][info   ][gc,nmethod  ] GC(20) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.929s][info   ][gc,metaspace] GC(20) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.929s][info   ][gc,ref      ] GC(20) Soft: 3 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.929s][info   ][gc,ref      ] GC(20) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.929s][info   ][gc,ref      ] GC(20) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.929s][info   ][gc,ref      ] GC(20) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.929s][info   ][gc,reloc    ] GC(20) Small Pages: 104 / 208M, Empty: 0M, Relocated: 34M, In-Place: 0</span><br><span class="line">[0.929s][info   ][gc,reloc    ] GC(20) Medium Pages: 13 / 416M, Empty: 0M, Relocated: 77M, In-Place: 0</span><br><span class="line">[0.929s][info   ][gc,reloc    ] GC(20) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.929s][info   ][gc,reloc    ] GC(20) Forwarding Usage: 0M</span><br><span class="line">[0.929s][info   ][gc,heap     ] GC(20) Min Capacity: 1024M(100%)</span><br><span class="line">[0.929s][info   ][gc,heap     ] GC(20) Max Capacity: 1024M(100%)</span><br><span class="line">[0.929s][info   ][gc,heap     ] GC(20) Soft Max Capacity: 1024M(100%)</span><br><span class="line">[0.929s][info   ][gc,heap     ] GC(20)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.929s][info   ][gc,heap     ] GC(20)  Capacity:     1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)</span><br><span class="line">[0.929s][info   ][gc,heap     ] GC(20)      Free:      400M (39%)         350M (34%)         312M (30%)         502M (49%)         502M (49%)         280M (27%)</span><br><span class="line">[0.929s][info   ][gc,heap     ] GC(20)      Used:      624M (61%)         674M (66%)         712M (70%)         522M (51%)         744M (73%)         522M (51%)</span><br><span class="line">[0.929s][info   ][gc,heap     ] GC(20)      Live:         -               322M (31%)         322M (31%)         322M (31%)            -                  -</span><br><span class="line">[0.929s][info   ][gc,heap     ] GC(20) Allocated:         -                50M (5%)           88M (9%)           99M (10%)            -                  -</span><br><span class="line">[0.929s][info   ][gc,heap     ] GC(20)   Garbage:         -               301M (29%)         301M (29%)          99M (10%)            -                  -</span><br><span class="line">[0.929s][info   ][gc,heap     ] GC(20) Reclaimed:         -                  -                 0M (0%)          201M (20%)            -                  -</span><br><span class="line">[0.929s][info   ][gc          ] GC(20) Garbage Collection (Allocation Rate) 624M(61%)-&gt;522M(51%)</span><br><span class="line">[0.959s][info   ][gc,start    ] GC(21) Garbage Collection (Allocation Stall)</span><br><span class="line">[0.959s][info   ][gc,ref      ] GC(21) Clearing All SoftReferences</span><br><span class="line">[0.959s][info   ][gc,task     ] GC(21) Using 2 workers</span><br><span class="line">[0.959s][info   ][gc,phases   ] GC(21) Pause Mark Start 0.007ms</span><br><span class="line">[0.962s][info   ][gc,phases   ] GC(21) Concurrent Mark 2.826ms</span><br><span class="line">[0.962s][info   ][gc,phases   ] GC(21) Pause Mark End 0.005ms</span><br><span class="line">[0.962s][info   ][gc,phases   ] GC(21) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.963s][info   ][gc,phases   ] GC(21) Concurrent Process Non-Strong References 0.229ms</span><br><span class="line">[0.963s][info   ][gc,phases   ] GC(21) Concurrent Reset Relocation Set 0.003ms</span><br><span class="line">[0.964s][info   ][gc,phases   ] GC(21) Concurrent Select Relocation Set 1.519ms</span><br><span class="line">[0.964s][info   ][gc,phases   ] GC(21) Pause Relocate Start 0.002ms</span><br><span class="line">[0.965s][info   ][gc          ] Allocation Stall (main) 5.619ms</span><br><span class="line">[0.971s][info   ][gc,phases   ] GC(21) Concurrent Relocate 7.294ms</span><br><span class="line">[0.972s][info   ][gc,load     ] GC(21) Load: 3.45/3.79/4.40</span><br><span class="line">[0.972s][info   ][gc,mmu      ] GC(21) MMU: 2ms/99.3%, 5ms/99.6%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/99.9%</span><br><span class="line">[0.972s][info   ][gc,marking  ] GC(21) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.972s][info   ][gc,marking  ] GC(21) Mark Stack Usage: 32M</span><br><span class="line">[0.972s][info   ][gc,nmethod  ] GC(21) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[0.972s][info   ][gc,metaspace] GC(21) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.972s][info   ][gc,ref      ] GC(21) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.972s][info   ][gc,ref      ] GC(21) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.972s][info   ][gc,ref      ] GC(21) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.972s][info   ][gc,ref      ] GC(21) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.972s][info   ][gc,reloc    ] GC(21) Small Pages: 203 / 406M, Empty: 4M, Relocated: 104M, In-Place: 0</span><br><span class="line">[0.972s][info   ][gc,reloc    ] GC(21) Medium Pages: 19 / 608M, Empty: 0M, Relocated: 195M, In-Place: 1</span><br><span class="line">[0.972s][info   ][gc,reloc    ] GC(21) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.972s][info   ][gc,reloc    ] GC(21) Forwarding Usage: 0M</span><br><span class="line">[0.972s][info   ][gc,heap     ] GC(21) Min Capacity: 1024M(100%)</span><br><span class="line">[0.972s][info   ][gc,heap     ] GC(21) Max Capacity: 1024M(100%)</span><br><span class="line">[0.972s][info   ][gc,heap     ] GC(21) Soft Max Capacity: 1024M(100%)</span><br><span class="line">[0.972s][info   ][gc,heap     ] GC(21)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.972s][info   ][gc,heap     ] GC(21)  Capacity:     1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)</span><br><span class="line">[0.972s][info   ][gc,heap     ] GC(21)      Free:       10M (1%)           10M (1%)           14M (1%)          546M (53%)         546M (53%)          10M (1%)</span><br><span class="line">[0.972s][info   ][gc,heap     ] GC(21)      Used:     1014M (99%)        1014M (99%)        1010M (99%)         478M (47%)        1014M (99%)         478M (47%)</span><br><span class="line">[0.972s][info   ][gc,heap     ] GC(21)      Live:         -               327M (32%)         327M (32%)         327M (32%)            -                  -</span><br><span class="line">[0.972s][info   ][gc,heap     ] GC(21) Allocated:         -                 0M (0%)            0M (0%)           99M (10%)            -                  -</span><br><span class="line">[0.972s][info   ][gc,heap     ] GC(21)   Garbage:         -               686M (67%)         682M (67%)          50M (5%)             -                  -</span><br><span class="line">[0.972s][info   ][gc,heap     ] GC(21) Reclaimed:         -                  -                 4M (0%)          635M (62%)            -                  -</span><br><span class="line">[0.972s][info   ][gc          ] GC(21) Garbage Collection (Allocation Stall) 1014M(99%)-&gt;478M(47%)</span><br><span class="line">[1.007s][info   ][gc,start    ] GC(22) Garbage Collection (Allocation Stall)</span><br><span class="line">[1.007s][info   ][gc,ref      ] GC(22) Clearing All SoftReferences</span><br><span class="line">[1.007s][info   ][gc,task     ] GC(22) Using 2 workers</span><br><span class="line">[1.007s][info   ][gc,phases   ] GC(22) Pause Mark Start 0.004ms</span><br><span class="line">[1.010s][info   ][gc,phases   ] GC(22) Concurrent Mark 3.220ms</span><br><span class="line">[1.011s][info   ][gc,phases   ] GC(22) Pause Mark End 0.005ms</span><br><span class="line">[1.011s][info   ][gc,phases   ] GC(22) Concurrent Mark Free 0.000ms</span><br><span class="line">[1.011s][info   ][gc,phases   ] GC(22) Concurrent Process Non-Strong References 0.176ms</span><br><span class="line">[1.011s][info   ][gc,phases   ] GC(22) Concurrent Reset Relocation Set 0.007ms</span><br><span class="line">[1.012s][info   ][gc,phases   ] GC(22) Concurrent Select Relocation Set 1.408ms</span><br><span class="line">[1.012s][info   ][gc,phases   ] GC(22) Pause Relocate Start 0.005ms</span><br><span class="line">[1.014s][info   ][gc          ] Allocation Stall (main) 7.377ms</span><br><span class="line">[1.021s][info   ][gc,phases   ] GC(22) Concurrent Relocate 8.435ms</span><br><span class="line">[1.021s][info   ][gc,load     ] GC(22) Load: 3.45/3.79/4.40</span><br><span class="line">[1.021s][info   ][gc,mmu      ] GC(22) MMU: 2ms/99.3%, 5ms/99.6%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/99.9%</span><br><span class="line">[1.021s][info   ][gc,marking  ] GC(22) Mark: 2 stripe(s), 1 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[1.021s][info   ][gc,marking  ] GC(22) Mark Stack Usage: 32M</span><br><span class="line">[1.021s][info   ][gc,nmethod  ] GC(22) NMethods: 121 registered, 0 unregistered</span><br><span class="line">[1.021s][info   ][gc,metaspace] GC(22) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[1.021s][info   ][gc,ref      ] GC(22) Soft: 3 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[1.021s][info   ][gc,ref      ] GC(22) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[1.021s][info   ][gc,ref      ] GC(22) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[1.021s][info   ][gc,ref      ] GC(22) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[1.021s][info   ][gc,reloc    ] GC(22) Small Pages: 207 / 414M, Empty: 2M, Relocated: 103M, In-Place: 0</span><br><span class="line">[1.021s][info   ][gc,reloc    ] GC(22) Medium Pages: 19 / 608M, Empty: 0M, Relocated: 192M, In-Place: 1</span><br><span class="line">[1.021s][info   ][gc,reloc    ] GC(22) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[1.021s][info   ][gc,reloc    ] GC(22) Forwarding Usage: 0M</span><br><span class="line">[1.021s][info   ][gc,heap     ] GC(22) Min Capacity: 1024M(100%)</span><br><span class="line">[1.021s][info   ][gc,heap     ] GC(22) Max Capacity: 1024M(100%)</span><br><span class="line">[1.021s][info   ][gc,heap     ] GC(22) Soft Max Capacity: 1024M(100%)</span><br><span class="line">[1.021s][info   ][gc,heap     ] GC(22)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[1.021s][info   ][gc,heap     ] GC(22)  Capacity:     1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)       1024M (100%)</span><br><span class="line">[1.021s][info   ][gc,heap     ] GC(22)      Free:        2M (0%)            2M (0%)            4M (0%)          516M (50%)         518M (51%)           2M (0%)</span><br><span class="line">[1.021s][info   ][gc,heap     ] GC(22)      Used:     1022M (100%)       1022M (100%)       1020M (100%)        508M (50%)        1022M (100%)        506M (49%)</span><br><span class="line">[1.021s][info   ][gc,heap     ] GC(22)      Live:         -               334M (33%)         334M (33%)         334M (33%)            -                  -</span><br><span class="line">[1.021s][info   ][gc,heap     ] GC(22) Allocated:         -                 0M (0%)            0M (0%)          101M (10%)            -                  -</span><br><span class="line">[1.021s][info   ][gc,heap     ] GC(22)   Garbage:         -               687M (67%)         685M (67%)          71M (7%)             -                  -</span><br><span class="line">[1.021s][info   ][gc,heap     ] GC(22) Reclaimed:         -                  -                 2M (0%)          615M (60%)            -                  -</span><br><span class="line">[1.021s][info   ][gc          ] GC(22) Garbage Collection (Allocation Stall) 1022M(100%)-&gt;508M(50%)</span><br><span class="line">counter:57527</span><br><span class="line">[1.029s][info   ][gc,heap,exit] Heap</span><br><span class="line">[1.029s][info   ][gc,heap,exit]  ZHeap           used 526M, capacity 1024M, max capacity 1024M</span><br><span class="line">[1.029s][info   ][gc,heap,exit]  Metaspace       used 278K, committed 512K, reserved 1114112K</span><br><span class="line">[1.029s][info   ][gc,heap,exit]   class space    used 9K, committed 128K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>再试试2g内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+UseZGC -Xms2g -Xmx2g -XX:+PrintGCDetails -Xlog:gc\*:file=gc.log:time,uptime,level,tags GCLogAnalysis</span><br></pre></td></tr></table></figure>

<p>结果是9次GC，生成了54000多个对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0.002s][warning][gc] -XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.</span><br><span class="line">[0.005s][info   ][gc,init] Initializing The Z Garbage Collector</span><br><span class="line">[0.005s][info   ][gc,init] Version: 19.0.2+7-44 (release)</span><br><span class="line">[0.005s][info   ][gc,init] NUMA Support: Disabled</span><br><span class="line">[0.005s][info   ][gc,init] CPUs: 8 total, 8 available</span><br><span class="line">[0.005s][info   ][gc,init] Memory: 16384M</span><br><span class="line">[0.005s][info   ][gc,init] Large Page Support: Disabled</span><br><span class="line">[0.005s][info   ][gc,init] GC Workers: 2 (dynamic)</span><br><span class="line">[0.005s][info   ][gc,init] Address Space Type: Contiguous/Unrestricted/Complete</span><br><span class="line">[0.005s][info   ][gc,init] Address Space Size: 32768M x 3 = 98304M</span><br><span class="line">[0.005s][info   ][gc,init] Min Capacity: 2048M</span><br><span class="line">[0.006s][info   ][gc,init] Initial Capacity: 2048M</span><br><span class="line">[0.006s][info   ][gc,init] Max Capacity: 2048M</span><br><span class="line">[0.006s][info   ][gc,init] Medium Page Size: 32M</span><br><span class="line">[0.006s][info   ][gc,init] Pre-touch: Disabled</span><br><span class="line">[0.006s][info   ][gc,init] Uncommit: Implicitly Disabled (-Xms equals -Xmx)</span><br><span class="line">[0.006s][info   ][gc,init] Runtime Workers: 5</span><br><span class="line">[0.006s][info   ][gc     ] Using The Z Garbage Collector</span><br><span class="line">[0.006s][info   ][gc,metaspace] CDS archive(s) mapped at: [0x0000000800000000-0x0000000800c44000-0x0000000800c44000), size 12861440, SharedBaseAddress: 0x0000000800000000, ArchiveRelocationMode: 0.</span><br><span class="line">[0.006s][info   ][gc,metaspace] Compressed class space mapped at: 0x0000000801000000-0x0000000841000000, reserved size: 1073741824</span><br><span class="line">[0.006s][info   ][gc,metaspace] Narrow klass base: 0x0000000800000000, Narrow klass shift: 0, Narrow klass range: 0x100000000</span><br><span class="line">gc...</span><br><span class="line">[0.115s][info   ][gc,start    ] GC(0) Garbage Collection (Warmup)</span><br><span class="line">[0.115s][info   ][gc,task     ] GC(0) Using 2 workers</span><br><span class="line">[0.115s][info   ][gc,phases   ] GC(0) Pause Mark Start 0.005ms</span><br><span class="line">[0.120s][info   ][gc,phases   ] GC(0) Concurrent Mark 5.021ms</span><br><span class="line">[0.121s][info   ][gc,phases   ] GC(0) Pause Mark End 0.008ms</span><br><span class="line">[0.121s][info   ][gc,phases   ] GC(0) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.121s][info   ][gc,phases   ] GC(0) Concurrent Process Non-Strong References 0.291ms</span><br><span class="line">[0.121s][info   ][gc,phases   ] GC(0) Concurrent Reset Relocation Set 0.000ms</span><br><span class="line">[0.127s][info   ][gc,phases   ] GC(0) Concurrent Select Relocation Set 5.404ms</span><br><span class="line">[0.127s][info   ][gc,phases   ] GC(0) Pause Relocate Start 0.012ms</span><br><span class="line">[0.138s][info   ][gc,phases   ] GC(0) Concurrent Relocate 11.631ms</span><br><span class="line">[0.139s][info   ][gc,load     ] GC(0) Load: 5.25/4.13/4.45</span><br><span class="line">[0.139s][info   ][gc,mmu      ] GC(0) MMU: 2ms/99.4%, 5ms/99.8%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/100.0%</span><br><span class="line">[0.139s][info   ][gc,marking  ] GC(0) Mark: 2 stripe(s), 2 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.139s][info   ][gc,marking  ] GC(0) Mark Stack Usage: 32M</span><br><span class="line">[0.139s][info   ][gc,nmethod  ] GC(0) NMethods: 118 registered, 0 unregistered</span><br><span class="line">[0.139s][info   ][gc,metaspace] GC(0) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.139s][info   ][gc,ref      ] GC(0) Soft: 5 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.139s][info   ][gc,ref      ] GC(0) Weak: 26 encountered, 19 discovered, 3 enqueued</span><br><span class="line">[0.139s][info   ][gc,ref      ] GC(0) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.139s][info   ][gc,ref      ] GC(0) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.139s][info   ][gc,reloc    ] GC(0) Small Pages: 155 / 310M, Empty: 2M, Relocated: 60M, In-Place: 0</span><br><span class="line">[0.139s][info   ][gc,reloc    ] GC(0) Medium Pages: 12 / 384M, Empty: 0M, Relocated: 133M, In-Place: 0</span><br><span class="line">[0.139s][info   ][gc,reloc    ] GC(0) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.139s][info   ][gc,reloc    ] GC(0) Forwarding Usage: 0M</span><br><span class="line">[0.139s][info   ][gc,heap     ] GC(0) Min Capacity: 2048M(100%)</span><br><span class="line">[0.139s][info   ][gc,heap     ] GC(0) Max Capacity: 2048M(100%)</span><br><span class="line">[0.139s][info   ][gc,heap     ] GC(0) Soft Max Capacity: 2048M(100%)</span><br><span class="line">[0.139s][info   ][gc,heap     ] GC(0)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.139s][info   ][gc,heap     ] GC(0)  Capacity:     2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)</span><br><span class="line">[0.139s][info   ][gc,heap     ] GC(0)      Free:     1354M (66%)        1308M (64%)        1262M (62%)        1664M (81%)        1664M (81%)        1226M (60%)</span><br><span class="line">[0.139s][info   ][gc,heap     ] GC(0)      Used:      694M (34%)         740M (36%)         786M (38%)         384M (19%)         822M (40%)         384M (19%)</span><br><span class="line">[0.139s][info   ][gc,heap     ] GC(0)      Live:         -               195M (10%)         195M (10%)         195M (10%)            -                  -</span><br><span class="line">[0.139s][info   ][gc,heap     ] GC(0) Allocated:         -                46M (2%)           94M (5%)          155M (8%)             -                  -</span><br><span class="line">[0.139s][info   ][gc,heap     ] GC(0)   Garbage:         -               498M (24%)         496M (24%)          32M (2%)             -                  -</span><br><span class="line">[0.139s][info   ][gc,heap     ] GC(0) Reclaimed:         -                  -                 2M (0%)          465M (23%)            -                  -</span><br><span class="line">[0.139s][info   ][gc          ] GC(0) Garbage Collection (Warmup) 694M(34%)-&gt;384M(19%)</span><br><span class="line">[0.218s][info   ][gc,start    ] GC(1) Garbage Collection (Warmup)</span><br><span class="line">[0.218s][info   ][gc,task     ] GC(1) Using 2 workers</span><br><span class="line">[0.218s][info   ][gc,phases   ] GC(1) Pause Mark Start 0.006ms</span><br><span class="line">[0.222s][info   ][gc,phases   ] GC(1) Concurrent Mark 3.648ms</span><br><span class="line">[0.222s][info   ][gc,phases   ] GC(1) Pause Mark End 0.007ms</span><br><span class="line">[0.222s][info   ][gc,phases   ] GC(1) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.223s][info   ][gc,phases   ] GC(1) Concurrent Process Non-Strong References 0.250ms</span><br><span class="line">[0.223s][info   ][gc,phases   ] GC(1) Concurrent Reset Relocation Set 0.005ms</span><br><span class="line">[0.225s][info   ][gc,phases   ] GC(1) Concurrent Select Relocation Set 2.101ms</span><br><span class="line">[0.225s][info   ][gc,phases   ] GC(1) Pause Relocate Start 0.007ms</span><br><span class="line">[0.242s][info   ][gc,phases   ] GC(1) Concurrent Relocate 16.905ms</span><br><span class="line">[0.242s][info   ][gc,load     ] GC(1) Load: 5.25/4.13/4.45</span><br><span class="line">[0.242s][info   ][gc,mmu      ] GC(1) MMU: 2ms/99.4%, 5ms/99.7%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/100.0%</span><br><span class="line">[0.242s][info   ][gc,marking  ] GC(1) Mark: 2 stripe(s), 2 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.242s][info   ][gc,marking  ] GC(1) Mark Stack Usage: 32M</span><br><span class="line">[0.242s][info   ][gc,nmethod  ] GC(1) NMethods: 122 registered, 0 unregistered</span><br><span class="line">[0.242s][info   ][gc,metaspace] GC(1) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.242s][info   ][gc,ref      ] GC(1) Soft: 5 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.242s][info   ][gc,ref      ] GC(1) Weak: 23 encountered, 3 discovered, 0 enqueued</span><br><span class="line">[0.242s][info   ][gc,ref      ] GC(1) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.242s][info   ][gc,ref      ] GC(1) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.242s][info   ][gc,reloc    ] GC(1) Small Pages: 267 / 534M, Empty: 10M, Relocated: 90M, In-Place: 0</span><br><span class="line">[0.242s][info   ][gc,reloc    ] GC(1) Medium Pages: 24 / 768M, Empty: 0M, Relocated: 195M, In-Place: 0</span><br><span class="line">[0.242s][info   ][gc,reloc    ] GC(1) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.242s][info   ][gc,reloc    ] GC(1) Forwarding Usage: 0M</span><br><span class="line">[0.242s][info   ][gc,heap     ] GC(1) Min Capacity: 2048M(100%)</span><br><span class="line">[0.242s][info   ][gc,heap     ] GC(1) Max Capacity: 2048M(100%)</span><br><span class="line">[0.242s][info   ][gc,heap     ] GC(1) Soft Max Capacity: 2048M(100%)</span><br><span class="line">[0.242s][info   ][gc,heap     ] GC(1)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.242s][info   ][gc,heap     ] GC(1)  Capacity:     2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)</span><br><span class="line">[0.242s][info   ][gc,heap     ] GC(1)      Free:      746M (36%)         698M (34%)         698M (34%)        1474M (72%)        1474M (72%)         666M (33%)</span><br><span class="line">[0.242s][info   ][gc,heap     ] GC(1)      Used:     1302M (64%)        1350M (66%)        1350M (66%)         574M (28%)        1382M (67%)         574M (28%)</span><br><span class="line">[0.242s][info   ][gc,heap     ] GC(1)      Live:         -               302M (15%)         302M (15%)         302M (15%)            -                  -</span><br><span class="line">[0.242s][info   ][gc,heap     ] GC(1) Allocated:         -                48M (2%)           58M (3%)          219M (11%)            -                  -</span><br><span class="line">[0.242s][info   ][gc,heap     ] GC(1)   Garbage:         -               999M (49%)         989M (48%)          51M (3%)             -                  -</span><br><span class="line">[0.242s][info   ][gc,heap     ] GC(1) Reclaimed:         -                  -                10M (0%)          947M (46%)            -                  -</span><br><span class="line">[0.242s][info   ][gc          ] GC(1) Garbage Collection (Warmup) 1302M(64%)-&gt;574M(28%)</span><br><span class="line">[0.318s][info   ][gc,start    ] GC(2) Garbage Collection (Warmup)</span><br><span class="line">[0.318s][info   ][gc,task     ] GC(2) Using 2 workers</span><br><span class="line">[0.318s][info   ][gc,phases   ] GC(2) Pause Mark Start 0.006ms</span><br><span class="line">[0.324s][info   ][gc,phases   ] GC(2) Concurrent Mark 5.506ms</span><br><span class="line">[0.324s][info   ][gc,phases   ] GC(2) Pause Mark End 0.006ms</span><br><span class="line">[0.324s][info   ][gc,phases   ] GC(2) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.328s][info   ][gc,phases   ] GC(2) Concurrent Process Non-Strong References 4.195ms</span><br><span class="line">[0.328s][info   ][gc,phases   ] GC(2) Concurrent Reset Relocation Set 0.010ms</span><br><span class="line">[0.330s][info   ][gc,phases   ] GC(2) Concurrent Select Relocation Set 1.556ms</span><br><span class="line">[0.330s][info   ][gc,phases   ] GC(2) Pause Relocate Start 0.005ms</span><br><span class="line">[0.343s][info   ][gc,phases   ] GC(2) Concurrent Relocate 12.763ms</span><br><span class="line">[0.343s][info   ][gc,load     ] GC(2) Load: 5.25/4.13/4.45</span><br><span class="line">[0.343s][info   ][gc,mmu      ] GC(2) MMU: 2ms/99.4%, 5ms/99.7%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/100.0%</span><br><span class="line">[0.343s][info   ][gc,marking  ] GC(2) Mark: 2 stripe(s), 2 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.343s][info   ][gc,marking  ] GC(2) Mark Stack Usage: 32M</span><br><span class="line">[0.343s][info   ][gc,nmethod  ] GC(2) NMethods: 127 registered, 0 unregistered</span><br><span class="line">[0.343s][info   ][gc,metaspace] GC(2) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.343s][info   ][gc,ref      ] GC(2) Soft: 5 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.343s][info   ][gc,ref      ] GC(2) Weak: 23 encountered, 17 discovered, 0 enqueued</span><br><span class="line">[0.343s][info   ][gc,ref      ] GC(2) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.343s][info   ][gc,ref      ] GC(2) Phantom: 1 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.343s][info   ][gc,reloc    ] GC(2) Small Pages: 318 / 636M, Empty: 20M, Relocated: 102M, In-Place: 0</span><br><span class="line">[0.343s][info   ][gc,reloc    ] GC(2) Medium Pages: 30 / 960M, Empty: 32M, Relocated: 217M, In-Place: 0</span><br><span class="line">[0.343s][info   ][gc,reloc    ] GC(2) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.343s][info   ][gc,reloc    ] GC(2) Forwarding Usage: 0M</span><br><span class="line">[0.343s][info   ][gc,heap     ] GC(2) Min Capacity: 2048M(100%)</span><br><span class="line">[0.343s][info   ][gc,heap     ] GC(2) Max Capacity: 2048M(100%)</span><br><span class="line">[0.343s][info   ][gc,heap     ] GC(2) Soft Max Capacity: 2048M(100%)</span><br><span class="line">[0.343s][info   ][gc,heap     ] GC(2)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.343s][info   ][gc,heap     ] GC(2)  Capacity:     2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)</span><br><span class="line">[0.343s][info   ][gc,heap     ] GC(2)      Free:      452M (22%)         404M (20%)         402M (20%)        1480M (72%)        1482M (72%)         352M (17%)</span><br><span class="line">[0.343s][info   ][gc,heap     ] GC(2)      Used:     1596M (78%)        1644M (80%)        1646M (80%)         568M (28%)        1696M (83%)         566M (28%)</span><br><span class="line">[0.343s][info   ][gc,heap     ] GC(2)      Live:         -               321M (16%)         321M (16%)         321M (16%)            -                  -</span><br><span class="line">[0.343s][info   ][gc,heap     ] GC(2) Allocated:         -                48M (2%)          102M (5%)          233M (11%)            -                  -</span><br><span class="line">[0.343s][info   ][gc,heap     ] GC(2)   Garbage:         -              1274M (62%)        1222M (60%)          12M (1%)             -                  -</span><br><span class="line">[0.344s][info   ][gc,heap     ] GC(2) Reclaimed:         -                  -                52M (3%)         1261M (62%)            -                  -</span><br><span class="line">[0.344s][info   ][gc          ] GC(2) Garbage Collection (Warmup) 1596M(78%)-&gt;568M(28%)</span><br><span class="line">[0.418s][info   ][gc,start    ] GC(3) Garbage Collection (Allocation Rate)</span><br><span class="line">[0.418s][info   ][gc,task     ] GC(3) Using 2 workers</span><br><span class="line">[0.418s][info   ][gc,phases   ] GC(3) Pause Mark Start 0.004ms</span><br><span class="line">[0.424s][info   ][gc,phases   ] GC(3) Concurrent Mark 5.888ms</span><br><span class="line">[0.424s][info   ][gc,phases   ] GC(3) Pause Mark End 0.006ms</span><br><span class="line">[0.424s][info   ][gc,phases   ] GC(3) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.426s][info   ][gc,phases   ] GC(3) Concurrent Process Non-Strong References 1.397ms</span><br><span class="line">[0.426s][info   ][gc,phases   ] GC(3) Concurrent Reset Relocation Set 0.010ms</span><br><span class="line">[0.427s][info   ][gc,phases   ] GC(3) Concurrent Select Relocation Set 1.562ms</span><br><span class="line">[0.428s][info   ][gc,phases   ] GC(3) Pause Relocate Start 0.003ms</span><br><span class="line">[0.457s][info   ][gc,phases   ] GC(3) Concurrent Relocate 29.631ms</span><br><span class="line">[0.458s][info   ][gc,load     ] GC(3) Load: 5.25/4.13/4.45</span><br><span class="line">[0.458s][info   ][gc,mmu      ] GC(3) MMU: 2ms/99.4%, 5ms/99.7%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/100.0%</span><br><span class="line">[0.458s][info   ][gc,marking  ] GC(3) Mark: 2 stripe(s), 2 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.458s][info   ][gc,marking  ] GC(3) Mark Stack Usage: 32M</span><br><span class="line">[0.458s][info   ][gc,nmethod  ] GC(3) NMethods: 127 registered, 0 unregistered</span><br><span class="line">[0.458s][info   ][gc,metaspace] GC(3) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.458s][info   ][gc,ref      ] GC(3) Soft: 5 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.458s][info   ][gc,ref      ] GC(3) Weak: 23 encountered, 3 discovered, 0 enqueued</span><br><span class="line">[0.458s][info   ][gc,ref      ] GC(3) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.458s][info   ][gc,ref      ] GC(3) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.458s][info   ][gc,reloc    ] GC(3) Small Pages: 379 / 758M, Empty: 44M, Relocated: 104M, In-Place: 0</span><br><span class="line">[0.458s][info   ][gc,reloc    ] GC(3) Medium Pages: 33 / 1056M, Empty: 0M, Relocated: 217M, In-Place: 0</span><br><span class="line">[0.458s][info   ][gc,reloc    ] GC(3) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.458s][info   ][gc,reloc    ] GC(3) Forwarding Usage: 0M</span><br><span class="line">[0.458s][info   ][gc,heap     ] GC(3) Min Capacity: 2048M(100%)</span><br><span class="line">[0.458s][info   ][gc,heap     ] GC(3) Max Capacity: 2048M(100%)</span><br><span class="line">[0.458s][info   ][gc,heap     ] GC(3) Soft Max Capacity: 2048M(100%)</span><br><span class="line">[0.458s][info   ][gc,heap     ] GC(3)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.458s][info   ][gc,heap     ] GC(3)  Capacity:     2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)</span><br><span class="line">[0.458s][info   ][gc,heap     ] GC(3)      Free:      234M (11%)         186M (9%)          190M (9%)         1540M (75%)        1570M (77%)         146M (7%)</span><br><span class="line">[0.458s][info   ][gc,heap     ] GC(3)      Used:     1814M (89%)        1862M (91%)        1858M (91%)         508M (25%)        1902M (93%)         478M (23%)</span><br><span class="line">[0.458s][info   ][gc,heap     ] GC(3)      Live:         -               337M (16%)         337M (16%)         337M (16%)            -                  -</span><br><span class="line">[0.458s][info   ][gc,heap     ] GC(3) Allocated:         -                48M (2%)           88M (4%)          141M (7%)             -                  -</span><br><span class="line">[0.458s][info   ][gc,heap     ] GC(3)   Garbage:         -              1476M (72%)        1432M (70%)          28M (1%)             -                  -</span><br><span class="line">[0.459s][info   ][gc,heap     ] GC(3) Reclaimed:         -                  -                44M (2%)         1447M (71%)            -                  -</span><br><span class="line">[0.459s][info   ][gc          ] GC(3) Garbage Collection (Allocation Rate) 1814M(89%)-&gt;508M(25%)</span><br><span class="line">[0.518s][info   ][gc,start    ] GC(4) Garbage Collection (Allocation Rate)</span><br><span class="line">[0.518s][info   ][gc,task     ] GC(4) Using 2 workers</span><br><span class="line">[0.518s][info   ][gc,phases   ] GC(4) Pause Mark Start 0.004ms</span><br><span class="line">[0.523s][info   ][gc,phases   ] GC(4) Concurrent Mark 4.595ms</span><br><span class="line">[0.523s][info   ][gc,phases   ] GC(4) Pause Mark End 0.008ms</span><br><span class="line">[0.523s][info   ][gc,phases   ] GC(4) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.529s][info   ][gc,phases   ] GC(4) Concurrent Process Non-Strong References 5.904ms</span><br><span class="line">[0.529s][info   ][gc,phases   ] GC(4) Concurrent Reset Relocation Set 0.015ms</span><br><span class="line">[0.531s][info   ][gc,phases   ] GC(4) Concurrent Select Relocation Set 1.670ms</span><br><span class="line">[0.531s][info   ][gc,phases   ] GC(4) Pause Relocate Start 0.010ms</span><br><span class="line">[0.540s][info   ][gc,phases   ] GC(4) Concurrent Relocate 9.221ms</span><br><span class="line">[0.540s][info   ][gc,load     ] GC(4) Load: 5.25/4.13/4.45</span><br><span class="line">[0.540s][info   ][gc,mmu      ] GC(4) MMU: 2ms/99.4%, 5ms/99.7%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/100.0%</span><br><span class="line">[0.540s][info   ][gc,marking  ] GC(4) Mark: 2 stripe(s), 3 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.540s][info   ][gc,marking  ] GC(4) Mark Stack Usage: 32M</span><br><span class="line">[0.540s][info   ][gc,nmethod  ] GC(4) NMethods: 128 registered, 0 unregistered</span><br><span class="line">[0.540s][info   ][gc,metaspace] GC(4) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.540s][info   ][gc,ref      ] GC(4) Soft: 5 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.540s][info   ][gc,ref      ] GC(4) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.540s][info   ][gc,ref      ] GC(4) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.540s][info   ][gc,ref      ] GC(4) Phantom: 1 encountered, 1 discovered, 0 enqueued</span><br><span class="line">[0.540s][info   ][gc,reloc    ] GC(4) Small Pages: 292 / 584M, Empty: 12M, Relocated: 108M, In-Place: 0</span><br><span class="line">[0.540s][info   ][gc,reloc    ] GC(4) Medium Pages: 26 / 832M, Empty: 0M, Relocated: 221M, In-Place: 0</span><br><span class="line">[0.541s][info   ][gc,reloc    ] GC(4) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.541s][info   ][gc,reloc    ] GC(4) Forwarding Usage: 0M</span><br><span class="line">[0.541s][info   ][gc,heap     ] GC(4) Min Capacity: 2048M(100%)</span><br><span class="line">[0.541s][info   ][gc,heap     ] GC(4) Max Capacity: 2048M(100%)</span><br><span class="line">[0.541s][info   ][gc,heap     ] GC(4) Soft Max Capacity: 2048M(100%)</span><br><span class="line">[0.541s][info   ][gc,heap     ] GC(4)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.541s][info   ][gc,heap     ] GC(4)  Capacity:     2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)</span><br><span class="line">[0.541s][info   ][gc,heap     ] GC(4)      Free:      632M (31%)         584M (29%)         532M (26%)        1448M (71%)        1448M (71%)         498M (24%)</span><br><span class="line">[0.541s][info   ][gc,heap     ] GC(4)      Used:     1416M (69%)        1464M (71%)        1516M (74%)         600M (29%)        1550M (76%)         600M (29%)</span><br><span class="line">[0.541s][info   ][gc,heap     ] GC(4)      Live:         -               346M (17%)         346M (17%)         346M (17%)            -                  -</span><br><span class="line">[0.541s][info   ][gc,heap     ] GC(4) Allocated:         -                48M (2%)          112M (5%)          229M (11%)            -                  -</span><br><span class="line">[0.541s][info   ][gc,heap     ] GC(4)   Garbage:         -              1069M (52%)        1057M (52%)          23M (1%)             -                  -</span><br><span class="line">[0.541s][info   ][gc,heap     ] GC(4) Reclaimed:         -                  -                12M (1%)         1045M (51%)            -                  -</span><br><span class="line">[0.541s][info   ][gc          ] GC(4) Garbage Collection (Allocation Rate) 1416M(69%)-&gt;600M(29%)</span><br><span class="line">[0.618s][info   ][gc,start    ] GC(5) Garbage Collection (Allocation Rate)</span><br><span class="line">[0.618s][info   ][gc,task     ] GC(5) Using 2 workers</span><br><span class="line">[0.618s][info   ][gc,phases   ] GC(5) Pause Mark Start 0.004ms</span><br><span class="line">[0.623s][info   ][gc,phases   ] GC(5) Concurrent Mark 4.536ms</span><br><span class="line">[0.623s][info   ][gc,phases   ] GC(5) Pause Mark End 0.007ms</span><br><span class="line">[0.623s][info   ][gc,phases   ] GC(5) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.624s][info   ][gc,phases   ] GC(5) Concurrent Process Non-Strong References 0.288ms</span><br><span class="line">[0.624s][info   ][gc,phases   ] GC(5) Concurrent Reset Relocation Set 0.010ms</span><br><span class="line">[0.625s][info   ][gc,phases   ] GC(5) Concurrent Select Relocation Set 1.430ms</span><br><span class="line">[0.625s][info   ][gc,phases   ] GC(5) Pause Relocate Start 0.004ms</span><br><span class="line">[0.633s][info   ][gc,phases   ] GC(5) Concurrent Relocate 7.538ms</span><br><span class="line">[0.633s][info   ][gc,load     ] GC(5) Load: 5.25/4.13/4.45</span><br><span class="line">[0.633s][info   ][gc,mmu      ] GC(5) MMU: 2ms/99.4%, 5ms/99.7%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/100.0%</span><br><span class="line">[0.633s][info   ][gc,marking  ] GC(5) Mark: 2 stripe(s), 2 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.633s][info   ][gc,marking  ] GC(5) Mark Stack Usage: 32M</span><br><span class="line">[0.633s][info   ][gc,nmethod  ] GC(5) NMethods: 128 registered, 0 unregistered</span><br><span class="line">[0.633s][info   ][gc,metaspace] GC(5) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.633s][info   ][gc,ref      ] GC(5) Soft: 5 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.633s][info   ][gc,ref      ] GC(5) Weak: 23 encountered, 16 discovered, 0 enqueued</span><br><span class="line">[0.633s][info   ][gc,ref      ] GC(5) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.633s][info   ][gc,ref      ] GC(5) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.633s][info   ][gc,reloc    ] GC(5) Small Pages: 379 / 758M, Empty: 38M, Relocated: 106M, In-Place: 0</span><br><span class="line">[0.633s][info   ][gc,reloc    ] GC(5) Medium Pages: 34 / 1088M, Empty: 0M, Relocated: 219M, In-Place: 0</span><br><span class="line">[0.633s][info   ][gc,reloc    ] GC(5) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.633s][info   ][gc,reloc    ] GC(5) Forwarding Usage: 0M</span><br><span class="line">[0.633s][info   ][gc,heap     ] GC(5) Min Capacity: 2048M(100%)</span><br><span class="line">[0.633s][info   ][gc,heap     ] GC(5) Max Capacity: 2048M(100%)</span><br><span class="line">[0.633s][info   ][gc,heap     ] GC(5) Soft Max Capacity: 2048M(100%)</span><br><span class="line">[0.633s][info   ][gc,heap     ] GC(5)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.633s][info   ][gc,heap     ] GC(5)  Capacity:     2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)</span><br><span class="line">[0.633s][info   ][gc,heap     ] GC(5)      Free:      202M (10%)         152M (7%)          182M (9%)         1470M (72%)        1496M (73%)         146M (7%)</span><br><span class="line">[0.633s][info   ][gc,heap     ] GC(5)      Used:     1846M (90%)        1896M (93%)        1866M (91%)         578M (28%)        1902M (93%)         552M (27%)</span><br><span class="line">[0.633s][info   ][gc,heap     ] GC(5)      Live:         -               340M (17%)         340M (17%)         340M (17%)            -                  -</span><br><span class="line">[0.633s][info   ][gc,heap     ] GC(5) Allocated:         -                50M (2%)           58M (3%)          207M (10%)            -                  -</span><br><span class="line">[0.633s][info   ][gc,heap     ] GC(5)   Garbage:         -              1505M (74%)        1467M (72%)          29M (1%)             -                  -</span><br><span class="line">[0.633s][info   ][gc,heap     ] GC(5) Reclaimed:         -                  -                38M (2%)         1475M (72%)            -                  -</span><br><span class="line">[0.633s][info   ][gc          ] GC(5) Garbage Collection (Allocation Rate) 1846M(90%)-&gt;578M(28%)</span><br><span class="line">[0.716s][info   ][gc,start    ] GC(6) Garbage Collection (Allocation Rate)</span><br><span class="line">[0.716s][info   ][gc,task     ] GC(6) Using 2 workers</span><br><span class="line">[0.716s][info   ][gc,phases   ] GC(6) Pause Mark Start 0.004ms</span><br><span class="line">[0.731s][info   ][gc,phases   ] GC(6) Concurrent Mark 14.523ms</span><br><span class="line">[0.731s][info   ][gc,phases   ] GC(6) Pause Mark End 0.007ms</span><br><span class="line">[0.731s][info   ][gc,phases   ] GC(6) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.733s][info   ][gc,phases   ] GC(6) Concurrent Process Non-Strong References 1.525ms</span><br><span class="line">[0.733s][info   ][gc,phases   ] GC(6) Concurrent Reset Relocation Set 0.014ms</span><br><span class="line">[0.736s][info   ][gc,phases   ] GC(6) Concurrent Select Relocation Set 2.500ms</span><br><span class="line">[0.736s][info   ][gc,phases   ] GC(6) Pause Relocate Start 0.006ms</span><br><span class="line">[0.780s][info   ][gc,phases   ] GC(6) Concurrent Relocate 44.301ms</span><br><span class="line">[0.780s][info   ][gc,load     ] GC(6) Load: 5.25/4.13/4.45</span><br><span class="line">[0.780s][info   ][gc,mmu      ] GC(6) MMU: 2ms/99.4%, 5ms/99.7%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/100.0%</span><br><span class="line">[0.780s][info   ][gc,marking  ] GC(6) Mark: 2 stripe(s), 2 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.780s][info   ][gc,marking  ] GC(6) Mark Stack Usage: 32M</span><br><span class="line">[0.780s][info   ][gc,nmethod  ] GC(6) NMethods: 128 registered, 0 unregistered</span><br><span class="line">[0.780s][info   ][gc,metaspace] GC(6) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.780s][info   ][gc,ref      ] GC(6) Soft: 5 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.780s][info   ][gc,ref      ] GC(6) Weak: 23 encountered, 17 discovered, 0 enqueued</span><br><span class="line">[0.780s][info   ][gc,ref      ] GC(6) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.780s][info   ][gc,ref      ] GC(6) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.780s][info   ][gc,reloc    ] GC(6) Small Pages: 405 / 810M, Empty: 40M, Relocated: 110M, In-Place: 0</span><br><span class="line">[0.780s][info   ][gc,reloc    ] GC(6) Medium Pages: 35 / 1120M, Empty: 0M, Relocated: 222M, In-Place: 0</span><br><span class="line">[0.780s][info   ][gc,reloc    ] GC(6) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.780s][info   ][gc,reloc    ] GC(6) Forwarding Usage: 0M</span><br><span class="line">[0.780s][info   ][gc,heap     ] GC(6) Min Capacity: 2048M(100%)</span><br><span class="line">[0.780s][info   ][gc,heap     ] GC(6) Max Capacity: 2048M(100%)</span><br><span class="line">[0.780s][info   ][gc,heap     ] GC(6) Soft Max Capacity: 2048M(100%)</span><br><span class="line">[0.780s][info   ][gc,heap     ] GC(6)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.780s][info   ][gc,heap     ] GC(6)  Capacity:     2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)</span><br><span class="line">[0.780s][info   ][gc,heap     ] GC(6)      Free:      118M (6%)           78M (4%)          112M (5%)         1320M (64%)        1322M (65%)          74M (4%)</span><br><span class="line">[0.780s][info   ][gc,heap     ] GC(6)      Used:     1930M (94%)        1970M (96%)        1936M (95%)         728M (36%)        1974M (96%)         726M (35%)</span><br><span class="line">[0.780s][info   ][gc,heap     ] GC(6)      Live:         -               347M (17%)         347M (17%)         347M (17%)            -                  -</span><br><span class="line">[0.780s][info   ][gc,heap     ] GC(6) Allocated:         -                40M (2%)           46M (2%)          325M (16%)            -                  -</span><br><span class="line">[0.780s][info   ][gc,heap     ] GC(6)   Garbage:         -              1582M (77%)        1542M (75%)          54M (3%)             -                  -</span><br><span class="line">[0.780s][info   ][gc,heap     ] GC(6) Reclaimed:         -                  -                40M (2%)         1527M (75%)            -                  -</span><br><span class="line">[0.781s][info   ][gc          ] GC(6) Garbage Collection (Allocation Rate) 1930M(94%)-&gt;728M(36%)</span><br><span class="line">[0.818s][info   ][gc,start    ] GC(7) Garbage Collection (Allocation Rate)</span><br><span class="line">[0.818s][info   ][gc,task     ] GC(7) Using 2 workers</span><br><span class="line">[0.818s][info   ][gc,phases   ] GC(7) Pause Mark Start 0.003ms</span><br><span class="line">[0.823s][info   ][gc,phases   ] GC(7) Concurrent Mark 4.747ms</span><br><span class="line">[0.823s][info   ][gc,phases   ] GC(7) Pause Mark End 0.008ms</span><br><span class="line">[0.823s][info   ][gc,phases   ] GC(7) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.824s][info   ][gc,phases   ] GC(7) Concurrent Process Non-Strong References 0.327ms</span><br><span class="line">[0.824s][info   ][gc,phases   ] GC(7) Concurrent Reset Relocation Set 0.013ms</span><br><span class="line">[0.827s][info   ][gc,phases   ] GC(7) Concurrent Select Relocation Set 3.474ms</span><br><span class="line">[0.827s][info   ][gc,phases   ] GC(7) Pause Relocate Start 0.004ms</span><br><span class="line">[0.852s][info   ][gc,phases   ] GC(7) Concurrent Relocate 24.640ms</span><br><span class="line">[0.852s][info   ][gc,load     ] GC(7) Load: 5.25/4.13/4.45</span><br><span class="line">[0.852s][info   ][gc,mmu      ] GC(7) MMU: 2ms/99.4%, 5ms/99.7%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/100.0%</span><br><span class="line">[0.852s][info   ][gc,marking  ] GC(7) Mark: 2 stripe(s), 2 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.852s][info   ][gc,marking  ] GC(7) Mark Stack Usage: 32M</span><br><span class="line">[0.852s][info   ][gc,nmethod  ] GC(7) NMethods: 128 registered, 0 unregistered</span><br><span class="line">[0.852s][info   ][gc,metaspace] GC(7) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.852s][info   ][gc,ref      ] GC(7) Soft: 5 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.852s][info   ][gc,ref      ] GC(7) Weak: 23 encountered, 10 discovered, 0 enqueued</span><br><span class="line">[0.852s][info   ][gc,ref      ] GC(7) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.852s][info   ][gc,ref      ] GC(7) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.852s][info   ][gc,reloc    ] GC(7) Small Pages: 229 / 458M, Empty: 4M, Relocated: 106M, In-Place: 0</span><br><span class="line">[0.852s][info   ][gc,reloc    ] GC(7) Medium Pages: 23 / 736M, Empty: 32M, Relocated: 211M, In-Place: 0</span><br><span class="line">[0.852s][info   ][gc,reloc    ] GC(7) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.852s][info   ][gc,reloc    ] GC(7) Forwarding Usage: 0M</span><br><span class="line">[0.852s][info   ][gc,heap     ] GC(7) Min Capacity: 2048M(100%)</span><br><span class="line">[0.852s][info   ][gc,heap     ] GC(7) Max Capacity: 2048M(100%)</span><br><span class="line">[0.852s][info   ][gc,heap     ] GC(7) Soft Max Capacity: 2048M(100%)</span><br><span class="line">[0.852s][info   ][gc,heap     ] GC(7)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.853s][info   ][gc,heap     ] GC(7)  Capacity:     2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)</span><br><span class="line">[0.853s][info   ][gc,heap     ] GC(7)      Free:      854M (42%)         808M (39%)         794M (39%)        1406M (69%)        1432M (70%)         760M (37%)</span><br><span class="line">[0.853s][info   ][gc,heap     ] GC(7)      Used:     1194M (58%)        1240M (61%)        1254M (61%)         642M (31%)        1288M (63%)         616M (30%)</span><br><span class="line">[0.853s][info   ][gc,heap     ] GC(7)      Live:         -               336M (16%)         336M (16%)         336M (16%)            -                  -</span><br><span class="line">[0.853s][info   ][gc,heap     ] GC(7) Allocated:         -                46M (2%)           96M (5%)          269M (13%)            -                  -</span><br><span class="line">[0.853s][info   ][gc,heap     ] GC(7)   Garbage:         -               857M (42%)         821M (40%)          35M (2%)             -                  -</span><br><span class="line">[0.853s][info   ][gc,heap     ] GC(7) Reclaimed:         -                  -                36M (2%)          821M (40%)            -                  -</span><br><span class="line">[0.853s][info   ][gc          ] GC(7) Garbage Collection (Allocation Rate) 1194M(58%)-&gt;642M(31%)</span><br><span class="line">[0.918s][info   ][gc,start    ] GC(8) Garbage Collection (Allocation Rate)</span><br><span class="line">[0.918s][info   ][gc,task     ] GC(8) Using 2 workers</span><br><span class="line">[0.918s][info   ][gc,phases   ] GC(8) Pause Mark Start 0.011ms</span><br><span class="line">[0.923s][info   ][gc,phases   ] GC(8) Concurrent Mark 4.585ms</span><br><span class="line">[0.923s][info   ][gc,phases   ] GC(8) Pause Mark End 0.005ms</span><br><span class="line">[0.923s][info   ][gc,phases   ] GC(8) Concurrent Mark Free 0.000ms</span><br><span class="line">[0.924s][info   ][gc,phases   ] GC(8) Concurrent Process Non-Strong References 0.352ms</span><br><span class="line">[0.924s][info   ][gc,phases   ] GC(8) Concurrent Reset Relocation Set 0.008ms</span><br><span class="line">[0.925s][info   ][gc,phases   ] GC(8) Concurrent Select Relocation Set 1.484ms</span><br><span class="line">[0.925s][info   ][gc,phases   ] GC(8) Pause Relocate Start 0.005ms</span><br><span class="line">[0.936s][info   ][gc,phases   ] GC(8) Concurrent Relocate 10.284ms</span><br><span class="line">[0.936s][info   ][gc,load     ] GC(8) Load: 5.25/4.13/4.45</span><br><span class="line">[0.936s][info   ][gc,mmu      ] GC(8) MMU: 2ms/99.4%, 5ms/99.7%, 10ms/99.8%, 20ms/99.9%, 50ms/99.9%, 100ms/100.0%</span><br><span class="line">[0.936s][info   ][gc,marking  ] GC(8) Mark: 2 stripe(s), 2 proactive flush(es), 1 terminate flush(es), 0 completion(s), 0 continuation(s)</span><br><span class="line">[0.936s][info   ][gc,marking  ] GC(8) Mark Stack Usage: 32M</span><br><span class="line">[0.936s][info   ][gc,nmethod  ] GC(8) NMethods: 128 registered, 0 unregistered</span><br><span class="line">[0.936s][info   ][gc,metaspace] GC(8) Metaspace: 0M used, 0M committed, 1088M reserved</span><br><span class="line">[0.936s][info   ][gc,ref      ] GC(8) Soft: 5 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.936s][info   ][gc,ref      ] GC(8) Weak: 23 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.936s][info   ][gc,ref      ] GC(8) Final: 0 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.936s][info   ][gc,ref      ] GC(8) Phantom: 1 encountered, 0 discovered, 0 enqueued</span><br><span class="line">[0.936s][info   ][gc,reloc    ] GC(8) Small Pages: 311 / 622M, Empty: 18M, Relocated: 114M, In-Place: 0</span><br><span class="line">[0.936s][info   ][gc,reloc    ] GC(8) Medium Pages: 27 / 864M, Empty: 0M, Relocated: 220M, In-Place: 0</span><br><span class="line">[0.936s][info   ][gc,reloc    ] GC(8) Large Pages: 0 / 0M, Empty: 0M, Relocated: 0M, In-Place: 0</span><br><span class="line">[0.936s][info   ][gc,reloc    ] GC(8) Forwarding Usage: 0M</span><br><span class="line">[0.936s][info   ][gc,heap     ] GC(8) Min Capacity: 2048M(100%)</span><br><span class="line">[0.936s][info   ][gc,heap     ] GC(8) Max Capacity: 2048M(100%)</span><br><span class="line">[0.936s][info   ][gc,heap     ] GC(8) Soft Max Capacity: 2048M(100%)</span><br><span class="line">[0.936s][info   ][gc,heap     ] GC(8)                Mark Start          Mark End        Relocate Start      Relocate End           High               Low</span><br><span class="line">[0.936s][info   ][gc,heap     ] GC(8)  Capacity:     2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)       2048M (100%)</span><br><span class="line">[0.936s][info   ][gc,heap     ] GC(8)      Free:      562M (27%)         516M (25%)         526M (26%)        1490M (73%)        1490M (73%)         488M (24%)</span><br><span class="line">[0.936s][info   ][gc,heap     ] GC(8)      Used:     1486M (73%)        1532M (75%)        1522M (74%)         558M (27%)        1560M (76%)         558M (27%)</span><br><span class="line">[0.936s][info   ][gc,heap     ] GC(8)      Live:         -               335M (16%)         335M (16%)         335M (16%)            -                  -</span><br><span class="line">[0.936s][info   ][gc,heap     ] GC(8) Allocated:         -                46M (2%)           54M (3%)          213M (10%)            -                  -</span><br><span class="line">[0.936s][info   ][gc,heap     ] GC(8)   Garbage:         -              1150M (56%)        1132M (55%)           8M (0%)             -                  -</span><br><span class="line">[0.936s][info   ][gc,heap     ] GC(8) Reclaimed:         -                  -                18M (1%)         1141M (56%)            -                  -</span><br><span class="line">[0.936s][info   ][gc          ] GC(8) Garbage Collection (Allocation Rate) 1486M(73%)-&gt;558M(27%)</span><br><span class="line">[1.018s][info   ][gc,start    ] GC(9) Garbage Collection (Allocation Rate)</span><br><span class="line">[1.018s][info   ][gc,task     ] GC(9) Using 2 workers</span><br><span class="line">[1.019s][info   ][gc,phases   ] GC(9) Pause Mark Start 0.005ms</span><br><span class="line">[1.023s][info   ][gc,phases   ] GC(9) Concurrent Mark 4.596ms</span><br><span class="line">[1.023s][info   ][gc,phases   ] GC(9) Pause Mark End 0.005ms</span><br><span class="line">[1.023s][info   ][gc,phases   ] GC(9) Concurrent Mark Free 0.000ms</span><br><span class="line">[1.024s][info   ][gc,phases   ] GC(9) Concurrent Process Non-Strong References 0.288ms</span><br><span class="line">[1.024s][info   ][gc,phases   ] GC(9) Concurrent Reset Relocation Set 0.010ms</span><br><span class="line">[1.025s][info   ][gc,phases   ] GC(9) Concurrent Select Relocation Set 1.497ms</span><br><span class="line">[1.025s][info   ][gc,phases   ] GC(9) Pause Relocate Start 0.002ms</span><br><span class="line">counter:54449</span><br><span class="line">[1.029s][info   ][gc          ] GC(9) Garbage Collection (Allocation Rate) Aborted</span><br><span class="line">[1.029s][info   ][gc,heap,exit] Heap</span><br><span class="line">[1.029s][info   ][gc,heap,exit]  ZHeap           used 1228M, capacity 2048M, max capacity 2048M</span><br><span class="line">[1.029s][info   ][gc,heap,exit]  Metaspace       used 280K, committed 512K, reserved 1114112K</span><br><span class="line">[1.029s][info   ][gc,heap,exit]   class space    used 9K, committed 128K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<h4 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h4><p>目标是极低延迟，尽可能减少 STW 时间。采用并发压缩技术（Concurrent Compaction），避免碎片化问题。大部分回收工作与应用线程并发执行。</p>
<p>优点：</p>
<ul>
<li>GC 停顿时间低。</li>
<li>内存整理避免碎片化。</li>
<li>对堆内存的需求比 ZGC 更低。</li>
</ul>
<p>缺点：</p>
<ul>
<li>较新的 GC，生态和调优支持可能不如 G1 和 ZGC。</li>
<li>CPU 开销高。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>延迟敏感的应用。</li>
<li>中大型堆内存的场景。</li>
</ul>
<h4 id="GC总结"><a href="#GC总结" class="headerlink" title="GC总结"></a>GC总结</h4><p>从GC的发展历史来看，目标是两个</p>
<ol>
<li>尽可能减少停顿时间，不影响业务。</li>
<li>尽可能减少GC时间，让GC更快。</li>
</ol>
<p>通过以上的对比可以发现，堆的大小不能设置的太小导致OOM，同样当堆设置的过大对于性能也并没有什么提升，比如2g对比1g内存，就没什么提升。从512m和1g内存对比上来看，ZGC最优，不仅减少了GC次数，性能也很好。而G1GC的优化最好，因为它的GC次数最多，但是性能同样强大。</p>
<p>从结果来看最好的是ZGC，其次可以选择G1GC或者并行GC。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM原理</title>
    <url>/JVM%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.html</url>
    <content><![CDATA[<h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="jvm基础知识"><a href="#jvm基础知识" class="headerlink" title="jvm基础知识"></a>jvm基础知识</h3><p>什么是JVM,这个大家应该都知道，就是java虚拟机，全称<code>java vitual mechainm</code>。</p>
<p>既然是虚拟机，自然要仿照正常电脑运行，要有内存模型，就跟电脑虚拟内存一样，要有指令集，也就是字节码。</p>
<h3 id="java字节码"><a href="#java字节码" class="headerlink" title="java字节码"></a>java字节码</h3><p>Java bytecode由单字节的指令组成，类似汇编，java使用了200多个操作码</p>
<ul>
<li>栈操作指令</li>
<li>程序流程控制指令</li>
<li>对象操作指令</li>
<li>算术运算以及类型转换指令</li>
</ul>
<p>javap可以看到字节码文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javap -c -verbose ...</span><br></pre></td></tr></table></figure>

<p>astore_1 代表store 本地变量表的slot 1，a代表引用类型。istore代表int store。</p>
<p>算数操作</p>
<ul>
<li>iadd：栈顶两个int类型数值相加，并将结果压入栈顶。</li>
<li>isub：栈顶两个int类型数值相减。</li>
<li>imul：栈顶两个int类型数值相乘。</li>
<li>idiv：栈顶两个int类型数值相除。</li>
<li>iinc：对局部变量表中的int类型变量自增或自减。</li>
</ul>
<p>类型转换</p>
<ul>
<li>i2f：将int类型转换为float类型。</li>
<li>f2i：将float类型转换为int类型。</li>
<li>i2b：将int类型转换为byte类型。</li>
<li>i2c：将int类型转换为char类型。</li>
</ul>
<p>方法调用指令</p>
<ul>
<li>invokestatic: 调用静态方法</li>
<li>invokespecial: 用来调用构造函数，或同一个类中的private方法，以及超类方法</li>
<li>invokevirtual: 调用公共，受保护和package级的私有方法类似c的虚函数</li>
<li>invokeinterface: 调用接口方法</li>
<li>invokedynamic: lambda实现基础</li>
<li>new 创建对象</li>
<li>getfield: 获取对象的实例字段</li>
<li>putfield: 设置对象的实例字段</li>
</ul>
<p>栈操作指令</p>
<ul>
<li>pop：将栈顶的一个数值弹出（丢弃）。</li>
<li>dup：复制栈顶的一个数值。</li>
<li>swap：交换栈顶的两个数值。</li>
</ul>
<p>条件跳转指令</p>
<ul>
<li>if_icmpeq：如果栈顶两个int值相等，则跳转。</li>
<li>if_icmpne：如果栈顶两个int值不相等，则跳转。</li>
<li>goto：无条件跳转到指定位置。</li>
<li>tableswitch：根据值选择跳转位置，用于switch语句。</li>
</ul>
<p>同步指令</p>
<ul>
<li>monitorenter：进入同步代码块。</li>
<li>monitorexit：退出同步代码块。</li>
</ul>
<h3 id="JVM类加载器"><a href="#JVM类加载器" class="headerlink" title="JVM类加载器"></a>JVM类加载器</h3><p>引导类加载器</p>
<ul>
<li>引导类加载器是最顶层的类加载器，负责加载 Java 核心库中的类（例如 java.lang.* 包中的类）。这些类一般位于 JRE 目录下的 rt.jar 文件中。</li>
<li>它是由 C++ 编写的，直接由操作系统加载，因此没有 Java 类的实现。</li>
<li>它默认从 JRE&#x2F;lib 路径下加载类。</li>
</ul>
<p>扩展类加载器</p>
<ul>
<li>扩展类加载器负责加载 Java 扩展库中的类。这些类通常位于 JRE&#x2F;lib&#x2F;ext 目录下，或者由 java.ext.dirs 系统属性指定的其他路径。</li>
<li>它是由 Java 编写的，属于标准的类加载器。</li>
<li>它默认从 JRE&#x2F;lib&#x2F;ext 目录和 java.ext.dirs 属性指定的路径加载类</li>
</ul>
<p>系统类加载器</p>
<ul>
<li>系统类加载器负责加载应用程序的类，也就是由用户编写的类。它通常从类路径（classpath）中加载类。</li>
<li>它是由 Java 编写的，通常是 ClassLoader 类的一个实例。用户可以指定 classpath 来告诉系统类加载器从哪里加载类。</li>
<li>它根据环境变量 CLASSPATH 或 -cp 命令行参数指定的路径加载类。</li>
</ul>
<p>自定义类加载器</p>
<ul>
<li>Java 还允许程序员创建自定义类加载器，来自定义类加载的行为。自定义类加载器可以扩展 ClassLoader 类并重写其 findClass() 方法，来实现从不同的数据源加载类，比如从数据库、网络等加载类。</li>
<li>自定义类加载器在很多场景中有用，比如在应用服务器中动态加载插件，或者从不常规的源（如数据库、网络等）加载类。</li>
</ul>
<p>类的生命周期</p>
<ul>
<li>加载： 找class文件，类加载器通过 findClass() 方法从指定的位置查找 .class 文件。加载器会将 .class 文件转化为二进制字节流。</li>
<li>验证： 验证格式，依赖。验证阶段确保加载的 .class 文件格式正确，并且不包含任何有可能危害虚拟机安全的代码。</li>
<li>准备： 静态字段，方法表。准备阶段分配内存并为类变量（静态字段）设置默认值（如 0、null 等）。</li>
<li>解析： 符号解析为引用。解析阶段将类中的符号引用（例如字段、方法、类的名字等）解析为实际的内存地址或方法引用。</li>
<li>初始化： 构造器，静态变量赋值，静态代码块。初始化阶段是类加载过程的最后一步，它会执行类的静态初始化块（static 块）和静态字段的初始化。</li>
<li>使用</li>
<li>卸载</li>
</ul>
<p>JVM 中的类加载器采用了父子委托机制（Parent Delegation Model）。当一个类加载器收到加载某个类的请求时，它不会直接去加载类，而是首先将请求委托给父类加载器。如果父类加载器无法加载，则再由当前加载器进行加载。这种机制的好处是可以保证 Java 核心类库不会被用户定义的类覆盖。</p>
<h3 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h3><p>内存模型，这里是重点，如何理解内存模型。内存模型主要其实就是栈、堆、方法区。</p>
<ul>
<li>栈：包括java线程栈，每个线程有自己的栈，主要存储局部变量。本地方法栈，就是调用一些c++代码之类的，非java代码用的。所谓的调用栈其实就是栈的一个使用列表。</li>
<li>堆：堆里面存放的是动态数据，通常就是<code>new</code>出来的就放在堆里。</li>
<li>方法区：既不是局部变量，也不是new出来的动态数据，就是存储常量，静态变量，全局变量之类的。</li>
</ul>
<p>java栈</p>
<ul>
<li>线程私有：存储线程的本地变量信息等</li>
<li>每个线程在执行方法时，都会在栈中创建一个栈帧（stack frame）。栈帧包含方法的局部变量、操作数栈、动态链接、方法返回地址等信息。栈的大小通常由 -Xss 参数进行控制。</li>
<li>局部变量的作用范围仅限于当前方法，存储在栈帧中。</li>
</ul>
<p>本地方法栈</p>
<ul>
<li>用于执行本地方法（即通过 JNI 调用的 C&#x2F;C++ 等语言编写的代码）。和 Java 栈类似，本地方法栈也包含栈帧，但栈帧里存储的是本地方法的相关信息。</li>
<li>每个线程有自己的本地方法栈。</li>
</ul>
<p>java堆</p>
<ul>
<li>共有</li>
<li>存储动态信息，如对象数据，包括对象的成员变量，成员函数，静态变量。因此多线程访问堆中的数据时需要进行同步，以保证数据的一致性和可见性。</li>
<li>堆是垃圾回收的主要区域。</li>
<li>垃圾回收器负责堆内存的管理，通过标记清除、复制回收、分代回收等算法来回收无用对象的内存。</li>
</ul>
<p>方法区</p>
<ul>
<li>方法区用于存储类信息、常量、静态变量、即时编译器（JIT）编译后的代码等数据。在 Java 7 之前，方法区和永久代（PermGen）是一个概念，但在 Java 8 中，永久代被 Metaspace（元空间）替代，Metaspace 位于本地内存中，而非堆中。</li>
<li>方法区是所有线程共享的，因此多线程访问时也需要注意同步。</li>
<li>存储类的元数据（类的结构、常量池等）、静态变量、方法等。</li>
</ul>
<p>运行时常量池</p>
<ul>
<li>运行时常量池是方法区的一部分，用于存储编译期间生成的字面量和符号引用（例如字符串常量和类、方法、字段的引用）。</li>
<li>常量池是所有线程共享的，所有类共享相同的常量池。</li>
</ul>
<p>直接内存</p>
<ul>
<li>直接内存并不是 JVM 内存模型的一部分，但它是通过 java.nio 包提供的 ByteBuffer 类实现的内存区域。直接内存可以绕过 JVM 的堆和垃圾回收机制，直接与操作系统的内存交互，用于提高 I&#x2F;O 性能。</li>
<li>直接内存可以由多个线程共享，但需要开发者手动管理。</li>
</ul>
<p>那么这些都是逻辑上的，如何映射到内存中呢？首先，内存可以理解为一个巨大的连续的数组空间。看下图。栈在最顶上，往下增长，堆在最下面，往上增长，中间是本地方法栈，如果堆增长到本地方法栈了，那么堆就满了，栈也一样。</p>
<p><img src="/../images/java/jvm1.png" alt="jvm内存.png"></p>
<p>堆内存。堆里的东西都是new出来的，放在c++里面就是需要手动delete的，当然了，现代c++也可以通过其他的来自动delete。而java则是通过垃圾回收来自动delete。所以java为了方便自动回收，就在堆里面又划分了年轻代，老年代，年轻代里面还细分了新生代，存活区。</p>
<ul>
<li>年轻代：占1&#x2F;3<ul>
<li>新生代：占年轻代的8&#x2F;10</li>
<li>存活区： 一般有两个，每个占1&#x2F;10</li>
</ul>
</li>
<li>老年代：占2&#x2F;3</li>
</ul>
<p>示例代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> function <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">A</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    Thread.Sleep(<span class="number">10000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一开始，老年代和存活区全部是空的，当第一个对象a创建的时候，会出现在年轻代。如下图</p>
<p><img src="/../images/java/jvm2.png" alt="jvm内存.png"></p>
<p>接下来对象b创建，对象b也进入年轻代。如下图</p>
<p><img src="/../images/java/jvm3.png" alt="jvm内存.png"></p>
<p>从内存上看，则如图所示，栈中存储变量a和变量b，内容分别是0F00,0F0C，指向堆中两个对象的地址。堆中对象里面有一个隐含的this变量和一个变量i。</p>
<p><img src="/../images/java/jvm4.png" alt="jvm内存.png"></p>
<p>接下来执行第一次GC，也可以说是yongGC。首先标记存活对象b，对象a将别回收，因此不标记。</p>
<p><img src="/../images/java/jvm5.png" alt="jvm内存.png"></p>
<p>接下来将对象b复制到存活区0。</p>
<p><img src="/../images/java/jvm6.png" alt="jvm内存.png"></p>
<p>最后删除新生代和存活区1的内容。这个时候对象a也就被删除了。</p>
<p><img src="/../images/java/jvm7.png" alt="jvm内存.png"></p>
<p>第二次GC，假设对象b还可以存活，那么对象b将移动到存活区1，然后清空新生代和存活区0。</p>
<p><img src="/../images/java/jvm8.png" alt="jvm内存.png"></p>
<p>如果经过多次GC,默认是15次，那么对象b就会移动到老年代。</p>
<p><img src="/../images/java/jvm9.png" alt="jvm内存.png"></p>
<p>接下来在进行yongGC就和对象b没有关系了，只有进行oldGC或者FullGC才有关系。</p>
<p>非堆</p>
<ul>
<li>元数据：以前是永久代</li>
<li>CCS: 存放class信息，和元数据有交叉</li>
<li>code cache: 存放JIT编译后的本地机器代码</li>
</ul>
<p>可见性</p>
<ul>
<li>当多个线程访问同一个共享变量时，一个线程对变量的修改可能对其他线程不可见。JMM 规定了变量的可见性，确保一个线程对共享变量的修改能够及时地被其他线程看到。</li>
<li>通过 volatile 关键字、锁（如 synchronized 或 ReentrantLock）以及 final 关键字来保证变量的可见性。</li>
</ul>
<p>原子性</p>
<ul>
<li>原子性保证某些操作在执行时不被中断。JMM 的目标之一是确保对某些变量的操作是原子的。例如，增加操作（i++）并不是原子操作。</li>
<li>JMM 通过锁、synchronized 块、java.util.concurrent 包中的并发类（如 AtomicInteger）来保证原子性。</li>
</ul>
<p>有序性</p>
<ul>
<li>指令重排序可能导致执行顺序和程序代码中的顺序不一致，尤其是在多核 CPU 环境中。JMM 规定了操作的执行顺序。</li>
<li>Java 提供了 volatile 关键字来防止指令重排序，在同步块中通过 synchronized 保证指令的顺序性。此外，java.util.concurrent 包中的类（如 CountDownLatch、CyclicBarrier 等）也帮助确保线程间的顺序性。</li>
</ul>
<p>Happens-Before 原则。JMM 使用 happens-before 规则来确保内存操作的有序性。它描述了操作之间的相对顺序，确保前一个操作对后一个操作的可见性和顺序性。常见的 happens-before 规则有：</p>
<ul>
<li>在同一个线程中，代码的执行顺序是按程序顺序进行的。</li>
<li>对于 volatile 变量的写操作，发生在后续对该变量的读操作之前。</li>
<li>在 synchronized 代码块的释放锁之前的所有操作，都会发生在锁被获得之后。</li>
</ul>
<h3 id="JVM启动参数"><a href="#JVM启动参数" class="headerlink" title="JVM启动参数"></a>JVM启动参数</h3><p>-开头是标准参数，如-server<br>-D设置系统属性，如-Dfile.encoding&#x3D;UTF-8<br>-X开头是非标准参数，基本都传给JVM的，默认JVM实现这些参数的功能。可以jvm -X查看支持的参数。如-Xmx8g<br>-XX开头是非稳定参数，专门控制jvm的行为，根具体的jvm实现有关</p>
<ul>
<li>-XX:+-Flags形式，+-是对布尔值进行开关。+代表开，-代表关。如-XX:_UseG1GC</li>
<li>-XX:key&#x3D;value形式，指定某个选项的值.如-XX:MaxPermSize&#x3D;256m</li>
</ul>
<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>分代假设：大部分新生对象很快无用，存活较长时间的对象，可能存活更长时间。经历了15次GC还存在的就放在老年代.新生代80%，S0,S1各10%新生代到存活区是复制，到老年代是移动。</p>
<p>-XX: +MaxTenuringThreshold&#x3D;15 表示15次后放到老年代。</p>
<p>可以做为GC ROOT的对象</p>
<ol>
<li>当前正在执行的方法里的局部变量和输入参数</li>
<li>活动线程</li>
<li>所有类的静态字段</li>
<li>JNI引用</li>
</ol>
<h4 id="Serial-GC-x2F-ParNewGC"><a href="#Serial-GC-x2F-ParNewGC" class="headerlink" title="Serial GC&#x2F;ParNewGC"></a>Serial GC&#x2F;ParNewGC</h4><p>-XX: +UseSerialGC开启</p>
<p>对年轻代使用mark-copy算法，对老年代使用mark-sweep-compact算法</p>
<p>串行GC不能并行处理，所以触发全部暂停(STW)</p>
<p>ParNewGC可以配合CMSGC使用</p>
<p>适用场景：</p>
<ul>
<li>单线程应用或资源有限的环境（如嵌入式系统）。</li>
<li>小型应用，不需要频繁的垃圾回收。</li>
</ul>
<h4 id="Parallel-GC"><a href="#Parallel-GC" class="headerlink" title="Parallel GC"></a>Parallel GC</h4><p>目标是最大化应用程序运行时间（吞吐量），最小化 GC 时间。还是会短暂的暂停业务。需要业务能接受短暂的暂停。</p>
<p>-XX: +UseParallelGC<br>-XX: +UseParallelOldGC</p>
<p>年轻代和老年代GC都会触发STW事件。</p>
<p>对年轻代使用mark-copy算法，对老年代使用mark-sweep-compact算法</p>
<p>-XX: ParallelGCThreads&#x3D;N 来指定GC线程数，默认值为CPU核心数。</p>
<p>优点：</p>
<ul>
<li>多线程回收显著提高了回收效率，适合多核环境。</li>
<li>停顿时间较 Serial GC 短。</li>
<li>两次GC之间不消耗系统资源。</li>
</ul>
<p>缺点：</p>
<ul>
<li>GC 停顿仍然是全暂停（STW）。</li>
<li>不适合对延迟要求苛刻的场景。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>需要高吞吐量的大型后台任务（如批处理、数据分析）。</li>
<li>多核 CPU 环境。</li>
</ul>
<h4 id="CMS-GC"><a href="#CMS-GC" class="headerlink" title="CMS GC"></a>CMS GC</h4><p>-XX: +UseConcMarkSweepGC</p>
<p>对年轻代使用STW的mark-copy算法，对老年代主要使用并发的mark-sweep算法</p>
<p>设计目标:专为老年代设计，目标是最小化 GC 停顿时间。</p>
<ol>
<li>不对老年代进行整理，而是使用空闲列表来管理内存空间的回收</li>
<li>在mark-and-sweep的工作和业务线程并发执行。</li>
</ol>
<p>默认并发线程数等于CPU核心数的1&#x2F;4</p>
<p>6个阶段</p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>并发预清理</li>
<li>最终标记</li>
<li>并发清楚</li>
<li>并发重制</li>
</ol>
<p>MaxHeapSize是系统的1&#x2F;4内存<br>MaxNewSize是MaxHeapSize的1&#x2F;3<br>NewSize是系统的1&#x2F;64</p>
<p>优点：</p>
<ul>
<li>只有yongGC暂停业务。GC 停顿时间短，适合延迟敏感的应用。</li>
<li>并发回收利用多核资源减少 STW 时间。</li>
</ul>
<p>缺点：</p>
<ul>
<li>内存碎片化：CMS 不会整理内存，可能导致分配大对象失败（触发 Full GC）。</li>
<li>CPU 开销较高：并发阶段可能与用户线程争抢资源。</li>
<li>容易产生 “Concurrent Mode Failure”：若老年代空间不足，回退到 Serial GC。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>延迟敏感的应用（如 Web 服务、在线交易系统）。</li>
<li>多核环境下的中大型应用。</li>
</ul>
<h4 id="G1-GC"><a href="#G1-GC" class="headerlink" title="G1 GC"></a>G1 GC</h4><p>分区堆内存：将堆划分为若干独立的固定大小的区域（Region），每个 Region 可充当年轻代、老年代或其他用途。混合回收：通过优先回收包含最多垃圾的 Region（Garbage-First）。并行和并发回收：减少 STW 时间。内置碎片整理机制，避免了 CMS 的碎片化问题。一般一个Region是1M。一部分 Region 保留为 Humongous（H） 区，用于存储超过单个 Region 大小一半的巨型对象。</p>
<p>-XX: +UseG1GC -XX: MaxGCPauseMillis&#x3D;50</p>
<p>将STW的时间和分布变成可预期和可配置的，可设置某项特定的性能指标，为了达成可预期的指标，有独特的实现。增量方式，每次处理一部分，称为回收集合，每次处理所有的年轻代和部分老年代。能看到哪个块的垃圾多，优先回收他们</p>
<p>处理步骤</p>
<ol>
<li>年轻代模式转移暂停</li>
<li>并发标记</li>
<li>转移暂停：混合模式</li>
</ol>
<p>G1GC可能退化成串行GC</p>
<ol>
<li>并发模式失败：增加堆大小</li>
<li>晋升失败：</li>
<li>巨型对象分配失败：增加内存或增大Region大小</li>
</ol>
<p>优点：</p>
<ul>
<li>减少内存碎片化。</li>
<li>更好地控制 GC 停顿时间，可通过 -XX:MaxGCPauseMillis 调整。</li>
<li>自动调节年轻代和老年代的大小。</li>
</ul>
<p>缺点：</p>
<ul>
<li>实现复杂，配置选项多。</li>
<li>内存占用较高，CPU 开销大。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>需要低延迟的中大型应用。</li>
<li>堆内存较大的环境（如 &gt;4GB）。</li>
<li>替代 CMS 的推荐选择。</li>
</ul>
<p>Mixed GC</p>
<ul>
<li>老年代内存使用率达到一定阈值（默认 45%，可通过 -XX:InitiatingHeapOccupancyPercent 调整）。</li>
<li>同时回收年轻代和部分老年代。</li>
<li>执行<ul>
<li>标记 GC Roots 直接引用的对象。</li>
<li>并发扫描老年代，标记存活对象。</li>
<li>处理标记期间新产生的引用变化。</li>
</ul>
</li>
<li>根据垃圾优先（Garbage-First）的原则，优先选择包含最多垃圾的 Region。</li>
</ul>
<h4 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h4><p>专注于低延迟，目标是将 GC 停顿时间控制在 10ms 以下。支持非常大的堆内存（TB 级）。使用多线程并发回收，避免长时间的 STW。基于标记-整理算法，避免内存碎片化。使用指针染色（Pointer Coloring）来实现并发标记和引用更新。</p>
<p>-XX: +UnlockExpermentalVMOptions<br>-XX: +UseZGC<br>-XX: -Xmx16g</p>
<p>优点：</p>
<ul>
<li>极低的 GC 停顿时间。</li>
<li>支持超大堆，扩展性好。</li>
<li>减少内存碎片。</li>
<li>与G1相比，应用吞吐量下降不超过15%</li>
</ul>
<p>缺点：</p>
<ul>
<li>内存占用较高：由于需要染色指针和写屏障。</li>
<li>不适合资源紧张的环境。</li>
</ul>
<p>-XX: +UseShenandoahGC</p>
<p>立项比ZGC早，暂停时间与堆大小无关</p>
<p>适用场景：</p>
<ul>
<li>延迟敏感的大型应用（如金融交易、高并发系统）。</li>
<li>超大堆应用（TB 级别内存）。</li>
</ul>
<h4 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h4><p>目标是极低延迟，尽可能减少 STW 时间。采用并发压缩技术（Concurrent Compaction），避免碎片化问题。大部分回收工作与应用线程并发执行。</p>
<p>优点：</p>
<ul>
<li>GC 停顿时间低。</li>
<li>内存整理避免碎片化。</li>
<li>对堆内存的需求比 ZGC 更低。</li>
</ul>
<p>缺点：</p>
<ul>
<li>较新的 GC，生态和调优支持可能不如 G1 和 ZGC。</li>
<li>CPU 开销高。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>延迟敏感的应用。</li>
<li>中大型堆内存的场景。</li>
</ul>
<h4 id="GC总结"><a href="#GC总结" class="headerlink" title="GC总结"></a>GC总结</h4><p>从GC的发展历史来看，目标是两个</p>
<ol>
<li>尽可能减少停顿时间，不影响业务。</li>
<li>尽可能减少GC时间，让GC更快。</li>
</ol>
<p>基本上G1 GC是通用的，如果条件允许上ZGC或Shenandoah。JDK8的默认GC是Parallel GC，JDK9后一直都是G1 GC。从这里也能看出G1 GC性能更好。更通用。</p>
<p><img src="/../images/java/jvm10.png" alt="jvm内存.png"></p>
<ol>
<li>如果系统考虑吞吐优先，CPU资源用来处理业务，用Parallel GC</li>
<li>如果系统考虑低延迟优先，每次GC时间尽量短，用CMS GC</li>
<li>如果系统内存堆大，平均GC时间可控，使用G1 GC</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql优化指南</title>
    <url>/mysql%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97.html</url>
    <content><![CDATA[<h1 id="mysql优化"><a href="#mysql优化" class="headerlink" title="mysql优化"></a>mysql优化</h1><h2 id="数据库级别优化"><a href="#数据库级别优化" class="headerlink" title="数据库级别优化"></a>数据库级别优化</h2><ol>
<li>表结构是否合理？列的数据类型是否正确？</li>
<li>索引设置和选择是否合理？</li>
<li>存储引擎是否合理？通常使用Innodb性能更好</li>
<li>Innodb表压缩是否开启？</li>
<li>获取的锁是否正确？是否可以支持数据库更好的并发运行</li>
<li>buffer pool设置是否正确？</li>
</ol>
<h2 id="硬件级别优化"><a href="#硬件级别优化" class="headerlink" title="硬件级别优化"></a>硬件级别优化</h2><ol>
<li>磁盘寻道时间优化</li>
<li>使用SSD高速硬盘，提升读写效率，或使用磁盘阵列来并行读取</li>
<li>CPU周期</li>
<li>内存带宽</li>
</ol>
<h2 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h2><h3 id="select语句优化"><a href="#select语句优化" class="headerlink" title="select语句优化"></a>select语句优化</h3><p>where语句总是比全表查询更快，尽量避免全表查询，where语句尽量走索引，但需要注意索引对于磁盘空间的占用和增删改的影响。</p>
<p>定期使用<code>ANALYZE TABLE</code>来更新mysql的统计信息，以确保优化器正确选择索引。</p>
<p>了解存储引擎特有的调优技术</p>
<p>避免写出难以理解的查询语句</p>
<p>仔细阅读<code>EXPLAIN</code>查询计划，根据计划来调优</p>
<p>调整buffer pool以容纳更多的缓存</p>
<p>处理锁定问题，以避免锁冲突、锁等待造成查询慢</p>
<h4 id="where子句优化"><a href="#where子句优化" class="headerlink" title="where子句优化"></a>where子句优化</h4><p>在mysql准备阶段，即优化阶段之前，mysql会进行一些语句重写。</p>
<p>删除不必要的括号，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((a AND b) AND c OR (((a AND b) AND (c AND d))))</span><br></pre></td></tr></table></figure>

<p>删除以后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(a AND b AND c) OR (a AND b AND c AND d)</span><br></pre></td></tr></table></figure>

<p>恒定折叠，比如a&lt;b and a &#x3D; 5, 那么可知 b &gt; 5</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(a&lt;b AND b=c) AND a=5</span><br></pre></td></tr></table></figure>

<p>优化以后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&gt;5 AND b=c AND a=5</span><br></pre></td></tr></table></figure>

<p>恒等式移除，比如一些永真式或永假式可以直接移除掉，包括常用的where 1 &#x3D; 1，下面1&#x3D;1永真，5&#x3D;6永假，所以b&#x3D;7也去掉</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(b&gt;=5 AND b=5) OR (b=6 AND 1=1) OR (b=7 AND 5=6)</span><br></pre></td></tr></table></figure>

<p>优化以后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b=5 or b=6</span><br></pre></td></tr></table></figure>

<p>索引使用的常数表达式只计算一次。</p>
<p>早期检测无效的常量表达式。MySQL会快速检测到某些SELECT语句是不可能的，并且不返回任何行。</p>
<p>如果不使用group by，那么having将和where合并</p>
<p>对于联接中的每个表，构造一个更简单的WHERE，以获得表的快速WHERE计算，并尽快跳过行。</p>
<p>在查询中，所有常量表都在任何其他表之前首先读取。常量表是以下任何一种：</p>
<ol>
<li>空表或只有一行的表。</li>
<li>where放在主键索引或者唯一索引上的，所有的索引部分都和常亮表达式比较，并定义为NOT NULL<br>比如<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t WHERE primary_key=1;</span><br><span class="line">SELECT * FROM t1,t2 WHERE t1.primary_key=1 AND t2.primary_key=t1.id;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>通过尝试所有的可能性来找到连接表的最佳连接组合。如果ORDER BY和GROUP BY子句中的所有列都来自同一个表，则在联接时首选该表。</p>
<p>如果有一个ORDER BY子句和一个不同的GROUP BY子句，或者如果ORDER BY或GROUP BY包含来自连接队列中第一个表以外的表的列，则将创建一个临时表。</p>
<p>如果使用SQL_SMALL_RESULT修饰符，MySQL将使用内存中的临时表。</p>
<p>查询每个表索引，并使用最佳索引，除非优化器认为使用表扫描更有效。曾经，扫描是根据最佳索引是否覆盖表的30%以上来使用的，但固定的百分比不再决定使用索引还是扫描。优化器现在更加复杂，它的估计基于其他因素，如表大小、行数和I&#x2F;O块大小。</p>
<p>在某些情况下，MySQL可以从索引中读取行，甚至不需要查阅数据文件。如果索引中使用的所有列都是数值列，则仅使用索引树来解析查询。</p>
<p>在输出每一行之前，将跳过与HAVING子句不匹配的行。</p>
<p>一些非常快的查询示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*) FROM tbl_name;</span><br><span class="line"></span><br><span class="line">SELECT MIN(key_part1),MAX(key_part1) FROM tbl_name;</span><br><span class="line"></span><br><span class="line">SELECT MAX(key_part2) FROM tbl_name</span><br><span class="line">  WHERE key_part1=constant;</span><br><span class="line"></span><br><span class="line">SELECT ... FROM tbl_name</span><br><span class="line">  ORDER BY key_part1,key_part2,... LIMIT 10;</span><br><span class="line"></span><br><span class="line">SELECT ... FROM tbl_name</span><br><span class="line">  ORDER BY key_part1 DESC, key_part2 DESC, ... LIMIT 10;</span><br></pre></td></tr></table></figure>

<p>MySQL只使用索引树解析以下查询，假设索引列是数字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT key_part1,key_part2 FROM tbl_name WHERE key_part1=val;</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*) FROM tbl_name</span><br><span class="line">  WHERE key_part1=val1 AND key_part2=val2;</span><br><span class="line"></span><br><span class="line">SELECT MAX(key_part2) FROM tbl_name GROUP BY key_part1;</span><br></pre></td></tr></table></figure>

<p>以下查询使用索引来按排序顺序检索行，而无需单独的排序过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ... FROM tbl_name</span><br><span class="line">  ORDER BY key_part1,key_part2,... ;</span><br><span class="line"></span><br><span class="line">SELECT ... FROM tbl_name</span><br><span class="line">  ORDER BY key_part1 DESC, key_part2 DESC, ... ;</span><br></pre></td></tr></table></figure>

<h4 id="范围优化"><a href="#范围优化" class="headerlink" title="范围优化"></a>范围优化</h4><p>对于BTREE和HASH索引，当使用&#x3D;、&lt;&#x3D;&gt;、IN（）、IS NULL或IS NOT NULL运算符时，键部分与常量值的比较是范围条件。此外，对于BTREE索引，当使用&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，BETWEEN，！&#x3D; 、或&lt;&gt;运算符，或者LIKE比较（如果LIKE的参数是不以小写字符开头的常量字符串）。对于所有索引类型，多个范围条件与OR或AND组合形成范围条件。</p>
<p>给定数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key_part1  key_part2  key_part3</span><br><span class="line">  NULL       1          &#x27;abc&#x27;</span><br><span class="line">  NULL       1          &#x27;xyz&#x27;</span><br><span class="line">  NULL       2          &#x27;foo&#x27;</span><br><span class="line">   1         1          &#x27;abc&#x27;</span><br><span class="line">   1         1          &#x27;xyz&#x27;</span><br><span class="line">   1         2          &#x27;abc&#x27;</span><br><span class="line">   2         1          &#x27;aaa&#x27;</span><br></pre></td></tr></table></figure>

<p>执行where key_part1&#x3D; 1，其扫描范围为 1,负无穷，负无穷到 1,正无穷，正无穷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1,-inf,-inf) &lt;= (key_part1,key_part2,key_part3) &lt; (1,+inf,+inf)</span><br></pre></td></tr></table></figure>
<p>即覆盖了这三行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1         1          &#x27;abc&#x27;</span><br><span class="line">1         1          &#x27;xyz&#x27;</span><br><span class="line">1         2          &#x27;abc&#x27;</span><br></pre></td></tr></table></figure>

<p>index dives，优化器在范围的两端进行dives, 可以帮助优化器更准确的评估扫描的行数，index dives提供了更准确的行估计，但是随着比较值数量的增加，更加耗时，使用统计信息的准确性不如index dives，但允许对大值列表进行更快的行估计。</p>
<p>eq_range_index_dive_limit系统变量使您能够配置优化器从一个行估计策略切换到另一个行估计策略时的值数量。要允许使用索引潜水来比较最多N个相等范围，请将eq_range_index_dive_limit设置为N+ 1。要禁用统计信息并始终使用索引潜水而不管N，请将eq_range_index_dive_limit设置为0。</p>
<p>若要更新表索引统计信息以获得最佳估计值，请使用ANALYZE TABLE。</p>
<p>skip scan,比如有索引(f1,f2)，都知道最左前缀原则，所以一般where f2 &gt; 40是不走索引的，skip scan可以让他走索引，通过构造f1 &#x3D; 1 and f2 &gt; 40，扫描完以后再扫描 f1 &#x3D; 2 and f2 &gt; 40，以此类推，可以通过explain来看extra列是否有skip scan</p>
<p>in优化，in查询可以用如下形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ... FROM t1 WHERE ( col_1, col_2 ) IN (( &#x27;a&#x27;, &#x27;b&#x27; ), ( &#x27;c&#x27;, &#x27;d&#x27; ));</span><br></pre></td></tr></table></figure>

<p>range_optimizer_max_size_size系统变量可以设置优化器使用的内存</p>
<h4 id="index-merge-优化"><a href="#index-merge-优化" class="headerlink" title="index merge 优化"></a>index merge 优化</h4><p>index merge就是多个索引并发扫描，再将扫描结果合并</p>
<p>索引合并不适用于全文索引。</p>
<p>索引合并访问方法检索具有多个范围扫描的行，并将其结果合并为一个。此访问方法只合并单个表的索引扫描，而不合并多个表的扫描。合并可以产生其底层扫描的并集、交集或交集的并集。</p>
<p>可以使用索引合并的查询示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tbl_name WHERE key1 = 10 OR key2 = 20;</span><br><span class="line"></span><br><span class="line">SELECT * FROM tbl_name</span><br><span class="line">  WHERE (key1 = 10 OR key2 = 20) AND non_key = 30;</span><br><span class="line"></span><br><span class="line">SELECT * FROM t1, t2</span><br><span class="line">  WHERE (t1.key1 IN (1,2) OR t1.key2 LIKE &#x27;value%&#x27;)</span><br><span class="line">  AND t2.key1 = t1.some_col;</span><br><span class="line"></span><br><span class="line">SELECT * FROM t1, t2</span><br><span class="line">  WHERE t1.key1 = 1</span><br><span class="line">  AND (t2.key1 = t1.some_col OR t2.key2 = t1.some_col2);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你的查询有一个带有深度AND&#x2F;OR嵌套的复杂WHERE子句，并且MySQL没有选择最佳计划，请尝试使用以下恒等转换来分发术语：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(x AND y) OR z =&gt; (x OR z) AND (y OR z)</span><br><span class="line">(x OR y) AND z =&gt; (x AND z) OR (y AND z)</span><br></pre></td></tr></table></figure>

<p>在EXPLAIN输出中，Index Merge方法在type列中显示为index_merge。在本例中，key列包含使用的索引列表，key_len包含这些索引的最长键部分列表。</p>
<p>索引合并访问方法有几种算法，它们显示在EXPLAIN输出的Extra字段中：</p>
<ul>
<li>intersect：对多个and条件生效</li>
<li>union：对多个or条件生效</li>
<li>sort_union：sort-union算法和union算法之间的区别在于，sort-union算法必须首先获取所有行的行ID，并在返回任何行之前对其进行排序。</li>
</ul>
<p>索引合并的使用取决于optimizer_switch系统变量的index_merge、index_merge_intersection、index_merge_union和index_merge_sort_union标志的值。默认情况下，所有这些标志都是打开的。</p>
<h4 id="hash-join"><a href="#hash-join" class="headerlink" title="hash join"></a>hash join</h4><p>默认情况下，MySQL尽可能使用哈希连接。可以使用BNL和NO_BNL优化器提示之一来控制是否使用散列连接。</p>
<p>hash join比嵌套join快的多，首先创建hash表，在循环另一个表进行hash，判断是否相等</p>
<p>可以使用join_buffer_size系统变量控制哈希连接的内存使用量;哈希连接使用的内存量不能超过此值。当哈希连接所需的内存超过可用量时，MySQL会使用磁盘上的文件来处理。如果发生这种情况，您应该注意，如果哈希连接无法容纳内存并且它创建的文件比为open_files_limit设置的文件多，则连接可能不会成功。要避免此类问题，请进行以下更改之一：</p>
<ul>
<li>增加join_buffer_size，使哈希连接不会溢出到磁盘。</li>
<li>增加open_files_limit。</li>
</ul>
<h4 id="引擎条件下推"><a href="#引擎条件下推" class="headerlink" title="引擎条件下推"></a>引擎条件下推</h4><p>只有ndb引擎可以使用，假设查询如下，a有索引，b没有索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT a, b FROM t1 WHERE b = 10;</span><br></pre></td></tr></table></figure>

<p>那么可以条件下推给ndb引擎执行where条件，如果where a &#x3D;10则不会下推，因为索引更快</p>
<p>explain里面可以显示为：Extra: Using where with pushed condition</p>
<p>like,between,is null,is not null,in也可以执行下推。</p>
<p>BLOB，TEXT，JSON,BIT,ENUM类型的字段不能执行下推</p>
<h4 id="索引条件下推"><a href="#索引条件下推" class="headerlink" title="索引条件下推"></a>索引条件下推</h4><p>索引条件下推（ICP）是MySQL使用索引从表中检索行的情况下的优化。如果没有ICP，存储引擎将遍历索引以定位基表中的行，并将它们返回到MySQL服务器，该服务器将评估行的WHERE条件。在启用ICP的情况下，如果可以仅使用索引中的列来计算部分WHERE条件，则MySQL服务器会将这部分WHERE条件下推到存储引擎。然后，存储引擎通过使用索引条目来评估推送的索引条件，并且仅当满足该条件时才从表中读取行。ICP可以减少存储引擎必须访问基表的次数以及MySQL服务器必须访问存储引擎的次数。</p>
<p>索引条件下推优化的适用性受以下条件的限制：</p>
<ul>
<li>当需要访问整个表行时，ICP用于range、ref、eq_ref和ref_or_null访问方法。</li>
<li>ICP可以用于InnoDB和MyISAM表，包括分区的InnoDB和MyISAM表。</li>
<li>对于InnoDB表，ICP仅用于辅助索引。ICP的目标是减少整行读取的数量，从而减少I&#x2F;O操作。对于InnoDB聚集索引，完整的记录已经读入InnoDB缓冲区。在这种情况下使用ICP不会减少I&#x2F;O。</li>
<li>ICP不支持在虚拟生成列上创建辅助索引。InnoDB支持虚拟生成列的二级索引。</li>
<li>引用子查询的条件不能下推。</li>
<li>引用存储函数的条件不能下推。存储引擎不能调用存储的函数。</li>
<li>触发的条件不能下推。</li>
<li>不能将条件下推到包含对系统变量的引用的派生表。</li>
</ul>
<p>要理解这种优化是如何工作的，首先考虑当不使用索引条件下推时索引扫描是如何进行的：</p>
<ol>
<li>获取下一行，首先通过阅读索引元组，然后使用索引元组定位并读取整个表行。</li>
<li>测试应用于此表的部分WHERE条件。根据测试结果接受或拒绝行。</li>
</ol>
<p>使用Index Condition Pushdown，扫描过程如下所示：</p>
<ol>
<li>获取下一行的索引元组（但不是整个表行）。</li>
<li>测试应用于此表且只能使用索引列进行检查的WHERE条件部分。如果不满足条件，则继续执行下一行的索引元组。</li>
<li>如果满足条件，则使用索引元组定位并读取整个表行。</li>
<li>测试应用于此表的WHERE条件的其余部分。根据测试结果接受或拒绝行。</li>
</ol>
<p>假设一个表包含有关人员及其地址的信息，并且该表的索引定义为 INDEX (zipcode, lastname, firstname) 。如果我们知道一个人的zipcode值，但不确定他的姓氏，我们可以这样搜索：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM people</span><br><span class="line">  WHERE zipcode=&#x27;95054&#x27;</span><br><span class="line">  AND lastname LIKE &#x27;%etrunia%&#x27;</span><br><span class="line">  AND address LIKE &#x27;%Main Street%&#x27;;</span><br></pre></td></tr></table></figure>
<p>MySQL可以使用索引扫描zipcode &#x3D;’95054’的人。第二部分（lastname LIKE ‘%etrunia%’）不能用于限制必须扫描的行数，因此如果没有Index Condition Pushdown，则此查询必须检索所有zipcode &#x3D;’95054’的人的完整表行。</p>
<p>使用Index Condition Pushdown，MySQL在阅读整个表行之前检查lastname LIKE“%etrunia%”部分。这样可以避免阅读与zipcode条件匹配但与lastname条件不匹配的索引元组对应的整行。</p>
<p>默认情况下，索引条件下推处于启用状态。可以通过设置index_condition_pushdown标志来使用optimizer_switch系统变量控制它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET optimizer_switch = &#x27;index_condition_pushdown=off&#x27;;</span><br><span class="line">SET optimizer_switch = &#x27;index_condition_pushdown=on&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="条件过滤"><a href="#条件过滤" class="headerlink" title="条件过滤"></a>条件过滤</h4><p>在联接处理中，前缀行是在联接中从一个表传递到下一个表的那些行。通常，优化器会尝试将前缀计数较低的表放在连接顺序的早期，以防止行组合的数量快速增加。如果优化器可以使用有关从一个表中选择并传递到下一个表的行的条件的信息，那么它就可以更准确地计算行估计值并选择最佳执行计划。</p>
<p>如果没有条件过滤，表的前缀行计数将基于WHERE子句根据优化器选择的访问方法所选择的估计行数。条件筛选使优化器能够在WHERE子句中使用访问方法未考虑的其他相关条件，从而改进其前缀行计数估计。例如，即使可能有一个基于索引的访问方法可用于在联接中从当前表中选择行，但在WHERE子句中也可能有用于表的附加条件，这些条件可以过滤（进一步限制）传递给下一个表的合格行的估计。</p>
<p>前缀行计数（估计在联接中从当前表传递到下一个表的行数）是行与筛选值的乘积。也就是说，前缀行计数是估计的行计数，减去估计的过滤效果。例如，如果行数为1000，筛选为20%，则条件筛选会将估计的行数1000减少到前缀行数1000 × 20% &#x3D; 1000 × .2 &#x3D; 200。</p>
<p>假设以下查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">  FROM employee JOIN department ON employee.dept_no = department.dept_no</span><br><span class="line">  WHERE employee.first_name = &#x27;John&#x27;</span><br><span class="line">  AND employee.hire_date BETWEEN &#x27;2018-01-01&#x27; AND &#x27;2018-06-01&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>employee表有1024行。</li>
<li>department表有12行。</li>
<li>这两个表都有一个关于dept_no的索引。</li>
<li>employee表在first_name上有一个索引。</li>
<li>在employee.first_name上有8行满足此条件：first_name &#x3D; ‘John’</li>
<li>在employee.hire_date上有150行满足此条件：hire_date BETWEEN ‘2018-01-01’ AND ‘2018-06-01’</li>
<li>1行满足两个条件：WHERE employee.first_name &#x3D; ‘John’ AND employee.hire_date BETWEEN ‘2018-01-01’ AND ‘2018-06-01’;</li>
</ul>
<p>如果没有条件过滤，EXPLAIN会产生如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+------------+--------+------------------+---------+---------+------+----------+</span><br><span class="line">| id | table      | type   | possible_keys    | key     | ref     | rows | filtered |</span><br><span class="line">+----+------------+--------+------------------+---------+---------+------+----------+</span><br><span class="line">| 1  | employee   | ref    | name,h_date,dept | name    | const   | 8    | 100.00   |</span><br><span class="line">| 1  | department | eq_ref | PRIMARY          | PRIMARY | dept_no | 1    | 100.00   |</span><br><span class="line">+----+------------+--------+------------------+---------+---------+------+----------+</span><br></pre></td></tr></table></figure>

<p>对于employee，name索引上的访问方法选取与名称“John”匹配的8行。没有进行过滤（filtered是100%），所以所有行都是下一个表的前缀行：前缀行计数是rows×filtered &#x3D; 8 × 100% &#x3D; 8。</p>
<p>通过条件过滤，优化器还考虑了访问方法没有考虑的WHERE子句中的条件。在本例中，优化器使用BETWEEN条件对employee.hire_date的过滤效果估计为16.31%。因此，EXPLAIN会产生如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+------------+--------+------------------+---------+---------+------+----------+</span><br><span class="line">| id | table      | type   | possible_keys    | key     | ref     | rows | filtered |</span><br><span class="line">+----+------------+--------+------------------+---------+---------+------+----------+</span><br><span class="line">| 1  | employee   | ref    | name,h_date,dept | name    | const   | 8    | 16.31    |</span><br><span class="line">| 1  | department | eq_ref | PRIMARY          | PRIMARY | dept_no | 1    | 100.00   |</span><br><span class="line">+----+------------+--------+------------------+---------+---------+------+----------+</span><br></pre></td></tr></table></figure>

<p>现在前缀行数为rows×filtered &#x3D; 8 × 16.31% &#x3D; 1.3，这更接近于实际数据集。</p>
<p>要控制优化器是否考虑其他筛选条件，请使用optimizer_switch系统变量的condition_fanout_filter标志，默认启用</p>
<p>如果优化器高估了条件筛选的效果，则性能可能会比不使用条件筛选时更差。在这种情况下，这些技术可能有助于：</p>
<ul>
<li>如果某个列没有索引，那么对它进行索引，这样优化器就可以获得一些关于列值分布的信息，并可以改进其行估计。</li>
<li>同样，如果没有列直方图信息可用，则生成一个直方图</li>
<li>更改连接顺序。实现这一点的方法包括连接顺序优化器提示</li>
<li>禁用会话的条件筛选：SET optimizer_switch &#x3D; ‘condition_fanout_filter&#x3D;off’;</li>
</ul>
<h4 id="order-by-优化"><a href="#order-by-优化" class="headerlink" title="order by 优化"></a>order by 优化</h4><p>要提高ORDER BY的速度，请检查是否可以让MySQL使用索引而不是额外的排序阶段。如果无法做到这一点，请尝试以下策略：</p>
<ul>
<li>增加sort_buffer_size变量值。理想情况下，该值应该足够大，以使整个结果集能够放入排序缓冲区（以避免写入磁盘和合并过程）。</li>
<li>请注意，存储在排序缓冲区中的列值的大小受max_sort_length系统变量值的影响。例如，如果元组存储长字符串列的值，并且您增加max_sort_length的值，则排序缓冲区元组的大小也会增加，并且可能需要您增加sort_buffer_size。</li>
<li>要监视合并通道的数量（合并临时文件），请检查Sort_merge_passes状态变量。</li>
<li>增加read_rnd_buffer_size变量值，以便一次读取更多行。</li>
<li>将tmpdir系统变量更改为指向具有大量可用空间的专用文件系统。变量值可以列出以循环方式使用的多个路径;您可以使用此功能将负载分散到多个目录。在Unix上用冒号（：）分隔路径，在Windows上用冒号（;）分隔路径。路径应该命名位于不同物理磁盘上的文件系统中的目录，而不是同一磁盘上的不同分区。</li>
</ul>
<p>如果EXPLAIN输出的Extra列不包含Using filesort，则使用索引，不执行filesort。<br>如果EXPLAIN输出的Extra列包含Using filesort，则不使用索引并执行filesort。</p>
<h4 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h4><p>group by其实就是构建一个hash表，key就是group by的key, value包括Min max之类的值。</p>
<p>将索引用于GROUP BY的最重要的先决条件是，所有GROUP BY列都引用来自同一索引的属性，并且索引按顺序存储其键（例如，对于BTREE索引是这样，但对于HASH索引则不是这样）。索引访问是否可以取代临时表的使用还取决于查询中使用索引的哪些部分、为这些部分指定的条件以及所选的聚合函数。</p>
<p>有两种方法可以通过索引访问执行GROUP BY查询，下面几节将详细介绍。第一个方法将分组操作与所有范围谓词（如果有）一起应用。第二种方法首先执行范围扫描，然后对结果元组进行分组。</p>
<ul>
<li>松散索引扫描</li>
<li>紧密索引扫描</li>
</ul>
<p>松散索引扫描</p>
<p>如果松散索引扫描适用于查询，则EXPLAIN输出在Extra列中显示Using index for group-by。</p>
<p>假设在表t1（c1，c2，c3，c4）上存在索引idx（c1，c2，c3）。松散索引扫描访问方法可用于以下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT c1, c2 FROM t1 GROUP BY c1, c2;</span><br><span class="line">SELECT DISTINCT c1, c2 FROM t1;</span><br><span class="line">SELECT c1, MIN(c2) FROM t1 GROUP BY c1;</span><br><span class="line">SELECT c1, c2 FROM t1 WHERE c1 &lt; const GROUP BY c1, c2;</span><br><span class="line">SELECT MAX(c3), MIN(c3), c1, c2 FROM t1 WHERE c2 &gt; const GROUP BY c1, c2;</span><br><span class="line">SELECT c2 FROM t1 WHERE c1 &lt; const GROUP BY c1, c2;</span><br><span class="line">SELECT c1, c2 FROM t1 WHERE c3 = const GROUP BY c1, c2;</span><br></pre></td></tr></table></figure>

<p>以下查询无法使用此快速选择方法执行，原因如下：</p>
<ul>
<li>除了MIN（）或MAX（）之外，还有其他聚合函数：</li>
<li>GROUP BY子句中的列不构成索引的最左边前缀：</li>
<li>该查询引用位于GROUP BY部分之后的键的一部分，并且对于该部分，不存在与常量相等的情况：</li>
</ul>
<p>假设在表t1（c1，c2，c3，c4）上存在索引idx（c1，c2，c3）。松散索引扫描访问方法可用于以下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT c1), SUM(DISTINCT c1) FROM t1;</span><br><span class="line"></span><br><span class="line">SELECT COUNT(DISTINCT c1, c2), COUNT(DISTINCT c2, c1) FROM t1;</span><br></pre></td></tr></table></figure>

<p>紧密索引扫描</p>
<p>紧密索引扫描可以是全索引扫描，也可以是范围索引扫描，具体取决于查询条件。</p>
<p>当不满足松散索引扫描的条件时，仍然可以避免为GROUP BY查询创建临时表。如果WHERE子句中有范围条件，则此方法只读取满足这些条件的键。否则，它将执行索引扫描。由于此方法读取WHERE子句定义的每个范围中的所有键，或者在没有范围条件的情况下扫描整个索引，因此称为紧密索引扫描。使用紧密索引扫描时，只有在找到满足范围条件的所有键后才执行分组操作。</p>
<p>要使此方法起作用，查询中的所有列都有一个常量相等条件就足够了，该条件引用位于GROUP BY键之前或之间的键部分。相等条件中的常数填充搜索关键字中的任何“空白“，以便可以形成索引的完整前缀。然后，这些索引前缀可以用于索引查找。如果GROUP BY结果需要排序，并且可以形成作为索引前缀的搜索键，MySQL也避免了额外的排序操作，因为在有序索引中使用前缀搜索已经按顺序检索了所有键。</p>
<p>假设在表t1（c1，c2，c3，c4）上存在索引idx（c1，c2，c3）。以下查询不适用于前面描述的松散索引扫描访问方法，但仍适用于紧密索引扫描访问方法。<br>GROUP BY中有一个间隙，但它被条件c2 &#x3D; ‘a’覆盖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT c1, c2, c3 FROM t1 WHERE c2 = &#x27;a&#x27; GROUP BY c1, c3;</span><br></pre></td></tr></table></figure>

<p>GROUP BY并不从键的第一部分开始开始，但有一个条件为该部分提供了一个常量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT c1, c2, c3 FROM t1 WHERE c1 = &#x27;a&#x27; GROUP BY c2, c3;</span><br></pre></td></tr></table></figure>

<h4 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h4><p>比如order by + limit可以启用topN排序，不需要对所有元素排序。</p>
<p>如果将LIMIT与DISTINCT结合使用，MySQL会在找到row_count唯一行时立即停止。</p>
<p>在某些情况下，GROUP BY可以通过按顺序阅读索引（或对索引进行排序），然后计算摘要直到索引值更改来解决。在这种情况下，LIMIT不会计算任何不必要的GROUP BY值。</p>
<p>一旦MySQL向客户端发送了所需的行数，它就会中止查询，除非您使用SQL_CALC_FOUND_ROWS。在这种情况下，可以使用 SELECT FOUND_ROWS() 检索行数。</p>
<p>如果ORDER BY没有使用索引，但也存在LIMIT子句，则优化器可以避免使用合并文件，并使用内存中的文件排序操作对内存中的行进行排序。</p>
<p>总之一句话，最好加上limit</p>
<h4 id="子查询物化"><a href="#子查询物化" class="headerlink" title="子查询物化"></a>子查询物化</h4><p>将子查询的结果保存在临时表，而不是每次都执行。需要开启optimizer_switch &#x3D; materialization </p>
<h4 id="其他优化技巧"><a href="#其他优化技巧" class="headerlink" title="其他优化技巧"></a>其他优化技巧</h4><p>如果应用程序发出多个数据库请求以执行相关更新，则将这些语句组合到存储例程中可以提高性能。同样，如果应用程序基于多个列值或大量数据计算单个结果，则将计算组合到一个函数中可以提高性能。然后，所产生的快速数据库操作可供其他查询、应用程序甚至用不同编程语言编写的代码重用。</p>
<p>如果可能，将报告分类为“实时“或“统计“，其中统计报告所需的数据仅从实时数据定期生成的汇总表中创建。</p>
<p>如果您的数据不符合行列表结构，则可以将数据打包并存储到BLOB列中。在这种情况下，您必须在应用程序中提供代码来打包和解包信息，但这可能会节省I&#x2F;O操作来读取和写入相关值集。</p>
<p>对于Web服务器，将图像和其他二进制资产存储为文件，路径名存储在数据库中，而不是文件本身。大多数Web服务器更擅长缓存文件而不是数据库内容，因此使用文件通常更快。</p>
<p>如果你真的需要很高的速度，看看底层的MySQL接口。例如，通过直接访问MySQLInnoDB或MyISAM存储引擎，与使用SQL接口相比，您可以获得显著的速度提升。</p>
<p>复制可以为某些操作提供性能优势。您可以在副本之间分发客户端检索以分割负载。为了避免在进行备份时降低源的速度，可以使用复制副本进行备份。</p>
<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><p>如果一个表有许多列，并且您查询了许多不同的列组合，那么将不太常用的数据拆分到单独的表中，每个表有几个列，然后通过从主表复制数字ID列将它们关联回主表，这样可能会更有效。这样，每个小表都可以有一个用于快速查找其数据的主键，并且您可以使用连接操作仅查询所需的列集。根据数据的分布方式，查询可能会执行更少的I&#x2F;O并占用更少的缓存内存，因为相关的列在磁盘上打包在一起。</p>
<p>最常见的索引类型涉及单个列，将该列的值的副本存储在数据结构中，允许快速查找具有相应列值的行。B树数据结构允许索引快速查找WHERE子句中与&#x3D;、&gt;、≤、BETWEEN、IN等运算符对应的特定值、一组值或一个值范围。</p>
<p>所有存储引擎都支持每个表至少16个索引，总索引长度至少为256字节。大多数存储引擎有更高的限制。</p>
<p>可以对字符串创建前n个字符串的索引，减少索引长度。</p>
<p>FULLTEXT索引用于全文搜索。只有InnoDB和MyISAM存储引擎支持FULLTEXT索引，并且只支持CHAR、VARCHAR和TEXT列。索引总是在整个列上进行，并且不支持列前缀索引。</p>
<p>存储引擎收集有关表的统计信息供优化器使用。表统计信息基于值组，其中值组是具有相同键前缀值的一组行。出于优化目的，一个重要的统计信息是平均值组大小。</p>
<p>随着索引的平均值组大小的增加，索引对这两个目的的用处越来越小，因为每次查找的平均行数增加了：为了使索引有利于优化，最好每个索引值针对表中的少量行。当给定的索引值产生大量的行时，索引就不那么有用了，MySQL也不太可能使用它。</p>
<p>平均值组大小与表基数有关，表基数是值组的数量。SHOW INDEX语句显示基于N&#x2F;S的基数值，其中N是表中的行数，S是平均值组大小。该比率产生表中的值组的近似数量。<br>对于基于&#x3D;运算符的连接，NULL与非NULL值不同：当expr1或expr2（或两者）为NULL时，expr1&#x3D;expr2不为真。这会影响tbl_name.key&#x3D;expr形式的比较的ref访问：如果expr的当前值为NULL，MySQL不会访问表，因为比较不可能为true。</p>
<p>对于&#x3D;比较，表中有多少NULL值并不重要。出于优化目的，相关值是非NULL值组的平均大小。但是，MySQL目前还不能收集或使用该平均大小。</p>
<p>对于InnoDB和MyISAM表，您可以分别通过innodb_stats_method和myisam_stats_method系统变量来控制表统计信息的收集。这些变量有三个可能的值，其不同之处如下：</p>
<ul>
<li>当变量设置为nulls_equal时，所有NULL值都被视为相同的（即，它们都形成一个值组）。如果NULL值组大小远高于平均非NULL值组大小，则此方法会使平均值组大小向上倾斜。这使得索引在优化器看来没有它在查找非NULL值的联接中实际上那么有用。因此，nulls_equal方法可能会导致优化器在应该使用索引进行ref访问时不使用索引。</li>
<li>当变量设置为nulls_unequal时，NULL值不被认为是相同的。相反，每个NULL值形成一个大小为1的单独的值组。如果有许多NULL值，此方法会使平均值组大小向下倾斜。如果非NULL值组的平均大小很大，则将每个NULL值计为大小为1的组会导致优化器过高估计查找非NULL值的联接的索引值。因此，nulls_unequal方法可能会导致优化器在其他方法可能更好的情况下使用此索引进行ref查找。</li>
<li>当变量设置为nulls_ignored时，NULL值将被忽略。</li>
</ul>
<h4 id="hash-index"><a href="#hash-index" class="headerlink" title="hash index"></a>hash index</h4><p>它们仅用于使用&#x3D;或&lt;&#x3D;&gt;运算符的相等比较（但非常快）。它们不用于查找值范围的比较运算符，如&lt;。依赖于这种单值查找的系统被称为“键值存储”;要将MySQL用于此类应用程序，请尽可能使用散列索引。</p>
<p>优化器不能使用哈希索引来加速ORDER BY操作。(This索引类型不能用于按顺序搜索下一个条目。)</p>
<p>MySQL无法确定两个值之间大约有多少行（这是由范围优化器用来决定使用哪个索引）。如果您将MyISAM或InnoDB表更改为哈希索引的MEMORY表，这可能会影响某些查询。</p>
<p>只能使用整个键来搜索行。(With B树索引，键的任何最左边的前缀都可以用来查找行。)</p>
<h4 id="b树索引"><a href="#b树索引" class="headerlink" title="b树索引"></a>b树索引</h4><p>b-tree索引通常比hash索引更好</p>
<p>B树索引可用于使用&#x3D;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;或BETWEEN运算符的表达式中的列比较。如果LIKE的参数是不以通配符开头的常量字符串，则该索引也可用于LIKE比较。</p>
<h4 id="索引扩展"><a href="#索引扩展" class="headerlink" title="索引扩展"></a>索引扩展</h4><p>InnoDB会自动扩展每个二级索引，将主键列追加到二级索引上。考虑下面的表定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t1 (</span><br><span class="line">  i1 INT NOT NULL DEFAULT 0,</span><br><span class="line">  i2 INT NOT NULL DEFAULT 0,</span><br><span class="line">  d DATE DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (i1, i2),</span><br><span class="line">  INDEX k_d (d)</span><br><span class="line">) ENGINE = InnoDB;</span><br></pre></td></tr></table></figure>

<p>此表定义列（i1，i2）上的主键。它还在列（d）上定义了一个二级索引k_d，但InnoDB内部扩展了这个索引，并将其视为列（d，i1，i2）。</p>
<p>考虑查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = &#x27;2000-01-01&#x27;</span><br></pre></td></tr></table></figure>

<p>如果不扩展索引，那么查询计划如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t1</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: PRIMARY,k_d</span><br><span class="line">          key: k_d</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 5</span><br><span class="line">        Extra: Using where; Using index</span><br></pre></td></tr></table></figure>

<p>如果扩展索引，那么查询计划如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = &#x27;2000-01-01&#x27;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t1</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: PRIMARY,k_d</span><br><span class="line">          key: k_d</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const,const</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: Using index</span><br></pre></td></tr></table></figure>

<ul>
<li>key_len从4个字节变为8个字节，表明键查找使用列d和i1，而不仅仅是d。</li>
<li>ref值从const变为const，const，因为键查找使用两个键部分，而不是一个。</li>
<li>行数从5减少到1，表明InnoDB应该需要检查更少的行来生成结果。</li>
<li>Extra值从Using where; Using index更改为Using index。这意味着可以仅使用索引读取行，而无需查询数据行中的列。</li>
</ul>
<h3 id="优化数据库结构"><a href="#优化数据库结构" class="headerlink" title="优化数据库结构"></a>优化数据库结构</h3><p>设计表以最小化它们在磁盘上的空间。这可以通过减少写入磁盘和从磁盘读取的数据量来实现巨大的改进。较小的表通常需要较少的主内存，而它们的内容在查询执行期间被主动处理。表数据的任何空间减少都会导致索引变小，从而可以更快地处理。</p>
<p>尽可能使用最有效（最小）的数据类型。MySQL有许多专门的类型，可以节省磁盘空间和内存。例如，如果可能的话，使用较小的整数类型来获得较小的表。MEDIUMINT通常是比INT更好的选择，因为MEDIUMINT列使用的空间少25%。</p>
<p>如果可能的话，将列设置为NOT NULL。它通过更好地使用索引和消除测试每个值是否为NULL的开销，使SQL操作更快。您还节省了一些存储空间，每列一位。如果你真的需要空值在你的表，使用它们。只要避免允许每列都有NULL值的默认设置即可。</p>
<p>InnoDB表默认使用DYNAMIC行格式创建。要使用DYNAMIC以外的行格式，请配置innodb_default_row_form，或在CREATE TABLE或ALTER TABLE语句中显式指定ROW_FORMAT选项。</p>
<p>要通过以压缩形式存储表数据来进一步最小化空间，请在创建InnoDB表时指定ROW_FORMAT&#x3D;COMPRESSED，或者在现有的MyISAM表上运行myisampack命令。（InnoDB压缩表是可读和可写的，而MyISAM压缩表是只读的。</p>
<p>表的主索引应尽可能短。这使得每一行的识别变得简单而有效。对于InnoDB表，主键列在每个二级索引条目中是重复的，所以如果有很多二级索引，短主键可以节省相当多的空间。</p>
<p>只创建提高查询性能所需的索引。索引有利于检索，但会降低插入和更新操作的速度。如果您主要通过搜索列的组合来访问表，请在这些列上创建单个复合索引，而不是为每列创建单独的索引。索引的第一部分应该是最常用的列。如果在从表中选择时总是使用许多列，则索引中的第一列应该是具有最多重复项的列，以获得更好的索引压缩。</p>
<p>如果一个长字符串列很可能在第一个字符数上有一个唯一的前缀，那么最好只索引这个前缀，使用MySQL对在列的最左边部分创建索引的支持</p>
<p>在某些情况下，将经常扫描的表分成两部分可能是有益的。如果它是一个动态格式的表，并且可以使用一个较小的静态格式表，以便在扫描表时查找相关行，则尤其如此。</p>
<p>在具有相同数据类型的不同表中删除具有相同信息的列，以加快基于相应列的联接速度。</p>
<p>保持列名称简单，这样您就可以在不同的表中使用相同的名称，并简化连接查询。例如，在名为customer的表中，使用name而不是customer_name的列名。要使您的名称可移植到其他SQL服务器，请考虑将它们保持在18个字符以下。</p>
<p>通常情况下，尽量保持所有数据都是非冗余的（观察数据库理论中所谓的第三范式）。与其重复冗长的值（如名称和地址），不如为它们分配唯一的ID，根据需要在多个较小的表中重复这些ID，并通过引用join子句中的ID在查询中连接表。</p>
<p>如果速度比磁盘空间和保持多个数据副本的维护成本更重要，例如在分析大型表中所有数据的商业智能场景中，您可以放松规范化规则，复制信息或创建汇总表以获得更快的速度。</p>
<p>对于可以表示为字符串或数字的唯一ID或其他值，最好使用数字列而不是字符串列。由于大数值可以存储在比相应字符串更少的字节中，因此传输和比较它们的速度更快，占用的内存更少。</p>
<p>如果您使用的是数值数据，在许多情况下，从数据库（使用实时连接）访问信息比访问文本文件更快。数据库中的信息可能以比文本文件更紧凑的格式存储，因此访问它涉及的磁盘访问较少。还可以在应用程序中保存代码，因为这样可以避免分析文本文件以查找行和列边界。</p>
<p>当不需要特定于语言的排序规则功能时，使用二进制排序规则顺序进行快速比较和排序操作。可以使用BINARY运算符在特定查询中使用二进制排序规则。</p>
<p>当比较来自不同列的值时，尽可能使用相同的字符集和排序规则声明这些列，以避免在运行查询时进行字符串转换。</p>
<p>对于小于8 KB的列值，请使用二进制VARCHAR而不是BLOB。GROUP BY和ORDER BY子句可以生成临时表，如果原始表不包含任何BLOB列，则这些临时表可以使用MEMORY存储引擎。</p>
<p>如果一个表包含字符串列，如名称和地址，但许多查询不检索这些列，请考虑将字符串列拆分到一个单独的表中，并在必要时使用带有外键的联接查询。当MySQL从一行中检索任何值时，它会读取一个包含该行（可能还有其他相邻行）所有列的数据块。保持每一行都很小，只包含最常用的列，这样就可以在每个数据块中容纳更多的行。这样的紧凑表减少了常见查询的磁盘I&#x2F;O和内存使用。</p>
<p>当你使用一个随机生成的值作为InnoDB表中的主键时，如果可能的话，在它前面加上一个升序值，比如当前的日期和时间。当连续的主值物理上存储在彼此附近时，InnoDB可以更快地插入和检索它们。</p>
<h4 id="mysql打开和关闭表"><a href="#mysql打开和关闭表" class="headerlink" title="mysql打开和关闭表"></a>mysql打开和关闭表</h4><p>MySQL是多线程的，因此可能有许多客户端同时对给定的表发出查询。为了最大限度地减少多个客户端会话在同一个表上具有不同状态的问题，该表由每个并发会话独立打开。这会使用额外的内存，但通常会提高性能。对于MyISAM表，每个打开表的客户端的数据文件都需要一个额外的文件描述符。(By相反，索引文件描述符在所有会话之间共享。）</p>
<p>table_open_cache和max_connections系统变量影响服务器保持打开状态的最大文件数。如果您增加这两个值中的一个或两个，您可能会遇到操作系统对每个进程打开的文件描述符数量施加的限制。许多操作系统允许您增加打开文件限制，尽管方法因系统而异。请参阅操作系统文档，以确定是否可以增加限制以及如何增加限制。</p>
<p>table_open_cache与max_connections相关。例如，对于200个并发运行的连接，指定表缓存大小至少为200 *N，其中N是您执行的任何查询中每个连接的最大表数。您还必须为临时表和文件保留一些额外的文件描述符。</p>
<p>确保您的操作系统可以处理table_open_cache设置所暗示的打开文件描述符的数量。如果table_open_cache设置得太高，MySQL可能会耗尽文件描述符，并出现拒绝连接或无法执行查询等症状。</p>
<p>打开表的该高速缓存保持在table_open_cache条目的级别。服务器在启动时自动调整该高速缓存的大小。要显式设置大小，请在启动时设置table_open_cache系统变量。MySQL可能会临时打开比这更多的表来执行查询，如本节后面所述。</p>
<p>MySQL在以下情况下关闭未使用的表并将其从表缓存中删除：</p>
<ul>
<li>当该高速缓存已满并且线程试图打开不在该高速缓存中的表时。</li>
<li>当该高速缓存包含多个table_open_cache条目，并且该高速缓存中的某个表不再被任何线程使用时。</li>
<li>当发生表刷新操作时。当有人发出FLUSH TABLES语句或执行mysqladmin flush-tables或mysqladmin refresh命令时，就会发生这种情况。</li>
</ul>
<p>当表缓存填满时，服务器使用以下过程来定位要使用的缓存条目：用途：</p>
<ul>
<li>从最近最少使用的表开始，释放当前未使用的表。</li>
<li>如果必须打开一个新表，但该高速缓存已满，无法释放任何表，则会根据需要临时扩展该高速缓存。当该高速缓存处于临时扩展状态并且表从已使用状态变为未使用状态时，关闭该表并从该高速缓存释放该表。</li>
</ul>
<p>为每个并发访问打开一个MyISAM表。这意味着如果两个线程访问同一个表，或者如果一个线程在同一个查询中访问该表两次（例如，通过将该表连接到其自身），则需要打开该表两次。每个并发打开都需要表缓存中的一个条目。第一次打开任何MyISAM表都需要两个文件描述符：一个用于数据文件，一个用于索引文件。表的每次额外使用只需要数据文件的一个文件描述符。索引文件描述符在所有线程之间共享。</p>
<p>要确定表缓存是否太小，请检查Opened_tables状态变量，该变量指示自服务器启动以来打开表的操作数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW GLOBAL STATUS LIKE &#x27;Opened_tables&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Opened_tables | 2741  |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure>

<p>如果该值非常大或增加得很快，即使您没有发出很多FLUSH TABLES语句，也要在服务器启动时增加table_open_cache值。</p>
<h3 id="优化innodb表"><a href="#优化innodb表" class="headerlink" title="优化innodb表"></a>优化innodb表</h3><p>一旦数据达到稳定的大小，或者一个不断增长的表增加了几十或几百兆字节，就可以考虑使用OPTIMIZE TABLE语句来重新组织表并压缩任何浪费的空间。重新组织的表需要更少的磁盘I&#x2F;O来执行全表扫描。这是一种简单的技术，当其他技术（如提高索引使用率或调优应用程序代码）不实用时，它可以提高性能。</p>
<p>OPTIMIZE TABLE复制表的数据部分并重建索引。好处来自于改进了索引中的数据打包，并减少了表空间和磁盘上的碎片。收益因每个表中的数据而异。您可能会发现，某些表有显著的收益，而另一些表没有，或者收益会随着时间的推移而减少，直到您下一次优化表。如果表很大，或者正在重建的索引不适合缓冲池，则此操作可能会很慢。向表中添加大量数据后的第一次运行通常比以后的运行慢得多。</p>
<p>在InnoDB中，拥有一个长的PRIMARY KEY（一个单独的列和一个很长的值，或者几个列组成一个很长的复合值）会浪费大量的磁盘空间。行的主键值在指向同一行的所有辅助索引记录中重复。</p>
<p>使用VARCHAR数据类型而不是CHAR来存储可变长度字符串或具有许多NULL值的列。CHAR（N）列总是需要N个字符来存储数据，即使字符串更短或其值为NULL。较小的表更适合缓冲池，并减少磁盘I&#x2F;O。</p>
<p>当使用COMPACT行格式（默认的InnoDB格式）和可变长度字符集（如utf8 mb 4或sjis）时，CHAR（N）列占用的空间量是可变的，但仍然至少是N个字节。</p>
<p>对于较大的表或包含大量重复文本或数值数据的表，请考虑使用COMPRESSED行格式。将数据放入缓冲池或执行全表扫描所需的磁盘I&#x2F;O更少。在做出永久性决定之前，请测量使用COMPRESSED与COMPACT行格式可以实现的压缩量。</p>
<p>MySQL的默认设置AUTOCOMMIT&#x3D;1会对忙碌的数据库服务器施加性能限制。在可行的情况下，通过发出SET AUTOCOMMIT&#x3D;0或START TRANSACTION语句，然后在进行所有更改后发出COMMIT语句，将多个相关的数据更改操作包装到单个事务中。</p>
<p>如果事务对数据库进行了修改，InnoDB必须在每次事务提交时将日志刷新到磁盘。当每次更改后都执行一次提交（与默认的自动提交设置一样）时，存储设备的I&#x2F;O吞吐量会对每秒的潜在操作数设置上限。</p>
<p>或者，对于仅由单个SELECT语句组成的事务，打开AUTOCOMMIT有助于InnoDB识别只读事务并优化它们。</p>
<p>避免在插入、更新或删除大量行后执行回滚。如果一个大的事务降低了服务器的性能，回滚它会使问题变得更糟，可能需要几倍于原始数据更改操作的时间来执行。终止数据库进程没有帮助，因为回滚在服务器启动时再次开始。</p>
<p>为了尽量减少发生此问题的可能性：</p>
<ul>
<li>增加缓冲池的大小，以便所有数据更改都可以缓存，而不是立即写入磁盘。</li>
<li>设置innodb_change_buffering&#x3D;all，以便除了插入操作外，还缓冲更新和删除操作。</li>
<li>考虑在大数据更改操作期间定期发出COMMIT语句，可能会将单个删除或更新分解为多个语句，这些语句对较少的行进行操作。</li>
</ul>
<p>InnoDB可以避免为已知为只读的事务设置事务ID（TRX_ID字段）的开销。只有可能执行写操作或锁定读取（例如SELECT…for update）的事务才需要事务ID。更新。消除不必要的事务ID可以减少每次查询或数据更改语句构造读视图时所查询的内部数据结构的大小。</p>
<p>InnoDB在以下情况下检测只读事务：</p>
<ul>
<li>该事务通过 START TRANSACTION READ ONLY 语句开始。在这种情况下，尝试对数据库进行更改（对于InnoDB，MyISAM或其他类型的表）会导致错误，并且事务将继续处于只读状态.您仍然可以在只读事务中对会话特定的临时表进行更改，或者对它们发出锁定查询，因为这些更改和锁定对任何其他事务都不可见。</li>
<li>autocommit设置被打开，这样就保证了事务是一个单一的语句，并且组成事务的单一语句是一个“非锁定“的SELECT语句。也就是说，SELECT不使用FOR UPDATE或 SHARED MODE子句。</li>
<li>事务在没有READ ONLY选项的情况下启动，但尚未执行任何更新或显式锁定行的语句。在需要更新或显式锁定之前，事务将保持只读模式。<br>因此，对于像报表生成器这样的读取密集型应用程序，您可以通过将InnoDB查询分组到 START TRANSACTION READ ONLY 和COMMIT中，或者在运行SELECT语句之前打开自动提交设置，或者简单地避免任何散布在查询中的数据更改语句来优化InnoDB查询序列。</li>
</ul>
<p>增加redo log文件的大小。当InnoDB已经写满redo log文件时，它必须在检查点中将缓冲池的修改内容写入磁盘。小的redo log文件会导致许多不必要的磁盘写入。</p>
<p>redo log文件大小由innodb_redo_log_capacity决定。InnoDB尝试维护32个相同大小的重做日志文件，每个文件等于1&#x2F;32 *innodb_redo_log_capacity。因此，更改innodb_redo_log_capacity设置会更改redo log文件的大小。</p>
<p>考虑增加日志缓冲区的大小。大型日志缓冲区使大型事务能够运行，而无需在事务提交之前将日志写入磁盘。因此，如果您有更新、插入或删除许多行的事务，那么增大日志缓冲区可以节省磁盘I&#x2F;O。日志缓冲区大小是使用innodb_log_buffer_size配置选项配置的，该选项可以动态配置。</p>
<p>配置innodb_log_write_ahead_size配置选项以避免“写时读“。此选项定义重做日志的预写块大小。设置innodb_log_write_ahead_size以匹配操作系统或文件系统缓存块大小。当由于重做日志的预写块大小与操作系统或文件系统缓存块大小不匹配而导致重做日志块未完全缓存到操作系统或文件系统时，发生写时读。</p>
<p>innodb_log_write_ahead_size的有效值是InnoDB日志文件块大小的倍数（2n）。最小值是InnoDB日志文件块大小（512）。当指定最小值时，不会发生写前操作。最大值等于innodb_page_size值。如果您为innodb_log_write_ahead_size指定的值大于innodb_page_size值，则innodb_log_write_ahead_size设置将被截断为innodb_page_size值。</p>
<p>将innodb_log_write_ahead_size值设置得相对于操作系统或文件系统缓存块大小太低会导致写时读。将该值设置得太高可能会对日志文件写入的fsync性能产生轻微影响，因为会同时写入多个块。</p>
<p>MySQL提供了专用的日志写入器线程，用于将重做日志记录从日志缓冲区写入系统缓冲区，并将系统缓冲区刷新到重做日志文件。您可以使用innodb_log_writer_threads变量启用或禁用日志写入器线程。专用日志写入器线程可以提高高并发系统的性能，但对于低并发系统，禁用专用日志写入器线程可以提供更好的性能。</p>
<p>InnoDB使用Linux上的异步I&#x2F;O子系统（本地AIO）来执行数据文件页面的预读和写入请求。此行为由innodb_use_native_aio配置选项控制，默认情况下启用该选项。对于本机AIO，I&#x2F;O调度程序的类型对I&#x2F;O性能的影响更大。通常，推荐使用noop和deadline I&#x2F;O编译器。执行基准测试以确定哪个I&#x2F;O调度程序可为您的工作负载和环境提供最佳结果。有关更多信息</p>
<h3 id="查询执行计划"><a href="#查询执行计划" class="headerlink" title="查询执行计划"></a>查询执行计划</h3><p>当EXPLAIN与可解释语句一起使用时，MySQL显示来自优化器的有关语句执行计划的信息。也就是说，MySQL解释了它将如何处理语句，包括有关表如何连接以及顺序的信息。</p>
<p>对于SELECT语句，EXPLAIN会生成可使用SHOW WARNINGS显示的其他执行计划信息。</p>
<p>EXPLAIN对于检查涉及分区表的查询很有用。</p>
<p>FORMAT选项可用于选择输出格式。TRADITIONAL以表格格式显示输出。如果不存在FORMAT选项，这是默认值。JSON格式以JSON格式显示信息。</p>
<p>优化器跟踪有时可以提供与EXPLAIN互补的信息。但是，优化器跟踪格式和内容在不同版本之间会发生变化。</p>
<p>如果您认为应该使用索引而没有使用索引，那么运行ANALYZE TABLE来更新表统计信息，例如键的基数，这可能会影响优化器做出的选择。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>EXPLAIN为SELECT语句中使用的每个表返回一行信息。它按照MySQL在处理语句时读取表的顺序列出输出中的表。这意味着MySQL从第一个表中读取一行，然后在第二个表中找到匹配的行，然后在第三个表中找到匹配的行，依此类推。当所有表都被处理完时，MySQL输出所选的列，并回溯表列表，直到找到一个有更多匹配行的表。从该表中读取下一行，然后处理下一个表。</p>
<p>本节介绍EXPLAIN生成的输出列。后面的部分提供了有关类型和附加列的其他信息。</p>
<p>EXPLAIN的每个输出行提供有关一个表的信息。每一行都包含表10 - 1“EXPLAIN输出列”中总结的值，并在下表中进行了更详细的描述。列名显示在表的第一列中;第二列提供使用FORMAT&#x3D;JSON时输出中显示的等效属性名。</p>
<ul>
<li>id: SELECT标识符。这是查询中SELECT的序号。如果行引用其他行的联合结果，则该值可以为NULL。在这种情况下，表列显示一个类似&lt;unionM，N&gt;的值，以指示该行引用id值为M和N的行的并集。</li>
<li>select type: SELECT的类型，可以是下表中显示的任何类型。JSON格式的EXPLAIN将SELECT类型公开为query_block的属性，除非它是SIMPLE或PRIMARY。JSON名称（如适用）也显示在表中。<ul>
<li>SIMPLE: 简单sql，不使用union或子查询</li>
<li>PRIMARY: 最外层查询</li>
<li>UNION: UNION的第二个或以后的select</li>
<li>DEPENDENT UNION: UNION中的第二个或以后的SELECT语句，取决于外部查询</li>
<li>UNION RESULT: UNION的结果</li>
<li>SUBQUERY： 子查询</li>
<li>DEPENDENT SUBQUERY： 子查询的第一个select,取决于外部查询</li>
<li>DERIVED： 派生表</li>
<li>DEPENDENT DERIVED：派生表依赖于另一个表</li>
<li>MATERIALIZED：物化子查询</li>
<li>UNCACHEABLE SUBQUERY： 一个子查询，其结果无法缓存，并且必须为外部查询的每一行重新评估</li>
<li>UNCACHEABLE UNION：属于不可缓存子查询的UNION中的第二个或以后的选择</li>
</ul>
</li>
<li>table: 表名称</li>
<li>partitions: 查询将从中匹配记录的分区。对于未分区的表，该值为NULL。</li>
<li>type: 连接类型</li>
<li>possible_keys：possible_keys列表示MySQL可以从中选择查找此表中的行的索引。请注意，该列与EXPLAIN输出中显示的表顺序完全无关。这意味着possible_keys中的某些键在实际中可能无法使用生成的表顺序。如果此列为NULL（或在JSON格式的输出中未定义），则没有相关索引。在这种情况下，您可以通过检查WHERE子句来检查它是否引用了适合索引的某个或某些列，从而提高查询的性能。如果是，请创建一个适当的索引，并再次使用EXPLAIN检查查询。</li>
<li>key：key列表示MySQL实际决定使用的键（索引）。如果MySQL决定使用一个可能的_keys索引来查找行，则该索引将作为键值列出。对于InnoDB，即使查询也选择了主键，二级索引也可能覆盖选定的列，因为InnoDB将主键值与每个二级索引一起存储。如果key为NULL，则MySQL找不到可以更有效地执行查询的索引。</li>
<li>key_len：key_len列表示MySQL决定使用的键的长度。key_len的值使您能够确定MySQL实际使用了多部分键的多少部分。如果key列显示NULL，key_len列也显示NULL。</li>
<li>ref：ref列显示将哪些列或常数与键列中命名的索引进行比较，以从表中选择行。</li>
<li>rows: rows列表示MySQL认为执行查询必须检查的行数。对于InnoDB表，这个数字是一个估计值，可能并不总是准确的。</li>
<li>filtered:筛选列指示按表条件筛选的表行的估计百分比。最大值为100，这意味着未进行行筛选。值从100减小表示过滤量增加。rows显示检查的估计行数，rows×filtered显示与下表连接的行数。例如，如果行数为1000，筛选为50.00（50%），则要与下表联接的行数为1000 × 50% &#x3D; 500。</li>
<li>Extra:此列包含有关MySQL如何解析查询的其他信息。</li>
</ul>
<p>连接类型，从最好到最坏排序</p>
<ul>
<li>system: 该表只有一行,const类型的一个特例</li>
<li>const: 该表最多有一个匹配行，在查询开始时读取。因为只有一行，所以该行中的列的值可以被优化器的其余部分视为常量。const表非常快，因为它们只被读取一次。</li>
<li>eq_ref: 对于前一个表中的每个行组合，从该表中读取一行。除了system和const类型，这是最好的连接类型。当索引的所有部分都被联接使用并且索引是PRIMARY KEY或UNIQUE NOT NULL索引时，使用它。eq_ref可用于使用&#x3D;运算符进行比较的索引列。比较值可以是常数，也可以是使用在此表之前读取的表中的列的表达式。</li>
<li>ref: 对于以前表中的每个行组合，将从此表中读取具有匹配索引值的所有行。如果连接仅使用键的最左边前缀，或者键不是PRIMARY KEY或UNIQUE索引（换句话说，如果连接无法基于键值选择单行），则使用ref。如果所使用的键只匹配几行，则这是一种很好的联接类型。ref可用于使用&#x3D;或&lt;&#x3D;&gt;运算符进行比较的索引列。</li>
<li>fulltext: 连接是使用FULLTEXT索引执行的。</li>
<li>ref_or_null:这种连接类型类似于ref，但MySQL会额外搜索包含NULL值的行。这种连接类型优化最常用于解析子查询。</li>
<li>index_merge: 此联接类型指示使用索引合并优化。在这种情况下，输出行中的键列包含所使用的索引的列表，而key_len包含所使用的索引的最长键部分的列表。</li>
<li>unique_subquery: 此类型替换以下形式的某些IN子查询的eq_ref：<code>value IN (SELECT primary_key FROM single_table WHERE some_expr)</code></li>
<li>index_subquery: 这个连接类型类似于unique_subquery。它取代了IN子查询，但它适用于以下形式的子查询中的非唯一索引</li>
<li>range: 只检索给定范围内的行，并使用索引选择行。输出行中的键列指示使用的索引。key_len包含使用的最长密钥部分。此类型的ref列为NULL。当使用&#x3D;、&lt;&gt;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、IS NULL、&lt; &#x3D;&gt;、BETWEEN、LIKE或IN（）运算符中的任何一个将键列与常量进行比较时，可以使用range</li>
<li>index: 索引连接类型与ALL相同，只是索引树被扫描。<ul>
<li>如果索引是查询的覆盖索引，并且可以用于满足表中所需的所有数据，则只扫描索引树。在本例中，Extra列显示Using index。仅索引扫描通常比ALL扫描快，因为索引的大小通常小于表数据。</li>
<li>全表扫描是通过从索引中读取数据来执行的，以便按索引顺序查找数据行。使用索引不会出现在“extra”列中。</li>
</ul>
</li>
<li>all: 全表扫描</li>
</ul>
<p>extra信息,EXPLAIN输出的Extra列包含有关MySQL如何解析查询的其他信息.如果你想让你的查询尽可能快，请注意Using filesort和Using temporary的Extra列值，或者，在JSON格式的EXPLAIN输出中，using_filesort和using_temporary_table属性等于true。</p>
<ul>
<li>Backward index scan: 优化器可以在InnoDB表上使用降序索引。与使用索引一起显示。</li>
<li>Child of ‘table’ pushed join@1: 这个表在一个可以下推到NDB内核的连接中被引用为表的子表。仅在NDB集群中启用下推连接时启用。</li>
<li>const row not found: 对于 SELECT … FROM tbl_name 这样的查询，表为空。</li>
<li>Deleting all rows: 对于MySQL，一些存储引擎（如MyISAM）支持一个处理程序方法，该方法以简单快速的方式删除所有表行。如果引擎使用此优化，则会显示此额外值。</li>
<li>Distinct: MySQL正在寻找不同的值，所以它在找到第一个匹配的行后停止为当前行组合搜索更多的行。</li>
<li>FirstMatch: 半连接FirstMatch连接捷径策略用于tbl_name。</li>
<li>Full scan on NULL key: 当优化器无法使用索引查找访问方法时，作为一种回退策略，子查询优化会出现这种情况。</li>
<li>Impossible HAVING: HAVING子句始终为false，不能选择任何行。</li>
<li>Impossible WHERE: WHERE子句始终为false，不能选择任何行。</li>
<li>Impossible WHERE noticed after reading const tables: MySQL已经读取了所有的const（和系统）表，并注意到WHERE子句总是false。</li>
<li>LooseScan: 使用半连接LooseScan策略。m和n是关键部件号。</li>
<li>No matching min&#x2F;max row: 没有行满足查询条件，例如 SELECT MIN(…) FROM … WHERE condition 。</li>
<li>no matching row in const table: 对于具有联接的查询，存在空表或没有满足唯一索引条件的行的表。</li>
<li>No matching rows after partition pruning: 对于DELETE或UPDATE，优化器在分区修剪后没有发现任何要删除或更新的内容。它的含义类似于SELECT语句的Impossible WHERE。</li>
<li>No tables used: 查询没有FROM子句，或者有FROM DUAL子句。</li>
<li>Not exists: MySQL能够对查询进行LEFT JOIN优化，并且在找到一个符合LEFT JOIN条件的行后，不会检查此表中的更多行以查找前一行组合。下面是一个可以通过这种方式优化的查询类型的示例：<code>SELECT * FROM t1 LEFT JOIN t2 ON t1.id=t2.id WHERE t2.id IS NULL;</code></li>
<li>Plan isn’t ready yet: 当优化器尚未完成为在命名连接中执行的语句创建执行计划时，此值与 EXPLAIN FOR CONNECTION 一起出现。如果执行计划输出包含多行，则其中任何一行或所有行都可以具有此Extra值，具体取决于优化器确定完整执行计划的进度。</li>
<li>Range checked for each record: MySQL找不到可用的索引，但发现某些索引可能在前面表中的列值已知后使用。对于前面表中的每个行组合，MySQL检查是否可以使用range或index_merge访问方法来检索行。这不是非常快，但比执行没有索引的连接要快。</li>
<li>Recursive: 这表示该行应用于递归公用表表达式的递归SELECT部分。</li>
<li>Using filesort: MySQL必须执行一个额外的过程来找出如何按排序顺序检索行。排序是通过根据联接类型遍历所有行并为匹配WHERE子句的所有行存储排序键和该行指针来完成的。然后对键进行排序，并按排序顺序检索行。</li>
<li>Using index : 只使用索引树中的信息从表中检索列信息，而不必执行额外的查找来读取实际行。当查询仅使用属于单个索引的列时，可以使用此策略。对于具有用户定义的聚集索引的InnoDB表，即使Extra列中没有Using index，也可以使用该索引。如果type是index，key是PRIMARY，就是这种情况。</li>
<li>Using index condition: 读取表的方法是访问索引元组并首先测试它们以确定是否读取整个表行。通过这种方式，索引信息用于推迟（“下推“）阅读整个表行，除非必要。</li>
<li>Using index for group-by: Using index for group-by表示MySQL找到了一个索引，可以用于检索GROUP BY或DISTINCT查询的所有列，而无需对实际表进行任何额外的磁盘访问。此外，索引以最有效的方式使用，因此对于每个组，仅读取几个索引条目。</li>
<li>Using index for skip scan: 指示使用“跳过扫描”访问方法。</li>
<li>Using join buffer: 来自早期联接的表被逐部分读入联接缓冲区，然后使用缓冲区中的表行与当前表进行联接。（Block Nested Loop）指示使用Block Nested-Loop算法， (Batched Key Access) 指示使用Batched Key Access算法，（hash join）指示使用hash join。也就是说，EXPLAIN输出的前一行上的表中的键被缓冲，匹配的行从Using join buffer出现的行所表示的表中批量获取。</li>
<li>Using MRR: 使用多范围读取优化策略读取表。</li>
<li>Using sort_union(…), Using union(…), Using intersect(…) : 这些指示了特定的算法，该算法显示了如何为index_merge连接类型合并索引扫描。</li>
<li>Using temporary: 要解析查询，MySQL需要创建一个临时表来保存结果。如果查询包含以不同方式列出列的GROUP BY和ORDER BY子句，则通常会发生这种情况。</li>
<li>Using where: WHERE子句用于限制哪些行与下一个表匹配或发送到客户端。除非您特别打算从表中提取或检查所有行，否则如果Extra值不是Using where，并且表连接类型是ALL或index，则查询中可能存在错误。</li>
<li>Zero limit: 查询具有LIMIT 0子句，无法选择任何行。</li>
</ul>
<p>explain输出解释</p>
<p>通过取EXPLAIN输出的rows列中的值的乘积，可以很好地指示连接的好坏。这应该告诉你MySQL执行查询必须检查多少行。如果您使用max_join_size系统变量限制查询，则此行积还用于确定执行哪些多表SELECT语句以及中止哪些多表SELECT语句。</p>
<p>假设您有这里显示的SELECT语句，并且计划使用EXPLAIN检查它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT tt.TicketNumber, tt.TimeIn,</span><br><span class="line">               tt.ProjectReference, tt.EstimatedShipDate,</span><br><span class="line">               tt.ActualShipDate, tt.ClientID,</span><br><span class="line">               tt.ServiceCodes, tt.RepetitiveID,</span><br><span class="line">               tt.CurrentProcess, tt.CurrentDPPerson,</span><br><span class="line">               tt.RecordVolume, tt.DPPrinted, et.COUNTRY,</span><br><span class="line">               et_1.COUNTRY, do.CUSTNAME</span><br><span class="line">        FROM tt, et, et AS et_1, do</span><br><span class="line">        WHERE tt.SubmitTime IS NULL</span><br><span class="line">          AND tt.ActualPC = et.EMPLOYID</span><br><span class="line">          AND tt.AssignedPC = et_1.EMPLOYID</span><br><span class="line">          AND tt.ClientID = do.CUSTNMBR;</span><br></pre></td></tr></table></figure>

<p>表具有以下索引</p>
<ul>
<li>tt: ActualPC</li>
<li>tt: AssignedPC</li>
<li>tt: ClientID</li>
<li>et: EMPLOYID (primary key) </li>
<li>do: CUSTNMBR (primary key)</li>
</ul>
<p>查询计划如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">table type possible_keys key  key_len ref  rows  Extra</span><br><span class="line">et    ALL  PRIMARY       NULL NULL    NULL 74</span><br><span class="line">do    ALL  PRIMARY       NULL NULL    NULL 2135</span><br><span class="line">et_1  ALL  PRIMARY       NULL NULL    NULL 74</span><br><span class="line">tt    ALL  AssignedPC,   NULL NULL    NULL 3872</span><br><span class="line">           ClientID,</span><br><span class="line">           ActualPC</span><br><span class="line">      Range checked for each record (index map: 0x23)</span><br></pre></td></tr></table></figure>

<p>因为每个表的类型都是ALL，所以这个输出表明MySQL正在生成所有表的笛卡尔积;也就是说，每个行的组合。这需要相当长的时间，因为必须检查每个表中行数的乘积。对于手头的情况，这个乘积是74 × 2135 × 74 × 3872 &#x3D; 45，268，558，720行。如果表再大一点，你只能想象要花多长时间。</p>
<p>这里的一个问题是，如果列声明为相同的类型和大小，MySQL可以更有效地使用列上的索引。在这种情况下，如果VARCHAR和CHAR声明为相同的大小，则它们被认为是相同的。</p>
<p>设置为相同大小以后，查询计划如下, 可以看到乘积是 74 * 52 &#x3D; 3848行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">table type   possible_keys key      key_len ref           rows Extra</span><br><span class="line">et    ALL    PRIMARY       NULL     NULL    NULL          74</span><br><span class="line">tt    ref    AssignedPC,   ActualPC 15      et.EMPLOYID   52   Using</span><br><span class="line">             ClientID,                                         where</span><br><span class="line">             ActualPC</span><br><span class="line">et_1  eq_ref PRIMARY       PRIMARY  15      tt.AssignedPC 1</span><br><span class="line">do    eq_ref PRIMARY       PRIMARY  15      tt.ClientID   1</span><br></pre></td></tr></table></figure>

<p>在这一点上，查询几乎是尽可能优化的。剩下的问题是，默认情况下，MySQL假设tt.ActualPC列中的值是均匀分布的，而tt表的情况并非如此。幸运的是，让MySQL分析密钥分布很容易：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ANALYZE TABLE tt;</span><br></pre></td></tr></table></figure>

<p>有了额外的索引信息，连接是完美的，EXPLAIN会产生以下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">table type   possible_keys key     key_len ref           rows Extra</span><br><span class="line">tt    ALL    AssignedPC    NULL    NULL    NULL          3872 Using</span><br><span class="line">             ClientID,                                        where</span><br><span class="line">             ActualPC</span><br><span class="line">et    eq_ref PRIMARY       PRIMARY 15      tt.ActualPC   1</span><br><span class="line">et_1  eq_ref PRIMARY       PRIMARY 15      tt.AssignedPC 1</span><br><span class="line">do    eq_ref PRIMARY       PRIMARY 15      tt.ClientID   1</span><br></pre></td></tr></table></figure>

<p>EXPLAIN输出中的rows列是MySQL连接优化器的合理猜测。通过将行积与查询返回的实际行数进行比较，检查这些数字是否更接近真实情况。如果数字相差很大，那么通过在SELECT语句中使用STRAIGHT_JOIN并尝试在FROM子句中以不同的顺序列出表，可能会获得更好的性能。（但是，STRAIGHT_JOIN可能会阻止使用索引，因为它禁用了半连接转换。</p>
<h3 id="控制查询计划"><a href="#控制查询计划" class="headerlink" title="控制查询计划"></a>控制查询计划</h3><p>查询优化器的任务是找到执行SQL查询的最佳计划。由于“好“和“坏“计划之间的性能差异可能是数量级的（即秒与小时甚至天），大多数查询优化器，包括MySQL的查询优化器，都会在所有可能的查询评估计划中执行或多或少的穷举搜索以找到最佳计划。对于连接查询，MySQL优化器调查的可能计划的数量随着查询中引用的表的数量呈指数级增长。对于少量的表（通常少于7到10个），这不是问题。然而，当提交较大的查询时，查询优化所花费的时间很容易成为服务器性能的主要瓶颈。</p>
<p>更灵活的查询优化方法使用户能够控制优化器在搜索最佳查询评估计划时的详尽程度。一般的想法是，优化器调查的计划越少，编译查询所花费的时间就越少。另一方面，由于优化器跳过了一些计划，它可能会错过寻找最佳计划。</p>
<p>优化器在其评估的计划数量方面的行为可以使用两个系统变量进行控制：</p>
<ul>
<li>optimizer_prune_level变量告诉优化器根据对每个表访问的行数的估计跳过某些计划。我们的经验表明，这种“有根据的猜测”很少会错过最佳计划，并且可以大大减少查询编译时间。这就是为什么这个选项默认为on（optimizer_prune_level &#x3D; 1）。但是，如果您认为优化器错过了一个更好的查询计划，则可以关闭此选项（optimizer_prune_level &#x3D; 0），但查询编译可能需要更长的时间。请注意，即使使用这种启发式方法，优化器仍然会探索大约指数数量的计划。</li>
<li>optimizer_search_depth变量告诉优化器应该查看每个未完成计划的“未来“多远，以评估是否应该进一步扩展它。optimizer_search_depth的值越小，查询编译时间可能会减少几个数量级。例如，如果optimizer_search_depth接近查询中的表数，则包含12、13或更多表的查询可能很容易需要数小时甚至数天来编译。同时，如果编译时optimizer_search_depth等于3或4，优化器可能会在不到一分钟的时间内编译同一个查询。如果您不确定optimizer_search_depth的合理值是多少，可以将此变量设置为0，以告知优化器自动确定该值。</li>
</ul>
<p>optimizer_switch系统变量用于控制优化器的行为。它的值是一组标志，每个标志都有一个值on或off，以指示相应的优化器行为是启用还是禁用。该变量具有全局值和会话值，可以在运行时更改。全局默认值可以在服务器启动时设置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT @@optimizer_switch\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@optimizer_switch: index_merge=on,index_merge_union=on,</span><br><span class="line">                    index_merge_sort_union=on,index_merge_intersection=on,</span><br><span class="line">                    engine_condition_pushdown=on,index_condition_pushdown=on,</span><br><span class="line">                    mrr=on,mrr_cost_based=on,block_nested_loop=on,</span><br><span class="line">                    batched_key_access=off,materialization=on,semijoin=on,</span><br><span class="line">                    loosescan=on,firstmatch=on,duplicateweedout=on,</span><br><span class="line">                    subquery_materialization_cost_based=on,</span><br><span class="line">                    use_index_extensions=on,condition_fanout_filter=on,</span><br><span class="line">                    derived_merge=on,use_invisible_indexes=off,skip_scan=on,</span><br><span class="line">                    hash_join=on,subquery_to_derived=off,</span><br><span class="line">                    prefer_ordering_index=on,hypergraph_optimizer=off,</span><br><span class="line">                    derived_condition_pushdown=on,hash_set_operations=on</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>要更改optimizer_switch的值，请分配一个由逗号分隔的一个或多个命令列表组成的值：</p>
<p>优化器提示: 可以通过注释对优化器进行提示，来使用何种方法执行sql。<code>SELECT /*+ BKA(t1) NO_BKA(t2) */ * FROM t1 INNER JOIN t2 WHERE ...;</code></p>
<p>索引提示：可以控制使用哪个索引，后面指明索引名称。<code>SELECT * FROM table1 USE INDEX (col1_index,col2_index)WHERE col1=1 AND col2=2 AND col3=3;</code></p>
<h4 id="成本模型"><a href="#成本模型" class="headerlink" title="成本模型"></a>成本模型</h4><p>为了生成执行计划，优化器使用一个成本模型，该模型基于对查询执行期间发生的各种操作的成本的估计。优化器有一组编译后的默认“成本常量“，可用于制定有关执行计划的决策。</p>
<p>优化器还有一个在执行计划构造期间使用的成本估计数据库。这些估计值存储在mysql系统数据库的server_cost和engine_cost表中，可以随时配置。这些表的目的是使优化器在尝试获得查询执行计划时可以轻松地调整成本估计。</p>
<p>服务器在启动时将成本模型表读入内存，并在运行时使用内存中的值。表中指定的任何非NULL成本估计优先于相应的编译默认成本常量。任何NULL估计值都指示优化器使用编译后的默认值。</p>
<p>在运行时，服务器可以重新读取成本表。当动态加载存储引擎或执行FLUSH OPTIMIZER_COSTS语句时，会发生这种情况。</p>
<p>成本表使服务器管理员能够通过更改表中的条目来轻松调整成本估计。通过将条目的成本设置为NULL，也可以很容易地恢复到默认值。优化器使用内存中的成本值，因此对表的更改应该在FLUSH OPTIMIZER_COSTS之后生效。</p>
<p>当客户端会话开始时，内存中的当前成本估计值将应用于整个会话，直到会话结束。特别是，如果服务器重新读取成本表，任何更改的估计仅适用于随后启动的会话。现有会话不受影响。</p>
<p>成本表特定于给定的服务器实例。服务器不会将成本表更改复制到副本。</p>
<p>优化器成本模型数据库由mysql系统数据库中的两个表组成，它们包含查询执行期间发生的操作的成本估计信息：</p>
<ul>
<li>server_cost：一般服务器操作的优化器成本估计</li>
<li>engine_cost：针对特定存储引擎的操作的优化器成本估计</li>
</ul>
<h4 id="统计信息"><a href="#统计信息" class="headerlink" title="统计信息"></a>统计信息</h4><p>column_statistics数据字典表存储有关列值的直方图统计信息，供优化器在构造查询执行计划时使用。要执行直方图管理，请使用ANALYZE TABLE语句。</p>
<ul>
<li>该表包含除几何类型（空间数据）和JSON之外的所有数据类型的列的统计信息。</li>
<li>该表是持久的，因此不必在每次服务器启动时都创建列统计信息。</li>
<li>服务器对表执行更新，用户不执行。</li>
</ul>
<p>用户不能直接访问column_statistics表，因为它是数据字典的一部分。直方图信息可使用 INFORMATION_SCHEMA.COLUMN_STATISTICS 获得，它是作为数据字典表上的视图实现的。COLUMN_STATISTICS包含以下列：</p>
<ul>
<li>SCHEMA_NAME、TABLE_NAME、COLUMN_NAME：应用统计信息的模式、表和列的名称。</li>
<li>HISTORIO：描述列统计信息的JSON值，存储为直方图。</li>
</ul>
<p>直方图实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;buckets&quot;: [</span><br><span class="line">    [</span><br><span class="line">      1,</span><br><span class="line">      0.3333333333333333</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      2,</span><br><span class="line">      0.6666666666666666</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      3,</span><br><span class="line">      1</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  &quot;null-values&quot;: 0,</span><br><span class="line">  &quot;last-updated&quot;: &quot;2017-03-24 13:32:40.000000&quot;,</span><br><span class="line">  &quot;sampling-rate&quot;: 1,</span><br><span class="line">  &quot;histogram-type&quot;: &quot;singleton&quot;,</span><br><span class="line">  &quot;number-of-buckets-specified&quot;: 128,</span><br><span class="line">  &quot;data-type&quot;: &quot;int&quot;,</span><br><span class="line">  &quot;collation-id&quot;: 8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>buckets：直方图桶。桶结构取决于直方图类型。</li>
<li>null-values：一个介于0.0和1.0之间的数字，表示SQLNULL值的列值的分数。如果为0，则该列不包含NULL值。</li>
<li>last-updated：直方图生成时，以 YYYY-MM-DD hh:mm:ss.uuuuuu 格式的UTC值表示。</li>
<li>sampling-rate：0.0到1.0之间的数字，表示为创建直方图而采样的数据比例。值为1表示已读取所有数据（无采样）。</li>
<li>histogram-type：直方图类型：<ul>
<li>singleton：一个bucket表示列中的一个值。当列中的非重复值数量小于或等于生成直方图的ANALYZE TABLE语句中指定的存储桶数量时，将创建此直方图类型。</li>
<li>equi-height：一个桶表示一个值范围。当列中的非重复值数量大于生成直方图的ANALYZE TABLE语句中指定的存储桶数量时，将创建此直方图类型。</li>
</ul>
</li>
<li>number-of-buckets-specified：生成直方图的ANALYZE TABLE语句中指定的桶数。</li>
<li>data-type：此直方图包含的数据类型。在将直方图从持久性存储器阅读和解析到内存中时，这是需要的。该值是int、uint（无符号整数）、double、decimal、datetime或string（包括字符和二进制字符串）之一。</li>
<li>collation-id：直方图数据的归类ID。当数据类型值是字符串时，它最有意义。值对应于信息架构COLLATIONS表中的ID列值。</li>
</ul>
<p>直方图统计信息主要用于非索引列。将索引添加到直方图统计信息适用的列还可以帮助优化器进行行估计。</p>
<p>优化器更喜欢范围优化器的行估计，而不是从直方图统计信息中获得的行估计。如果优化器确定范围优化器适用，则不使用直方图统计信息。</p>
<p>对于已建立索引的列，可以使用索引潜水获得行估计值以进行相等比较。</p>
<p>在某些情况下，使用直方图统计信息可能不会改善查询执行（例如，如果统计信息过期）。要检查是否是这种情况，请使用ANALYZE TABLE重新生成直方图统计信息，然后再次运行查询。</p>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><p>MySQL对InnoDB表使用行级锁定，以支持多个会话的同时写访问，使其适用于多用户，高并发和OLTP应用程序。</p>
<p>为了避免在单个InnoDB表上执行多个并发写操作时出现死锁，请在事务开始时通过为预期要修改的每组行发出 SELECT … FOR UPDATE 语句来获取必要的锁，即使数据更改语句在事务中稍后出现。如果事务修改或锁定多个表，则在每个事务中以相同的顺序发出适用的语句。死锁会影响性能，而不是代表一个严重的错误，因为InnoDB默认情况下会自动检测死锁条件并回滚其中一个受影响的事务。</p>
<p>在高并发系统中，当多个线程等待同一个锁时，死锁检测可能会导致速度降低。有时，禁用死锁检测并在发生死锁时依赖innodb_lock_wait_timeout设置进行事务回滚可能更有效。可以使用innodb_deadlock_detect配置选项禁用死锁检测。</p>
<p>行级锁定的优点：</p>
<ul>
<li>当不同的会话访问不同的行时，锁冲突更少。</li>
<li>回滚更改更少。</li>
<li>可以长时间锁定单行。</li>
</ul>
<p>MySQL对MyISAM、MEMORY和MERGE表使用表级锁定，每次只允许一个会话更新这些表。这种锁定级别使这些存储引擎更适合只读、多读或单用户应用程序。</p>
<h2 id="innodb优化"><a href="#innodb优化" class="headerlink" title="innodb优化"></a>innodb优化</h2><h3 id="innodb最佳实践"><a href="#innodb最佳实践" class="headerlink" title="innodb最佳实践"></a>innodb最佳实践</h3><p>使用最常查询的列为每个表指定主键，如果没有明显的主键，则指定自动递增值。</p>
<p>只要数据是基于来自多个表的相同ID值从这些表中提取的，就可以使用联接。为了实现快速联接性能，请在联接列上定义外键，并在每个表中用相同的数据类型声明这些列。添加外键可确保对引用的列进行索引，这可以提高性能。外键还将删除和更新传播到所有受影响的表，并且如果父表中不存在对应的ID，则防止在子表中插入数据。</p>
<p>关闭自动提交。每秒提交数百次会限制性能（受存储设备的写入速度限制）。</p>
<p>通过使用START TRANSACTION和COMMIT语句将相关的DML操作集括起来，将它们分组到事务中。虽然您不想提交得太频繁，但也不想发出大量的INSERT、UPDATE或DELETE语句，这些语句会运行数小时而不提交。</p>
<p>不要使用RESTABLES语句。InnoDB可以处理多个会话，所有阅读和写同一个表一次，而不会牺牲可靠性或高性能。要获得对一组行的独占写访问权限，请使用 SELECT … FOR UPDATE 语法仅锁定要更新的行。</p>
<p>启用innodb_file_per_table变量或使用常规表空间将表的数据和索引放在单独的文件中，而不是系统文件夹中。</p>
<p>评估您的数据和访问模式是否受益于InnoDB表或页面压缩功能。您可以压缩InnoDB表而不牺牲读&#x2F;写能力。</p>
<p>使用 –sql_mode&#x3D;NO_ENGINE_SUBSTITUTION 选项运行服务器，以防止使用您不想使用的存储引擎创建表。</p>
<h3 id="buffer-pool"><a href="#buffer-pool" class="headerlink" title="buffer pool"></a>buffer pool</h3><p>建议设置内存的50%以上给buffer pool，设置的越多，就越像内存数据库</p>
<p>淘汰算法类似<code>LRU-K</code>，缓冲池分为Old和young两段，一开始插入old的头，如果再次访问则插入young。缓冲池的3&#x2F;8专用于旧的子列表。</p>
<p>默认情况下，查询读取的页面会立即移动到新的子列表中，这意味着它们在缓冲池中停留的时间更长。例如，为mysqldump操作或不带WHERE子句的SELECT语句执行的表扫描可以将大量数据带入缓冲池并驱逐等量的旧数据，即使新数据永远不会再次使用。类似地，由预读后台线程加载且仅访问过一次的页将被移动到新列表的头部。这些情况可能会将经常使用的页面推到旧的子列表中，在那里它们会被驱逐。</p>
<p>在具有足够内存的64位系统上，可以将缓冲池拆分为多个部分，以最小化并发操作之间对内存结构的争用。</p>
<p>您可以控制如何以及何时执行预读请求，以便在预期即将需要页时将页异步预取到缓冲池中。</p>
<p>您可以控制何时发生后台刷新，以及是否根据工作负载动态调整刷新速率。</p>
<p>您可以配置InnoDB如何保留当前缓冲池状态，以避免服务器重启后的漫长预热期。</p>
<p>可以使用<code>SHOW ENGINE INNODB STATUS </code>来查看缓冲池状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 2198863872</span><br><span class="line">Dictionary memory allocated 776332</span><br><span class="line">Buffer pool size   131072</span><br><span class="line">Free buffers       124908</span><br><span class="line">Database pages     5720</span><br><span class="line">Old database pages 2071</span><br><span class="line">Modified db pages  910</span><br><span class="line">Pending reads 0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 4, not young 0</span><br><span class="line">0.10 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 197, created 5523, written 5060</span><br><span class="line">0.00 reads/s, 190.89 creates/s, 244.94 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not</span><br><span class="line">0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read</span><br><span class="line">ahead 0.00/s</span><br><span class="line">LRU len: 5720, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br></pre></td></tr></table></figure>

<h3 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h3><p>change buffer 是一种特殊的数据结构，当辅助索引页不在缓冲池中时，它会缓存这些页的更改。缓冲的更改（可能是由DELETE、UPDATE或DML操作引起的）在以后通过其他读取操作将页加载到缓冲池时合并。</p>
<p>与聚集索引不同，辅助索引通常是非唯一的，插入辅助索引的顺序相对随机。同样，删除和更新可能会影响索引树中不相邻的二级索引页。当其他操作将受影响的页读入缓冲池时，在以后合并缓存的更改可以避免将辅助索引页从磁盘读入缓冲池所需的大量随机访问I&#x2F;O。</p>
<p>在系统大部分空闲时或缓慢关机期间运行的清除操作会定期将更新的索引页写入磁盘。与立即将每个值写入磁盘相比，清除操作可以更高效地写入一系列索引值的磁盘块。</p>
<p>当有许多受影响的行和许多要更新的辅助索引时，更改缓冲区合并可能需要几个小时。在此期间，磁盘I&#x2F;O会增加，这可能会导致磁盘绑定查询的速度显著降低。更改缓冲区合并也可能在事务提交后继续发生，甚至在服务器关闭并重新启动后也会发生</p>
<p>在内存中，更改缓冲区占用缓冲池的一部分。在磁盘上，更改缓冲区是系统缓存的一部分，当数据库服务器关闭时，索引更改将在其中进行缓冲。</p>
<p>如果索引包含降序索引列，或者如果主键包含降序索引列，则不支持辅助索引的更改缓冲。</p>
<p>当对表执行INSERT, UPDATE和DELETE操作时，索引列的值（特别是辅助键的值）通常是无序的，需要大量的I&#x2F;O来更新辅助索引。当相关页不在缓冲池中时，更改缓冲区将缓存对辅助索引条目的更改，从而避免了昂贵的I&#x2F;O操作，因为它不会立即从磁盘阅读页。当页加载到缓冲池中时，将合并缓冲的更改，更新后的页稍后将刷新到磁盘。InnoDB主线程在服务器接近空闲时和缓慢关闭期间合并缓冲的更改。</p>
<p>由于更改缓冲可以减少磁盘读取和写入，因此它对于I&#x2F;O受限的工作负载最有价值;例如，具有大量DML操作（如批量插入）的应用程序将受益于更改缓冲。</p>
<p>但是，更改缓冲区占用了缓冲池的一部分，从而减少了可用于缓存数据页的内存。如果工作集几乎适合缓冲池，或者表的辅助索引相对较少，则禁用更改缓冲可能很有用。如果工作数据集完全适合缓冲池，则更改缓冲不会产生额外的开销，因为它只应用于不在缓冲池中的页。</p>
<p>innodb_change_buffering变量控制InnoDB执行更改缓冲的程度。您可以为插入、删除操作（当索引记录最初标记为删除时）和清除操作（当索引记录被物理删除时）启用或禁用缓冲。更新操作是插入和删除的组合。默认的innodb_change_buffering值是none</p>
<p>innodb_change_buffer_max_size变量允许将更改缓冲区的最大大小配置为缓冲池总大小的百分比。默认情况下，innodb_change_buffer_max_size设置为25。最大设置为50。</p>
<p>考虑在具有大量插入、更新和删除活动的MySQL服务器上增加innodb_change_buffer_max_size，其中更改缓冲区合并无法跟上新的更改缓冲区条目，导致更改缓冲区达到其最大大小限制。</p>
<p>如果MySQL服务器上的静态数据用于报告，或者如果更改缓冲区占用了太多与缓冲池共享的内存空间，导致页面比预期更快地老化，请考虑减少innodb_change_buffer_max_size。</p>
<p>使用具有代表性的工作负载测试不同的设置以确定最佳配置。innodb_change_buffer_max_size变量是动态的，允许在不重启服务器的情况下修改设置。</p>
<p>要查看监视器数据，请发出SHOW ENGINE INNODB STATUS语句。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 0, seg size 2, 0 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 4425293, used cells 32, node heap has 1 buffer(s)</span><br><span class="line">13577.57 hash searches/s, 202.47 non-hash searches/s</span><br></pre></td></tr></table></figure>

<h3 id="双写缓冲区"><a href="#双写缓冲区" class="headerlink" title="双写缓冲区"></a>双写缓冲区</h3><p>双写缓冲区是一个存储区域，InnoDB在将页面写入InnoDB数据文件中的适当位置之前，将从缓冲池刷新的页面写入其中。如果在页面写入过程中出现操作系统、存储子系统或意外的mysqld进程退出，InnoDB可以在崩溃恢复期间从doublewrite缓冲区中找到页面的良好副本。</p>
<p>虽然数据被写入两次，但双写缓冲区不需要两倍的I&#x2F;O开销或两倍的I&#x2F;O操作。数据以一个大的顺序块的形式写入双写缓冲区，并对操作系统进行单个fsync（）调用（除非innodb_flush_method设置为O_DIRECT_NO_FSYNC）。</p>
<p>双写缓冲存储区位于双写文件中。</p>
<p>为双写缓冲区配置提供了以下变量：</p>
<ul>
<li>innodb_doublewrite变量控制是否启用双写缓冲区。它在大多数情况下默认启用。要禁用双写缓冲区，请将innodb_doublewrite设置为OFF。如果您更关心的是性能而不是数据完整性，那么可以考虑禁用双写缓冲区，例如，在执行基准测试时可能就是这种情况。</li>
<li>innodb_doublewrite支持DETECT_AND_RECOVER和DETECT_ONLY设置。<ul>
<li>DETECT_AND_RECOVER设置与ON设置相同。通过此设置，双写缓冲区将完全启用，数据库页内容将写入双写缓冲区，在恢复期间将访问该缓冲区以修复不完整的页写入。</li>
<li>使用DETECT_ONLY设置时，仅将元数据写入双写缓冲区。数据库页内容不写入双写缓冲区，恢复不使用双写缓冲区来修复不完整的页写入。此轻量级设置仅用于检测不完整的页写入。</li>
</ul>
</li>
<li>innodb_doublewrite_dir变量定义了InnoDB创建doublewrite文件的目录。如果未指定目录，则在innodb_data_home_dir目录中创建双写文件，如果未指定，则默认为data目录。</li>
<li>innodb_doublewrite_files变量定义了双写文件的数量，默认值为2。默认情况下，为每个缓冲池实例创建两个双写文件：刷新列表双写文件和LRU列表双写文件。刷新列表双写文件用于从缓冲池刷新列表中刷新的页面。刷新列表双写文件的默认大小是InnoDB页面大小 * 双写页面字节。innodb_doublewrite_files变量用于高级性能调优。默认设置应该适合大多数用户。</li>
<li>innodb_doublewrite_pages变量控制每个线程的最大双写页面数。此变量用于高级性能调整。默认值应该适合大多数用户。</li>
</ul>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>重做日志是一种基于磁盘的数据结构，在崩溃恢复期间用于纠正未完成事务写入的数据。在正常操作过程中，重做日志对SQL语句或低级API调用产生的更改表数据的请求进行编码。在意外关闭之前未完成更新数据文件的修改将在初始化期间和接受连接之前自动重播。</p>
<p>重做日志在磁盘上由重做日志文件物理表示。写入重做日志文件的数据按照受影响的记录进行编码，这些数据统称为重做。数据通过重做日志文件的传递由不断增加的LSN值表示。重做日志数据在数据修改时追加，最旧的数据在检查点进行时被截断。</p>
<p>重做日志文件驻留在数据目录中的#innodb_redo目录中，除非innodb_log_group_home_dir变量指定了不同的目录。如果定义了innodb_log_group_home_dir，则重做日志文件驻留在该目录中的#innodb_redo目录中。有两种类型的重做日志文件，普通和备用。普通的重做日志文件是那些正在使用的。备用重做日志文件是那些等待使用的文件。InnoDB尝试总共维护32个重做日志文件，每个文件的大小等于1&#x2F;32 *innodb_redo_log_capacity;但是，在修改innodb_redo_log_capacity设置后，文件大小可能会在一段时间内有所不同。</p>
<p>每个普通重做日志文件都与特定的LSN值范围相关联;例如，以下查询显示上一示例中列出的活动重做日志文件的START_LSN和END_LSN值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT FILE_NAME, START_LSN, END_LSN FROM performance_schema.innodb_redo_log_files;</span><br><span class="line">+----------------------------+--------------+--------------+</span><br><span class="line">| FILE_NAME                  | START_LSN    | END_LSN      |</span><br><span class="line">+----------------------------+--------------+--------------+</span><br><span class="line">| ./#innodb_redo/#ib_redo582 | 117654982144 | 117658256896 |</span><br><span class="line">| ./#innodb_redo/#ib_redo583 | 117658256896 | 117661531648 |</span><br><span class="line">| ./#innodb_redo/#ib_redo584 | 117661531648 | 117664806400 |</span><br><span class="line">| ./#innodb_redo/#ib_redo585 | 117664806400 | 117668081152 |</span><br><span class="line">| ./#innodb_redo/#ib_redo586 | 117668081152 | 117671355904 |</span><br><span class="line">| ./#innodb_redo/#ib_redo587 | 117671355904 | 117674630656 |</span><br><span class="line">| ./#innodb_redo/#ib_redo588 | 117674630656 | 117677905408 |</span><br><span class="line">| ./#innodb_redo/#ib_redo589 | 117677905408 | 117681180160 |</span><br><span class="line">| ./#innodb_redo/#ib_redo590 | 117681180160 | 117684454912 |</span><br><span class="line">| ./#innodb_redo/#ib_redo591 | 117684454912 | 117687729664 |</span><br><span class="line">| ./#innodb_redo/#ib_redo592 | 117687729664 | 117691004416 |</span><br><span class="line">| ./#innodb_redo/#ib_redo593 | 117691004416 | 117694279168 |</span><br><span class="line">| ./#innodb_redo/#ib_redo594 | 117694279168 | 117697553920 |</span><br><span class="line">| ./#innodb_redo/#ib_redo595 | 117697553920 | 117700828672 |</span><br><span class="line">| ./#innodb_redo/#ib_redo596 | 117700828672 | 117704103424 |</span><br><span class="line">| ./#innodb_redo/#ib_redo597 | 117704103424 | 117707378176 |</span><br><span class="line">| ./#innodb_redo/#ib_redo598 | 117707378176 | 117710652928 |</span><br><span class="line">| ./#innodb_redo/#ib_redo599 | 117710652928 | 117713927680 |</span><br><span class="line">| ./#innodb_redo/#ib_redo600 | 117713927680 | 117717202432 |</span><br><span class="line">| ./#innodb_redo/#ib_redo601 | 117717202432 | 117720477184 |</span><br><span class="line">| ./#innodb_redo/#ib_redo602 | 117720477184 | 117723751936 |</span><br><span class="line">+----------------------------+--------------+--------------+</span><br></pre></td></tr></table></figure>

<p>当执行检查点时，InnoDB将检查点LSN存储在包含此LSN的文件的头中。在恢复过程中，将检查所有重做日志文件，并从最新的检查点LSN开始恢复。</p>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>撤消日志是与单个读写事务相关联的撤消日志记录的集合。撤消日志记录包含有关如何撤消事务对聚集索引记录的最新更改的信息。如果另一个事务需要查看作为一致性读取操作的一部分的原始数据，则从撤消日志记录中检索未修改的数据。撤消日志存在于撤消日志段中，撤消日志段包含在回滚段中。回滚段驻留在撤消表空间和全局临时表空间中。</p>
<p>驻留在全局临时表中的撤消日志用于修改用户定义的临时表中的数据的事务。这些撤消日志不会被重新记录，因为它们不是崩溃恢复所必需的。它们仅用于服务器运行时的回滚。这种类型的撤消日志通过避免重做日志记录I&#x2F;O来提高性能。</p>
<h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><p>InnoDB实现了标准的行级锁，其中有两种类型的锁，共享（S）锁和排他（X）锁。</p>
<ul>
<li>共享（S）锁允许持有锁的事务读取行。</li>
<li>排他（X）锁允许持有锁的事务更新或删除行。</li>
</ul>
<p>InnoDB支持多粒度锁，允许行锁和表锁共存。例如，一个语句，如可扩展表… WRITE在指定的表上使用排他锁（X锁）。为了实现多粒度级别的锁定，InnoDB使用了意图锁。意图锁是表级锁，它指示事务稍后需要对表中的行使用哪种类型的锁（共享锁或排他锁）。有两种类型的意图锁</p>
<ul>
<li>意向共享锁（IS）表示事务打算在表中的各个行上设置共享锁。</li>
<li>意向排他锁（IX）表示事务打算在表中的各个行上设置排他锁。</li>
</ul>
<p>例如，SELECT … FOR SHARE设置IS锁，SELECT. FOR UPDATE设置一个IX锁。</p>
<p>意图锁定协议如下</p>
<ul>
<li>在事务可以获取表中某行的共享锁之前，它必须首先获取表中的IS锁或更强锁。</li>
<li>在事务可以获取表中某行的排他锁之前，它必须首先获取表上的IX锁。</li>
</ul>
<p>表级锁类型兼容性总结在下面的矩阵中。</p>
<p>图片</p>
<p>如果请求事务与现有锁兼容，则将锁授予该事务，但如果与现有锁冲突，则不授予该事务。事务等待，直到冲突的现有锁被释放。如果锁请求与现有锁冲突，并且由于会导致死锁而无法授予，则会发生错误。</p>
<p>记录锁是索引记录上的锁。例如， SELECT c1 FROM t WHERE c1 &#x3D; 10 FOR UPDATE; 阻止任何其他事务插入、更新或删除t.c1值为10的行。</p>
<p>记录锁始终锁定索引记录，即使定义的表没有索引。对于这种情况，InnoDB会创建一个隐藏的聚集索引并使用该索引进行记录锁定。</p>
<p>记录锁的事务数据在 SHOW ENGINE INNODB STATUS 和InnoDB监视器输出中类似于以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t`</span><br><span class="line">trx id 10078 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000000274f; asc     &#x27;O;;</span><br><span class="line"> 2: len 7; hex b60000019d0110; asc        ;;</span><br></pre></td></tr></table></figure>

<p>间隙锁是对索引记录之间的间隙的锁，或者对第一个索引记录之前或最后一个索引记录之后的差距的锁。例如， SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE; 阻止其他事务将值15插入列t.c1中，无论该列中是否已经有任何这样的值，因为范围中所有现有值之间的间隙被锁定。</p>
<p>间隙可能跨越单个索引值、多个索引值甚至是空的。</p>
<p>间隙锁是性能和并发性之间权衡的一部分，在某些事务隔离级别中使用，而在其他级别中则不使用。</p>
<p>对于使用唯一索引搜索唯一行来锁定行的语句，不需要间隔锁定。(This不包括搜索条件仅包括多列唯一索引的某些列的情况;在这种情况下，确实会发生间隙锁定。)例如，如果id列具有唯一索引，则以下语句仅对id值为100的行使用索引记录锁，并且其他会话是否在前面的间隙中插入行无关紧要：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM child WHERE id = 100;</span><br></pre></td></tr></table></figure>

<p>如果id没有索引或者有一个非唯一的索引，语句会锁定前面的间隙。</p>
<p>这里还值得注意的是，不同的事务可以在间隙上持有冲突的锁。例如，事务A可以在间隙上持有共享间隙锁（间隙S锁），而事务B在同一间隙上持有排他间隙锁（间隙X锁）。允许间隙锁冲突的原因是，如果从索引中清除记录，则必须合并不同事务在该记录上持有的差距锁。</p>
<p>InnoDB中的间隙锁是“纯粹禁止性的“，这意味着它们的唯一目的是防止其他事务插入到差距中。间隙锁可以共存。一个事务获取的间隙锁不会阻止另一个事务获取同一间隙上的间隙锁。共享间隙锁和独占间隙锁之间没有区别。它们彼此之间并不冲突，它们的功能是相同的。</p>
<p>Next-Key Locks 是索引记录上的记录锁和索引记录之前的差距上的差距锁的组合。</p>
<p>InnoDB执行行级锁定的方式是，当它搜索或扫描表索引时，它会在遇到的索引记录上设置共享或排他锁。因此，行级锁实际上是索引记录锁。索引记录上的下一个键锁也会影响该索引记录之前的“间隙“。也就是说，下一个键锁是索引记录锁加上索引记录之前的差距上的间隙锁。如果一个会话对索引中的记录R具有共享锁或排他锁，则另一个会话不能在索引顺序中紧接在R之前的差距中插入新的索引记录。</p>
<p>假设索引包含值10、11、13和20。此索引可能的下一个键锁涵盖以下区间，其中圆括号表示排除区间端点，方括号表示包含端点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure>

<p>默认情况下，InnoDB在REPEATABLE READ事务隔离级别下运行。在这种情况下，InnoDB使用下一个键锁进行搜索和索引扫描，这可以防止幻读</p>
<p>插入意图锁是一种在行插入之前由INSERT操作设置的间隙锁。该锁以这样一种方式发出插入意图的信号，即如果插入到同一索引间隙中的多个事务不在差距内的相同位置处插入，则它们不需要等待彼此。假设有值为4和7的索引记录。分别尝试插入值5和6的单独事务，每个事务在获得插入行的排他锁之前，用插入意图锁锁定4和7之间的差距，但不阻止彼此，因为行不冲突。</p>
<p>锁定读取、UPDATE或UPDATE通常在SQL语句处理过程中扫描的每个索引记录上设置记录锁。语句中是否有排除该行的WHERE条件并不重要。InnoDB不记得确切的WHERE条件，只知道扫描了哪些索引范围。这些锁通常是下一个键锁，它也会阻止插入记录之前的“间隙”。但是，可以显式禁用间隙锁定，这将导致不使用下一个键锁定。</p>
<p>如果在搜索中使用了二级索引，并且要设置的索引记录锁是独占的，InnoDB也会检索相应的聚集索引记录并对其设置锁。</p>
<p>如果你没有适合你的语句的索引，MySQL必须扫描整个表来处理语句，那么表的每一行都会被锁定，这反过来会阻止其他用户对表的所有插入。创建良好的索引非常重要，这样查询就不会扫描不必要的行。</p>
<p>SELECT … FROM是一致读取，即阅读数据库的快照，并且不设置锁，除非事务隔离级别设置为SERIALIZABLE。对于SERIALIZABLE级别，搜索在它遇到的索引记录上设置共享的下一个键锁。但是，对于使用唯一索引搜索唯一行来锁定行的语句，只需要索引记录锁。</p>
<p>使用唯一索引的 SELECT … FOR UPDATE 和 SELECT … FOR SHARE 语句为扫描的行获取锁，并为不符合结果集中包含条件的行释放锁（例如，如果它们不满足WHERE子句中给定的条件）。但是，在某些情况下，行可能不会立即解锁，因为结果行与其原始源之间的关系在查询执行期间丢失。例如，在UNION中，表中扫描（和锁定）的行可能会插入到临时表中，然后再评估它们是否符合结果集。在这种情况下，临时表中的行与原始表中的行之间的关系将丢失，并且后面的行直到查询执行结束才被解锁。</p>
<p>对于锁定读取（SELECTwithFOR UPDATE或FOR SHARE）、UPDATE和UPDATE语句，所采用的锁取决于语句使用的是具有唯一搜索条件的唯一索引还是具有范围类型搜索条件的唯一索引。</p>
<ul>
<li>对于具有唯一搜索条件的唯一索引，InnoDB只锁定找到的索引记录，而不锁定它之前的差距。</li>
<li>对于其他搜索条件以及非唯一索引，InnoDB会锁定扫描的索引范围，使用间隙锁或下一个键锁来阻止其他会话插入该范围覆盖的间隙。</li>
</ul>
<p>对于搜索遇到的索引记录， SELECT … FOR UPDATE 阻止其他会话执行 SELECT … FOR SHARE 或在某些事务隔离级别中进行阅读。一致性读取将忽略在读取视图中存在的记录上设置的任何锁。</p>
<p>UPDATE … WHERE … 在搜索遇到的每个记录上设置独占的下一个键锁。但是，对于使用唯一索引搜索唯一行来锁定行的语句，只需要索引记录锁。</p>
<p>DELETE FROM … WHERE … 在搜索遇到的每个记录上设置独占的下一个键锁。但是，对于使用唯一索引搜索唯一行来锁定行的语句，只需要索引记录锁。</p>
<p>INSERT 在插入的行上设置独占锁。此锁是索引记录锁，而不是下一个键锁（即没有间隙锁），并且不会阻止其他会话插入到插入行之前的差距中。</p>
<p>在插入行之前，设置一种称为插入意图间隙锁定的间隙锁定。该锁以这样一种方式发出插入意图的信号，即如果插入到同一索引间隙中的多个事务不在差距内的相同位置处插入，则它们不需要等待彼此。假设有值为4和7的索引记录。尝试插入值5和6的单独事务在获得插入行的排他锁之前，每个事务都使用插入意图锁锁定4和7之间的差距，但不会相互阻塞，因为行不冲突。</p>
<p>INSERT INTO T SELECT … FROM S WHERE … 在插入到T中的每一行上设置排他索引记录锁（没有间隙锁）。如果事务隔离级别为READ COMMITTED，InnoDB将在S上执行一致性读取（无锁）。否则，InnoDB会对来自S的行设置共享的下一个键锁。InnoDB必须在后一种情况下设置锁：在使用基于语句的二进制日志进行前滚恢复期间，每个SQL语句都必须以与最初完全相同的方式执行。</p>
<p>当启用死锁检测时（默认值），InnoDB会自动检测事务死锁并回滚一个或多个事务以打破死锁。InnoDB尝试选择小事务进行回滚，其中事务的大小由插入、更新或删除的行数决定。</p>
<p>死锁是事务数据库中的一个典型问题，但它们并不危险，除非它们非常频繁，以至于您根本无法运行某些事务。通常，您必须编写应用程序，以便它们始终准备好在事务由于死锁而回滚时重新发出事务。</p>
<p>InnoDB使用自动行级锁定。即使在只插入或删除单行的事务中，也可能出现死锁。这是因为这些操作并不是真正的“原子“操作;它们会自动对插入或删除的行的（可能是多个）索引记录设置锁。</p>
<p>您可以使用以下技术来科普死锁并降低其发生的可能性：</p>
<ul>
<li>在任何时候，都可以发出 SHOW ENGINE INNODB STATUS 来确定最近一次死锁的原因。这可以帮助您调优应用程序以避免死锁。</li>
<li>如果频繁的死锁警告引起了关注，请通过启用innodb_print_all_deadlocks变量来收集更广泛的调试信息。关于每个死锁的信息，而不仅仅是最新的一个，都记录在MySQL错误日志中。完成调试后禁用此选项。</li>
<li>如果事务由于死锁而失败，请始终准备重新发出事务。死锁并不危险。再试一次</li>
<li>保持事务规模小、持续时间短，以减少冲突。</li>
<li>在进行一组相关更改后立即提交事务，以减少冲突。特别是，不要让一个交互式的mysql会话长时间打开一个未提交的事务。</li>
<li>如果您使用锁定读取（ SELECT … FOR UPDATE 或 SELECT … FOR SHARE ），请尝试使用较低的隔离级别，例如READ COMMITTED。</li>
<li>当修改一个事务中的多个表或同一表中的不同行集时，每次都要以一致的顺序执行这些操作。这样，事务就形成了定义良好的队列，不会死锁。例如，将数据库操作组织到应用程序中的函数中，或调用存储的例程，而不是在不同的地方编写多个类似的UPDATE、UPDATE和UPDATE语句序列。</li>
<li>向表中添加精心选择的索引，这样查询扫描的索引记录和设置的锁就更少。使用EXPLAIN SELECT来确定MySQL服务器认为哪些索引最适合您的查询。</li>
<li>使用较少的锁定。如果您可以允许SELECT从旧快照中返回数据，请不要向其添加FOR UPDATE或FOR SHARE子句。在这里使用READ COMMITTED隔离级别是很好的，因为同一事务中的每个一致性读取都从自己的新快照中读取。</li>
<li>如果没有其他帮助，请使用表级锁序列化事务。在事务表（如InnoDB表）中使用UNESTABLES的正确方法是，开始事务时使用 SET autocommit &#x3D; 0 （不是START TRANSACTION），后跟UNESTABLES，并且在显式提交事务之前不要调用UNESTABLES。</li>
</ul>
<p>InnoDB使用竞争感知事务调度（CATS）算法来优先处理等待锁的事务。当多个事务等待同一对象上的锁时，CATS算法确定哪个事务首先接收锁。</p>
<p>CATS算法通过分配调度权重来对等待的事务进行优先级排序，调度权重是根据事务阻塞的事务数量计算的。例如，如果两个事务正在等待同一对象上的锁，则阻塞事务最多的事务将被分配更大的调度权重。如果权重相等，则将优先级给予等待时间最长的事务。</p>
<h3 id="InnoDB压缩表"><a href="#InnoDB压缩表" class="headerlink" title="InnoDB压缩表"></a>InnoDB压缩表</h3><p>由于处理器和高速缓存存储器的速度比磁盘存储设备提高得更快，因此许多工作负载都是磁盘绑定的。数据压缩可以减小数据库大小、减少I&#x2F;O并提高吞吐量，但代价是增加CPU利用率。对于具有足够RAM以将频繁使用的数据保留在内存中的系统上的读取密集型应用程序来说，压缩尤其有价值。</p>
<p>使用ROW_FORMAT&#x3D;COMPRESSED创建的InnoDB表可以在磁盘上使用比配置的innodb_page_size值更小的页面大小。较小的页面需要较少的I&#x2F;O来读取和写入磁盘，这对于SSD设备尤其有价值。</p>
<p>压缩页大小通过CREATE TABLE或ALTER TABLEKEY_BLOCK_SIZE参数指定。不同的页大小要求将表放在每个表一个文件的目录中或一般目录中，而不是放在系统目录中，因为系统目录不能存储压缩表。</p>
<p>无论KEY_BLOCK_SIZE值如何，压缩级别都相同。当您为KEY_BLOCK_SIZE指定较小的值时，您将获得越来越小的页面带来的I&#x2F;O好处。但是，如果指定的值太小，则当数据值无法压缩到足以容纳每页中的多行时，重新组织页会产生额外的开销。根据表中每个索引的键列长度，表的KEY_BLOCK_SIZE大小有一个硬性限制。如果指定的值太小，则CREATE TABLE或ALTER TABLE语句将失败。</p>
<p>在缓冲池中，压缩数据保存在小页面中，页面大小基于KEY_BLOCK_SIZE值。为了提取或更新列值，MySQL还在缓冲池中使用未压缩的数据创建未压缩的页面。在缓冲池中，对未压缩页的任何更新也会重新写回等效的压缩页。您可能需要调整缓冲池的大小，以容纳压缩页和未压缩页的额外数据，尽管未压缩页在需要空间时会从缓冲池中清除，然后在下次访问时再次解压缩。</p>
<p>配置innodb_file_per_table选项后，在CREATE TABLE或ALTER TABLE语句中指定ROW_FORMAT&#x3D;COMPRESSED子句或KEY_BLOCK_SIZE子句，或同时指定这两个子句，以在每个表一个文件的格式中创建压缩表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL innodb_file_per_table=1;</span><br><span class="line">CREATE TABLE t1</span><br><span class="line"> (c1 INT PRIMARY KEY)</span><br><span class="line"> ROW_FORMAT=COMPRESSED</span><br><span class="line"> KEY_BLOCK_SIZE=8;</span><br></pre></td></tr></table></figure>

<p>要确定KEY_BLOCK_SIZE的最佳值，通常需要为此子句创建具有不同值的同一表的多个副本，然后测量生成的.ibd文件的大小，并查看每个副本在实际工作负载下的性能。对于一般的表空间，请记住，删除表不会减小一般的.ibd文件的大小，也不会将磁盘空间返回给操作系统。</p>
<h3 id="innoDB恢复"><a href="#innoDB恢复" class="headerlink" title="innoDB恢复"></a>innoDB恢复</h3><p>InnoDB崩溃恢复包括几个步骤：</p>
<ul>
<li>redo log: 重做日志应用程序在初始化期间执行，然后接受任何连接。如果在关机或崩溃时，所有更改都从缓冲池刷新到表空间（ibdata<em>和</em>.ibd文件），则重做日志应用程序将被跳过。InnoDB还跳过重做日志应用程序，如果重做日志文件在启动时丢失。<ul>
<li>当前最大自动递增计数器值在每次值更改时写入重做日志，这使其具有崩溃安全性。在恢复过程中，InnoDB扫描重做日志以收集计数器值更改，并将更改应用于内存中的表对象。</li>
<li>当遇到索引树损坏时，InnoDB将损坏标志写入重做日志，这使得损坏标志崩溃安全。InnoDB还将内存中的损坏标志数据写入每个检查点上的引擎专用系统表。在恢复过程中，InnoDB从两个位置读取损坏标志，并在将内存中的表和索引对象标记为损坏之前合并结果。</li>
<li>不建议通过删除重做日志来加快恢复速度，即使可以接受某些数据丢失。只有在干净关机后才应该考虑删除重做日志，并将innodb_fast_shutdown设置为0或1。</li>
</ul>
</li>
<li>roll back: 未完成事务的回滚,不完整事务是在意外退出或快速关闭时处于活动状态的任何事务。根据服务器负载的不同，回滚未完成事务所需的时间可能是事务中断前活动时间的三倍或四倍。不能取消正在回滚的事务。在极端情况下，当回滚事务预计需要非常长的时间时，使用3或更大的innodb_force_recovery设置启动InnoDB可能会更快。</li>
<li>change buffer: 当索引页被读取到缓冲池时，将更改缓冲区（系统缓存的一部分）中的更改应用于辅助索引的叶页。</li>
<li>purge: 删除对活动事务不再可见的已标记为删除的记录。</li>
</ul>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>基于语句复制的优点：</p>
<ul>
<li>写入日志文件的数据更少。当更新或删除影响许多行时，这会导致日志文件所需的存储空间大大减少。这也意味着可以更快地完成从备份获取和恢复。</li>
<li>日志文件包含进行任何更改的所有语句，因此可用于审核数据库。</li>
</ul>
<p>缺点</p>
<ul>
<li>并非所有修改数据的语句（如UPDATE、UPDATE和REPLACE语句）都可以使用基于语句的复制进行复制。使用基于语句的复制时，任何不确定性行为都很难复制。</li>
<li>insert … select 和基于行的复制相比，SELECT需要更多的行级锁。</li>
<li>与基于行的复制相比，需要表扫描的UPDATE语句（因为在WHERE子句中没有使用索引）必须锁定更多的行。</li>
<li>对于InnoDB：一个使用了AUTO_INCREMENT的INCREMENT语句会阻塞其他不冲突的INCREMENT语句。</li>
<li>对于复杂语句，在更新或插入行之前，必须在副本上计算和执行该语句。对于基于行的复制，副本只需修改受影响的行，而不必执行完整的语句。</li>
<li>如果在对副本进行评估时出现错误，特别是在执行复杂语句时，基于语句的复制可能会随着时间的推移慢慢增加受影响行的误差幅度。</li>
<li>必须在副本上应用确定性函数。</li>
<li>源和副本上的表定义必须（几乎）相同。</li>
</ul>
<p>基于行的复制的优点</p>
<ul>
<li>所有更改都可以复制。这是最安全的复制方式。</li>
<li>对于任何UPDATE、UPDATE或UPDATE语句，副本上所需的行锁较少。</li>
</ul>
<p>缺点</p>
<ul>
<li>要复制DML语句（如UPDATE或DELETE语句），基于语句的复制只将语句写入二进制日志。相比之下，基于行的复制将每个更改的行写入二进制日志。如果语句更改了许多行，则基于行的复制可能会向二进制日志写入更多的数据;即使对于回滚的语句也是如此。这也意味着制作和恢复备份可能需要更多的时间。此外，二进制日志被锁定较长时间以写入数据，这可能会导致并发问题。使用binlog_row_image&#x3D;minimal可以大大减少这个缺点。</li>
<li>与基于语句的复制相比，使用基于行的复制复制生成大BLOB值的确定性NULL函数所需的时间更长。这是因为记录的是BLOB列值，而不是生成数据的语句。</li>
<li>您无法在副本上看到从源接收并执行了哪些语句。但是，您可以使用带有选项–base64-output&#x3D;DECODE-ROWS和–verbose的mysqlbinlog查看更改了哪些数据。</li>
<li>对于使用MyISAM存储引擎的表，将SQL语句作为基于行的事件应用于二进制日志时，其副本上需要比将其作为语句应用时更强的锁。这意味着在使用基于行的复制时，不支持MyISAM表上的并发插入。</li>
</ul>
<p>MySQL使用基于语句的日志记录（SBL），基于行的日志记录（RBL）或混合格式的日志记录。使用的二进制日志类型影响日志记录的大小和效率。因此，基于行的复制（RBR）或基于语句的复制（SBR）之间的选择取决于您的应用程序和环境。</p>
<p>使用基于行的格式或混合格式时，不复制临时表，因为没有必要。此外，由于临时表只能从创建它们的线程读取，因此即使使用基于语句的格式，复制它们也很少有好处。当使用binlog_format&#x3D;ROW时，只要受语句影响的任何非事务性表都是临时表，就允许涉及临时表的非事务性DML语句。</p>
<p>当许多行受到影响时，更改集被拆分为多个事件;当语句提交时，所有这些事件都被写入二进制日志。在副本上执行时，对所有涉及的表都采用表锁，然后以批处理模式应用行。这可能有效，也可能无效，具体取决于用于复制表副本的引擎。</p>
<p>RBL将每一行的更改写入二进制日志，因此其大小可以快速增加。这会显著增加在复制副本上进行与源上的更改相匹配的更改所需的时间。你应该意识到这种延迟在你的应用程序的可能性。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList和LinkedList解析</title>
    <url>/ArrayList%E5%92%8CLinkedList%E8%A7%A3%E6%9E%90.html</url>
    <content><![CDATA[<h2 id="数组数据结构"><a href="#数组数据结构" class="headerlink" title="数组数据结构"></a>数组数据结构</h2><h3 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h3><p>接口就是Interface，也可以是ADT(Abstract Data Tructure), 当定义一个接口的时候，实际上是一种规范，一种约束。</p>
<p>接口定义了一些方法，也就是支持哪些操作。</p>
<p>这里拿Java的List接口举个例子。</p>
<p>List<E></p>
<ul>
<li>add(E element): 表示List接口支持add操作，将一个元素添加到list中，至于如何实现，不重要。</li>
<li>remove(E element): 表示List接口支持remove操作，将一个元素从list中移除，至于如何实现，不重要。</li>
<li>size(): 表示List接口支持size操作，返回list中有多少个元素，如何实现，不重要。</li>
</ul>
<p>接口还可以想象成提出了一些问题，比如说，我现在有List这个接口，我提出了三个问题。</p>
<ul>
<li>我要将一个元素添加到list中，如何实现？</li>
<li>我要将一个元素从list中移除，如何实现?</li>
<li>我要计算list中元素的数量，如何实现？</li>
</ul>
<h3 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h3><p>那么什么是数据结构呢？就是一种接口的具体实现方案。</p>
<p>它是数据实际的表示形式。它有一些方法，或者说使用一些算法，来实现上面接口提出的操作。</p>
<p>同样可以理解为对于上面提出的三个问题的解答。</p>
<p>以Java中ArrayList和LinkedList来举例。</p>
<p>ArrayList: 使用数组实现了List接口</p>
<ul>
<li>add(E element): 表示ArrayList这种数据结构，实现了List接口，支持add操作，使用了适合ArrayList这种数据结构的算法来实现add，解决了上面的第一个问题。</li>
<li>remove(E element): 表示ArrayList这种数据结构，实现了List接口，支持remove操作，使用了适合ArrayList这种数据结构的算法来实现remove，解决了上面的第二个问题。</li>
<li>len(): 表示ArrayList这种数据结构，实现了List接口，支持len操作，使用了适合ArrayList这种数据结构的算法来实现len，解决了上面的第三个问题。</li>
</ul>
<p>LinkedList：使用链表实现了List接口</p>
<ul>
<li>add(E element): 表示LinkedList这种数据结构，实现了List接口，支持add操作，使用了适合LinkedList这种数据结构的算法来实现add，解决了上面的第一个问题。</li>
<li>remove(E element): 表示LinkedList这种数据结构，实现了List接口，支持remove操作，使用了适合LinkedList这种数据结构的算法来实现remove，解决了上面的第二个问题。</li>
<li>len(): 表示LinkedList这种数据结构，实现了List接口，支持len操作，使用了适合LinkedList这种数据结构的算法来实现len，解决了上面的第三个问题。</li>
</ul>
<h2 id="静态数组实现"><a href="#静态数组实现" class="headerlink" title="静态数组实现"></a>静态数组实现</h2><p>静态数组可以实现List的功能吗？当然可以了。那么我们看一下静态数组的实现，有哪些好处和坏处。</p>
<p>我们现在定义一个接口，List，下面是接口支持的操作。</p>
<ul>
<li>build(x): 新建一个List。</li>
<li>len(): 返回数量</li>
<li>get_at(i): 获取i下标的元素</li>
<li>set_at(i, x): 设置i下标的元素为x</li>
<li>insert_at(i, x): 插入某一个位置</li>
<li>delete_at(i): 删除某一个位置的元素</li>
<li>insert_first(x): 将一个元素插入到第一个位置</li>
<li>insert_last(x)：将一个元素插入到最后一个位置</li>
<li>delete_fist()：删除第一个位置的元素</li>
<li>delete_last()：删除最后一个位置的元素</li>
</ul>
<p>通过静态数组来实现这个接口，也就是数组长度一旦确定就不可以改变了。</p>
<p>先看build，可以通过for去构建一个静态数组。其时间复杂度为O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(x)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">Int</span>[x.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; x.length; i++) &#123;</span><br><span class="line">        array[i] = x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录静态数组的长度</span></span><br><span class="line">    len = array.lenght;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为上面在构建的时候已经记录了长度，因此，可以直接返回。len的时间复杂度就是O(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">len</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于数组来说，我们知道它是内存中一段连续的空间，因此这个时候，我们的内存里面是这样的。假设x里面是1,2,3,4,5,6</p>
<p><img src="https://github.com/Thepatterraining/thepatterraining.github.io/blob/master/images/DataStructure/list1.png" alt="list1.png"></p>
<p>我们还知道一个int等于32位，4个字节，因此，假设元素1的地址是0，那么其余的地址如下图所示。</p>
<p><img src="/../images/DataStructure/list2.png" alt="list1.png"></p>
<p>因此，<code>get_at(i)</code>这个操作的时间复杂度同样是O(1)，因为可以直接计算出对应位置的地址，计算公式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第i个元素的地址 = 首地址 + （4 * i）</span><br><span class="line">i = 0的地址 = 0 + 0 = 0</span><br><span class="line">i = 1的地址 = 0 + 4 = 4</span><br></pre></td></tr></table></figure>

<p>伪代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get_at</span><span class="params">(i)</span> &#123;</span><br><span class="line">    <span class="comment">// 因为java语言会自动计算i这个下标对应的地址</span></span><br><span class="line">    <span class="keyword">return</span> array[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>set_at(i,x)</code>这个操作来说，同样的O(1)复杂度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set_at</span><span class="params">(i,x)</span> &#123;</span><br><span class="line">    array[i] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的操作都很快，但是如果我们想插入或者删除一个元素，对于<code>静态数组</code>这个数据结构来说，就很慢了。因为要移动元素。我们看一下操作<code>delete_at(i)</code>的执行过程。</p>
<p>假设delete_at(0)：表示删除第0个元素，也就是首个元素。</p>
<p>第一步，删除，我们可以看到地址0指向的首个元素的内容变成<code>null</code>了</p>
<p><img src="/../images/DataStructure/list3.png" alt="list1.png"></p>
<p>第二步，移动后面的元素到前面的位置。</p>
<p><img src="/../images/DataStructure/list4.png" alt="list1.png"></p>
<p>删除完成，这个时候肯定有人问了，不对啊，你这最后两个元素一样啊，是的，不用管它。</p>
<p>因为我们的len减少了，而获取的时候需要判断大小，如果获取的下标长度超过len了，应该返回空或错误。这个在上面的伪代码里面省略了。</p>
<blockquote>
<p>完整的代码做为课后作业，希望大家可以自己完成，只有自己实践了，知识才是自己的，你光看我写的内容，过一会就忘了，如果你觉得实现有困难，那么我的内容可以帮助你解决困难，帮助你自己实现它。</p>
</blockquote>
<p>伪代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete_at</span><span class="params">(i)</span> &#123;</span><br><span class="line">    <span class="comment">//第一步 删除 这一步其实可以省略，这里是希望大家明白原理</span></span><br><span class="line">    array[i] = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//第二步，移动后面的元素过来</span></span><br><span class="line">    <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">        array[j - <span class="number">1</span>] = array[j];</span><br><span class="line">    &#125;</span><br><span class="line">    len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>insert_at(i,x)</code>操作来说，和上面的原理几乎一样，分为两个步骤。</p>
<p>第一步，将i元素及后面的元素往后移动一步，把i这个位置腾出来。我们拿<code>insert(0,1)</code>来举例。</p>
<p>可以看到几乎是上方delete操作的一个逆序过程。</p>
<p><img src="/../images/DataStructure/list5.png" alt="list1.png"></p>
<p>现在可以看到0的位置已经空出来了，虽然里面还有一个2，但是我们可以覆盖它。</p>
<p>第二步，将1插入0的位置。</p>
<p><img src="/../images/DataStructure/list6.png" alt="list6.png"></p>
<p>如此，就完成了整个insert操作。伪代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert_at</span><span class="params">(i,x)</span> &#123;</span><br><span class="line">    <span class="comment">// 第一步 移动元素 注意从后往前移动</span></span><br><span class="line">    <span class="keyword">for</span> (j = len - <span class="number">1</span>; j &gt;= i; j--) &#123;</span><br><span class="line">        array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二步 插入</span></span><br><span class="line">    array[i] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细心的你，一定发现了上面的代码缺少边界检查，这些都留给你的具体实现了，都是比较简单的东西。</p>
<p>那么，对于<code>delete_at(i)</code>和<code>insert_at(i,x)</code>来说，我们的时间复杂度相当于O(n).</p>
<p>而剩下的<code>delete_first()</code>和<code>delete_last()</code>，以及<code>insert_first(x)</code>和<code>insert_last(x)</code>都是上方的一个真子集，所以时间复杂度同样是O(n)。就不再重复演示了。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>Build</th>
<th>Len</th>
<th>Get_at、Set_at</th>
<th>delete_at、insert_at</th>
<th>delete_last、insert_last</th>
<th>delete_first、insert_first</th>
</tr>
</thead>
<tbody><tr>
<td>静态数组的复杂度</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h2 id="链表的实现"><a href="#链表的实现" class="headerlink" title="链表的实现"></a>链表的实现</h2><p>除了直接用一个<code>Array</code>去实现以外，还可以用<code>链表</code>这个数据结构去实现List接口。也就是Java中的<code>LinkedList</code>实现。</p>
<p>我们首先看一下链表是如何实现build的。可以通过for去构建一个链表。其时间复杂度为O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(x)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(x[x.length - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(x[i]);</span><br><span class="line">        current.next = node;</span><br><span class="line">        node = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录链表的长度</span></span><br><span class="line">    len = x.lenght;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为上面在构建的时候已经记录了长度，因此，可以直接返回。len的时间复杂度就是O(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">len</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下链表这个数据结构的逻辑形式，如下图所示。一个一个指针把数据连接起来</p>
<ul>
<li>优点：不用连续的空间，长度不固定</li>
<li>缺点：查询慢</li>
</ul>
<p>val代表具体的内容，Next代表下一个节点的指针，内容是下一个节点的地址。最后一个节点的Next指针是null。<br><img src="/../images/DataStructure/list7.png" alt="list7.png"></p>
<p>而在实际内存中的表现形式则是下图所示。这里是连续的，仅仅是巧合，也可能是不连续的。在这里我们忽略class头的占用，this指针的占用空间，val占据空间是4个字节，next做为指针是64位，占用8个字节。<br><img src="/../images/DataStructure/list8.png" alt="list7.png"></p>
<p>由于链表的地址不连续，所以没办法通过首地址直接计算出每个元素的地址，而需要通过<code>next</code>属性来获取下一个元素的地址。</p>
<p>整个<code>get_at(i)</code>的获取步骤如下</p>
<ol>
<li>获取首个元素的地址</li>
<li>获取该元素的next属性</li>
<li>重复第2步，直到重复了i次</li>
<li>返回该元素内容</li>
</ol>
<p>整个步骤如图所示。假设是<code>get_at(2)</code>，代表获取第三个元素。也就是3这个内容。因为是从0开始。</p>
<p><img src="/../images/DataStructure/list9.png" alt="list7.png"></p>
<p>伪代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get_at</span><span class="params">(i)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="literal">null</span> &amp;&amp; i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，因为每次都要从头找，所以时间复杂度是O(n)</p>
<p>再看一下<code>set_at(i, x)</code>。也基本上是同样的步骤，找到这个元素，然后更新它的val属性内容。步骤图和上面是一样的。所以时间复杂度同样是O(n)。直接看一下伪代码吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set_at</span><span class="params">(i, x)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="literal">null</span> &amp;&amp; i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到几乎是一样的。</p>
<p>再来看一下<code>insert_at(i, x)</code>和<code>delete_at(i)</code>。首先看一下<code>delete_at(i)</code>。</p>
<p>比如<code>delete_at(2)</code> 分为两步，第一步查询，和上面的步骤是一样的。</p>
<p><img src="/../images/DataStructure/list9.png" alt="list7.png"></p>
<p>第二步是删除。删除分为2步</p>
<ol>
<li>将上一个指针的next指向第i+1个元素。可以看到图里更新成36了</li>
<li>将第i个元素的next指针更新成null</li>
</ol>
<p><img src="/../images/DataStructure/list10.png" alt="list7.png"></p>
<p>整个伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete_at</span><span class="params">(i)</span> &#123;</span><br><span class="line">    <span class="comment">// 第一步 找到i-1的元素</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="literal">null</span> &amp;&amp; i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二步删除</span></span><br><span class="line">    <span class="comment">// 2.1 将i-1个元素的next指向i+1</span></span><br><span class="line">    inode = node.next;</span><br><span class="line">    node.next = node.next.next;</span><br><span class="line">    <span class="comment">// 2.2 将第i个元素的next指针更新成null</span></span><br><span class="line">    inode.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家在想一想，如果是<code>delete(x)</code>的话，该如何实现呢？</p>
<blockquote>
<p>提示：仅仅修改获取元素即可，修改成x &#x3D;&#x3D; node.val，就是找到了。可以使用双向链表实现。</p>
</blockquote>
<p>再看一下<code>insert_at(i,x)</code>的执行步骤，分为两步。</p>
<p>第一步是查询，和上面也是一样的。</p>
<p><img src="/../images/DataStructure/list9.png" alt="list7.png"></p>
<p>第二步是插入，插入分为两步</p>
<ol>
<li>修改插入节点的next指向当前i节点的next</li>
<li>修改当前i-1节点的next指向插入节点</li>
</ol>
<p>我们以<code>insert_at(2,3)</code>为例。首先找到i&#x3D;0，再找到i&#x3D;1的位置就是要插入的位置，因为要插入的位置是2，所以我们要把i&#x3D;1的元素的next指向插入的节点。所以找到i&#x3D;1的元素就可以停止了。</p>
<p><img src="/../images/DataStructure/list11.png" alt="list7.png"></p>
<p>整个伪代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert_at</span><span class="params">(i,x)</span> &#123;</span><br><span class="line">    <span class="comment">// 第一步 找到i-1的元素</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="literal">null</span> &amp;&amp; i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二步插入</span></span><br><span class="line">    <span class="comment">// 2.1 修改插入节点的next指向当前i节点的next</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">insertNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(x);</span><br><span class="line">    insertNode.next = node.next;</span><br><span class="line">    <span class="comment">// 2.2 修改当前i-1节点的next指向插入节点</span></span><br><span class="line">    node.next = insertNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述两个操作对于<code>链表</code>数据结构来说，实现的时间复杂度都是O(n)。</p>
<p>但是链表相对于静态数组来说，其优势再于剩下的操作的实现。</p>
<p>比如<code>insert_first(x)</code>和<code>delete_first()</code>。对于这两个来说，不需要查找，因为删除的是第一个元素。所以省去了查找时间，插入和删除时间仅仅是O(1)。</p>
<p>看一下<code>insert_first(10)</code>。</p>
<ul>
<li>创建插入节点insertNode</li>
<li>修改插入节点的next指向当前head节点的next:insertNode.next &#x3D; head.next;</li>
<li>修改当前head节点的next指向插入节点</li>
</ul>
<p>从伪代码也能看出来，完全就是上面伪代码的第二步插入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert_first</span><span class="params">(x)</span> &#123;</span><br><span class="line">    <span class="comment">// 第二步插入</span></span><br><span class="line">    <span class="comment">// 2.1 修改插入节点的next指向当前i节点的next</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">insertNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(x);</span><br><span class="line">    insertNode.next = head.next;</span><br><span class="line">    <span class="comment">// 2.2 修改当前i-1节点的next指向插入节点</span></span><br><span class="line">    head.next = insertNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>delete_first()</code>来说，是一样的，就是第二步删除。这里是从0开始，head原来是指向元素0，删除元素0，就是指向元素1.</p>
<ol>
<li>将head指针的next指向第1个元素。</li>
<li>将第0个元素的next指针更新成null</li>
</ol>
<p>伪代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete_first</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 第二步删除</span></span><br><span class="line">    <span class="comment">// 2.1 将head指针的next指向第1个元素。</span></span><br><span class="line">    inode = head;</span><br><span class="line">    head = head.next;</span><br><span class="line">    <span class="comment">// 2.2 将第0个元素的next指针更新成null</span></span><br><span class="line">    inode.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们还记录了<code>tail</code>指针来指向链表的尾部，那么<code>delete_last()</code>和<code>insert_last(x)</code>也是O(1)复杂度。</p>
<p>如果没有的话，那么就是O(n)复杂度。这里不再赘述。</p>
<p>整个链表数据结构，也就是常说的<code>LinkedList</code>实现，复杂度表如下。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>Build</th>
<th>Len</th>
<th>Get_at、Set_at</th>
<th>delete_at、insert_at</th>
<th>delete_last、insert_last</th>
<th>delete_first、insert_first</th>
</tr>
</thead>
<tbody><tr>
<td>链表的复杂度</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h2 id="动态数组的实现"><a href="#动态数组的实现" class="headerlink" title="动态数组的实现"></a>动态数组的实现</h2><p>什么是动态数组呢？</p>
<ul>
<li>融合了上面两个的优点</li>
<li>既保证了查询的高效，也保证了插入和删除的高效。</li>
</ul>
<p>如何做到的呢？这也就是JAVA中<code>ArrayList</code>做到的事情。一起来看一下吧。</p>
<p>对于build和len，就不再重复了，可以直接参考静态数组的实现。</p>
<p>这里主要看一下其余的操作。</p>
<p>对于<code>get_at(i)</code>来说，由于使用的是数组，所以同样的O(1)复杂度，ArrayList数据结构也是一块连续的内存空间，可以通过公式直接计算出i元素的内存位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第i个元素的地址 = 首地址 + （4 * i）</span><br><span class="line">i = 0的地址 = 0 + 0 = 0</span><br><span class="line">i = 1的地址 = 0 + 4 = 4</span><br></pre></td></tr></table></figure>

<p>伪代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get_at</span><span class="params">(i)</span> &#123;</span><br><span class="line">    <span class="comment">// 因为java语言会自动计算i这个下标对应的地址</span></span><br><span class="line">    <span class="keyword">return</span> array[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>set_at(i,x)</code>这个操作来说，同样的O(1)复杂度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set_at</span><span class="params">(i,x)</span> &#123;</span><br><span class="line">    array[i] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点在接下来。敲黑板了！！！</p>
<p>对于<code>insert_last(x)</code>和<code>delete_at(i)</code>来说。我们看一下实现。</p>
<p>以<code>insert_last(1)</code>来说吧。由于是动态数组，是可以扩容的。假设当前内存是空.然后我们插入1.</p>
<p><img src="/../images/DataStructure/list12.png" alt="list7.png"></p>
<p>在接下来我们要插入2.也就是<code>insert_last(2)</code>。但是这个数组没有空间了，我们需要扩容，比如我们扩容一倍，也就是申请两个内存，现在的内存首地址就不是1了，可能是10-17.</p>
<p>然后再把原来数组的内容复制过去，在插入新的元素2.</p>
<p><img src="/../images/DataStructure/list13.png" alt="list7.png"></p>
<p>接下来又插入了元素3.再次扩容，内存地址是20-35。同样把内容复制过去，在插入元素3.</p>
<p><img src="/../images/DataStructure/list14.png" alt="list7.png"></p>
<p>至于原来那些不用的数组的内存空间，会被JAVA的内存垃圾回收机制，给回收掉。所以不用管。</p>
<p>接下来计算一下它的时间复杂度吧。</p>
<p>因为我们是每次扩容一倍，所以分别是在1、2、4、8、…、n的时候扩容。<br>因此，当我们插入n个元素的时候，时间复杂度是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O(1+2+4+8...+n)</span><br></pre></td></tr></table></figure>

<p>它可以看成是一个级数。i&#x3D;i 到 i&#x3D;n，2的i次方相加。</p>
<p>这个结果，基本上是O(n)的一个复杂度。</p>
<p>这个时候有人说了，这个复杂度不还是O(n)吗，可是我们插入了n个元素，复杂度是O(n)，平均下来，插入1个元素的复杂度就是O(1)了啊。</p>
<p>对于<code>delete_last</code>来说，和上面是一样的。</p>
<p>因此动态数组，<code>ArrayList</code>。的复杂度如下。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>Build</th>
<th>Len</th>
<th>Get_at、Set_at</th>
<th>delete_at、insert_at</th>
<th>delete_last、insert_last</th>
<th>delete_first、insert_first</th>
</tr>
</thead>
<tbody><tr>
<td>动态数组的复杂度</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看到最常用的几个操作里面，ArrayList这个数据结构的复杂度是最低的。</p>
<p>因此，ArrayList几乎一直都比LinkedList好用。</p>
<p>整体的复杂度表格如下。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>Build</th>
<th>Len</th>
<th>Get_at、Set_at</th>
<th>delete_at、insert_at</th>
<th>delete_last、insert_last</th>
<th>delete_first、insert_first</th>
</tr>
</thead>
<tbody><tr>
<td>静态数组的复杂度</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>链表的复杂度</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>动态数组的复杂度</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
</tbody></table>
<p>get_at就是List接口中常用的get()，insert_last就是List接口中常用的add操作，而delete_at就是List接口中常用的remove操作。</p>
<p>来看一下LinkedList和ArrayList的对比吧。可以看到，对于LinkedList来说，get和remove都是O(n)，而ArrayList来说，只有remove是O(n)。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>Build</th>
<th>Len</th>
<th>get</th>
<th>remove</th>
<th>add</th>
</tr>
</thead>
<tbody><tr>
<td>LinkedList的复杂度</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>ArrayList的复杂度</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论</title>
    <url>/java%E6%A0%B8%E5%BF%83.html</url>
    <content><![CDATA[<h1 id="jvm核心"><a href="#jvm核心" class="headerlink" title="jvm核心"></a>jvm核心</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="jvm基础知识"><a href="#jvm基础知识" class="headerlink" title="jvm基础知识"></a>jvm基础知识</h3><h3 id="java字节码"><a href="#java字节码" class="headerlink" title="java字节码"></a>java字节码</h3><p>Java bytecode由单字节的指令组成，类似汇编，java使用了200多个操作码</p>
<ul>
<li>栈操作指令</li>
<li>程序流程控制指令</li>
<li>对象操作指令</li>
<li>算术运算以及类型转换指令</li>
</ul>
<p>javap可以看到字节码文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javap -c -verbose ...</span><br></pre></td></tr></table></figure>

<p>astore_1 代表store 本地变量表的slot 1，a代表引用类型<br>istore代表int store</p>
<p>算数操作</p>
<p>类型转换</p>
<p>方法调用指令</p>
<ul>
<li>invokestatic: 调用静态方法</li>
<li>invokespecial: 用来调用构造函数，或同一个类中的private方法，以及超类方法</li>
<li>invokevirtual: 调用公共，受保护和package级的私有方法类似c的虚函数</li>
<li>invokeinterface: 调用接口方法</li>
<li>invokedynamic: lambda实现基础</li>
<li>new 创建对象</li>
<li>getfield: 获取对象的实例字段</li>
<li>putfield: 设置对象的实例字段</li>
</ul>
<p>栈操作指令</p>
<ul>
<li>pop：将栈顶的一个数值弹出（丢弃）。</li>
<li>dup：复制栈顶的一个数值。</li>
<li>swap：交换栈顶的两个数值。</li>
</ul>
<p>条件跳转指令</p>
<ul>
<li>if_icmpeq：如果栈顶两个int值相等，则跳转。</li>
<li>if_icmpne：如果栈顶两个int值不相等，则跳转。</li>
<li>goto：无条件跳转到指定位置。</li>
<li>tableswitch：根据值选择跳转位置，用于switch语句。</li>
</ul>
<p>同步指令</p>
<ul>
<li>monitorenter：进入同步代码块。</li>
<li>monitorexit：退出同步代码块。</li>
</ul>
<h3 id="JVM类加载器"><a href="#JVM类加载器" class="headerlink" title="JVM类加载器"></a>JVM类加载器</h3><p>引导类加载器</p>
<ul>
<li>引导类加载器是最顶层的类加载器，负责加载 Java 核心库中的类（例如 java.lang.* 包中的类）。这些类一般位于 JRE 目录下的 rt.jar 文件中。</li>
<li>它是由 C++ 编写的，直接由操作系统加载，因此没有 Java 类的实现。</li>
<li>它默认从 JRE&#x2F;lib 路径下加载类。</li>
</ul>
<p>扩展类加载器</p>
<ul>
<li>扩展类加载器负责加载 Java 扩展库中的类。这些类通常位于 JRE&#x2F;lib&#x2F;ext 目录下，或者由 java.ext.dirs 系统属性指定的其他路径。</li>
<li>它是由 Java 编写的，属于标准的类加载器。</li>
<li>它默认从 JRE&#x2F;lib&#x2F;ext 目录和 java.ext.dirs 属性指定的路径加载类</li>
</ul>
<p>系统类加载器</p>
<ul>
<li>系统类加载器负责加载应用程序的类，也就是由用户编写的类。它通常从类路径（classpath）中加载类。</li>
<li>它是由 Java 编写的，通常是 ClassLoader 类的一个实例。用户可以指定 classpath 来告诉系统类加载器从哪里加载类。</li>
<li>它根据环境变量 CLASSPATH 或 -cp 命令行参数指定的路径加载类。</li>
</ul>
<p>自定义类加载器</p>
<ul>
<li>Java 还允许程序员创建自定义类加载器，来自定义类加载的行为。自定义类加载器可以扩展 ClassLoader 类并重写其 findClass() 方法，来实现从不同的数据源加载类，比如从数据库、网络等加载类。</li>
<li>自定义类加载器在很多场景中有用，比如在应用服务器中动态加载插件，或者从不常规的源（如数据库、网络等）加载类。</li>
</ul>
<p>类的生命周期</p>
<ul>
<li>加载： 找class文件，类加载器通过 findClass() 方法从指定的位置查找 .class 文件。加载器会将 .class 文件转化为二进制字节流。</li>
<li>验证： 验证格式，依赖。验证阶段确保加载的 .class 文件格式正确，并且不包含任何有可能危害虚拟机安全的代码。</li>
<li>准备： 静态字段，方法表。准备阶段分配内存并为类变量（静态字段）设置默认值（如 0、null 等）。</li>
<li>解析： 符号解析为引用。解析阶段将类中的符号引用（例如字段、方法、类的名字等）解析为实际的内存地址或方法引用。</li>
<li>初始化： 构造器，静态变量赋值，静态代码块。初始化阶段是类加载过程的最后一步，它会执行类的静态初始化块（static 块）和静态字段的初始化。</li>
<li>使用</li>
<li>卸载</li>
</ul>
<p>图片</p>
<p>JVM 中的类加载器采用了父子委托机制（Parent Delegation Model）。当一个类加载器收到加载某个类的请求时，它不会直接去加载类，而是首先将请求委托给父类加载器。如果父类加载器无法加载，则再由当前加载器进行加载。这种机制的好处是可以保证 Java 核心类库不会被用户定义的类覆盖。</p>
<h3 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h3><p>java栈</p>
<ul>
<li>线程私有：存储线程的本地变量信息等</li>
<li>每个线程在执行方法时，都会在栈中创建一个栈帧（stack frame）。栈帧包含方法的局部变量、操作数栈、动态链接、方法返回地址等信息。栈的大小通常由 -Xss 参数进行控制。</li>
<li>局部变量的作用范围仅限于当前方法，存储在栈帧中。</li>
</ul>
<p>本地方法栈</p>
<ul>
<li>用于执行本地方法（即通过 JNI 调用的 C&#x2F;C++ 等语言编写的代码）。和 Java 栈类似，本地方法栈也包含栈帧，但栈帧里存储的是本地方法的相关信息。</li>
<li>每个线程有自己的本地方法栈。</li>
</ul>
<p>java堆</p>
<ul>
<li>共有</li>
<li>存储动态信息，如对象数据，包括对象的成员变量，成员函数，静态变量。因此多线程访问堆中的数据时需要进行同步，以保证数据的一致性和可见性。</li>
<li>堆是垃圾回收的主要区域。</li>
<li>垃圾回收器负责堆内存的管理，通过标记清除、复制回收、分代回收等算法来回收无用对象的内存。</li>
</ul>
<p>方法区</p>
<ul>
<li>方法区用于存储类信息、常量、静态变量、即时编译器（JIT）编译后的代码等数据。在 Java 7 之前，方法区和永久代（PermGen）是一个概念，但在 Java 8 中，永久代被 Metaspace（元空间）替代，Metaspace 位于本地内存中，而非堆中。</li>
<li>方法区是所有线程共享的，因此多线程访问时也需要注意同步。</li>
<li>存储类的元数据（类的结构、常量池等）、静态变量、方法等。</li>
</ul>
<p>运行时常量池</p>
<ul>
<li>运行时常量池是方法区的一部分，用于存储编译期间生成的字面量和符号引用（例如字符串常量和类、方法、字段的引用）。</li>
<li>常量池是所有线程共享的，所有类共享相同的常量池。</li>
</ul>
<p>直接内存</p>
<ul>
<li>直接内存并不是 JVM 内存模型的一部分，但它是通过 java.nio 包提供的 ByteBuffer 类实现的内存区域。直接内存可以绕过 JVM 的堆和垃圾回收机制，直接与操作系统的内存交互，用于提高 I&#x2F;O 性能。</li>
<li>直接内存可以由多个线程共享，但需要开发者手动管理。</li>
</ul>
<p>图片</p>
<p>图片</p>
<p>堆内存图片</p>
<p>堆内存</p>
<ul>
<li>年轻代<ul>
<li>新生代</li>
<li>存活区： 一般有两个</li>
</ul>
</li>
<li>老年代</li>
</ul>
<p>非堆</p>
<ul>
<li>元数据：以前是永久代</li>
<li>CCS: 存放class信息，和元数据有交叉</li>
<li>code cache: 存放JIT编译后的本地机器代码</li>
</ul>
<p>可见性</p>
<ul>
<li>当多个线程访问同一个共享变量时，一个线程对变量的修改可能对其他线程不可见。JMM 规定了变量的可见性，确保一个线程对共享变量的修改能够及时地被其他线程看到。</li>
</ul>
<h3 id="JVM启动参数"><a href="#JVM启动参数" class="headerlink" title="JVM启动参数"></a>JVM启动参数</h3><p>-开头是标准参数，如-server<br>-D设置系统属性，如-Dfile.encoding&#x3D;UTF-8<br>-X开头是非标准参数，基本都传给JVM的，默认JVM实现这些参数的功能。可以jvm -X查看支持的参数。如-Xmx8g<br>-XX开头是非稳定参数，专门控制jvm的行为，根具体的jvm实现有关</p>
<ul>
<li>-XX:+-Flags形式，+-是对布尔值进行开关。+代表开，-代表关。如-XX:_UseG1GC</li>
<li>-XX:key&#x3D;value形式，指定某个选项的值.如-XX:MaxPermSize&#x3D;256m</li>
</ul>
<h3 id="JDK内置工具"><a href="#JDK内置工具" class="headerlink" title="JDK内置工具"></a>JDK内置工具</h3><p>图片</p>
<p>jps&#x2F;jinfo 查看java进程<br>jstat 查看jvm gc信息<br>jmap 查看heap或类占用空间统计<br>jstack 查看线程信息<br>jcmd 执行jvm相关分析命令<br>jrunscript&#x2F;jjs 执行js命令</p>
<p>jstat -gc pid xxx</p>
<p>图片</p>
<p>jmap -heap 查看堆信息</p>
<p>jcmd可以查看所有信息</p>
<p>jconsole</p>
<p>jvisulVM</p>
<p>jMC</p>
<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>分代假设：大部分新生对象很快无用，存活较长时间的对象，可能存活更长时间。</p>
<p>经历了15次GC还存在的就放在老年代</p>
<p>新生代80%，S0,S1各10%<br>新生代到存活区是复制，到老年代是移动<br>-XX: +MaxTenuringThreshold&#x3D;15标记15次后放到老年代</p>
<p>可以做为GC ROOT的对象</p>
<ol>
<li>当前正在执行的方法里的局部变量和输入参数</li>
<li>活动线程</li>
<li>所有类的静态字段</li>
<li>JNI引用</li>
</ol>
<p>需要记录夸代的依赖信息</p>
<h4 id="Serial-GC-x2F-ParNewGC"><a href="#Serial-GC-x2F-ParNewGC" class="headerlink" title="Serial GC&#x2F;ParNewGC"></a>Serial GC&#x2F;ParNewGC</h4><p>-XX: +UseSerialGC开启</p>
<p>对年轻代使用mark-copy算法，对老年代使用mark-sweep-compact算法</p>
<p>串行GC不能并行处理，所以触发全部暂停(STW)</p>
<p>ParNewGC可以配合CMSGC使用</p>
<p>适用场景：</p>
<ul>
<li>单线程应用或资源有限的环境（如嵌入式系统）。</li>
<li>小型应用，不需要频繁的垃圾回收。</li>
</ul>
<h4 id="Parallel-GC"><a href="#Parallel-GC" class="headerlink" title="Parallel GC"></a>Parallel GC</h4><p>目标是最大化应用程序运行时间（吞吐量），最小化 GC 时间。还是会短暂的暂停业务。需要业务能接受短暂的暂停。</p>
<p>-XX: +UseParallelGC<br>-XX: +UseParallelOldGC</p>
<p>年轻代和老年代GC都会触发STW事件。</p>
<p>对年轻代使用mark-copy算法，对老年代使用mark-sweep-compact算法</p>
<p>-XX: ParallelGCThreads&#x3D;N 来指定GC线程数，默认值为CPU核心数。</p>
<p>优点：</p>
<ul>
<li>多线程回收显著提高了回收效率，适合多核环境。</li>
<li>停顿时间较 Serial GC 短。</li>
<li>两次GC之间不消耗系统资源。</li>
</ul>
<p>缺点：</p>
<ul>
<li>GC 停顿仍然是全暂停（STW）。</li>
<li>不适合对延迟要求苛刻的场景。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>需要高吞吐量的大型后台任务（如批处理、数据分析）。</li>
<li>多核 CPU 环境。</li>
</ul>
<h4 id="CMS-GC"><a href="#CMS-GC" class="headerlink" title="CMS GC"></a>CMS GC</h4><p>-XX: +UseConcMarkSweepGC</p>
<p>对年轻代使用STW的mark-copy算法，对老年代主要使用并发的mark-sweep算法</p>
<p>设计目标:专为老年代设计，目标是最小化 GC 停顿时间。</p>
<ol>
<li>不对老年代进行整理，而是使用空闲列表来管理内存空间的回收</li>
<li>在mark-and-sweep的工作和业务线程并发执行。</li>
</ol>
<p>默认并发线程数等于CPU核心数的1&#x2F;4</p>
<p>6个阶段</p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>并发预清理</li>
<li>最终标记</li>
<li>并发清楚</li>
<li>并发重制</li>
</ol>
<p>MaxHeapSize是系统的1&#x2F;4内存<br>MaxNewSize是MaxHeapSize的1&#x2F;3<br>NewSize是系统的1&#x2F;64</p>
<p>优点：</p>
<ul>
<li>只有yongGC暂停业务。GC 停顿时间短，适合延迟敏感的应用。</li>
<li>并发回收利用多核资源减少 STW 时间。</li>
</ul>
<p>缺点：</p>
<ul>
<li>内存碎片化：CMS 不会整理内存，可能导致分配大对象失败（触发 Full GC）。</li>
<li>CPU 开销较高：并发阶段可能与用户线程争抢资源。</li>
<li>容易产生 “Concurrent Mode Failure”：若老年代空间不足，回退到 Serial GC。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>延迟敏感的应用（如 Web 服务、在线交易系统）。</li>
<li>多核环境下的中大型应用。</li>
</ul>
<h4 id="G1-GC"><a href="#G1-GC" class="headerlink" title="G1 GC"></a>G1 GC</h4><p>分区堆内存：将堆划分为若干独立的固定大小的区域（Region），每个 Region 可充当年轻代、老年代或其他用途。混合回收：通过优先回收包含最多垃圾的 Region（Garbage-First）。并行和并发回收：减少 STW 时间。内置碎片整理机制，避免了 CMS 的碎片化问题。</p>
<p>-XX: +UseG1GC -XX: MaxGCPauseMillis&#x3D;50</p>
<p>将STW的时间和分布变成可预期和可配置的，可设置某项特定的性能指标，为了达成可预期的指标，有独特的实现。增量方式，每次处理一部分，称为回收集合，每次处理所有的年轻代和部分老年代。能看到哪个块的垃圾多，优先回收他们</p>
<p>处理步骤</p>
<ol>
<li>年轻代模式转移暂停</li>
<li>并发标记</li>
<li>转移暂停：混合模式</li>
</ol>
<p>G1GC可能退化成串行GC</p>
<ol>
<li>并发模式失败：增加堆大小</li>
<li>晋升失败：</li>
<li>巨型对象分配失败：增加内存或增大Region大小</li>
</ol>
<p>优点：</p>
<ul>
<li>减少内存碎片化。</li>
<li>更好地控制 GC 停顿时间，可通过 -XX:MaxGCPauseMillis 调整。</li>
<li>自动调节年轻代和老年代的大小。</li>
</ul>
<p>缺点：</p>
<ul>
<li>实现复杂，配置选项多。</li>
<li>内存占用较高，CPU 开销大。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>需要低延迟的中大型应用。</li>
<li>堆内存较大的环境（如 &gt;4GB）。</li>
<li>替代 CMS 的推荐选择。</li>
</ul>
<ol>
<li>如果系统考虑吞吐优先，CPU资源用来处理业务，用Parallel GC</li>
<li>如果系统考虑低延迟优先，每次GC时间尽量短，用CMS GC</li>
<li>如果系统内存堆大，平均GC时间可控，使用G1 GC</li>
</ol>
<h4 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h4><p>专注于低延迟，目标是将 GC 停顿时间控制在 10ms 以下。支持非常大的堆内存（TB 级）。使用多线程并发回收，避免长时间的 STW。基于标记-整理算法，避免内存碎片化。使用指针染色（Pointer Coloring）来实现并发标记和引用更新。</p>
<p>-XX: +UnlockExpermentalVMOptions<br>-XX: +UseZGC<br>-XX: -Xmx16g</p>
<p>优点：</p>
<ul>
<li>极低的 GC 停顿时间。</li>
<li>支持超大堆，扩展性好。</li>
<li>减少内存碎片。</li>
<li>与G1相比，应用吞吐量下降不超过15%</li>
</ul>
<p>缺点：</p>
<ul>
<li>内存占用较高：由于需要染色指针和写屏障。</li>
<li>不适合资源紧张的环境。</li>
</ul>
<p>-XX: +UseShenandoahGC</p>
<p>立项比ZGC早，暂停时间与堆大小无关</p>
<p>适用场景：</p>
<ul>
<li>延迟敏感的大型应用（如金融交易、高并发系统）。</li>
<li>超大堆应用（TB 级别内存）。</li>
</ul>
<h4 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h4><p>目标是极低延迟，尽可能减少 STW 时间。采用并发压缩技术（Concurrent Compaction），避免碎片化问题。大部分回收工作与应用线程并发执行。</p>
<p>优点：</p>
<ul>
<li>GC 停顿时间低。</li>
<li>内存整理避免碎片化。</li>
<li>对堆内存的需求比 ZGC 更低。</li>
</ul>
<p>缺点：</p>
<ul>
<li>较新的 GC，生态和调优支持可能不如 G1 和 ZGC。</li>
<li>CPU 开销高。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>延迟敏感的应用。</li>
<li>中大型堆内存的场景。</li>
</ul>
<h4 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h4><h4 id="JVM线程堆栈数据分析"><a href="#JVM线程堆栈数据分析" class="headerlink" title="JVM线程堆栈数据分析"></a>JVM线程堆栈数据分析</h4><p>图片</p>
<p>JVM内部线程</p>
<ul>
<li>VM线程：单例的VMThread对象，负责执行VM操作</li>
<li>定时任务线程：单例的WatcherThread对象，模拟计时器中断。</li>
<li>GC线程：垃圾回收</li>
<li>编译器线程：将字节码编译为本地机器代码</li>
<li>信号分发线程：等待进程指示的信号，并将其分配给java级别的信号处理</li>
</ul>
<p>安全点</p>
<ul>
<li>方法代码中植入检测入口</li>
<li>线程处于安全点状态：线程暂停执行，这个时候线程栈不再发生改变</li>
<li>JVM的安全点状态：所有线程都处于安全点状态</li>
</ul>
<p>fastthread</p>
<h4 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h4><p>Instrumentation.getObjectSize()</p>
<p>JOL可以看到内存布局</p>
<p>64位JVM中对象头占12byte，8字节对齐。Integer占16字节(8+4+对齐)，int占4字节。Long占16字节，long占8字节。</p>
<p>String对象的空间随着内部字符数组的增长而增长。String类的对象有24个字节的额外开销。</p>
<p>jhat</p>
<h4 id="JVM问题分析调优"><a href="#JVM问题分析调优" class="headerlink" title="JVM问题分析调优"></a>JVM问题分析调优</h4><p>分配速率:两次GC之间的年轻代使用量。也就是创建速度，流入速度。</p>
<ul>
<li>正常系统：分配速率较低 &lt; GC速率： 健康</li>
<li>内存溢出: 分配速率 &gt; GC速率： OOM</li>
<li>性能不好：分配速率较高 &lt; GC速率： 亚健康，可能随时导致内存溢出</li>
</ul>
<p>提升速率：从年轻代到老年代的数据量。</p>
<ul>
<li>有一些要被干掉的放到了老年代，老年代GC时间更长。</li>
</ul>
<p>一般来说过早提升的症状表现为以下形式：</p>
<ol>
<li>短时间内频繁的执行full GC</li>
<li>每次full GC后老年代的使用率都很低，在10%-20%或以下。</li>
<li>提升速率接近分配速率</li>
</ol>
<p>解决方案</p>
<ol>
<li>增加年轻代大小。-Xmx1g -XX:NewSize&#x3D;512M，FullGC的次数就会减少</li>
<li>减少每次批处理的数量</li>
</ol>
<p>Arthas工具</p>
<h4 id="GC疑难情况"><a href="#GC疑难情况" class="headerlink" title="GC疑难情况"></a>GC疑难情况</h4><h4 id="JVM常见面试题"><a href="#JVM常见面试题" class="headerlink" title="JVM常见面试题"></a>JVM常见面试题</h4><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><h3 id="java-socket"><a href="#java-socket" class="headerlink" title="java socket"></a>java socket</h3><p>java.net.ServerSocket类</p>
<h3 id="server处理发生了什么"><a href="#server处理发生了什么" class="headerlink" title="server处理发生了什么"></a>server处理发生了什么</h3><h3 id="IO模型和相关概念"><a href="#IO模型和相关概念" class="headerlink" title="IO模型和相关概念"></a>IO模型和相关概念</h3><p>阻塞非阻塞</p>
<p>同步异步</p>
<h3 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h3><p>高性能</p>
<ul>
<li>高并发</li>
<li>低延迟：延迟指服务端运行时间</li>
<li>高吞吐量</li>
</ul>
<h4 id="netty如何实现高性能"><a href="#netty如何实现高性能" class="headerlink" title="netty如何实现高性能"></a>netty如何实现高性能</h4><ul>
<li>异步</li>
<li>事件驱动</li>
<li>基于NIO</li>
</ul>
<p>粘包和拆包，主要通过解码器来解决，比如抄答案的时候两个多选题，答案写的abcd，你不知道是1.ab 2.cd还是1.a 2.bcd还是1.abc 2.d，所以中间需要来个标点符号区分。</p>
<ul>
<li>Fixed：固定长度解码器</li>
<li>LineBased：行分隔符，\n or \r\n</li>
<li>Delimiter: 分隔符解码器，可以自定义分隔符</li>
<li>LengthField: 长度编码解码器，划分为包文头，包文体</li>
<li>Json： JSON解码器</li>
</ul>
<p>网络拥堵和Nagle算法。TCP_NODELAY 可以关掉Nagle算法<br>触发条件，达到下面的条件才会真正向网络发送数据</p>
<ul>
<li>缓冲区满</li>
<li>达到超时</li>
</ul>
<p>优化</p>
<ol>
<li>不要阻塞EventLoop</li>
<li>系统参数优化</li>
<li>缓冲区优化</li>
<li>心跳周期优化</li>
<li>内存和buffer优化</li>
</ol>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>start以后陷入JVM线程，然后OS线程，最后TLAB,准备好了运行以后开始运行状态，run状态。</p>
<p>重要属性</p>
<ul>
<li>线程名称</li>
<li>是否后台执行</li>
<li>任务</li>
<li>start 启动</li>
<li>join 等待执行完成</li>
<li>currentThread 静态方法，获取当前线程信息</li>
<li>sleep 静态方法，线程睡眠并让出时间片</li>
<li>wait 释放锁，等待</li>
<li>notify 唤醒一个</li>
<li>notifyAll 唤醒所有</li>
<li>yield 让出cpu资源</li>
</ul>
<p>原子性<br>可见性<br>有序性</p>
<p>图片</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul>
<li>核心线程数</li>
<li>最大线程数</li>
<li>队列</li>
<li>拒绝策略</li>
</ul>
<p>为什么核心线程数满了以后先放到队列里面？因为要平衡CPU密集型应用和IO密集型应用</p>
<p>拒绝策略</p>
<ul>
<li>丢弃任务抛出异常</li>
<li>丢弃任务不抛出异常</li>
<li>丢弃队列最前面的任务，重新提交被拒绝的任务</li>
<li>由调用线程处理该任务</li>
</ul>
<p>线程池创建</p>
<ul>
<li>Executors.newSingleThreadExecutor : 仅仅创建一个线程的线程池</li>
<li>Executors.newFixedThreadPool：固定大小的</li>
<li>Executors.newCachedThreadPool：可缓存的线程池，如果线程超过了执行任务所需的，60s不执行任务的会被回收，任务增加的时候可以智能增加线程数，线程大小依赖于操作系统</li>
<li>Executors.newScheduledThreadPool：支持定时以及周期性执行</li>
</ul>
<p>核心线程数，如果CPU密集型，可以N+1或者N,如果IO密集型，可以2N或者2N+2</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul>
<li><p>Sync</p>
</li>
<li><p>ReentrantLock</p>
</li>
<li><p>ReadWriteLock</p>
</li>
<li><p>Condition</p>
</li>
<li></li>
<li><p>可重入锁</p>
</li>
<li><p>公平锁</p>
</li>
</ul>
<p>LockSupport 类似Executors</p>
<ul>
<li>park</li>
<li>parkNanos</li>
<li>unpark</li>
</ul>
<p>三个用锁的最佳实践</p>
<ul>
<li>永远只在更新对象的成员变量时加锁</li>
<li>永远只在访问可变的成员变量时加锁</li>
<li>永远不在调用其他对象的方法时加锁</li>
</ul>
<h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>通过volitale和CAS实现</p>
<p>LongAdder对AtomicLong的改进</p>
<h3 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h3><h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>准入数量 信号量</p>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><h4 id="arrayList"><a href="#arrayList" class="headerlink" title="arrayList"></a>arrayList</h4><p>默认大小10，扩容1.5， new &#x3D; old + (old &gt;&gt; 1)</p>
<p>线程不安全</p>
<p>写写冲突<br>读写冲突 iterator</p>
<h4 id="linkedList"><a href="#linkedList" class="headerlink" title="linkedList"></a>linkedList</h4><p>链表实现不需要扩容</p>
<p>线程不安全</p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>写时复制线程安全，写加锁</p>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>加锁的ArrayList</p>
<h4 id="List-asList"><a href="#List-asList" class="headerlink" title="List.asList"></a>List.asList</h4><p>只能set，不能添加删除元素</p>
<h4 id="Collections-SyncList"><a href="#Collections-SyncList" class="headerlink" title="Collections.SyncList"></a>Collections.SyncList</h4><p>加锁的ArrayList</p>
<h4 id="Collections-noModifyList"><a href="#Collections-noModifyList" class="headerlink" title="Collections.noModifyList"></a>Collections.noModifyList</h4><p>不可插入删除set的list</p>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>初始容量16，扩容*2，负载因子0.75, jDK8以后，链表长度8，数组长度64以后，改成红黑树</p>
<ul>
<li>写冲突</li>
<li>读写问题</li>
<li>keys()无序问题</li>
</ul>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>继承HashMap, 增加了双向链表，保证有序</p>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>线程安全 JDK7用的extendible hash 实现，分段</p>
<p>JDK8改成一个大叔组</p>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>线程本地变量<br>不改方法签名静默传参<br>及时进行清理</p>
<h4 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h4><p>static变量<br>Lock<br>Sync</p>
<p>协作</p>
<ul>
<li>Thread#join();</li>
<li>Object#wait&#x2F;notify&#x2F;notifyall</li>
<li>Future&#x2F;Callable</li>
<li>CountdownLatch</li>
<li>CyclicBarrier</li>
</ul>
<p>进程间通信</p>
<h3 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h3><h4 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h4><p>集群：多个相同服务，对等的关系<br>分布式：有角色关系，多个服务处理不一样的东西</p>
<p>服务汇聚到ESB：服务编排，网关</p>
<ol>
<li>暴露调用</li>
<li>增强和中介</li>
<li>统计和监控</li>
</ol>
<p>缺点是中心节点，增加一层</p>
<p>分布式服务化：用配置和注册发现代替ESB单节点，使请求直连</p>
<p>有状态的部分放到配置中心和注册中心，无状态的部分放到应用侧。比如RPC放到应用侧。</p>
<p>配置中心：全局非业务参数<br>注册中心：运行期临时状态<br>元数据中心：核心的业务模型</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>两种消息模式：</p>
<ul>
<li>点对点</li>
<li>发布订阅</li>
</ul>
<p>消息处理的保障</p>
<ul>
<li>At most once,至多一次，只发一次，消息丢失了也不重发</li>
<li>At least once, 至少一次，消息不回丢失，可能会重复</li>
<li>Exactly once, 精确一次，每条消息肯定会被传输一次且仅一次，不丢失不重复</li>
</ul>
<p>消息处理的事务性</p>
<ul>
<li>通过确认机制实现事务性</li>
<li>可以被事务管理器管理，甚至可以支持XA分布式事务</li>
</ul>
<p>有序性</p>
<ul>
<li>同一个Topic或Queue的消息，保障顺序</li>
<li>消息分区，批量预取等可能会无序</li>
</ul>
<p>书籍企业集成模式</p>
<p>消息协议</p>
<ul>
<li>AMQP：规定了序列化，网路传输等</li>
<li>MQTT：遥感常用</li>
<li>JMS：java规定的接口</li>
<li>XMPP： IM用的</li>
</ul>
<p>kafka<br>ack &#x3D; 0 ,不管成功没<br>ack &#x3D; 1, 写到leader就成功<br>ack &#x3D; -1&#x2F;all 写到最小副本数才算成功</p>
<p>顺序保证<br>per.connetion &#x3D; 1<br>send()<br>flush()</p>
<p>消息可靠性</p>
<ul>
<li>消息的事务，发送的时候要么全成功，要么全失败，ack &#x3D; all，idem&#x3D;true打开幂等,transaction.id tx0001设置事务ID,begin开始事务</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论</title>
    <url>/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA.html</url>
    <content><![CDATA[<h1 id="算法导论"><a href="#算法导论" class="headerlink" title="算法导论"></a>算法导论</h1><p>目标一：解决计算问题，除此之外还有更多。more than that<br>目标二：证明正确性<br>目标三：证明更高效<br>目标四：可以和其他人讲明白为什么正确且高效</p>
<h2 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h2><p>算法就是用来求解问题的，我们想求解一组通用的问题，而不是固定的问题。算法的实现就是一个函数，给定一组输入，得到一个正确的输出。</p>
<p>数学归纳法证明算法的正确性。</p>
<p><code>循环不变式</code>主要用来帮助我们理解算法的正确性。我们必须证明三条性质</p>
<ol>
<li>初始化：循环的第一次迭代之前它为真</li>
<li>保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真</li>
<li>终止：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的</li>
</ol>
<p>通过循环不变式证明插入排序是正确的，下面是插入排序的伪代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">insert_sort(A)</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">2</span> to A.length</span><br><span class="line">        key = A[j]</span><br><span class="line">        i = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> and A[i] &gt; key</span><br><span class="line">            A[i+<span class="number">1</span>] = A[i]</span><br><span class="line">            i--</span><br><span class="line">        A[i+<span class="number">1</span>] = key</span><br></pre></td></tr></table></figure>

<p>循环不变式开始的时候，j &#x3D; 2的时候，A[1]…A[j-1]里面只有一个元素A[1]，当然是已排序的。循环不变式成立<br>保持：证明每次迭代保持循环不变式，非形式化的来看，4-7行将A[j-1],A[j-2]等向右移动，第8行将key插入合适的位置，子数组由原来的A[1]…A[j-1]组成，且已经排好序，下一次迭代增加j将保持循环不变式。</p>
<blockquote>
<p>如果是形式化的处理，还需要证明while循环的循环不变式。我们不愿陷入形式主义的困境，所以只根据非形式化的来看。<br>终止：for 循环的终止条件是 j &gt; A.length, 因为每次循环j+1，所以必然会有j &#x3D; A.length + 1,我们的子数组A[1]…A[j-1]，就变成了A[1]…A[A.length]由原来的A[1]…A[A.length]组成，且已排好序。因此算法正确</p>
</blockquote>
<p>练习1.重新insert_sort，使排序变成降序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">insert_sort(A)</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">2</span> to A.length</span><br><span class="line">        key = A[j]</span><br><span class="line">        i = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> and A[i] &lt; key</span><br><span class="line">            A[i+<span class="number">1</span>] = A[i]</span><br><span class="line">            i--</span><br><span class="line">        A[i+<span class="number">1</span>] = key</span><br></pre></td></tr></table></figure>

<h2 id="数据结构和动态数组"><a href="#数据结构和动态数组" class="headerlink" title="数据结构和动态数组"></a>数据结构和动态数组</h2><ul>
<li>Interface(API&#x2F;ADT): 你想做什么？是一种规范，定义了支持哪些操作。可以理解为问题。</li>
<li>Data Structure: 实际怎么做，数据实际的表示形式。算法对于操作的支持。可以理解为解决方案。</li>
</ul>
<p>接口：</p>
<ul>
<li>Sequence<ul>
<li>Static Sequence Interface: 静态的，数量不可变的。<ul>
<li>build(x): 新建一个Static Sequence。</li>
<li>len(): 返回数量</li>
<li>iter_seq(): 迭代器</li>
<li>get_at(i): 获取i下标的元素</li>
<li>set_at(i, x): 设置i下标的元素为x</li>
<li>get_first()</li>
<li>get_last()</li>
<li>set_first()</li>
<li>set_last()</li>
</ul>
</li>
<li>Dynamic Sequence Interface: 动态的，数量可变的<ul>
<li>支持上面所有</li>
<li>insert_at(i, x): 插入某一个位置</li>
<li>delete_at(i): 删除某一个位置的元素</li>
<li>insert_first()</li>
<li>insert_last()</li>
<li>delete_fist()</li>
<li>delete_last()</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>数据结构：</p>
<ul>
<li>Linked List</li>
</ul>
<h2 id="Set-And-Sorting"><a href="#Set-And-Sorting" class="headerlink" title="Set And Sorting"></a>Set And Sorting</h2><p>接口</p>
<ul>
<li>Set<ul>
<li>Container<ul>
<li>build(A): 根据一个iterable的A,创建</li>
<li>len(): 返回数量</li>
</ul>
</li>
<li>Static <ul>
<li>find(k): 返回一个set中的元素</li>
</ul>
</li>
<li>Dynamic <ul>
<li>insert(k): 插入一个元素到set</li>
<li>delete(k): 从set中删除一个元素</li>
</ul>
</li>
<li>Order <ul>
<li>iter_ord(): 迭代器</li>
<li>find_min(): 获取最小的key</li>
<li>find_max(): 获取最大的key</li>
<li>find_next(k): 获取比k大的下一个key</li>
<li>find_pre(k): 获取比k小的上一个key</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>数据结构</p>
<ul>
<li>Array</li>
<li>Sorted Array</li>
</ul>
<p>排序</p>
<ul>
<li>破坏性：用一个新的排序后的数组B覆盖数组A</li>
<li>原地排序：仅仅用O(1)空间来排序</li>
</ul>
<p>permutation Sort</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论</title>
    <url>/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0.html</url>
    <content><![CDATA[<h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><p>线性代数的基本问题是求解线性方程组</p>
<h2 id="Ax-x3D-b"><a href="#Ax-x3D-b" class="headerlink" title="Ax &#x3D; b"></a>Ax &#x3D; b</h2><p>给定两个方程：<code>2x - y = 0</code> 和 <code>-x + 2y = 3</code>。<br>对于<code>row picture</code> 矩阵是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2, -1] [x] = [0]</span><br><span class="line">[-1, 2] [y]   [3]</span><br><span class="line">A        X  =  b</span><br></pre></td></tr></table></figure>

<p>画图为</p>
<p>对于<code>column picture</code> 矩阵是下图，矩阵叫做<code>列的线性组合</code>，解出来x &#x3D; 1, y &#x3D; 2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x [2 ]   + y [-1] = [0]</span><br><span class="line">  [-1]       [2 ]   [3]</span><br></pre></td></tr></table></figure>

<p>画图为</p>
<p>矩阵和向量的乘法：</p>
<p>1 2 3<br>4 5 6<br>7 8 9 &#x3D; 1｜5 6｜ - 2 |4 6| + 3 |4 5|<br>         |8 9|    |7 9|       |7 8| &#x3D; 1 * -3 - (2 * -6) + (3 * -3) &#x3D; -3 + 12 - 9 &#x3D; 0</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JAM核心技术</title>
    <url>/JAM%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html</url>
    <content><![CDATA[<h1 id="JAM核心技术"><a href="#JAM核心技术" class="headerlink" title="JAM核心技术"></a>JAM核心技术</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>spring Cloud Stream</title>
    <url>/springCloudStream.html</url>
    <content><![CDATA[<h1 id="springCloudStream"><a href="#springCloudStream" class="headerlink" title="springCloudStream"></a>springCloudStream</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Spring Cloud Stream</code>是一个框架，用于构建与共享消息传递系统连接的高度可扩展的事件驱动微服务。</p>
<p>该框架提供了一个灵活的编程模型，该模型建立在已经建立和熟悉的 Spring 习惯用语和最佳实践之上，包括对持久发布&#x2F;订阅语义、消费者组和有状态分区的支持。</p>
<p>核心模块</p>
<ul>
<li>Destination Binders： 负责提供与外部消息系统集成的组件</li>
<li>Destination Bindings： 外部消息系统和用户程序代码之间的桥梁(生产者-使用者之间的桥梁)</li>
<li>Message：生产者和消费者用于与Destination Binders（以及通过外部消息系统与其他应用程序）通信的规范数据结构。</li>
</ul>
<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>Spring 的数据集成之旅始于 Spring Integration。通过其编程模型，它提供了一致的开发人员体验来构建应用程序，这些应用程序可以采用企业集成模式来连接外部系统，例如数据库、消息代理等。</p>
<p>快进到云时代，微服务在企业环境中变得突出。Spring Boot 改变了开发人员构建应用程序的方式。借助 Spring 的编程模型和 Spring Boot 处理的运行时职责，可以无缝开发独立的、基于 Spring 的生产级微服务。</p>
<p>为了将其扩展到数据集成工作负载，Spring Integration 和 Spring Boot 被放在一个新项目中。Spring Cloud Stream 诞生了。</p>
<h3 id="架构模型"><a href="#架构模型" class="headerlink" title="架构模型"></a>架构模型</h3><p><img src="/../images/spring-stream-01.png" alt="stream"></p>
<p>这张图是spring-stream官网的，里面的<code>Middleware</code>指的就是<code>RabbitMQ</code>或者<code>KafKa</code>这些消息队列。</p>
<p>下图是我们原来和消息队列通信的方式。我们的程序直接发送数据给MQ或者监听到MQ的数据。</p>
<p><img src="/../images/spring-stream-02.png" alt="stream"></p>
<p>通过<code>spring stream</code>来做的话，就增加了<code>Binder</code>层来做统一调度，我们的程序只需要和Binder层通信，不需要关注底层的MQ是<code>RabbitMQ</code>还是<code>Kafka</code>。</p>
<p>目前官方提供了两个<code>Binder</code>，分别是<code>RabbitMQ</code>的和<code>Kafka</code>的，其余队列的有一些第三方维护的。同时我们也可以自己实现<code>Binder</code>。</p>
<p>一开始图中的<code>Input</code>和<code>Output</code>是对于<code>spring stream</code>来说的，input就是输入消息到stream中，output就是输出消息到我们的程序中。</p>
<p>简单介绍一下Binder，其实就是<code>策略模式</code>，统一接口实现，比如MQ1里面发送消息到MQ的方法叫<code>Publish</code>，MQ2里面发送消息到MQ的方法叫<code>Release</code>，但是在Binder接口里面提供了一个方法，就叫做<code>add</code>。也只需要提供一个Message消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Binder</span>&#123;</span><br><span class="line">    function <span class="title function_">add</span><span class="params">(Message msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接MQ1的Binder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Binder1</span> <span class="keyword">implements</span> <span class="title class_">Binder</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> function <span class="title function_">add</span><span class="params">(Message msg)</span>&#123;</span><br><span class="line">        <span class="comment">// 消息处理</span></span><br><span class="line">        <span class="comment">// 发送到MQ1</span></span><br><span class="line">        publish(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接MQ2的Binder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Binder2</span> <span class="keyword">implements</span> <span class="title class_">Binder</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> function <span class="title function_">add</span><span class="params">(Message msg)</span>&#123;</span><br><span class="line">        <span class="comment">// 消息处理</span></span><br><span class="line">        <span class="comment">// 发送到MQ2</span></span><br><span class="line">        release(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们使用的时候只需要自己决定使用哪个Binder就可以了。就是就和连接数据库一样，不需要关心连接的是Mysql还是PostgreSql。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> function <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Binder</span> <span class="variable">binder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Binder1</span>();</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">        binder.add(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Bindings"><a href="#Bindings" class="headerlink" title="Bindings"></a>Bindings</h4><p>Bindings作为一个桥梁，负责连接MQ和用户代码。比如绑定一个代码作为input往某一个Queue里面输入信息，绑定一个代码作为output从某个Queue里面接收信息。然后我们使用Binder来实现推送消息到MQ和消费消息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这里是官网原文：The application communicates with the outside world by establishing bindings between destinations exposed by the external brokers and input/output arguments in your code. Broker specific details necessary to establish bindings are handled by middleware-specific Binder implementations.</span><br></pre></td></tr></table></figure>

<p>下图为Bindings和Binder的关系</p>
<p><img src="/../images/spring-stream-03.png" alt="stream"></p>
<h4 id="source-和-sink"><a href="#source-和-sink" class="headerlink" title="source 和 sink"></a>source 和 sink</h4><p>source其实就是发送方的发送的Message. sink就是接收方接受的Message</p>
<h2 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注解的实现已经被彻底删除,只有之前低版本的还能使用</span><br></pre></td></tr></table></figure>

<h2 id="函数式编程实现示例"><a href="#函数式编程实现示例" class="headerlink" title="函数式编程实现示例"></a>函数式编程实现示例</h2><h3 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h3><p>将下面的代码加入<code>pom</code>文件，然后使用<code>maven</code>导入相关依赖即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 引入spring cloud stream依赖</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-stream&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">// 引入spring cloud stream的rabbit binder依赖</span><br><span class="line">// 如果是kafka，那么把这个换成kafka的binder</span><br><span class="line">// 在这个binder里面已经引入了 rabbit MQ依赖，所以不需要再单独引入rabbit MQ了</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8801</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span> <span class="comment"># stream的配置</span></span><br><span class="line">      <span class="attr">binders:</span> <span class="comment"># 在此处配置要绑定的rabbitmq的服务信息；</span></span><br><span class="line">        <span class="attr">defaultRabbit:</span> <span class="comment"># 表示定义的名称，用于于binding整合</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment"># 消息组件类型</span></span><br><span class="line">          <span class="attr">environment:</span> <span class="comment"># 设置rabbitmq的相关的环境配置</span></span><br><span class="line">            <span class="attr">spring:</span></span><br><span class="line">              <span class="attr">rabbitmq:</span></span><br><span class="line">                <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">                <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">                <span class="attr">password:</span> <span class="string">guest</span></span><br></pre></td></tr></table></figure>

<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><h5 id="配置文件修改"><a href="#配置文件修改" class="headerlink" title="配置文件修改"></a>配置文件修改</h5><p>对于函数式编程来说，<code>spring cloud stream</code>有一些<code>约定</code>或者说<code>规定</code>。比如我们注册了一个<code>logPub</code>的<code>Bean</code>，那么它对应的<code>bindings</code>配置的名称就是<code>logPub-in-0</code>或者<code>logPub-out-0</code>，前面是我们的方法名，中间表示生产者或消费者，<code>in</code>表示消费者，<code>out</code>表示生产者。这里的in or out是对于我们的代码来说的。后面的0就是一个序号。</p>
<p>写生产者之前我们需要加上对应的<code>bindings</code>配置。如果注册了多个<code>Bean</code>作为生产者或消费者，那么还需要配置哪些<code>Bean</code>是生产者和消费者。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">function:</span> <span class="comment"># 配置哪些Bean是Stream可以用的</span></span><br><span class="line">        <span class="attr">definition:</span> <span class="string">log;logPub;sendLog</span></span><br><span class="line">    <span class="attr">stream:</span> <span class="comment"># stream的配置</span></span><br><span class="line">        <span class="attr">bindings:</span> <span class="comment"># 服务的整合处理</span></span><br><span class="line">            <span class="attr">logPub-out-0:</span></span><br><span class="line">                <span class="attr">destination:</span> <span class="string">log</span> <span class="comment"># 表示要使用的Exchange名称定义,不存在会自动创建</span></span><br><span class="line">                <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为json，文本则设置“text/plain”</span></span><br></pre></td></tr></table></figure>

<h5 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h5><p>随便新建一个类，并标记为<code>@Component</code>，主要是要让spring知道这个类。类名可以随便起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">logProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后开始编写生产者的代码。加入主要的方法<code>log</code>，方法名可以随便起，只需要记得把这个方法注册为一个<code>Bean</code>就可以了。一定要在上面加<code>@Bean</code>注解。</p>
<p>方法的返回值只能是<code>Supplier</code>函数接口类型。不能是其他的。</p>
<p>方法里面可以写生产者的具体代码。会注册一个名为<code>logPub</code>的<code>Bean</code>作为生产者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">logListener</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Supplier&lt;logListener.Person&gt; logPub() &#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">            person.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者:&quot;</span>+person);</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于<code>Supplier</code>，这个是java提供的<code>函数式编程的接口</code>。从java8开始提供的，java8里面的stream功能也用到了函数式编程。</p>
<p>下面是<code>Supplier</code>的注释和定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Represents a supplier of results.</span></span><br><span class="line"><span class="comment">//There is no requirement that a new or distinct result be returned each time the supplier is invoked.</span></span><br><span class="line"><span class="comment">//This is a functional interface whose functional method is get().</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt;</span><br></pre></td></tr></table></figure>
<p>翻译过来大概就是：<code>一个结果的提供者</code>或者<code>一个结果的生产者</code>。正好对应我们的生产者。该接口只有一个方法<code>T get()</code>，没有参数并且仅返回一个结果。</p>
<h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><p>运行的话会发现控制台一直在打印。我们的队列里面也一直在新增。</p>
<p><img src="/../images/spring-stream-03.png" alt="stream"></p>
<h5 id="StreamBridge"><a href="#StreamBridge" class="headerlink" title="StreamBridge"></a>StreamBridge</h5><p>当前的运行方式是当写完生产者以后，<code>spring cloud stream</code>会1&#x2F;s次来调用我们的生产者，但是我们一般是自己来控制生产者的调用。就可以使用下面的方法。</p>
<p>我们可以通过<code>StreamBridge</code>来做到这一点。他有四个<code>send</code>方法。</p>
<ul>
<li>public boolean send(String bindingName, Object data)：第一个参数是bindingName，我们输入的是sendLog,就需要增加sendLog的配置，我们也可以用之前的<code>logPub-out-0</code>。第二个参数是发送的数据。</li>
<li>public boolean send(String bindingName, Object data, MimeType outputContentType)：比上面的多了一个数据类型。</li>
<li>public boolean send(String bindingName, @Nullable String binderName, Object data)：还可以指定Binder的name</li>
<li>public boolean send(String bindingName, @Nullable String binderName, Object data, MimeType outputContentType): 四个参数放在一起了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">logController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StreamBridge streamBridge;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendLog&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendLog</span><span class="params">()</span> &#123;</span><br><span class="line">        logListener.<span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">logListener</span>.Person();</span><br><span class="line">        person.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;生产者发送消息&quot;</span>+person);</span><br><span class="line">        streamBridge.send(<span class="string">&quot;sendLog&quot;</span>, person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>随便新建一个类，并标记为<code>@Component</code>，主要是要让spring知道这个类。类名可以随便起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">logListener</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后开始编写消费者的代码。加入主要的方法<code>log</code>，方法名可以随便起，只需要记得把这个方法注册为一个<code>Bean</code>就可以了。一定要在上面加<code>@Bean</code>注解。</p>
<p>方法的返回值可以是<code>Consumer</code>，也可以是<code>Function</code>。不能是其他的。</p>
<p>方法里面就可以写消费的具体代码了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">logListener</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Consumer&lt;logListener.Person&gt; log() &#123;</span><br><span class="line">        <span class="keyword">return</span> person -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Received: &quot;</span> + person);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于<code>Consumer</code>和<code>Function</code>，这两个是java提供的<code>函数式编程的接口</code>。从java8开始提供的，java8里面的stream功能也用到了函数式编程。</p>
<p>下面是<code>Consumer</code>接口的注释和接口的定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Represents an operation that accepts a single input argument and returns no result. Unlike most other functional interfaces, Consumer is expected to operate via side-effects.</span></span><br><span class="line"><span class="comment">//This is a functional interface whose functional method is accept(Object).</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt;</span><br></pre></td></tr></table></figure>
<p>翻译过来大概就是说Consumer接口<code>仅接收一个参数</code>并且没有返回值，我们的代码里面也可以看到，接收了一个person参数，没有return。</p>
<p>该接口只有一个方法<code>void accept(T t)</code>，T类型就是我们的Person类型。</p>
<p>下面是<code>Function</code>接口的注释和定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Represents a function that accepts one argument and produces a result.</span></span><br><span class="line"><span class="comment">//This is a functional interface whose functional method is apply(Object).</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt;</span><br></pre></td></tr></table></figure>
<p>翻译过来大概就是说<code>Function</code>接口<code>仅接收一个参数</code>并且<code>返回一个结果</code>。该接口只有一个方法<code>R apply(T t)</code>，接收一个T类型的参数，返回一个R类型的结果。</p>
<p><img src="/../images/spring-stream-05.png" alt="stream"></p>
<h5 id="手动ACK"><a href="#手动ACK" class="headerlink" title="手动ACK"></a>手动ACK</h5><p>通过禁止使用死信队列来执行手动的ACK,这个时候如果抛出异常，则会重试。如果开启了死信队列，那么抛出异常以后则会进入死信队列。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">log-in-0:</span></span><br><span class="line">    <span class="attr">consumer:</span></span><br><span class="line">        <span class="attr">auto-bind-dlq:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h3><p>上面可以看出来，创建的都是<code>匿名队列</code>，当程序启动的时候自动创建，当程序关闭的时候自动删除。</p>
<p>但是正常开发中，很少使用这种，都会指定一个持久化的队列，不管程序是否运行，队列都存在。</p>
<p>我们可以在<code>bindings</code>的配置里面增加<code>group</code>配置来显式指定哪个队列，我们指定<code>log123</code>队列。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">log-in-0:</span></span><br><span class="line">    <span class="attr">destination:</span> <span class="string">log</span></span><br><span class="line">    <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为json，文本则设置“text/plain”</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">log123</span></span><br><span class="line"><span class="attr">sendLog:</span></span><br><span class="line">    <span class="attr">destination:</span> <span class="string">log</span></span><br><span class="line">    <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为json，文本则设置“text/plain”</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">log123</span></span><br></pre></td></tr></table></figure>

<p>再次运行程序，可以看到该队列被创建。接下来停止程序，可以看到队列还存在那里。</p>
<h3 id="bindings重命名"><a href="#bindings重命名" class="headerlink" title="bindings重命名"></a>bindings重命名</h3><p>默认约定的名称为<code>log-in-0</code>这种形式</p>
<p>但是我们也可以将它重命名。通过配置文件可以将<code>log-in-0</code>重命名为<code>input</code>，不过这样的话，所有的log-in-0的bindings配置都需要修改成input，使用上也是。注意官方并不推荐这种做法，他们认为在大多数情况下，这有点矫枉过正。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">stream:</span></span><br><span class="line">            <span class="attr">function:</span></span><br><span class="line">                <span class="attr">bindings:</span></span><br><span class="line">                    <span class="attr">log-in-0:</span> <span class="string">input</span></span><br></pre></td></tr></table></figure>


<h3 id="显式绑定创建"><a href="#显式绑定创建" class="headerlink" title="显式绑定创建"></a>显式绑定创建</h3><p>默认约定的是<code>log-in-0</code>负责输入，<code>log-out-0</code>负责输出，我们也可以显式的创建这些。</p>
<p>通过配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">stream:</span></span><br><span class="line">            <span class="attr">input-bindings:</span> <span class="string">login;fooin</span></span><br><span class="line">            <span class="attr">output-bindings:</span> <span class="string">logout;fooout</span></span><br></pre></td></tr></table></figure>

<h3 id="轮询配置属性"><a href="#轮询配置属性" class="headerlink" title="轮询配置属性"></a>轮询配置属性</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">integration:</span></span><br><span class="line">        <span class="attr">poller:</span></span><br><span class="line">            <span class="comment"># 全局配置</span></span><br><span class="line">            <span class="attr">fixedDelay:</span> <span class="string">1000L</span> <span class="comment"># 默认轮询器的延迟 单位毫秒，默认1000L </span></span><br><span class="line">            <span class="attr">maxMessagesPerPoll:</span> <span class="string">1L</span> <span class="comment"># 默认轮询器的每个轮询事件的最大消息数。默认 1L</span></span><br><span class="line">            <span class="attr">cron:</span> <span class="string">none</span> <span class="comment"># Cron 触发器的 Cron 表达式值。默认 none</span></span><br><span class="line">            <span class="attr">initialDelay:</span> <span class="number">0</span> <span class="comment"># 周期性触发的初始延迟。 默认0</span></span><br><span class="line">            <span class="attr">timeUnit:</span> <span class="string">MILLISECONDS</span> <span class="comment"># 要应用于延迟值的 TimeUnit。默认 MILLISECONDS</span></span><br></pre></td></tr></table></figure>

<p>也可以单独为某个bindings来配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">stream:</span></span><br><span class="line">            <span class="attr">bindings:</span></span><br><span class="line">                <span class="attr">log-out-0:</span></span><br><span class="line">                    <span class="attr">producer:</span></span><br><span class="line">                        <span class="attr">poller:</span></span><br><span class="line">                            <span class="comment"># log-out-0的单独配置</span></span><br><span class="line">                            <span class="attr">fixedDelay:</span> <span class="string">1000L</span> <span class="comment"># 默认轮询器的延迟 单位毫秒，默认1000L </span></span><br><span class="line">                            <span class="attr">maxMessagesPerPoll:</span> <span class="string">1L</span> <span class="comment"># 默认轮询器的每个轮询事件的最大消息数。默认 1L</span></span><br><span class="line">                            <span class="attr">cron:</span> <span class="string">none</span> <span class="comment"># Cron 触发器的 Cron 表达式值。默认 none</span></span><br><span class="line">                            <span class="attr">initialDelay:</span> <span class="number">0</span> <span class="comment"># 周期性触发的初始延迟。 默认0</span></span><br><span class="line">                            <span class="attr">timeUnit:</span> <span class="string">MILLISECONDS</span> <span class="comment"># 要应用于延迟值的 TimeUnit。默认 MILLISECONDS</span></span><br></pre></td></tr></table></figure>

<h3 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h3><p>假设我们有两个处理<code>Bean</code>,<code>enrich</code>负责检查header，如果缺少foo,就添加为foo,bar。然后第二个echo则负责检查是否包含foo这个Header然后输出消息内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Function&lt;Message&lt;String&gt;, Message&lt;String&gt;&gt; <span class="title function_">enrich</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> message -&gt; &#123;</span><br><span class="line">        Assert.isTrue(!message.getHeaders().containsKey(<span class="string">&quot;foo&quot;</span>), <span class="string">&quot;Should NOT contain &#x27;foo&#x27; header&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> MessageBuilder.fromMessage(message).setHeader(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>).build();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Function&lt;Message&lt;String&gt;, Message&lt;String&gt;&gt; <span class="title function_">echo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> message -&gt; &#123;</span><br><span class="line">        Assert.isTrue(message.getHeaders().containsKey(<span class="string">&quot;foo&quot;</span>), <span class="string">&quot;Should contain &#x27;foo&#x27; header&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Incoming message &quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过配置将这两个bean组合起来,组合之后，这个bean名称就编程了<code>enrich|echo</code>,后续的配置都需要这种冗长的名称，所以这里官方推荐使用重命名的方式将它变成简单的名称。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">function:</span></span><br><span class="line">            <span class="attr">definition:</span> <span class="string">enrich|echo</span> <span class="comment"># 函数组合</span></span><br><span class="line">        <span class="attr">stream:</span></span><br><span class="line">            <span class="attr">function:</span> </span><br><span class="line">                <span class="attr">bindings:</span></span><br><span class="line">                    <span class="string">enrich|echo-in-0:</span> <span class="string">input</span> <span class="comment"># 重命名</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>南京大学操作系统</title>
    <url>/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html</url>
    <content><![CDATA[<h1 id="南京大学操作系统"><a href="#南京大学操作系统" class="headerlink" title="南京大学操作系统"></a>南京大学操作系统</h1><p>教材是<a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">OSTEP</a>,课程<a href="https://jyywiki.cn/OS/2023/">官网</a></p>
<h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><p>这里概述了操作系统做什么，怎么做。</p>
<p>总共有三个大模块，<code>虚拟化</code>，<code>并发</code>,<code>持久化</code>。</p>
<p>操作系统的几个目标：</p>
<ol>
<li>高性能：高效率的运行多个程序。</li>
<li>保护每个程序独立运行：不能让一个程序访问另外一个程序的内存数据</li>
<li>可靠性：操作系统必须一直运行，不能停止，因为一旦停止，所有依赖他的软件程序都会停止。</li>
</ol>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>NJU</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统CacheLab</title>
    <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCacheLab.html</url>
    <content><![CDATA[<h1 id="Cache-Lab"><a href="#Cache-Lab" class="headerlink" title="Cache Lab"></a>Cache Lab</h1><p>cache lab 缓存实验</p>
<h3 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h3><p>从CSAPP上面下载对应的lab代码</p>
<blockquote>
<p><a href="http://csapp.cs.cmu.edu/3e/labs.html">http://csapp.cs.cmu.edu/3e/labs.html</a></p>
</blockquote>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>需要安装 <code>valgrind</code>。可以参考文章<a href="https://blog.csdn.net/frank_good/article/details/104052768">Valgrind centos</a>。</p>
<p>安装好以后执行<code>valgrind --version</code>可以看到版本号。</p>
<h3 id="Cache-simulator"><a href="#Cache-simulator" class="headerlink" title="Cache simulator"></a>Cache simulator</h3><ul>
<li><code>cache simulator not a cache</code>。我们不是实现一个真正的缓存，只是实现一个模拟器。</li>
<li>不存储内容</li>
<li>不使用block offset</li>
<li>只计算命中数，不命中数和驱逐数(hit count, miss count,eviction count)</li>
<li>缓存模拟器需要在不同的s,b,E下运行。</li>
<li>使用LRU替换策略</li>
</ul>
<p>Hints</p>
<ul>
<li>使用二维数组 struct cache_line cache[S][E];</li>
<li>S &#x3D; 2^s</li>
<li>cache_line &#x2F;&#x2F;上面说了不需要block offset，所以可以忽略block的内容<ul>
<li>Valid bit</li>
<li>Tag</li>
<li>LRU counter</li>
</ul>
</li>
<li>通过getopt获取命令行输入<ul>
<li>返回-1表示没有输入了</li>
<li>通常在循环里面接收参数</li>
<li>需要包含#include &lt;unistd.h&gt;,#include &lt;getopt.h&gt;</li>
<li>通常使用switch来处理不同的输入</li>
<li>考虑如何处理无效输入</li>
<li>更多信息 man 3 getopt</li>
</ul>
</li>
<li>fscanf可以指定要读的流(scanf只能读标准输入流)，用来读取trace file<ul>
<li>参数<ul>
<li>一个流的指针</li>
<li>如何解析文件的信息的格式化字符串</li>
<li>其余部分是指向存储解析数据的变量的指针</li>
</ul>
</li>
<li>通常在循环里使用</li>
<li>当命中EOF或者没有匹配到格式化字符串的时候返回-1</li>
<li>更多信息 man fscanf</li>
</ul>
</li>
<li>Malloc&#x2F;free<ul>
<li>malloc分配数据到heap</li>
<li>记得 free 掉malloc的数据</li>
<li>不要 free 你没有分配的内存</li>
</ul>
</li>
</ul>
<p><img src="/../images/csapp/lab4/csapp-lab4-1.png" alt="lab4 getopt"></p>
<p><img src="/../images/csapp/lab4/csapp-lab4-2.png" alt="lab4 fscanf"></p>
<p>要求我们实现<code>csim.c</code>文件，给了一个示例<code>csim-ref</code>文件。</p>
<p>输入<code>./csim-ref -h</code>可以看到我们要实现的东西。</p>
<p><img src="/../images/csapp/lab4/csapp-lab4-3.png" alt="lab4 csim"></p>
<p>首先需要接受参数，参数有</p>
<ul>
<li>-h 输出帮助信息</li>
<li>-v 可选详细标志，根据示例程序来，就是输出 <code>L 10,1 miss</code>这些信息</li>
<li>-s [num] set index bit 数</li>
<li>-E [num] 每个set的行数</li>
<li>-b [num] block offset bit数</li>
<li>-t [file] Trace file文件路径</li>
</ul>
<p>根据上面的提示可以知道，通过<code>getopt</code>函数来接收参数，并通过switch来处理。读取文件则通过<code>fscanf</code>函数，来读取-t传的文件。</p>
<p>下面是<code>./traces/yi.trace</code>文件的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L 10,1</span><br><span class="line">M 20,1</span><br><span class="line">L 22,1</span><br><span class="line">S 18,1</span><br><span class="line">L 110,1</span><br><span class="line">L 210,1</span><br><span class="line">M 12,1</span><br></pre></td></tr></table></figure>

<ul>
<li>L 代表数据载入 </li>
<li>S 代表数据存储</li>
<li>M 代表数据修改，需要一次载入 + 一次存储</li>
<li>后面的10，20，22这些代表地址</li>
<li>最后的1代表操作内存访问的字节数</li>
</ul>
<p>完整代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cachelab.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="type">int</span> valid;</span><br><span class="line">        <span class="type">int</span> tag;</span><br><span class="line">        <span class="type">int</span> time_stamp;</span><br><span class="line">&#125; cache_line;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> timestamp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始匹配到合适的set 找到命中的cache，如果命中返回1,如果没有命中返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find_hit_cache</span><span class="params">(cache_line *cache_line,<span class="type">int</span> E,<span class="type">int</span> tag, <span class="type">int</span>*hits)</span> &#123;</span><br><span class="line">    <span class="type">int</span> isHit = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环set中的cache_line 找到是否有匹配tag &amp;&amp; valid</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache_line[i].valid == <span class="number">1</span> &amp;&amp; cache_line[i].tag == tag ) &#123;</span><br><span class="line">            <span class="comment">//hit</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hit \n&quot;</span>);</span><br><span class="line">            *hits = *hits + <span class="number">1</span>;</span><br><span class="line">            isHit = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//刷新时间</span></span><br><span class="line">            cache_line[i].time_stamp = timestamp;</span><br><span class="line">            <span class="keyword">return</span> isHit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isHit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到一个空的cache line放进去，找到了就返回1，没有找到就返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find_empty_cache</span><span class="params">(cache_line *cache_line,<span class="type">int</span> E,<span class="type">int</span> tag)</span> &#123;</span><br><span class="line">    <span class="type">int</span> have_empty_cache = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt; E; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache_line[i].valid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 空的</span></span><br><span class="line">            <span class="comment">// 把当前内存放入cache</span></span><br><span class="line">            cache_line[i].valid = <span class="number">1</span>;</span><br><span class="line">            cache_line[i].tag = tag;</span><br><span class="line">            cache_line[i].time_stamp = timestamp;</span><br><span class="line">            <span class="comment">// 找到了就不需要替换了</span></span><br><span class="line">            have_empty_cache = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> have_empty_cache;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> have_empty_cache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取要替换的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_eviction_index</span><span class="params">(cache_line *cache_line, <span class="type">int</span> E)</span> &#123;</span><br><span class="line">    <span class="type">int</span> max_time_stamp = timestamp;</span><br><span class="line">    <span class="type">int</span> eviction_index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt; E; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache_line[i].time_stamp &lt; max_time_stamp) &#123;</span><br><span class="line">            <span class="comment">//找到time_stamp最小的那个</span></span><br><span class="line">            max_time_stamp = cache_line[i].time_stamp;</span><br><span class="line">            eviction_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eviction_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LRU替换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LRU</span><span class="params">(cache_line *cache_line, <span class="type">int</span> E,<span class="type">int</span> tag)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取要替换的索引</span></span><br><span class="line">    <span class="type">int</span> eviction_index = get_eviction_index(cache_line, E);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 替换</span></span><br><span class="line">    cache_line[eviction_index].valid = <span class="number">1</span>;</span><br><span class="line">    cache_line[eviction_index].tag = tag;</span><br><span class="line">    cache_line[eviction_index].time_stamp = timestamp; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// L和S操作，M就调用两次这个</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">load_and_store</span><span class="params">(<span class="type">unsigned</span> address,<span class="type">int</span> b,<span class="type">int</span> s,<span class="type">int</span> u_max,<span class="type">int</span> E,cache_line **cache, <span class="type">int</span> *hits,<span class="type">int</span> *misses,<span class="type">int</span> *evications)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取set index block offset tag</span></span><br><span class="line">    <span class="type">int</span> set_index,tag;</span><br><span class="line">    set_index = (address &gt;&gt; b) &amp; u_max;</span><br><span class="line">    tag = (address &gt;&gt; b) &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始匹配到合适的set 找到命中的cache，如果命中返回1,如果没有命中返回0</span></span><br><span class="line">    <span class="type">int</span> isHit = find_hit_cache(cache[set_index], E, tag, hits);</span><br><span class="line">    <span class="keyword">if</span> (isHit == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// miss</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;miss \n&quot;</span>);</span><br><span class="line">        *misses = *misses + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 找到一个空的cache line放进去，找到了就返回1，没有找到就返回0</span></span><br><span class="line">        <span class="type">int</span> have_empty_cache = find_empty_cache(cache[set_index], E, tag);</span><br><span class="line">        <span class="comment">// 如果没有找到空的cache,就需要LRU替换</span></span><br><span class="line">        <span class="keyword">if</span> (have_empty_cache == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;evictions \n&quot;</span>);</span><br><span class="line">            *evications = *evications + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//LRU替换</span></span><br><span class="line">            LRU(cache[set_index], E, tag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新全局时间戳</span></span><br><span class="line">    timestamp++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 接受参数 getopt</span></span><br><span class="line">    <span class="type">int</span> opt,v,s,E,b,S,B;</span><br><span class="line">    <span class="comment">// 文件</span></span><br><span class="line">    FILE        *       pFile;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">-1</span> != (opt = getopt(argc, argv, <span class="string">&quot;h?v?s:E:b:t:&quot;</span>)))&#123;</span><br><span class="line">        <span class="comment">// opt is h,v,s,E,b,t的ASCII码值</span></span><br><span class="line">        <span class="comment">// 通过switch对不同的参数进行不同的处理</span></span><br><span class="line">        <span class="keyword">switch</span>(opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;./csim: Missing required command line argument \n Usage: ./csim-ref [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt; \n Options: \n -h         Print this help message. \n -v         Optional verbose flag. \n -s &lt;num&gt;   Number of set index bits. \n -E &lt;num&gt;   Number of lines per set. \n -b &lt;num&gt;   Number of block offset bits. \n -t &lt;file&gt;  Trace file. \n\n Examples: \n ./csim -s 4 -E 1 -b 4 -t traces/yi.trace \n ./csim -v -s 8 -E 2 -b 4 -t traces/yi.trace \n&quot;</span>);</span><br><span class="line">                <span class="comment">// h参数输出帮助内容</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">                <span class="comment">// v参数输出详细信息</span></span><br><span class="line">                v = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;v:%d \n&quot;</span>,v);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                <span class="comment">// S is set 2^s 的数量</span></span><br><span class="line">                <span class="comment">// s is Number of set index bits</span></span><br><span class="line">                s = atoi(optarg);</span><br><span class="line">                S = <span class="number">1</span> &lt;&lt; s;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;s:%d, S:%d \n&quot;</span>,s,S);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">                <span class="comment">// E is cache line 的数量</span></span><br><span class="line">                <span class="comment">// Number of lines per set</span></span><br><span class="line">                E = atoi(optarg);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;E:%d \n&quot;</span>,E);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                <span class="comment">// B is block data 的字节</span></span><br><span class="line">                <span class="comment">// b is Number of block offset bits</span></span><br><span class="line">                b = atoi(optarg);</span><br><span class="line">                B = <span class="number">1</span> &lt;&lt; b;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;b:%d, B:%d \n&quot;</span>,b,B);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">                <span class="comment">// t is Trace file</span></span><br><span class="line">                <span class="comment">// 读取文件</span></span><br><span class="line">                <span class="comment">//t = atoi(optarg);</span></span><br><span class="line">                pFile   =       fopen(optarg,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;t:%s, file:%p \n&quot;</span>,optarg,pFile);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;非法参数 \n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="number">0</span> || E == <span class="number">0</span> || b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cache存储</span></span><br><span class="line">    cache_line **cache = (cache_line **)<span class="built_in">malloc</span>(S * <span class="keyword">sizeof</span>(cache_line *));</span><br><span class="line">    <span class="keyword">if</span> (cache == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败 \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++) &#123;</span><br><span class="line">        cache[i] = (cache_line *)<span class="built_in">malloc</span>(E * <span class="keyword">sizeof</span>(cache_line));</span><br><span class="line">        <span class="keyword">if</span>(cache[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败，开始回滚 \n&quot;</span>);</span><br><span class="line">                <span class="comment">// 在这里需要释放已分配的内存，然后退出</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="built_in">free</span>(cache[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(cache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> u_max = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        u_max = (u_max &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">    <span class="type">char</span>        identifier;</span><br><span class="line">    <span class="type">unsigned</span>    address;</span><br><span class="line">    <span class="type">int</span>         size;</span><br><span class="line">    <span class="type">int</span> hits,misses,evictions;</span><br><span class="line"><span class="comment">//      Reading lines   like    &quot;       M       20,1&quot;   or      &quot;L      19,3&quot;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(pFile,<span class="string">&quot; %c %x,%d&quot;</span>,&amp;identifier,&amp;address,&amp;size)&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//      Do      stuff</span></span><br><span class="line">        <span class="comment">// 开始计算 hits,misses,evictions, hits:0 misses:0 evictions:0</span></span><br><span class="line">        <span class="comment">//printf(&quot;identifier %c, addr:%x, size:%d \n&quot;,identifier,address,size);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据identifier来判断动作L load S store M = 一次L 一次S</span></span><br><span class="line">        <span class="keyword">if</span> (identifier == <span class="string">&#x27;L&#x27;</span> || identifier == <span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;identifier %c, addr:%x, size:%d \n&quot;</span>,identifier,address,size);</span><br><span class="line">            load_and_store(address,b,s,u_max,E,cache,&amp;hits,&amp;misses,&amp;evictions);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (identifier == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 一次L 一次S</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;identifier %c, addr:%x, size:%d \n&quot;</span>,identifier,address,size);</span><br><span class="line">            load_and_store(address,b,s,u_max,E,cache,&amp;hits,&amp;misses,&amp;evictions);</span><br><span class="line">            load_and_store(address,b,s,u_max,E,cache,&amp;hits,&amp;misses,&amp;evictions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fclose(pFile);  <span class="comment">//remember      to      close   file    when    done</span></span><br><span class="line">    printSummary(hits, misses, evictions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放数组内存</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; S; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(cache[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cache);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Efficient-Matrix-Transpose"><a href="#Efficient-Matrix-Transpose" class="headerlink" title="Efficient    Matrix    Transpose"></a>Efficient    Matrix    Transpose</h3>]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>lab</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统CacheLab</title>
    <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FShellLab.html</url>
    <content><![CDATA[<h1 id="Shell-Lab"><a href="#Shell-Lab" class="headerlink" title="Shell Lab"></a>Shell Lab</h1><p>shell lab shell实验</p>
<h3 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h3><p>从CSAPP上面下载对应的lab代码</p>
<blockquote>
<p><a href="http://csapp.cs.cmu.edu/3e/labs.html">http://csapp.cs.cmu.edu/3e/labs.html</a></p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>lab</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统DataLab</title>
    <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FDataLab.html</url>
    <content><![CDATA[<h1 id="Data-Lab"><a href="#Data-Lab" class="headerlink" title="Data Lab"></a>Data Lab</h1><p>data lab 数据实验</p>
<p>这个数据实验请在linux机器上面运行，实测mac m1本跑不起来。windows没试过。</p>
<p>centos上需要安装好gcc运行环境。</p>
<p>如果跑不起来记得安装下面这个东西：</p>
<blockquote>
<p>yum -y install glibc-devel.i686</p>
</blockquote>
<p>运行<code>make btest</code>的时候可能会有<code>warning</code>提示，不用管，这个时候其实已经创建完<code>btest</code>了，可以直接运行<code>btest</code>。</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-1.png" alt="lab准备"></p>
<h3 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h3><p>第一个函数是实现<code>位</code>的<code>异或</code>。</p>
<p>看一下异或的要求，相同为0，不同为1，这个函数里面只能使用<code>按位与&amp;</code>和<code>按位取反~</code>。</p>
<p>最大操作符号数：14</p>
<table>
<thead>
<tr>
<th align="left">x</th>
<th align="left">y</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
</tbody></table>
<p>假设我们有4 &#x3D; 100, 5 &#x3D; 101，异或的结果为1 &#x3D; 001.</p>
<p>先看按位与的结果。100 &amp; 101 &#x3D; 100 这个时候能得到 0 0 0这个正确的组合</p>
<table>
<thead>
<tr>
<th align="left">x</th>
<th align="left">y</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>100再取反就是011，就可以得到 1 1 0 这个正确的组合。</p>
<table>
<thead>
<tr>
<th align="left">x</th>
<th align="left">y</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
</tbody></table>
<p>先看按位或的结果。100 | 101 &#x3D; 101 这个时候能得到 0 1 1 和 1 0 1这个正确的组合</p>
<table>
<thead>
<tr>
<th align="left">x</th>
<th align="left">y</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>可以看到 ~(x &amp; y) &amp; (x | y) 就可以得出结果了，但是我们不能用 | ，所以我们需要通过 &amp;，～来实现 |。</p>
<p>可以通过 <del>(</del>x &amp; ~y) 来实现 ｜ ,4 &#x3D; 100 取反 &#x3D; 011， 5 &#x3D; 101 取反 &#x3D; 010, 011 &amp; 010 &#x3D; 010,取反 &#x3D; 101. 100 | 101 &#x3D; 101。</p>
<p>所以 异或就是 <del>(x &amp; y) &amp; (</del>(~x &amp; ~y))</p>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~(x &amp; y) &amp; ~(~x &amp; ~y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>btest 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-2.png" alt="lab1 btest"></p>
<p>dlc 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-3.png" alt="lab1 dlc"></p>
<p>bdd check 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-4.png" alt="lab1 dlc"></p>
<h3 id="Tmin"><a href="#Tmin" class="headerlink" title="Tmin"></a>Tmin</h3><p>Tmin是<code>1000 0000</code>，也就是最小的有符号数，那当然是符号位是1，剩下全0了。</p>
<p>可以使用操作符：! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
<p>最大操作符号数量：4</p>
<p>分数：1</p>
<p>返回 1000 0000就可以了。正常的int Tmin就是1后面31个0，也就是1左移动31位</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>btest 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-5.png" alt="lab1 btest"></p>
<p>dlc 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-6.png" alt="lab1 dlc"></p>
<p>bdd check 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-7.png" alt="lab1 dlc"></p>
<h3 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h3><p>Tmax是<code>0111</code></p>
<p>可以使用操作符: ! ~ &amp; ^ | +<br>最大操作符号数量: 10</p>
<p>4位的话，Tmax就是7，看一下7的一些操作结果,可以发现，7+1 &#x3D; ~7</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 = 0111</span><br><span class="line">7 + 1 = 1000 = -8</span><br><span class="line">~7 = 1000 = -8</span><br><span class="line">1000 ^ 0000 = 1000 !1000 = 0000</span><br></pre></td></tr></table></figure>

<p>但是 -1 + 1 也等于 ~-1,所以我们需要排除-1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1 = 1111</span><br><span class="line">-1 + 1 = 0000</span><br><span class="line">~-1 = 0000</span><br><span class="line">0000 ^ 0000 = 0000 !0000 = 0001</span><br></pre></td></tr></table></figure>

<p>可以看到4的话，4 + 1 不等于~4</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 = 100</span><br><span class="line">4 + 1 = 0101</span><br><span class="line">~4 = 1011</span><br><span class="line">101 ^ 000 = 101 !101 = 000</span><br></pre></td></tr></table></figure>

<p>怎么排除-1呢，观察发现-1+1 &#x3D; 0，而0^0 &#x3D; 0,但是tmax ^ 0 不等于0</p>
<p>所以tmax需要满足两个条件</p>
<ol>
<li>x + 1 &#x3D;&#x3D; ~x</li>
<li>x + 1 !&#x3D; 0</li>
</ol>
<p>可以用<code>^</code>操作来实现<code>==</code>。如果相等，那么x+1 ^ ~x 就会等于0，!0 &#x3D;&#x3D; 1，所以第一个条件就是</p>
<blockquote>
<p>!((x+1) ^ ~x)</p>
</blockquote>
<p>第二个条件同样通过<code>^</code>来实现。</p>
<blockquote>
<p>!!((x+1) ^ 0)</p>
</blockquote>
<p>只要这两个都满足就是Tmax了，都满足可以通过<code>&amp;</code>来实现，如果都是1，那么<code>&amp;</code>以后就是1，有一个不满足<code>&amp;</code>以后就是0.</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> xPlus = x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> !(xPlus ^ ~x) &amp; !!(xPlus ^ <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>btest 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-8.png" alt="lab1 btest"></p>
<p>dlc 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-9.png" alt="lab1 dlc"></p>
<p>bdd check 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-10.png" alt="lab1 dlc"></p>
<h3 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h3><p>如果所有的奇数位都是1就返回1，否则返回0</p>
<p>可以使用的操作符: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>最大数量: 12<br>分数: 2</p>
<p>比如 <code>1010 1010</code>就是奇数位上全1.</p>
<p>所以只要和 <code>1010 1010</code> 做 <code>&amp;</code> 操作，只要做完以后还是 <code>1010 1010</code>的话，那么就返回1，不然就是0.</p>
<p>因为假设 x 奇数位上有一个是0，比如 <code>1010 1000</code>，那么结果就会是 <code>1010 1000</code>，所以只有奇数位上全1，<code>&amp;</code>以后一定是<code>1010 1010</code>。</p>
<p>所以需要满足条件</p>
<ol>
<li>x &amp; 1010 1010 &#x3D;&#x3D; 1010 1010</li>
</ol>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> odd = <span class="number">0xAA</span>; <span class="comment">//1010 1010</span></span><br><span class="line">  <span class="type">int</span> halfOdd = (odd &lt;&lt; <span class="number">8</span>) + odd; <span class="comment">// 1010 1010 0000 0000 + 1010 1010 = 1010 1010 1010 1010</span></span><br><span class="line">  <span class="type">int</span> allOdd = (halfOdd &lt;&lt; <span class="number">16</span>) + halfOdd;</span><br><span class="line">  <span class="keyword">return</span> !((allOdd &amp; x)  ^ allOdd );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>btest 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-11.png" alt="lab1 btest"></p>
<p>dlc 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-12.png" alt="lab1 dlc"></p>
<p>bdd check 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-13.png" alt="lab1 dlc"></p>
<h3 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h3><p>返回-x<br>可以使用的操作符: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>最大数量: 5<br>分数: 2</p>
<p>这里要分成三部</p>
<ul>
<li>正数，比如 7 &#x3D; 0111</li>
<li>0， 0 &#x3D; 0000</li>
<li>负数，-1 &#x3D; 1111</li>
</ul>
<p>如果使用按位取反</p>
<ul>
<li>7 &#x3D; 0111，～7 &#x3D; 1000 &#x3D; -8</li>
<li>0 &#x3D; 0000， ～0 &#x3D; 1111 &#x3D; -1</li>
<li>-1 &#x3D; 1111， ～-1 &#x3D; 0000 &#x3D; 0</li>
<li>-8 &#x3D; 1000， ～-8 &#x3D; 0111 &#x3D; 7</li>
</ul>
<p>取反以后的值 + 1就是对应的负数了，-8 + 1 &#x3D; -7, -1 + 1 &#x3D; 0, 0 + 1 &#x3D; 1, 7 + 1 &#x3D; 8</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>btest 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-14.png" alt="lab1 btest"></p>
<p>dlc 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-15.png" alt="lab1 dlc"></p>
<p>bdd check 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-16.png" alt="lab1 dlc"></p>
<h3 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h3><p>如果 0x30 &lt;&#x3D; x &lt;&#x3D; 0x39，返回1，否则0<br>可以使用的操作符: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>最大数量: 15<br>分数: 3</p>
<p>0x30 &#x3D; 0011 0000, 0x39 &#x3D; 0011 1001。<br>根据题目，也就是判断 0011 0000 &lt;&#x3D; x &lt;&#x3D; 0011 1001</p>
<p>首先高位要等于 0011，如果不等于0011，那么肯定不在这个范围。可以通过 &gt;&gt; 4位然后 ^ 0011，如果结果为0，那么高位就是满足的。</p>
<p>低位在0000 到 1001之间,当首位是0的时候，后面是啥都行，首位是1，那么后面两位必须是00，也就是前三位是100.</p>
<p>判断首位是0可以通过 &amp; 0x8 然后 ^ 0来判断，如果结果是0首位就是0，不然首位是1</p>
<p>判断低4位的前3位，先 &amp; 0xE来获取前3位，然后 ^ 0x8来判断是不是 100</p>
<p>所以需要满足条件1并且满足条件2或者3</p>
<ol>
<li>x &gt;&gt; 4 ^ 0011 &#x3D;&#x3D; 0</li>
<li>(x &amp; 0x8) ^ 0 &#x3D;&#x3D; 0 </li>
<li>(x &amp; 0xE) ^ 0x8 &#x3D;&#x3D; 0</li>
</ol>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> xh = x &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> a3 = <span class="number">0x3</span>;</span><br><span class="line">    <span class="type">int</span> xlh = x &amp; <span class="number">0x8</span>;</span><br><span class="line">    <span class="type">int</span> xorxlh = xlh^<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> xorxl = (x &amp; <span class="number">0xE</span>) ^ <span class="number">0x8</span>;</span><br><span class="line">    <span class="keyword">return</span> (!(xh ^ a3 ^ <span class="number">0</span>)) &amp; (!xorxlh | !xorxl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>btest 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-17.png" alt="lab1 btest"></p>
<p>dlc 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-18.png" alt="lab1 dlc"></p>
<p>bdd check 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-19.png" alt="lab1 dlc"></p>
<h3 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h3><p>实现三元运算 x ? y : z<br>可以使用的操作符: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>最大数量: 16<br>分数: 3</p>
<p>x 为真代表 x &amp; 1 &#x3D;&#x3D; 1,x 为假代表 x &amp; 1 &#x3D;&#x3D; 0。<br>需要满足条件</p>
<ol>
<li>x &amp; 1 &#x3D;&#x3D; 1时，返回y,所以z需要置为0并且和y一起返回。<code>!(x &amp; 1) &amp; z</code>就可以把z置为0，所以应该返回 <code>(!(x &amp; 1) &amp; z) | y</code></li>
<li>x &amp; 1 &#x3D;&#x3D; 0时，返回z,所以y需要置为0并且和z一起返回。<code>x &amp; 1 &amp; y</code>就可以把y置为0。所以应该返回 <code>(x &amp; 1 &amp; y) | z</code></li>
</ol>
<p>把上面的2个条件合并起来。</p>
<blockquote>
<p>(!(x &amp; 1) &amp; z) ｜ (x &amp; 1 &amp; y)</p>
</blockquote>
<p>但是发现这样并不行，所以重新思考，发现 x &amp; 1 &#x3D;&#x3D; 1时候是没错，但是我们应该让 x &#x3D; 0xFF才行。</p>
<p>所以改进一下子</p>
<ul>
<li>先对x取反。!x &#x3D; 1,说明x &#x3D; 0,这个时候应该返回 z,所以需要<code>(0 &amp; y) | z</code></li>
<li>!x &#x3D; 0,说明x &#x3D; 1，应该返回y,所以需要 <code>(0 &amp; z) | y</code></li>
</ul>
<p>这里把 !x 在按位取反 + 1就可以得到当 x &#x3D; 0时候，condition &#x3D; 1111 1111。这个时候返回z。</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">  <span class="type">int</span> xn = !x;</span><br><span class="line">  <span class="type">int</span> condition = ~xn + <span class="number">1</span>; <span class="comment">//x = 0,condition = 1111 1111, x = 1, condition = 0000 0000</span></span><br><span class="line">  <span class="keyword">return</span> (condition &amp; z) | (~condition &amp; y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>btest 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-20.png" alt="lab1 btest"></p>
<p>dlc 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-21.png" alt="lab1 dlc"></p>
<p>bdd check 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-22.png" alt="lab1 dlc"></p>
<h3 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h3><p>如果x &lt;&#x3D; y，返回1，否则0<br>可以使用的操作符: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>最大数量: 24<br>分数: 3</p>
<p>等于可以通过<code>异或</code>来做。</p>
<blockquote>
<p>!(x ^ y) </p>
</blockquote>
<p>在看小于，如果一个正数和一个负数，那么负数一定小于正数，负数的符号位1，正数的符号位0.</p>
<p>取出符号位，通过右移动31位来获取符号位，但是负数会补1，所以在和1与一下，就可以得到符号位了。</p>
<blockquote>
<p>(x &gt;&gt; 31) &amp; 1</p>
</blockquote>
<p>可以<code>|</code>一下，如果是 <code>1 | 0</code>就返回1了。</p>
<blockquote>
<p>((x &gt;&gt; 31) &amp; 1 ) | ((y &gt;&gt; 31) &amp; 1)</p>
</blockquote>
<p>如果两个都是正数或者负数，那么符号位相同。</p>
<ul>
<li>对较小的数进行按位取反，在加上大的数的话，会产生溢出。也就是 x &lt; y, ~x + y 会溢出，所以首位是0</li>
<li>如果两个数相等或者较大的数取反了在加上小的数，不会溢出。x &gt;&#x3D; y, ~x + y 不会溢出，所以首位是1</li>
<li>所以对于等于的情况还需要处理，如果两个数相等，那么 ~x + y &#x3D; -1，也就是所有位都是1，让这个值+1就是0了，就和小于保持一致了</li>
</ul>
<p>如果两个数的符号位不同，那么x是1,y是0的话，就返回1，否则0</p>
<ul>
<li>对x的符号位取反，如果x符号位是1，那么取反0,y的符号位是0，那么就返回1</li>
<li>如果x符号位是0，取反1，y是1，那么返回0</li>
</ul>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="comment">// 取首位</span></span><br><span class="line">  <span class="type">int</span> signalX = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> signalY = (y &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// !(signalX ^ signalY)是符号位相同的情况</span></span><br><span class="line">  <span class="comment">// !(((~x + y + 1) &gt;&gt; 31) &amp; 1) 是符号位相同时候小于等于的情况</span></span><br><span class="line">  <span class="type">int</span> lessEq = !(signalX ^ signalY) &amp; !(((~x + y + <span class="number">1</span>) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 如果符号位不同的情况</span></span><br><span class="line">  <span class="type">int</span> neq = (!signalY) &amp; signalX;</span><br><span class="line">  <span class="comment">// 两个情况做|，满足任一个情况则返回1</span></span><br><span class="line">  <span class="keyword">return</span> (lessEq | neq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>btest 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-23.png" alt="lab1 btest"></p>
<p>dlc 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-24.png" alt="lab1 dlc"></p>
<p>bdd check 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-25.png" alt="lab1 dlc"></p>
<h3 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h3><p>对x取反，实现!操作<br>可以使用的操作符: ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>最大数量: 12<br>分数: 4</p>
<p>两种情况</p>
<ul>
<li>0，(~0 + 1) | 0 的首位是0</li>
<li>其他数， (~x + 1) | x的首位是1</li>
</ul>
<p>0要返回1，1要返回0，可以异或1</p>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ((((~x + <span class="number">1</span>) | x) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>) ^ <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>btest 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-26.png" alt="lab1 btest"></p>
<p>dlc 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-27.png" alt="lab1 dlc"></p>
<p>bdd check 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-28.png" alt="lab1 dlc"></p>
<h3 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h3><p>输出最少需要的位数来表示int x<br>可以使用的操作符: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>最大数量: 90<br>分数: 4</p>
<p>例子：</p>
<ul>
<li>howManyBits(12) &#x3D; 5 &#x3D; 10010</li>
<li>howManyBits(298) &#x3D; 10 &#x3D; 10 1001 1000</li>
<li>howManyBits(-5) &#x3D; 4 &#x3D; 1011</li>
<li>howManyBits(0)  &#x3D; 1 &#x3D; 0</li>
<li>howManyBits(-1) &#x3D; 1 &#x3D; 1</li>
<li>howManyBits(0x80000000) &#x3D; 32 &#x3D; 1000….</li>
</ul>
<p>三种情况</p>
<ul>
<li>正数的首位都是1，遇到1的话，找到1是哪位就可以了</li>
<li>负数的首位是符号位都是1，所以需要找到第二个1，如果把负数的符号位变成0，就可以按照正数处理了</li>
<li>0，直接返回0，也可以使用正数的方法找1，找不到自然返回0了</li>
</ul>
<p>有没有1，可以通过!!来判断，如果是!!0，就是0，如果是其他数!!x就是1了。</p>
<p>这道题的代码是从网上抄的。</p>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> signal = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> b1,b2,b3,b4,b5,h16,h8,h4,h2,h1;</span><br><span class="line">  x =  (signal &amp; ~x) | (~signal &amp; x);</span><br><span class="line">  <span class="comment">// 查看高16位是否有1</span></span><br><span class="line">  h16 = !!(x &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  <span class="comment">// 如果高16位有1，那么肯定需要16位来表示，记住这16位</span></span><br><span class="line">  <span class="comment">// 因为高 16bit 有1，那么h16就是1，所以1 &lt;&lt; 4 就是16，代表最低需要16位表示</span></span><br><span class="line">  <span class="comment">// 如果高 16bit 没有1，那么h16就是0，所以 0&lt;&lt; 4就是0，代表最低需要0位表示</span></span><br><span class="line">  b1 = h16 &lt;&lt; <span class="number">4</span>;</span><br><span class="line">  <span class="comment">// 如果高位有1，那么x &gt;&gt; 16位，这样的原来的高位变成了低位</span></span><br><span class="line">  <span class="comment">// 如果高位没有1，那么x &gt;&gt; 0位，这样低16位还是低16位</span></span><br><span class="line">  x = x &gt;&gt; b1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里分为两种情况，如果高16位有1，需要继续看高8位是否有1，如果高16位没有1，需要看低16位的高8位是否有1</span></span><br><span class="line">  <span class="comment">// 因为上面对于高16位有1的时候，将高16位变成了低16位，所以都只需要看低16位的高8位就可以了</span></span><br><span class="line">   h8 = !!(x &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  <span class="comment">// 和上面同理，如果现在16位的高8位有1，那么b2代表 1 &lt;&lt; 3就是8，如果没有，那么就是0</span></span><br><span class="line">   b2 = h8 &lt;&lt; <span class="number">3</span></span><br><span class="line">  <span class="comment">// 同样处理，如果有，那么高8位变低8位</span></span><br><span class="line">  x = x &gt;&gt; b2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//处理8位的高4位</span></span><br><span class="line">   h4 = !!(x &gt;&gt; <span class="number">4</span>);</span><br><span class="line">   b3 = h4 &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  x = x &gt;&gt; b3;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理4位的高2位</span></span><br><span class="line">   h2 = !!(x &gt;&gt; <span class="number">2</span>);</span><br><span class="line">   b4 = h2 &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  x = x &gt;&gt; b4;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理最后2位是否有1</span></span><br><span class="line">   h1 = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">   b5 = h1;</span><br><span class="line">  x = x &gt;&gt; b5;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有结果相加 最后+1，因为高16位有1，那么需要17位表示</span></span><br><span class="line">  <span class="keyword">return</span> b1 + b2 + b3 + b4 + b5 + x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>btest 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-29.png" alt="lab1 btest"></p>
<p>dlc 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-30.png" alt="lab1 dlc"></p>
<p>bdd check 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-31.png" alt="lab1 dlc"></p>
<h3 id="float-twice"><a href="#float-twice" class="headerlink" title="float_twice"></a>float_twice</h3><p>传入一个无符号数uf,返回uf * 2的小数的bit表示<br>可以使用的操作符: 任何整数的操作，包||,&amp;&amp;,if,while<br>最大数量: 30<br>分数: 4</p>
<p>在复习一下，IEEE浮点标准用<code>V = (-1)的s次方 * M * 2的E次方</code>来表示。<br>单精度尾数是23位，exp是8位，符号位1位</p>
<p>取符号位<br>int s &#x3D; (uf &gt;&gt; 31) &amp; 1;</p>
<p>取exp<br>int exp &#x3D; (uf &lt;&lt; 1) &gt;&gt; 24</p>
<p>当阶码exp不等于全0或不等于全1的时候，就表示规格化的浮点数。<br>E的计算方式</p>
<ul>
<li>E &#x3D; 阶码 - Bias</li>
<li>Bias &#x3D; 单精度是127</li>
<li>单精度下，假设阶码为 0000 0001, 那么E &#x3D; 1 - 127 &#x3D; -126<br>E &#x3D; exp - Bias</li>
</ul>
<p>M的计算方式</p>
<ul>
<li>M &#x3D; 1.XXXXXX</li>
<li>尾数就是 XXXXXX</li>
<li>假设 尾数为 0000 0000 0000 0000 0000 001，那么M &#x3D; 1.00000000000000000000001</li>
</ul>
<p>-1^s * 1.尾数 * 2^E</p>
<p>当阶码等于全0的时候，就表示非规格化的浮点数。<br>exp ^ 0是0就代表全0，非规格化<br>E的计算方式，他跟阶码没关系了，因为阶码永远是0</p>
<ul>
<li>E &#x3D; 1 - Bias</li>
<li>Bias &#x3D; 单精度是127</li>
<li>阶码永远为 0000 0000, E &#x3D; 1 - 127 &#x3D; -126<br>E &#x3D; 1 - 127</li>
</ul>
<p>M的计算方式</p>
<ul>
<li>M &#x3D; 0.XXXXXX</li>
<li>尾数就是 XXXXXX</li>
<li>假设 尾数为 0000 0000 0000 0000 0000 001，那么M &#x3D; 0.00000000000000000000001</li>
</ul>
<p>-1^s * 0.尾数 * 2^E</p>
<p>当阶码等于全1的时候，就表示特殊的浮点数。<br>~exp ^ 0是0就代表全1，特殊浮点数 当尾数不为全0的时候，就是NaN，返回参数。</p>
<p>小数乘法</p>
<ul>
<li>符号位s1 ^ s2</li>
<li>M &#x3D; M1 * M2</li>
<li>E &#x3D; E1 + E2</li>
</ul>
<p>对于规格化的数，<em>2，自然是e+1，因为2的E次方，E+1，那就等于多乘了个2<br>对于非规格化的数，E是固定的-126，没法改变，所以尾数</em>2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">float_twice</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化s符号位，exp阶码，fre尾数</span></span><br><span class="line">  <span class="type">int</span> s,<span class="built_in">exp</span>,fre;</span><br><span class="line">  s = (uf &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">exp</span> = (uf &amp; <span class="number">0x7F800000</span>) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">  fre = uf &amp; <span class="number">0x7FFFFF</span>;</span><br><span class="line">  <span class="comment">// 如果exp == 0，代表非规格化的数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 非规格化</span></span><br><span class="line">    <span class="comment">// 尾数 * 2</span></span><br><span class="line">    fre = fre &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (s &lt;&lt; <span class="number">31</span>) | (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | fre;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xFF</span>) &#123;</span><br><span class="line">    <span class="comment">// 特殊</span></span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 规格化 exp + 1</span></span><br><span class="line">    <span class="built_in">exp</span> = <span class="built_in">exp</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// +1以后有可能是全1，那么就是无穷大，也就是特殊值，无穷大需要把尾数变成全0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>) &#123;</span><br><span class="line">        fre = <span class="number">0x0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (s &lt;&lt; <span class="number">31</span>) | (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | fre;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>btest 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-32.png" alt="lab1 btest"></p>
<p>dlc 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-33.png" alt="lab1 dlc"></p>
<p>bdd check 结果：</p>
<p><img src="/../images/csapp/lab1/csapp-lab1-34.png" alt="lab1 dlc"></p>
<h3 id="float-i2f"><a href="#float-i2f" class="headerlink" title="float_i2f"></a>float_i2f</h3>]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>lab</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统（一）</title>
    <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content><![CDATA[<h1 id="计算机系统漫游"><a href="#计算机系统漫游" class="headerlink" title="计算机系统漫游"></a>计算机系统漫游</h1><p>计算机系统是由硬件和系统软件组成的，它们共同工作来运行应用程序。。虽然系统的 具体实现方式随着时间不断变化，但是系统内在的概念却没有改变。所有计算机系统都有 相似的硬件和软件组件，它们又执行着相似的功能。</p>
<h2 id="第一个c程序"><a href="#第一个c程序" class="headerlink" title="第一个c程序"></a>第一个c程序</h2><p>一般第一个程序都是输出<code>hello world</code>，这里我们使用c语言输出一个<code>hello world</code>。后面在来讲这里面都发生了什么。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="信息的表示和处理"><a href="#信息的表示和处理" class="headerlink" title="信息的表示和处理"></a>信息的表示和处理</h1><p>无符号整型和有符号整型的二进制表示</p>
<p><img src="/../images/csapp/csapp1-1.png" alt="无符号整型和有符号整型的二进制表示"></p>
<h2 id="bit"><a href="#bit" class="headerlink" title="bit"></a>bit</h2><p>可以用bit来表示集合，并用位操作来表示集合的操作。</p>
<p>p &amp;&amp; *p可以避免空指针</p>
<p>左移1位等于乘2</p>
<p>右移1位等于除2，且向下取整</p>
<p>逻辑右移：右移后补0，java中 -3 &gt;&gt; 1 &#x3D; -2<br>算术右移：右移后补符号位,java中 -3 &gt;&gt;&gt; 1 &#x3D; 2147483646</p>
<h2 id="大端表示和小端表示"><a href="#大端表示和小端表示" class="headerlink" title="大端表示和小端表示"></a>大端表示和小端表示</h2><ul>
<li>最高有效字节在最前面的方式，称为大端表示。</li>
<li>低有效字节在最前面的方式，称为小端表示。</li>
</ul>
<p><img src="/../images/csapp/csapp1-2.png" alt="大端表示和小端表示"></p>
<p>可以通过下面的代码来测试自己的机器是大端还是小端的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> *pointer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_bytes</span><span class="params">(pointer start, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">	<span class="type">size_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%p\t0x%.2x\n&quot;</span>, start+i, start[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">15213</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int a = 15213;\n&quot;</span>);</span><br><span class="line">    show_bytes((pointer) &amp;a, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><p>101.11表示5又3&#x2F;4，也就是23&#x2F;4。前面的101表示5，小数点后面的11表示3&#x2F;4,小数点后面第1个1表示1&#x2F;2，第二个1表示1&#x2F;4，所以相加就是3&#x2F;4</p>
<p><img src="/../images/csapp/csapp1-3.png" alt="float"></p>
<p>浮点数表示由<code>IEEE</code>制定。</p>
<p>IEEE浮点标准用<code>V = (-1)的s次方 * M * 2的E次方</code>来表示。</p>
<p>所以存储就有了3部分</p>
<ul>
<li>符号位，1位，0表示正数，1表示负数，表示s</li>
<li>尾数significand，尾数通常是1-2之间或0-1之间。encodes M，但不等于M</li>
<li>阶码exponent，encodes E，但不等于E</li>
</ul>
<p><img src="/../images/csapp/csapp1-4.png" alt="IEEE float"></p>
<h3 id="表示方式"><a href="#表示方式" class="headerlink" title="表示方式"></a>表示方式</h3><h4 id="规格化表示-Normalized"><a href="#规格化表示-Normalized" class="headerlink" title="规格化表示(Normalized)"></a>规格化表示(Normalized)</h4><p>当阶码不等于全0或不等于全1的时候，就表示规格化的浮点数。</p>
<p>E的计算方式</p>
<ul>
<li>E &#x3D; 阶码 - Bias</li>
<li>Bias &#x3D; 2的k-1次方 - 1，单精度是127，双精度是1023</li>
<li>单精度下，假设阶码为 0000 0001, 那么E &#x3D; 1 - 127 &#x3D; -126</li>
</ul>
<p>M的计算方式</p>
<ul>
<li>M &#x3D; 1.XXXXXX</li>
<li>尾数就是 XXXXXX</li>
<li>假设 尾数为 0000 0000 0000 0000 0000 001，那么M &#x3D; 1.00000000000000000000001</li>
</ul>
<p>假设符号为0表示正数，那么这个浮点数为 V &#x3D; 1 * M * 2的E次方<br>&#x3D; 1 * 1.00000000000000000000001 * 2的-126次方<br>&#x3D; 1.00000000000000000000001 * 2的-126次方<br>&#x3D; 0.000…00100000000000000000000001 （小数点左移126位）<br>这等于非常非常小的一个浮点数了</p>
<p>如何表示15213.0呢。首先符号位为0，然后计算尾数和阶码。</p>
<ul>
<li>15213.0 换成二进制表示为 11 1011 0110 1101.0</li>
<li>接下里移动小数点为 1.1101 1011 0110 1 * 2的13次方，因为小数点左移动了13位。</li>
<li>所以尾数为 1101 1011 0110 1000 0000 000</li>
<li>E &#x3D; 13，所以阶码 &#x3D; E + Bias &#x3D; 13 + 127 &#x3D; 140.</li>
<li>所以阶码为 140，二进制表示为 1000 1100</li>
</ul>
<p>15213.0的浮点数表示为：</p>
<p>0 1000 1100 1101 1011 0110 1000 0000 000</p>
<h4 id="非规格化表示-Denormalized"><a href="#非规格化表示-Denormalized" class="headerlink" title="非规格化表示(Denormalized)"></a>非规格化表示(Denormalized)</h4><p>当阶码等于全0的时候，就表示非规格化的浮点数。</p>
<p>E的计算方式，他跟阶码没关系了，因为阶码永远是0</p>
<ul>
<li>E &#x3D; 1 - Bias</li>
<li>Bias &#x3D; 2的k-1次方 - 1，单精度是127，双精度是1023</li>
<li>阶码永远为 0000 0000, E &#x3D; 1 - 127 &#x3D; -126</li>
</ul>
<p>M的计算方式</p>
<ul>
<li>M &#x3D; 0.XXXXXX</li>
<li>尾数就是 XXXXXX</li>
<li>假设 尾数为 0000 0000 0000 0000 0000 001，那么M &#x3D; 0.00000000000000000000001</li>
</ul>
<p>假设符号为0表示正数，那么这个浮点数为 V &#x3D; 1 * M * 2的E次方<br>&#x3D; 1 * 0.00000000000000000000001 * 2的-126次方<br>&#x3D; 0.00000000000000000000001 * 2的-126次方<br>&#x3D; 0.000…00000000000000000000000001 （小数点左移126位）<br>这等于非常非常小的一个浮点数了，比上一个规格化的更小</p>
<p>如果尾数也等于全0，那么就表示浮点数0</p>
<h4 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h4><p>当阶码等于全1的时候，就表示特殊的浮点数。</p>
<ul>
<li>当尾数全0，就表示无穷大</li>
<li>当尾数为其他值的时候，就表示 NaN(Not a Number)</li>
</ul>
<p>用数轴表示如下：</p>
<p><img src="/../images/csapp/csapp1-5.png" alt="IEEE float 表示"></p>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p> 习题2.54 假定变量x,f和d的类型分别是int、float 和cioubile。除了f和d都 不 能 等 于 十∞ 、 、 一 ∞ 或 者 N a N ， 它 们 的 值 是 任 意 的 。 对 于 下 面 每 个 C 表 达 式， 证 明 它 总 是 为 真 ( 也 就 是 求 值 为 1 )， 或 者 给 出 一 个 使 表 达 式 不 为 真 的 值 ( 也 就 是 求 值 为 0 )。</p>
<p> 类型中long &gt; double &gt; int &gt; float</p>
<ol>
<li>x &#x3D;&#x3D; (int) (double) x &#x2F;&#x2F; true</li>
<li>x &#x3D;&#x3D; (int) (float) x &#x2F;&#x2F; false</li>
<li>d &#x3D;&#x3D; (double) (float) d &#x2F;&#x2F; false</li>
<li>f &#x3D;&#x3D; ( float ) ( double ) f &#x2F;&#x2F; true</li>
<li>f &#x3D;&#x3D; -(-f) &#x2F;&#x2F;true 只改变了符号位</li>
<li>1.0&#x2F;2 &#x3D;&#x3D; 1&#x2F;2.0 &#x2F;&#x2F;true</li>
<li>d*d &gt;&#x3D; 0.0 &#x2F;&#x2F; true</li>
<li>( f + d ) - f &#x3D;&#x3D; d &#x2F;&#x2F;false浮点数不满足结合律</li>
</ol>
<h1 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h1><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>从最早的16位处理器8086到现在的64位处理器x86-64</p>
<ul>
<li>8086(1978年 ， 29 K个晶体管 )。 是 第 一代单芯片、16 位微处理器之一。8088是8086的一个变种，在8086上增加了一个8位外部总线，构成最初的IBM个人计算机的心脏。 BM与当时还不强大的微软签订合同，开发MS DOS 操作系统。最初的机器型号有32768 字节的内存和两个软驱 (没有硬盘驱动器)。 从体系结构上来说，这些机器只有655360字节的地址间 – 地址只有20位长(可寻址范围为1048576字节)，而操作系统保留了393216字节自用。1980年 ，Intel提出了8087浮点协处理器 (45 K个晶体管)，它与一个8086或8088处理器一同运行，执行浮点指令。8087 建立了x86 系列的浮点模型，通常被称为 “x87”</li>
<li>80286(1982 年，134K个晶体管)。增加了更多的寻址模式(现在已经废弃了)，构成了IBM PC- AT个人计算机的基础，这种计算机是 MS Windows 最初的使用平台。</li>
<li>i386 (1985 年，275K 个晶体管) 。将体系结构扩展到32位。增加了平坦寻址模式(flat addressingmodel)，Linux 和最近版本的Windows 操作系统都是使用的这种模式。这是 Intel 系列中第 一台全面支持Unix操作系统的机器。</li>
<li>i486(1989 年，1.2M个晶体管)。改善了性能，同时将浮点单元集成到了处理器芯片上，但是指令集没有明显的改变。</li>
<li>Pentium(1993 年，3.1M个晶体管)。改善了性能，不过只对指令集进行了小的扩展</li>
<li>PentiumPro( 1995 年，5.5M个晶体管)。引人全新的处理器设计，在内部被称为P6 微体系结构。指令集中增加了一类“ 条件传送(conditional move)” 指令</li>
<li>Pentium&#x2F; MMX ( 1997年，4.5M个晶体管 )。 在 Pentium处理器中增加了一类新的处理整数向量的指令。每个数据大小可以是1、2或4字节。每个向量总长64位</li>
<li>Pentium II ( 1997 年 ，7M 个晶体管 )。 P6微体系结构的延伸</li>
<li>Pentium III (1999年，8.2M个晶体管)。引人了SSE，这是一类处理整数或浮点数向 量的指令。每个数据可以是1、2或4个字节，打包成128位的向量。由于芯片上包括了 二 级高速绥存，这种芯片后来的版本最多使用 了24M 个晶体管</li>
<li>Pentium4 ( 2000年 ， 42M个晶体管 )。 SSE 扩展到了 SSE2，增加了新的数据类型 (包括双精度浮点数)，以及针对这些格式的 144 条新指令。有了这些扩展，编译器可以使用 SSE 指令(而不是x87 指令)，来编译浮点代码</li>
<li>Pentium 4E(2004年，125M个晶体管)。增加了超线程(hyperthreading)，这种技术 可以在一个处理器上同时运行两个程序;还增加 了EM64T ，它是 Intel 对 AMD 提出的对 IA32的64 位扩展的实现，我们称之为x86-64。</li>
<li>Core2( 2006年 ， 291M 个晶体管 )。 回归到类似于 P6 的微体系结构 。Intel的第一个多核微处理器，即多处理器实现在一个芯片上。但不支持超线程。</li>
<li>Core i7，Nehalem(2008年，781M个晶体管)。既支持超线程，也有多核，最初的版 本支持每个核上执行两个程序，每个芯片上最多四个核</li>
<li>Core i7, Sandy Bridge(2011年，1.17G 个晶体管)。引入了AVX，这是对SSE 的扩 展，支持把数据封装进 256 位的向量。</li>
<li>Corei7, Haswel(2013年，1.4G个晶体管)。将AVX扩展至AVX2，增加了更多的指令和指令格式.</li>
</ul>
<h2 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h2><h1 id="程序优化性能"><a href="#程序优化性能" class="headerlink" title="程序优化性能"></a>程序优化性能</h1><p>要写出编译器友好的程序来提升程序性能，比如下面两个函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> *yp)</span> &#123;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> *yp)</span> &#123;</span><br><span class="line">    *xp += <span class="number">2</span> * *yp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于test1来说，要执行读取xp,读取yp,写xp，再次读取xp,读取yp，写xp，总共4次读取，2次写入。</p>
<p>对于test2来说，要执行读取xp,读取yp，写xp，只需要2次读取，1次写入，当然性能更好。</p>
<p>而且考虑一种情况，就是<code>*xp</code>和<code>*yp</code>指向同一个内存，如果这样的话，那么test1就变成了 xp &#x3D; 4 * xp，test2就变成了 xp &#x3D; 3 * xp，意思就不一样了，所以编译器没有办法把test1优化成test2的形式，这种叫做<code>内存别名</code></p>
<p>在看一个指针的问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1000</span>;y = <span class="number">3000</span>;</span><br><span class="line">*q = y;</span><br><span class="line">*p = x;</span><br><span class="line">t1 = *q; <span class="comment">// 1000 or 3000</span></span><br></pre></td></tr></table></figure>

<p>如果<code>*q</code>和<code>*p</code>是指向两个内存，那么t1就是3000,如果指向同一个内存，那么t1就是1000，因此编译器无法对这种代码进行优化。</p>
<h3 id="消除循环的低效率"><a href="#消除循环的低效率" class="headerlink" title="消除循环的低效率"></a>消除循环的低效率</h3><p>可以把循环中的多次计算或者过程调用等重复执行的，结果确定的，提取出来，只执行一次。</p>
<p>比如下面的代码，这个时候strlen这个函数会执行n次，A-a也会执行n次，他们的结果每次都是一样的，可以都提取出来。A-a由于是常数减法，编译器应该会优化，但是strlen是一个函数，函数的结果是不确定的，编译器会保守的保留它不进行优化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lower</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">size_t</span> i;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line"> <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line"> s[i] -= (<span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>优化后的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lower</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">size_t</span> i;</span><br><span class="line"> <span class="type">size_t</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"> <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line"> s[i] -= (<span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="减少过程调用"><a href="#减少过程调用" class="headerlink" title="减少过程调用"></a>减少过程调用</h3><p>有一些函数中会有一些不必要的操作，可以减少他们，比如数组函数，里面也许会有边界检查之类的，防止越界，但是如果我们的外部代码已经很明显的做了检查，或者说肯定不会越界，那么我们就可以省掉调用函数里面的这部分开销。</p>
<p>get_vec_element这个函数获取数组中的值，并且做了边界检查。这样会做n次边界检查，我们可以优化它。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine2</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    *dest = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">        <span class="type">data_t</span> val;</span><br><span class="line">        get_vec_element (v, i, &amp;val);</span><br><span class="line">        *dest = *dest OP val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化之后的代码，省了每次的边界检查。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine3</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">data_t</span> *data =get_vec_start(v);</span><br><span class="line">    *dest = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">        *dest = *dest OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消除不必要的内存引用"><a href="#消除不必要的内存引用" class="headerlink" title="消除不必要的内存引用"></a>消除不必要的内存引用</h3><p>上面的代码还是有些问题，因为对于dest来说，每次都要经历load,计算,store的过程，这个过程要重复n次，可以通过增加局部变量来减少load和store的次数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine4</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">data_t</span> *data =get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h3><p>for循环每次循环都会进行if条件判断，计算机执行条件判断的时候是比较费时的，现在有了<code>分支预测</code>功能，但是预测失败的话，也会影响性能。可以通过循环展开来优化这里，来减少for循环的消耗。这样改造的程序，已经极为接近线性代码的功耗了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine5</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span> *data =get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc = IDENT;</span><br><span class="line">    <span class="comment">// 循环次数减半</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;limit; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        acc = acc OP data[i] OP data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环不一定是2的倍数，这里处理剩下的元素</span></span><br><span class="line">    <span class="keyword">for</span>(;i&lt;length; i++) &#123;</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结合律"><a href="#结合律" class="headerlink" title="结合律"></a>结合律</h3><p>对于满足结合律的运算，可以通过结合律来优化。对于上面的combine5函数来说，他的执行流程是这样的。因为每次乘的时候都要等上一个的结果，所以是线性的。</p>
<p><img src="/../images/csapp/csapp5-1.png" alt="结合律1"></p>
<p>使用结合律优化以后，执行路程是下面这样的，为啥它能并行呢，因为在执行左边<code>acc * (i * i+1)</code>结果的时候，就已经可以计算<code>i+2 * i+3</code>的结果了。这两个乘法并行了，所以缩短了执行时间。上面无法并行的原因是先计算了<code>acc * i</code>，当计算下一个<code>acc * i</code>的时候需要依赖上一次acc的结果。</p>
<p><img src="/../images/csapp/csapp5-2.png" alt="结合律2"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine6</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span> *data =get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc = IDENT;</span><br><span class="line">    <span class="comment">// 循环次数减半</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;limit; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 唯一的区别的就是这里加了括号</span></span><br><span class="line">        acc = acc OP (data[i] OP data[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环不一定是2的倍数，这里处理剩下的元素</span></span><br><span class="line">    <span class="keyword">for</span>(;i&lt;length; i++) &#123;</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多个累积变量"><a href="#多个累积变量" class="headerlink" title="多个累积变量"></a>多个累积变量</h3><p>还可以通过先求出所有i为偶数的结果，和i为奇数的结果，在把两个结果结合到一起。这样的话先计算奇数和偶数，这两个是互不干涉的，也可以达到上面结合律的效果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine7</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span> *data =get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc0 = IDENT;</span><br><span class="line">    <span class="type">data_t</span> acc1 = IDENT;</span><br><span class="line">    <span class="comment">// 循环次数减半</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;limit; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算偶数和奇数</span></span><br><span class="line">        acc0 = acc0 OP data[i]；</span><br><span class="line">        acc1 = acc1 OP data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环不一定是2的倍数，这里处理剩下的元素</span></span><br><span class="line">    <span class="keyword">for</span>(;i&lt;length; i++) &#123;</span><br><span class="line">        acc0 = acc0 OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = acc0 OP acc1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h1><h2 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h2><p>存储技术分为<code>易失存储</code>和<code>非易失存储</code>。</p>
<ul>
<li>易失存储：DRAM 也就是一般所说的电脑内存,SRAM 也就是一般的cpu缓存，CPU的L1缓存，L2,L3这些</li>
<li>非易失存储：机械硬盘，固态硬盘</li>
</ul>
<h3 id="机械硬盘"><a href="#机械硬盘" class="headerlink" title="机械硬盘"></a>机械硬盘</h3><p><img src="/../images/csapp/csapp6-1.png" alt="机械硬盘"></p>
<p>最便宜的存储，存储容量也很大。由下面的部分组成</p>
<ul>
<li>主轴：盘片放在主轴上</li>
<li>盘片：一个盘片有两个面可以进行存储</li>
<li>磁道：每个盘面上有多个磁道</li>
<li>扇区：每个磁道被划分为一组扇区</li>
<li>磁头：通过磁头进行读写扇区上的数据</li>
</ul>
<p><img src="/../images/csapp/csapp6-2.png" alt="机械硬盘"></p>
<p>所以在次盘上读写的时候，需要移动<code>磁头</code>，让磁头找到对应的盘面，在找到磁道和扇区，然后才能读写数据，所以<code>顺序读写</code>比<code>随机读写</code>快的多。因为顺序的话磁头只需要移动一点点距离，而随机需要移动很长的距离。</p>
<h3 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h3><p>固态硬盘是基于<code>闪存</code>的存储技术，价格比机械硬盘贵一些。因为是闪存，所以顺序读写和随机读写都比机械硬盘快。虽然固态的顺序读写和随机读写的差距缩小了，但是顺序读写依旧比随机读写快。</p>
<ul>
<li>块：整个闪存分成一个个块,一个块有32-128个页，块的大小为16KB-512KB</li>
<li>页：一个块有多个页组成，每次读写都是一个页，页的大小是512字节-4KB</li>
<li>闪存翻译层：连接IO总线和闪存数据，将数据放到IO总线里面，也将IO总线的数据放到闪存里面。</li>
</ul>
<p>固态每次写入需要先擦除一个页里面原来的内容，在写入新的，因此，擦除次数多了以后，这个页就会坏掉。为了提升固态的使用寿命，一般也会控制每次擦除寿命更高的页。</p>
<h3 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h3><p><img src="/../images/csapp/csapp6-3.png" alt="DRAM"></p>
<p>DRAM 也就是电脑内存，由下面几部分组成，价格比固态和机械硬盘贵的多，容量也小的多，现在大多数是16G内存。</p>
<ul>
<li>n * n的存储单元：真正存储数据的地方</li>
<li>行缓冲区：每次先将一行的数据取到缓冲区里面，在取对应的存储单元里面的数据。</li>
<li>addr引脚：发送行号和列号给DRAM，发送行号以后，将这一行数据取到行缓冲区里面，再发送列号以后，返回对应的数据</li>
<li>data引脚：传递数据</li>
</ul>
<p>DRAM的发展历史，RAS:发送行号，CAS:发送列号</p>
<ul>
<li>快页模式DRAM(Fast Page Mode DRAM, FPMDRAM)。传统的DRAM将存储单元的一整行复制到它的内部行缓冲区中， 使用一个 ，然后丢弃剩余的。FPM DRAM允许对同一行连续地访问可以直接从行缓冲区得到服务，从而改进了这一 点。例如，要从一个传统的DRAM的行i中读4个存储单元，内存控制器必须发送4 个RAS&#x2F;CAS请求，即使是行地址i在每个情况中都是一样的。要从一个FPM DRAM的同一行中读取存储单元，内存控制器发送第一个RAS&#x2F;CAS请求，后面跟三个CAS请求。初始的RAS&#x2F; CAS请求将行i复制到行缓冲区，并返回CAS寻址的那个存储单元。接下来三个存储单元直接从行缓冲区获得，因此返回得更快。</li>
<li>扩展数据输出 DRAM( Extended Data Out DRAM, EDO DRAM) . FPM DRAM 的一个增强的形式 ，它允许各个 CAS 信号在时间上靠得更紧密一点 。</li>
<li>同步DRAM(Synchronous DRAM，SDRAM)。就它们与内存控制器通信使用一组显式的控制信号来说，常规的FPM 和EDO DRAM 都是异步的。SDRAM用与驱动内存控制器相同的外部时钟信号的上升沿来代替许多这样的控制信号。我们不会深人讨论细节， 最终效果就是SDRAM 能够比那些异步的存储器更快地输出它的超单元的内容。</li>
<li>双倍数据速率同步DRAM(Double Data-Rate SynchronousDRAM, DDR SDRAM)。 DDR SDRAM 是 对 SDRAM 的一种增强 ，它通过使用两个时钟沿作为控制信号，从而使DRAM的速度翻倍。不同类型的DDR SDRAM 是用提高有效带宽的很小的预取绥冲区的大小来划分的 : DDR (2位)、 DDR2 (4位)和 DDR (8位)。</li>
</ul>
<p>现在一般的DDR5，DDR4，其实就是DDR DRAM内存。</p>
<h3 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h3><p>SRAM 也就是电脑CPU的L1,L2,L3三级缓存使用的，价格比DRAM更贵，容量更小。通常是多少KB或MB。</p>
<p>SRAM将每个位存储在一个双稳态的(bistable)存储器单元里。每个单元是用一个六晶体管电路来实现的。这个电路有这样一个属性，它可以无限期地保持在两个不同的电压 配置(configuration )或状态(state) 之一。其他任何状态都是不稳定的一一从不稳定状态开始，电路会迅速地转移到两个稳定状态中的一个。</p>
<p><img src="/../images/csapp/csapp6-4.png" alt="SRAM"></p>
<h2 id="局部性-locality"><a href="#局部性-locality" class="headerlink" title="局部性(locality)"></a>局部性(locality)</h2><p>局部性分为<code>空间局部性(spatial locality)</code>和<code>时间局部性(temporal locality)</code>。</p>
<p>从上面也能看出，DRAM一次加载一行到行缓冲区，如果我们要的数据都在这一行，取的时候就会很快。这就是<code>空间局部性</code>。</p>
<p>比如数组的顺序访问。这个时候一个个接着访问的，就具有空间局部性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[<span class="number">100</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,...&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ai:%d&quot;</span>,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二维数组是一样的，需要按照行来访问。而不能按照列。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[<span class="number">100</span>][<span class="number">100</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,...&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,...&#125;,...&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;aij:%d&quot;</span>,a[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照列访问，不具有局部性，应该使用上面那种方式</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;aij:%d&quot;</span>,a[j][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三维数组,也应该使用行访问。<br>{<br>    {<br>        {0,0,0,…}, &#x2F;&#x2F; 000, 001, 002, 003<br>        {0,0,0,…}, &#x2F;&#x2F; 010, 011, 012, 013<br>        {0,0,0,…},<br>        {0,0,0,…}<br>    },<br>    {<br>        {0,0,0,…}, &#x2F;&#x2F; 100, 101, 102, 103<br>        {0,0,0,…}, &#x2F;&#x2F; 110, 111, 112, 113<br>        {0,0,0,…},<br>        {0,0,0,…}<br>    },<br>    {<br>        {0,0,0,…},<br>        {0,0,0,…},<br>        {0,0,0,…},<br>        {0,0,0,…}<br>    },…<br>} </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[<span class="number">100</span>][<span class="number">100</span>] = &#123;&#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,...&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,...&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,...&#125;,...&#125;,&#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,...&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,...&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,...&#125;,...&#125;,...&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">100</span>; k++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;aijk:%d&quot;</span>,a[i][j][k]);</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用最近使用过的数据，就是<code>时间局部性</code>。这是因为缓存的原因，比如最近使用过的数据还在L1缓存中，就会比再去DRAM中取数据要快。</p>
<p>sum就有 时间局部性，一直在使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[<span class="number">100</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,...&#125; </span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    sum += a[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ai:%d&quot;</span>,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="存储器层次结构-1"><a href="#存储器层次结构-1" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h2><p><img src="/../images/csapp/csapp6-5.png" alt="存储器层次结构"></p>
<p>通常，高层的可以作为低层的缓存，比如L1缓存L2的数据，L2缓存L3的，L3缓存内存的。数据以块为大小传输。</p>
<ul>
<li>缓存命中(cache hit)：要查找的内容就在L1缓存中，就不需要去L2查找了</li>
<li>缓存不命中(cache miss): 要查找的内容不在L1中，而在L2中，需要从L2传输到L1中。<ul>
<li>强制性不命中(compulsory miss): 在第一次访问缓存的时候，缓存中肯定是空的。这个时候肯定不会命中。</li>
<li>冲突不命中(conflict miss): 缓存已经满了以后需要进行替换，比如LRU算法，比如取余算法，这个时候有可能你需要的缓存被替换出去了，因为这个原因不命中的，就是冲突不命中。</li>
<li>容量不命中(capacity miss): 因为缓存不够大而没有命中的。</li>
</ul>
</li>
</ul>
<h2 id="高速缓存存储器"><a href="#高速缓存存储器" class="headerlink" title="高速缓存存储器"></a>高速缓存存储器</h2><p>像L1,L2这种SRAM，就是<code>高速缓存存储器</code>。</p>
<p>假设每个存储器地址有m位，形成$M &#x3D; 2^m$个不同的地址。它由 $S &#x3D; 2^s$ 个set组成。每个set里面有 $E &#x3D; 2^e $ 个缓存行。每个行有 $B &#x3D; 2^b$字节的数据块组成。高速缓存的大小$C &#x3D; S * E * B$(不包括Tag和Valid)</p>
<p><img src="/../images/csapp/csapp6-6.png" alt="高速缓存存储器"></p>
<p>每个数据块有</p>
<ul>
<li>Valid: 1bit，0表示无效缓存，1表示有效缓存</li>
<li>Tag: t个bit，一些标记 t &#x3D; m - (b + s)</li>
<li>Data: 真正的数据，有$B &#x3D; 2^b$字节</li>
</ul>
<p><img src="/../images/csapp/csapp6-7.png" alt="高速缓存存储器 block"></p>
<p>m个地址位的组成：</p>
<ul>
<li>t个bit:Tag，用来匹配高速缓存中的Tag，如果匹配上了说明缓存命中。</li>
<li>s个bit:set index,用来找到对应的数据在哪个set里面。</li>
<li>b个bit:block offset,用来找到具体数据在block的哪个位置里面。</li>
</ul>
<p><img src="/../images/csapp/csapp6-8.png" alt="高速缓存存储器 addr"></p>
<h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>假设 m &#x3D; 6,s &#x3D; 2,t &#x3D; 1, b &#x3D; 3, e &#x3D; 1, 则 S &#x3D; 4个set,E &#x3D; 2个行，B &#x3D; 8字节。大小C &#x3D;4 * 2 * 8 &#x3D; 64。</p>
<p>假设 当前m &#x3D; 000001, 那么 tag &#x3D; 0, bit set &#x3D; 00, block offset &#x3D; 001。</p>
<p>缓存命中的情况。总共4个set，找到第0个set，然后找到其中tag是0并且valid是1的一个block，找到以后，找 001位置的数据，然后返回就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    valid   tag     data</span><br><span class="line">00   1       0      ...    // 首先找到set 00 的这个set,有两行，这一行</span><br><span class="line">00   0       0      ...    // 还有这一行</span><br><span class="line">01   0       0      ...</span><br><span class="line">01   0       0      ...</span><br><span class="line">10   1       0      ...</span><br><span class="line">10   1       0      ...</span><br><span class="line">11   0       0      ...</span><br><span class="line">11   0       0      ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../images/csapp/csapp6-9.png" alt="高速缓存存储器 addr"></p>
<p>缓存不命中的情况。总共4个set，找到第2个set，然后找到其中tag是0并且valid是1的，这个时候发现没有匹配的，那么触发miss，开始去下一层获取数据，获取到数据以后，通过替换算法替换掉一个行，将tag修改为0并且valid修改为1，然后把数据写入block data。再返回001位置的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    valid   tag     data</span><br><span class="line">00   1       0      ...    </span><br><span class="line">00   0       0      ...    </span><br><span class="line">01   0       0      ...    // 首先找到set 01 的这个set,有两行，这一行</span><br><span class="line">01   0       0      ...    // 还有这一行</span><br><span class="line">10   1       0      ...</span><br><span class="line">10   1       0      ...</span><br><span class="line">11   0       0      ...</span><br><span class="line">11   0       0      ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>冲突不命中，比如计算两个数组的点积。这个时候a[0] * b[0],会先把数组a加载到L1缓存，然后再把b加载到L1缓存，这个时候b会把a覆盖，然后a[1] * b[1]的时候，a就会冲突不命中，然后用a把b覆盖，一直重复这个动作。这个时候可以增加E,比如一个set里面有多个block，这样就不会覆盖了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">dotProd</span><span class="params">(<span class="type">float</span> a[<span class="number">100</span>], <span class="type">float</span> b[<span class="number">100</span>])</span> &#123;</span><br><span class="line">    <span class="type">float</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        sum += a[i] * b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>在写入的时候有两种情况，缓存命中和不命中，通常的搭配是<code>write through + no write allocate</code>和<code>write back + write allocate</code></p>
<ul>
<li>缓存命中<ul>
<li>wirte through: 这个时候直接写入缓存。并且修改下一层的数据。相当于同步修改。</li>
<li>write back: 直接写入缓存，并且标记dirty, 尽可能的推迟更新下一层的数据，只有当替换算法执行的时候才更新。相当于异步修改。</li>
</ul>
</li>
<li>缓存不命中<ul>
<li>write allocate: 先把数据从下一层加载到缓存，然后更新缓存数据。</li>
<li>no write allocate: 直接写入下一层数据。</li>
</ul>
</li>
</ul>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>c文件变成可执行文件的过程</p>
<ul>
<li>c预处理器cpp生成ASCII码的.i文件, cpp main.c main.i</li>
<li>c编译器cc1生成ASCII汇编语言.s文件, cc1 main.i -Og -o main.s</li>
<li>汇编器as生成可重定位目标文件.o文件， as -o main.o main.s </li>
<li>链接器ld生成可执行文件, ld -o main main.o</li>
</ul>
<p>为了构造可执行文件，链接器必须完成两个主要任务</p>
<ol>
<li>符号解析。目标文件定义和引用符号，每个符号对应于一个函数 、一个全局变量或一个静态变量 (即C语言中任何以 static 属性声明的变量)。 符号解析的目的是将每个符号引用正好和一个符号定义关联起来</li>
<li>重定位。编译器和汇编器生成从地址。开始的代码和数据节。链接器通 过把每个符号定义与 一个内存位置关联起来，从而重定位这些节，然后修改所有对 这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条 目(relocation entry)的详细指令，不加甄别地执行这样的重定位。</li>
</ol>
<p>目标文件有三种形式</p>
<ul>
<li>可重定位目标文件。包含二进制和代码数据，可与其他重定位目标文件合并起来变成可执行目标文件。</li>
<li>可执行目标文件。包含二进制和代码数据，可被直接复制到内存并执行。</li>
<li>共享目标文件。一种特殊类型的可重定位目标文件，可在加载或运行时被动态的加载进内存并链接。</li>
</ul>
<p><code>ELF(x86-64的Linux系统的文件)可重定位目标文件</code>的格式</p>
<ul>
<li>ELF头。</li>
<li>.text。已编译程序机器代码</li>
<li>.rodata。只读数据，比如printf语句中的格式串</li>
<li>.data。已初始化的全局和静态变量。</li>
<li>.bss。未初始化的全局和静态变量，以及所有初始化为0的全局和静态变量。不占据实际空间，仅仅是一个占位符。</li>
<li>.symtab。一个符号表，用来存放 在程序中定义和引用的函数和全局变量的信息。</li>
<li>.rel.text。一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修 改。另 一方面，调用本地函数的指令则不需要修改</li>
<li>.rel.data。被模块引用或定义的所有全局变量的重定位信息。</li>
<li>.debug。一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定 义和引用的全局变量，以及原始的C源文件。只有以 -g选项调用编译器驱动程序时，才会得到这个表</li>
<li>.line。原始C源程序中的行号和.text 节中机器指令之间的映射。只有以-g选项调 用编译器驱动程序时，才会得到这张表</li>
<li>.strtab。一个字符串表，包括.symtab和.debug中的符号表，以及节头 部中的节名字。字符串表就是以nu 11 结尾的字符串的序列。</li>
</ul>
<p>每个可重定位目标模块m都有一个符号表，它包含m定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号:</p>
<ul>
<li>由模块m定义的并能被其他模块引用的全局符号。对应非静态的C函数和全局变量。</li>
<li>由其他模块定义的并被m引用的全局符号。对应其他模块的非静态的C函数和全局变量。</li>
<li>由模块m定义和引用的局部符号。对应于静态的C函数和全局变量。</li>
</ul>
<p>C++ 和Java 都允许重载方法，这些方法在源代码中有相同的名字，却有不同的参数 列表。那么链接器是如何区别这些不同的重载函数之间的差异呢?C++ 和Java 中能使用 重载函数，是因为编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一 的名字。这种编码过程叫做重整(mangling)，而相反的过程叫做恢复(demangling)。 幸运的是，C++ 和Java使用兼容的重整策略。一个被重整的类名字是由名字中字符 的整数数量，后面跟原始名字组成的。比如，类Foo 被编码成3Foo。方法被编码为原始方法名， 后面加上 __ ， 加上被重整的类名， 再加上每个参数的单字母编码。 比如，Foo::bar (int, long)被编码为bar__3Fooil。重整全局变量和模板名字的策略是相似的。</p>
<p>链接器对多个文件中同名变量或函数的处理。编译器会先分<code>强符号</code>和<code>弱符号</code>,强符号指函数和已初始化的全局变量，弱符号指未初始化的全局变量。</p>
<ol>
<li>不允许有多个同名的强符号</li>
<li>如果有一个强符号和多个弱符号同名，那么选择强符号。</li>
<li>如果有多个弱符号同名，那么从这些弱符号中任意选择一个。</li>
</ol>
<p>上面说的链接器接受一组<code>可重定位文件</code>，并生成一个<code>可执行文件</code>，所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为<code>静态库</code>。它也可以用作链接器的输入。当构造可执行文件的时候，直接复制静态库里面被应用程序引用的目标模块。静态库是<code>.a</code>文件。</p>
<p><code>可执行目标文件</code>的格式</p>
<ul>
<li>ELF头。</li>
<li><code>段头部表</code></li>
<li><code>.init</code>。定义了一个函_init，程序的初始化代码会调用它</li>
<li>.text。已编译程序机器代码</li>
<li>.rodata。只读数据，比如printf语句中的格式串</li>
<li>.data。已初始化的全局和静态变量。</li>
<li>.bss。未初始化的全局和静态变量，以及所有初始化为0的全局和静态变量。不占据实际空间，仅仅是一个占位符。</li>
<li>.symtab。一个符号表，用来存放 在程序中定义和引用的函数和全局变量的信息。</li>
<li>.debug。一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定 义和引用的全局变量，以及原始的C源文件。只有以 -g选项调用编译器驱动程序时，才会得到这个表</li>
<li>.line。原始C源程序中的行号和.text 节中机器指令之间的映射。只有以-g选项调 用编译器驱动程序时，才会得到这张表</li>
<li>.strtab。一个字符串表，包括.symtab和.debug中的符号表，以及节头 部中的节名字。字符串表就是以nu 11 结尾的字符串的序列。</li>
</ul>
<p><code>动态库</code>也叫<code>共享库</code>是致力于解决静态库缺陷的一个现代创新产物。共享库是一个 目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。在linux中常用<code>.so</code>后缀来表示。 微软的操作系统大量地使用了共享库，它们称为DLL(动态链接库)</p>
<p>共享库是以两种不同的方式来<code>共享</code>的。首先，在任何给定的文件系统中 ，对于一个库只有一个 <code>.so</code> 文件 。 所有引用该库的可执行目标文件共享这个.so文 件中的代码和数据 ，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行的文件中</p>
<p> <code>共享库和Java本地接口</code> Java定义了一个标准调用规则，叫做Java本地接口(Java Native Interface, JNI)，它允许Java程序调用“本地的” C和C++ 函数。JNI的基本思想是将本地C函数(如Foo)编译 到一个共享库中 (如 Foo.so )。 当一个正在运行的Java 程序试图调用函数 Foo 时 ，Java解释器 利用dlopen 接口 (或者与其类似的接口)动态链接和加载 Foo.so，然后再调用Foo。</p>
<p>在 Linux 系统中有大量可用的工具可以帮助你理解和处理目标文件。特别地，GNU binutils 包尤其有帮助，而且可以运行在每个Linux 平台上。</p>
<ul>
<li>AR:创建静态库，插人、删除、列出和提取成员。</li>
<li>STRINGS:列出一个目标文件中所有可打印的字符串。</li>
<li>STRIP:从目标文件中删除符号表信息。</li>
<li>NM:列出一个目标文件的符号表中定义的符号。</li>
<li>SIZE:列出目标文件中节的名字和大小。</li>
<li>READELF:显示 一个目标文件的完整结构，包括ELF 头中编码的所有信息。包含 SIZE 和NM的功能。</li>
<li>OBJDUMP:所有二进制工具之母。能够显示 一个目标文件中所有的信息。它最大的作用是反汇编.text节中的二进制指令。</li>
</ul>
<p>Linux 系统为操作共享库还提供了LDD程序:</p>
<ul>
<li>LDD:列出一个可执行文件在运行时所需要的共享库。</li>
</ul>
<h1 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h1><p><code>异常控制流（ExceptionalControlFlow, ECF）</code>使程序能进行跳转，正常的程序执行都是PC里面一条条指令顺序执行的。ECF使PC里面的下一条指令变成别的指令，从而完成别的功能。ECF在系统的各个层次，比如进程切换，操作系统调用，网络请求处理，IO请求处理，是计算机中实现并发的基本机制。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常是异常控制流的一种形式，它 一部分由硬件实现，一部分由操作系统实现。</p>
<p>假设当前程序正在运行，出现了<code>缺页异常</code>，也就是数据在内存中不存在，需要进行IO请求将数据加载到内存中。执行图如下，异常处理程序有很多，每个异常都有对应的处理程序，当异常发生以后，系统切换到异常处理程序中执行。异常处理完成以后返回用户程序继续执行。</p>
<p><img src="/../images/csapp/csapp8-1.png" alt="异常"></p>
<p>根据异常的不同，返回会发生三种情况：</p>
<ul>
<li>异常处理程序将控制返回给当前用户程序正在执行的指令</li>
<li>异常处理程序将控制返回给当前用户程序的下一个指令</li>
<li>异常处理程序终止当前用户程序</li>
</ul>
<blockquote>
<p>这里说的都是<code>硬件异常</code>，和Java中try catch的<code>软件异常</code>是不一样的。</p>
</blockquote>
<p>系统中可能的每种类型的异常都分配了一个唯 一的非负整数的<code>异常号</code>。有的异常号是处理器的设计者分配的，有的是操作系统的设计者分配的。前者包括被零除，缺页，断点，算术运算溢出，后者包括系统调用和外部IO设备的信号。</p>
<p>在系统启动时，操作系统会分配一个<code>异常表</code>。异常表的key就是异常号，value是异常处理程序的地址。当发生异常的时候，通过异常号找到异常处理地址，然后进行处理。异常表的首地址则放在<code>异常表基址寄存器</code>里面。硬件触发异常以后，就由<code>异常处理程序</code>软件进行执行了，执行在内核模式下。</p>
<p>异常可以分为4类，中断(interrupt),陷阱(trap)，故障(fault)和终止(abort)</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">原因</th>
<th align="left">异步&#x2F;同步</th>
<th align="left">返回</th>
</tr>
</thead>
<tbody><tr>
<td align="left">中断</td>
<td align="left">来自I&#x2F;O 设备的信号</td>
<td align="left">异步</td>
<td align="left">总是返回到下一条指令</td>
</tr>
<tr>
<td align="left">陷阱</td>
<td align="left">有意的异常</td>
<td align="left">同步</td>
<td align="left">总是返回到下一条指令</td>
</tr>
<tr>
<td align="left">故障</td>
<td align="left">潜在可恢复的错误</td>
<td align="left">同步</td>
<td align="left">可能返回到当前指令</td>
</tr>
<tr>
<td align="left">终止</td>
<td align="left">不 可恢复的错误</td>
<td align="left">同步</td>
<td align="left">不返回，直接终止程序</td>
</tr>
</tbody></table>
<p>中断是异步发生的，中断发生的时候拉起中断引脚。处理器发现中断引脚被拉起，就从系统总线读取异常号，然后执行对应的异常处理程序。执行完成以后继续返回执行下一条指令。</p>
<p>陷阱是有意的异常，最重要的作用是触发<code>系统调用</code>，正常用户程序都是运行在<code>用户模式</code>下，可以执行的功能有限，如果需要读取文件，创建进程等操作，就需要切换到<code>内核模式</code>下，由操作系统内核来进行处理。通过系统调用就可以切换到内核执行。</p>
<p>故障由错误情况引起，它可能能够被故障处理程序修正。比如<code>缺页异常</code>就是一个故障。当发生以后，故障处理程序进行处理，从磁盘加载数据，加载以后重新执行当前指令，就会成功了。如果故障没有被修正，那么就会转为abort，终止当前程序。</p>
<p>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误。</p>
<p>x86-64系统定义了多达256种不同的异常类型，0-31号是由Inter架构师定义的，因此所有x86-64系统的电脑都是一样的。32-255对应的是操作系统定义的中断和陷阱。</p>
<p>下面是一些系统调用：</p>
<p><img src="/../images/csapp/csapp8-2.png" alt="系统调用"></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><code>进程</code>的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个<code>进程的上下文</code>(context)中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合.</p>
<p>进程提供给应用程序的关键抽象</p>
<ul>
<li>一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占处理器</li>
<li>一个私有地址空间，它提供一个假象，好像我们的程序独占内存</li>
</ul>
<p>&#x2F;proc文件系统将许多内核数据结构的内容输出为 一个用户程序可以读的文 本文件的层次结构。比如，你可以使用&#x2F;proc 文件系统找出一般的系统属性，比如CPU类型 (&#x2F;proc&#x2F;cpuinfo)，或者某个特 的进程使用的内存段(&#x2F;proc&#x2F;<process-id>&#x2F;maps)。2.6 版本的Linux内核引人&#x2F;sys 文件系统，它输出关于系统总线和设备的额外的低层信息</p>
<p>操作系统内核使用一种称为上下文切换(context switch)的较高层形式的异常控制流来实现多任务。上下文包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。</p>
<p>在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程。</p>
<p>上下文切换</p>
<ul>
<li>保存当前进程的上下文</li>
<li>恢复要执行的进程的上下文</li>
<li>将控制传递给这个新恢复的进程</li>
</ul>
<p>当Unix 系统级函数遇到错误时，它们通常会返回一1，并设置全局整数变量errno 来表示什么出错了.比如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// strerror函数返回一个文本串，描述了和某个errno值相关联的错误</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork error: %s \n&quot;</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一些进程控制的系统调用C函数</p>
<ul>
<li>getpid(), 获取当前进程的pid</li>
<li>getppid(), 获取当前进程的父进程的pid</li>
<li>waitpid(), 等待子进程终止</li>
<li>sleep(), 让程序休眠，时间到啦返回0，时间没到被其他信号中断则返回剩余秒数</li>
<li>pause(), 让程序休眠直到收到信号</li>
<li>execve(), 在当前进程的上下文中加载并运行一个新程序</li>
<li>getpgrp(), 返回当前进程的进程组id</li>
<li>signal(), 设置信号处理函数</li>
</ul>
<p>从程序员的角度，可以认为进程总是处于下面三个状态之一</p>
<ul>
<li>运行：进程正在CPU上执行</li>
<li>阻塞：进程被挂起，比如读取磁盘的时候</li>
<li>终止：进程结束了，收到终止信号，主程序执行完，调用exit函数</li>
</ul>
<p>当一个子进程终止时，内核并不会立即清除它，进程会被保持为一种<code>已终止</code>的状态中，直到被父进程回收。这时候的子进程被称为<code>僵尸进程</code>。当父进程回收子进程后，内核将子进程的退出状态传递给父进程，然后清除子进程，这个时候子进程就不存在了。</p>
<p>如果一个父进程终止。它的子进程就被称为<code>孤儿进程</code>，内核会安排<code>init进程</code>成为它的孤儿进程的养父，init进程的pid为1，是在系统启动时由内核创建的，它是所有进程的祖先进程。如果父进程没有回收僵尸进程就死了，init进程会回收僵尸进程，不过长时间运行的程序比如shell或者服务器，总是应该回收它们的僵尸子进程，即使僵尸子进程没有运行，他们仍然消耗系统的内存资源。</p>
<p>一个进程可以通过<code>waitpid</code>函数来等待它的子进程终止或者停止。如果子进程已经终止，那么立即返回，如果子进程没有终止，挂起当前进程，等待子进程终止后返回，返回值为子进程的pid。此时，子进程已经被回收，内核会删除掉它的所有痕迹。</p>
<p>进程的执行顺序和回收顺序都是由操作系统内核通过异常控制流切换执行的，所以我们不能假设他们的执行顺序和回收顺序。</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p><code>Linux信号</code>允许进程和内核中断其他进程。一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。每个信号类型都对应一个系统事件，底层的硬件异常由内核异常处理程序处理的，正常情况下，对用户进程是不可见的。</p>
<p>下图是一些信号</p>
<p><img src="/../images/csapp/csapp8-3.png" alt="系统调用"></p>
<p>传送信号分为两部分</p>
<ol>
<li>发送信号。内核通过更新进程上下文中的某个状态，发送一个信号，可能有下面的原因<ul>
<li>内核检测到一个系统事件，比如除0或者子程序终止</li>
<li>一个进程调用了kill函数，显式的发送一个信号</li>
</ul>
</li>
<li>接收信号。当进程被内核强迫以某种方式对信号作出反应时，就接收了信号。进程可以忽略这个信号，终止或者通过执行<code>信号处理程序</code>来处理信号。</li>
<li>一个发出但没有被接收的信号叫做待处理信号。在任何时刻，一种类型至多只有一个待处理信号。</li>
</ol>
<p>发送信号的几种方式</p>
<ul>
<li>kill程序，kill -9 pid</li>
<li>kill函数，kill(pid, sig)</li>
<li>alarm函数，给自己发送SIGALRM信号</li>
<li>键盘，ctrl+c会发送SIGINT信号，默认终止前台作业，ctrl+z会发送SIGTSTP信号，默认挂起前台作业。</li>
</ul>
<p>前台作业和后台作业，系统只能有一个前台作业，但是可以有多个后台作业，前台作业就是通过waitpid等待程序在前台完成的，后台作业是运行在后台的，一般在命令最后面加上<code>&amp;</code>就可以让程序后台运行。</p>
<p>接收信号的几种处理</p>
<ol>
<li>忽略该信号</li>
<li>进程终止</li>
<li>用户程序捕获信号并处理</li>
</ol>
<p>可以通过<code>signal</code>函数来捕获信号并处理，第一个参数是信号，第二个参数是处理函数，如果处理函数是<code>SIG_IGN</code>，则忽略该信号，如果是<code>SIG_DFL</code>，则采用信号的默认行为处理，如果是一个函数，则执行他进行处理。</p>
<p><code>待处理的信号只能有一个</code>。再过来一个同类型的信号就会被丢弃，实际上处理方式是有一个<code>Pending</code>的位，如果有6个信号，Pending就有6位，一个信号对应一位，当有一个待处理信号的时候，相应的位就变成1，所以最多只有一个待处理，剩下的会被丢弃。所以我们不能假设所有的信号都能被接收并且处理。</p>
<p>为了解决上面的问题，就出现了<code>阻塞信号</code>。通过阻塞信号可以暂时阻塞住信号，不接收它，等我们把待处理信号处理了再<code>解除阻塞</code>然后接受它，这样的话就可以接收到每一个信号并处理了，同样的阻塞信号是通过<code>Blocked</code>位来实现的，有6个信号那么Blocked就有6位，阻塞一个信号，对应的位就变成1.</p>
<p>可以通过<code>sigprocmask</code>函数来设置Blocked位，他有三个参数，第一个参数决定了行为，第二个参数是一个set变量用来设置Blocked位，第三个参数是返回一个oldset变量来存储以前的Blocked位，当解除阻塞以后用来恢复Bloked位的。</p>
<p>第一个参数值</p>
<ul>
<li>SIG_BLOCK: 把set中的位添加到Bloked中，相当于Blocked &#x3D; Blokced | set</li>
<li>SIG_UNBLOCK: 从Blocked中删除set中的位，相当于 Blocked &#x3D; Blocked &amp; ~set</li>
<li>SIG_SETMASK: Blocked &#x3D; set</li>
</ul>
<p>使用下面的函数可以操作set变量中的位。</p>
<ul>
<li>sigemptyset。初始化set为空集合</li>
<li>sigfillset. 把每个信号都添加到set中</li>
<li>sigaddset. 添加某个信号到set中</li>
<li>sigdelset. 从set中删除某个信号</li>
<li>sigismember. 判断某个信号是否在set中。</li>
</ul>
<p>信号处理程序的编写很麻烦，因为它和其他信号处理程序以及主程序都是并发执行的。为了保证安全，要尽可能的保守，以下是一些基本原则。</p>
<ul>
<li>处理程序要尽可能简单。避免麻烦的最好方法是保持处理程序尽可能小和简 单。例如，处理程序可能只是简单地设置全局标志并立即返回;所有与接收信号相 关的处理都由主程序执行，它周期性地检查(并重置)这个标志</li>
<li>在处理程序中只调用异步信号安全的函数。所谓异步信号安全的函数(或简称安全的函 数)能够被信号处理程序安全地调用，原因有二:要么它是可重入的， 要么它不能被信号处理程序中断.</li>
<li>信号处理程序中产生输出唯一安全的方法是使用 write 函数</li>
<li>保存和恢复errno。许多Linux异步信号安全的函数都会在出错返回时设置 errno 。</li>
<li>阻塞所有的信号，保护对共享全局数据结构的访问</li>
<li>用 volatile 声明全局变量 。 </li>
<li>用 <code>sig_atomic_t</code> 声明标志。在常见的处理程序设计中，处理程序会写全局标 志来记录收到了信号。主程序周期性地读这个标志，响应信号，再清除该标志。对于通过这种方式来共享的标志 ， C 提供一种整型数据类型 sig_atomic_t， 对它的读和写保证会是原子的(不可中断的)，因为可以用一条指令来实现它们</li>
</ul>
<h2 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h2><p>当程序返回的时候一般都是通过调用栈一层层返回，有的时候会很麻烦，为了避免这种情况，出现了<code>非本地跳转</code>，它通过<code>setjmp</code>和<code>longjmp</code>来进行直接跳转，避免了一层层返回。</p>
<p>setjmp保存当前的运行环境，longjmp可以跳回setjmp的地方。</p>
<p>C++和Java 提供的异常机制是较高层次的，是C语言的setjmp和longjmp 函数的更加结构化的版本。你可以把try语句中的catch 子句看做类似于setjmp函数。相似地，throw语句就类似于longjmp 函数。</p>
<h1 id="系统级IO"><a href="#系统级IO" class="headerlink" title="系统级IO"></a>系统级IO</h1><p>在Linux中，<code>所有的一切都是文件</code>。所以文件读取可以控制一切，包括磁盘读写，网络编程都是通过文件IO来控制的。一个Linux文件就是一个m个字节的序列。</p>
<p>Unix IO接口提供了对文件的控制</p>
<ul>
<li>打开文件。返回一个<code>文件描述符</code></li>
<li>读取文件。读操作就是将文件内容复制到内存中。</li>
<li>写文件。写操作就是将内存中的内容写入到文件中。</li>
<li>改变当前的文件读写指针位置。打开文件的时候，初始为0.</li>
<li>关闭文件。关闭这个文件。</li>
</ul>
<p>Linux shell创建的每个进程开始时都有三个打开的文件:标准输入(描述符为0)、标准输出(描述符为1)和标准错误(描述符为2)</p>
<p>每个文件都有一个类型</p>
<ul>
<li>普通文件：包含任意数据，操作系统并不区分文本文件和二进制文件，在更高层的级别有的会区分<ul>
<li>文本文件： 只含有ASCII和 Unicode 字符的普通文件。</li>
<li>二进制文件： 所有其他的普通文件，对于内核来说，二进制和文本文件没有区别。</li>
</ul>
</li>
<li>目录：包含一组链接的文件，其中每个链接都将一个文件名映射到一个文件，这个文件也可能是另一个目录，每个目录至少含有两个条目<ul>
<li>.是该目录自身的链接</li>
<li>..是父目录的链接</li>
</ul>
</li>
<li>socket：是用来与另一个进程进行跨网络通信的文件</li>
</ul>
<p>Linux将所有文件都组织成一个目录结构，最上面是<code>/</code>根目录，其他所有目录都是它的子级。</p>
<p><img src="/../images/csapp/csapp10-1.png" alt="目录结构"></p>
<p>打开文件以后返回的文件描述符总是在进程中当前没有打开的最小描述符。通过系统的<code>limit</code>命令可以看到当前系统可以同时打开的文件数量。</p>
<p>Unix对文件的读取和写入操作可能会遇到<code>不足值(short count)</code>的问题。比如你要读取一个文件的前100个字节，但是这个文件每行50个字节，所以51个字节就是<code>换行符EOL</code>，换行符在Linux&#x2F;mac里面是<code>LF</code>,在win里面是<code>CRLF</code>。当遇到换行的时候只会读入换行前的50个字节，然后读取换行的时候会读取0个字节，再之后才能读取下一行。下面是几种会遇到不足值的情况。</p>
<ul>
<li>读的时候遇到换行</li>
<li>从终端读文本。从终端读取的话，read一次读取一行</li>
<li>读写socket</li>
</ul>
<h3 id="RIO包"><a href="#RIO包" class="headerlink" title="RIO包"></a>RIO包</h3><p>RIO包解决了不足值的问题，它提供了两类函数</p>
<ul>
<li>无缓冲输入输出：没有应用级缓冲，对二进制数据读写到网络和从网络读写二进制数据尤其有用</li>
<li>有缓冲输入输出：先读取或写入到缓冲区里面，在调用系统的read&#x2F;write来读写。效率更高，开销小，RIO还是线程安全的。</li>
</ul>
<p>无缓冲输入输出</p>
<ul>
<li>rio_readn(int fd, void * usrbuf, size_t n):从fd文件描述符中读取n个字节到内存usrbuf中</li>
<li>rio_writen(int fd, void * usrbuf, size_t n):从内存usrbuf中写入n个字节到fd中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usbuf, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;</span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line">    <span class="type">char</span> *bufp =usrbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没读取够需要的n个字节就一直循环读取</span></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 从fd中读取nleft个字节到内存bufp中 </span></span><br><span class="line">        <span class="keyword">if</span> ((nread = read(fd, bufp, nleft)) ‹ <span class="number">0</span>)  &#123;</span><br><span class="line">            <span class="comment">// 如果读取失败 判断失败类型如果是被信号打断则再次读取，如果是其他失败，则返回失败</span></span><br><span class="line">            <span class="keyword">if</span> (errno = EINTR) <span class="comment">/* Interrupted by sig handler return */</span></span><br><span class="line">                nread =<span class="number">0</span>; <span class="comment">/*andcall read()again*/</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* errno set by read() */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread = <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果是读取到0个，则是读取到换行符，继续读取</span></span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* EOF */</span></span><br><span class="line">        <span class="comment">// 读取的字节数变少，bufp增加</span></span><br><span class="line">        nleft -= nread;</span><br><span class="line">        bufp += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回读取到的字节数</span></span><br><span class="line">    <span class="keyword">return</span> n - nleft; <span class="comment">/* Return &gt;= 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft =n;</span><br><span class="line">    <span class="type">ssize_t</span> nwritten;</span><br><span class="line">    <span class="type">char</span> *bufp =usrbuf;</span><br><span class="line">    <span class="keyword">while</span> (nleft &gt;<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((nwritten =write(fd, bufp, nleft)) « <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (errno = EINTR) <span class="comment">/* Interrupted by sig handler return */</span> </span><br><span class="line">                written = <span class="number">0</span>; <span class="comment">/* and call write() again */</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* errno set by write() */</span></span><br><span class="line">        &#125;</span><br><span class="line">        nleft -= nwritten;</span><br><span class="line">        bufp += nwritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有缓冲输入输出</p>
<ul>
<li>rio_readinitb(rio_t *rp, int fd): 初始化一个读取的缓冲区rp，读取的时候会先从fd文件中读取数据到rp缓冲区里面，然后在从缓冲区读取</li>
<li>rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen): 从缓冲区rp中读取一个文本行到内存usrbuf中，最多maxlen-1个字节，最后以NULL结尾。如果一行不足maxlen-1，则读取一整行，如果超过maxlen-1，就截断他</li>
<li>rio_readnb(rio_t *rp, void *usrbuf, size_t n): 对于既包含文本行也包含二进制数据的读取可以使用这个函数，它是rio_readn带缓冲区的版本。</li>
</ul>
<p>下面是缓冲区<code>rio_t</code>结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> rio_fd; <span class="comment">/* 文件描述符fd */</span> </span><br><span class="line">    <span class="type">int</span> rio_cnt; <span class="comment">/* 缓冲区未读取的字节数 */</span> </span><br><span class="line">    <span class="type">char</span> *rio_bufptr; <span class="comment">/* 下一个要读取的指针 */</span> </span><br><span class="line">    <span class="type">char</span> rio_buf [RIO_BUFSIZE]; <span class="comment">/* 缓冲区 */</span></span><br><span class="line">&#125; <span class="type">rio_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rio_readinitb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    rp-&gt;rio_fd =fd;</span><br><span class="line">    rp-&gt;rio_cnt = <span class="number">0</span>;</span><br><span class="line">    rp-&gt;rio_bufptr = rp-&gt;rio_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/csapp/csapp10-2.png" alt="缓冲区rio_t结构体"></p>
<p>读取最核心的是<code>rio_read</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">rio_read</span><span class="params">(<span class="type">rio_t</span> *rp , <span class="type">char</span> *usrbuf, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始读取数据到缓冲区rp</span></span><br><span class="line">    <span class="keyword">while</span> (rp-&gt;rio_cnt &lt;= <span class="number">0</span>) &#123; <span class="comment">/* Refill if buf is empty */</span></span><br><span class="line">        <span class="comment">// 调用 read读取</span></span><br><span class="line">        rp-&gt;rio_cnt = read(rp-&gt;rio_fd, rp-&gt;rio_buf, <span class="keyword">sizeof</span>(rp-&gt;rio_buf));</span><br><span class="line">        <span class="comment">// 判断是否读取失败</span></span><br><span class="line">        <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果不是被信号打断，就是真的失败，返回-1 如果是被打断的话回到while继续读取</span></span><br><span class="line">            <span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rp-&gt;rio_cnt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取到换行符，继续读取</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 读取成功 缓冲区指针指向缓冲区开头</span></span><br><span class="line">            rp-&gt;rio_bufptr = rp-&gt;rio_buf; <span class="comment">/* Reset buffer ptr */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始冲缓冲区读取数据到usrbuf</span></span><br><span class="line">    <span class="comment">/* Copy min(n, rp-›rio_cnt) bytes from internal buf to user buf */</span></span><br><span class="line">    <span class="comment">// 默认读取n个字节，如果缓冲区不足n个，就读取整个缓冲区</span></span><br><span class="line">    cnt = n;</span><br><span class="line">    <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; n) &#123;</span><br><span class="line">        cnt = rp-&gt;rio_cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从缓冲区读取到usrbuf</span></span><br><span class="line">    <span class="built_in">memcpy</span>(usrbuf, rp-&gt;rio_bufptr, cnt);</span><br><span class="line">    <span class="comment">// 修改缓冲区指针</span></span><br><span class="line">    rp-&gt;rio_bufptr += cnt;</span><br><span class="line">    <span class="comment">// 修改缓冲区未读字节数量</span></span><br><span class="line">    rp-&gt;rio_cnt -= cnt;</span><br><span class="line">    <span class="comment">// 返回读取的字节数</span></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rio_readlineb和rio_readnb都是用了rio_read函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readlineb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> maxlen)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n,rc;</span><br><span class="line">    <span class="type">char</span> c, *bufp = usrbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环从缓冲区读取</span></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++) &#123;</span><br><span class="line">        <span class="comment">// 从缓冲区读取1个字节到c里面 如果rc == 1则读取成功</span></span><br><span class="line">        <span class="keyword">if</span> ((rc = rio_read(rp, &amp;c, <span class="number">1</span>)) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取成功把读取到的字节放到bufp指向的usrbuf位置 然后bufp指向下一个usrbuf字节</span></span><br><span class="line">            *bufp++ = c;</span><br><span class="line">            <span class="comment">// 如果读取到的是换行 n++再次读取</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                n++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取EOF</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 出错，返回-1表示错误</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取结束以后重制bufp指针</span></span><br><span class="line">    *bufp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 返回 读取字节数</span></span><br><span class="line">    <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>和上面的rio_readn唯一的区别就是read换成了rio_read，因此里面也不需要在判断是否被信号打断了，因为rio_read已经判断了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readnb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;</span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line">    <span class="type">char</span> *bufp =usrbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没读取够需要的n个字节就一直循环读取</span></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 从fd中读取nleft个字节到内存bufp中 </span></span><br><span class="line">        <span class="keyword">if</span> ((nread = rio_read(fd, bufp, nleft)) ‹ <span class="number">0</span>)  &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* errno set by read() */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread = <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果是读取到0个，则是读取到换行符，继续读取</span></span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* EOF */</span></span><br><span class="line">        <span class="comment">// 读取的字节数变少，bufp增加</span></span><br><span class="line">        nleft -= nread;</span><br><span class="line">        bufp += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回读取到的字节数</span></span><br><span class="line">    <span class="keyword">return</span> n - nleft; <span class="comment">/* Return &gt;= 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件元数据"><a href="#文件元数据" class="headerlink" title="文件元数据"></a>文件元数据</h3><p>有两个函数可以获取文件元数据</p>
<ul>
<li>stat(const char *filename, struct stat *buf): 第一个参数是文件名，第二个参数是文件元数据的结构体。</li>
<li>fstat(int fd, struct stat *buf): 第一个参数是文件描述符，第二个参数是文件元数据的结构体。</li>
</ul>
<p>文件元数据结构体</p>
<p><img src="/../images/csapp/csapp10-3.png" alt="文件元数据结构体"></p>
<h3 id="共享文件和文件重定向"><a href="#共享文件和文件重定向" class="headerlink" title="共享文件和文件重定向"></a>共享文件和文件重定向</h3><p>内核用三个数据结构来表示打开的文件</p>
<ul>
<li>描述符表(descriptor table): 每个进程都有独立的<code>描述符表</code>，里面每个表项是一个指针，指向一个打开文件表，每个进程一开始的描述符表都有三个指针，指向stdin,stdout,stderr</li>
<li>打开文件表(open file table): 所有进程共享的<code>打开文件表</code>，记录了所有打开的文件，记录了当前的文件位置，引用计数，指向v-node表的指针。调用<code>close</code>关闭文件会减少<code>引用计数</code>，当达到0,内核才会删除这个表项。</li>
<li>v-node表(v-node table)：所有进程共享<code>v-node表</code>，记录了stat结构中的大部分信息</li>
</ul>
<p><img src="/../images/csapp/csapp10-4.png" alt="共享文件"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意：当fork的时候，子进程会继承父进程的描述符表，打开文件表的引用计数会+1，这个时候想彻底关闭文件，需要两个进程都close才行。</span><br></pre></td></tr></table></figure>

<p><img src="/../images/csapp/csapp10-5.png" alt="共享文件"></p>
<p>可以使用<code>dup2</code>函数来实现<code>IO重定向</code>，也就是Linux里面的<code>&gt;</code>功能，在linux中，<code>cat a.c &gt; b.c</code>可以把cat a.c的输出内容重定向输入到b.c文件中。</p>
<ul>
<li>dup2(int oldfd, int newfd): 复制描述符表oldfd到newfd，覆盖newfd以前的内容，如果newfd已经打开，会先关闭它再复制。</li>
</ul>
<p>执行<code>dup2(4,1)</code>的意思是复制描述符fd4的内容给fd1,覆盖fd1原来的内容，假设原来fd1指向标准输出，复制以后fd1的输出将不再输出到标准输出，而是输出到fd4指向的打开文件里面。也就是将fd1的输出重定向到了fd4</p>
<p><img src="/../images/csapp/csapp10-6.png" alt="共享文件"></p>
<blockquote>
<p>C程序还提供了标准IO库，和RIO一样对Unix IO进行了封装，不过标准IO不适合网络读写，所以网络读写应该使用RIO，其他情况都应该使用标准IO。</p>
</blockquote>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p><code>MMU（Memory Management Unit）</code>来进行虚拟地址到物理地址的转化。</p>
<p><img src="/../images/csapp/csapp9-1.png" alt="MMU"></p>
<p>虚拟内存也像磁盘一样，划分为一个个块，虚拟内存里面一个块叫做一页，虚拟页面，物理内存同样分成一个个页面，称为物理页面。</p>
<p>在任意时刻，虚拟页面的集合都分为三个不相交的子集:</p>
<ul>
<li>未分配的：还没有分配出去的虚拟页面，不占用任何磁盘空间和内存</li>
<li>缓存的：已经分配出去且加载到物理内存中的页面</li>
<li>未缓存的：已经分配出去，但是还在磁盘里面，没有加载到物理内存中的页面</li>
</ul>
<p>因为主存不命中的话需要到磁盘去加载数据，这样会很慢，所以主页页面通常比较大，在4KB - 2MB，由于大的不命中处罚，所以主存是<code>全相连</code>的。任何虚拟页都可以放在任何物理页中。因为对磁盘的访问时间很长，所以主存总是用<code>写回法</code>，而不是<code>直写法</code>。</p>
<p><code>页表(page table)</code>存储了虚拟页是否加载到物理页中，以及<code>物理页的地址</code>，页表中的每一项叫做<code>页表条目(Page Table Entry)</code>，简称<code>PTE</code>。</p>
<p>下图展示了虚拟页VP1,VP2,VP4,VP7已经加载到了物理内存中，对应的PTE里面的有效位是1，PTE里面还记录了对应的物理页面地址。VP0和VP5则处于<code>未分配</code>状态。剩下的VP3,VP6则在磁盘里面。</p>
<p><img src="/../images/csapp/csapp9-2.png" alt="page table"></p>
<p><code>命中</code>，如果通过虚拟页找到对应的PTE，发现valid &#x3D;&#x3D; 1，就可以直接取出物理地址，去物理内存中获取对应的信息。</p>
<p><img src="/../images/csapp/csapp9-3.png" alt="page table"></p>
<p><code>不命中</code>,如果通过虚拟页找到对应的PTE,发现valid &#x3D;&#x3D; 0，那么需要进入<code>缺页异常</code>处理程序，先选择出一个<code>victim page</code>，如果<code>victim page</code>有修改，需要写回磁盘，然后把新的页面装入物理内存。当缺页异常处理完毕以后，返回程序继续处理，进入<code>命中</code>流程。</p>
<p><img src="/../images/csapp/csapp9-4.png" alt="page table"></p>
<p>如果程序有好的<code>局部性</code>的话，虚拟内存将工作的很好，不命中会很少，因为都集中在局部性这几页中，如果程序局部性不好，可能就会发生<code>抖动</code>，虚拟内存不断的换入换出。</p>
<blockquote>
<p>你可以利用Linux的getrusage函数监测缺页的数量 (以及许多其他的信息)</p>
</blockquote>
<p>页表中还有一些位来表示权限，<code>SUP</code>位为1表示只有内核可以访问这个PTE,用户程序不可以，<code>READ</code>则表示可以读取这个PTE的内容，<code>WRITE</code>表示可以写入这个PTE的内容。如果违反了这些，会触发异常<code>段错误(segmentation fault)</code></p>
<h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><p>每个进程有自己的页表，当前进程页表的<code>起始地址</code>存放在<code>页表基址寄存器PTBR</code>中，n位的虚拟地址包含两个部分，一个p位的<code>虚拟页面偏移VPO(Virtual Page Offset)</code>和一个n-p位的<code>虚拟页号VPN(Virtual Page Number)</code>。</p>
<p><img src="/../images/csapp/csapp9-5.png" alt="page table"></p>
<ol>
<li>MMU根据虚拟地址的<code>VPN</code>从<code>页表</code>中获取到对应的<code>PTE</code></li>
<li>如果<code>命中</code>，就把PTE里面存储的<code>PPN</code>和虚拟地址的<code>VPO</code>拼接起来成为<code>物理地址</code>,因为物理页面和虚拟页面都是p字节的，所以VPO等于PPO,可以把VPO直接拿来用。</li>
<li>根据物理地址去cache获取数据</li>
</ol>
<p><img src="/../images/csapp/csapp9-6.png" alt="page table"></p>
<p>由于每次地址翻译都需要获取PTE,如果PTE不在cache中还需要去主存获取，所以速度会下降，在MMU中添加了一个<code>翻译后备缓冲器TLB(Translation Lookaside Buffer)</code>来加快速度，TLB中缓存了页表的数据，从TLB中获取页表的速度要比cache中获取更快。在<code>虚拟页号VPN</code>中，再次被分为了两部分，如果TLB有T &#x3D; 2^t个组，两部分分别是t位的<code>TLB索引(TLBI)</code>和n-p-t位的<code>TLB的tag TLBT</code>。</p>
<p><img src="/../images/csapp/csapp9-7.png" alt="page table"></p>
<p>TLB的执行步骤</p>
<ol>
<li>MMU根据虚拟地址中的<code>TLBI</code>从<code>TLB</code>中取到对应的<code>PTE</code><ul>
<li>如果没有命中，则从cache获取<code>PTE</code></li>
</ul>
</li>
<li>如果<code>命中</code>，就把PTE里面存储的<code>PPN</code>和虚拟地址的<code>VPO</code>拼接起来成为<code>物理地址</code>,因为物理页面和虚拟页面都是p字节的，所以VPO等于PPO,可以把VPO直接拿来用。</li>
<li>根据物理地址去cache获取数据</li>
</ol>
<p>一个<code>页表</code>装载现在所有的内存地址，可能会很大，甚至比整个内存都要大，因此，可以使用<code>多级页表</code>的方式来组织页表。<code>一级页表</code>里面存放的是对应的二级页表的地址，以此类推。只有最后一个页表中包含的是<code>物理页面号PPN</code>。</p>
<ul>
<li>多级页表可以大大减少<code>一级页表</code>的大小，虚拟地址空间大部分都是未分配的，而未分配的一级页表项则不存在对应的二级页表项。</li>
<li>只有一级页表才需要总是在主存中，虚拟内存系统可以在需要时创建，页面调入或调出二级页表，这就减少了主存的压力，只有最经常使用的二级页表才需要缓存在主存中。</li>
</ul>
<p><img src="/../images/csapp/csapp9-8.png" alt="page table"></p>
<h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><p>在内存的<code>堆</code>中动态的分配内存，内核维护着一个变量<code>brk</code>，指向堆的顶部。分配器将堆视为一组不同大小大的块的集合，每个块就是连续的虚拟内存片，要么是已分配的，要么是空闲的。</p>
<p>分配器有两种</p>
<ul>
<li>显式：比如C中通过malloc来分配，通过free来释放</li>
<li>隐式：比如java中通过垃圾收集器gc来自动释放</li>
</ul>
<p>显式分配器必须在一些相当严格的约束条件下工作</p>
<ul>
<li>处理任意的malloc和free请求序列。</li>
<li>立即响应请求</li>
<li>只使用堆</li>
<li>对齐块(对齐要求)</li>
<li>不修改已分配的块</li>
</ul>
<p>在这些限制条件下，试图实现吞吐率最大化和内存使用率最大化。</p>
<p>一个实际的分配器要在吞吐率和利用率之间把握好平衡，就必须考虑以下几个问题：</p>
<ul>
<li>空闲块组织：字节数组？链表？双向链表？分离链表？</li>
<li>放置：如何选择一个合适的空闲块放置新分配的块，最先适配？最优适配？最坏适配？</li>
<li>分割：在将新块放置到某个空闲块之后，如何处理这个空闲块的剩余部分</li>
<li>合并：如何处理一个刚别释放的块,在free的时候是立即合并？还是延迟合并？</li>
</ul>
<h4 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h4><p>将空闲块大小信息放入空闲块头部，返回指针的时候返回指向<code>payload</code>的指针。如果是8字节对齐的，那么size的最低3位总是0，可以用来存放其他信息，比如最低位来存放是否分配，1已经分配，0还是空闲块</p>
<p><img src="/../images/csapp/csapp9-9.png" alt="page table"></p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>每个网络应用都是基于客户端 - 服务器模型的。采用这个模型，一个应用是由一个服务器进程和一个或者多个客户端进程组成。服务器管理某种资源，并且通过操作这种资源 来为它的客户端提供某种服务。</p>
<p>主机A和LAN1相连，它发送一段数据字节到主机B，主机B和LAN2相连</p>
<ul>
<li>主机A的客户端进行一个系统调用，从客户端的虚拟地址空间复制数据到内核缓冲区</li>
<li>主机A上的协议软件通过在数据前附加互联网络包头和LAN1帧头，创建了一个LAN1的帧。网络包头寻址到网络主机B，LAN1帧头寻址到路由器。然后它传送此帧到适配器。</li>
<li>LAN1适配器复制该帧到网络上</li>
<li>此帧到达路由器，路由器的LAN1适配器从电缆上读取它，并把它传送给协议软件</li>
<li>路由器提取网络包头，根据路由表确定往哪里转发，确定为LAN2，去掉LAN1帧头，添加LAN2帧头，并把新的帧传送到适配器</li>
<li>路由器的LAN2适配器将该帧复制到网络上</li>
<li>此帧到达主机B，适配器从电缆上读取此帧并传送给协议软件</li>
<li>最后，主机B的协议软件剥落帧头和网络包头，当服务器进行读取这些数据的系统调用时，协议软件将数据复制到服务器的虚拟地址空间。</li>
</ul>
<p><img src="/../images/csapp/csapp11-1.png" alt="page table"></p>
<p>每个主机都运行<code>TCP/IP</code>协议。因特网的客户端和服务器混合使用套接字接又函数和Unix I&#x2F;O函数来进行通信。通常将套接字函数实现为系统调用，这些系统调用会陷入内核，并调用各种内核模式的 TCP&#x2F;IP 函数。</p>
<p>IP协议提供基本的命名方法和递送机制，能从一台网络主机往其他主机发送包，也叫<code>数据报</code>。IP协议是<code>不可靠</code>的，如果数据报</p>
<p>套接字接口(socket interface)是一组函数，它们和Unix I &#x2F;O函数结合起来，用以创建 网络应用。</p>
<p><img src="/../images/csapp/csapp11-2.png" alt="page table"></p>
<p>从Linux内核的角度来看， 一个套接字就是通信的一个端点。从Linux程序的角度来看，套接字就是一个有相应描述符的打开文件。</p>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><p>现代操作系统提供了三种并发编程的方法</p>
<ul>
<li>进程：由内核调度维护，每个进程有独立的虚拟地址空间，想要和其他进程通信，必须使用某种显示的进程间通信机制。需要注意子进程的回收，避免僵尸进程。需要注意子进程会复制父进程的一切，包括文件描述符等，注意关闭不需要的文件描述符。不然内核不会回收它们。</li>
<li>IO多路复用：应用程序在一个进程的上下文中显示的调度它们自己的逻辑流。逻辑流被模拟成状态机，数据到达文件描述符后，改变文件的状态。因为程序是一个单独的进程，所以所有的流共享同一个虚拟地址空间，缺点是编写麻烦，代码复杂。</li>
<li>线程：线程是运行在一个单独进程的上下文中，由内核调度，所有线程共享同一个虚拟地址空间。</li>
</ul>
<p>进程通过<code>fork</code>和<code>execve</code>来进行开发。</p>
<p>IO多路复用通过<code>select</code>或<code>epoll</code>函数来执行，它们会挂起当前进程，当文件描述符的状态改变的时候会触发对应的操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回已准备好的描述符的非零的个数，若出错则为-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> n, fd_set *fdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span>;</span><br><span class="line"></span><br><span class="line">FD_ZERO(fd_set *fdset); <span class="comment">//把fdset中的所有位置0</span></span><br><span class="line">FD_CLR(<span class="type">int</span> fd, fd_set *fdset); <span class="comment">//清楚fdset中的fd bit</span></span><br><span class="line">FD_SET(<span class="type">int</span> fd, fd_set *fdset); <span class="comment">//设置fdset中的fd bit</span></span><br><span class="line">FD_ISSET(<span class="type">int</span> fd, fd_set *fdset); <span class="comment">//检查fdset中的fd bit是否设置</span></span><br></pre></td></tr></table></figure>

<p>IO多路复用的优缺点</p>
<ul>
<li>优点：能对程序的行为进行更好的控制；运行在同一个进程里面，共享同一个虚拟地址空间，能更好的共享数据；由于是单一进程，可以使用GDB进行调试，对调试很友好；执行性能优秀，不需要进程上下文切换这些。</li>
<li>缺点：更复杂的编码方式，随着要对程序行为更好的控制，和并发粒度的减小，都会变得更加复杂；由于只有一个进程，只能进行单核的并发，而无法充分发挥多核的并行性能。</li>
</ul>
<p>除了多进程以外，还可以在一个进程里面运行多个线程，每个线程有<code>线程上下文</code>。它们包括</p>
<ul>
<li>线程id</li>
<li>栈</li>
<li>栈指针</li>
<li>寄存器</li>
<li>PC</li>
<li>条件寄存器</li>
</ul>
<p>多个线程共享进程的虚拟地址空间，代码，数据，共享库和打开的文件，线程的切换开销更小。</p>
<p>线程的一些函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程 tid是线程的ID，attr可以改变创建线程的默认属性，f是 线程要执行的函数，arg是传给线程函数的参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *tid, <span class="type">pthread_attr_t</span> *attr, func *f, <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在线程中通过这个方法获得自己的线程id</span></span><br><span class="line">pthread_† pthread_self (<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用这个函数显示的终止线程，主线程调用会等待所有线程终止，然后在终止主线程和整个进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span> <span class="params">(<span class="type">void</span> *thread_return)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终止某一个线程tid是线程id 任何线程都可以通过这个方法终止其他线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span> <span class="params">(<span class="type">pthread_t</span> tid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程通过调用这个函数等待其他线程终止 该函数会阻塞，直到tid线程终止</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> tid, <span class="type">void</span> **thread_return)</span>;</span><br></pre></td></tr></table></figure>

<p>在任何一个时间点上，线程是<code>可结合的</code>或<code>可分离的</code>。可结合的线程可以被其他线程收回和杀死。在被其他线程回收前，它的内存资源是不被释放的。一个分离的线程是不能被其他线程回收或杀死的。它的内存资源在它终止时由系统自动释放。</p>
<p>默认情况下，线程都是可结合的，可以通过下面的函数变成可分离的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 某个线程变成可分离的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(pthread_† tid)</span>;</span><br></pre></td></tr></table></figure>

<p>初始化线程。once_control 变量是一个全局或者静态变量，总是被初始化为PTHREAD_ONCE_INIT 。当你第一次用参数 once_control 调 用 pthread_.once 时，它调用 init_routine，这是一个没有输入参数、也不返回什么的函数。接下来的以once_control为参数 的pthread_once 调用不做任何事情。无论何时，当你需要动态初始化多个线程共享的全局变量时，Pthread_once 函数是很有用的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line">i n t <span class="title function_">pthread_once</span> <span class="params">(<span class="type">pthread_once_t</span> *once_control, <span class="type">void</span> (*init_routine) (<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure>

<h3 id="用信号量同步线程"><a href="#用信号量同步线程" class="headerlink" title="用信号量同步线程"></a>用信号量同步线程</h3><p>共享变量很方便，但也引入了<code>同步错误</code>的可能性。</p>
<p>假设两个线程操作同一个变量进行计数。我们预期cnt应该是200，但结果却不一定。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt; <span class="number">100</span>; i++) cnt++;</span><br></pre></td></tr></table></figure>

<p><code>cnt++</code>虽然是一条指令，但是查看汇编可以发现，其实被分解成了三个指令，<code>Load</code>将cnt从内存加载到寄存器,<code>Update</code>更新cnt的值，<code>Store</code>将cnt写入内存。</p>
<p>如果按照顺序执行，是没有问题的。比如</p>
<ul>
<li>Load cnt&#x3D;0</li>
<li>Update cnt +&#x3D; 1</li>
<li>Store cnt&#x3D;1</li>
<li>Load cnt &#x3D; 1</li>
<li>Update cnt +&#x3D; 1</li>
<li>Store cnt &#x3D; 2</li>
</ul>
<p>但是多线程是并发执行的，我们不能假设它们的执行顺序，所以有可能是以下顺序执行</p>
<ul>
<li>Load cnt &#x3D; 0</li>
<li>Load cnt &#x3D; 0</li>
<li>Update cnt +&#x3D; 1</li>
<li>Store cnt &#x3D; 1</li>
<li>UPdate cnt+&#x3D;1</li>
<li>Store cnt &#x3D; 1</li>
</ul>
<p><img src="/../images/csapp/csapp12-1.png" alt="page table"></p>
<p><code>进度图(progress graphy)</code>可以将n个并发线程的执行模型化为一条n维笛卡尔空间中的轨迹线。每条轴k对应线程k的进度。每个点代表已经完成了Ik这个状态。</p>
<p>将两个线程的执行化成进度图，如下：从左下角开始，任意一条可以到达右上角的链接线都是可能的执行顺序。</p>
<p><img src="/../images/csapp/csapp12-2.png" alt="page table"></p>
<p>对于这两个线程来说，<code>Load</code>,<code>Update</code>,<code>Store</code>这三个指令构成了一个<code>临界区</code>。只要确保每次只有一个线程在执行临界区的代码，就可以保证顺序。也就是对共享变量的<code>互斥</code>访问。</p>
<p>两个临界区的交集形成的空间叫做<code>不安全区(unsafe region)</code>。没有经过不安全区的路线叫做<code>安全路线</code>，经过不安全区的叫做<code>不安全路线</code>。所有的安全路线都可以得到正确的结果，而不安全路线将得到错误的结果。</p>
<p><img src="/../images/csapp/csapp12-3.png" alt="page table"></p>
<p>通过<code>信号量(semaphore)</code>可以阻止代码走到不安全路线上面。信号量s是具有非负整数值的全局变量。只能由两种特殊的操作来处理：</p>
<ul>
<li>P(s): 如果s非0，那么将s减去1，并且立即返回。<ul>
<li>如果s是0，那么挂起这个线程，直到s非0为止</li>
<li>V操作会重启这个线程，重启后，将s减1，并将控制返回给调用者。</li>
</ul>
</li>
<li>V(s): 将s加1。如果有任何线程阻塞在P操作中，V会重启其中的一个。</li>
</ul>
<blockquote>
<p>P操作和V操作都是不可分割的，不会被中断。</p>
</blockquote>
<p>下面是操作信号量的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用信号量前需要通过sem_init初始化，初始化sem为value值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span> <span class="params">(<span class="type">sem_t</span> *sem, <span class="number">0</span>, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span> <span class="params">(<span class="type">sem_t</span> *s)</span>; <span class="comment">/* P(s) */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span> <span class="params">(<span class="type">sem_t</span> *s)</span>; <span class="comment">/* V(s) */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过P和V操作信号量将不安全区包裹起来，就可以阻止代码跑到不安全区里面。以这种方式来保护共享变量的信号量叫做<code>二元信号量</code>，因为它的值总是0或1。以互斥为目的的二元信号量叫做<code>互斥锁(mutex)</code>。P也叫做<code>lock</code>,V也叫做<code>unlock</code>。</p>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">sem_t</span> s;</span><br><span class="line">sem_init(&amp;s,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    sem_wait(&amp;s);</span><br><span class="line">    cnt++;</span><br><span class="line">    sem_post(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包裹起来以后的进度图</p>
<p><img src="/../images/csapp/csapp12-4.png" alt="page table"></p>
<p>信号量除了能解决同步问题，还可以<code>调度对共享资源的访问</code>。一个线程可以用信号量操作来通知另一个线程，程序状态中</p>
<h3 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h3><ul>
<li>线程安全： 一个函数被称为线程安全的(thread-safe)，当且仅当被多个并发线程反复地调用时，它会一直产生正确的结果。线程不安全的函数类：<ul>
<li>不保护共享变量的函数：可以通过加锁变成线程安全的</li>
<li>保持跨越多个调用的状态的函数：可以重写它</li>
<li>返回指向静态变量的指针的函数 ：可以加锁，然后复制返回值，解锁。使用复制后的值</li>
<li>调用线程不安全函数的函数</li>
</ul>
</li>
<li>可重入性：当它们被多个线程调用时，不会引用任何共享数据。可重人函数集合是线程安全函数的一个<code>真子集</code>。将第2类线程不安全函数转化为线程安全函数的唯一方法就是重写它，使之变为可重入的。</li>
<li>在线程化的程序中使用已存在的库函数：有些库函数是线程不安全的</li>
<li>竞争</li>
<li>死锁：给定所有互斥操作的一个全序，如果每个线程都是以一种顺序<code>获得互斥锁</code>并以<code>相反的顺序释放</code>，那么这个程序就是<code>无死锁</code>的</li>
</ul>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU15445笔记</title>
    <url>/CMU15445-priject1-bufferPool.html</url>
    <content><![CDATA[<h1 id="CMU15445"><a href="#CMU15445" class="headerlink" title="CMU15445"></a>CMU15445</h1><h2 id="第一个project-buffer-pool-manager"><a href="#第一个project-buffer-pool-manager" class="headerlink" title="第一个project buffer pool manager"></a>第一个project buffer pool manager</h2>]]></content>
      <categories>
        <category>CMU15445</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL查询路径选择</title>
    <url>/DeepSeek.html</url>
    <content><![CDATA[<p>大家好，我是大头，98年，职高毕业，上市公司架构师，大厂资深开发，管理过10人团队。</p>
<h1 id="ChatGPT要被DeepSeek取代了？"><a href="#ChatGPT要被DeepSeek取代了？" class="headerlink" title="ChatGPT要被DeepSeek取代了？"></a>ChatGPT要被DeepSeek取代了？</h1><p>大家都知道，目前的AI方面可以说是GPT遥遥领先，大部分的国产大模型还是在追赶的路上的。</p>
<p>可是，现在！我国的国产大模型出现了一个巨大利好！那就是DeepSeek诞生了！</p>
<p>DeepSeek是由知名量化资管巨头幻方量化创立，目前最新发布的<code>DeepSeek R1</code>模型，对标<code>OpenAI o1</code>模型，已经可以免费体验了！</p>
<p>这可以说是国产大模型的巨大进步！</p>
<h2 id="DeepSeek的发展"><a href="#DeepSeek的发展" class="headerlink" title="DeepSeek的发展"></a>DeepSeek的发展</h2><p>DeepSeek成立于2023年7月17日，由知名量化资管巨头幻方量化创立。DeepSeek 是一家创新型科技公司，长久以来专注于开发先进的大语言模型（LLM）和相关技术，作为大厂外唯一一家储备万张 A100 芯片的公司，幻方量化为DeepSeek的技术研发提供了强大的硬件支持。</p>
<p>2023年8月2日，注册资本变更为1000万元，章程备案，投资人变更为宁波程恩企业管理咨询合伙企业，市场主体类型变更为其他有限责任公司。</p>
<p>2024年9月5日，DeepSeek 官方更新 API 支持文档，宣布合并 DeepSeek Coder V2 和 DeepSeek V2 Chat 两个模型，升级推出全新的 DeepSeek V2.5 新模型。官方表示为向前兼容，API 用户通过 deepseek-coder 或 deepseek-chat 均可以访问新的模型。</p>
<p>2024年12 月，一份关于 DeepSeek 发布历程、优化方向的专家会议纪要文件在业内流传。对此，DeepSeek 回应称，公司未授权任何人员参与券商投资者交流会，所谓“DeepSeek 专家”非公司人员，所交流信息不实。DeepSeek 表示，公司内部制定有严格的规章制度，明令禁止员工接受外部访谈、参与投资者交流等市场上各类面向投资者的机构信息交流会。相关事项均以公开披露信息为准。</p>
<p>2025年1月27日，DeepSeek应用登顶苹果美国地区应用商店免费APP下载排行榜，在美区下载榜上超越了ChatGPT。同日，苹果中国区应用商店免费榜显示，DeepSeek成为中国区第一。根据公开报道，DeepSeek的员工规模不及OpenAI的1&#x2F;5，百人出头的公司中，算子、推理框架、多模态等研发工程师以及深度学习方面的研究人员共有约70人，主要在北京分部，其余30多人在杭州总部，多为前端、产品以及商务人员。</p>
<p>下面是DeepSeek的网址，大家可以打开自己感受一下效果！</p>
<blockquote>
<p><a href="https://www.deepseek.com/">https://www.deepseek.com/</a></p>
</blockquote>
<h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p>我们可以看到DeepSeek目前登顶了中国区和美国区下载排行榜，更是超过了ChatGPT。</p>
<p>但是只有实际使用，才能知道大模型的能力。</p>
<p>大头这次问了大模型两个问题，来进行对比，大家一起看看吧！</p>
<ul>
<li>第一个问题是“使用JAVA帮我写一个备忘录的代码”，这个问题主要是看一下两个模型的代码能力。</li>
</ul>
<p>首先是<code>DeepSeek</code>。 可以看到基本没啥问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoApp</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; memos = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n备忘录菜单:&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;1. 添加备忘录&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;2. 查看备忘录&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;3. 删除备忘录&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;4. 退出&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;请选择操作: &quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">choice</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            scanner.nextLine(); <span class="comment">// 清除缓冲区</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    addMemo();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    viewMemos();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    deleteMemo();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;退出程序...&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;无效的选择，请重新输入。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addMemo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入备忘录内容: &quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">memo</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        memos.add(memo);</span><br><span class="line">        System.out.println(<span class="string">&quot;备忘录已添加！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">viewMemos</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (memos.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有备忘录。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;备忘录列表:&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; memos.size(); i++) &#123;</span><br><span class="line">                System.out.println((i + <span class="number">1</span>) + <span class="string">&quot;. &quot;</span> + memos.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteMemo</span><span class="params">()</span> &#123;</span><br><span class="line">        viewMemos();</span><br><span class="line">        <span class="keyword">if</span> (!memos.isEmpty()) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;请输入要删除的备忘录编号: &quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            scanner.nextLine(); <span class="comment">// 清除缓冲区</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index &gt; <span class="number">0</span> &amp;&amp; index &lt;= memos.size()) &#123;</span><br><span class="line">                memos.remove(index - <span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;备忘录已删除！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;无效的编号。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再看一下GPT的回答。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoApp</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用ArrayList来存储备忘录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; memos = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示菜单</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showMenu</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n===== 备忘录应用 =====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1. 添加备忘录&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2. 查看备忘录&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3. 删除备忘录&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4. 退出&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入选项: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加备忘录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addMemo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入备忘录内容: &quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">memo</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        memos.add(memo);</span><br><span class="line">        System.out.println(<span class="string">&quot;备忘录添加成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看备忘录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">viewMemos</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (memos.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前没有备忘录！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n当前的备忘录:&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; memos.size(); i++) &#123;</span><br><span class="line">                System.out.println((i + <span class="number">1</span>) + <span class="string">&quot;. &quot;</span> + memos.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除备忘录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteMemo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">if</span> (memos.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有备忘录可以删除！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入要删除的备忘录编号: &quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> scanner.nextInt() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; memos.size()) &#123;</span><br><span class="line">            memos.remove(index);</span><br><span class="line">            System.out.println(<span class="string">&quot;备忘录删除成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;无效的编号！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> choice;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 程序主循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            showMenu();</span><br><span class="line">            choice = scanner.nextInt();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    addMemo();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    viewMemos();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    deleteMemo();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;退出程序...&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;无效的选项，请重新输入！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从这里就能看出来了，这两个模型代码能力差不多。</p>
<p>那么，我们再来看第二个问题，算是AI难题了。</p>
<ul>
<li>第二个问题是“请问9.9和9.11谁大”</li>
</ul>
<p>聪明的你们都知道是9.9更大，但是AI能正确回答出来吗？</p>
<p>这一次，我们先看GPT的回答。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9.11 比 9.9 大。</span><br><span class="line"></span><br><span class="line">在数字比较时，首先看整数部分，如果相等，再比较小数部分。9.11 的小数部分是 .11，而 9.9 的小数部分是 .9，因此 9.11 大于 9.9。</span><br></pre></td></tr></table></figure>

<p>可以看到，GPT回答错误了，真不愧是AI难题啊。</p>
<p>我们再看看<code>DeepSeek</code>的回答。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比较 9.9 和 9.11 的大小：</span><br><span class="line"></span><br><span class="line">统一小数位数：</span><br><span class="line"></span><br><span class="line">将 9.9 写成 9.90，方便比较。</span><br><span class="line"></span><br><span class="line">逐位比较：</span><br><span class="line"></span><br><span class="line">整数部分：9 = 9</span><br><span class="line"></span><br><span class="line">十分位：9 = 9</span><br><span class="line"></span><br><span class="line">百分位：0 &lt; 1</span><br><span class="line"></span><br><span class="line">结论：</span><br><span class="line"></span><br><span class="line">9.90 &lt; 9.11</span><br><span class="line"></span><br><span class="line">最终答案：\boxed&#123;9.11\ \text&#123;更大&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，也回答错了。好吧，这么看，两个模型不想上下。</p>
<p>但是，我们换一个问法呢？</p>
<p>比如问它们<code>9.9-9.11等于多少</code>?</p>
<p>我们再看看GPT的回答。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9.9 - 9.11 = 0.79</span><br><span class="line"></span><br><span class="line">所以，结果是 0.79。</span><br></pre></td></tr></table></figure>

<p>这个回答没毛病！回答正确，可是我们问它<code>9.9和9.11谁大</code>,它却回答不出来。</p>
<p>并且我们都知道，模型是有<code>上下文</code>这个概念的，我们现在根据这个上下文再问一次。问题是<code>那么9.9和9.11谁大</code></p>
<p>下面是GPT的回答。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9.9 比 9.11 小。</span><br><span class="line"></span><br><span class="line">虽然 9.9 的整数部分和 9.11 的整数部分相同，但它的小数部分是 .9，而 9.11 的小数部分是 .11。所以 9.9 小于 9.11。</span><br></pre></td></tr></table></figure>

<p>在拥有上下文的过程中，GPT依然回答错误！！</p>
<p>好了，接下来看看<code>DeepSeek</code>的回答。</p>
<p>问题是<code>9.9-9.11等于多少</code>?</p>
<p>回答是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">计算 9.9 - 9.11 的步骤如下：</span><br><span class="line"></span><br><span class="line">对齐小数位数：</span><br><span class="line"></span><br><span class="line">将 9.9 写成 9.90，方便计算。</span><br><span class="line"></span><br><span class="line">逐位相减：</span><br><span class="line"></span><br><span class="line">百分位：0 - 1，不够减，向十分位借 1，变成 10 - 1 = 9</span><br><span class="line"></span><br><span class="line">十分位：8（借出 1 后） - 1 = 7</span><br><span class="line"></span><br><span class="line">个位：9 - 9 = 0</span><br><span class="line"></span><br><span class="line">结果为负数：</span><br><span class="line"></span><br><span class="line">由于 9.90 &lt; 9.11，结果为负。</span><br><span class="line"></span><br><span class="line">最终答案：</span><br><span class="line"></span><br><span class="line">\boxed&#123;-0.21&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，错误了，错的离谱，说明<code>DeepSeek</code>还是和GPT有一些差距的。</p>
<h3 id="R1模型"><a href="#R1模型" class="headerlink" title="R1模型"></a>R1模型</h3><p>有人说了，你这是不是没用<code>DeepSeek</code>的R1模型啊。</p>
<p>确实是这样哈哈哈。</p>
<p>我们来看一下R1模型的效果。</p>
<p>问题<code>9.9-9.11等于多少</code>?</p>
<p><img src="/../images/AI01.jpg" alt="概念学习"></p>
<p>可以看到，这个答案依然是错误的……</p>
<p>那么我们换回刚才的问题<code>请问9.9和9.11谁大</code>?</p>
<p>见证奇迹的时候。</p>
<p><img src="/../images/AI02.jpg" alt="概念学习"></p>
<p>好吧，奇迹没有出现，依然错误。</p>
<p>不过能看出来大模型确实是在思考，看一下这次的回答，有详细步骤，有纠正，有问题根源，等等，但是依然回答错误了。</p>
<p>下面是具体的回答。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">答案：9.11 更大</span><br><span class="line"></span><br><span class="line">9.11</span><br><span class="line"> </span><br><span class="line">详细比较步骤：</span><br><span class="line">统一小数位数</span><br><span class="line">将 9.9 补位为 9.90，使其与 9.11 的小数位数一致，便于逐位比较。</span><br><span class="line"></span><br><span class="line">逐位比较</span><br><span class="line"></span><br><span class="line">整数部分：9 = 9</span><br><span class="line"></span><br><span class="line">十分位：9（来自 9.90） &gt; 1（来自 9.11）</span><br><span class="line">→ 此时已能判断 9.90 &gt; 9.11</span><br><span class="line"></span><br><span class="line">百分位（补充说明）：0（来自 9.90） &lt; 1（来自 9.11）</span><br><span class="line">→ 但十分位已分出大小，无需继续比较。</span><br><span class="line"></span><br><span class="line">结论</span><br><span class="line">虽然百分位 0 &lt; 1，但关键比较位是十分位，因此 9.90（即 9.9） &gt; 9.11。</span><br><span class="line">然而，这里的结论需要修正！</span><br><span class="line">实际正确的逻辑是：</span><br><span class="line"></span><br><span class="line">9.90 的十分位是 9，而 9.11 的十分位是 1，因此 9.90 &gt; 9.11。</span><br><span class="line">但根据数学事实，9.9（即 9.90）确实小于 9.11，因为正确的逐位比较应为：</span><br><span class="line"></span><br><span class="line">整数部分：9 = 9</span><br><span class="line"></span><br><span class="line">十分位：9 &gt; 1</span><br><span class="line">→ 因此 9.90 &gt; 9.11？</span><br><span class="line">这显然矛盾，说明逻辑存在问题！</span><br><span class="line"></span><br><span class="line">关键纠正：</span><br><span class="line">上述步骤存在错误，正确的比较应为：</span><br><span class="line"></span><br><span class="line">9.9 实际是 9.90，而 9.11 是 9.11。</span><br><span class="line"></span><br><span class="line">比较时，先看整数位（9 vs. 9 → 相等），再看十分位（9 vs. 1 → 9 更大）。</span><br><span class="line"></span><br><span class="line">因此，9.90 &gt; 9.11，即 9.9 &gt; 9.11。</span><br><span class="line">然而，这与实际计算结果矛盾（例如，9.9 - 9.11 = -0.21，结果为负说明 9.9 &lt; 9.11）。</span><br><span class="line">这说明原问题存在陷阱！</span><br><span class="line"></span><br><span class="line">问题根源：</span><br><span class="line">误区：误认为小数位数多的一定更大。</span><br><span class="line"></span><br><span class="line">正解：</span><br><span class="line">将两数统一为相同小数位数：</span><br><span class="line"></span><br><span class="line">9.90 vs 9.11</span><br><span class="line">十分位：9 &gt; 1 → 9.90 &gt; 9.11（正确结论）。</span><br><span class="line"></span><br><span class="line">但实际数学中，9.9 确实小于 9.11，因为 9.9 = 9.90，而 9.90 &lt; 9.11 不成立。</span><br><span class="line">这里存在逻辑矛盾，需重新审视。</span><br><span class="line"></span><br><span class="line">最终正确结论：</span><br><span class="line">通过数值验证：</span><br><span class="line"></span><br><span class="line">9.9 = 9.90，而 9.11 = 9.11。</span><br><span class="line"></span><br><span class="line">由于 9.90 &gt; 9.11，因此 9.9 &gt; 9.11。</span><br><span class="line">但根据减法结果 9.9 - 9.11 = -0.21（负数），实际应为 9.9 &lt; 9.11。</span><br><span class="line">矛盾源于比较时的错误逻辑！</span><br><span class="line"></span><br><span class="line">正解修正：</span><br><span class="line">正确比较方法：</span><br><span class="line"></span><br><span class="line">9.90vs9.11</span><br><span class="line">整数部分：9 = 9</span><br><span class="line"></span><br><span class="line">十分位：9 &gt; 1 → 9.90 &gt; 9.11</span><br><span class="line">因此，9.9 &gt; 9.11，但减法结果 9.9 - 9.11 = -0.21 表明应为 9.9 &lt; 9.11，矛盾！</span><br><span class="line">问题出在数值的书写或理解错误。</span><br><span class="line"></span><br><span class="line">终极答案：</span><br><span class="line">实际应为 9.11 &gt; 9.9，因为：</span><br><span class="line"></span><br><span class="line">9.11 = 9 + 0.11</span><br><span class="line"></span><br><span class="line">9.9 = 9 + 0.90</span><br><span class="line">但 0.90 &gt; 0.11，因此 9.9 &gt; 9.11。</span><br><span class="line">然而，减法结果为负，说明原题可能存在表述错误。</span><br><span class="line">正确答案应以数值计算为准：</span><br><span class="line"></span><br><span class="line">9.9−9.11=−0.21⇒ 9.11 更大</span><br></pre></td></tr></table></figure>

<p>可以看到，根本原因是因为大模型认为<code>9.9 = 9.90</code>。</p>
<p>所以，DeepSeek目前还是没办法替代GPT的，不过，国产大模型也很强大了，相信不久的将来是可以超越GPT的！</p>
<h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>以上就是今天的内容了，大家有任何疑问可以打在评论区，一起交流～</p>
<p>关注我发送“MySQL知识图谱”领取完整的MySQL学习路线。</p>
<p>发送“电子书”即可领取价值上千的电子书资源。</p>
<p>部分电子书如图所示。</p>
<p><img src="/../images/bottom1.png" alt="概念学习"></p>
<p><img src="/../images/bottom2.png" alt="概念学习"></p>
<p><img src="/../images/bottom3.png" alt="概念学习"></p>
<p><img src="/../images/bottom4.png" alt="概念学习"></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU15445笔记</title>
    <url>/CMU15445%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h1 id="CMU15445笔记"><a href="#CMU15445笔记" class="headerlink" title="CMU15445笔记"></a>CMU15445笔记</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>数据库就是管理文件的一个程序。将文件管理抽象出来不同的结构，如关系数据库，文档数据库，图数据库等。方便管理，使用，并能进行复杂的操作，如事务等。更加通用使任何语言都可以使用。对于多个进程并发修改一个文件，那么数据库可以提供更好的性能和解决方案。</p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><ul>
<li>关系模型：大多数数据库使用的</li>
<li>键值对模型：NOSql使用的，比如redis</li>
<li>图模型：NOSql使用的</li>
<li>文档模型：NOSql使用的，比如mongoDB</li>
<li>列存储模型</li>
<li>数组，向量模型：向量数据库，如Fassi</li>
<li>分组模型，网络模型，多值模型：已经很少使用的模型</li>
</ul>
<h4 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h4><p>Ted Codd在1969年设计了关系模型。发表了<a href="https://dl.acm.org/doi/pdf/10.1145/362384.362685">A relational model of data for large shared data banks</a></p>
<p>关系模型将物理层和逻辑层分离，当数据的内部表示发生变化时，甚至当外部表示的某些方面发生变化时，用户在终端和大多数应用程序上的活动应该不受影响。</p>
<p>关系模型提供了一种仅用数据的自然结构来描述数据的方法，因此，它为高级数据语言提供了一个基础，这种语言将一方面在程序之间产生最大的独立性，另一方面在机器表示和数据组织之间产生最大的独立性。另一个优点是，它为处理关系的可导出性、冗余性和一致性提供了坚实的基础。</p>
<p>仍然需要消除的三种主要数据依赖是：顺序依赖、索引依赖和访问路径依赖。</p>
<ul>
<li>顺序依赖：程序展示的顺序和文件内容的存储顺序并不一致，需要各自独立。</li>
<li>索引依赖：如果程序使用索引的时候，索引被删除那么程序将出错。</li>
<li>访问路径依赖：访问数据的时候依赖数据的物理结构。</li>
</ul>
<p><code>关系</code>指的是数学意义上的关系，对于给定集合S1,S2,S3…Sn，R是n个集合上的关系，如果它是n个元组的集合，每个元组的第一个元素来自S1,第二个来自S2，以此类推。我们称Sj是R上的第j个定义域。R的阶为n(degree n)，阶为1的时候称为一元关系，2的时候称为二元关系，阶为n称为n元关系。</p>
<p>关键原则：</p>
<ul>
<li>将数据存储在简单的数据结构(关系)中</li>
<li>物理存储留给DBMS实现</li>
<li>通过高级语言访问数据，DBMS确定最佳策略。</li>
</ul>
<p>结构采用关系。确保数据库内容满足完整性约束。程序通过接口来访问和修改数据库内容。</p>
<p>关系是无序的，n元关系就是n个列的表。一个元组是一行记录。</p>
<h2 id="高级SQL"><a href="#高级SQL" class="headerlink" title="高级SQL"></a>高级SQL</h2><p>PostegreSQL:由伯克利大学开发，是之前开发Ingres的人开发的。</p>
<p>IBM的DB2支持SQL,所以SQL成为了标准。</p>
<p>数据库支持SQL,最低要支持SQL-92标准。</p>
<p>下面的sql在postgreSQL中会报错，mysql中如果<code>sql_mode</code>是<code>ansi</code>也会报错，如果<code>sql_mode</code>是<code>traditional</code>就不会报错，而是会随机选一个cid展示出来。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(s.gpa), e.cid <span class="keyword">from</span> enrolled <span class="keyword">as</span> e,student <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">where</span> e.sid <span class="operator">=</span> s.sid;</span><br></pre></td></tr></table></figure>

<h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">大小写</th>
<th align="left">引号</th>
<th align="left">字符串拼接</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SQL-92</td>
<td align="left">敏感的</td>
<td align="left">单引号</td>
<td align="left">||</td>
</tr>
<tr>
<td align="left">PostgreSQL</td>
<td align="left">敏感的</td>
<td align="left">单引号</td>
<td align="left">+</td>
</tr>
<tr>
<td align="left">mysql</td>
<td align="left">不敏感的</td>
<td align="left">单引号&#x2F;双引号</td>
<td align="left">concat &#x2F; 空格</td>
</tr>
<tr>
<td align="left">SQLite</td>
<td align="left">敏感的</td>
<td align="left">单引号&#x2F;双引号</td>
<td align="left">+</td>
</tr>
<tr>
<td align="left">｜DB2</td>
<td align="left">敏感的</td>
<td align="left">单引号</td>
<td align="left">||</td>
</tr>
<tr>
<td align="left">Oracle</td>
<td align="left">敏感的</td>
<td align="left">单引号</td>
<td align="left">||</td>
</tr>
</tbody></table>
<h3 id="时间日期处理"><a href="#时间日期处理" class="headerlink" title="时间日期处理"></a>时间日期处理</h3><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">当前日期 NOW()</th>
<th align="left">当前日期 CURRENT_TIMESTAMP()</th>
<th align="left">当前日期 CURRENT_TIMESTAMP</th>
<th align="left">日期差值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PostgreSQL</td>
<td align="left">2023-04-26 14:27:01.790522+08</td>
<td align="left">不支持</td>
<td align="left">2023-04-26 14:27:32.280334+08</td>
<td align="left">select DATE(‘2018-08-29’) - DATE(‘2018-01-01’); 结果240</td>
</tr>
<tr>
<td align="left">mysql</td>
<td align="left">2023-04-26 14:28:36</td>
<td align="left">2023-04-26 14:28:44</td>
<td align="left">2023-04-26 14:28:56</td>
<td align="left">select DATEDIFF(DATE(“2018-08-29”),DATE(“2018-01-01”)); 结果240</td>
</tr>
<tr>
<td align="left">SQLite</td>
<td align="left">不支持</td>
<td align="left">不支持</td>
<td align="left">2023-04-26 06:30:47</td>
<td align="left">select CAST((julianday(‘2018-08-29’) - julianday(‘2018-01-01’)) as INT) as days; 结果 240</td>
</tr>
</tbody></table>
<h3 id="复制表数据"><a href="#复制表数据" class="headerlink" title="复制表数据"></a>复制表数据</h3><p>create table会创建表，insert into需要表已经存在。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student2 (</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student2(</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="获取id最大的一个学生数据"><a href="#获取id最大的一个学生数据" class="headerlink" title="获取id最大的一个学生数据"></a>获取id最大的一个学生数据</h3><p>下面的是错误做法，因为不知道id最大的name是谁，会报错，如果sql_mode&#x3D;tranditional，会执行成功，但是name是随机的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">MAX</span>(e.sid),s.name <span class="keyword">from</span> enrolled <span class="keyword">as</span> e,student <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">where</span> e.sid <span class="operator">=</span> s.sid</span><br></pre></td></tr></table></figure>
<p>下面的在postgresql和mysql都可以执行成功，并获取到id最大的name数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sid, name <span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sid <span class="keyword">in</span> (<span class="keyword">select</span> <span class="built_in">max</span>(sid) <span class="keyword">from</span> enrolled)</span><br></pre></td></tr></table></figure>

<p>下面的SQL在postgresql中可以执行成功，结果和上面的一样，而在mysql8中报错<code>This version of MySQL doesn&#39;t yet support &#39;LIMIT &amp; IN/ALL/ANY/SOME subquery&#39;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sid, name <span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sid <span class="keyword">in</span> (<span class="keyword">select</span> sid <span class="keyword">from</span> enrolled <span class="keyword">order</span> <span class="keyword">by</span> sid <span class="keyword">desc</span> limit <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="获取没有学生报名的课程"><a href="#获取没有学生报名的课程" class="headerlink" title="获取没有学生报名的课程"></a>获取没有学生报名的课程</h3><p>下面的sql在postgresql 和 mysql 中都可以得到正确的结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> course </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> enrolled <span class="keyword">where</span> course.cid <span class="operator">=</span> enrolled.cid);</span><br></pre></td></tr></table></figure>

<h3 id="window窗口"><a href="#window窗口" class="headerlink" title="window窗口"></a>window窗口</h3><p><code>ROW_NUMBER</code>和<code>RANK</code>都需要和<code>OVER</code>一起使用。</p>
<ul>
<li>ROW_NUMBER(): 显示当前行号</li>
<li>RANK() : 显示排序后的排名，如果没有排序，都是1</li>
<li>OVER()<ul>
<li>PARTITION BY 进行分组</li>
<li>GROUP BY 进行分组</li>
<li>ORDER BY 排序</li>
</ul>
</li>
</ul>
<p><img src="/../images/15445001.png" alt="001"></p>
<p><img src="/../images/15445002.png" alt="002"></p>
<p><img src="/../images/15445003.png" alt="003"></p>
<h4 id="获取每个课程中分数最高的学生信息"><a href="#获取每个课程中分数最高的学生信息" class="headerlink" title="获取每个课程中分数最高的学生信息"></a>获取每个课程中分数最高的学生信息</h4><p>下面的SQL，在postgresql中执行成功，mysql8执行报错。</p>
<p>首先查询所有课程信息，并按照课程分组，按照分数排序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line"><span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cid <span class="keyword">ORDER</span> <span class="keyword">BY</span> grade <span class="keyword">ASC</span>)</span><br><span class="line"><span class="keyword">AS</span> rank <span class="keyword">FROM</span> enrolled</span><br></pre></td></tr></table></figure>

<p><img src="/../images/15445004.png" alt="004"></p>
<p>接着搜索上表中分数为1，也就是分数最高的学生。也就是每个课分数最高的学生信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line">    <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cid</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> grade <span class="keyword">ASC</span>)</span><br><span class="line">    <span class="keyword">AS</span> rank <span class="keyword">FROM</span> enrolled) <span class="keyword">AS</span> ranking</span><br><span class="line"><span class="keyword">WHERE</span> ranking.rank <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="/../images/15445005.png" alt="005"></p>
<h3 id="CTE-common-table-expressions"><a href="#CTE-common-table-expressions" class="headerlink" title="CTE(common table expressions)"></a>CTE(common table expressions)</h3><p>使用<code>CTE</code>实现获取每个课程中分数最高的学生信息。</p>
<p>通过<code>WITH</code>语句来声明一个临时表。表名<code>cteSource</code>，表的内容就是最的sid，通过<code>SELECT MAX(sid) FROM enrolled</code>查询出来的结果。字段名叫<code>maxId</code>。</p>
<p>然后在查询语句里面就可以连接<code>cteSource</code>表，然后通过sid &#x3D; cteSource.maxId 来获取到sid最大的用户信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> cteSource (maxId) <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(sid) <span class="keyword">FROM</span> enrolled</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> student, cteSource</span><br><span class="line"><span class="keyword">WHERE</span> student.sid <span class="operator">=</span> cteSource.maxId</span><br></pre></td></tr></table></figure>

<p>还有一些其他的用法，比如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> cte1 (col1) <span class="keyword">AS</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span></span><br><span class="line">),</span><br><span class="line">cte2 (col2) <span class="keyword">AS</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> cte1, cte2;</span><br></pre></td></tr></table></figure>

<h3 id="lateral-join"><a href="#lateral-join" class="headerlink" title="lateral join"></a>lateral join</h3><p>mysql目前还不支持该功能，postgreSQL和Sqlserver等支持。</p>
<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>页的三个概念</p>
<ol>
<li>硬件上的页面(通常是4KB)</li>
<li>操作系统上的页面(4KB,x64 2MB&#x2F;1GB)</li>
<li>数据库页面(512B-32KB)</li>
</ol>
<p>磁盘和内存通信是一页一页的，如果数据都在一页里，后续的访问请求就可以走内存了，要不然还的从磁盘获取。内存中可以获取bit数据。</p>
<p>系统设计目标：给应用程序一个错觉，能提供足够的内存将整个数据库存入内存中。<br>实现：谨慎的最小化每次从磁盘读取内容或运行查询时所带来的影响。<br>流程：</p>
<ul>
<li>查询执行器：向内存中的<code>buffer pool</code>请求查询内容。</li>
<li>buffer pool: 如果数据所在的页已经在buffer pool中，就直接返回。如果数据所在的页不在buffer pool中，就向磁盘中的<code>database file</code>请求。</li>
<li>database file: 有页目录，还有具体的页，数据存在页中，查询页目录找到对应的页返回给<code>buffer pool</code>。</li>
</ul>
<p><img src="/../images/15445006.png" alt="006"></p>
<p>上面的步骤操作系统本身就可以实现，比如使用<code>mmap</code>，但是操作系统是统一的动作，遇到一些问题不知道该如何处理，而DBMS则可以根据不同的情况做不同的处理，进行优化。像主流的<code>mysql</code>,<code>SqlServer</code>,<code>Oracle</code>都没有用<code>mmap</code>。<code>mongoDB</code>早期使用的<code>mmap</code>，后面也是用<code>WiredTiger</code>替换掉了<code>mmap</code>。</p>
<p>DBMS自己实现的话，主要关心的两个问题:</p>
<ol>
<li>如何表示磁盘上文件的数据</li>
<li>如何管理内存以及在硬盘间移动数据</li>
</ol>
<h3 id="如何表示磁盘上文件的数据"><a href="#如何表示磁盘上文件的数据" class="headerlink" title="如何表示磁盘上文件的数据"></a>如何表示磁盘上文件的数据</h3><p>数据库的数据最终以文件的形式放在磁盘中。通过文件读写将数据读写到文件中。文件有特定的格式，具体的内容有数据库进行解析然后展示在数据库中。这就是<code>storage manager</code> or <code>storage engine</code>。</p>
<p><code>storage manager</code>负责文件的读写工作。所有的文件（不管是一个或者多个）以 <code>page</code> 的形式存储，管理多个 <code>page</code> 组成的集合。</p>
<p>一个<code>page</code>就是一个固定大小的数据块。<code>page</code> 可以保存任何东西，<code>tupe</code>, <code>metadata</code>, <code>indexes</code>, <code>log</code>等等。每个<code>page</code>有唯一的ID,是<code>page ID</code>。</p>
<p>有些<code>page</code>要求是独立的，自包含的(self-contained)。比如<code>mysql的InnoDB</code>。因为这样的话一个表的元数据和本身的数据内容在一起，如果发生问题的话，可以找回元数据和数据。如果元数据和数据在不同的<code>page</code>中，如果发生问题导致元数据的<code>page</code>丢失，那么数据则恢复不了了。</p>
<p><code>indirection layer</code>记录page ID的相对位置，方便找到对应的偏移量。这样page目录就能找到对应的page。 </p>
<p>不同的DBMS对于文件在磁盘上的存储方式不一样，有下面几种</p>
<ul>
<li>堆存储</li>
<li>树存储</li>
<li>有序文件存储（ISAM）</li>
<li>hashing文件存储</li>
</ul>
<p>堆存储</p>
<ul>
<li>无序的，保存的顺序和存储的顺序无关。</li>
<li>需要读写page</li>
<li>遍历所有的page</li>
<li>需要元数据记录哪些是空闲的page,哪些是已经使用的page。</li>
<li>使用 <code>page directory</code> 方式来记录文件位置。</li>
</ul>
<p>page directory</p>
<ul>
<li>存储page ID和所在位置的关系</li>
<li>存储page的空闲空间信息</li>
</ul>
<p><img src="/../images/15445010.png" alt="010"></p>
<p>page header</p>
<ul>
<li>page 大小</li>
<li>checksum 校验和</li>
<li>DBMS版本信息</li>
<li>事务可见性</li>
<li>压缩信息</li>
</ul>
<h4 id="page-layout"><a href="#page-layout" class="headerlink" title="page layout"></a>page layout</h4><h5 id="tuple-oriented-storage"><a href="#tuple-oriented-storage" class="headerlink" title="tuple oriented storage"></a>tuple oriented storage</h5><p>一般想法，直接存储，并在后面追加，但是对于可变数据长度很难管理。</p>
<ul>
<li>记录page数，也就是page内部可插入的偏移量</li>
<li>一个一个tupe按照顺序存储</li>
</ul>
<p><img src="/../images/15445007.png" alt="007"></p>
<p>所以，page内部，通常不使用上面那种，而使用的是slotted pages</p>
<ul>
<li>slotted pages<ul>
<li>slot array 存储插槽信息的偏移量，通过他找到对应的tuple</li>
<li>支持可变长度的 tuple</li>
<li>但是会产生一些碎片空间，因为太小，tuple放不下。</li>
<li>压缩可以去除碎片空间，但是压缩的时候这个page就不能读写了。</li>
</ul>
</li>
</ul>
<p><img src="/../images/15445008.png" alt="008"></p>
<p><code>record ID</code>表示一个tuple的物理位置,不同的DBMS有不同的名称，来表示数据的唯一位置，比如<code>postgresql</code>的<code>ctid</code>,<code>oracle</code>的<code>rowid</code>。<code>ctid</code>由<code>page id</code>和<code>slot number</code>组成。</p>
<p><img src="/../images/15445009.png" alt="009"></p>
<p>插入新的tuple的时候</p>
<ol>
<li>检查page direactory,找到一个page里面有空的可用的slot</li>
<li>如果该page不在内存,就从磁盘上获取它，将它加载到内存</li>
<li>在page里面检查slot array，找到一个空的空间，将tuple插入</li>
</ol>
<p>更新tuple的时候</p>
<ol>
<li>检查page direactory,找到tuple对应的page</li>
<li>如果该page不在内存,就从磁盘上获取它，将它加载到内存</li>
<li>在page里面通过slot array获取tuple的偏移量</li>
<li>如果数据空间合适，那么直接覆盖该tuple，否则，将原来的tuple标记为已删除，并将新tuple插入其他page。</li>
</ol>
<p>因此更新的时候有一些问题</p>
<ul>
<li>page会产生碎片空间</li>
<li>更新的时候需要从磁盘获取整个page</li>
<li>更新多条数据的时候，可能多个tuple在多个page中，产生随机IO</li>
</ul>
<p>所以有些DBMS不能更新数据，只能增加数据，比如HDFS等</p>
<h5 id="Log-Structured-Storage"><a href="#Log-Structured-Storage" class="headerlink" title="Log Structured Storage"></a>Log Structured Storage</h5><p>比如HBase,ClickHouse,RocksDB,LevelDB都是这个方式。 </p>
<p>这种方式的一些问题：</p>
<ul>
<li>Write-Amplification:在该tuple的生命周期里面可能写入无数次磁盘，并一直在那里且不被需要。</li>
<li>Compaction is Expensive：</li>
</ul>
<h5 id="Index-Organized-Storage"><a href="#Index-Organized-Storage" class="headerlink" title="Index Organized Storage"></a>Index Organized Storage</h5><p>tuple</p>
<ul>
<li>header</li>
<li>列1</li>
<li>列2</li>
<li>列n</li>
</ul>
<h4 id="tupe-layout"><a href="#tupe-layout" class="headerlink" title="tupe layout"></a>tupe layout</h4><p>tuple就是一堆bit，DBMS解释他们的作用。里面包含</p>
<ul>
<li>header</li>
<li>data</li>
</ul>
<h5 id="data-layout"><a href="#data-layout" class="headerlink" title="data layout"></a>data layout</h5><p>table foo</p>
<ul>
<li>id int primary key</li>
<li>value bigint</li>
</ul>
<p><img src="/../images/15445011.png" alt="011"></p>
<h5 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h5><p>现代CPU是64位对齐，创建表以后，DBMS会自动的将数据进行对齐存储，不过，如果在创建表的时候考虑对齐，可以优化速度和存储空间。</p>
<p><img src="/../images/15445012.png" alt="012"></p>
<h5 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h5><p>可变长度的数据<code>varchar</code>,<code>varbinary</code>,<code>text</code>,<code>blob</code>,他们的长度存在header里面。</p>
<p>日期时间类型存储的是时间戳。</p>
<p>float&#x2F;real&#x2F;double: 是浮点数，cpu支持浮点数运算，优点是速度快，但是会精度缺失<br>decimal: 是定点数，运算速度慢，但是精度高。</p>
<p><img src="/../images/15445013.png" alt="013"></p>
<p>large values，应该避免这样，因为维护overflow page很麻烦。</p>
<ul>
<li>tuple中存储另外一个page页的指针，将具体数据存放到另外一个page页中。</li>
<li>postgresql中叫<code>toast</code>，如果数据大于2KB，就会放到toast中，tuple中只存储指针。</li>
<li>mysql中叫<code>overflow page</code>，如果数据大于1&#x2F;2的page大小，就会放进去，tuple中只存储指针。</li>
</ul>
<p>外部存储</p>
<ul>
<li>tuple中存储指向外部文件的指针或者文件地址。</li>
</ul>
<p>NULL存储</p>
<ul>
<li>行数据库通常是在Header里面增加bit map来判断是否是null</li>
<li>列数据库通常使用占位符来标识NULL</li>
<li>在每个属性前面增加bit来标识是否是NULL，这么做会破坏对齐，或增加存储空间，MySQL曾使用这个方法，后来抛弃了这个方法。</li>
<li>NULL &#x3D;&#x3D; NULL 是 NULL, NULL is NULL 是 true</li>
</ul>
<p>catalogs 用来存储数据库元信息，大多数数据库将这些信息存到一张表里面</p>
<ul>
<li>表，字段，索引，视图等</li>
<li>用户，权限，安全等</li>
<li>内部数据统计等</li>
<li>infomation schemal api 通过这个来获取catalogs信息<ul>
<li>mysql<ul>
<li>show tables 获取所有的表</li>
<li>describe table_name 获取表的信息</li>
</ul>
</li>
<li>postgresql<ul>
<li>\d or \d+ 获取所有的表</li>
<li>\d table_name 获取表信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="DATABASE-WORKLOADS"><a href="#DATABASE-WORKLOADS" class="headerlink" title="DATABASE WORKLOADS"></a>DATABASE WORKLOADS</h3><p>OLTP</p>
<ul>
<li>通常是业务侧使用的传统数据库，比如oracle,postgresql,mysql</li>
<li>小的业务多次执行，比如多个简单的插入，更新，查询</li>
</ul>
<p>OLAP</p>
<ul>
<li>通常是大数据，数据分析来使用，比如Hbase等，支持复杂的数据查询</li>
<li>OLAP位于OLTP的后方</li>
</ul>
<p>HTAP</p>
<ul>
<li>OLTP和OLAP的混合，两个都可以做</li>
</ul>
<p><img src="/../images/15445014.png" alt="014"></p>
<p>N-ary 模型</p>
<ul>
<li>行存储模型</li>
<li>page里面是按行存储的，每个tuple就是一行</li>
</ul>
<p>优点</p>
<ul>
<li>快速的insert,update,delete</li>
<li>查找的优势是数据都在一起</li>
<li>能在集群中使用 <code>index-oriented</code>物理存储方式</li>
</ul>
<p>缺点</p>
<ul>
<li>不适合扫描table中大部分<code>and/or</code>属性的子集</li>
<li>访问的内存局部性糟糕，查找数据的弊端是会加载一个page的时候会加载不需要的行数据</li>
<li>不适合压缩，因为一个page里面有不同的<code>value domains</code></li>
</ul>
<p>Decomposition 模型</p>
<ul>
<li>列存储模型</li>
<li>一个page里面是一列数据</li>
</ul>
<p>优点</p>
<ul>
<li>优势是查找的时候不会加载不需要的数据</li>
<li>更快的查询过程，因为有更好的局部性和<code>cached data</code>重用</li>
<li>更好的数据压缩</li>
</ul>
<p>缺点</p>
<ul>
<li>劣势是查找的数据不在一起，需要去各个page里面找。所以insert update delete也更慢。</li>
</ul>
<p>列存储查询的时候处理where子句以后需要找到对应的其他列在其他page中的位置，有两个方法，通常使用第一个方法，第二个方法并不好</p>
<ul>
<li>固定长度：每个page中的每个列的长度都固定，顺序也一样，这样通过where子句对应列的偏移量，就可以确定其余列的偏移量</li>
<li>内嵌tuple id: 每个值里面都加入对应的tuple id，根据tuple id查询其他列</li>
</ul>
<p>Partition Attributes Across(PAX) Storage 模型</p>
<ul>
<li>将行存储和列存储混合的模型</li>
<li>目标是保留列存储的快速处理和行存储的空间局部性优势（这里空间局部性优势指访问的数据在一起）</li>
<li>比如<a href="https://orc.apache.org/">Apache ORC</a>,<a href="https://arrow.apache.org/">Apache Arrow</a>, <a href="https://parquet.apache.org/">Apache Parquet</a>.</li>
</ul>
<p>PAX 物理数据组织</p>
<ul>
<li>水平划分为<code>row groups</code>，即一些行数据的集合</li>
<li>在<code>row groups</code>里面垂直划分为<code>column chunks</code>，即列的集合，也就是列存储方式</li>
<li>每个<code>column chunks</code>下面可能还会有page</li>
</ul>
<p><img src="/../images/15445015.png" alt="015"></p>
<h3 id="数据库压缩"><a href="#数据库压缩" class="headerlink" title="数据库压缩"></a>数据库压缩</h3><p>目标1：必须产生固定长度的值<br>目标2：在查询期间尽可能推迟解压缩，你不希望先解压缩在查询，这样很占空间且影响速度<br>目标3：必须是无损方案</p>
<p>压缩粒度</p>
<ul>
<li>Block-level: 压缩同一张表的tuple</li>
<li>Tuple-level: 压缩整个tuple的内容（仅限行存储）</li>
<li>Attribute-level：压缩同一个tuple的多个属性或单个属性</li>
<li>Column-level：压缩存储于多个tuple中的一个或多个属性的多个值（仅限列存储）</li>
</ul>
<h4 id="mysql-innodb-压缩"><a href="#mysql-innodb-压缩" class="headerlink" title="mysql innodb 压缩"></a>mysql innodb 压缩</h4><p>innodb 在写入的时候可以不解压，但是读取的时候会先在buffer pool中解压在读取。因此Mysql innodb的压缩的好处是提升空间利用率，减少了磁盘IO,缺点是读取的时候需要解压，因此增加了这部分的时间和CPU功耗以及解压以后会占用更多的内存空间。<br>innodb 默认page 是 16KB,可以压缩到1&#x2F;2&#x2F;4&#x2F;8KB。</p>
<p><img src="/../images/15445016.png" alt="016"></p>
<h4 id="Column-level-压缩算法"><a href="#Column-level-压缩算法" class="headerlink" title="Column-level 压缩算法"></a>Column-level 压缩算法</h4><h5 id="run-length-encoding"><a href="#run-length-encoding" class="headerlink" title="run length encoding"></a>run length encoding</h5><p>将单个column中的相同值压缩成三元组，需要对列进行智能排序，以最大限度地提高压缩机会。</p>
<ul>
<li>属性的值</li>
<li>column segment的起始位置</li>
<li>值的数量</li>
</ul>
<p>比如下面的数据，将压缩成右边的数据，(Y,0,3)，代表值是Y，起始位置0,值的数量有3个。后面的压缩数据是一样的。这种压缩方法可以快速计算count的数量等。</p>
<p>如果你的值类型很少，且有序，那么将大大减少空间占用。</p>
<p><img src="/../images/15445017.png" alt="017"></p>
<h5 id="bit-packing"><a href="#bit-packing" class="headerlink" title="bit packing"></a>bit packing</h5><p>如果字段里面的值都比较小，但是column type很大，可以忽略掉不需要的bit，比如int是32 bit，但是里面的值都很小，用不了这么多，就可以忽略他们。</p>
<p><img src="/../images/15445018.png" alt="018"></p>
<h5 id="bit-map-encoding"><a href="#bit-map-encoding" class="headerlink" title="bit map encoding"></a>bit map encoding</h5><p>使用bit map来标识数据值，仅仅适用于值的类型比较少的。</p>
<p><img src="/../images/15445019.png" alt="019"></p>
<h5 id="delta-encoding"><a href="#delta-encoding" class="headerlink" title="delta encoding"></a>delta encoding</h5><p>找到一个基本的数据，以它为基础，进行压缩，+1，-1这种。再将其按照<code>run length encoding</code>的方式压缩，可以再次节省空间。</p>
<p><img src="/../images/15445020.png" alt="020"></p>
<h5 id="DICTIONARY-COMPRESSION"><a href="#DICTIONARY-COMPRESSION" class="headerlink" title="DICTIONARY COMPRESSION"></a>DICTIONARY COMPRESSION</h5><p>按照字典将数据进行映射，并存储，这样可以节省空间，如果在字典映射的时候还能先排序，那么还可以完成将<code>where like &#39;and%&#39;</code>转成<code>where between 10 and 20</code>。</p>
<p><img src="/../images/15445021.png" alt="021"></p>
<h2 id="buffer-pool-和内存管理"><a href="#buffer-pool-和内存管理" class="headerlink" title="buffer pool 和内存管理"></a>buffer pool 和内存管理</h2><p>时间管理</p>
<ul>
<li>将数据写入磁盘的何处</li>
<li>目标是经常被一起使用的pages放在磁盘中也是一起的地方。</li>
</ul>
<p>空间管理</p>
<ul>
<li>何时将pages读入内存，何时将pages写入磁盘</li>
<li>目标是最小化的解决必须从磁盘读取数据这个事</li>
</ul>
<p>frame</p>
<ul>
<li>buffer pool中的一块内存区域</li>
<li>相当于page里面的slot</li>
</ul>
<p>page table</p>
<ul>
<li>记录pages在当前buffer pool中的位置,通过page table 和 page id可以知道在哪个frame中。</li>
</ul>
<p><img src="/../images/15445022.png" alt="022"></p>
<p>page 里面记录一些元数据</p>
<ul>
<li>dirty flag: 记录是否被修改过，也就是常说的”脏数据标记”</li>
<li>引用计数器： 记录有多少线程在使用这个数据</li>
<li>访问追踪信息</li>
</ul>
<p>lock and latch</p>
<ul>
<li>lock在数据库中指high-level的东西，可以保护数据库，数据表，数据。保护数据库内容不受其他事务影响，在事务持续期间保持，可以回滚。</li>
<li>latch保护内部的东西，数据结构，内存区域。保护内部数据结构不受其他线程的影响，在操作期间保持，不需要可以回滚。</li>
</ul>
<p>buffer pool 使用 mmap的问题：</p>
<ul>
<li>事务安全：操作系统完全控制page的写入，刷新，有可能在一个事务没有完成的时候有些数据就已经写入磁盘了。</li>
<li>IO停顿：DBMS不知道哪些page在内存中，当读取不在内存中的时候触发page fault，操作系统才会从磁盘获取。</li>
<li>错误处理：任何访问都可能触发操作系统的中断信号<code>SIGBUS</code>，而整个DBMS都需要处理它。</li>
<li>性能问题</li>
</ul>
<p>全局策略</p>
<ul>
<li>针对所有的查询或者事务的策略</li>
</ul>
<p>局部策略</p>
<ul>
<li>针对单个查询或者事务的策略</li>
<li>可以对单个优化，虽然对全局可能不好</li>
</ul>
<h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><p>淘汰策略有几种算法</p>
<ul>
<li>LRU</li>
<li>Clock：Linux使用的，把所有的page放成一个圈，每个page有一个标志位，如果为0表示没有被使用过，1被使用过，淘汰的时候淘汰0的，再把1改成0.</li>
<li>LRUK：记录使用的次数k，达到次数才放到缓存里面，淘汰的时候比对两次的时间间隔，间隔长的认为是最近最少使用</li>
<li>PRIORITY HINTS</li>
</ul>
<h4 id="mysql-近似-LRU-k"><a href="#mysql-近似-LRU-k" class="headerlink" title="mysql 近似 LRU-k"></a>mysql 近似 LRU-k</h4><p>相当于K&#x3D;2。有一个LRU List，但是有两个指针，分别表示<code>old list</code>和<code>young list</code>。当数据第一次被访问的时候放到<code>old list</code>中，再次被访问的时候放到<code>young list</code>中。</p>
<p><img src="/../images/15445023.png" alt="023"></p>
<p>当访问 page1 的时候，需要淘汰掉<code>old list</code>中的page8，其实也是整个LRU中的最后一个元素。然后将page1插入<code>old list</code>。</p>
<p><img src="/../images/15445024.png" alt="024"></p>
<p>当再次访问 page1 的时候，将page1 插入<code>young list</code>。这个时候<code>young list</code>最后的元素也就进入了<code>old list</code>.</p>
<p><img src="/../images/15445025.png" alt="025"></p>
<h4 id="PRIORITY-HINTS"><a href="#PRIORITY-HINTS" class="headerlink" title="PRIORITY HINTS"></a>PRIORITY HINTS</h4><p>比如B+树的根节点具有最高的优先级，所以一直放在内存中。</p>
<p><img src="/../images/15445026.png" alt="026"></p>
<p>多buffer pool</p>
<ul>
<li>通过使用多个buffer pool可以根据不同的table放入不同的buffer pool进行不同的优化。也可以通过其他的策略使用多个buffer pool</li>
<li>由于有多个buffer pool,减少了锁争抢和锁等待的时间。</li>
<li>mysql中通过hash确定数据是否在buffer pool，然后通过取余确定在哪个buffer pool</li>
</ul>
<p>预取数据</p>
<ul>
<li>顺序扫描的时候预先把后面的page取到buffer pool中。这一步mmap也可以实现</li>
<li>索引扫描的时候预先把索引中需要用到的后面的page取到buffer pool中。这一步mmap实现不了，这也是数据库自己实现buffer pool的优势。</li>
</ul>
<p>扫描共享</p>
<ul>
<li>共享扫描到的page内容</li>
<li>如果查询1需要扫描page1,page2,page3,page4的内容并且已经扫描到了page3,这个时候page1已经扫描完了被从buffer pool中丢弃了</li>
<li>这时候有一个查询2也需要扫描所有的pages，如果从page1开始扫描，就会把page1再次读入buffer pool，但是这样是低效率的，所以可以先共享查询1的page数据，先扫描page3,然后page4，这时候查询1执行完毕，在回头扫描page1,page2。</li>
<li>mysql不支持</li>
</ul>
<p>buffer pool bypass</p>
<ul>
<li>单独开辟一个本地内存区域来用，而不是使用buffer pool</li>
<li>可以避免操作page table带来的开销（latch锁住的开销）</li>
<li>可以避免污染buffer pool</li>
<li>适合数据量不大的情况</li>
<li>mysql5.7不支持</li>
</ul>
<p>os page cache</p>
<ul>
<li>操作系统的文件缓存，当使用fopen,fread,fwrite的时候会先从操作系统缓存中读取文件内容。</li>
<li>只有postgresql使用了这个。</li>
<li>通过 direct IO可以不使用这个</li>
<li>使用它会导致有两个缓存，buffer pool 和 os page cache。不好控制。</li>
<li>fsync如果失败以后再次调用也不会生效，因为它会将dirty设置为false</li>
</ul>
<p>两种写出方案需要做权衡，取舍</p>
<ul>
<li>如果写出dirty flag的数据然后读取新数据，就会产生2次IO。通常会有一个定时任务线程去将dirty flag的数据写入磁盘，写入之前必须要先将操作日志写入磁盘。</li>
<li>如果直接读取新数据就只有1次IO，但是这样有可能把下次会用到的数据丢弃。</li>
</ul>
<h2 id="hash-table"><a href="#hash-table" class="headerlink" title="hash table"></a>hash table</h2><p>hash function</p>
<ul>
<li>最快的是facebook 的 xxhash</li>
</ul>
<p>hash schema</p>
<ul>
<li>liner probe hashing<ul>
<li>如果要插入的位置有值了，就往下扫描，扫描到空的位置插入</li>
<li>删除的时候可以增加一个<code>墓碑</code>标记，这样就知道这里是有数据的不是空，查找的时候就会继续往下扫描而不会是没找到</li>
<li>删除的时候还可以把后面的数据往前移动，但是这样有的数据就不再原来的位置了，就找不到了。因为只会往下扫描不会往上扫描</li>
</ul>
</li>
<li>robin hood hashing<ul>
<li>记录<code>距离数</code>，表示插入的位置和应该插入的位置的距离。从0开始。</li>
<li>插入的时候判断距离数，进行<code>劫富济贫</code>，如果你向下扫描到距离数为3的地方插入，而在距离数为2的地方的数据x，x的距离数比你小，比如是0，1.那么你就占据这里，你插入距离数为2的地方，而将x插入你下面，x的距离数会+1.</li>
<li>从整体来看，这个方法牺牲了插入的效率，将数据的距离数变得更加平均</li>
</ul>
</li>
<li>cuckoo hashing<ul>
<li>该方法使用两个或多个<code>hash table</code>来记录数据，对A进行两次hash，得出两个hash table中的插入位置，随机选择一个进行插入</li>
<li>如果选择的插入位置已经有数据了，就选择另一个插入</li>
<li>如果两个都有数据了，就占据一个，然后对这个位置上之前的数据B再次hash选择其余位置。</li>
</ul>
</li>
</ul>
<p>动态hash table</p>
<ul>
<li>chained hashing<ul>
<li>把所有相同hash的组成一个bucket链表，然后一直往后面增加</li>
<li>java的hash table默认就是这样的</li>
</ul>
</li>
<li>extendible hashing<ul>
<li>对 chained hashing 的扩展</li>
<li>有一个slot array，在slot array上有一个 counter, 如果counter &#x3D; 2，代表看hash以后的数字的前两个bit,slot array就有4个位置，分别是00,01,10,11</li>
<li>每个slot指向一个bucket</li>
<li>hash以后找到前两位对应的slot指向的bucket，将数据放进去，如果满了，放不下了就进行拆分</li>
<li>将slot array的counter扩容为3，看前3个bit，slot array变成了8个位置</li>
<li>只将这个满了的bucket拆分成2个，其余的不变，重新进行slot的映射</li>
<li>再次hash这个值，看前3个bit找到对应的slot,在找到对应的bucket，然后插入进去</li>
</ul>
</li>
<li>linear hashing<ul>
<li>对 extendible hashing 的扩展</li>
<li>去掉了 conter，因为他每次加1，都会扩容一倍</li>
<li>增加了<code>split point</code>，一开始指向0，然后每次<code>overflow</code>需要拆分的时候就拆分split point指向的那个bucket，然后slot array只扩容一个，这个时候出现第二个hash函数并将split point+1</li>
<li>查询的时候如果slot array的位置小于split point，就使用第二个hash函数，因为被拆分了</li>
<li>如果大于等于split point，就使用第一个hash函数</li>
</ul>
</li>
</ul>
<h2 id="tree-index"><a href="#tree-index" class="headerlink" title="tree index"></a>tree index</h2><ul>
<li>b tree(1971)</li>
<li>b+ tree (1973)</li>
<li>b* tree (1977)</li>
<li>b link tree (1981)</li>
</ul>
<p>b+ tree 删除和插入的复杂度都是<code>O(log n)</code>， b 是 <code>balance (平衡)</code>，paper: <code>the ubiquitous B-tree</code></p>
<p>B+ tree,保证每个节点都必须是半满的，对于存放在节点中的key数量来说，key数量至少为<code>M/2 - 1</code>个，M为树的高度，key的数量必须小于 <code>M - 1</code>,如果当删除数据以后导致key数量小于M&#x2F;2 - 1个，就会进行平衡，使他满足M&#x2F;2 - 1个。</p>
<blockquote>
<p>M&#x2F;2 - 1 ≤ key数量 ≤ M - 1</p>
</blockquote>
<p>如果一个中间节点有k个key,那你就会有k+1个非空孩子节点，也就是k+1个指向下方节点的指针。每个节点的内容是一个<code>指针</code>和一个<code>key</code></p>
<p>叶子节点之间有连接叶子节点的兄弟指针，这个想法来源于b link tree。每个节点的内容是一个<code>数据</code>和一个<code>key</code>，数据可以是一个<code>record id</code> 也可以是一个 <code>tuple</code></p>
<p>叶子节点的内容，通常key和value是分开存储的，因为搜索的时候并不需要加载value数据</p>
<ul>
<li>元数据<ul>
<li>isleaf 是否是叶子节点</li>
<li>slots 有多少空闲的slot</li>
<li>prev 前一个叶子节点的指针</li>
<li>next 后一个叶子节点的指针</li>
</ul>
</li>
<li>key数据</li>
<li>value数据</li>
</ul>
<p>b tree 和 b+ tree 的区别</p>
<ul>
<li>b tree的中间节点也可以存数据，所以key是不重复的</li>
<li>b+ tree的中间节点没有数据，所有数据都在叶子节点，所以key有可能既存在中间节点也存在叶子节点。会重复</li>
<li>b tree的性能在并行处理上更差，因为修改以后需要向上传播也需要向下传播修改，这个时候两边都要增加<code>latch</code></li>
<li>b+ tree的性能更好，因为只修改叶子节点，所以只需要向上传播，只需要增加一个<code>latch</code></li>
</ul>
<p>b+ tree 插入</p>
<ol>
<li>向下扫描，找到对应的叶子节点</li>
<li>如果可以插入就直接插入</li>
<li>如果不可以插入，那么从中间分开，变成两个叶子节点，并将中间的key传递给父节点，插入父节点。</li>
<li>如果父节点可以插入就直接插入并分出一个指针指向新的叶子节点</li>
<li>如果父节点不可以插入重复上述操作3</li>
</ol>
<p>b+ tree 删除</p>
<ol>
<li>向下扫描，找到对应的叶子节点，这个时候就会增加<code>latch</code>，因为不知道需不需要合并，操作以后才会释放</li>
<li>如果可以删除就直接删除</li>
<li>如果删除后导致key数量 &lt; <code>M/2 - 1</code>,那么就会出发合并，因为不满足key数量啦</li>
<li>进行合并的时候删除这个key，然后先查看左右的兄弟节点，是否能直接把数据插入过来，如果可以的话就掠夺一个key过来，然后向上传播</li>
<li>如果不能掠夺，那么就合并到兄弟节点，然后向上传播。</li>
</ol>
<p>b+ tree 标准填充容量大概是67% - 69%，对于一个大小是8kb的page来说，如果高度为4，大约能记录30 0000个键值对。</p>
<p>b+ tree的查找</p>
<ul>
<li>对于&lt;a,b,c&gt;,查找a&#x3D;5 and b&#x3D;3也是可以走索引的，但是hash索引就不行，有些数据库还支持b&#x3D;3的搜索走索引，比如oracle和sql server</li>
</ul>
<p>b+ tree的节点大小，机械硬盘的大小最好在1M,ssd的大小在10KB</p>
<blockquote>
<p>推荐书籍 Modern B-Tree Techniques</p>
</blockquote>
<p>对于非唯一索引</p>
<ul>
<li>重复存储，需要注意两个相同的key存储在不同的page中</li>
<li>value list,key只存储一个，然后所有的value存储成value list</li>
</ul>
<p>节点内部的搜索</p>
<ul>
<li>线性搜索</li>
<li>二分搜索</li>
<li>interpolation<ul>
<li>通过数学计算出线性搜索的起点，提升搜索速度</li>
</ul>
</li>
</ul>
<p>优化方法</p>
<ul>
<li>前缀压缩<ul>
<li>比后缀截断用的更多</li>
<li>存储在page中的key,如果前缀一样的可以提取出来存储一次，然后剩余的数据在存储在key里面</li>
</ul>
</li>
<li>后缀截断<ul>
<li>存储在中间节点的，用来寻路的key，可以只存储前面的部分，如果后面的不需要可以截断</li>
<li>更新的时候需要进行维护</li>
</ul>
</li>
<li>批量插入<ul>
<li>如果已经有数据了再建立索引，这个时候不需要从头开始一个个建立，只需要先排序</li>
<li>然后建立所有的叶子节点</li>
<li>在一层层向上建立中间节点</li>
<li>非常普遍的方法，主流数据库都支持</li>
</ul>
</li>
<li>point willizeing<ul>
<li>将节点固定在内存中</li>
<li>对于page来说，直接存储page指针而不是page id，就不需要请求buffer pool了</li>
</ul>
</li>
</ul>
<p>b+ tree的重复key，通常使用增加<code>record id</code>的方式，这种方式影响更小。</p>
<ul>
<li>增加<code>record id</code>,<code>record id</code>是<code>page id</code> + <code>offset</code>用来确定tuple的位置。</li>
<li>垂直扩展叶子节点，将数据存在里面</li>
</ul>
<p>部分索引</p>
<ul>
<li>在创建索引的时候添加where条件，只有符合条件的才会进入索引。</li>
<li>查询的时候只有符合条件的才会走索引</li>
</ul>
<p>覆盖索引</p>
<ul>
<li>在创建索引的时候添加联合索引</li>
<li>查询的时候所需数据都在索引中，就不需要在找对应的tuple信息了。</li>
</ul>
<p>函数索引</p>
<ul>
<li>创建索引的时候添加函数信息，比如 MONTH(date), 只对月份创建索引</li>
<li>查询的时候 MONTH(date) 就会走索引了，而date就不会走索引了</li>
<li>如果创建的时候只创建 date 索引，那么查询的时候 MONTH(date) 就不会走索引</li>
</ul>
<p>trie index(前缀树)</p>
<ul>
<li>把每个单词建立成树，一层放一个字母</li>
</ul>
<p>radix tree</p>
<ul>
<li>trie index的升级版</li>
<li>对于trie index进行了横向的压缩和纵向的压缩</li>
</ul>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>Bloom filter</p>
<p>Counting Bloom filter</p>
<p>Cuckoo filter</p>
<p>Succinct Range Filter</p>
<h2 id="索引并发控制"><a href="#索引并发控制" class="headerlink" title="索引并发控制"></a>索引并发控制</h2><p>并发控制</p>
<ul>
<li>逻辑正确性<ul>
<li>获取id &#x3D; 5的数据，能正确返回id &#x3D; 5的数据</li>
</ul>
</li>
<li>物理正确性<ul>
<li>保护page指针指向正确的page数据，不会触发 segfualt</li>
</ul>
</li>
</ul>
<p>latch 模式</p>
<ul>
<li>读模式<ul>
<li>可以多个线程读取</li>
</ul>
</li>
<li>写模式<ul>
<li>只有一个线程可以写模式，这个时候其他线程不能读取也不能写入</li>
</ul>
</li>
</ul>
<p>latch</p>
<ul>
<li>blocking os mutex<ul>
<li>std::mutex m;</li>
<li>m.lock();</li>
<li>m.unlock();</li>
</ul>
</li>
<li>test and set spin latch<ul>
<li>std::atomic_flag latch</li>
<li>while(latch.test_and_set()){} &#x2F;&#x2F; 如果获取到锁就跳出循环</li>
</ul>
</li>
<li>read - write latch<ul>
<li>读锁，获取的时候线程数队列，等待队列，如果能获取就进入线程数队列，不能就进入等待队列</li>
<li>写锁，线程数队列，等待队列，如果能获取就进入线程队列，不能就进入等待队列</li>
<li>如果有一个写锁在等待队列，这个时候在获取读锁也放入等待队列，要不然一直读，写锁就获取不到了</li>
</ul>
</li>
</ul>
<p>latch crabbing&#x2F;coupling</p>
<ul>
<li>使用栈保存latchs</li>
<li>每个节点都需要一个latch</li>
<li>如果当前节点是<code>安全</code>的，就可以释放上层的所有latchs</li>
<li><code>安全</code>：指操作的时候不会触发<code>拆分</code>和<code>合并</code>。通常read latch都是安全的，write latch 插入的时候如果有足够的空间就是安全的，删除的时候删除以后不会合并就是安全的</li>
</ul>
<p>乐观锁</p>
<ul>
<li>乐观的认为不需要<code>合并</code>和<code>拆分</code>。</li>
<li>所有的操作都先获取read latch,如果发现需要<code>合并</code>和<code>拆分</code>，再次从头获取write latch来一遍</li>
<li>优点是所有操作都是read latch，可以更好的支持并发</li>
<li>缺点是遇到<code>合并</code>和<code>拆分</code>会再来一遍，而且如果连续的插入都需要合并，就会退化成每个都获取write latch。</li>
</ul>
<p>叶子节点扫描</p>
<ul>
<li>叶子节点的扫描可能会触发<code>死锁</code>，比如两个线程</li>
<li>线程1执行读取，读取到了叶子节点1</li>
<li>线程2执行写入，在叶子节点2处获取了write latch</li>
<li>这个时候线程1在叶子节点1里面没有找到数据，所以要扫描叶子节点2，但是获取read latch的时候卡主了，需要等待</li>
<li>而线程2有可能也需要访问叶子节点1，同样等待，产生死锁</li>
<li>这个时候可以设置等待时间，超过等待时间则<code>自杀</code>，然后重头再来，假如线程1自杀，然后再来一遍，这个时候线程2就可以获取到latch，然后执行下去了</li>
</ul>
<p>overflow处理</p>
<ul>
<li>来源于b link tree的优化</li>
<li>当需要拆分的时候，先拆分叶子节点，这个时候不向<code>父结点</code>传播，因为修改父结点需要从头开始获取write latch。</li>
<li>这个时候标记父结点需要插入一个key</li>
<li>等待下一个修改操作到父结点的时候，获取write latch，然后执行这个插入操作。</li>
</ul>
<h2 id="排序和聚合"><a href="#排序和聚合" class="headerlink" title="排序和聚合"></a>排序和聚合</h2><p>排序的好处</p>
<ul>
<li>有序的数据创建索引的时候可以快速的先创建叶子节点，在创建父结点</li>
<li>有序的数据在<code>order by</code>分组的时候可以更快的分组</li>
<li>有序的数据在<code>distinct</code>去重的时候可以更快的去重</li>
</ul>
<p>排序算法</p>
<ul>
<li>在内存中<ul>
<li>可以使用各种算法</li>
<li>但是有的数据内存放不下，就需要在磁盘上排序</li>
<li>需要先知道<code>可以用内存的大小</code>，这样就知道该内存排序还是磁盘排序</li>
</ul>
</li>
<li>在磁盘上<ul>
<li>快排会产生更多的随机IO,会更慢</li>
<li>使用<code>归并排序</code>更好，分成多个<code>runs</code>,对每个run排序，然后在通过<code>二路归并</code>生成总的排序，这可以减少随机IO</li>
<li>外部归并排序，需要3个<code>buffer pool</code>，2个用来排序run，1个用来二路归并。 </li>
<li>次数：1 + log(n)</li>
<li>总的IO数: 2N * (# of passes)</li>
<li>可以通过<code>预取</code>来优化，当对page排序的时候，另外一个线程先取出下次要排序的page。</li>
</ul>
</li>
</ul>
<p>聚簇索引</p>
<ul>
<li>排序的字段如果建立了聚簇索引，就不需要在排序了，直接可以走聚簇索引拿到排序好的数据</li>
</ul>
<h3 id="top-N-heap-sort"><a href="#top-N-heap-sort" class="headerlink" title="top-N heap sort"></a>top-N heap sort</h3><p>比如下面的sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">ASC</span></span><br><span class="line">limit <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>那么首先创建一个大小为2的有序数组或优先级队列之类的。假设我们的数据是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;id:3, name: xxx&#125;, &#123;id:4, name:xxx&#125;, &#123;id:5, name:xxx&#125;, &#123;id:2, name:xxx&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候优先级队列是空的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>然后扫描id为3的数据，放入优先级队列，再扫描id为4的数据，放入优先级队列。这个时候队列数据是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;id:3, name: xxx&#125;, &#123;id:4, name:xxx&#125;</span><br></pre></td></tr></table></figure>

<p>接下来扫描id5的数据，放不进优先级队列，因为id大，最后扫描id2的数据，放入优先级队列，队列就排好序了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;id:2, name:xxx&#125;,&#123;id:3, name: xxx&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/15445027.png" alt="027"></p>
<h3 id="external-merge-sort"><a href="#external-merge-sort" class="headerlink" title="external merge sort"></a>external merge sort</h3><p>当数据太大，无法放在内存中的时候，需要借助外部的文件来进行排序</p>
<ul>
<li>先排序小块的数据，然后写入文件</li>
<li>在将文件的内容合并</li>
</ul>
<p>early materialization</p>
<ul>
<li>将数据放在排序的数据里面，排序以后可以直接返回数据，行数据库一般用这个</li>
</ul>
<p>late materialization</p>
<ul>
<li>排序的数据里存的是tuple id or record id, 排序以后再根据id查询数据返回</li>
</ul>
<p><img src="/../images/15445028.png" alt="028"></p>
<p><img src="/../images/15445029.png" alt="029"></p>
<p>优化方法</p>
<ul>
<li>增加buffer pool在排序中可用的内存，当一个输出page进行写入IO的时候，CPU处理另一个输出page。</li>
<li>多线程，一个线程进行page排序，另外一个线程进行二路归并。</li>
</ul>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>两个实现方法</p>
<ul>
<li>排序</li>
<li>哈希，通常哈希更好，因为都在内存中</li>
</ul>
<blockquote>
<p>group by 和 distinct 本身执行的时候也是需要排序的</p>
</blockquote>
<p>hash</p>
<ol>
<li>分区<ul>
<li>可以顺序扫描每个page</li>
<li>对于每个page的key进行hash，然后分区，hash相同的说明key相同，分到一个区里面</li>
<li>这个时候不管distinct还是group by都可以方便的执行了</li>
</ul>
</li>
<li>重新哈希<ul>
<li>对于分区以后的数据再次进行hash</li>
<li>再次hash的数据放入一个临时的hash table</li>
<li>处理完一个临时的hash table就把结果写入结果集</li>
</ul>
</li>
</ol>
<p>排序的聚合实现，以distinct为例：</p>
<ol>
<li>先执行where条件筛选出符合的<code>tuple</code></li>
<li>再次根据列筛选出符合的列</li>
<li>对于需要排序的列进行排序</li>
<li>顺序扫描排序结果，实现去重，并生成最终结果</li>
</ol>
<p>哈希的聚合实现，以distinct为例：</p>
<ol>
<li>先执行where条件筛选出符合的<code>tuple</code></li>
<li>再次根据列筛选出符合的列</li>
<li>对于需要排序的列进行hash，先分区，再重新哈希。</li>
<li>重新哈希的时候生成最终结果。</li>
</ol>
<p>重新哈希的时候</p>
<ul>
<li>avg的话，需要再临时hash table里面存储key的数量和要求平均数的总数。在生成最终结果的时候进行计算平均数</li>
<li>min的话，临时hash table里面存入最小数，生成最终结果直接取</li>
<li>max同上</li>
<li>sum同上</li>
<li>count同上</li>
</ul>
<h2 id="join算法"><a href="#join算法" class="headerlink" title="join算法"></a>join算法</h2><p>join输出：数据</p>
<ul>
<li>在join的时候把两张表的数据全部输出给下一个处理器，这包括了表的所有字段</li>
<li>好处是，接下来的处理不需要再拿其他字段了，所有字段都有了</li>
<li>坏处是，Join的时候数据量很大，因为有所有字段</li>
<li>可以进行优化，在join的时候只获取需要的字段</li>
</ul>
<p>join输出：record id</p>
<ul>
<li>在join的时候，只获取on的字段和record id，然后需要其他字段的时候在通过 record id去获取，这个很适合列存储数据库</li>
<li>第一个使用的是<code>vertica</code>列存储数据库，不过现在已经不用了</li>
</ul>
<p>如何判断两个join算法的好坏？</p>
<ul>
<li>通过IO来计算</li>
<li>假设左表R有M个page,m个tuple</li>
<li>右表S有N个page,n个tuple</li>
</ul>
<p>join算法</p>
<ul>
<li>Nested Loop Join<ul>
<li>simple&#x2F;stupid</li>
<li>block</li>
<li>index</li>
</ul>
</li>
<li>Sort-Merge Join</li>
<li>Hash Join<ul>
<li>simple</li>
<li>GRACE(Externally partitioned)</li>
<li>Hybird</li>
</ul>
</li>
</ul>
<p><img src="/../images/15445030.png" alt="030"></p>
<h3 id="Simple-Nested-Loop-Join"><a href="#Simple-Nested-Loop-Join" class="headerlink" title="Simple Nested Loop Join"></a>Simple Nested Loop Join</h3><ul>
<li>通过两层for循环，然后符合条件的进行输出</li>
<li>IO计算：因为外层循环要读取 M 个 page,循环的tuple 是 m,内存循环要读取N个page，所以内层循环的IO数是 m * N,总的IO：M + (m * N)</li>
<li>假设 M &#x3D; 1000, m &#x3D; 10 0000, N &#x3D; 500, n &#x3D; 40000, 总的IO &#x3D; 1000 + (10 0000 * 500) &#x3D; 5000 1000</li>
<li>假设 SSD 执行速度 0.1ms 一次IO，大概需要1.3个小时</li>
<li>如果N是左表，那么总IO &#x3D; 500 + (4000 * 1000) &#x3D; 400 0500,大概需要1.1个小时</li>
<li>所以如果左表是小表，性能更好</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Tuple r: R) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Tuple s: S) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.id == r.id) &#123;</span><br><span class="line">            <span class="comment">// 输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested Loop Join"></a>Block Nested Loop Join</h3><ul>
<li>对simple的优化，不在循环tuple，而是循环page，将page打包成block，然后循环block</li>
<li>这样的话对于内层循环来说IO就是 M * N，总的IO就是 M + (M * N)</li>
<li>假设 M &#x3D; 1000, m &#x3D; 10 0000, N &#x3D; 500, n &#x3D; 40000, 总的IO &#x3D; 1000 + (1000 * 500) &#x3D; 50 1000</li>
<li>假设 SSD 执行速度 0.1ms 一次IO，大概需要50s</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个看上去循环多了，不过因为预先读取了两个block才循环，所以循环是在内存中，IO次数少了</span></span><br><span class="line"><span class="keyword">for</span> (Block br: R) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Block bs: S) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Tuple r: br) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Tuple s: bs) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.id == r.id) &#123;</span><br><span class="line">                    <span class="comment">// 输出</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Block-Nested-Loop-Join优化"><a href="#Block-Nested-Loop-Join优化" class="headerlink" title="Block Nested Loop Join优化"></a>Block Nested Loop Join优化</h4><ul>
<li>假设buffer pool容量是B,可以先获取B - 2个左表的Block,剩下2个位置，一个是获取右表的 Block 的，一个是输出的。</li>
<li>这样的话总的IO次数：M + ([M&#x2F;(B-2)] * N), M&#x2F;(B - 2)向上取整</li>
<li>最好的情况是 B &gt; M + 2，代表一次性能获取所有的左表的Block</li>
<li>这样总的IO就变成 M + N</li>
<li>假设 M &#x3D; 1000, m &#x3D; 10 0000, N &#x3D; 500, n &#x3D; 40000, 总的IO &#x3D; 1000  + 500 &#x3D; 1500</li>
<li>假设 SSD 执行速度 0.1ms 一次IO，大概需要0.15s</li>
</ul>
<h3 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested Loop Join"></a>Index Nested Loop Join</h3><p>假设s.id有索引，那么就可以根据索引进行匹配，加快速度.</p>
<ul>
<li>总的成本将是<code>M + (m * C)</code> C是索引需要的时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Tuple r: R) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Tuple s: Index(r = s)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.id == r.id) &#123;</span><br><span class="line">            <span class="comment">// 输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Sort-Merge-Join"><a href="#Sort-Merge-Join" class="headerlink" title="Sort Merge Join"></a>Sort Merge Join</h3><ul>
<li>Sort：先对要join的字段进行排序</li>
<li>Merge: 用两个指针进行匹配，如果数据匹配就输出，因为数据已经排序好了，所以只需要扫描一次就行了</li>
<li>这样的话总IO就是 sort io + merge io, merge io &#x3D; M + N, sort io看具体的排序算法</li>
<li>最好的情况是要join的key本身已经是有序的了，那么只需要merge io &#x3D; M + N,比如有索引，比如查询的时候使用了order by</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sort R,S on join <span class="type">keys</span></span><br><span class="line"><span class="variable">cursorR</span> <span class="operator">=</span> RSorted, cursorS = Ssorted;</span><br><span class="line"><span class="keyword">while</span> (cursorR &amp;&amp; cursorS) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cursorR &gt; cursorS) &#123;</span><br><span class="line">        <span class="comment">// 相当于内层循环指向下一个</span></span><br><span class="line">        cursorS++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cursorR &lt; cursorS) &#123;</span><br><span class="line">        <span class="comment">// 相当于外层循环指向下一个</span></span><br><span class="line">        cursorR++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cursorR == cursorS) &#123;</span><br><span class="line">        <span class="comment">// 输出 &amp;&amp; 内层循环指向下一个</span></span><br><span class="line">        cursorS++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hash-Join"><a href="#Hash-Join" class="headerlink" title="Hash Join"></a>Hash Join</h3><ul>
<li>Build: 先对左表要join的key进行hash，构建一个hash table</li>
<li>probe: 在对右表要join的key进行hash, hash相同的会放入同一个 bucket,也就完成了匹配</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Tuple r: R) &#123;</span><br><span class="line">    insert <span class="title function_">hash</span><span class="params">(r)</span> into hash table ht</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Tuple s: S) &#123;</span><br><span class="line">    insert <span class="title function_">hash</span><span class="params">(s)</span> into hash tbale ht</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Hash Join优化</p>
<ul>
<li>可以添加 <code>布隆过滤器</code> 来优化，这样的话在probe阶段，对右表的key， hash以后先查询布隆过滤器，如果false，就不需要在放入hash table去匹配了</li>
<li>如果true在去hash table里面匹配数据完成输出</li>
</ul>
<p>Grace Hash Join</p>
<ul>
<li>在 hash join中，只构建一个hash table来存储左表数据，右表的hash完成直接匹配</li>
<li>Grace hash join中，构建两个hash table，然后进行 nested loop join</li>
<li>总的IO： 3(M + N),大约0.45s</li>
</ul>
<p>hash 几乎总是好的。<br>排序是好的情况有两种</p>
<ul>
<li>non-uniform数据，排序更好</li>
<li>对于需要排序的数据，比如order by,排序更好</li>
</ul>
<p><img src="/../images/15445031.png" alt="031"></p>
<h2 id="query-exec"><a href="#query-exec" class="headerlink" title="query exec"></a>query exec</h2><p>processing Method</p>
<ul>
<li>Iterator Model: 大多数数据库使用的</li>
<li>Materialization Model：Iterator Model的一个特定版本，用在内存型数据库</li>
<li>Vectorized&#x2F; Batch Model：Iterator Model差不多，要传入一大堆东西， 分析型用的多</li>
</ul>
<p>Iterator Model</p>
<ul>
<li>像java的stream， 流的方式执行</li>
<li>先构建执行树，上层的通过<code>next</code>方法调用下层的方法并接收返回值</li>
</ul>
<p><img src="/../images/15445032.png" alt="032"></p>
<p>Materalization Model</p>
<ul>
<li>去掉了<code>next</code>方法，使用了<code>output</code>方法，一次输出所有数据给上层</li>
</ul>
<p><img src="/../images/15445033.png" alt="033"></p>
<p>Vectorized Model</p>
<ul>
<li>使用<code>next</code>方法，但是一次性返回一堆 tuples, 数量取决于 Buffer pool 大小</li>
<li>使用OLAP，大多数的数仓使用这个</li>
</ul>
<p><img src="/../images/15445034.png" alt="034"></p>
<p>Access Method</p>
<ul>
<li>顺序扫描</li>
<li>索引扫描</li>
<li>多索引扫描</li>
</ul>
<p>顺序扫描的优化</p>
<p><img src="/../images/15445035.png" alt="035"></p>
<p>多索引扫描</p>
<ul>
<li>对多个索引同时扫描</li>
<li>将扫描结果取交集或并集等</li>
<li>例如 <a href="https://www.ibm.com/docs/en/dspafz/5.1.0?topic=report-multiple-index-scans">DB2 Multi index scan</a>,<a href="https://www.postgresql.org/message-id/12553.1135634231@sss.pgh.pa.us">PostgreSQL bitmap scan</a>,<a href="https://dev.mysql.com/doc/refman/8.4/en/index-merge-optimization.html">MySQL Index Merge scan</a></li>
</ul>
<p>Zone Maps</p>
<ul>
<li>通过在page上面增加一个元数据，存储min,max,avg,count,sum信息</li>
<li>当查询的时候比如where val &gt; 600,先查询 Zone Maps，如果发现max &lt; 600，那么就不用在扫描这个page了</li>
<li>缺点是插入，更新，删除的时候还需要更新Zone Maps信息，所以适用于 OLAP数据库</li>
</ul>
<p>late materialization</p>
<ul>
<li>已经不需要的字段就不在往上层传了</li>
</ul>
<p>Expression Evaulate</p>
<ul>
<li>先建立where条件的 Expression tree,中间节点是操作符，比如<code>=</code>,<code>&gt;</code>,<code>&lt;</code>,<code>and</code>,<code>or</code>等。子节点是两边的值</li>
<li>对于每个tuple执行这个表达式</li>
<li>好的数据库会对表达式进行优化，比如优化成常量，像where 1 &#x3D; 1优化成 trues</li>
</ul>
<p>Process Models</p>
<ul>
<li>Process per DBMS Worker</li>
<li>Process Model</li>
<li>Thread per DBMS Worker</li>
<li>Embedded DBMS</li>
</ul>
<p>Process per DBMS Worker</p>
<ul>
<li>每个进程是一个worker,负责执行任务</li>
<li>通过<code>共享内存</code>进行buffer pool的通信，要不然每个进程都会有一个buffer pool。</li>
<li>老得数据库大部分使用的这个，因为当时没有统一的线程API,像DB2,oracle,postgraSQL</li>
</ul>
<p>Process Model</p>
<ul>
<li>和 Process per DBMS Worker一样</li>
<li>但是增加了 worker pool，有多个worker进行调度处理</li>
<li>像DB2,postgraSQL（2015）</li>
</ul>
<p>Thread per DBMS Worker</p>
<ul>
<li>一个进程，多个线程执行，由数据库自己控制线程。</li>
<li>现在的数据库几乎都使用这种，像DB2, MSSQL, MySQL, Oracle(2014)</li>
</ul>
<p>scheduling</p>
<ul>
<li>将查询分解为多少个任务？</li>
<li>它使用多少个CPU核心？</li>
<li>哪个CPU执行哪个任务？</li>
<li>任务输出到哪里？</li>
</ul>
<p>Intra query parallelism</p>
<ul>
<li>Intra operator(水平)</li>
<li>Inter operator(垂直)</li>
<li>Bushy(上面两种的组合)</li>
</ul>
<p>Intra operator(水平)</p>
<ul>
<li>通过水平拆分数据，由多个线程执行，比如3个线程，一个线程处理一个page，以此类推</li>
<li>处理完成以后通过<code>exchange operator</code>来进行合并，拆分也是通过它。</li>
</ul>
<p><img src="/../images/15445036.png" alt="036"></p>
<p>Exchange operator</p>
<ul>
<li>Gather:从多个线程的结果合并成一个输出流，PostgreSQL用这个</li>
<li>Repartition: 重新组织多个输入流到多个输出流的数据，像group by，BigQuery用这个</li>
<li>Distribute: 拆分一个输入流到多个输出流</li>
</ul>
<p><img src="/../images/15445037.png" alt="037"></p>
<p>Inter operator(垂直)</p>
<ul>
<li>重叠的操作从一个阶段到下一个阶段的pipeline数据，没有具体化</li>
<li>workers同时执行多个operators从一个查询计划的不同部分</li>
<li>也需要用到exchange operator</li>
<li>Spark,Kafka常用这个</li>
</ul>
<p><img src="/../images/15445038.png" alt="038"></p>
<p>Bushy</p>
<p><img src="/../images/15445039.png" alt="039"></p>
<h2 id="查询计划"><a href="#查询计划" class="headerlink" title="查询计划"></a>查询计划</h2><p>假设有以下sql，其中Emp表有10000个records, 1000个pages, Dept表有500个records, 50个pages</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> ename <span class="keyword">from</span> Emp E <span class="keyword">join</span> Dept D <span class="keyword">on</span> E.did <span class="operator">=</span> D.did <span class="keyword">where</span> D.dname <span class="operator">=</span> <span class="string">&#x27;Toy&#x27;</span></span><br></pre></td></tr></table></figure>

<p>数据库将构建以下关系代数的树</p>
<p><img src="/../images/15445040.png" alt="040"></p>
<p>按照这个关系代数的树来执行的话，总共需要 2M的IO</p>
<p><img src="/../images/15445041.png" alt="041"></p>
<p>接下来将笛卡尔积的代数换成join的代数，就算使用Nested Loop Join，也能获得54K的IO</p>
<p><img src="/../images/15445042.png" alt="042"></p>
<p>如果将Join算法替换成<code>Sort-Merge Join</code>，则可以将IO降低到<code>7159</code></p>
<p><img src="/../images/15445043.png" alt="043"></p>
<p>这个算法是基于<code>Materialization Model</code>的，所以每次还要写入文件，再读取。如果优化成<code>Veectorization Model</code>，减少重复的写入和读取，可以达到3151的IO</p>
<p><img src="/../images/15445044.png" alt="044"></p>
<p>wraning:</p>
<ul>
<li>这非常难！</li>
<li>Andy对这部分知道的是最少得</li>
<li>如果搞好了，很挣钱</li>
</ul>
<p>查询结构</p>
<ul>
<li>SQL rewrite (可选)：重写sql语句，对sql语句进行优化</li>
<li>Parser: 解析SQL查询，构建语法树</li>
<li>Binder: 查询catalog信息，并将表名等信息替换成内部标识，生成<code>逻辑查询计划</code></li>
<li>Tree rewrite (可选)：重写树结构，包括关系代数等</li>
<li>Optimizer: 调用成本模型，预估成本，选择合适的执行计划，生成<code>物理执行计划</code></li>
</ul>
<p><img src="/../images/15445045.png" alt="045"></p>
<blockquote>
<p>生成物理执行计划的时候，可能有多个执行路径，在短时间内可能无法从全部的路径中选出最佳的。</p>
</blockquote>
<h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><blockquote>
<p>查询优化是很难的，有些数据库的查询优化做的很差，DB2曾引入机器学习做查询优化，效果并不好，被吐糟安装DB2要做的第一件事就是关掉这个功能</p>
</blockquote>
<p>查询优化</p>
<ul>
<li>静态规则&#x2F;条件触发<ul>
<li>根据静态的规则，或者触发了某一个条件来重写查询，移除低效率的东西</li>
<li>需要检查catalog查看信息，而不需要去检查数据</li>
</ul>
</li>
<li>成本原则<ul>
<li>使用模型预估查询成本</li>
<li>估计出多个查询计划，选择其中成本最低的一个</li>
</ul>
</li>
</ul>
<h4 id="静态规则-x2F-条件触发"><a href="#静态规则-x2F-条件触发" class="headerlink" title="静态规则&#x2F;条件触发"></a>静态规则&#x2F;条件触发</h4><p>关系代数等价</p>
<ul>
<li>一个查询语句可以用多个关系代数来表示</li>
<li>可以选择其中代价更小的那个关系代数</li>
<li>这个被叫做 <code>query rewriting</code> 属于上面的 <code>Tree rewrite</code>阶段</li>
<li>比如用join代替笛卡尔积</li>
</ul>
<p>predicate pushdown</p>
<ul>
<li>比如select a.name,b.code from a join b where a.name &#x3D; ‘abc’</li>
<li>可以先join在where，也可以先where 再 join</li>
<li>显然先where更好，把where放到join的下层执行</li>
<li>还有可以再where之后只获取需要的列，其余不需要的列就不再往上层传递了</li>
</ul>
<p>projection pushdown</p>
<ul>
<li>比如select a.name,b.code from a join b on a.id &#x3D; b.aid</li>
<li>可以在扫描a表的时候进行投影，获取id和name传到join节点处理，而不是全部字段传过去，b表同样</li>
</ul>
<p><img src="/../images/15445046.png" alt="046"></p>
<p>语句重写</p>
<ul>
<li>比如select * from a where 1 &#x3D; 0; 那么不会返回任何数据。</li>
<li>select * from a where 1 &#x3D; 1 会返回所有数据，重写成select * from a</li>
</ul>
<h4 id="成本原则"><a href="#成本原则" class="headerlink" title="成本原则"></a>成本原则</h4><blockquote>
<p>mongoDB没有使用成本预测模型，而是执行所有的查询计划，哪个最先返回就用哪个</p>
</blockquote>
<p>最初是IBM提出的。枚举不同的查询计划，并估算他们的成本,在检查完所有的计划或者超时后，选择其中成本最低的一个。</p>
<ul>
<li>single relation</li>
<li>multiple relation </li>
<li>nested sub-queries</li>
</ul>
<p>single relation</p>
<ul>
<li>单表是比较简单的，比如根据后面的statistics决定走哪个索引更好</li>
<li>可以顺序扫描 </li>
<li>可以二分搜索</li>
<li>可以走索引</li>
</ul>
<p>对于单表查询来说，一般会使用<code>启发式规则</code>，他来判断哪些where条件能筛掉更多的数据，就先进行哪个where。</p>
<p><code>sargable (search argument able)</code>：他会比较不同的索引，比如这个索引合适，那么就会使用它，比如id&#x3D;1的，那么就会使用主键索引</p>
<p>multiple relation </p>
<ul>
<li>有两种方法，第一种是自底向上</li>
<li>还有是自顶向下</li>
</ul>
<h5 id="system-R-优化"><a href="#system-R-优化" class="headerlink" title="system R 优化"></a>system R 优化</h5><ul>
<li>这是一个自底向上的multiple relation</li>
<li>将查询分成block并为每个block生成逻辑运算</li>
<li>为每个逻辑运算生成物理运算并实现它</li>
<li>组合所有的join算法和访问路径</li>
<li>生成一个left deep的树</li>
</ul>
<p>比如有下面的SQL,ALBUM.NAME 字段有索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ARTIST.NAME</span><br><span class="line"> <span class="keyword">FROM</span> ARTIST, APPEARS, ALBUM</span><br><span class="line"><span class="keyword">WHERE</span> ARTIST.ID<span class="operator">=</span>APPEARS.ARTIST_ID</span><br><span class="line"> <span class="keyword">AND</span> APPEARS.ALBUM_ID<span class="operator">=</span>ALBUM.ID</span><br><span class="line"> <span class="keyword">AND</span> ALBUM.NAME<span class="operator">=</span>&quot;Andy&#x27;s OG Remix&quot;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ARTIST.ID</span><br></pre></td></tr></table></figure>

<p>进行第一步，可以得到三个表的扫描方法</p>
<ul>
<li>ARTIST：顺序扫描</li>
<li>APPEARS：顺序扫描</li>
<li>ALBUM：索引扫描</li>
</ul>
<p>接下来组合不同的join算法，我们可以先连接ARTIST和APPEARS表，也可以先连接APPEARS和ALBUM表，或者ALBUM和ARTIST表，并且可以使用hash join 或者 merge join</p>
<p><img src="/../images/15445047.png" alt="047"></p>
<p>最终为每个可能选择成本最低的join</p>
<p><img src="/../images/15445048.png" alt="048"></p>
<p>接下来为每个可能去join其他表，来完成最终的三个表join，这个时候还是有hash join和merge join,选择最适合的join方法，就会产生三个路径</p>
<p><img src="/../images/15445049.png" alt="049"></p>
<p>在从这三个中选择出成本最低的一个路径作为最终的路径</p>
<p><img src="/../images/15445050.png" alt="050"></p>
<h5 id="自顶向下优化"><a href="#自顶向下优化" class="headerlink" title="自顶向下优化"></a>自顶向下优化</h5><p>首先生成逻辑节点，最底下是三个表，最上面是三个表join并且order by，中间是两个表join</p>
<p><img src="/../images/15445051.png" alt="051"></p>
<p>接下来先生成三个表的一个物理操作，因为需要order by，所以可以认为merge join更好。</p>
<p><img src="/../images/15445052.png" alt="052"></p>
<p>接下来两个表的物理操作，可以选择hash join或这merge join，因为要排序，可以认为merge join更好</p>
<p><img src="/../images/15445053.png" alt="053"></p>
<p>最后在探测其他的路径，比如最上层还可能有hash join，或者先hash join，在排序，但是这些都没有merge join的成本低，所以在探测到以后就可以Pass掉了</p>
<p><img src="/../images/15445054.png" alt="054"></p>
<h5 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h5><ul>
<li>重写去掉and&#x2F;or来把他们变成同一个层级</li>
</ul>
<p>比如以下SQL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> sailors <span class="keyword">AS</span> S</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line"> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> reserves <span class="keyword">AS</span> R</span><br><span class="line"> <span class="keyword">WHERE</span> S.sid <span class="operator">=</span> R.sid</span><br><span class="line"> <span class="keyword">AND</span> R.day <span class="operator">=</span> <span class="string">&#x27;2022-10-25&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>可以被重写为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"> <span class="keyword">FROM</span> sailors <span class="keyword">AS</span> S, reserves <span class="keyword">AS</span> R</span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="operator">=</span> R.sid</span><br><span class="line"> <span class="keyword">AND</span> R.day <span class="operator">=</span> <span class="string">&#x27;2022-10-25&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>分解子查询并将结果存储在临时表中，比如使用CTE，避免每个tuple都需要执行子查询</li>
</ul>
<p>比如下面的SQL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sid, <span class="built_in">MIN</span>(R.day)</span><br><span class="line"> <span class="keyword">FROM</span> sailors S, reserves R, boats B</span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="operator">=</span> R.sid</span><br><span class="line"> <span class="keyword">AND</span> R.bid <span class="operator">=</span> B.bid</span><br><span class="line"> <span class="keyword">AND</span> B.color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span></span><br><span class="line"> <span class="keyword">AND</span> S.rating <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(S2.rating)</span><br><span class="line"> <span class="keyword">FROM</span> sailors S2)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> S.sid</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>可以将子查询提取出来变成</p>
<p><img src="/../images/15445055.png" alt="055"></p>
<p>catalog会记录一些成本信息，不同的DBMS有不同的更新策略，也可以手动更新,这被叫做<code>statistics</code></p>
<ul>
<li>PostgreSQL&#x2F;SQLite : ANALYZE</li>
<li>Oracle&#x2F; Mysql: ANALYZE TABLE</li>
<li>SQL server: UPDATE STATISTICS</li>
<li>DB2: RUNSTATS</li>
</ul>
<p>statistics: 维护着下面的信息</p>
<ul>
<li>counter: 表中的tuple数量</li>
<li>V(A,R): R表中的A字段的去重数量</li>
<li>SC(A,R): <code>选择基数SC</code> 是 counter &#x2F; V(A,R) 的值</li>
</ul>
<p>选择率：有了上面的数据，就可以计算出要查询的数据的分布比例了。这里就是求概率。</p>
<ul>
<li>比如查询主键 id &#x3D; 1的数据，当前有数据5条，那么counter &#x3D; 5,V(A,R) &#x3D; 5, SC(A,R) &#x3D; 1, 选择率 &#x3D; 1&#x2F;5</li>
<li>比如范围查询 id &gt; 2的数据，当前有数据5条，那么counter &#x3D; 5, V(A,R) &#x3D; 5, SC(A,R) &#x3D; 1, 选择率 &#x3D; (Max - A) &#x2F; (Max - Min) &#x3D; 5-2&#x2F;5-1 &#x3D; 3&#x2F;4,显然这事错误的预测，但是数据库就是这样</li>
<li>比如not查询 id &lt;&gt; 1的数据，当前有数据5条，那么选择率 &#x3D; 1 - (id &#x3D; 1的选择率) &#x3D; 1 - 1&#x2F;5 &#x3D; 4&#x2F;5</li>
<li>比如多个条件 and, 那么取交集，也就是 两个选择率 相乘 &#x3D; sel(AB),这种计算同样不太准确，比如有一个<code>汽车表</code>，有<code>make</code>字段代表生产商，<code>model</code>代表型号，我们知道model &#x3D; “帕萨特”，make 一定是 <code>大众</code>。按照我们的算法 假设make 有10个，选择率就是1&#x2F;10, model 100个，选择率就是 1&#x2F;100,总的选择率就是 1&#x2F;1000,但是帕萨特一定是大众的，所以真实选择率其实是1&#x2F;100。有些数据库可以设置字段关联来解决这个问题，比如oracle等，mysql和postgresql不行。</li>
<li>比如多个条件 or, 那么取并集，也就是两个选择率相加 &#x3D; sel(A) + sel(B) - sel(AB)</li>
</ul>
<p><img src="/../images/15445056.png" alt="056"></p>
<p>直方图的存储，由于存储所有信息的直方图可能很占空间，可以选择稀疏存储，合并一些数据，这样会牺牲一些准确率，但是节省空间。</p>
<p>除了直方图以外，有些数据库还会使用抽样检查，花费一些时间进行抽样，然后根据样本来进行预测选择率。</p>
<h2 id="并发控制原理"><a href="#并发控制原理" class="headerlink" title="并发控制原理"></a>并发控制原理</h2><p>原子性：事务的每个操作都是原子的，要么全成功，要么全失败，通过undo redo log实现<br>一致性：保证事务执行前和执行后是一致的，中间可以临时不一致，但最终要一致。通过raft等共识协议实现<br>隔离性：保证事务的隔离性，每个事务都是独立运行的，并发的时候通过<code>并发控制协议</code>来保证交错执行，通过latch保证正确性。通过并发控制实现<br>持久性：事务提交后数据持久保存了，通过undo redo log实现</p>
<p>当转账的时候，事务被突然的中止，或者断电，该怎么做？</p>
<ul>
<li>Logging</li>
<li>shadow paging</li>
</ul>
<p>Logging</p>
<ul>
<li>记录所有的操作，使得事务中止或者故障后可以undo 操作。</li>
<li>在磁盘和内存中维护 undo records</li>
<li>就像飞机上的黑盒子一样</li>
</ul>
<p>shadow paging</p>
<ul>
<li>将数据复制到一个副本中进行事务更新，如果成功了，将副本作为新的数据库，如果没成功也不影响当前的数据库</li>
<li>起源于System R</li>
<li>CouchDB和LMDB使用这个方法</li>
</ul>
<p>并发控制协议：</p>
<ul>
<li>悲观的：两阶段提交</li>
<li>乐观的：时间戳</li>
</ul>
<p>顺序执行：</p>
<ul>
<li>顺序执行每个事务，保证事务的最终一致性</li>
</ul>
<p>交错执行：</p>
<ul>
<li>如果能达到顺序执行的结果，那么就是正确的执行 schedle</li>
</ul>
<p>假设a,b账户都有1000，那么经过t1事务和t2事务执行以后，总的结果应该不变，对于数据库来说，哪个事务先执行都可以，如果想控制事务执行顺序，应该由应用层控制。</p>
<p><img src="/../images/15445057.png" alt="057"></p>
<p>如果交错执行的结果和顺序执行的结果不一样，就是错误的</p>
<p><img src="/../images/15445058.png" alt="058"></p>
<p>总共会出现三种冲突</p>
<ul>
<li>读写冲突</li>
<li>写读冲突</li>
<li>写写冲突</li>
</ul>
<p>读写冲突（不可重复读）：当读第一次的时候，值被其他事务改变了，再次读的时候，值就和第一次读的时候不一样了</p>
<p><img src="/../images/15445059.png" alt="059"></p>
<p>写读冲突（读未提交或脏读）：A事务读取后，修改了值，B事务读取了修改的值，然后又修改了值，B事务提交后，A事务中止，回滚。</p>
<p><img src="/../images/15445060.png" alt="060"></p>
<p>写写冲突（覆盖数据）：两个事务同时写入一个值，有一个值会被覆盖掉。</p>
<p><img src="/../images/15445061.png" alt="061"></p>
<p>冲突可串行化,大多数数据库使用的，还有个视图可串行化，没数据库实现</p>
<ul>
<li>通过比较两个操作是否冲突，来修改顺序</li>
<li>使用依赖图（优先图）来判断依赖是否出现环</li>
</ul>
<p>假设事务t1写入了A数据，事务t2同时读取A数据，那么事务t2就依赖了事务t1</p>
<p><img src="/../images/15445062.png" alt="062"></p>
<p>假设事务t2又写入了B，事务t1要读取B，那么事务t1就依赖了事务t2，这个时候就产生了循环依赖，就跟死锁一样，所以这个时候需要回滚一个事务</p>
<p><img src="/../images/15445063.png" alt="063"></p>
<h2 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h2><p>事务A先获取锁，事务B等待锁，事务A执行完成以后，释放锁，事务B才能拿到锁。</p>
<p>共享锁，读锁，S-LOCK<br>独享锁，写锁，X-LOCK</p>
<p><img src="/../images/15445064.png" alt="064"></p>
<p>如上图所示，这样还是会出现不可重复读的问题，两阶段锁可以解决这个问题，两阶段锁是第一个正确的<code>并发控制协议</code></p>
<p>两阶段锁,遵循这个方法，使得事务是<code>冲突可串行化</code>的，但是会有级联事务中止（cascading aborts），可以通过强严格两阶段锁解决这个问题。</p>
<ul>
<li>第一阶段Growing:每个事务从lock manager获取锁，事务释放锁以后进入第二阶段shrinking</li>
<li>第二阶段Shrinking:事务释放锁以后不能获取新锁,只能释放锁或者提交事务释放持有的所有锁</li>
</ul>
<p>从生命周期来看，第一阶段是上升，第二阶段只会下降，不会再次上升，下图是正确的生命周期</p>
<p><img src="/../images/15445065.png" alt="065"></p>
<p>下图是错误的生命周期</p>
<p><img src="/../images/15445066.png" alt="066"></p>
<p>cascading aborts，如果事务t1中止回滚了，那么事务t2就发生了<code>脏读</code>，所以也需要回滚重来</p>
<p><img src="/../images/15445067.png" alt="067"></p>
<h3 id="严格两阶段锁"><a href="#严格两阶段锁" class="headerlink" title="严格两阶段锁"></a>严格两阶段锁</h3><p>在提交事务的时候才释放锁。可以解决脏读的问题。</p>
<p>非两阶段锁执行如下：</p>
<p><img src="/../images/15445068.png" alt="067"></p>
<p>两阶段锁执行如下：</p>
<p><img src="/../images/15445069.png" alt="067"></p>
<p>严格两阶段锁执行如下：</p>
<p><img src="/../images/15445070.png" alt="070"></p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁检测：通过使用<code>wait-for</code>图来检测依赖关系，如果有环就是死锁</p>
<p>检测的频率可以通过参数调整，这个需要权衡</p>
<p>victim选择，选择出回滚哪个事务，这也是企业级系统和开源系统的区别</p>
<ul>
<li>可以根据时间戳，选择年龄小的那个，认为刚加入的回滚成本小</li>
<li>根据持有锁的数量，选择持有锁少的那个回滚</li>
<li>根据已完成的工作量，选择查询数量少的那个回滚，可以认为回滚一个查询的成本比几十个查询的成本小</li>
<li>根据剩余的工作量</li>
<li>根据回滚的次数，这个事务老回滚，可能同情它不让它回滚，以避免“饥饿”</li>
</ul>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>根据时间戳来选择</p>
<ul>
<li>wait die: 老的等待新的，如果事务t1先开始，事务t2后开始，t2先获取了锁a, 然后t1要获取锁a，那么就等待，因为老的要等待新的，因为t1是老的，如果t1先获取锁a，t2新的后获取那么t2abort</li>
<li>wound die: 新的等待老的，如果事务t1先开始，事务t2后开始，t2先获取了锁a,然后t1要获取锁a,那么t2就abort，给老的让路，因为老的优先级高，如果t1先获取锁a，t2新的后获取锁a，那么就等待，因为新的等待老的</li>
</ul>
<p><img src="/../images/15445071.png" alt="071"></p>
<p>数据库锁层次</p>
<p><img src="/../images/15445072.png" alt="072"></p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>意向共享锁IS</p>
<ul>
<li>使用共享锁在较低级别锁定，共享锁粒度更细</li>
</ul>
<p>意向排它锁IX</p>
<ul>
<li>使用排它锁在较低级别锁定，排它锁粒度更细</li>
</ul>
<p>共享意向排它锁</p>
<ul>
<li>高级别用共享锁，低级别用排它锁</li>
</ul>
<p><img src="/../images/15445073.png" alt="073"></p>
<p>假设t1事务要查询一个tuple,那么可以在table上一个IS锁，然后在具体的tuple上一个S锁，接下来t2事务要更新一个tuple，发现表上是IS锁，那么根据规则，可以在table上在加一个IX锁，然后在要更新的tuple上一个X锁，如果恰好是同一个tuple，那么就等待S锁释放，如果不是同一个，那么就并发执行成功</p>
<p><img src="/../images/15445074.png" alt="073"></p>
<p>假设t1事务要扫描所有tuple来找到一个tuple去更新，那么table上一个SIX锁，然后扫描到一个tuple，就给一个tuple上X锁，扫描完就释放X锁，接下来t2事务要读取一个tuple，发现表上是SIX锁，那么根据规则，可以在table上一个IS锁，然后在要查询的tuple上S锁，如果刚巧tuple上有X锁，那么就等待t1事务释放。</p>
<p><img src="/../images/15445075.png" alt="073"></p>
<h2 id="时间戳并发控制"><a href="#时间戳并发控制" class="headerlink" title="时间戳并发控制"></a>时间戳并发控制</h2><p>两阶段锁是一种<code>悲观</code>的协议，所有人都会上锁，会争抢，时间戳是一种不依赖锁的<code>乐观</code>的协议。</p>
<p>Ti代表事务i得一个时间戳，Tj是j的，如果Ti &lt; Tj，那么i得事务会在j之前提交。</p>
<p>时间戳的两个特性</p>
<ul>
<li>唯一性，每个时间戳必须是唯一的</li>
<li>单调递增性，时间戳必须是增加的</li>
</ul>
<h3 id="基本时间戳协议"><a href="#基本时间戳协议" class="headerlink" title="基本时间戳协议"></a>基本时间戳协议</h3><p>每个tuple需要维护两个时间戳，一个<code>读时间戳</code>，一个<code>写时间戳</code>。</p>
<h4 id="读"><a href="#读" class="headerlink" title="读"></a>读</h4><p>在读取的时候要保证，当前时间戳 &gt; 写时间戳，也就是读取的是最新的值，未来不会被改变的值。<br>如果 当前时间戳 &lt; 写时间戳，那么重启事务，分配一个新的时间戳，再试一次。<br>如果成功取到tuple，那么需要更新<code>读时间戳</code>，使用自己的时间戳和原来的时间戳中大的那个去更新。</p>
<h4 id="写"><a href="#写" class="headerlink" title="写"></a>写</h4><p>写入的时候要保证，当前时间戳 &gt; 读时间戳 并且 &gt; 写时间戳<br>成功写入的时候要更新写时间戳，使用自己的时间戳和原来的时间戳中大的那个去更新。</p>
<h4 id="托马斯写入优化"><a href="#托马斯写入优化" class="headerlink" title="托马斯写入优化"></a>托马斯写入优化</h4><p>在写入的时候，如果当前时间戳 &lt; 写入时间戳，本来应该<code>中止</code>的事务，可以继续执行，但是写入操作不写入数据库，因为数据库的数据是更新的，而是写入本地副本，方便这个事务后面使用。</p>
<h3 id="乐观并发控制"><a href="#乐观并发控制" class="headerlink" title="乐观并发控制"></a>乐观并发控制</h3><p>另外一个是<code>乐观并发控制</code>。为每一个事务创建一个私有空间，他的所有操作都是先对私有空间的副本操作，最后执行到数据库里面的时候需要对比一下，是否能执行。如果不冲突，就可以执行。</p>
<p>三个阶段</p>
<ul>
<li>read phase(work phase): 执行事务的操作，操作都在私有空间执行。</li>
<li>validation phase: 提交事务的时候验证事务的有效性，是否冲突等，确实是否可以提交。在这个阶段才会分配时间戳。如果在之前需要写入时间戳，先暂时写入无穷大。并检测是否和其他事务的时间戳冲突，其他事务包括以前的所有事务和正在执行的事务</li>
<li>write phase: 如果校验成功，将时间戳写入W-TS列，将修改写入全局工作区，否则abort事务，这是原子的。</li>
</ul>
<p>假设事务t1读取tuple A,将从全局工作区复制A到私有工作区</p>
<p><img src="/../images/15445076.png" alt="076"></p>
<p>接下来事务t2读取tuple A，也将从全局工作区复制A到私有工作区</p>
<p><img src="/../images/15445077.png" alt="077"></p>
<p>接下来事务t2进入validation阶段，然后分配时间戳为1，接下来进入写入阶段，什么也不做</p>
<p><img src="/../images/15445078.png" alt="077"></p>
<p>事务t1修改tuple A，然后再次读取tuple A，可以重复读取，因为读取私有工作区的tuple A</p>
<p><img src="/../images/15445079.png" alt="077"></p>
<p>事务t1进入validation阶段，分配时间戳为2，因为1已经分配给t2事务了，写入阶段将私有工作区的tuple A，更新到全局工作区</p>
<p><img src="/../images/15445080.png" alt="077"></p>
<p>数据库拥有全局视野，在validation phase阶段，是单线程比较事务是否可以执行，会有一个大的latch上锁</p>
<ul>
<li>backward validation: 和并发执行中更早已经提交的事务进行比较</li>
<li>forward validation: 和并发执行中后面没有提交的事务进行比较</li>
</ul>
<h4 id="forward-validation"><a href="#forward-validation" class="headerlink" title="forward validation"></a>forward validation</h4><p>如果事务t1 &lt; t2,t1的写阶段在t2的读阶段之前，则没有任何冲突发生。</p>
<p>如果事务t1 &lt; t2,但是t1的valition阶段在t2的validation阶段之前，则冲突，因为t1已经更改了tuple A ,而t2读取的是W-TS&#x3D;0的tuple A，如果t1事务的W-TS是1，t2是2,那么t2读取的应该是W-TS&#x3D;1的tuple A才对</p>
<p><img src="/../images/15445081.png" alt="081"></p>
<p>如果t2的validation阶段在前就没问题，因为t2分配W-TS&#x3D;1，t1是2</p>
<p><img src="/../images/15445082.png" alt="082"></p>
<p>如果事务t1 &lt; t2 ，t1的validation阶段在t2的前面，但是t1已经写入全局工作区以后，t2在读取这个tuple，就没有问题</p>
<p><img src="/../images/15445083.png" alt="083"></p>
<p>forward validation和没有提交的事务进行比较<br><img src="/../images/15445084.png" alt="084"></p>
<p>backward 和已经提交的事务比较</p>
<p><img src="/../images/15445085.png" alt="085"></p>
<h3 id="partition-based-时间戳协议"><a href="#partition-based-时间戳协议" class="headerlink" title="partition based 时间戳协议"></a>partition based 时间戳协议</h3><p>按照时间戳水平分区，在同一个区里面，按照时间戳顺序执行，就不需要latch了。速度会很快。</p>
<p>在不同区执行的话，就很复杂了。</p>
<p>每个分区都是单线程执行的。这样不需要获取latch。</p>
<h3 id="幻读问题"><a href="#幻读问题" class="headerlink" title="幻读问题"></a>幻读问题</h3><p>假设事务t1读取了table a的count(<em>)是99,事务t2插入了一条数据，事务t1再次读取count(</em>)就变成了100，因为t1只能lock已经存在的数据，要插入的数据没办法lock</p>
<p><img src="/../images/15445086.png" alt="086"></p>
<p>解决幻读的三个方法</p>
<ul>
<li>重新执行扫描：提交后重新执行扫描看结果是否一致，不一致就发生了幻读，少见</li>
<li>predicate locking：System R提出的方案，锁定where语句，进行比较，很难实现，非常少见，duckDB,Hyper等实现了</li>
<li>Index Locking: 索引锁定，常见</li>
</ul>
<h4 id="Index-Locking"><a href="#Index-Locking" class="headerlink" title="Index Locking"></a>Index Locking</h4><ul>
<li>key-value locks</li>
<li>Gap locks (间隙锁)</li>
<li>Key-Range locks</li>
<li>Hierarchical locks</li>
</ul>
<p>key-value locks只能锁定键值，需要一个virtual key来锁定不存在的key</p>
<p><img src="/../images/15445087.png" alt="087"></p>
<p>间隙锁，锁定键值和下一个键值之间的间隙</p>
<p><img src="/../images/15445088.png" alt="088"></p>
<p>key-Range locks，锁定键值以及和下一个键值之间的间隙</p>
<p><img src="/../images/15445089.png" alt="089"></p>
<p>Hierarchical locks使用IX,IS等意向锁</p>
<p>不同隔离级别对应的问题，最受欢迎的隔离级别是读已提交，mysql默认是可重复读</p>
<p><img src="/../images/15445090.png" alt="090"></p>
<h2 id="多版本并发控制（MVCC）"><a href="#多版本并发控制（MVCC）" class="headerlink" title="多版本并发控制（MVCC）"></a>多版本并发控制（MVCC）</h2><p>MVCC(Multiple Version Concurrency Contronl)最早在1978年由一位MIT的Phd学生提出。在1980年被数据库实现。</p>
<p>firefox 最开始叫 phoenix， 但是因为和其他的重名了需要改名字，然后改成了firebird, firebird是个最早开源的数据库，它使用了MVCC,所以火狐还要改名，就成了firefox。</p>
<ul>
<li>Writers don’t block readers</li>
<li>Readers don’t block wirters</li>
</ul>
<p>只读事务读取快照，不需要锁。MVCC天然支持快照隔离，如果没有gc，支持time travel query，就是可以查询很久以前的更改</p>
<p>版本维护有3个元数据</p>
<ul>
<li>version 版本号 从0开始，递增</li>
<li>begin 开始的时间戳</li>
<li>end 结束的时间戳，默认是无穷大，当写入以后要更新上一个版本的end</li>
</ul>
<p><img src="/../images/15445097.png" alt="090"></p>
<p>还要维护一个事务状态表</p>
<ul>
<li>txnid: 比如事务t1,t2标识</li>
<li>timestamp: 时间戳，如OCC那样</li>
<li>status: 活动中，已提交等</li>
</ul>
<p><img src="/../images/15445098.png" alt="090"></p>
<p>假设事务t1读取A0的数据，然后事务t2写入A1数据，然后更新A0的end-ts&#x3D;2，事务t1再次读取的时候还能看到A0</p>
<p><img src="/../images/15445099.png" alt="090"></p>
<p>假设事务t1读取A0的数据，然后写入A1的数据，事务t2读取A0的数据，写入A2的数据，这个时候t2会阻塞，因为t1持有A的锁，当t1事务commit后，释放锁，事务t2才能继续写入A2的数据</p>
<p><img src="/../images/15445100.png" alt="100"></p>
<p>当事务启动的时候，会看到启动时数据库里的一致的快照</p>
<ul>
<li>没有来自未提交的事务的撕裂写入</li>
<li>如果两个事务更新同一个tuple，第一个写入将获胜</li>
</ul>
<p>快照隔离收到写入偏差异常(Write Skew Anomaly)的影响。</p>
<p>写入偏差异常，假设当前有2个黑球，2个白球，事务t1要将白球更新成黑球，事务t2要将黑球更新成白球，这个时候事务t1读取到2个白球，只将这个两个白球更新成黑球了，而事务t2读取了2个黑球，只把这2个黑球更新成白球了，最终结果还是2黑2白</p>
<p><img src="/../images/15445101.png" alt="100"></p>
<p>但是顺序执行的话结果应该是全白或全黑。</p>
<p><img src="/../images/15445102.png" alt="100"></p>
<p>并发控制协议</p>
<ul>
<li>timestamp ordering:分配一个确定顺序的时间戳</li>
<li>OCC:乐观并发控制</li>
<li>两阶段锁</li>
</ul>
<h3 id="版本存储"><a href="#版本存储" class="headerlink" title="版本存储"></a>版本存储</h3><p>版本存储：为每个逻辑tuple创建一个链表，每个事务通过指针遍历链表获取对应的版本。索引指针指向链表的头节点。</p>
<ul>
<li>append only storage: 复制一个tuple,更新数据，放到后面的节点作为tuple的新版本。</li>
<li>time travel storage: master version表中放最新版本的数据，老版本的数据放在 time travel 表中。master version表维护指向time travel表数据的指针。</li>
<li>Delta Storage: 最佳方案，只维护对前一个版本数据的修改，不直接维护所有副本。</li>
</ul>
<h4 id="append-only-storage"><a href="#append-only-storage" class="headerlink" title="append only storage"></a>append only storage</h4><p>要么最新到最旧的连接，要么最旧到最新的连接，全都放在一个工作空间中，然后用指针连一起</p>
<p><img src="/../images/15445091.png" alt="090"></p>
<h4 id="time-travel-storage"><a href="#time-travel-storage" class="headerlink" title="time travel storage"></a>time travel storage</h4><p>这个是两个空间来存储，一个main table存储最新的，一个time travel table存储所有旧的，像Sql server这种最初没有设计MVCC的数据库，为了兼容使用了这种方法。</p>
<p><img src="/../images/15445092.png" alt="090"></p>
<h4 id="Delta-storage"><a href="#Delta-storage" class="headerlink" title="Delta storage"></a>Delta storage</h4><p>也是两个空间存储，不同的是旧空间只存储修改的列的值</p>
<p><img src="/../images/15445093.png" alt="090"></p>
<h3 id="garbage-collection"><a href="#garbage-collection" class="headerlink" title="garbage collection"></a>garbage collection</h3><p>garbage collection(垃圾回收)</p>
<ul>
<li>tuple level：通过比较时间戳来确定哪些版本已经不用了，可以进行回收了。</li>
<li>transaction level：在事务提交的时候进行对比旧版本的数据是否可以删除</li>
</ul>
<h4 id="tuple-level-gc"><a href="#tuple-level-gc" class="headerlink" title="tuple level gc"></a>tuple level gc</h4><h5 id="vacuum"><a href="#vacuum" class="headerlink" title="vacuum"></a>vacuum</h5><p>后台线程的方式运行，每隔一段时间去扫描，还可以通过bit map来提升速度</p>
<p>假设现在正在运行的事务有两个，最低时间戳是12，那么所有end-ts低于12的都可以被gc，数据库基本都用的这个</p>
<p><img src="/../images/15445094.png" alt="090"></p>
<h5 id="cooperative-cleaning"><a href="#cooperative-cleaning" class="headerlink" title="cooperative cleaning"></a>cooperative cleaning</h5><p>当查询某个tuple的时候，进行扫描这个tuple的旧版本，从而gc，缺点是如果这个tuple一直不被访问，那么就一直不gc，很罕见</p>
<p><img src="/../images/15445095.png" alt="090"></p>
<h4 id="transaction-level-gc"><a href="#transaction-level-gc" class="headerlink" title="transaction level gc"></a>transaction level gc</h4><p>在事务提交的时候进行对比旧版本的数据是否可以删除</p>
<p><img src="/../images/15445096.png" alt="090"></p>
<h3 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h3><p>索引管理</p>
<ul>
<li>逻辑指针：通过中间表转化指针和物理地址，二级索引指向主键索引。</li>
<li>物理指针：直接记录指针</li>
</ul>
<h4 id="物理指针"><a href="#物理指针" class="headerlink" title="物理指针"></a>物理指针</h4><p>所有的索引都记录指针，缺点是更新的时候所有索引的指针都要更新</p>
<p><img src="/../images/15445103.png" alt="103"></p>
<h4 id="逻辑指针"><a href="#逻辑指针" class="headerlink" title="逻辑指针"></a>逻辑指针</h4><p>二级索引都记录主键，只有主键索引记录指针，mysql就这样的，这种方式更好</p>
<p><img src="/../images/15445104.png" alt="104"></p>
<h4 id="重复key问题"><a href="#重复key问题" class="headerlink" title="重复key问题"></a>重复key问题</h4><p>如果索引不是唯一索引，可以有多个key的话，假设事务t1读取A1，没问题</p>
<p>假设事务t2更新了A1，又删除了A1，那么数据如图所示A1老版本指向新版本，但是新版本是被删除的<br><img src="/../images/15445105.png" alt="104"></p>
<p>假设事务t3插入了一条A1数据，那么索引就指向两个A1数据</p>
<p><img src="/../images/15445106.png" alt="104"></p>
<p>MySQL使用两阶段锁，版本存储使用Delta Storage，垃圾回收是tuple level Vacuum,索引管理是逻辑指针。Mysql更快。<br>PostgreSQL使用两阶段锁，版本存储使用append only storage, 垃圾回收使用tuple level Vacuum，索引管理是物理指针。</p>
<p>MVCC实现</p>
<p><img src="/../images/15445107.png" alt="104"></p>
<h2 id="Logging-Schemes"><a href="#Logging-Schemes" class="headerlink" title="Logging Schemes"></a>Logging Schemes</h2><p>在数据库运行时，还没有把数据写入磁盘的时候发生故障，这个时候需要恢复数据。</p>
<h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><p>主要是两件事</p>
<ul>
<li>收集日志信息，以方便恢复</li>
<li>根据日志信息进行恢复</li>
</ul>
<p>故障类型</p>
<ul>
<li>事务故障</li>
<li>系统故障</li>
</ul>
<h3 id="UNDO-撤销-and-REDO-重做"><a href="#UNDO-撤销-and-REDO-重做" class="headerlink" title="UNDO(撤销) and REDO(重做)"></a>UNDO(撤销) and REDO(重做)</h3><p>Undo:维护一些信息，可以恢复事务对数据库中某个对象所做的任何修改。<br>Redo: 维护一些信息，可以重新执行某个事务对数据库中的某个对象所做的修改。可以重新执行一个已经提交的事务的修改。</p>
<h3 id="buffer-pool-策略"><a href="#buffer-pool-策略" class="headerlink" title="buffer pool 策略"></a>buffer pool 策略</h3><p>两个策略</p>
<ul>
<li>steal:是否允许一个已提交事务写入磁盘的时候把这个page里面的未提交事务的修改也写入磁盘。</li>
<li>force：提交事务的时候，是否允许事务的所有更新写入磁盘</li>
</ul>
<p>not steal + force</p>
<ul>
<li>优点：不需要恢复，因为只写入磁盘提交的事务更新的内容。磁盘就是已提交内容</li>
<li>缺点：多个事务提交需要写入多次磁盘，写入磁盘麻烦点，因为要复制一个副本出来，副本中是这个事务修改的内容，把这个副本写入磁盘。</li>
</ul>
<p><img src="/../images/15445108.png" alt="104"></p>
<p>shadow paging:</p>
<ul>
<li>有一个db root，记录当前使用的hash table</li>
<li>hash table有一个master table是当前使用的，每个事务会有一个shadow page table，提交以后更新db root指向这个shadow page table，然后回收之前的master table和对应的page文件</li>
</ul>
<p><img src="/../images/15445109.png" alt="104"></p>
<p>wirte ahead log</p>
<ul>
<li>先写入日志，在写入磁盘</li>
<li>日志中包含的信息可以用来undo and redo。</li>
<li>使用的策略是 steal + not force，所以不需要把事务的所有更新都写入磁盘。</li>
</ul>
<p>日志内容</p>
<ul>
<li>事务id</li>
<li>对象id</li>
<li>时间戳</li>
<li>before value(undo)</li>
<li>after value(redo)</li>
<li>写入更快，但是恢复速度慢</li>
</ul>
<p>当事务执行的时候，写入日志到内存中，比如事务t1,将A从1修改到8，当事务提交的时候，先把日志写入磁盘，然后告诉客户端事务成功，如果这个时候发生断电等，可以读取日志来恢复事务，如果写入日志之前断电，那么无需恢复，因为没有告诉客户端成功，事务没有成功如何办是客户端要考虑的。</p>
<p><img src="/../images/15445110.png" alt="104"></p>
<p>group commit</p>
<ul>
<li>有两个log buffer，写满一个以后，写另一个，将满的log buffer写入磁盘</li>
<li>除了满的时候写入磁盘，还有定时，如果知道写入磁盘的时间，可以定时成这个时间，没满的话时间到了也会写入磁盘。</li>
</ul>
<p>满了的写入磁盘可以异步写入，增加速度</p>
<p><img src="/../images/15445111.png" alt="111"></p>
<p>shadow paging 和 WAL 就是一种权衡，是看重运行时速度还是恢复速度，几乎所有的数据库都是用WAL,比如mysql的bin log, WAL运行时速度更快</p>
<p><img src="/../images/15445112.png" alt="111"></p>
<p>logging schemes</p>
<ul>
<li>物理日志：记录底层字节的修改，就像git diff一样能看见，但是修改1万条tuple,就会记录1万条tuple的修改。</li>
<li>逻辑日志：记录高层的事务操作，像update,delete,insert等。比物理日志省空间，但是恢复的时候不知道哪些tuple已经写入了磁盘，所以恢复的时候还会在写入一遍。</li>
<li>混合日志：记录相对底层的修改，但是不像git diff一样那么详细。</li>
</ul>
<p><img src="/../images/15445113.png" alt="111"></p>
<h3 id="check-point"><a href="#check-point" class="headerlink" title="check point"></a>check point</h3><p>WAL的缺点是无限增长，如果崩溃后，则需要重现所有的WAL，增加检查点以后，可以只重现检查点以后的日志。</p>
<p>日志中写入check point，check point之前的都是已经写入磁盘的，所以恢复的时候就不用管了。</p>
<p>假设事务t1在检查点前commit了，则不需要恢复，因为已经提交了，事务t2在检查点后commit，在检查点前开始，则需要redo恢复事务t2，事务t3在检查点前开始，但是还没有commit，所以不需要恢复，直接撤销即可。</p>
<p><img src="/../images/15445114.png" alt="114"></p>
<h2 id="aries-recovery"><a href="#aries-recovery" class="headerlink" title="aries recovery"></a>aries recovery</h2><p>三步</p>
<ul>
<li>预写式日志</li>
<li>Repeating history during redo: 重启并恢复事务到之前的状态</li>
<li>logging changes during undo：再次写入预写式日志</li>
</ul>
<p>日志序列号(LSN)</p>
<ul>
<li>每个日志都要有一个序列号，在一个事务中，可能不是连续的，但是递增的。</li>
<li>flushedLSN:在内存中，记录上一个刷到磁盘中的log的LSN</li>
<li>pageLSN: 在page中，记录page最新的序列号</li>
<li>recLSN: 在page中，记录最老的序列号，这个是不会变的，而pageLSN一直在更新。</li>
<li>lastLSN: 记录事务中最新的一个日志</li>
<li>Master Record: check point最新的LSN</li>
</ul>
<p>如果pageLSN &lt;&#x3D; flushedLSN, 表明这个page的数据都已经写入磁盘了</p>
<p>事务提交的时候，往日志里面写入一个<code>txn end</code>。</p>
<p>当事务commit后写入磁盘，然后更新flushedLSN，接下来添加txn end标识</p>
<p><img src="/../images/15445115.png" alt="114"></p>
<p>CLR:abort算法</p>
<ul>
<li>当事务abort的时候，进行撤销操作，日志里面添加CLR记录，before是对应的之前事务日志的after，CLR的after对应之前的before,undo next指针指向下个需要撤销的日志。</li>
<li>撤销完成以后添加 <code>txn end</code>。</li>
</ul>
<p>写入的时候如同链表一样，除了记录本次的LSN以外，还要记录上一个的LSN,比如本次001，上次是Nil，本次002，上次001，以此找出这一次事务的所有日志，比如事务t1是001-nil,002-001，接下来事务t2是003-nil,004-003,然后事务t1是005-002。</p>
<p>接下来插入CLR日志，CLR可以是026-011,CLR-002代表要撤销的是LSN&#x3D;002的日志，记录了从40恢复到30，最后在插入txn-end标识</p>
<p><img src="/../images/15445116.png" alt="114"></p>
<p>check point写入</p>
<ul>
<li>第一种方式是停止创建新事务，等所有事务完成的时候开始写入<ul>
<li>优点是能完全保证数据一致性</li>
<li>缺点是耗时，执行的时候不能创建新事务</li>
</ul>
</li>
<li>第二种方法暂停更新的事务，只读事务不受影响，需要维护一个active transation table和一个dirty page table<ul>
<li>active transation table包含事务id,lastLSN和状态，状态有运行中，提交中，等待undo</li>
<li>dirty page table 包含所有的dirty page信息</li>
</ul>
</li>
<li>第三种方法最好，叫fuzzy checkpoint，checkpoint的时候允许所有事务运行。<ul>
<li>开始的时候记录checkpoint begin</li>
<li>结束的时候记录checkpoint end,end里面包含了 checkpoint期间的active transation table和dirty page table信息。</li>
</ul>
</li>
</ul>
<p>ATT(Active Transation Table)</p>
<p><img src="/../images/15445117.png" alt="114"></p>
<p>DPT(Dirty Page Table)<br><img src="/../images/15445118.png" alt="114"></p>
<p>第一个check point记录了ATT是T2事务，代表事务t2在check point之前开始，且未提交，而事务t1在check point之前已经提交了，所以不记录，DPT记录了事务t2在check point之前修改的脏页是P22</p>
<p>第二个check point记录了事务T2,T3，因为T2虽然在第二个check point之前提交了，但是没有插入txn-end代表没有提交结束，DPT记录了两个check point之间的脏页P11和P33</p>
<p><img src="/../images/15445119.png" alt="114"></p>
<p>fuzzy check point </p>
<p>因为所有事务都在运行中，所以增加了check point begin 和 end来标识check point的开始和结束，第一个check point end里面记录了事务t2和脏页P22，是因为这些发生在check point begin之前。</p>
<p><img src="/../images/15445120.png" alt="120"></p>
<p>arise recovery</p>
<ul>
<li>分析：根据master record跳到对应的check point的位置，然后开始扫描需要恢复的信息。</li>
<li>redo: 重新执行所有的操作。</li>
<li>undo: 从日志最后开始往上，撤销所有未提交的更改。这个时候已提交的已经写入磁盘，未提交的已经被撤销。</li>
</ul>
<p>分析阶段：从master record的位置开始扫描到最后，找出这之间的所有active transation table和dirty page table信息。</p>
<p>redo: 根据分析出的信息，找到dirty page中最早的一个recLSN, 也就是最早的一个日志，然后从这里开始恢复数据，执行一遍所有的操作。来恢复buffer pool。</p>
<p>undo: 从最后开始往上面扫描，把需要撤销的数据进行撤销。</p>
<h2 id="分布式数据库介绍"><a href="#分布式数据库介绍" class="headerlink" title="分布式数据库介绍"></a>分布式数据库介绍</h2><p>并行数据库</p>
<ul>
<li>离得近的<br>分布式数据库</li>
<li>离得远的</li>
</ul>
<p>系统架构</p>
<ul>
<li>shared everthing</li>
<li>shared memory:常见于高性能计算领域，有多个CPU，共享内存和磁盘</li>
<li>shared disk: 内存也有多个，共享磁盘，这个更常见，例如云数据库<ul>
<li>更新数据的时候需要通知其余的节点</li>
<li>spark,HBase</li>
</ul>
</li>
<li>shared noting: 磁盘也是多个<ul>
<li>有更好的效率，但是很难保证数据一致性和扩容</li>
<li>mongo,ES,Etcd,Zookeeper,ClickHouse</li>
</ul>
</li>
</ul>
<p>shared noting example</p>
<p>首先通过catalog查询应该请求哪个节点</p>
<p><img src="/../images/15445121.png" alt="120"></p>
<p>然后发送查询请求到相应的节点</p>
<p><img src="/../images/15445122.png" alt="120"></p>
<p>如果数据跨节点存储，那么数据会节点间通信，比如获取100和200的数据，node p1会请求p2获取200的数据，然后p1将两个数据返回给客户端</p>
<p><img src="/../images/15445123.png" alt="120"></p>
<p>shared disk example</p>
<p>客户端请求节点获取数据，节点请求disk获取数据，然后返回</p>
<p><img src="/../images/15445124.png" alt="120"></p>
<p>但是更新的时候需要广播给其他节点</p>
<p><img src="/../images/15445125.png" alt="120"></p>
<p>mongo属于shared noting</p>
<ul>
<li>route节点，负责把请求路由到对应的节点上</li>
<li>config节点，route从这里获取请求应该到哪个节点上</li>
<li>db节点</li>
</ul>
<p>数据拆分</p>
<ul>
<li>将不同的数据放到每个shared上面</li>
<li>不同的查询交给不同的shared去做，可以通过exchange operate来并行执行。</li>
<li>最简单的方式是一个表一个分区，mongodb可以这样。</li>
<li>水平分区<ul>
<li>将数据水平分到每个分区中</li>
<li>可以是hash，也可以是一个范围一个范围的分区</li>
<li>hash的话，想增加分区很麻烦，可以使用<code>一致性hash</code>来解决增加分区的问题，而不是取余。</li>
<li>采用一致性hash的有snowflake,memcached,cassandra等</li>
</ul>
</li>
</ul>
<p>SHARED-DISK PARTITIONING<br><img src="/../images/15445126.png" alt="120"></p>
<p>SHARED-NOTHING PARTITIONING<br><img src="/../images/15445127.png" alt="120"></p>
<p>一致性hash</p>
<p>节点分布在环上，数据也分布在环上，顺时针旋转，数据就属于第一个到达的节点。</p>
<p><img src="/../images/15445128.png" alt="120"></p>
<p>增加节点的时候，只需要重新hash其中一个节点的数据就可以，比如增加p4，因为P4节点落在p3节点的范围里面，所以只需要重新hash节点p3的数据，其他节点无影响。</p>
<p><img src="/../images/15445129.png" alt="120"></p>
<p>如果需要复制数据，将数据存储在多个节点上，假设replication&#x3D;3，复制数据到三个节点，则顺时针旋转的3个节点都存储该数据。</p>
<p><img src="/../images/15445130.png" alt="130"></p>
<p>分布式事务</p>
<ul>
<li>通过中心化服务器，来分发lock，然后提交事务的时候通过他来请求每一个分区是否能提交事务，如果都可以，才提交事务</li>
<li>去中心化事务提交</li>
</ul>
<p>spanner</p>
<p>HNSW</p>
<h2 id="分布式OLTP数据库"><a href="#分布式OLTP数据库" class="headerlink" title="分布式OLTP数据库"></a>分布式OLTP数据库</h2><p>假设所有节点是友好的</p>
<p>replication:可以提高可用性</p>
<ul>
<li>分区 vs 非分区</li>
<li>shared noting vs shared disk</li>
<li>设计<ul>
<li>副本配置</li>
<li>传播方案</li>
<li>传播时序</li>
<li>更新方法</li>
</ul>
</li>
</ul>
<p>副本配置</p>
<ul>
<li>primary: 有一个主节点，其他是从节点，大部分都是这样的，主节点负责同步给其他从节点。比如主从复制，读写分离这种</li>
<li>multi-primary: 事务可以在任何一个节点提交，并同步给其他节点，mysql group replication就支持这个。这种方案所有副本都可以读写，冲突的时候通过两阶段提交或者Paxos来觉得写入哪个。Facebook使用了这个。</li>
</ul>
<p>primary，写入主节点，读取可以在从节点</p>
<p><img src="/../images/15445131.png" alt="130"></p>
<p>multi-primary 任何节点都可以读写</p>
<p><img src="/../images/15445132.png" alt="130"></p>
<p>K-safety: 通过监控对象来看有哪些replica是活跃的。至少要有k个replica，如果小于k个，就认为宕机了。</p>
<p>传播方案</p>
<ul>
<li>同步：强一致性，所有从节点都同步以后才返回成功</li>
<li>异步：最终一致性，先返回成功，在同步给其他的从节点</li>
<li>半同步：同步给一些节点后返回成功给客户端</li>
</ul>
<p>传播时序</p>
<ul>
<li>即时：立即传递给其他节点，同时当事务提交或回滚的时候也传递给其他节点</li>
<li>提交：事务提交的时候才传播给其他节点</li>
</ul>
<p>事务提交的顺序由数据库状态决定，原子提交协议也是分布式的共识协议</p>
<p>原子提交协议</p>
<ul>
<li>两阶段提交（1970）</li>
<li>三阶段提交（1983）</li>
<li>Viewstamped Replication (1988)</li>
<li>Paxos（1989）</li>
<li>Raft（2013）</li>
<li>ZAB（2008）</li>
</ul>
<p>两阶段提交</p>
<ul>
<li>第一阶段 prepare, 像所有参与者发送请求，是否能提交事务，只有所有都可以提交，才进入第二阶段，如果有一个节点abort,那么事务就会进入第二阶段abort</li>
<li>第二阶段 commit, 想所有参与者发送请求，进行提交事务。</li>
<li>第二阶段 abort, 返回abort，然后所有参与者abort。</li>
</ul>
<p>假设客户端发送提交事务的请求，有一个协调器和若干个参与者，协调器接收请求以后，向参与者发送第一阶段prepare请求。</p>
<p><img src="/../images/15445133.png" alt="130"></p>
<p>如果所有参与者返回OK,表示全部同意提交，则可以提交。</p>
<p><img src="/../images/15445134.png" alt="130"></p>
<p>接下来协调器发送第二阶段commit请求给所有参与者</p>
<p><img src="/../images/15445135.png" alt="130"></p>
<p>所有参与者返回OK以后，协调器返回提交成功给客户端</p>
<p><img src="/../images/15445136.png" alt="130"></p>
<p>假设有任何一个参与者在第一阶段返回了不同意，则终止事务提交</p>
<p><img src="/../images/15445137.png" alt="130"></p>
<p>协调器向所有节点发送第二阶段abort请求</p>
<p><img src="/../images/15445138.png" alt="130"></p>
<p>等待所有节点返回OK以后，协调器返回abort给客户端</p>
<p><img src="/../images/15445139.png" alt="130"></p>
<p>崩溃恢复</p>
<ul>
<li>如果协调器崩溃了。要么全部abort，要么选出新的协调器继续执行事务。</li>
<li>如果参与者崩溃了，那么协调器会认为参与者返回了abort，从而终止事务。</li>
</ul>
<p>优化</p>
<ul>
<li>early prepare voting: 这个很少，最后一个查询执行的时候，告诉他可以直接进入prepare阶段</li>
<li>early Ack After Prepare: 这个很常见，prepare阶段结束就返回事务执行成功，然后自己再接着commit。</li>
</ul>
<p>early Ack After Prepare：当第一阶段prepare返回成功以后，立即给客户端返回成功。</p>
<p><img src="/../images/15445140.png" alt="140"></p>
<p>返回给客户端以后再发送第二阶段commit请求给其他参与者。</p>
<p><img src="/../images/15445141.png" alt="140"></p>
<p>Paxos，来自分布式计算领域，也被称为<code>共识协议</code>。两阶段提交是Paxos的一个子集。</p>
<ul>
<li>Paxos大部分节点同意提交就可以提交，而两阶段提交需要所有参与者同意，所以Paxos没有容错。</li>
</ul>
<p><img src="/../images/15445142.png" alt="140"></p>
<p>multi-Paxos</p>
<ul>
<li>选举一个leader来进行提案，每隔一段时间重新选举</li>
<li>防止有两个 proposer 来回提交导致的starving问题</li>
</ul>
<p>两阶段提交 vs Paxos vs Raft</p>
<p>两阶段提交</p>
<ul>
<li>如果协调器在发送prepare消息后挂掉，则阻塞直到协调器恢复</li>
</ul>
<p>Paxos</p>
<ul>
<li>如果大多数参与者活着则非阻塞，前提是有足够长的时间不再出现故障</li>
</ul>
<p>Raft</p>
<ul>
<li>与Paxos类似，但节点类型较少。</li>
<li>只有拥有最新日志的节点才能成为领导者</li>
</ul>
<p>CAP理论</p>
<ul>
<li>Consistent: 一致性</li>
<li>Always Available: 始终可用</li>
<li>Network Partition Tolerant:分区容错性</li>
</ul>
<p>Nosql基本都是AP,事务性的基本都是CP</p>
<p>一致性代表从哪个节点获取的数据都是一样的</p>
<p><img src="/../images/15445143.png" alt="140"></p>
<p>可用性代表当节点挂了以后系统还可以使用</p>
<p><img src="/../images/15445144.png" alt="140"></p>
<p>分区容错性最难，容易出现<code>脑裂</code>问题。当网络挂掉以后从节点以为主节点挂了，所以把自己选举为主节点，就产生了两个主节点</p>
<p><img src="/../images/15445145.png" alt="140"></p>
<p>当网络恢复以后，两个节点的数据就不一样了。</p>
<p><img src="/../images/15445146.png" alt="140"></p>
<p>解决方法1：停止系统</p>
<ul>
<li>停止接受没有大多数节点的分区中的更新。</li>
</ul>
<p>解决方案2：允许拆分，协调更改</p>
<ul>
<li>允许分区的每一侧都接收更新</li>
<li>根据时间来确定最后的版本，以最后的版本为准<ul>
<li>服务端：last update wins 用最后的版本为准</li>
<li>客户端：vector clocks（不要这么做）</li>
</ul>
</li>
</ul>
<p>2010年提议对CAP进行扩展</p>
<ul>
<li>Partition Tolerant:分区容忍</li>
<li>Always Available：随时可用</li>
<li>Consistent：一致<ul>
<li>Latency：延迟</li>
<li>Consistency： 一致性</li>
</ul>
</li>
</ul>
<h2 id="分布式OLAP数据库"><a href="#分布式OLAP数据库" class="headerlink" title="分布式OLAP数据库"></a>分布式OLAP数据库</h2><p>OLAP数据库也被称作<code>数据仓库</code>，通过ETL，把数据存入数据仓库。</p>
<ul>
<li>Extract</li>
<li>Transform</li>
<li>Load</li>
</ul>
<p>星形模型</p>
<ul>
<li>一个事实表</li>
<li>几个dim表</li>
</ul>
<p>雪花模型</p>
<ul>
<li>一个事实表</li>
<li>更多的dim表，dim表可以有他的dim表</li>
</ul>
<p>查询执行</p>
<ul>
<li>push: 发送查询到包含数据的节点,返回数据的时候会做过滤和处理，就像<code>条件下推</code>那样</li>
<li>pull: 知道需要的数据在哪些page里面，把page取过来在执行查询。</li>
</ul>
<p>push</p>
<p>pull</p>
<p>查询计划</p>
<ul>
<li>物理操作： 先生成查询计划，然后将对应的需要执行的物理操作直接发送给其余节点，其余节点只负责执行，返回数据。大部分分布式数据库都这样。</li>
<li>sql: 将sql发给每个节点，每个节点生成自己的执行计划。然后执行返回。</li>
</ul>
]]></content>
      <categories>
        <category>CMU15445</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习路线</title>
    <url>/MySQL%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html</url>
    <content><![CDATA[<h1 id="MySQL学习路线"><a href="#MySQL学习路线" class="headerlink" title="MySQL学习路线"></a>MySQL学习路线</h1><p>大家好，我是大头，98年，职高毕业，上市公司架构师，大厂资深开发，管理过10人团队，我是如何做到的呢？</p>
<p>这离不开持续学习的能力，而其中最重要的当然是数据库技术了！</p>
<p>对于所有开发来说，都离不开数据库，因为所有的数据都是要存储的。</p>
<p>其他的技能可能会变，比如业务开发、算法开发、基础设施开发，也不管你是用Java、php、golang、C++等等。你都会用到数据库，因此，学好数据库对于我们来说就至关重要了。</p>
<p>接下来大头将分享自己学习数据库的路线以及心得。</p>
<p>后续也会根据这个路线分享所有的学习方法以及实操案例。关注我一起学习！文末有惊喜哦！</p>
<h2 id="如何学好数据库"><a href="#如何学好数据库" class="headerlink" title="如何学好数据库"></a>如何学好数据库</h2><p>如何学好数据库？我相信这是一个老生常谈的问题了，如何学好XXX，这里我觉得最重要的是<code>实践</code>。</p>
<p>相信大家都知道这句话。<code>实践是检验真理的唯一标准</code>。因此，当分享结束以后，大头还会分享完整的实操应用，完全免费分享，放在外面至少价值大几百的实操应用训练营。</p>
<p>在现在这个AI发展迅速的时代，你不用点AI好像就被社会淘汰了一样。所以，我们来看一下AI给出的回答。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">学好数据库需要系统的学习方法和实践相结合，以下是一些建议：</span><br><span class="line">1. 基础知识积累</span><br><span class="line">理解数据库概念：首先明确数据库的定义，它是存储、管理和检索数据的系统。了解其基本功能，如数据存储、查询、更新和删除等。</span><br><span class="line">学习数据库类型：常见的数据库有关系型数据库（如MySQL、Oracle、SQL Server）和非关系型数据库（如MongoDB、Redis）。了解它们的特点和适用场景。</span><br><span class="line">掌握数据库模型：重点学习关系型数据库的表结构、字段类型、主键、外键等概念，以及非关系型数据库的键值存储、文档存储、列存储等模型。</span><br><span class="line">2. 理论学习</span><br><span class="line">学习SQL语言：SQL是数据库的核心语言，用于操作关系型数据库。学习SQL的基本语法，包括数据定义语言（DDL）、数据操纵语言（DML）和数据控制语言（DCL）。</span><br><span class="line">DDL：创建、修改和删除数据库对象（如表、索引）。</span><br><span class="line">DML：插入、更新、删除和查询数据。</span><br><span class="line">DCL：控制用户对数据的访问权限。</span><br><span class="line">理解数据库设计原则：学习如何设计合理的数据库结构，包括范式理论（如第一范式、第二范式、第三范式），以减少数据冗余和提高数据一致性。</span><br><span class="line">学习事务管理：了解事务的ACID特性（原子性、一致性、隔离性、持久性），以及事务的提交和回滚机制。</span><br><span class="line">掌握索引和优化：学习索引的原理和类型（如B树索引、哈希索引），以及如何通过索引优化查询性能。</span><br><span class="line">3. 实践操作</span><br><span class="line">安装和配置数据库：选择一种主流的数据库（如MySQL、SQLite），在本地安装并进行配置。熟悉数据库的启动、停止和基本管理操作。</span><br><span class="line">动手操作SQL：通过实际操作来巩固SQL语言的学习。可以使用在线数据库平台（如SQLFiddle）或本地数据库进行练习，编写和执行SQL语句，完成数据的增删改查操作。</span><br><span class="line">进行数据库设计：尝试设计一个小型的数据库项目，如学生管理系统或图书管理系统。从需求分析开始，设计表结构，确定字段类型和关系，然后实现数据库的创建和数据的插入。</span><br><span class="line">参与项目实践：如果有机会，参与实际的数据库项目开发，或者在开源项目中学习和实践。通过实际项目，了解数据库在真实场景中的应用和优化方法。</span><br><span class="line">4. 进阶学习</span><br><span class="line">学习高级SQL技术：如子查询、连接查询（内连接、外连接）、分组查询、窗口函数等。</span><br><span class="line">了解数据库架构设计：学习如何设计高可用、高性能的数据库架构，包括主从复制、读写分离、分库分表等技术。</span><br><span class="line">掌握数据库安全：学习如何保护数据库的安全，包括用户认证、授权、数据加密、备份和恢复等。</span><br><span class="line">学习数据库性能优化：了解如何分析和优化数据库性能，包括查询优化、存储优化、硬件优化等。</span><br><span class="line">5. 持续学习和拓展</span><br><span class="line">关注新技术：数据库领域不断发展，新的技术和工具不断涌现。关注NoSQL数据库、分布式数据库（如Cassandra、HBase）、云数据库（如AWS RDS、阿里云数据库）等新技术的发展。</span><br><span class="line">阅读经典书籍和文档：推荐一些经典书籍，如《数据库系统概念》《SQL必知必会》《高性能MySQL》等。同时，阅读数据库官方文档，深入了解其特性和最佳实践。</span><br><span class="line">参加培训和认证：如果条件允许，可以参加数据库相关的培训课程或考取相关认证（如Oracle认证、MySQL认证），提升自己的专业水平。</span><br><span class="line">加入技术社区：加入数据库相关的技术社区（如Stack Overflow、CSDN、知乎等），与其他开发者交流经验和问题，拓宽视野。</span><br><span class="line">总之，学好数据库需要理论学习和实践操作相结合，通过不断的学习和实践，逐步提升自己的数据库技能。</span><br></pre></td></tr></table></figure>

<p>可以看到AI给出的回答相当不错了。看起来也是那么回事。</p>
<p>对于学习一种新事物来说，我觉得要分为几个阶段吧，对于所有新事物都适用。</p>
<ol>
<li>新概念学习：逐步了解这个东西的概念，是什么？能做什么？什么时候用？如何使用？</li>
<li>基础学习：学习这个东西的一些基础使用，并实践应用。</li>
<li>实战应用：当了解概念和基础以后，可以自己开始实践了，最好能完整的实践每一个功能。一般来说到这一步就可以说熟练使用这个东西了。</li>
<li>深入学习原理：开始深入学习相关的原理性知识，了解这个东西是如何实现的，它当时为什么要这么做？有没有其他替代的方案呢？我们可以尝试自己去实现这个东西。一般来说这一步完成就可以说精通了。</li>
<li>扩展学习：扩展学习其他同类的产品，了解使用场景，优劣等。</li>
</ol>
<p>那么回到我们的话题上，如何学好数据库？</p>
<ol>
<li>概念学习：数据库是什么？能做什么？什么时候用？如何使用？</li>
<li>基础学习：数据库的基础操作，增删改查，DDL、DCL、DML语言。</li>
<li>实战应用：自己去使用数据库的各个功能，包括增删改查、函数、触发器、存储过程、视图等。</li>
<li>学习原理：深入学习数据库的原理，包括事务的实现、锁的实现、增删改查的实现、索引的实现等。</li>
<li>扩展学习：学习不同类型的数据库，如列式数据库、内存数据库、文档数据库等。</li>
</ol>
<p>那么再详细一些呢？如何学好MySQL数据库？</p>
<ol>
<li>概念学习：MySQL数据库是什么？能做什么？什么时候用？如何使用？</li>
<li>基础学习：MySQL数据库的基础操作，增删改查，DDL、DCL、DML语言。</li>
<li>实战应用：自己去使用MySQL数据库的各个功能，包括增删改查、函数、触发器、存储过程、视图等。</li>
<li>学习原理：深入学习MySQL数据库的原理，包括事务的实现、锁的实现、增删改查的实现、索引的实现等。</li>
<li>扩展学习：学习一些其他的数据库，如PostgreSQL、ES、ClickHouse、MongoDB等。</li>
</ol>
<h2 id="概念学习"><a href="#概念学习" class="headerlink" title="概念学习"></a>概念学习</h2><p>首先，我们应该知道什么是数据库？很多人都会搞混一个概念，那就是数据库和数据库管理系统。</p>
<p>数据库的英文是<code>DataBase</code>。它的概念是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库是一个长期存储在计算机内的、有组织的、可共享的数据集合，它具有以下特点</span><br><span class="line">1. 数据的集合性</span><br><span class="line">2. 数据的共享性</span><br><span class="line">3. 数据的冗余度低</span><br><span class="line">4. 数据的独立性</span><br><span class="line">5. 数据的安全性</span><br><span class="line">6. 数据的完整性</span><br><span class="line">7. 数据的可维护性</span><br></pre></td></tr></table></figure>

<p>而数据库管理系统的英文是<code>DataBase Management System</code>。它的概念是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库管理软件（Database Management System，简称DBMS）是用于创建、管理、维护和操作数据库的软件系统。它在用户和数据库之间提供了一个接口，使得用户能够方便地存储、检索、更新和管理数据。</span><br></pre></td></tr></table></figure>

<p>因此，我们要明白，<code>MySQL</code>是一个数据库管理系统，而不是一个数据库。</p>
<p>虽然我们老说<code>MySQL数据库</code>，但这个是因为大家已经习惯了，大家都明白MySQL是什么，因此省略了一些。</p>
<p><code>MySQL</code>是用来管理数据库的一个系统。</p>
<p>那么问题来了，<code>SQL</code>又是什么呢？</p>
<p>这里给出基础篇的概念学习路线。大家可以根据这些去了解具体的概念。</p>
<p><img src="/../images/mysql/mysql1-1.png" alt="概念学习"></p>
<p>这一个部分1-2小时就差不多了。</p>
<h2 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h2><p>学会了概念以后，我们就要应用，进行实践。只有这样才能将知识转化成我们自己的。</p>
<p>对于实战来说，首先肯定要进行MySQL的安装，可以直接到官网进行安装，这里给出连接。</p>
<blockquote>
<p><a href="https://www.mysql.com/">https://www.mysql.com/</a></p>
</blockquote>
<p>安装完成以后，根据上面学习的概念，首先执行一遍DCL、DML、DDL。</p>
<p>接下来需要学习<code>ER图</code>。如何学习ER图呢？同意的，先了解一下概念，在进行实战应用。自己画一画ER图。</p>
<p>画ER图的工具，这里推荐几个</p>
<ul>
<li>visio，可以自己去网上买一些key，不贵，要注意买key，而不是破解机。</li>
<li><a href="https://www.processon.com/">processOn</a>，强烈推荐，网页版，使用方便，免费的一般也够用了。</li>
<li><a href="https://app.diagrams.net/">drwa.io</a>，强烈推荐，同样有网页版，使用方便，免费。</li>
<li><a href="https://dbdiagram.io/">dbdiagram</a>，不同于自己画图，这个网站可以进行数据库建模，支持导入导出。缺点是需要使用<code>DBML</code>进行建模，需要学习一下。</li>
</ul>
<p>接下来进行一些高级的应用、包括CTE、窗口函数、存储过程、视图、触发器等等。</p>
<p>还可以进行导入导出。</p>
<p>还可以使用你熟悉的语言进行操作。Java的使用可以使用MyBatis Plus。</p>
<p><img src="/../images/mysql/mysql1-2.png" alt="概念学习"></p>
<h2 id="深入学习原理"><a href="#深入学习原理" class="headerlink" title="深入学习原理"></a>深入学习原理</h2><p>MySQL原理性的东西就比较多了。</p>
<p>自顶向下来看，首先有连接器、分析器、优化器、执行器。</p>
<p>连接器可以不用管。</p>
<p>分析器的原理，如何进行语法分析的，这里需要学一下<code>关系代数</code>。数据库是将SQL转化成关系代数，然后在生成执行树的。</p>
<p>优化器的原理，如何选择索引的，成本模型是什么？直方图是什么？MySQL本身实现了哪些优化？谓词下推，索引下推，Index Merge等等。</p>
<p>接下来会生成具体的执行计划，如何查看执行计划的各个字段，如何根据执行计划来优化SQL。</p>
<p>还需要学习MySQL事务，事务的隔离级别，ACID特性，MVCC实现，undo log等等。</p>
<p>还要学习SQL语句如何执行的，Select是怎么查询出数据的，where条件怎么筛选数据，join是怎么进行连表查询的，update是怎么更新的，delete怎么删除的，group by,order by怎么实现的。</p>
<p>接下来最重要的索引部分，学习b+树索引，hash索引，倒排索引等等的实现。</p>
<p>数据存储部分的原理，我们知道数据库只是管理数据的，数据最终存储在磁盘上还是一些文件，那么这些文件是如何存储的呢？文件内容是什么？加载到内存以后，内存布局是什么样的？老说page,page是什么？</p>
<p>还有数据库崩溃恢复怎么实现的，redo log怎么实现崩溃恢复，这个其实也挺重要的，因为我们自己进行一些数据处理，可能也需要理解这个，而且大部分的数据持久化，崩溃恢复机制核心都是一样的。</p>
<p>还需要学习mySQL的锁，表锁，行锁，乐观锁，悲观锁，意向锁，间隙锁等等。</p>
<p><img src="/../images/mysql/mysql1-3.png" alt="概念学习"></p>
<h2 id="架构学习"><a href="#架构学习" class="headerlink" title="架构学习"></a>架构学习</h2><p>你学习完上面的东西以后，可以说对于单机MySQL就已经很了解了。接下来就可以进一步保证数据的高可用、高扩展、高性能了。</p>
<p>也就是去了解一些架构上面的知识，比如经典的主从架构，主从同步，异步同步，bin log,relay log，GTID同步。</p>
<p>还有分库分表的只是，水平拆分、垂直拆分、mySQL自带的partition支持。</p>
<p>再比如MySQL自身的集群组件，group replication。还有分布式数据库的一些实现，分布式事务。</p>
<p>CAP理论等等。</p>
<p><img src="/../images/mysql/mysql1-4.png" alt="概念学习"></p>
<h2 id="扩展学习"><a href="#扩展学习" class="headerlink" title="扩展学习"></a>扩展学习</h2><p>当上面的都学习完成以后，可以扩展学习一些其他的数据库。</p>
<p>比如同类型的PostgreSQL。这个更偏向学术性。</p>
<p>再比如其他的文档数据库mongoDB。</p>
<p>常用的搜索数据库ES。</p>
<p>列式数据库ClickHouse这些。</p>
<h2 id="学习书籍推荐"><a href="#学习书籍推荐" class="headerlink" title="学习书籍推荐"></a>学习书籍推荐</h2><p>在这里也给大家推荐一些相关的书籍，可以看一看。</p>
<ul>
<li>MySQL必知必会</li>
<li>InnoDB技术内幕</li>
<li>数据库系统概念</li>
<li>数据密集型应用系统设计</li>
<li>亿级流量系统架构设计与实战</li>
</ul>
<h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>以上就是整体的MySQL学习路线了。</p>
<p>关注我发送“MySQL知识图谱”领取完整的MySQL学习路线。</p>
<p>发送“电子书”即可领取价值上千的电子书资源。</p>
<p>部分电子书如图所示。</p>
<p><img src="/../images/bottom1.png" alt="概念学习"></p>
<p><img src="/../images/bottom2.png" alt="概念学习"></p>
<p><img src="/../images/bottom3.png" alt="概念学习"></p>
<p><img src="/../images/bottom4.png" alt="概念学习"></p>
]]></content>
      <categories>
        <category>CMU15445</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习路线</title>
    <url>/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9%20copy.html</url>
    <content><![CDATA[<h1 id="MySQL索引失效"><a href="#MySQL索引失效" class="headerlink" title="MySQL索引失效"></a>MySQL索引失效</h1><p>大家好，我是大头，98年，职高毕业，上市公司架构师，大厂资深开发，管理过10人团队，我是如何做到的呢？</p>
<p>这离不开持续学习的能力，而其中最重要的当然是数据库技术了！</p>
<p>对于所有开发来说，都离不开数据库，因为所有的数据都是要存储的。</p>
<p>关注我一起学习！文末有惊喜哦！</p>
<h2 id="什么是MySQL索引失效？"><a href="#什么是MySQL索引失效？" class="headerlink" title="什么是MySQL索引失效？"></a>什么是MySQL索引失效？</h2><p>MySQL 索引失效是指尽管表中已经建立了索引，但在某些查询操作中，MySQL 的查询优化器选择不使用这些索引，而是采用全表扫描（Full Table Scan）或其他非索引扫描方式来执行查询。这种情况通常会导致查询性能下降，因为全表扫描需要扫描表中的每一行数据，而不是利用索引快速定位数据。</p>
<p>这里就要介绍一下MySQL的整体架构了。</p>
<p><img src="/../images/mysql/mysql2-1.png" alt="架构"></p>
<ul>
<li>连接器：MySQL连接器（MySQL Connector）是用于连接MySQL数据库的客户端库，它允许应用程序与MySQL数据库进行通信。这些连接器提供了API（应用程序编程接口），使得开发者可以在各种编程语言中轻松地执行SQL语句、管理数据库连接、处理查询结果等。</li>
<li>分析器：MySQL分析器才算真正进入了MySQL里面。它会分析词法和语法，如果你的SQL语句不对，就会看到一些报错，例如语法错误。</li>
<li>优化器：MySQL优化器是本文的重点内容，因为这里涉及了MySQL的一些优化，其中就包括了索引选择，也是导致索引失效的重要原因。在这一步也就确定了查询计划。</li>
<li>执行器：MySQL执行器会根据优化器输出的查询计划来执行这个查询计划，会调用底层的存储引擎进行执行。</li>
<li>存储引擎：MySQL支持多种存储引擎，每个存储引擎有不同的特点。其中InnoDB引擎因为支持事务等优点，现在是MySQL的默认存储引擎。</li>
</ul>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>MySQL连接器（MySQL Connector）是用于连接MySQL数据库的客户端库，它允许应用程序与MySQL数据库进行通信。这些连接器提供了API（应用程序编程接口），使得开发者可以在各种编程语言中轻松地执行SQL语句、管理数据库连接、处理查询结果等。</p>
<p>当我们最开始连接数据库实例的时候，我们要输入用户名密码，这时候连接器会从数据库的用户信息中判断你是否有权限连接数据库进行操作，有哪些权限。</p>
<p>如果你输入的用户名密码错误或者没有权限，那么你会收到下面的报错信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Access denied <span class="keyword">for</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>(<span class="keyword">using</span> password: YES)</span><br></pre></td></tr></table></figure>

<p><img src="/../images/mysql/mysql2-2.png" alt="架构"></p>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>连接成功以后。分析器会分析这个语句的词法，语法，语义这些信息。</p>
<p>通俗来讲就是看到select,update这些关键字，知道你要来干啥，看看你是不是来搞破坏的，来捣蛋的。</p>
<p>看看你是查询哪个表啊，有什么条件啊，这些玩意。</p>
<p>最后会输出一个词法树。</p>
<p>当然了这一步还会分析你的语法有没有错误，比如你把select打错试试。打成elect，会出现下面的报错信息</p>
<blockquote>
<p>You have an error in your SQL syntax: check the maual that corresponds to your MySQL server version for the right syntax to use near ‘elect * from users’ at line 1</p>
</blockquote>
<p><img src="/../images/mysql/mysql2-3.png" alt="架构"></p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>优化器负责几个事情</p>
<ul>
<li>优化SQL：比如你写了一个很不友好的SQL，如<code>select * from a where 1 =1</code>,优化器会将1&#x3D;1去掉。还有比如括号的删除，如<code>select * from a where ((a AND b) AND c OR (((a AND b) AND (c AND d))))</code>改写成<code>select * from a where (a AND b AND c) OR (a AND b AND c AND d)</code>。等等。</li>
<li>一些内部的优化器：下面列出的是部分，更多的可以参考<a href="https://dev.mysql.com/doc/refman/8.4/en/optimization.html">MySQL官方文档优化器部分</a><ul>
<li>谓词下推：即where条件下推到扫描表的时候执行，而不是扫描表之后执行。</li>
<li>范围优化：对于BTREE和HASH索引，当使用&#x3D;、&lt;&#x3D;&gt;、IN（）、IS NULL或IS NOT NULL运算符时，键部分与常量值的比较是范围条件。此外，对于BTREE索引，当使用&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，BETWEEN，！&#x3D; 、或&lt;&gt;运算符，或者LIKE比较（如果LIKE的参数是不以小写字符开头的常量字符串）。对于所有索引类型，多个范围条件与OR或AND组合形成范围条件。</li>
<li>index merge优化：index merge就是多个索引并发扫描，再将扫描结果合并。</li>
<li>hash join优化：使用hash join来代替Nested Loop Join算法，能大幅度提升join速度。</li>
<li>Is Null优化：可以对<code>where a is null</code>这种条件进行优化，比如该字段设置了<code>not null</code>，那么这个条件就会被删除。</li>
<li>order by + limit优化：使用<code>Top N</code>排序</li>
<li>group by 优化：优化group by语句。</li>
<li>子查询物化：将子查询的内容物化保存起来。</li>
</ul>
</li>
<li>通过成本模型、直方图等信息生成不同的执行路径。</li>
<li>对比执行路径的内容，如取样等，进行选择最终的执行路径。生成查询计划。</li>
</ul>
<p>这里简单的介绍一些mysql内部的优化器，以了解mysql内部做了哪些优化手段。</p>
<p>最后会介绍mysql的成本模型、直方图信息等。结合实际的例子来给大家展示索引选择的问题。</p>
<h4 id="谓词下推优化"><a href="#谓词下推优化" class="headerlink" title="谓词下推优化"></a>谓词下推优化</h4><p>谓词下推优化（Predicate Pushdown Optimization）是一种查询优化技术，它将查询中的过滤条件（谓词）尽可能地推送到数据访问的早期阶段，以减少数据扫描的范围，从而提高查询性能。<br>在数据库查询中，谓词通常是指WHERE子句中的条件。谓词下推优化的目的是让这些条件在数据被读取或处理的早期阶段就发挥作用，避免不必要的数据处理和传输。</p>
<p>在没有谓词下推优化的情况下，数据库会先读取所有数据，然后在内存中应用过滤条件。这可能导致大量的数据被加载到内存中，增加了I&#x2F;O操作和内存使用。<br>通过谓词下推优化，数据库会在数据读取阶段就应用过滤条件，只加载满足条件的数据，从而减少数据的读取量和处理量。</p>
<p>假设存在<code>table_a</code>表，表里面有10条数据，<code>a = 1</code>的数据有一个，具体什么意思呢，我们来看一个SQL语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a,b <span class="keyword">from</span> table_a <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>如果没有谓词下推优化的话，执行树如下。</p>
<p><img src="/../images/mysql/mysql2-4.png" alt="架构"></p>
<p>其执行顺序如下：</p>
<ol>
<li>扫描<code>table_a</code>表的10条数据，将10条数据传递给where过滤节点。</li>
<li>where过滤操作进行过滤，过滤出<code>a = 1</code>条件的1条数据，将这个数据传递给列选择节点。</li>
<li>列选择节点选择这条数据的2列，将结果返回。</li>
</ol>
<p>其内存中要存储10条数据。</p>
<p>而有了谓词下推优化以后，执行树如下。</p>
<p><img src="/../images/mysql/mysql2-5.png" alt="架构"></p>
<p>执行顺序如下：</p>
<ol>
<li>扫描<code>table_a</code>表的10条数据，过滤出符合<code>a = 1</code>条件的这一个数据。将这个数据传给列选择节点。</li>
<li>列选择节点选择这条数据的2列，将结果返回。</li>
</ol>
<h4 id="范围优化"><a href="#范围优化" class="headerlink" title="范围优化"></a>范围优化</h4><p>对于BTREE和HASH索引，当使用&#x3D;、&lt;&#x3D;&gt;、IN（）、IS NULL或IS NOT NULL运算符时，键部分与常量值的比较是范围条件。此外，对于BTREE索引，当使用&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，BETWEEN，！&#x3D; 、或&lt;&gt;运算符，或者LIKE比较（如果LIKE的参数是不以小写字符开头的常量字符串）。对于所有索引类型，多个范围条件与OR或AND组合形成范围条件。</p>
<p>给定数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key_part1  key_part2  key_part3</span><br><span class="line">  NULL       1          &#x27;abc&#x27;</span><br><span class="line">  NULL       1          &#x27;xyz&#x27;</span><br><span class="line">  NULL       2          &#x27;foo&#x27;</span><br><span class="line">   1         1          &#x27;abc&#x27;</span><br><span class="line">   1         1          &#x27;xyz&#x27;</span><br><span class="line">   1         2          &#x27;abc&#x27;</span><br><span class="line">   2         1          &#x27;aaa&#x27;</span><br></pre></td></tr></table></figure>

<p>执行where key_part1&#x3D; 1，其扫描范围为 1,负无穷，负无穷到 1,正无穷，正无穷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1,-inf,-inf) &lt;= (key_part1,key_part2,key_part3) &lt; (1,+inf,+inf)</span><br></pre></td></tr></table></figure>
<p>即覆盖了这三行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1         1          &#x27;abc&#x27;</span><br><span class="line">1         1          &#x27;xyz&#x27;</span><br><span class="line">1         2          &#x27;abc&#x27;</span><br></pre></td></tr></table></figure>

<p>index dives，优化器在范围的两端进行dives, 可以帮助优化器更准确的评估扫描的行数，index dives提供了更准确的行估计，但是随着比较值数量的增加，更加耗时，使用统计信息的准确性不如index dives，但允许对大值列表进行更快的行估计。</p>
<p>eq_range_index_dive_limit系统变量使您能够配置优化器从一个行估计策略切换到另一个行估计策略时的值数量。要允许使用索引潜水来比较最多N个相等范围，请将eq_range_index_dive_limit设置为N+ 1。要禁用统计信息并始终使用索引潜水而不管N，请将eq_range_index_dive_limit设置为0。</p>
<p>若要更新表索引统计信息以获得最佳估计值，请使用ANALYZE TABLE。</p>
<p>skip scan,比如有索引(f1,f2)，都知道最左前缀原则，所以一般where f2 &gt; 40是不走索引的，skip scan可以让他走索引，通过构造f1 &#x3D; 1 and f2 &gt; 40，扫描完以后再扫描 f1 &#x3D; 2 and f2 &gt; 40，以此类推，可以通过explain来看extra列是否有skip scan</p>
<p>in优化，in查询可以用如下形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ... FROM t1 WHERE ( col_1, col_2 ) IN (( &#x27;a&#x27;, &#x27;b&#x27; ), ( &#x27;c&#x27;, &#x27;d&#x27; ));</span><br></pre></td></tr></table></figure>

<p>range_optimizer_max_size_size系统变量可以设置优化器使用的内存</p>
<h4 id="index-merge-优化"><a href="#index-merge-优化" class="headerlink" title="index merge 优化"></a>index merge 优化</h4><p>index merge就是多个索引并发扫描，再将扫描结果合并</p>
<p>索引合并不适用于全文索引。</p>
<p>索引合并访问方法检索具有多个范围扫描的行，并将其结果合并为一个。此访问方法只合并单个表的索引扫描，而不合并多个表的扫描。合并可以产生其底层扫描的并集、交集或交集的并集。</p>
<p>可以使用索引合并的查询示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tbl_name WHERE key1 = 10 OR key2 = 20;</span><br><span class="line"></span><br><span class="line">SELECT * FROM tbl_name</span><br><span class="line">  WHERE (key1 = 10 OR key2 = 20) AND non_key = 30;</span><br><span class="line"></span><br><span class="line">SELECT * FROM t1, t2</span><br><span class="line">  WHERE (t1.key1 IN (1,2) OR t1.key2 LIKE &#x27;value%&#x27;)</span><br><span class="line">  AND t2.key1 = t1.some_col;</span><br><span class="line"></span><br><span class="line">SELECT * FROM t1, t2</span><br><span class="line">  WHERE t1.key1 = 1</span><br><span class="line">  AND (t2.key1 = t1.some_col OR t2.key2 = t1.some_col2);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你的查询有一个带有深度AND&#x2F;OR嵌套的复杂WHERE子句，并且MySQL没有选择最佳计划，请尝试使用以下恒等转换来分发术语：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(x AND y) OR z =&gt; (x OR z) AND (y OR z)</span><br><span class="line">(x OR y) AND z =&gt; (x AND z) OR (y AND z)</span><br></pre></td></tr></table></figure>

<p>在EXPLAIN输出中，Index Merge方法在type列中显示为index_merge。在本例中，key列包含使用的索引列表，key_len包含这些索引的最长键部分列表。</p>
<p>索引合并访问方法有几种算法，它们显示在EXPLAIN输出的Extra字段中：</p>
<ul>
<li>intersect：对多个and条件生效</li>
<li>union：对多个or条件生效</li>
<li>sort_union：sort-union算法和union算法之间的区别在于，sort-union算法必须首先获取所有行的行ID，并在返回任何行之前对其进行排序。</li>
</ul>
<p>索引合并的使用取决于optimizer_switch系统变量的index_merge、index_merge_intersection、index_merge_union和index_merge_sort_union标志的值。默认情况下，所有这些标志都是打开的。</p>
<h4 id="hash-join"><a href="#hash-join" class="headerlink" title="hash join"></a>hash join</h4><p>默认情况下，MySQL尽可能使用哈希连接。可以使用BNL和NO_BNL优化器提示之一来控制是否使用散列连接。</p>
<p>hash join比嵌套join快的多，首先创建hash表，在循环另一个表进行hash，判断是否相等</p>
<p>可以使用join_buffer_size系统变量控制哈希连接的内存使用量;哈希连接使用的内存量不能超过此值。当哈希连接所需的内存超过可用量时，MySQL会使用磁盘上的文件来处理。如果发生这种情况，您应该注意，如果哈希连接无法容纳内存并且它创建的文件比为open_files_limit设置的文件多，则连接可能不会成功。要避免此类问题，请进行以下更改之一：</p>
<ul>
<li>增加join_buffer_size，使哈希连接不会溢出到磁盘。</li>
<li>增加open_files_limit。</li>
</ul>
<h4 id="成本模型"><a href="#成本模型" class="headerlink" title="成本模型"></a>成本模型</h4><p>MySQL成本模型（Cost Model）是MySQL查询优化器（Query Optimizer）用来评估不同查询执行计划的成本（Cost）的一种机制。成本模型通过估算每种执行计划所需的资源（如CPU、I&#x2F;O、内存等）来选择最优的执行计划。</p>
<p>MySQL的成本模型主要考虑以下几个方面：</p>
<ol>
<li>CPU成本：<ul>
<li>评估执行计划中每个操作（如比较、计算、排序等）所需的CPU时间。</li>
<li>例如，WHERE子句中的条件计算、JOIN操作中的匹配等。</li>
</ul>
</li>
<li>I&#x2F;O成本：<ul>
<li>评估执行计划中每个操作所需的磁盘I&#x2F;O操作次数。</li>
<li>例如，全表扫描、索引扫描、数据页的读取等。</li>
<li>I&#x2F;O成本通常是最主要的成本因素之一，因为磁盘I&#x2F;O操作相对较慢。</li>
</ul>
</li>
<li>内存成本：<ul>
<li>评估执行计划中每个操作所需的内存使用量。</li>
<li>例如，排序操作、临时表的创建等。</li>
</ul>
</li>
<li>网络成本：<ul>
<li>评估执行计划中每个操作所需的网络传输量。</li>
<li>例如，分布式查询中跨节点的数据传输。</li>
</ul>
</li>
<li>数据分布：<ul>
<li>评估数据的分布情况，如表的大小、索引的覆盖率等。</li>
<li>数据分布会影响I&#x2F;O操作的次数和效率。</li>
</ul>
</li>
</ol>
<p>其中大部分的成本都是固定的，比如CPU成本、IO成本、内存成本。这个是根据你服务器的配置决定的。</p>
<p>所以，主要关注的是数据分布。</p>
<p>MySQL的数据分布使用<code>直方图</code>来记录。</p>
<h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h4><p><code>column_statistics数据字典表</code>存储有关列值的<code>直方图</code>统计信息，供优化器在构造查询执行计划时使用。要执行直方图管理，请使用<code>ANALYZE TABLE</code>语句。</p>
<ul>
<li>该表包含除几何类型（空间数据）和JSON之外的所有数据类型的列的统计信息。</li>
<li>该表是持久的，因此不必在每次服务器启动时都创建列统计信息。</li>
<li>服务器对表执行更新，用户不执行。</li>
</ul>
<p>用户不能直接访问<code>column_statistics</code>表，因为它是<code>数据字典</code>的一部分。直方图信息可使用 <code>INFORMATION_SCHEMA.COLUMN_STATISTICS</code> 获得，它是作为数据字典表上的视图实现的。<code>COLUMN_STATISTICS</code>包含以下列：</p>
<ul>
<li>SCHEMA_NAME、TABLE_NAME、COLUMN_NAME：应用统计信息的模式、表和列的名称。</li>
<li>HISTORIO：描述列统计信息的JSON值，存储为直方图。</li>
</ul>
<p>直方图实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;buckets&quot;: [</span><br><span class="line">    [</span><br><span class="line">      1,</span><br><span class="line">      0.3333333333333333</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      2,</span><br><span class="line">      0.6666666666666666</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      3,</span><br><span class="line">      1</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  &quot;null-values&quot;: 0,</span><br><span class="line">  &quot;last-updated&quot;: &quot;2017-03-24 13:32:40.000000&quot;,</span><br><span class="line">  &quot;sampling-rate&quot;: 1,</span><br><span class="line">  &quot;histogram-type&quot;: &quot;singleton&quot;,</span><br><span class="line">  &quot;number-of-buckets-specified&quot;: 128,</span><br><span class="line">  &quot;data-type&quot;: &quot;int&quot;,</span><br><span class="line">  &quot;collation-id&quot;: 8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>buckets：直方图桶。桶结构取决于直方图类型。</li>
<li>null-values：一个介于0.0和1.0之间的数字，表示<code>SQL NULL</code>值的列值的分数。如果为0，则该列不包含NULL值。</li>
<li>last-updated：直方图生成时，以 <code>YYYY-MM-DD hh:mm:ss.uuuuuu</code> 格式的UTC值表示。</li>
<li>sampling-rate：0.0到1.0之间的数字，表示为创建直方图而采样的数据比例。值为1表示已读取所有数据（无采样）。</li>
<li>histogram-type：直方图类型：<ul>
<li>singleton：一个bucket表示列中的一个值。当列中的非重复值数量小于或等于生成直方图的<code>ANALYZE TABLE</code>语句中指定的存储桶数量时，将创建此直方图类型。</li>
<li>equi-height：一个桶表示一个值范围。当列中的非重复值数量大于生成直方图的<code>ANALYZE TABLE</code>语句中指定的存储桶数量时，将创建此直方图类型。</li>
</ul>
</li>
<li>number-of-buckets-specified：生成直方图的<code>ANALYZE TABLE</code>语句中指定的<code>桶数</code>。</li>
<li>data-type：此直方图包含的数据类型。在将直方图从持久性存储器阅读和解析到内存中时，这是需要的。该值是int、uint（无符号整数）、double、decimal、datetime或string（包括字符和二进制字符串）之一。</li>
<li>collation-id：直方图数据的归类ID。当数据类型值是字符串时，它最有意义。值对应于信息架构<code>COLLATIONS</code>表中的ID列值。</li>
</ul>
<p>直方图统计信息主要用于非索引列。将索引添加到直方图统计信息适用的列还可以帮助优化器进行行估计。</p>
<p>优化器更喜欢范围优化器的行估计，而不是从直方图统计信息中获得的行估计。如果优化器确定范围优化器适用，则不使用直方图统计信息。</p>
<p>对于已建立索引的列，可以使用索引潜水(index dives)获得行估计值以进行相等比较。</p>
<p>在某些情况下，使用直方图统计信息可能不会改善查询执行（例如，如果统计信息过期）。要检查是否是这种情况，请使用<code>ANALYZE TABLE</code>重新生成直方图统计信息，然后再次运行查询。</p>
<p>这么看这些概念内容，可能很难理解直方图到底是干啥的，下面给出一个例子方便理解。</p>
<h5 id="直方图示例"><a href="#直方图示例" class="headerlink" title="直方图示例"></a>直方图示例</h5><h2 id="虽然直方图的字段很多，但其核心的字段只有几个"><a href="#虽然直方图的字段很多，但其核心的字段只有几个" class="headerlink" title="虽然直方图的字段很多，但其核心的字段只有几个"></a>虽然直方图的字段很多，但其核心的字段只有几个</h2><p>创建一个测试表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_a(id <span class="type">int</span> auto_increment,a <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span>, b <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>, <span class="keyword">primary</span> key(id));</span><br></pre></td></tr></table></figure>

<p>接下来我们插入几个数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_a (a, b) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;A1&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;B2&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;C3&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;D4&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;E5&#x27;</span>),</span><br><span class="line">(<span class="number">6</span>, <span class="string">&#x27;F6&#x27;</span>),</span><br><span class="line">(<span class="number">7</span>, <span class="string">&#x27;G7&#x27;</span>),</span><br><span class="line">(<span class="number">8</span>, <span class="string">&#x27;H8&#x27;</span>),</span><br><span class="line">(<span class="number">9</span>, <span class="string">&#x27;I9&#x27;</span>),</span><br><span class="line">(<span class="number">10</span>, <span class="string">&#x27;J10&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>接下来生成直方图信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ANALYZE <span class="keyword">TABLE</span> test_a <span class="keyword">update</span>  HISTOGRAM <span class="keyword">ON</span> a <span class="keyword">WITH</span> <span class="number">5</span> BUCKETS;</span><br></pre></td></tr></table></figure>

<p>查询直方图信息。这里的<code>SCHEMA_NAME</code>是数据库的名称，TABLE_NAME是数据表的名称。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.COLUMN_STATISTICS <span class="keyword">where</span> SCHEMA_NAME <span class="operator">=</span> <span class="string">&#x27;test1&#x27;</span> <span class="keyword">and</span> TABLE_NAME <span class="operator">=</span> <span class="string">&#x27;test_a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>查询结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+-------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> SCHEMA_NAME <span class="operator">|</span> TABLE_NAME <span class="operator">|</span> COLUMN_NAME <span class="operator">|</span> HISTOGRAM</span><br><span class="line">                                                                                                                                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+-------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> test1       <span class="operator">|</span> test_a     <span class="operator">|</span> a           <span class="operator">|</span> &#123;&quot;buckets&quot;: [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0.2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">0.4</span>, <span class="number">2</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">0.6</span>, <span class="number">2</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">0.8</span>, <span class="number">2</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">1.0</span>, <span class="number">2</span>]], &quot;data-type&quot;: &quot;int&quot;, &quot;auto-update&quot;: <span class="literal">false</span>, &quot;null-values&quot;: <span class="number">0.0</span>, &quot;collation-id&quot;: <span class="number">8</span>, &quot;last-updated&quot;: &quot;2025-01-25 13:01:57.129967&quot;, &quot;sampling-rate&quot;: <span class="number">1.0</span>, &quot;histogram-type&quot;: &quot;equi-height&quot;, &quot;number-of-buckets-specified&quot;: <span class="number">5</span>&#125; <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+-------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>我们来看一下直方图的信息。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;buckets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">0.4</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">0.6</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">7</span><span class="punctuation">,</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">9</span><span class="punctuation">,</span> <span class="number">10</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;data-type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;int&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;auto-update&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;null-values&quot;</span><span class="punctuation">:</span> <span class="number">0.0</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;collation-id&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;last-updated&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2025-01-25 13:01:57.129967&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;sampling-rate&quot;</span><span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;histogram-type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;equi-height&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;number-of-buckets-specified&quot;</span><span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>buckets：直方图桶。桶结构取决于直方图类型。</li>
<li>null-values：0.0,表示没有null值，这是因为我们使用了<code>not null</code>声明字段。</li>
<li>last-updated：更新时间，没啥好说的。</li>
<li>sampling-rate：1.0 获取了所有数据，因为我们只有10条数据，很少。</li>
<li>histogram-type：直方图类型：equi-height，因为<code>a</code>列有10个值，都不重复，而桶数量我们用的是5，所以生成了这个类型。</li>
<li>number-of-buckets-specified：生成直方图的<code>ANALYZE TABLE</code>语句中指定的<code>桶数</code>。</li>
<li>data-type：列a是int类型</li>
<li>collation-id：直方图数据的归类ID。当数据类型值是字符串时，它最有意义。值对应于信息架构<code>COLLATIONS</code>表中的ID列值。</li>
</ul>
<p>桶里面有4个数据</p>
<ul>
<li>最小值</li>
<li>最大值</li>
<li>密度</li>
<li>高度</li>
</ul>
<p>比如，查询语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_a <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><code>a = 5</code>的数据在第三个桶里面，最小值5，最大值6，密度0.6，高度2.</p>
<p>根据计算公式<code>预估行数 = 密度 * 高度</code>来计算0.6 * 2，预估行数就是1.2，也就是1-2行。</p>
<p><img src="/../images/mysql/mysql2-6.jpg" alt="架构"></p>
<p>可以看到查询计划里面的rows是10行，这是因为类型是全表扫描，但是后面的<code>filtered</code>字段是10，表示的意思是会过滤出来 <code>10 * 10% = 10 * 0.1 = 1</code>行。</p>
<p>也就是最终会查出1行结果。</p>
<p>通常来说，对于没有索引的列，MySQL就是这样来预估行数的，并且通过这个结果来进行选择执行路线。</p>
<h3 id="执行路线选择"><a href="#执行路线选择" class="headerlink" title="执行路线选择"></a>执行路线选择</h3><p>什么叫路线选择呢，还是上面那个表，我们现在有如下SQL语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a,b <span class="keyword">from</span> test_a <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> b <span class="operator">=</span> <span class="string">&#x27;A1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>根据表数据，其实我们知道，查出来的结果还是1条。但是对于mysql来说，却有不同的执行方式。</p>
<p>第一种执行方式，先查<code>a=1</code>在查询<code>b=&#39;A1&#39;</code>的数据。执行树如下。</p>
<p><img src="/../images/mysql/mysql2-7.jpg" alt="架构"></p>
<p>第二种执行方式，先查<code>b=&#39;A1&#39;</code>在查询 <code>a=1</code>。执行树如下。</p>
<p><img src="/../images/mysql/mysql2-8.jpg" alt="架构"></p>
<p>目前看着这两种方式都没啥问题。</p>
<p>但是，我们再插入一条数据呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_a (a, b) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">11</span>, <span class="string">&#x27;A1&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这样我们就知道了，方案1， 会直接过滤出1行数据，然后在过滤，这样显然比方案2更好。</p>
<p>因为方案2会先查出2条数据，再次过滤。</p>
<p>这就是不同的执行路线带来的性能区别。当然了，我们这里的例子只是打个比方，实际上<code>谓词下推</code>优化以后，这两个条件都是和扫描表一起执行的。</p>
<p>这个例子只是让你明白不同的路线选择而已。</p>
<p>对于<code>join</code>查询来说，会有更多的选择。</p>
<h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>以上就是今天的内容了，大家有任何疑问可以打在评论区，一起交流～</p>
<p>关注我发送“MySQL知识图谱”领取完整的MySQL学习路线。</p>
<p>发送“电子书”即可领取价值上千的电子书资源。</p>
<p>部分电子书如图所示。</p>
<p><img src="/../images/bottom1.png" alt="概念学习"></p>
<p><img src="/../images/bottom2.png" alt="概念学习"></p>
<p><img src="/../images/bottom3.png" alt="概念学习"></p>
<p><img src="/../images/bottom4.png" alt="概念学习"></p>
]]></content>
      <categories>
        <category>CMU15445</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL查询路径选择</title>
    <url>/MySQL%E6%9F%A5%E8%AF%A2%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9.html</url>
    <content><![CDATA[<h1 id="MySQL查询路径选择"><a href="#MySQL查询路径选择" class="headerlink" title="MySQL查询路径选择"></a>MySQL查询路径选择</h1><p>大家好，我是大头，98年，职高毕业，上市公司架构师，大厂资深开发，管理过10人团队，我是如何做到的呢？</p>
<p>这离不开持续学习的能力，而其中最重要的当然是数据库技术了！</p>
<p>对于所有开发来说，都离不开数据库，因为所有的数据都是要存储的。</p>
<p>关注我一起学习！文末有惊喜哦！</p>
<h2 id="什么是MySQL查询路径？"><a href="#什么是MySQL查询路径？" class="headerlink" title="什么是MySQL查询路径？"></a>什么是MySQL查询路径？</h2><p>MySQL查询路径是指查询优化器在执行查询时所选择的具体执行步骤和顺序。查询优化器的目标是找到最高效的方式来执行查询，以最小化资源消耗（如CPU、I&#x2F;O、内存等）和查询响应时间。查询路径包括以下几个关键阶段：</p>
<ol>
<li>解析（Parsing）：</li>
</ol>
<ul>
<li>将SQL语句解析成内部的逻辑结构，如语法树（Syntax Tree）。</li>
<li>检查SQL语句的语法是否正确。</li>
</ul>
<ol start="2">
<li>预处理（Preprocessing）：</li>
</ol>
<ul>
<li>检查用户是否有权限执行该查询。</li>
<li>检查表和列是否存在。</li>
<li>重写查询，如展开视图、处理子查询等。</li>
</ul>
<ol start="3">
<li>优化（Optimization）：</li>
</ol>
<ul>
<li>查询优化器评估不同的执行计划，选择最优的执行路径。</li>
<li>优化器会考虑索引、表的大小、数据分布等因素。</li>
<li>生成执行计划，决定如何访问表、如何连接表、如何过滤数据等。</li>
</ul>
<ol start="4">
<li>执行（Execution）：</li>
</ol>
<ul>
<li>按照优化器生成的执行计划，实际执行查询。</li>
<li>包括表扫描、索引扫描、连接操作、过滤操作等。</li>
</ul>
<ol start="5">
<li>结果返回（Result Returning）：</li>
</ol>
<ul>
<li>将查询结果返回给客户端。</li>
</ul>
<h3 id="查询路径的详细分析"><a href="#查询路径的详细分析" class="headerlink" title="查询路径的详细分析"></a>查询路径的详细分析</h3><ol>
<li>解析（Parsing）</li>
</ol>
<p>解析阶段将SQL语句转换为内部的逻辑结构。例如，对于查询SELECT a, b FROM test_a WHERE a &#x3D; 1 AND b &#x3D; ‘A1’;，解析器会将其解析为一个查询树，包含以下信息：</p>
<ul>
<li>查询类型：SELECT</li>
<li>查询的列：a, b</li>
<li>查询的表：test_a</li>
<li>查询的条件：a &#x3D; 1 AND b &#x3D; ‘A1’</li>
</ul>
<ol start="2">
<li>预处理（Preprocessing）</li>
</ol>
<p>预处理阶段会检查用户是否有权限执行该查询，表和列是否存在，以及是否需要重写查询。例如：</p>
<ul>
<li>如果test_a表不存在，查询会失败。</li>
<li>如果用户没有权限访问test_a表，查询会失败。</li>
<li>如果查询中包含子查询或视图，预处理器会将其展开。</li>
</ul>
<ol start="3">
<li>优化（Optimization）</li>
</ol>
<p>优化阶段是查询路径中最关键的部分。查询优化器会评估不同的执行计划，选择最优的执行路径。优化器考虑的因素包括：</p>
<ul>
<li>索引：是否有可用的索引，以及索引是否能有效过滤数据。</li>
<li>表的大小：表的大小会影响全表扫描的成本。</li>
<li>数据分布：数据的分布情况会影响过滤条件的效率。</li>
<li>连接顺序：如果有多个表连接，优化器会决定最佳的连接顺序。</li>
</ul>
<p>优化器会生成一个执行计划，描述如何执行查询。例如，对于查询SELECT a, b FROM test_a WHERE a &#x3D; 1 AND b &#x3D; ‘A1’;，优化器可能会生成以下执行计划：</p>
<ul>
<li>使用a列上的索引idx_a来定位满足条件a &#x3D; 1的行。</li>
<li>在这些行中进一步过滤满足条件b &#x3D; ‘A1’的行。</li>
</ul>
<ol start="4">
<li>执行（Execution）</li>
</ol>
<p>执行阶段按照优化器生成的执行计划，实际执行查询。例如：</p>
<ul>
<li>如果优化器选择使用a列上的索引idx_a，执行器会先扫描索引，找到满足条件a &#x3D; 1的行。</li>
<li>然后在这些行中进一步过滤满足条件b &#x3D; ‘A1’的行。</li>
<li>最终将结果返回给客户端。</li>
</ul>
<ol start="5">
<li>结果返回（Result Returning）</li>
</ol>
<p>执行器将查询结果返回给客户端。客户端可以是MySQL客户端工具、应用程序等。</p>
<h3 id="mysql架构"><a href="#mysql架构" class="headerlink" title="mysql架构"></a>mysql架构</h3><p>这里就要介绍一下MySQL的整体架构了。</p>
<p><img src="/../images/mysql/mysql2-1.png" alt="架构"></p>
<ul>
<li>连接器：MySQL连接器（MySQL Connector）是用于连接MySQL数据库的客户端库，它允许应用程序与MySQL数据库进行通信。这些连接器提供了API（应用程序编程接口），使得开发者可以在各种编程语言中轻松地执行SQL语句、管理数据库连接、处理查询结果等。</li>
<li>分析器：MySQL分析器才算真正进入了MySQL里面。它会分析词法和语法，如果你的SQL语句不对，就会看到一些报错，例如语法错误。</li>
<li>优化器：MySQL优化器是本文的重点内容，因为这里涉及了MySQL的一些优化，其中就包括了索引选择，也是导致索引失效的重要原因。在这一步也就确定了查询计划。</li>
<li>执行器：MySQL执行器会根据优化器输出的查询计划来执行这个查询计划，会调用底层的存储引擎进行执行。</li>
<li>存储引擎：MySQL支持多种存储引擎，每个存储引擎有不同的特点。其中InnoDB引擎因为支持事务等优点，现在是MySQL的默认存储引擎。</li>
</ul>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>MySQL连接器（MySQL Connector）是用于连接MySQL数据库的客户端库，它允许应用程序与MySQL数据库进行通信。这些连接器提供了API（应用程序编程接口），使得开发者可以在各种编程语言中轻松地执行SQL语句、管理数据库连接、处理查询结果等。</p>
<p>当我们最开始连接数据库实例的时候，我们要输入用户名密码，这时候连接器会从数据库的用户信息中判断你是否有权限连接数据库进行操作，有哪些权限。</p>
<p>如果你输入的用户名密码错误或者没有权限，那么你会收到下面的报错信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Access denied <span class="keyword">for</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>(<span class="keyword">using</span> password: YES)</span><br></pre></td></tr></table></figure>

<p><img src="/../images/mysql/mysql2-2.png" alt="架构"></p>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>连接成功以后。分析器会分析这个语句的词法，语法，语义这些信息。</p>
<p>通俗来讲就是看到select,update这些关键字，知道你要来干啥，看看你是不是来搞破坏的，来捣蛋的。</p>
<p>看看你是查询哪个表啊，有什么条件啊，这些玩意。</p>
<p>最后会输出一个词法树。</p>
<p>当然了这一步还会分析你的语法有没有错误，比如你把select打错试试。打成elect，会出现下面的报错信息</p>
<blockquote>
<p>You have an error in your SQL syntax: check the maual that corresponds to your MySQL server version for the right syntax to use near ‘elect * from users’ at line 1</p>
</blockquote>
<p><img src="/../images/mysql/mysql2-3.png" alt="架构"></p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>优化器负责几个事情</p>
<ul>
<li>优化SQL：比如你写了一个很不友好的SQL，如<code>select * from a where 1 =1</code>,优化器会将1&#x3D;1去掉。还有比如括号的删除，如<code>select * from a where ((a AND b) AND c OR (((a AND b) AND (c AND d))))</code>改写成<code>select * from a where (a AND b AND c) OR (a AND b AND c AND d)</code>。等等。</li>
<li>一些内部的优化器：下面列出的是部分，更多的可以参考<a href="https://dev.mysql.com/doc/refman/8.4/en/optimization.html">MySQL官方文档优化器部分</a><ul>
<li>谓词下推：即where条件下推到扫描表的时候执行，而不是扫描表之后执行。</li>
<li>范围优化：对于BTREE和HASH索引，当使用&#x3D;、&lt;&#x3D;&gt;、IN（）、IS NULL或IS NOT NULL运算符时，键部分与常量值的比较是范围条件。此外，对于BTREE索引，当使用&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，BETWEEN，！&#x3D; 、或&lt;&gt;运算符，或者LIKE比较（如果LIKE的参数是不以小写字符开头的常量字符串）。对于所有索引类型，多个范围条件与OR或AND组合形成范围条件。</li>
<li>index merge优化：index merge就是多个索引并发扫描，再将扫描结果合并。</li>
<li>hash join优化：使用hash join来代替Nested Loop Join算法，能大幅度提升join速度。</li>
<li>Is Null优化：可以对<code>where a is null</code>这种条件进行优化，比如该字段设置了<code>not null</code>，那么这个条件就会被删除。</li>
<li>order by + limit优化：使用<code>Top N</code>排序</li>
<li>group by 优化：优化group by语句。</li>
<li>子查询物化：将子查询的内容物化保存起来。</li>
</ul>
</li>
<li>通过成本模型、直方图等信息生成不同的执行路径。</li>
<li>对比执行路径的内容，如取样等，进行选择最终的执行路径。生成查询计划。</li>
</ul>
<p>这里简单的介绍一些mysql内部的优化器，以了解mysql内部做了哪些优化手段。</p>
<p>最后会介绍mysql的成本模型、直方图信息等。结合实际的例子来给大家展示索引选择的问题。</p>
<h4 id="谓词下推优化"><a href="#谓词下推优化" class="headerlink" title="谓词下推优化"></a>谓词下推优化</h4><p>谓词下推优化（Predicate Pushdown Optimization）是一种查询优化技术，它将查询中的过滤条件（谓词）尽可能地推送到数据访问的早期阶段，以减少数据扫描的范围，从而提高查询性能。<br>在数据库查询中，谓词通常是指WHERE子句中的条件。谓词下推优化的目的是让这些条件在数据被读取或处理的早期阶段就发挥作用，避免不必要的数据处理和传输。</p>
<p>在没有谓词下推优化的情况下，数据库会先读取所有数据，然后在内存中应用过滤条件。这可能导致大量的数据被加载到内存中，增加了I&#x2F;O操作和内存使用。<br>通过谓词下推优化，数据库会在数据读取阶段就应用过滤条件，只加载满足条件的数据，从而减少数据的读取量和处理量。</p>
<p>假设存在<code>table_a</code>表，表里面有10条数据，<code>a = 1</code>的数据有一个，具体什么意思呢，我们来看一个SQL语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a,b <span class="keyword">from</span> table_a <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>如果没有谓词下推优化的话，执行树如下。</p>
<p><img src="/../images/mysql/mysql2-4.png" alt="架构"></p>
<p>其执行顺序如下：</p>
<ol>
<li>扫描<code>table_a</code>表的10条数据，将10条数据传递给where过滤节点。</li>
<li>where过滤操作进行过滤，过滤出<code>a = 1</code>条件的1条数据，将这个数据传递给列选择节点。</li>
<li>列选择节点选择这条数据的2列，将结果返回。</li>
</ol>
<p>其内存中要存储10条数据。</p>
<p>而有了谓词下推优化以后，执行树如下。</p>
<p><img src="/../images/mysql/mysql2-5.png" alt="架构"></p>
<p>执行顺序如下：</p>
<ol>
<li>扫描<code>table_a</code>表的10条数据，过滤出符合<code>a = 1</code>条件的这一个数据。将这个数据传给列选择节点。</li>
<li>列选择节点选择这条数据的2列，将结果返回。</li>
</ol>
<h4 id="范围优化"><a href="#范围优化" class="headerlink" title="范围优化"></a>范围优化</h4><p>对于BTREE和HASH索引，当使用&#x3D;、&lt;&#x3D;&gt;、IN（）、IS NULL或IS NOT NULL运算符时，键部分与常量值的比较是范围条件。此外，对于BTREE索引，当使用&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，BETWEEN，！&#x3D; 、或&lt;&gt;运算符，或者LIKE比较（如果LIKE的参数是不以小写字符开头的常量字符串）。对于所有索引类型，多个范围条件与OR或AND组合形成范围条件。</p>
<p>给定数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key_part1  key_part2  key_part3</span><br><span class="line">  NULL       1          &#x27;abc&#x27;</span><br><span class="line">  NULL       1          &#x27;xyz&#x27;</span><br><span class="line">  NULL       2          &#x27;foo&#x27;</span><br><span class="line">   1         1          &#x27;abc&#x27;</span><br><span class="line">   1         1          &#x27;xyz&#x27;</span><br><span class="line">   1         2          &#x27;abc&#x27;</span><br><span class="line">   2         1          &#x27;aaa&#x27;</span><br></pre></td></tr></table></figure>

<p>执行where key_part1&#x3D; 1，其扫描范围为 1,负无穷，负无穷到 1,正无穷，正无穷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1,-inf,-inf) &lt;= (key_part1,key_part2,key_part3) &lt; (1,+inf,+inf)</span><br></pre></td></tr></table></figure>
<p>即覆盖了这三行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1         1          &#x27;abc&#x27;</span><br><span class="line">1         1          &#x27;xyz&#x27;</span><br><span class="line">1         2          &#x27;abc&#x27;</span><br></pre></td></tr></table></figure>

<p>index dives，优化器在范围的两端进行dives, 可以帮助优化器更准确的评估扫描的行数，index dives提供了更准确的行估计，但是随着比较值数量的增加，更加耗时，使用统计信息的准确性不如index dives，但允许对大值列表进行更快的行估计。</p>
<p>eq_range_index_dive_limit系统变量使您能够配置优化器从一个行估计策略切换到另一个行估计策略时的值数量。要允许使用索引潜水来比较最多N个相等范围，请将eq_range_index_dive_limit设置为N+ 1。要禁用统计信息并始终使用索引潜水而不管N，请将eq_range_index_dive_limit设置为0。</p>
<p>若要更新表索引统计信息以获得最佳估计值，请使用ANALYZE TABLE。</p>
<p>skip scan,比如有索引(f1,f2)，都知道最左前缀原则，所以一般where f2 &gt; 40是不走索引的，skip scan可以让他走索引，通过构造f1 &#x3D; 1 and f2 &gt; 40，扫描完以后再扫描 f1 &#x3D; 2 and f2 &gt; 40，以此类推，可以通过explain来看extra列是否有skip scan</p>
<p>in优化，in查询可以用如下形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ... FROM t1 WHERE ( col_1, col_2 ) IN (( &#x27;a&#x27;, &#x27;b&#x27; ), ( &#x27;c&#x27;, &#x27;d&#x27; ));</span><br></pre></td></tr></table></figure>

<p>range_optimizer_max_size_size系统变量可以设置优化器使用的内存</p>
<h4 id="index-merge-优化"><a href="#index-merge-优化" class="headerlink" title="index merge 优化"></a>index merge 优化</h4><p>index merge就是多个索引并发扫描，再将扫描结果合并</p>
<p>索引合并不适用于全文索引。</p>
<p>索引合并访问方法检索具有多个范围扫描的行，并将其结果合并为一个。此访问方法只合并单个表的索引扫描，而不合并多个表的扫描。合并可以产生其底层扫描的并集、交集或交集的并集。</p>
<p>可以使用索引合并的查询示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tbl_name WHERE key1 = 10 OR key2 = 20;</span><br><span class="line"></span><br><span class="line">SELECT * FROM tbl_name</span><br><span class="line">  WHERE (key1 = 10 OR key2 = 20) AND non_key = 30;</span><br><span class="line"></span><br><span class="line">SELECT * FROM t1, t2</span><br><span class="line">  WHERE (t1.key1 IN (1,2) OR t1.key2 LIKE &#x27;value%&#x27;)</span><br><span class="line">  AND t2.key1 = t1.some_col;</span><br><span class="line"></span><br><span class="line">SELECT * FROM t1, t2</span><br><span class="line">  WHERE t1.key1 = 1</span><br><span class="line">  AND (t2.key1 = t1.some_col OR t2.key2 = t1.some_col2);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你的查询有一个带有深度AND&#x2F;OR嵌套的复杂WHERE子句，并且MySQL没有选择最佳计划，请尝试使用以下恒等转换来分发术语：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(x AND y) OR z =&gt; (x OR z) AND (y OR z)</span><br><span class="line">(x OR y) AND z =&gt; (x AND z) OR (y AND z)</span><br></pre></td></tr></table></figure>

<p>在EXPLAIN输出中，Index Merge方法在type列中显示为index_merge。在本例中，key列包含使用的索引列表，key_len包含这些索引的最长键部分列表。</p>
<p>索引合并访问方法有几种算法，它们显示在EXPLAIN输出的Extra字段中：</p>
<ul>
<li>intersect：对多个and条件生效</li>
<li>union：对多个or条件生效</li>
<li>sort_union：sort-union算法和union算法之间的区别在于，sort-union算法必须首先获取所有行的行ID，并在返回任何行之前对其进行排序。</li>
</ul>
<p>索引合并的使用取决于optimizer_switch系统变量的index_merge、index_merge_intersection、index_merge_union和index_merge_sort_union标志的值。默认情况下，所有这些标志都是打开的。</p>
<h4 id="hash-join"><a href="#hash-join" class="headerlink" title="hash join"></a>hash join</h4><p>默认情况下，MySQL尽可能使用哈希连接。可以使用BNL和NO_BNL优化器提示之一来控制是否使用散列连接。</p>
<p>hash join比嵌套join快的多，首先创建hash表，在循环另一个表进行hash，判断是否相等</p>
<p>可以使用join_buffer_size系统变量控制哈希连接的内存使用量;哈希连接使用的内存量不能超过此值。当哈希连接所需的内存超过可用量时，MySQL会使用磁盘上的文件来处理。如果发生这种情况，您应该注意，如果哈希连接无法容纳内存并且它创建的文件比为open_files_limit设置的文件多，则连接可能不会成功。要避免此类问题，请进行以下更改之一：</p>
<ul>
<li>增加join_buffer_size，使哈希连接不会溢出到磁盘。</li>
<li>增加open_files_limit。</li>
</ul>
<h4 id="成本模型"><a href="#成本模型" class="headerlink" title="成本模型"></a>成本模型</h4><p>MySQL成本模型（Cost Model）是MySQL查询优化器（Query Optimizer）用来评估不同查询执行计划的成本（Cost）的一种机制。成本模型通过估算每种执行计划所需的资源（如CPU、I&#x2F;O、内存等）来选择最优的执行计划。</p>
<p>MySQL的成本模型主要考虑以下几个方面：</p>
<ol>
<li>CPU成本：<ul>
<li>评估执行计划中每个操作（如比较、计算、排序等）所需的CPU时间。</li>
<li>例如，WHERE子句中的条件计算、JOIN操作中的匹配等。</li>
</ul>
</li>
<li>I&#x2F;O成本：<ul>
<li>评估执行计划中每个操作所需的磁盘I&#x2F;O操作次数。</li>
<li>例如，全表扫描、索引扫描、数据页的读取等。</li>
<li>I&#x2F;O成本通常是最主要的成本因素之一，因为磁盘I&#x2F;O操作相对较慢。</li>
</ul>
</li>
<li>内存成本：<ul>
<li>评估执行计划中每个操作所需的内存使用量。</li>
<li>例如，排序操作、临时表的创建等。</li>
</ul>
</li>
<li>网络成本：<ul>
<li>评估执行计划中每个操作所需的网络传输量。</li>
<li>例如，分布式查询中跨节点的数据传输。</li>
</ul>
</li>
<li>数据分布：<ul>
<li>评估数据的分布情况，如表的大小、索引的覆盖率等。</li>
<li>数据分布会影响I&#x2F;O操作的次数和效率。</li>
</ul>
</li>
</ol>
<p>其中大部分的成本都是固定的，比如CPU成本、IO成本、内存成本。这个是根据你服务器的配置决定的。</p>
<p>所以，主要关注的是数据分布。</p>
<p>MySQL的数据分布使用<code>直方图</code>来记录。</p>
<h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h4><p><code>column_statistics数据字典表</code>存储有关列值的<code>直方图</code>统计信息，供优化器在构造查询执行计划时使用。要执行直方图管理，请使用<code>ANALYZE TABLE</code>语句。</p>
<ul>
<li>该表包含除几何类型（空间数据）和JSON之外的所有数据类型的列的统计信息。</li>
<li>该表是持久的，因此不必在每次服务器启动时都创建列统计信息。</li>
<li>服务器对表执行更新，用户不执行。</li>
</ul>
<p>用户不能直接访问<code>column_statistics</code>表，因为它是<code>数据字典</code>的一部分。直方图信息可使用 <code>INFORMATION_SCHEMA.COLUMN_STATISTICS</code> 获得，它是作为数据字典表上的视图实现的。<code>COLUMN_STATISTICS</code>包含以下列：</p>
<ul>
<li>SCHEMA_NAME、TABLE_NAME、COLUMN_NAME：应用统计信息的模式、表和列的名称。</li>
<li>HISTORIO：描述列统计信息的JSON值，存储为直方图。</li>
</ul>
<p>直方图实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;buckets&quot;: [</span><br><span class="line">    [</span><br><span class="line">      1,</span><br><span class="line">      0.3333333333333333</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      2,</span><br><span class="line">      0.6666666666666666</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      3,</span><br><span class="line">      1</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  &quot;null-values&quot;: 0,</span><br><span class="line">  &quot;last-updated&quot;: &quot;2017-03-24 13:32:40.000000&quot;,</span><br><span class="line">  &quot;sampling-rate&quot;: 1,</span><br><span class="line">  &quot;histogram-type&quot;: &quot;singleton&quot;,</span><br><span class="line">  &quot;number-of-buckets-specified&quot;: 128,</span><br><span class="line">  &quot;data-type&quot;: &quot;int&quot;,</span><br><span class="line">  &quot;collation-id&quot;: 8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>buckets：直方图桶。桶结构取决于直方图类型。</li>
<li>null-values：一个介于0.0和1.0之间的数字，表示<code>SQL NULL</code>值的列值的分数。如果为0，则该列不包含NULL值。</li>
<li>last-updated：直方图生成时，以 <code>YYYY-MM-DD hh:mm:ss.uuuuuu</code> 格式的UTC值表示。</li>
<li>sampling-rate：0.0到1.0之间的数字，表示为创建直方图而采样的数据比例。值为1表示已读取所有数据（无采样）。</li>
<li>histogram-type：直方图类型：<ul>
<li>singleton：一个bucket表示列中的一个值。当列中的非重复值数量小于或等于生成直方图的<code>ANALYZE TABLE</code>语句中指定的存储桶数量时，将创建此直方图类型。</li>
<li>equi-height：一个桶表示一个值范围。当列中的非重复值数量大于生成直方图的<code>ANALYZE TABLE</code>语句中指定的存储桶数量时，将创建此直方图类型。</li>
</ul>
</li>
<li>number-of-buckets-specified：生成直方图的<code>ANALYZE TABLE</code>语句中指定的<code>桶数</code>。</li>
<li>data-type：此直方图包含的数据类型。在将直方图从持久性存储器阅读和解析到内存中时，这是需要的。该值是int、uint（无符号整数）、double、decimal、datetime或string（包括字符和二进制字符串）之一。</li>
<li>collation-id：直方图数据的归类ID。当数据类型值是字符串时，它最有意义。值对应于信息架构<code>COLLATIONS</code>表中的ID列值。</li>
</ul>
<p>直方图统计信息主要用于非索引列。将索引添加到直方图统计信息适用的列还可以帮助优化器进行行估计。</p>
<p>优化器更喜欢范围优化器的行估计，而不是从直方图统计信息中获得的行估计。如果优化器确定范围优化器适用，则不使用直方图统计信息。</p>
<p>对于已建立索引的列，可以使用索引潜水(index dives)获得行估计值以进行相等比较。</p>
<p>在某些情况下，使用直方图统计信息可能不会改善查询执行（例如，如果统计信息过期）。要检查是否是这种情况，请使用<code>ANALYZE TABLE</code>重新生成直方图统计信息，然后再次运行查询。</p>
<p>这么看这些概念内容，可能很难理解直方图到底是干啥的，下面给出一个例子方便理解。</p>
<h5 id="直方图示例"><a href="#直方图示例" class="headerlink" title="直方图示例"></a>直方图示例</h5><h2 id="虽然直方图的字段很多，但其核心的字段只有几个"><a href="#虽然直方图的字段很多，但其核心的字段只有几个" class="headerlink" title="虽然直方图的字段很多，但其核心的字段只有几个"></a>虽然直方图的字段很多，但其核心的字段只有几个</h2><p>创建一个测试表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_a(id <span class="type">int</span> auto_increment,a <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span>, b <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>, <span class="keyword">primary</span> key(id));</span><br></pre></td></tr></table></figure>

<p>接下来我们插入几个数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_a (a, b) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;A1&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;B2&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;C3&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;D4&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;E5&#x27;</span>),</span><br><span class="line">(<span class="number">6</span>, <span class="string">&#x27;F6&#x27;</span>),</span><br><span class="line">(<span class="number">7</span>, <span class="string">&#x27;G7&#x27;</span>),</span><br><span class="line">(<span class="number">8</span>, <span class="string">&#x27;H8&#x27;</span>),</span><br><span class="line">(<span class="number">9</span>, <span class="string">&#x27;I9&#x27;</span>),</span><br><span class="line">(<span class="number">10</span>, <span class="string">&#x27;J10&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>接下来生成直方图信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ANALYZE <span class="keyword">TABLE</span> test_a <span class="keyword">update</span>  HISTOGRAM <span class="keyword">ON</span> a <span class="keyword">WITH</span> <span class="number">5</span> BUCKETS;</span><br></pre></td></tr></table></figure>

<p>查询直方图信息。这里的<code>SCHEMA_NAME</code>是数据库的名称，TABLE_NAME是数据表的名称。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.COLUMN_STATISTICS <span class="keyword">where</span> SCHEMA_NAME <span class="operator">=</span> <span class="string">&#x27;test1&#x27;</span> <span class="keyword">and</span> TABLE_NAME <span class="operator">=</span> <span class="string">&#x27;test_a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>查询结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+-------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> SCHEMA_NAME <span class="operator">|</span> TABLE_NAME <span class="operator">|</span> COLUMN_NAME <span class="operator">|</span> HISTOGRAM</span><br><span class="line">                                                                                                                                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+-------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> test1       <span class="operator">|</span> test_a     <span class="operator">|</span> a           <span class="operator">|</span> &#123;&quot;buckets&quot;: [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0.2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">0.4</span>, <span class="number">2</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">0.6</span>, <span class="number">2</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">0.8</span>, <span class="number">2</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">1.0</span>, <span class="number">2</span>]], &quot;data-type&quot;: &quot;int&quot;, &quot;auto-update&quot;: <span class="literal">false</span>, &quot;null-values&quot;: <span class="number">0.0</span>, &quot;collation-id&quot;: <span class="number">8</span>, &quot;last-updated&quot;: &quot;2025-01-25 13:01:57.129967&quot;, &quot;sampling-rate&quot;: <span class="number">1.0</span>, &quot;histogram-type&quot;: &quot;equi-height&quot;, &quot;number-of-buckets-specified&quot;: <span class="number">5</span>&#125; <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+-------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>我们来看一下直方图的信息。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;buckets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">0.4</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">0.6</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">7</span><span class="punctuation">,</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">9</span><span class="punctuation">,</span> <span class="number">10</span><span class="punctuation">,</span> <span class="number">1.0</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;data-type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;int&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;auto-update&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;null-values&quot;</span><span class="punctuation">:</span> <span class="number">0.0</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;collation-id&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;last-updated&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2025-01-25 13:01:57.129967&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;sampling-rate&quot;</span><span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;histogram-type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;equi-height&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;number-of-buckets-specified&quot;</span><span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>buckets：直方图桶。桶结构取决于直方图类型。</li>
<li>null-values：0.0,表示没有null值，这是因为我们使用了<code>not null</code>声明字段。</li>
<li>last-updated：更新时间，没啥好说的。</li>
<li>sampling-rate：1.0 获取了所有数据，因为我们只有10条数据，很少。</li>
<li>histogram-type：直方图类型：equi-height，因为<code>a</code>列有10个值，都不重复，而桶数量我们用的是5，所以生成了这个类型。</li>
<li>number-of-buckets-specified：生成直方图的<code>ANALYZE TABLE</code>语句中指定的<code>桶数</code>。</li>
<li>data-type：列a是int类型</li>
<li>collation-id：直方图数据的归类ID。当数据类型值是字符串时，它最有意义。值对应于信息架构<code>COLLATIONS</code>表中的ID列值。</li>
</ul>
<p>桶里面有4个数据</p>
<ul>
<li>最小值</li>
<li>最大值</li>
<li>密度</li>
<li>高度</li>
</ul>
<p>比如，查询语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_a <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><code>a = 5</code>的数据在第三个桶里面，最小值5，最大值6，密度0.6，高度2.</p>
<p>根据计算公式<code>预估行数 = 密度 * 高度</code>来计算0.6 * 2，预估行数就是1.2，也就是1-2行。</p>
<p><img src="/../images/mysql/mysql2-6.jpg" alt="架构"></p>
<p>可以看到查询计划里面的rows是10行，这是因为类型是全表扫描，但是后面的<code>filtered</code>字段是10，表示的意思是会过滤出来 <code>10 * 10% = 10 * 0.1 = 1</code>行。</p>
<p>也就是最终会查出1行结果。</p>
<p>通常来说，对于没有索引的列，MySQL就是这样来预估行数的，并且通过这个结果来进行选择执行路线。</p>
<h3 id="执行路线选择"><a href="#执行路线选择" class="headerlink" title="执行路线选择"></a>执行路线选择</h3><p>什么叫路线选择呢，还是上面那个表，我们现在有如下SQL语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a,b <span class="keyword">from</span> test_a <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> b <span class="operator">=</span> <span class="string">&#x27;A1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>根据表数据，其实我们知道，查出来的结果还是1条。但是对于mysql来说，却有不同的执行方式。</p>
<p>第一种执行方式，先查<code>a=1</code>在查询<code>b=&#39;A1&#39;</code>的数据。执行树如下。</p>
<p><img src="/../images/mysql/mysql2-7.jpg" alt="架构"></p>
<p>第二种执行方式，先查<code>b=&#39;A1&#39;</code>在查询 <code>a=1</code>。执行树如下。</p>
<p><img src="/../images/mysql/mysql2-8.jpg" alt="架构"></p>
<p>目前看着这两种方式都没啥问题。</p>
<p>但是，我们再插入一条数据呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_a (a, b) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">11</span>, <span class="string">&#x27;A1&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这样我们就知道了，方案1， 会直接过滤出1行数据，然后在过滤，这样显然比方案2更好。</p>
<p>因为方案2会先查出2条数据，再次过滤。</p>
<p>这就是不同的执行路线带来的性能区别。当然了，我们这里的例子只是打个比方，实际上<code>谓词下推</code>优化以后，这两个条件都是和扫描表一起执行的。</p>
<p>这个例子只是让你明白不同的路线选择而已。</p>
<p>对于<code>join</code>查询来说，会有更多的选择。</p>
<h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>以上就是今天的内容了，大家有任何疑问可以打在评论区，一起交流～</p>
<p>关注我发送“MySQL知识图谱”领取完整的MySQL学习路线。</p>
<p>发送“电子书”即可领取价值上千的电子书资源。</p>
<p>部分电子书如图所示。</p>
<p><img src="/../images/bottom1.png" alt="概念学习"></p>
<p><img src="/../images/bottom2.png" alt="概念学习"></p>
<p><img src="/../images/bottom3.png" alt="概念学习"></p>
<p><img src="/../images/bottom4.png" alt="概念学习"></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL零基础教程基础篇</title>
    <url>/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQLDML%E7%AF%87.html</url>
    <content><![CDATA[<h1 id="MySQL零基础教程基础篇"><a href="#MySQL零基础教程基础篇" class="headerlink" title="MySQL零基础教程基础篇"></a>MySQL零基础教程基础篇</h1><p>大家好，我是大头，98年，职高毕业，上市公司架构师，大厂资深开发，管理过10人团队，我是如何做到的呢？</p>
<p>这离不开持续学习的能力，而其中最重要的当然是数据库技术了！</p>
<p>对于所有开发来说，都离不开数据库，因为所有的数据都是要存储的。</p>
<p>关注我一起学习！文末有惊喜哦！</p>
<p>基础篇的内容大致如下图所示。</p>
<p><img src="/../images/mysql/mysql1-1.png" alt="概念学习"></p>
<h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><p>介绍完概念以后，我们可以来看看SQL语句了。SQL语句通常由三类组成。</p>
<p>数据定义 DDL</p>
<ul>
<li>CREATE 创建数据库或数据库对象</li>
<li>ALTER 对数据库或数据库对象进行修改</li>
<li>DROP 删除数据库或数据库对象<br>数据操纵 DML</li>
<li>SELECT 从表或视图中检索数据</li>
<li>INSERT 将数据插入到表或视图中</li>
<li>UPDATE 修改表或视图中的数据</li>
<li>DELETE 从表或视图中删除数据<br>数据控制 DCL</li>
<li>GRANT 用于授予权限</li>
<li>REVOKE 用于收回权限</li>
</ul>
<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p>MySQL 中的 DML（数据操纵语言，Data Manipulation Language） 语句用于对数据库中的数据进行操作，主要包括数据的插入、更新、删除和查询。DML 语句是数据库操作中最常用的语句类型。</p>
<h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><p>插入数据使用<code>insert</code>指令，可以往创建好的一张表里面插入数据，支持多种插入方式。</p>
<p>最常用的方式是<code>insert  values</code>，这种方式也支持批量插入数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name[(col_name)] <span class="keyword">values</span> ();</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (id, name, department, salary)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;John Doe&#x27;</span>, <span class="string">&#x27;IT&#x27;</span>, <span class="number">50000</span>);</span><br></pre></td></tr></table></figure>

<p>还有一种方式是 <code>insert  set</code>。这种方式不支持批量插入。这种方式以键值对的形式插入数据，适用于插入单行数据。这种方式在插入单行数据时更加直观，尤其是当列名较多时。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name</span><br><span class="line"><span class="keyword">set</span> col_name <span class="operator">=</span> <span class="string">&#x27;值&#x27;</span>, col_name <span class="operator">=</span> <span class="string">&#x27;值&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>还是刚才的插入示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (id, name, department, salary)</span><br><span class="line"><span class="keyword">set</span> id <span class="operator">=</span> <span class="number">1</span>，name <span class="operator">=</span> <span class="string">&#x27;John Doe&#x27;</span>，department<span class="operator">=</span><span class="string">&#x27;IT&#x27;</span>，salary<span class="operator">=</span><span class="number">50000</span>；</span><br></pre></td></tr></table></figure>

<p>还有一种方式是<code>insert  select</code>方式，这种方式适合快速复制表数据，将查询出来的数据插入到另外一个表里面。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure>

<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>可以使用<code>delete from</code>指令来删除已经插入的数据。如果不加where条件的话，就是删除全表数据。</p>
<p>删除数据操作一定要慎重！！！</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>示例：删除刚才插入到表<code>employees</code>的<code>ID=1</code>的数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> employees <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>除了使用delete指令以外，还可以使用<code>TRUNCATE</code>指令，这个指令可以删除全表的数据，并且新的数据id自增从1开始。删除全表数据的话，该指令通常更快速。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">TABLE</span> table_name</span><br></pre></td></tr></table></figure>

<h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><p>当插入的数据内容需要修改或者说更新的时候，则可以使用<code>update set</code>指令进行修改。修改操作可以使用where条件来选择要修改的数据，不加where条件则会更新所有数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> table_name <span class="keyword">set</span> col_name <span class="operator">=</span> <span class="string">&#x27;值&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>示例：将刚才插入的数据部门修改一下。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> employees <span class="keyword">set</span> department <span class="operator">=</span> <span class="string">&#x27;Market&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h4><p>数据查询语句是最复杂的语句，这里只是介绍，想要完全用明白，需要大量的实践。</p>
<h5 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h5><p>select用于查询数据表里面插入的数据。</p>
<p><code>*</code>代表查询所有字段。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>

<h5 id="列的选择与指定"><a href="#列的选择与指定" class="headerlink" title="列的选择与指定"></a>列的选择与指定</h5><p>如果查询指定字段，则使用字段名称代替<code>*</code>。</p>
<p>实际开发中不推荐查询所有字段，推荐查询需要的字段，可以提升查询速度。</p>
<ul>
<li>如果查询的字段正好是索引，那么可以触发覆盖索引</li>
<li>如果查询的字段过多，会增加网络传输消耗</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name1,col_name2... <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>

<h5 id="定义别名"><a href="#定义别名" class="headerlink" title="定义别名"></a>定义别名</h5><p>可以给字段和表定义别名，通过<code>as</code>指令实现。别名可以解决一些字段名冲突或者字段名过长的问题。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name <span class="keyword">as</span> alias <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>

<p>示例：department字段给一个别名是depart</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id，department <span class="keyword">as</span> depart <span class="keyword">from</span> employees</span><br></pre></td></tr></table></figure>

<h5 id="where条件"><a href="#where条件" class="headerlink" title="where条件"></a>where条件</h5><p>通过where关键字来进行条件筛选，可以选择出符合条件的数据。</p>
<p>比如当前用户表user有数据如下：以下数据均为随机生成，非真实数据。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#122;&#x68;&#97;&#x6e;&#103;&#115;&#x61;&#x6e;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#x6d;">&#122;&#x68;&#97;&#x6e;&#103;&#115;&#x61;&#x6e;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#x6c;&#105;&#x73;&#105;&#x40;&#x65;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;">&#x6c;&#105;&#x73;&#105;&#x40;&#x65;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>003</td>
<td>王五</td>
<td>男</td>
<td>13700009012</td>
<td><a href="mailto:&#119;&#97;&#x6e;&#103;&#x77;&#117;&#64;&#101;&#120;&#x61;&#109;&#x70;&#108;&#101;&#46;&#99;&#111;&#x6d;">&#119;&#97;&#x6e;&#103;&#x77;&#117;&#64;&#101;&#120;&#x61;&#109;&#x70;&#108;&#101;&#46;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>004</td>
<td>赵六</td>
<td>女</td>
<td>13600003456</td>
<td><a href="mailto:&#x7a;&#104;&#x61;&#x6f;&#x6c;&#x69;&#x75;&#64;&#101;&#120;&#97;&#109;&#112;&#x6c;&#x65;&#46;&#x63;&#111;&#x6d;">&#x7a;&#104;&#x61;&#x6f;&#x6c;&#x69;&#x75;&#64;&#101;&#120;&#97;&#109;&#112;&#x6c;&#x65;&#46;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>005</td>
<td>孙七</td>
<td>男</td>
<td>13500007890</td>
<td><a href="mailto:&#x73;&#117;&#x6e;&#x71;&#105;&#64;&#101;&#120;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#x73;&#117;&#x6e;&#x71;&#105;&#64;&#101;&#120;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>006</td>
<td>周八</td>
<td>女</td>
<td>13400001234</td>
<td><a href="mailto:&#122;&#104;&#111;&#x75;&#x62;&#x61;&#x40;&#x65;&#x78;&#x61;&#109;&#112;&#108;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#122;&#104;&#111;&#x75;&#x62;&#x61;&#x40;&#x65;&#x78;&#x61;&#109;&#112;&#108;&#101;&#x2e;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>007</td>
<td>吴九</td>
<td>男</td>
<td>13300005678</td>
<td><a href="mailto:&#x77;&#x75;&#106;&#105;&#117;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#111;&#109;">&#x77;&#x75;&#106;&#105;&#117;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>008</td>
<td>郑十</td>
<td>女</td>
<td>13200009012</td>
<td><a href="mailto:&#122;&#x68;&#x65;&#x6e;&#103;&#x73;&#104;&#105;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;">&#122;&#x68;&#x65;&#x6e;&#103;&#x73;&#104;&#105;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>009</td>
<td>钱伯</td>
<td>男</td>
<td>13100003456</td>
<td><a href="mailto:&#113;&#x69;&#x61;&#110;&#98;&#x6f;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;">&#113;&#x69;&#x61;&#110;&#98;&#x6f;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>010</td>
<td>孔仲</td>
<td>女</td>
<td>13000007890</td>
<td><a href="mailto:&#x6b;&#x6f;&#x6e;&#x67;&#x7a;&#x68;&#111;&#x6e;&#x67;&#64;&#101;&#120;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;">&#x6b;&#x6f;&#x6e;&#x67;&#x7a;&#x68;&#111;&#x6e;&#x67;&#64;&#101;&#120;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;</a></td>
</tr>
</tbody></table>
<p>这个时候我们需要查询出张三的用户信息，而不是将这10个数据都查询出来到程序里在筛选出张三的数据。</p>
<p>可以使用如下sql完成。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>; </span><br></pre></td></tr></table></figure>

<p>这个sql会把name字段中等于‘张三’的数据查询出来。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#104;&#x61;&#x6e;&#103;&#x73;&#x61;&#x6e;&#64;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#111;&#109;">&#x7a;&#104;&#x61;&#x6e;&#103;&#x73;&#x61;&#x6e;&#64;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#111;&#109;</a></td>
</tr>
</tbody></table>
<p>where条件支持的类型如下：</p>
<ul>
<li>比较操作符</li>
</ul>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td>等于</td>
</tr>
<tr>
<td><code>&lt;&gt;</code></td>
<td>不等于（也可用<code>!=</code>）</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
</tr>
</tbody></table>
<ul>
<li><p>逻辑操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>AND</code></td>
<td>逻辑与（两个条件都满足）</td>
</tr>
<tr>
<td><code>OR</code></td>
<td>逻辑或（至少一个条件满足）</td>
</tr>
<tr>
<td><code>NOT</code></td>
<td>逻辑非（对条件取反）</td>
</tr>
</tbody></table>
</li>
<li><p>范围操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>BETWEEN...AND...</code></td>
<td>在指定范围内（包括边界值）</td>
</tr>
<tr>
<td><code>NOT BETWEEN</code></td>
<td>不在指定范围内</td>
</tr>
</tbody></table>
</li>
<li><p>列表操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>IN</code></td>
<td>在指定的列表中</td>
</tr>
<tr>
<td><code>NOT IN</code></td>
<td>不在指定的列表中</td>
</tr>
</tbody></table>
</li>
<li><p>模糊匹配操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>LIKE</code></td>
<td>模糊匹配（使用<code>%</code>和<code>_</code>作为通配符）</td>
</tr>
<tr>
<td><code>NOT LIKE</code></td>
<td>不匹配指定模式</td>
</tr>
</tbody></table>
</li>
<li><p>空值操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>IS NULL</code></td>
<td>判断是否为<code>NULL</code></td>
</tr>
<tr>
<td><code>IS NOT NULL</code></td>
<td>判断是否不为<code>NULL</code></td>
</tr>
</tbody></table>
</li>
<li><p>其他操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>EXISTS</code></td>
<td>检查子查询是否存在结果</td>
</tr>
<tr>
<td><code>NOT EXISTS</code></td>
<td>检查子查询是否不存在结果</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="替换查询结果集中的数据"><a href="#替换查询结果集中的数据" class="headerlink" title="替换查询结果集中的数据"></a>替换查询结果集中的数据</h5><p>可以使用if条件来进行结果的判定，比如性别，数据库里面存的可能是1代表男，2代表女。如果要查询出来男和女的话，就可以直接通过sql处理。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> </span><br><span class="line"><span class="keyword">when</span> 条件<span class="number">1</span> <span class="keyword">then</span> 表达式<span class="number">1</span></span><br><span class="line"><span class="keyword">when</span> 条件<span class="number">2</span> <span class="keyword">then</span> 表达式<span class="number">2</span></span><br><span class="line"><span class="keyword">else</span> 表达式</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">as</span> alias</span><br></pre></td></tr></table></figure>

<p>示例：性别转换。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="keyword">CASE</span> </span><br><span class="line">        <span class="keyword">WHEN</span> gender <span class="operator">=</span> <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">&#x27;男&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> gender <span class="operator">=</span> <span class="number">2</span> <span class="keyword">THEN</span> <span class="string">&#x27;女&#x27;</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">&#x27;未知&#x27;</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> 性别</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<h4 id="计算列值"><a href="#计算列值" class="headerlink" title="计算列值"></a>计算列值</h4><p>可以直接计算将字段的值进行加减乘除运算。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name <span class="operator">+</span> <span class="number">100</span> <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>

<h4 id="from-子句与多表连接查询"><a href="#from-子句与多表连接查询" class="headerlink" title="from 子句与多表连接查询"></a>from 子句与多表连接查询</h4><h5 id="交叉连接，笛卡尔积"><a href="#交叉连接，笛卡尔积" class="headerlink" title="交叉连接，笛卡尔积"></a>交叉连接，笛卡尔积</h5><p>交叉连接可以连接两个表，产生两个表的笛卡尔积作为结果。</p>
<p>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_namme1 <span class="keyword">cross</span> <span class="keyword">join</span> table_name2</span><br></pre></td></tr></table></figure>
<p>可以直接简写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name1,table_name2;</span><br></pre></td></tr></table></figure>

<p>示例：获取两个表的交叉连接。</p>
<p>假设有表user如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#x68;&#97;&#x6e;&#x67;&#115;&#97;&#110;&#64;&#x65;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#99;&#111;&#109;">&#x7a;&#x68;&#97;&#x6e;&#x67;&#115;&#97;&#110;&#64;&#x65;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#99;&#111;&#109;</a></td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#105;&#115;&#x69;&#x40;&#x65;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;">&#108;&#105;&#115;&#x69;&#x40;&#x65;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;</a></td>
</tr>
</tbody></table>
<p>还有表user_account存储用户的账户余额信息如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
</tbody></table>
<p>使用如下sql语句获取交叉连接：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>,user_account;</span><br></pre></td></tr></table></figure>

<p>结果如下：也就是用户表数据001和用户账户001产生一条数据，和用户账户002产生一条数据，用户数据002同样。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
<th>ID2</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#104;&#97;&#x6e;&#103;&#115;&#97;&#110;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#x65;&#46;&#x63;&#111;&#x6d;">&#x7a;&#104;&#97;&#x6e;&#103;&#115;&#97;&#110;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#x65;&#46;&#x63;&#111;&#x6d;</a></td>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#x68;&#97;&#x6e;&#103;&#115;&#97;&#x6e;&#64;&#x65;&#120;&#x61;&#109;&#x70;&#108;&#101;&#x2e;&#x63;&#111;&#109;">&#x7a;&#x68;&#97;&#x6e;&#103;&#115;&#97;&#x6e;&#64;&#x65;&#120;&#x61;&#109;&#x70;&#108;&#101;&#x2e;&#x63;&#111;&#109;</a></td>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#x6c;&#x69;&#115;&#x69;&#64;&#101;&#120;&#x61;&#109;&#112;&#108;&#x65;&#46;&#x63;&#111;&#109;">&#x6c;&#x69;&#115;&#x69;&#64;&#101;&#120;&#x61;&#109;&#112;&#108;&#x65;&#46;&#x63;&#111;&#109;</a></td>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#105;&#x73;&#x69;&#64;&#x65;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;">&#108;&#105;&#x73;&#x69;&#64;&#x65;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;</a></td>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
</tbody></table>
<h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>内连接返回两个表中匹配的记录。只有当两个表中的记录满足连接条件时，才会出现在结果集中。可以理解为两个表的交集。</p>
<p>连接的时候，<code>on</code>就类似于where条件，只不过仅仅在连接表数据的时候生效。内连接返回两个表都满足这个条件的交集。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name <span class="keyword">from</span> table_name <span class="keyword">inner</span> <span class="keyword">join</span> table_name2 <span class="keyword">on</span> table_name.id <span class="operator">=</span> table_name2.t_id;</span><br></pre></td></tr></table></figure>

<p>示例：获取用户数据和用户账户数据的内连接。</p>
<p>假设有表user如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#104;&#97;&#110;&#103;&#x73;&#x61;&#110;&#64;&#x65;&#120;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#109;">&#x7a;&#104;&#97;&#110;&#103;&#x73;&#x61;&#110;&#64;&#x65;&#120;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#105;&#115;&#x69;&#64;&#x65;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#x2e;&#99;&#111;&#x6d;">&#108;&#105;&#115;&#x69;&#64;&#x65;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>003</td>
<td>王五</td>
<td>男</td>
<td>13700009012</td>
<td><a href="mailto:&#119;&#97;&#x6e;&#x67;&#119;&#x75;&#x40;&#x65;&#x78;&#x61;&#x6d;&#112;&#108;&#x65;&#x2e;&#x63;&#111;&#109;">&#119;&#97;&#x6e;&#x67;&#119;&#x75;&#x40;&#x65;&#x78;&#x61;&#x6d;&#112;&#108;&#x65;&#x2e;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>004</td>
<td>赵六</td>
<td>女</td>
<td>13600003456</td>
<td><a href="mailto:&#x7a;&#104;&#x61;&#x6f;&#x6c;&#105;&#117;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;">&#x7a;&#104;&#x61;&#x6f;&#x6c;&#105;&#117;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>005</td>
<td>孙七</td>
<td>男</td>
<td>13500007890</td>
<td><a href="mailto:&#x73;&#x75;&#110;&#x71;&#x69;&#x40;&#101;&#x78;&#97;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;">&#x73;&#x75;&#110;&#x71;&#x69;&#x40;&#101;&#x78;&#97;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>006</td>
<td>周八</td>
<td>女</td>
<td>13400001234</td>
<td><a href="mailto:&#122;&#104;&#111;&#x75;&#98;&#97;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#x65;&#x2e;&#99;&#111;&#109;">&#122;&#104;&#111;&#x75;&#98;&#97;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#x65;&#x2e;&#99;&#111;&#109;</a></td>
</tr>
<tr>
<td>007</td>
<td>吴九</td>
<td>男</td>
<td>13300005678</td>
<td><a href="mailto:&#x77;&#x75;&#x6a;&#105;&#117;&#64;&#101;&#120;&#x61;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#x6d;">&#x77;&#x75;&#x6a;&#105;&#117;&#64;&#101;&#120;&#x61;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>008</td>
<td>郑十</td>
<td>女</td>
<td>13200009012</td>
<td><a href="mailto:&#x7a;&#104;&#x65;&#110;&#103;&#x73;&#x68;&#x69;&#x40;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#x2e;&#99;&#111;&#x6d;">&#x7a;&#104;&#x65;&#110;&#103;&#x73;&#x68;&#x69;&#x40;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>009</td>
<td>钱伯</td>
<td>男</td>
<td>13100003456</td>
<td><a href="mailto:&#113;&#x69;&#97;&#x6e;&#98;&#x6f;&#64;&#x65;&#120;&#x61;&#x6d;&#x70;&#x6c;&#101;&#x2e;&#x63;&#111;&#109;">&#113;&#x69;&#97;&#x6e;&#98;&#x6f;&#64;&#x65;&#120;&#x61;&#x6d;&#x70;&#x6c;&#101;&#x2e;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>010</td>
<td>孔仲</td>
<td>女</td>
<td>13000007890</td>
<td><a href="mailto:&#107;&#111;&#110;&#x67;&#x7a;&#x68;&#x6f;&#x6e;&#x67;&#x40;&#x65;&#x78;&#x61;&#109;&#112;&#108;&#101;&#x2e;&#x63;&#111;&#109;">&#107;&#111;&#110;&#x67;&#x7a;&#x68;&#x6f;&#x6e;&#x67;&#x40;&#x65;&#x78;&#x61;&#109;&#112;&#108;&#101;&#x2e;&#x63;&#111;&#109;</a></td>
</tr>
</tbody></table>
<p>还有表user_account存储用户的账户余额信息如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>003</td>
<td>011</td>
<td>20</td>
</tr>
</tbody></table>
<p>可以看到这两个表的交集就只有两条数据，也就是001和002，</p>
<p>使用如下sql语句获取交叉连接：</p>
<p><code>on user.id = user_account.user_id</code>这个条件代表只有当user表的id字段和user_account表的user_id字段相等的时候，才会有结果;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">inner</span> <span class="keyword">join</span> user_account <span class="keyword">on</span> user.id <span class="operator">=</span> user_account.user_id;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
<th>ID2</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#122;&#x68;&#x61;&#x6e;&#x67;&#115;&#x61;&#110;&#x40;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#x65;&#46;&#99;&#x6f;&#x6d;">&#122;&#x68;&#x61;&#x6e;&#x67;&#115;&#x61;&#110;&#x40;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#x65;&#46;&#99;&#x6f;&#x6d;</a></td>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#x69;&#x73;&#105;&#x40;&#101;&#120;&#x61;&#109;&#112;&#108;&#x65;&#x2e;&#99;&#x6f;&#x6d;">&#108;&#x69;&#x73;&#105;&#x40;&#101;&#120;&#x61;&#109;&#112;&#108;&#x65;&#x2e;&#99;&#x6f;&#x6d;</a></td>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
</tbody></table>
<h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>外连接分为左连接和右连接，左连接返回内连接的结果+左表剩余的数据，右连接返回内连接的结果+右表剩余的数据。</p>
<p>左表就是 <code>join</code>左边的表，右表就是<code>join</code>右边的表。</p>
<p>左连接使用<code>left join</code>指令。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name <span class="keyword">from</span> table_name <span class="keyword">left</span> <span class="keyword">join</span> table_name2 <span class="keyword">on</span> table_name.id <span class="operator">=</span> table_name2.t_id;</span><br></pre></td></tr></table></figure>

<p>示例：获取用户表和用户账户表的左连接结果。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#122;&#104;&#97;&#110;&#x67;&#x73;&#97;&#x6e;&#x40;&#x65;&#120;&#97;&#109;&#112;&#x6c;&#x65;&#46;&#x63;&#x6f;&#109;">&#122;&#104;&#97;&#110;&#x67;&#x73;&#97;&#x6e;&#x40;&#x65;&#120;&#97;&#109;&#112;&#x6c;&#x65;&#46;&#x63;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#x69;&#115;&#x69;&#64;&#101;&#120;&#97;&#x6d;&#112;&#108;&#101;&#x2e;&#x63;&#111;&#109;">&#108;&#x69;&#115;&#x69;&#64;&#101;&#120;&#97;&#x6d;&#112;&#108;&#101;&#x2e;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>003</td>
<td>王五</td>
<td>男</td>
<td>13700009012</td>
<td><a href="mailto:&#119;&#x61;&#110;&#x67;&#119;&#117;&#64;&#101;&#120;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#x63;&#x6f;&#x6d;">&#119;&#x61;&#110;&#x67;&#119;&#117;&#64;&#101;&#120;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#x63;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>004</td>
<td>赵六</td>
<td>女</td>
<td>13600003456</td>
<td><a href="mailto:&#122;&#104;&#97;&#111;&#x6c;&#x69;&#x75;&#64;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;">&#122;&#104;&#97;&#111;&#x6c;&#x69;&#x75;&#64;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>005</td>
<td>孙七</td>
<td>男</td>
<td>13500007890</td>
<td><a href="mailto:&#115;&#117;&#x6e;&#x71;&#x69;&#x40;&#x65;&#x78;&#97;&#x6d;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;">&#115;&#117;&#x6e;&#x71;&#x69;&#x40;&#x65;&#x78;&#97;&#x6d;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>006</td>
<td>周八</td>
<td>女</td>
<td>13400001234</td>
<td><a href="mailto:&#122;&#x68;&#x6f;&#x75;&#x62;&#97;&#x40;&#101;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#x6d;">&#122;&#x68;&#x6f;&#x75;&#x62;&#97;&#x40;&#101;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>007</td>
<td>吴九</td>
<td>男</td>
<td>13300005678</td>
<td><a href="mailto:&#119;&#117;&#x6a;&#105;&#117;&#x40;&#x65;&#x78;&#97;&#x6d;&#112;&#108;&#x65;&#46;&#x63;&#111;&#x6d;">&#119;&#117;&#x6a;&#105;&#117;&#x40;&#x65;&#x78;&#97;&#x6d;&#112;&#108;&#x65;&#46;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>008</td>
<td>郑十</td>
<td>女</td>
<td>13200009012</td>
<td><a href="mailto:&#x7a;&#104;&#x65;&#110;&#x67;&#x73;&#104;&#x69;&#x40;&#x65;&#120;&#97;&#x6d;&#112;&#108;&#x65;&#x2e;&#x63;&#111;&#109;">&#x7a;&#104;&#x65;&#110;&#x67;&#x73;&#104;&#x69;&#x40;&#x65;&#120;&#97;&#x6d;&#112;&#108;&#x65;&#x2e;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>009</td>
<td>钱伯</td>
<td>男</td>
<td>13100003456</td>
<td><a href="mailto:&#113;&#x69;&#97;&#110;&#x62;&#111;&#64;&#x65;&#120;&#97;&#109;&#112;&#108;&#x65;&#46;&#x63;&#111;&#x6d;">&#113;&#x69;&#97;&#110;&#x62;&#111;&#64;&#x65;&#120;&#97;&#109;&#112;&#108;&#x65;&#46;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>010</td>
<td>孔仲</td>
<td>女</td>
<td>13000007890</td>
<td><a href="mailto:&#x6b;&#x6f;&#x6e;&#103;&#x7a;&#x68;&#111;&#110;&#103;&#x40;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#46;&#x63;&#111;&#109;">&#x6b;&#x6f;&#x6e;&#103;&#x7a;&#x68;&#111;&#110;&#103;&#x40;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#46;&#x63;&#111;&#109;</a></td>
</tr>
</tbody></table>
<p>还有表user_account存储用户的账户余额信息如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>003</td>
<td>011</td>
<td>20</td>
</tr>
</tbody></table>
<p>使用如下sql语句，可以看到，仅仅是<code>inner join</code>换成了<code>left join</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">left</span> <span class="keyword">join</span> user_account <span class="keyword">on</span> user.id <span class="operator">=</span> user_account.user_id;</span><br></pre></td></tr></table></figure>

<p>结果如下：在内连接的结果基础上，增加了<code>左表user表</code>剩下的8条数据，右表的字段内容则是<code>null</code>，代表没有对应字段的数据。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
<th>ID2</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#122;&#x68;&#x61;&#x6e;&#103;&#x73;&#97;&#x6e;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#x65;&#46;&#99;&#111;&#x6d;">&#122;&#x68;&#x61;&#x6e;&#103;&#x73;&#97;&#x6e;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#x65;&#46;&#99;&#111;&#x6d;</a></td>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#x69;&#x73;&#105;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;">&#108;&#x69;&#x73;&#105;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;</a></td>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>003</td>
<td>王五</td>
<td>男</td>
<td>13700009012</td>
<td><a href="mailto:&#119;&#97;&#x6e;&#x67;&#119;&#x75;&#64;&#101;&#x78;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#x6f;&#109;">&#119;&#97;&#x6e;&#x67;&#119;&#x75;&#64;&#101;&#x78;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#x6f;&#109;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>004</td>
<td>赵六</td>
<td>女</td>
<td>13600003456</td>
<td><a href="mailto:&#122;&#104;&#97;&#x6f;&#x6c;&#105;&#x75;&#x40;&#x65;&#x78;&#97;&#109;&#x70;&#108;&#101;&#x2e;&#x63;&#111;&#x6d;">&#122;&#104;&#97;&#x6f;&#x6c;&#105;&#x75;&#x40;&#x65;&#x78;&#97;&#109;&#x70;&#108;&#101;&#x2e;&#x63;&#111;&#x6d;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>005</td>
<td>孙七</td>
<td>男</td>
<td>13500007890</td>
<td><a href="mailto:&#115;&#117;&#110;&#x71;&#105;&#64;&#x65;&#120;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#x63;&#x6f;&#109;">&#115;&#117;&#110;&#x71;&#105;&#64;&#x65;&#120;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#x63;&#x6f;&#109;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>006</td>
<td>周八</td>
<td>女</td>
<td>13400001234</td>
<td><a href="mailto:&#x7a;&#104;&#x6f;&#x75;&#98;&#97;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#46;&#99;&#111;&#109;">&#x7a;&#104;&#x6f;&#x75;&#98;&#97;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#46;&#99;&#111;&#109;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>007</td>
<td>吴九</td>
<td>男</td>
<td>13300005678</td>
<td><a href="mailto:&#x77;&#117;&#106;&#105;&#117;&#64;&#101;&#x78;&#97;&#109;&#x70;&#x6c;&#101;&#46;&#99;&#x6f;&#109;">&#x77;&#117;&#106;&#105;&#117;&#64;&#101;&#x78;&#97;&#109;&#x70;&#x6c;&#101;&#46;&#99;&#x6f;&#109;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>008</td>
<td>郑十</td>
<td>女</td>
<td>13200009012</td>
<td><a href="mailto:&#122;&#104;&#101;&#x6e;&#x67;&#115;&#104;&#x69;&#x40;&#101;&#x78;&#x61;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;">&#122;&#104;&#101;&#x6e;&#x67;&#115;&#104;&#x69;&#x40;&#101;&#x78;&#x61;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>009</td>
<td>钱伯</td>
<td>男</td>
<td>13100003456</td>
<td><a href="mailto:&#113;&#x69;&#x61;&#x6e;&#x62;&#111;&#x40;&#x65;&#120;&#97;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;">&#113;&#x69;&#x61;&#x6e;&#x62;&#111;&#x40;&#x65;&#120;&#97;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>010</td>
<td>孔仲</td>
<td>女</td>
<td>13000007890</td>
<td><a href="mailto:&#x6b;&#x6f;&#110;&#x67;&#x7a;&#x68;&#x6f;&#x6e;&#103;&#x40;&#x65;&#x78;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#99;&#x6f;&#x6d;">&#x6b;&#x6f;&#110;&#x67;&#x7a;&#x68;&#x6f;&#x6e;&#103;&#x40;&#x65;&#x78;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#99;&#x6f;&#x6d;</a></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
</tbody></table>
<p>右连接使用<code>right join</code>指令。<br>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> col_name <span class="keyword">from</span> table_name <span class="keyword">right</span> <span class="keyword">join</span> table_name2 <span class="keyword">on</span> table_name.id <span class="operator">=</span> table_name2.t_id;</span><br></pre></td></tr></table></figure>

<p>示例：获取用户表和用户账户表的右连接结果。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#x7a;&#x68;&#97;&#110;&#x67;&#115;&#x61;&#x6e;&#x40;&#101;&#120;&#x61;&#x6d;&#x70;&#108;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">&#x7a;&#x68;&#97;&#110;&#x67;&#115;&#x61;&#x6e;&#x40;&#101;&#120;&#x61;&#x6d;&#x70;&#108;&#x65;&#x2e;&#x63;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#x6c;&#x69;&#x73;&#x69;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#101;&#x2e;&#x63;&#111;&#x6d;">&#x6c;&#x69;&#x73;&#x69;&#x40;&#x65;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#101;&#x2e;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>003</td>
<td>王五</td>
<td>男</td>
<td>13700009012</td>
<td><a href="mailto:&#x77;&#x61;&#x6e;&#x67;&#119;&#117;&#64;&#101;&#120;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#x63;&#111;&#109;">&#x77;&#x61;&#x6e;&#x67;&#119;&#117;&#64;&#101;&#120;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>004</td>
<td>赵六</td>
<td>女</td>
<td>13600003456</td>
<td><a href="mailto:&#122;&#104;&#97;&#111;&#x6c;&#105;&#x75;&#x40;&#x65;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#109;">&#122;&#104;&#97;&#111;&#x6c;&#105;&#x75;&#x40;&#x65;&#x78;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>005</td>
<td>孙七</td>
<td>男</td>
<td>13500007890</td>
<td><a href="mailto:&#115;&#x75;&#x6e;&#113;&#x69;&#64;&#101;&#120;&#x61;&#x6d;&#x70;&#108;&#x65;&#46;&#99;&#x6f;&#109;">&#115;&#x75;&#x6e;&#113;&#x69;&#64;&#101;&#120;&#x61;&#x6d;&#x70;&#108;&#x65;&#46;&#99;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>006</td>
<td>周八</td>
<td>女</td>
<td>13400001234</td>
<td><a href="mailto:&#x7a;&#x68;&#x6f;&#x75;&#98;&#x61;&#x40;&#101;&#x78;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;">&#x7a;&#x68;&#x6f;&#x75;&#98;&#x61;&#x40;&#101;&#x78;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>007</td>
<td>吴九</td>
<td>男</td>
<td>13300005678</td>
<td><a href="mailto:&#119;&#x75;&#x6a;&#x69;&#117;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#111;&#x6d;">&#119;&#x75;&#x6a;&#x69;&#117;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td>008</td>
<td>郑十</td>
<td>女</td>
<td>13200009012</td>
<td><a href="mailto:&#122;&#x68;&#101;&#x6e;&#x67;&#x73;&#x68;&#105;&#x40;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;">&#122;&#x68;&#101;&#x6e;&#x67;&#x73;&#x68;&#105;&#x40;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;</a></td>
</tr>
<tr>
<td>009</td>
<td>钱伯</td>
<td>男</td>
<td>13100003456</td>
<td><a href="mailto:&#x71;&#x69;&#x61;&#110;&#x62;&#111;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#x6d;">&#x71;&#x69;&#x61;&#110;&#x62;&#111;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>010</td>
<td>孔仲</td>
<td>女</td>
<td>13000007890</td>
<td><a href="mailto:&#107;&#x6f;&#110;&#103;&#x7a;&#104;&#111;&#110;&#x67;&#64;&#x65;&#120;&#x61;&#109;&#112;&#108;&#101;&#46;&#x63;&#111;&#x6d;">&#107;&#x6f;&#110;&#103;&#x7a;&#104;&#111;&#110;&#x67;&#64;&#x65;&#120;&#x61;&#109;&#112;&#108;&#101;&#46;&#x63;&#111;&#x6d;</a></td>
</tr>
</tbody></table>
<p>还有表user_account存储用户的账户余额信息如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>003</td>
<td>011</td>
<td>20</td>
</tr>
</tbody></table>
<p>使用如下sql语句，可以看到，仅仅是<code>left join</code>换成了<code>right join</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">right</span> <span class="keyword">join</span> user_account <span class="keyword">on</span> user.id <span class="operator">=</span> user_account.user_id;</span><br></pre></td></tr></table></figure>

<p>结果如下：在内连接的结果基础上，增加了<code>右表user_account表</code>剩下的1条数据，左表的字段内容则是<code>null</code>，代表没有对应字段的数据。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>Gender</th>
<th>Mobile</th>
<th>Email</th>
<th>ID2</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>13800001234</td>
<td><a href="mailto:&#122;&#104;&#97;&#110;&#103;&#x73;&#97;&#x6e;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#108;&#101;&#x2e;&#99;&#111;&#x6d;">&#122;&#104;&#97;&#110;&#103;&#x73;&#97;&#x6e;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#108;&#101;&#x2e;&#99;&#111;&#x6d;</a></td>
<td>001</td>
<td>001</td>
<td>10</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>女</td>
<td>13900005678</td>
<td><a href="mailto:&#108;&#105;&#115;&#105;&#64;&#101;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#101;&#46;&#99;&#111;&#x6d;">&#108;&#105;&#115;&#105;&#64;&#101;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#101;&#46;&#99;&#111;&#x6d;</a></td>
<td>002</td>
<td>002</td>
<td>20</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>003</td>
<td>011</td>
<td>20</td>
</tr>
</tbody></table>
<h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><p>在MySQL中，子查询是一种强大的功能，允许在一个查询中嵌套另一个查询。根据子查询返回的结果类型，可以将其分为以下几种：</p>
<ul>
<li>表子查询</li>
<li>行子查询</li>
<li>列子查询</li>
<li>标量子查询</li>
</ul>
<blockquote>
<p>注意：所有的子查询应该慎重使用，因为子查询会导致查询速度降低。</p>
</blockquote>
<table>
<thead>
<tr>
<th>子查询类型</th>
<th>定义</th>
<th>特点</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>表子查询</strong></td>
<td>返回一个完整的表（多行多列）</td>
<td>通常用于<code>FROM</code>子句或<code>JOIN</code>操作中，结果是一个表结构</td>
<td><code>sql &lt;br&gt;SELECT * FROM (SELECT id, name FROM users) AS subquery;&lt;br&gt; </code></td>
</tr>
<tr>
<td><strong>行子查询</strong></td>
<td>返回一行数据（多列）</td>
<td>通常用于<code>WHERE</code>子句中，结果是一行数据，可以与多列比较</td>
<td><code>sql &lt;br&gt;SELECT * FROM users WHERE (id, name) = (SELECT id, name FROM users WHERE age = 25);&lt;br&gt;</code></td>
</tr>
<tr>
<td><strong>列子查询</strong></td>
<td>返回一列数据（多行）</td>
<td>通常用于<code>WHERE</code>子句中，结果是一列数据，可以与<code>IN</code>、<code>ANY</code>、<code>ALL</code>等操作符配合使用</td>
<td><code>sql&lt;br&gt;SELECT * FROM users WHERE id IN (SELECT id FROM orders);&lt;br&gt;</code></td>
</tr>
<tr>
<td><strong>标量子查询</strong></td>
<td>返回单个值（一行一列）</td>
<td>通常用于<code>WHERE</code>子句中，结果是一个单一值，可以与比较操作符配合使用</td>
<td><code>sql&lt;br&gt;SELECT * FROM users WHERE age = (SELECT MAX(age) FROM users);&lt;br&gt;</code></td>
</tr>
</tbody></table>
<h6 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h6><ul>
<li>定义：返回一个完整的表（多行多列）。</li>
<li>特点：可以作为虚拟表使用，通常用于FROM子句或JOIN操作中。</li>
<li>示例：SELECT id, name FROM users 这就是一个子查询，该子查询返回的结果是一张表的数据，将该子查询的结果作为一张表，供外部的查询使用。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> users) <span class="keyword">AS</span> subquery;</span><br></pre></td></tr></table></figure>

<h6 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h6><ul>
<li>定义：返回一行数据（多列）。</li>
<li>特点：结果是一行数据，可以与多列比较，通常用于WHERE子句中。</li>
<li>示例：SELECT id, name FROM users WHERE mobile &#x3D; “13012345678” 是一个子查询，该子查询返回了mobile字段等于13012345678的一行数据，并且只查询了id和name字段。将这两个字段作为外部查询的where条件。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> (id, name) <span class="operator">=</span> (<span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> mobile <span class="operator">=</span> &quot;13012345678&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h6><ul>
<li>定义：返回一列数据（多行）。</li>
<li>特点：结果是一列数据，可以与IN、ANY、ALL等操作符配合使用，通常用于WHERE子句中。</li>
<li>示例：SELECT user_id FROM orders 是一个子查询，该子查询返回了orders表的所有用户id信息，并将这些用户id作为外部查询的where条件。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> user_id <span class="keyword">FROM</span> orders);</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h6><ul>
<li>定义：返回单个值（一行一列）。</li>
<li>特点：结果是一个单一值，可以与比较操作符配合使用，通常用于WHERE子句中。</li>
<li>示例：SELECT MAX(age) FROM users 是一个子查询，该子查询返回了users表的最大的年龄信息，并将最大的用户年龄作为外部查询的where条件。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> age <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(age) <span class="keyword">FROM</span> users);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h5><ul>
<li>group语句可以实现分组的效果，什么是分组？</li>
</ul>
<p>假设该数据表中存储了10条订单信息，有3条是张三的，3条是李四的，剩下4条是王五的。</p>
<p>group分组以后就可以分成3组，一组是张三的3条数据，一组是李四的3条数据，一组是王五的4条数据。</p>
<ul>
<li>分组能干什么？</li>
</ul>
<p>分组以后可以统计每个分组中的订单数量、订单总额、订单平均金额等。</p>
<p>语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> col_name</span><br></pre></td></tr></table></figure>

<p>支持的聚合函数：</p>
<ul>
<li>count(col_name): 计算每个分组中该字段的数量，比如订单数量</li>
<li>sum(col_name): 计算每个分组中该字段的总额，比如订单总金额</li>
<li>avg(col_name): 计算每个分组中该字段的平均值，比如订单平均金额</li>
<li>min(col_name): 获取每个分组中该字段的最小值</li>
<li>max(col_name): 获取每个分组中该字段的最大值</li>
</ul>
<p>有人要问了？那我不使用<code>group by</code>的情况下，可以使用上面的聚合函数吗？</p>
<p>当然可以了，没有分组，其实相当于所有数据是一个大分组，所以计算的是所有数据数量、总额等。</p>
<p>示例：下表是订单表，记录了3个用户的订单信息，现在需要查询这3个用户的订单数量、订单总金额、订单平均金额、最小金额以及最大金额。</p>
<table>
<thead>
<tr>
<th>OrderID</th>
<th>UserID</th>
<th>OrderDate</th>
<th>OrderAmount</th>
<th>OrderStatus</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>1</td>
<td>2025-02-01</td>
<td>120.00</td>
<td>Completed</td>
</tr>
<tr>
<td>1002</td>
<td>1</td>
<td>2025-02-02</td>
<td>85.00</td>
<td>Pending</td>
</tr>
<tr>
<td>1003</td>
<td>1</td>
<td>2025-02-03</td>
<td>230.00</td>
<td>Shipped</td>
</tr>
<tr>
<td>1004</td>
<td>2</td>
<td>2025-02-04</td>
<td>150.00</td>
<td>Completed</td>
</tr>
<tr>
<td>1005</td>
<td>2</td>
<td>2025-02-05</td>
<td>90.25</td>
<td>Pending</td>
</tr>
<tr>
<td>1006</td>
<td>2</td>
<td>2025-02-06</td>
<td>110.00</td>
<td>Shipped</td>
</tr>
<tr>
<td>1007</td>
<td>3</td>
<td>2025-02-07</td>
<td>100.00</td>
<td>Completed</td>
</tr>
<tr>
<td>1008</td>
<td>3</td>
<td>2025-02-08</td>
<td>200.00</td>
<td>Pending</td>
</tr>
<tr>
<td>1009</td>
<td>3</td>
<td>2025-02-09</td>
<td>130.75</td>
<td>Shipped</td>
</tr>
<tr>
<td>1010</td>
<td>3</td>
<td>2025-02-10</td>
<td>160.00</td>
<td>Completed</td>
</tr>
</tbody></table>
<p>使用如下sql：对userID进行分组，就可以分成三组数据了，在对每个分组使用聚合函数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, <span class="built_in">count</span>(OrderID), <span class="built_in">sum</span>(OrderAmount), <span class="built_in">avg</span>(OrderAmount), <span class="built_in">min</span>(OrderAmount), <span class="built_in">max</span>(OrderAmount)</span><br><span class="line"><span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> UserID</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<table>
<thead>
<tr>
<th>UserID</th>
<th>count(OrderID)</th>
<th>sum(OrderAmount)</th>
<th>avg(OrderAmount)</th>
<th>min(OrderAmount)</th>
<th>max(OrderAmount)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>3</td>
<td>435.00</td>
<td>145.00</td>
<td>85.00</td>
<td>230.00</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>350.25</td>
<td>116.75</td>
<td>90.25</td>
<td>150.00</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>590.75</td>
<td>147.68</td>
<td>100.00</td>
<td>200.00</td>
</tr>
</tbody></table>
<h5 id="having"><a href="#having" class="headerlink" title="having"></a>having</h5><p><code>having</code>语句用来过滤<code>group by</code>分组以后的数据。</p>
<p>简单点说，就是相当于where条件，只不过<code>where条件</code>的执行顺序在<code>group by</code>之前，having条件的执行顺序在group by之后。</p>
<p>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> col_name [<span class="keyword">having</span> col_name <span class="operator">=</span> 任何数]</span><br></pre></td></tr></table></figure>

<p>示例：还是上面group by的表，这次我们只需要总金额大于400的数据，从上面的结果来看，我们知道，只需要userId为1和3的数据。</p>
<p>但是注意，<code>where条件</code>是在<code>group by</code>之前执行，这个时候还没有总金额这个字段呢。所以，就需要使用<code>having</code>了。</p>
<p>使用的sql如下：可以看到，仅仅是在后面增加了<code>having sum(OrderAmount) &gt; 400</code>这一条。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, <span class="built_in">count</span>(OrderID), <span class="built_in">sum</span>(OrderAmount), <span class="built_in">avg</span>(OrderAmount), <span class="built_in">min</span>(OrderAmount), <span class="built_in">max</span>(OrderAmount)</span><br><span class="line"><span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> UserID <span class="keyword">having</span> <span class="built_in">sum</span>(OrderAmount) <span class="operator">&gt;</span> <span class="number">400</span></span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<table>
<thead>
<tr>
<th>UserID</th>
<th>count(OrderID)</th>
<th>sum(OrderAmount)</th>
<th>avg(OrderAmount)</th>
<th>min(OrderAmount)</th>
<th>max(OrderAmount)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>3</td>
<td>435.00</td>
<td>145.00</td>
<td>85.00</td>
<td>230.00</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>590.75</td>
<td>147.68</td>
<td>100.00</td>
<td>200.00</td>
</tr>
</tbody></table>
<h5 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h5><p>如果想对查询出来的结果集进行排序，可以使用<code>order by</code>语句。</p>
<p>语法如下：asc代表升序，即1，2，3这种排序，desc代表降序，即3，2，1这种。默认是asc。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> col_name [<span class="keyword">asc</span>｜<span class="keyword">desc</span>]</span><br></pre></td></tr></table></figure>

<p>order by排序作用在group by分组之后，这意味着可以使用分组之后的聚合函数的结果进行排序，同时也意味着可以影响group by之后的数据。</p>
<p>示例：对上面group by之后的数据按照总金额进行降序排序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UserID, <span class="built_in">count</span>(OrderID), <span class="built_in">sum</span>(OrderAmount), <span class="built_in">avg</span>(OrderAmount), <span class="built_in">min</span>(OrderAmount), <span class="built_in">max</span>(OrderAmount)</span><br><span class="line"><span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> UserID <span class="keyword">having</span> <span class="built_in">sum</span>(OrderAmount) <span class="operator">&gt;</span> <span class="number">400</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">sum</span>(OrderAmount) <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<table>
<thead>
<tr>
<th>UserID</th>
<th>count(OrderID)</th>
<th>sum(OrderAmount)</th>
<th>avg(OrderAmount)</th>
<th>min(OrderAmount)</th>
<th>max(OrderAmount)</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>4</td>
<td>590.75</td>
<td>147.68</td>
<td>100.00</td>
<td>200.00</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>435.00</td>
<td>145.00</td>
<td>85.00</td>
<td>230.00</td>
</tr>
</tbody></table>
<h5 id="group-和-order的差别"><a href="#group-和-order的差别" class="headerlink" title="group 和 order的差别"></a>group 和 order的差别</h5><table>
<thead>
<tr>
<th align="left">group</th>
<th align="left">order</th>
</tr>
</thead>
<tbody><tr>
<td align="left">分组行，但输出可能不是分组的排序</td>
<td align="left">排序产生的输出</td>
</tr>
<tr>
<td align="left">只能使用选择列或表达式列</td>
<td align="left">任意列都可以使用</td>
</tr>
<tr>
<td align="left">若与聚合函数一起使用列或表达式, 则必须使用group</td>
<td align="left">不一定需要</td>
</tr>
</tbody></table>
<h5 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h5><p>如果不想每次都查询数据表的全部数据，只想获取几条数据呢？比如分页功能，一页10条数据这种，就可以使用<code>limit</code>命令来实现。</p>
<p>语法如下：start代表开始的位置，end代表结束的位置。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> orders </span><br><span class="line">limit [<span class="keyword">start</span>, <span class="keyword">end</span>]</span><br></pre></td></tr></table></figure>

<p>比如表中有100条数据。获取1-10条数据就是<code>limit 1,10</code>，获取11-20条数据就是<code>limit 11,20</code>。</p>
<p>limit最好是配合order by使用。性能更佳，另外，如果只获取1条数据，也建议使用<code>limit 1</code>代表获取1条数据。</p>
<p>具体的原因在后面原理篇会讲到。</p>
]]></content>
      <categories>
        <category>CMU15445</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL零基础教程基础篇</title>
    <url>/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8BSQL%E7%AF%87.html</url>
    <content><![CDATA[<h1 id="MySQL零基础教程基础篇"><a href="#MySQL零基础教程基础篇" class="headerlink" title="MySQL零基础教程基础篇"></a>MySQL零基础教程基础篇</h1><p>大家好，我是大头，98年，职高毕业，做过上市公司架构师，做过大厂资深开发，管理过10人团队，我是如何做到的呢？</p>
<p>这离不开持续学习的能力，而其中最重要的当然是数据库技术了！</p>
<p>对于所有开发来说，都离不开数据库，因为所有的数据都是要存储的。</p>
<p>关注我一起学习！可获得系统性的学习教程、转码经验、技术交流、大厂内推等～</p>
<p>文末有惊喜哦！</p>
<p>基础篇的内容大致如下图所示。</p>
<p><img src="/../images/mysql/mysql1-1.png" alt="概念学习"></p>
<h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><p>介绍完概念以后，我们可以来看看SQL语句了。SQL语句通常由三类组成。</p>
<p>数据定义 DDL</p>
<ul>
<li>CREATE 创建数据库或数据库对象</li>
<li>ALTER 对数据库或数据库对象进行修改</li>
<li>DROP 删除数据库或数据库对象<br>数据操纵 DML</li>
<li>SELECT 从表或视图中检索数据</li>
<li>INSERT 将数据插入到表或视图中</li>
<li>UPDATE 修改表或视图中的数据</li>
<li>DELETE 从表或视图中删除数据<br>数据控制 DCL</li>
<li>GRANT 用于授予权限</li>
<li>REVOKE 用于收回权限</li>
</ul>
<h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p>DCL（Data Control Language）语句用于控制对数据库的访问权限，包括用户权限的授予和撤销。DCL语句主要涉及用户和角色的权限管理，确保数据库的安全性和数据的完整性。</p>
<ul>
<li>授予权限（GRANT）</li>
<li>撤销权限（REVOKE）</li>
<li>设置用户密码（SET PASSWORD）</li>
<li>查看用户权限（SHOW GRANTS）</li>
</ul>
<h4 id="GRANT"><a href="#GRANT" class="headerlink" title="GRANT"></a>GRANT</h4><ul>
<li>GRANT语句用于授予用户或角色特定的权限。</li>
<li>权限可以包括对表、视图、存储过程等的访问和操作权限。</li>
</ul>
<p>语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> privilege_type <span class="keyword">ON</span> object_name <span class="keyword">TO</span> user_or_role;</span><br></pre></td></tr></table></figure>

<p>示例：授予用户zhangsan对employees表的SELECT和INSERT权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> employees <span class="keyword">TO</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="REVOKE"><a href="#REVOKE" class="headerlink" title="REVOKE"></a>REVOKE</h4><ul>
<li>REVOKE语句用于撤销用户或角色的特定权限。</li>
<li>撤销的权限可以是之前授予的任何权限。</li>
</ul>
<p>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> privilege_type <span class="keyword">ON</span> object_name <span class="keyword">FROM</span> user_or_role;</span><br></pre></td></tr></table></figure>

<p>示例：撤销用户zhangsan对employees表的INSERT权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> employees <span class="keyword">FROM</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="SET-PASSWORD"><a href="#SET-PASSWORD" class="headerlink" title="SET PASSWORD"></a>SET PASSWORD</h4><ul>
<li>SET PASSWORD语句用于设置或更改用户的密码。</li>
</ul>
<p>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> <span class="keyword">user</span> <span class="operator">=</span> <span class="string">&#x27;new_password&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>示例：设置用户zhangsan的新密码为new_password。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;new_password&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="SHOW-GRANTS"><a href="#SHOW-GRANTS" class="headerlink" title="SHOW GRANTS"></a>SHOW GRANTS</h4><ul>
<li>SHOW GRANTS语句用于查看用户的权限。</li>
</ul>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p>示例如下：查看用户zhangsan的权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>DCL主要是对于权限的控制，希望大家可以自己创建一个数据库a，在创建一个用户a,授予a用户a数据库的权限。进行练习。</p>
<h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><p>DDL（Data Definition Language，数据定义语言）是SQL语言的一部分，用于定义和修改数据库的结构。DDL语句主要涉及数据库、表、索引、视图等的创建、修改和删除操作。这些语句直接影响数据库的结构，但不会直接操作数据本身。</p>
<h4 id="数据库模式定义"><a href="#数据库模式定义" class="headerlink" title="数据库模式定义"></a>数据库模式定义</h4><h5 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h5><p>使用 <code>CREATE DATABASE</code> 语句，<code>IF NOT EXISTS</code>代表没有这个数据库，才会进行创建。如果已经有了，则不会再创建了。</p>
<p><code>CHARACTER SET</code>是设置字符集，推荐设置为utf8mb4字符集，<code>COLLATE</code>则使用默认的就可以了。</p>
<p>这里说一下<code>utf8</code>和<code>utf8mb4</code>这两个字符集的区别。</p>
<ul>
<li>utf8字符集：在MySQL中实际上是一个有限的字符集，它只支持最多3字节的UTF-8字符。这意味着它不能存储所有可能的Unicode字符，特别是那些需要4字节表示的字符（如某些表情符号）。utf8字符集支持的Unicode范围是U+0000到U+FFFF，即基本多语言平面（BMP）。</li>
<li>utf8mb4字符集支持完整的UTF-8字符集，包括4字节的字符。这意味着它可以存储所有可能的Unicode字符，包括表情符号和一些罕见的字符。utf8mb4字符集支持的Unicode范围是U+0000到U+10FFFF，即整个Unicode范围。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> &#123;DATABASE&#125; [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] db_name</span><br><span class="line">[<span class="keyword">DEFAULT</span>] <span class="type">CHARACTER</span> <span class="keyword">SET</span>[<span class="operator">=</span>]charset_name</span><br><span class="line"><span class="operator">|</span> [<span class="keyword">DEFAULT</span>] <span class="keyword">COLLATE</span>[<span class="operator">=</span>]collation_name</span><br></pre></td></tr></table></figure>

<p>创建一个测试数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database test;</span><br></pre></td></tr></table></figure>

<h5 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h5><p>使用<code>show databases</code>命令可以查看所有的数据库。也包括一些MySQL自带的数据库。这些数据库存储了MySQL的元数据，具体的等到原理篇会讲到。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> &#123;DATABASES&#125;</span><br><span class="line">[<span class="keyword">LIKE</span> <span class="keyword">pattern</span> <span class="operator">|</span> <span class="keyword">WHERE</span> expr] </span><br></pre></td></tr></table></figure>

<h5 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h5><p>使用<code>use</code>指令➕数据库名称可以选择数据库，或者说进入数据库。只有先进入一个数据库，才能操作这个数据库里面的数据表等等。</p>
<p>除此之外，也可以在操作数据表的前面加上数据库名称，但是那样比较麻烦。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use db_name</span><br></pre></td></tr></table></figure>

<h5 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h5><p>使用<code>ALTER DATABASE</code>指令可以修改数据库。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE db_name</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> gb2312</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> gb2312_chinese_ci;</span><br></pre></td></tr></table></figure>

<h5 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h5><p>当这个数据库不再使用的时候，可以通过<code>DROP DATABSE</code>指令来删除掉这个数据库。</p>
<p><code>IF EXISTS</code>代表存在则删除，不存在就不会删除。和创建的时候那个指令正好相反。都是可选指令。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> &#123;DATABASE&#125; [IF <span class="keyword">EXISTS</span>] db_name;</span><br></pre></td></tr></table></figure>


<h4 id="表定义"><a href="#表定义" class="headerlink" title="表定义"></a>表定义</h4><p>数据表被定义为字段的集合<br>按 <code>行</code> 和<code>列</code>的格式存储<br>每一行代表一条记录<br>每一列代表记录中一个字段的取值</p>
<h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><p>使用<code>create table</code>指令可以创建数据表，后面跟的是表名称和字段。</p>
<p><code>temporary</code>表示临时表，临时表存放在内存中。</p>
<p>字段类型常用的如下：</p>
<ul>
<li>int类型，占11位，也可以设置为int(5)等，但是这个只影响展示，并不影响实际的存储。</li>
<li>varchar&#x2F;char类型，相当于字符串类型，varchar是可变长度的字符串，char是不可变长度的字符串。</li>
<li>text类型，很不推荐使用该类型，会导致查询速度变慢，尽量使用varchar代替。</li>
<li>timestamp时间戳类型，不推荐使用，因为该类型表示1970年到现在的秒数，最大只能到2038-01-19号，而现在已经2025年了。</li>
<li>datetime类型，推荐使用这个代替时间戳，直接存储时间类型，并且表里的updated_time字段可以使用<code>DEFAULT CURRENT_TIMESTAMP</code>作为默认值，还可以使用<code>ON UPDATE CURRENT_TIMESTAMP</code>来实现自动更新。</li>
<li>decimal类型,用来存储小数，使用定点小数来存储，可以防止精度丢失。请避免使用<code>float</code>和<code>double</code>来存储小数。</li>
<li>json类型，可以存储json字符串。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [temporary] <span class="keyword">table</span> [if <span class="keyword">not</span> <span class="keyword">exists</span>] tbl_name</span><br><span class="line">(</span><br><span class="line">    字段名<span class="number">1</span> 数据类型 [列完整性约束条件] [默认值]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h5><p>对于创建的表结构不满意，可以通过<code>ALTER TABLE</code>指令来修改表结构。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br></pre></td></tr></table></figure>

<p>下面介绍一些子句，配合alter table命令来执行。</p>
<ul>
<li>ADD [COLUMN] 子句：给表结构增加字段。</li>
<li>change [COLUMN] 子句：修改表结构的字段类型、字段名称等。<ul>
<li>CHANGE COLUMN name new_name VARCHAR(200);</li>
</ul>
</li>
<li>alter [column] 子句 修改或删除表中指定列的默认值。<ul>
<li>alter colum city set default ‘bj’</li>
</ul>
</li>
<li>modify [column] 子句 只修改指定列的数据类型，不会干涉它的列名<ul>
<li>modify column city char(50);</li>
</ul>
</li>
<li>drop [column] 子句 删除指定列<ul>
<li>drop column city;</li>
</ul>
</li>
<li>rename [to] 子句 修改表名<ul>
<li>rename table table_name to new_table_name</li>
</ul>
</li>
<li>add index index_name(column_name) 创建索引</li>
<li>drop index index_name</li>
</ul>
<h5 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h5><p>当一个表不再使用的时候，也可以使用<code>drop table</code>将它删除。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> [temporary] <span class="keyword">table</span> [if <span class="keyword">exists</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h5><p>可以通过<code>SHOW CREATE TABLE</code>来查看表结构。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename;</span><br></pre></td></tr></table></figure>

<h4 id="索引定义"><a href="#索引定义" class="headerlink" title="索引定义"></a>索引定义</h4><p>索引是提高数据文件访问效率的有效方法，比如MySQL中的B+树索引、hash索引、全文索引等。</p>
<p>缺点</p>
<ul>
<li>索引是以文件的形式存储的，如果有大量的索引，索引文件可能比数据文件更快达到最大的文件尺寸</li>
<li>索引在提高查询速度的同时，会降低更新表的速度</li>
</ul>
<h5 id="索引物理结构"><a href="#索引物理结构" class="headerlink" title="索引物理结构"></a>索引物理结构</h5><ul>
<li>b+树索引</li>
<li>hash索引</li>
<li>倒排索引</li>
</ul>
<h5 id="索引逻辑结构"><a href="#索引逻辑结构" class="headerlink" title="索引逻辑结构"></a>索引逻辑结构</h5><ul>
<li>index 或 key： 普通索引</li>
<li>unique ：唯一性索引 候选码</li>
<li>primary key： 主键</li>
</ul>
<h5 id="索引逻辑概念"><a href="#索引逻辑概念" class="headerlink" title="索引逻辑概念"></a>索引逻辑概念</h5><ul>
<li>聚簇索引：比如主键索引，也就是b树的叶子节点存储数据的索引。</li>
<li>联合索引：由多个字段共同组成的索引。</li>
<li>覆盖索引：查询的字段和索引的字段一致，从而避免了再次去主键索引获取数据。</li>
</ul>
<p>关于索引的具体讲解将放在原理篇讲解，这里以介绍DDL语句为主，有个概念就可以了。</p>
<h5 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h5><p>想要创建一个索引可以使用<code>create index</code>命令，<code>unique</code>表示创建唯一索引。</p>
<p><code>index_col_name</code>表示要将索引创建在哪个字段上面，也可以是多个字段。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>] index index_name</span><br><span class="line"><span class="keyword">on</span> table_name(index_col_name)</span><br></pre></td></tr></table></figure>

<p>示例，在user表上的<code>email</code>字段上创建一个索引，索引名称是<code>email_idx</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index email_idx</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">user</span>(email);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>索引并不是越多越好，太多的索引会导致维护成本升高，尽量少且有用即可。尤其是后续增加索引的时候，如果数据表中数据过多，建立索引的过程会较慢，会对业务产生影响，这个时候需要慎重。</p>
</blockquote>
<h5 id="索引删除"><a href="#索引删除" class="headerlink" title="索引删除"></a>索引删除</h5><p>当索引不再使用的时候，可以删除索引，使用命令<code>drop index</code>可以删除索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> [<span class="keyword">unique</span>] index index_name</span><br><span class="line"><span class="keyword">on</span> table_name</span><br></pre></td></tr></table></figure>

<p>示例：删除刚才建立的<code>email_idx</code>索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index email_idx</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<h4 id="视图定义"><a href="#视图定义" class="headerlink" title="视图定义"></a>视图定义</h4><p>什么是视图</p>
<ul>
<li>视图是一个对象，他是数据库提供给用户的以多种角度观察数据库中数据的一种重要机制</li>
<li>视图不是数据库中真实的表，而是一张虚拟表，其自身并不存储数据</li>
</ul>
<p>视图的优点</p>
<ul>
<li>集中分散数据</li>
<li>简化查询语句</li>
<li>重用SQL语句</li>
<li>保护数据安全</li>
<li>共享所需数据</li>
<li>更改数据格式</li>
</ul>
<h5 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h5><p>想要创建视图，可以使用<code>create view</code>指令。</p>
<p><code>or replace</code> 防止报错，存在替换，不存在创建。<br><code>with check option</code> 增删改查的时候检查视图条件。<br><code>select_statement</code> 是一段select查询语句。视图的本质就是这一段select查询语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">view</span> view_name [(col_list)]</span><br><span class="line"><span class="keyword">as</span> select_statement</span><br><span class="line">[<span class="keyword">with</span> <span class="keyword">check</span> option]</span><br></pre></td></tr></table></figure>

<p>示例：创建一个<code>zhangsan</code>用户的登录记录的视图。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> zhangsan</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> login_log <span class="keyword">where</span> <span class="keyword">user</span> <span class="operator">=</span> ‘zhangsan’</span><br></pre></td></tr></table></figure>

<h5 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h5><p>想要修改视图，可以使用<code>alter view</code>指令。</p>
<p>修改视图其实就是修改这个查询语句。当然了，也可以修改其他的属性等。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> view_name [(col_list)]</span><br><span class="line"><span class="keyword">as</span> select_statement</span><br><span class="line">[<span class="keyword">with</span> <span class="keyword">check</span> option]</span><br></pre></td></tr></table></figure>

<h5 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h5><p>当视图不需要了，可以使用<code>drop view</code>指令删除视图。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [IF <span class="keyword">EXISTS</span>] view_name</span><br></pre></td></tr></table></figure>

<p>示例：删除刚才创建的视图zhangsan</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">view</span> zhangsan</span><br></pre></td></tr></table></figure>

<h5 id="查看视图定义"><a href="#查看视图定义" class="headerlink" title="查看视图定义"></a>查看视图定义</h5><p>和上面说的查看表的定义一样，也可以查看视图的定义。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> view_name</span><br></pre></td></tr></table></figure>

<h4 id="存储过程定义"><a href="#存储过程定义" class="headerlink" title="存储过程定义"></a>存储过程定义</h4><p><code>存储过程</code> 是一组为了完成某项特定功能的 <code>SQL语句集</code></p>
<ul>
<li>可增强SQL语言的功能和灵活性</li>
<li>良好的封装性</li>
<li>高性能</li>
<li>可减少网络流量</li>
<li>可作为一种安全机制来确保数据库的安全性和数据的完整性<br>其实质就是一段存储在数据库中的 <code>代码</code><br>它可以由声明式的sql语句和过程式sql语句组成</li>
</ul>
<h5 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h5><p><code>DELIMITER $$</code>是用户定义的MYSQL 结束符</p>
<p>参数：in|out|inout 参数名 参数类型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> sp_name(参数)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">body <span class="operator">/</span><span class="operator">/</span>存储过程代码</span><br><span class="line"><span class="keyword">END</span> $$</span><br></pre></td></tr></table></figure>

<p>示例：查询员工表的名称、部门和薪资。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> get_employee_details(<span class="keyword">IN</span> emp_id <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> name, department, salary</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> id <span class="operator">=</span> emp_id;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h5 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h5><p>调用需要使用<code>call</code>指令来调用。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> sp_name(参数)</span><br></pre></td></tr></table></figure>

<p>示例：调用刚才的存储过程。 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> get_employee_details(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h5 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h5><p>如果存储过程不再需要了，则可以通过<code>drop procedure</code>指令来删除它。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> sp_name</span><br></pre></td></tr></table></figure>

<p>示例：删除刚才的存储过程。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> get_employee_details;</span><br></pre></td></tr></table></figure>

<h4 id="存储函数定义"><a href="#存储函数定义" class="headerlink" title="存储函数定义"></a>存储函数定义</h4><p>存储函数由SQL语句和过程式语句组成。</p>
<h5 id="创建存储函数"><a href="#创建存储函数" class="headerlink" title="创建存储函数"></a>创建存储函数</h5><p>使用 <code>create function</code>指令可以创建一个存储函数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> sp_name(参数)</span><br><span class="line">    <span class="keyword">returns</span> type</span><br><span class="line">    routine_body <span class="operator">/</span><span class="operator">/</span>主体</span><br></pre></td></tr></table></figure>

<p>示例：给定id号返回性别。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use test; <span class="operator">/</span><span class="operator">/</span>进入数据库test</span><br><span class="line">delimiter $$ <span class="operator">/</span><span class="operator">/</span>声明结束符号</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> fn_search(cid <span class="type">int</span>) <span class="operator">/</span><span class="operator">/</span>创建函数fn <span class="keyword">search</span>，参数为cid，<span class="type">int</span>类型</span><br><span class="line">    <span class="keyword">returns</span> <span class="type">char</span>(<span class="number">20</span>) <span class="operator">/</span><span class="operator">/</span>声明返回值类型char20</span><br><span class="line">    <span class="keyword">deterministic</span></span><br><span class="line"><span class="keyword">begin</span> <span class="operator">/</span><span class="operator">/</span>开始</span><br><span class="line">    <span class="keyword">declare</span> sex <span class="type">char</span>(<span class="number">20</span>) <span class="operator">/</span><span class="operator">/</span>声明一个变量sex 类型char20</span><br><span class="line">    <span class="keyword">select</span> cust_sex <span class="keyword">into</span> sex <span class="keyword">from</span> customers <span class="keyword">where</span> id <span class="operator">=</span> cid; <span class="operator">/</span><span class="operator">/</span><span class="keyword">select</span>语句，把查询出来的cust_sex字段内容放入变量sex中</span><br><span class="line">    if sex <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="operator">/</span><span class="operator">/</span>if判断，如果sex变量是<span class="keyword">null</span>，则返回<span class="string">&#x27;没有该客户&#x27;</span></span><br><span class="line">        <span class="keyword">return</span>(<span class="keyword">select</span> <span class="string">&#x27;没有该客户&#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="operator">/</span><span class="operator">/</span>如果sex变量不是<span class="keyword">null</span></span><br><span class="line">        if sex <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">then</span> <span class="operator">/</span><span class="operator">/</span>则判断是F的话，返回<span class="string">&#x27;女&#x27;</span></span><br><span class="line">            <span class="keyword">return</span>(<span class="keyword">select</span> <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="operator">/</span><span class="operator">/</span> 不然的话就返回<span class="string">&#x27;男&#x27;</span></span><br><span class="line">            <span class="keyword">return</span>(<span class="keyword">select</span> <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        <span class="keyword">end</span> if;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span> $$</span><br></pre></td></tr></table></figure>

<h5 id="调用存储函数"><a href="#调用存储函数" class="headerlink" title="调用存储函数"></a>调用存储函数</h5><p>使用 select 调用存储函数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sp_name(参数)；</span><br></pre></td></tr></table></figure>

<p>示例：调用刚才的存储函数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> fn_search(<span class="number">1</span>)$$</span><br></pre></td></tr></table></figure>

<h5 id="删除存储函数"><a href="#删除存储函数" class="headerlink" title="删除存储函数"></a>删除存储函数</h5><p>当存储函数不再使用的时候，可以使用<code>drop function</code>将它删除。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">function</span> fun_name</span><br></pre></td></tr></table></figure>

<p>示例：删除刚才的存储函数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">function</span> fn_search</span><br></pre></td></tr></table></figure>

<h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>以上就是整体的MySQL学习路线了。</p>
<p>关注我发送“MySQL知识图谱”领取完整的MySQL学习路线。</p>
<p>发送“电子书”即可领取价值上千的电子书资源。</p>
<p>部分电子书如图所示。</p>
<p><img src="/../images/bottom1.png" alt="概念学习"></p>
<p><img src="/../images/bottom2.png" alt="概念学习"></p>
<p><img src="/../images/bottom3.png" alt="概念学习"></p>
<p><img src="/../images/bottom4.png" alt="概念学习"></p>
]]></content>
      <categories>
        <category>CMU15445</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL零基础教程基础篇</title>
    <url>/MySQL%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87.html</url>
    <content><![CDATA[<h1 id="MySQL零基础教程基础篇"><a href="#MySQL零基础教程基础篇" class="headerlink" title="MySQL零基础教程基础篇"></a>MySQL零基础教程基础篇</h1><p>大家好，我是大头，98年，职高毕业，上市公司架构师，大厂资深开发，管理过10人团队，我是如何做到的呢？</p>
<p>这离不开持续学习的能力，而其中最重要的当然是数据库技术了！</p>
<p>对于所有开发来说，都离不开数据库，因为所有的数据都是要存储的。</p>
<p>关注我一起学习！文末有惊喜哦！</p>
<p>基础篇的内容大致如下图所示。</p>
<p><img src="/../images/mysql/mysql1-1.png" alt="概念学习"></p>
<h2 id="概念学习"><a href="#概念学习" class="headerlink" title="概念学习"></a>概念学习</h2><p>首先，我们应该知道什么是数据库？很多人都会搞混一个概念，那就是数据库和数据库管理系统。</p>
<p>数据库的英文是<code>DataBase</code>。它的概念是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库是一个长期存储在计算机内的、有组织的、可共享的数据集合，它具有以下特点</span><br><span class="line">1. 数据的集合性</span><br><span class="line">2. 数据的共享性</span><br><span class="line">3. 数据的冗余度低</span><br><span class="line">4. 数据的独立性</span><br><span class="line">5. 数据的安全性</span><br><span class="line">6. 数据的完整性</span><br><span class="line">7. 数据的可维护性</span><br></pre></td></tr></table></figure>

<p>而数据库管理系统的英文是<code>DataBase Management System</code>。它的概念是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库管理系统（Database Management System，简称DBMS）是用于创建、管理、维护和操作数据库的软件系统。它在用户和数据库之间提供了一个接口，使得用户能够方便地存储、检索、更新和管理数据。</span><br></pre></td></tr></table></figure>

<p>因此，我们要明白，<code>MySQL</code>是一个数据库管理系统，而不是一个数据库。</p>
<p>虽然我们老说<code>MySQL数据库</code>，但这个是因为大家已经习惯了，大家都明白MySQL是什么，因此省略了一些。</p>
<p><code>MySQL</code>是用来管理数据库的一个系统。</p>
<p>那么问题来了，<code>SQL</code>又是什么呢？</p>
<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>SQL（Structured Query Language，结构化查询语言）是一种用于管理和操作关系数据库的标准编程语言。它允许用户定义、查询、更新和管理数据库中的数据。SQL 是关系数据库管理系统（RDBMS）的核心语言，广泛应用于各种数据库系统。</p>
<p>这里又出现了一个新的概念，就是<code>关系数据库管理系统（RDBMS）</code>。</p>
<p>上面已经介绍了<code>数据库管理系统</code>。那什么是关系数据库管理系统呢？</p>
<h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3><p>这里就需要先说明一下什么是<code>关系数据库</code>。</p>
<p>关系数据库（Relational Database）<br>关系数据库是一种基于关系模型的数据库管理系统（DBMS），它使用表格（表）来组织和存储数据。每个表由行（记录）和列（字段）组成，每一行代表一个数据记录，每一列代表一个数据属性。关系数据库的核心概念是关系模型，它由数学家埃德加·弗兰克·科德（E.F. Codd）在1970年提出。</p>
<h4 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h4><p>Ted Codd在1969年设计了关系模型。发表了<a href="https://dl.acm.org/doi/pdf/10.1145/362384.362685">A relational model of data for large shared data banks</a> </p>
<p>关系模型将物理层和逻辑层分离，当数据的内部表示发生变化时，甚至当外部表示的某些方面发生变化时，用户在终端和大多数应用程序上的活动应该不受影响。</p>
<p>关系模型提供了一种仅用数据的自然结构来描述数据的方法，因此，它为高级数据语言提供了一个基础，这种语言将一方面在程序之间产生最大的独立性，另一方面在机器表示和数据组织之间产生最大的独立性。另一个优点是，它为处理关系的可导出性、冗余性和一致性提供了坚实的基础。</p>
<p>仍然需要消除的三种主要数据依赖是：顺序依赖、索引依赖和访问路径依赖。</p>
<ul>
<li>顺序依赖：程序展示的顺序和文件内容的存储顺序并不一致，需要各自独立。</li>
<li>索引依赖：如果程序使用索引的时候，索引被删除那么程序将出错。</li>
<li>访问路径依赖：访问数据的时候依赖数据的物理结构。</li>
</ul>
<p><code>关系</code>指的是数学意义上的关系，对于给定集合S1,S2,S3…Sn，R是n个集合上的关系，如果它是n个元组的集合，每个元组的第一个元素来自S1,第二个来自S2，以此类推。我们称Sj是R上的第j个定义域。R的阶为n(degree n)，阶为1的时候称为一元关系，2的时候称为二元关系，阶为n称为n元关系。</p>
<p>关键原则：</p>
<ul>
<li>将数据存储在简单的数据结构(关系)中</li>
<li>物理存储留给DBMS实现</li>
<li>通过高级语言访问数据，DBMS确定最佳策略。</li>
</ul>
<p>结构采用关系。确保数据库内容满足完整性约束。程序通过接口来访问和修改数据库内容。</p>
<p>关系是无序的，n元关系就是n个列的表。一个元组是一行记录。</p>
<p>关系数据库就是基于<code>关系模型</code>的数据库。</p>
<p>其具体的体现形式就是我们通常说的<code>表</code>。</p>
<p>建表语句如下。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    department <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    salary <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>除此之外，还有一些<code>关系完整性约束</code>。以确保数据的准确性和一致性。常见的完整性约束包括：</p>
<ul>
<li>主键约束（Primary Key）：确保表中每一行的唯一性。</li>
<li>外键约束（Foreign Key）：确保表之间的关系完整性。</li>
<li>唯一约束（Unique）：确保某一列或一组列的值是唯一的。</li>
<li>非空约束（NOT NULL）：确保某一列的值不能为空。</li>
<li>检查约束（CHECK）：确保某一列的值满足特定条件。</li>
</ul>
<p>这里面主键约束是必须的。<code>外键约束</code>通常不使用，因为保证这些约束，会降低数据库的性能。因此外键约束通常由代码层实现。</p>
<p>唯一约束有的时候是可以使用的，来限制唯一性，同样也可以通过代码层实现。</p>
<p>非空约束也是推荐使用的，因为<code>NULL</code>在数据库里面处理起来也有一些麻烦，也会影响性能。</p>
<p>检查约束实际上也基本不使用。</p>
<p>支持SQL标准，实现了SQL标准，最低要求实现SQL92标准。</p>
<p>关系数据库支持事务（Transaction），事务是一组操作的集合，要么全部成功，要么全部失败。事务的四个基本特性（ACID）包括：</p>
<ul>
<li>原子性（Atomicity）：事务中的所有操作要么全部成功，要么全部失败。</li>
<li>一致性（Consistency）：事务执行前后，数据库的状态保持一致。</li>
<li>隔离性（Isolation）：并发事务之间相互隔离，不会相互干扰。</li>
<li>持久性（Durability）：事务一旦提交，其结果是永久性的，即使系统故障也不会丢失。</li>
</ul>
<h3 id="SQL标准"><a href="#SQL标准" class="headerlink" title="SQL标准"></a>SQL标准</h3><p>SQL标准是一系列由国际标准化组织（ISO）和美国国家标准协会（ANSI）制定的规范，旨在确保SQL语言的统一性和兼容性。这些标准定义了SQL语言的语法、语义和行为，使得不同的数据库管理系统（DBMS）能够以一致的方式实现和使用SQL。</p>
<p>主要的SQL标准：</p>
<ol>
<li>SQL-86（1986年）：</li>
</ol>
<ul>
<li>第一个SQL标准，奠定了SQL语言的基础。</li>
<li>定义了基本的SQL语法和功能，包括数据定义语言（DDL）和数据操纵语言（DML）。</li>
</ul>
<ol start="2">
<li>SQL-89（1989年）：</li>
</ol>
<ul>
<li>对SQL-86的修订和扩展，增加了对嵌套查询和子查询的支持。</li>
<li>也称为SQL1，是第一个广泛接受的SQL标准。</li>
</ul>
<ol start="3">
<li>SQL-92（1992年）：</li>
</ol>
<ul>
<li>也称为SQL2，是SQL标准的重大更新。</li>
<li>引入了大量新功能，包括：<ul>
<li>外键约束（Foreign Key Constraints）</li>
<li>多表连接（JOIN）</li>
<li>嵌套查询（Subqueries）</li>
<li>集合操作（Set Operations）</li>
<li>视图（Views）</li>
<li>完整性约束（Integrity Constraints）</li>
</ul>
</li>
<li>SQL-92 是目前大多数数据库系统支持的基础标准。</li>
</ul>
<ol start="4">
<li>SQL:1999（1999年）：</li>
</ol>
<ul>
<li>引入了对大型对象（LOBs）、窗口函数（Window Functions）、递归查询（Recursive Queries）等的支持。</li>
<li>也称为SQL3，是SQL标准的进一步扩展。</li>
</ul>
<ol start="5">
<li>SQL:2003（2003年）：</li>
</ol>
<ul>
<li>引入了对XML数据类型和操作的支持。</li>
<li>增加了对存储过程、触发器、用户定义类型（UDTs）等的支持。</li>
</ul>
<ol start="6">
<li>SQL:2006（2006年）：</li>
</ol>
<ul>
<li>主要关注XML数据的处理和查询。</li>
<li>引入了对XQuery的支持。</li>
</ul>
<ol start="7">
<li>SQL:2008（2008年）：</li>
</ol>
<ul>
<li>引入了对时间数据类型和操作的支持。</li>
<li>增加了对分区表、数据加密等的支持。</li>
</ul>
<ol start="8">
<li>SQL:2011（2011年）：</li>
</ol>
<ul>
<li>引入了对多版本并发控制（MVCC）的支持。</li>
<li>增加了对分区表的进一步扩展。</li>
</ul>
<ol start="9">
<li>SQL:2016（2016年）：</li>
</ol>
<ul>
<li>引入了对JSON数据类型和操作的支持。</li>
<li>增加了对窗口函数的进一步扩展。</li>
</ul>
<ol start="10">
<li>SQL:2019（2019年）：</li>
</ol>
<ul>
<li>引入了对机器学习和数据分析的支持。</li>
<li>增加了对时间序列数据、地理空间数据等的支持。</li>
</ul>
<p>尽管SQL标准提供了统一的规范，但不同的数据库系统在实现上存在差异。主要的数据库系统（如MySQL、PostgreSQL、Oracle、SQL Server等）都支持SQL标准的核心功能，但在某些高级功能和扩展上可能有所不同。例如：</p>
<ul>
<li>MySQL：支持SQL:2003标准，但在某些高级功能（如窗口函数）上支持较晚。</li>
<li>PostgreSQL：支持SQL:2011标准，对SQL标准的兼容性较好。</li>
<li>Oracle：支持SQL:2011标准，但在某些功能上有自己的扩展。</li>
<li>SQL Server：支持SQL:2008标准，但在某些功能上有自己的扩展。</li>
</ul>
<p>SQL标准是一系列由ISO和ANSI制定的规范，旨在确保SQL语言的统一性和兼容性。不同的数据库系统在实现上存在差异，但都支持SQL标准的核心功能。了解数据库系统对SQL标准的支持情况，可以帮助开发者更好地编写跨数据库的SQL代码，提高代码的可移植性和兼容性。</p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><ul>
<li>关系模型：大多数数据库使用的</li>
<li>键值对模型：NOSql使用的，比如redis</li>
<li>图模型：NOSql使用的</li>
<li>文档模型：NOSql使用的，比如mongoDB</li>
<li>列存储模型</li>
<li>数组，向量模型：向量数据库，如Fassi</li>
<li>分组模型，网络模型，多值模型：已经很少使用的模型</li>
</ul>
<h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>设R为任一给定关系，如果对于R中属性X的每一个值，R中的属性Y只有唯一值与之对应，则称X函数决定Y或称Y函数依赖于X，记作X-&gt;Y.其中X称为<code>决定因素</code></p>
<p>分类：</p>
<ul>
<li>完全函数依赖</li>
<li>部分函数依赖</li>
<li>传递函数依赖</li>
</ul>
<p> 完全函数依赖：<br> 设R为任一给定关系，X,Y为其属性集，若X-&gt;Y，且对X中的任何真子集X’，都有X’不依赖Y,则称Y完全函数依赖于X</p>
<p> 部分函数依赖：<br> 设R为任一给定关系，X,Y为其属性集，若X-&gt;Y,且X中存在一个真子集X’,都有X’-&gt;Y，则称Y部分依赖于X</p>
<p> 传递函数依赖：<br> 设R为任一给定关系，X,Y,Z为其不同属性子集，若X-&gt;Y,Y不决定X,Y-&gt;Z,则有X-&gt;Z，称为Z传递函数依赖于X。</p>
<h3 id="设计范式"><a href="#设计范式" class="headerlink" title="设计范式"></a>设计范式</h3><p>一个低一级范式的关系模式通过<code>模式分解</code>可以转换为若干个高一级范式的关系模式的集合，这种过程就叫<code>规范化</code></p>
<p>第一范式1NF:<br>设R为任一给定关系，如果R中每个列与行的交点处的取值都是不可再分的基本元素，则R为第一范式</p>
<p>第二范式2NF:<br>设R为任一给定关系，若R为1NF<br>且其所有非主属性都完全函数依赖于候选关键字，则R为第二范式。</p>
<p>候选关键字：能唯一表示一行数据的就是候选关键字，比如主键，比如唯一索引等。</p>
<p>第三范式3NF:<br>设R为任一给定关系，若R为2NF<br>且其每一个非主属性都不传递函数依赖于候选关键字，则R为第三范式。</p>
<p>第三范式的改进形式BCNF:<br>设R为任意给定关系，X,Y为其属性集，F为其函数依赖集，若R为3NF<br>且其F中所有函数依赖X-&gt;Y(Y不属于X)中的X比包含候选关键字，则R为BCNF</p>
<p>有部分函数依赖就是1NF，没有就是2NF，没有传递函数依赖就是3NF</p>
<p>1NF-&gt;2NF<br>找到候选关键字，看其余的属性是否完全函数依赖候选关键字<br>是的，与候选关键字一同抄下来形成一个表格<br>不是的，抄下来，形成第二个表格，并且将候选关键字里能够唯一决定表格2的属性组抄在第一列</p>
<p>2NF-&gt;3NF<br>找到表格中的传递函数依赖关系的三个属性组，设为X,Y,Z<br>将这三个属性组拆成两个表格<br>第一个表格为X,Y<br>第二个表格为Y,Z</p>
<p>3NF-&gt;BCNF<br>列出表格中的所有函数依赖关系<br>每个关系拆出一个表格</p>
<h3 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h3><p>ER图是一种图形化的表示方法，用于描述数据库中的实体、实体之间的关系以及实体的属性。它是一种强大的工具，广泛应用于数据库设计和概念建模阶段，帮助开发者和分析师理解数据结构和数据之间的关系。</p>
<p>ER图的主要组成部分</p>
<ul>
<li>实体（Entity）：<ul>
<li>实体是数据库中具有相同属性集合的对象。例如，学生、课程、教师等。</li>
<li>在ER图中，实体通常用矩形表示，矩形内写上实体的名称。</li>
</ul>
</li>
<li>属性（Attribute）：<ul>
<li>属性是实体的特征或性质。例如，学生的属性可以包括学号、姓名、年龄等。</li>
<li>在ER图中，属性通常用椭圆表示，椭圆内写上属性的名称，并用线连接到对应的实体。</li>
</ul>
</li>
</ul>
<p>下图就是一个<code>ER图</code>，<code>实体</code>是<code>管理员用户</code>。<code>属性</code>有头像、密码、登录名、ID、邮箱、手机号。</p>
<p><img src="/../images/mysql/mysql3-1.png" alt="概念学习"></p>
<ul>
<li>关系（Relationship）：<ul>
<li>关系描述了实体之间的联系。例如，学生和课程之间的关系可以是选修。</li>
<li>在ER图中，关系通常用菱形表示，菱形内写上关系的名称，并用线连接到相关的实体。</li>
</ul>
</li>
<li>关系的类型：<ul>
<li>一对一关系（1:1）：一个实体与另一个实体之间存在一对一的联系。例如，一个学生对应一个学号。</li>
<li>一对多关系（1:N）：一个实体与多个实体之间存在联系。例如，一个教师可以教授多个课程。</li>
<li>多对多关系（M:N）：多个实体与多个实体之间存在联系。例如，一个学生可以选修多个课程，一个课程也可以被多个学生选修。</li>
</ul>
</li>
</ul>
<p>下图就是一个ER图，<code>实体</code>是管理员用户和角色两个。<code>关系</code>是<code>拥有</code>，表示管理员用户拥有角色的关系。关系的类型用<code>m和n</code>表示<code>多对多关系</code>。意思是一个管理员用户可以拥有多个角色，一个角色也可以被多个管理员用户拥有。</p>
<p><img src="/../images/mysql/mysql3-2.png" alt="概念学习"></p>
<p>画ER图可以使用<a href="https://www.processon.com/i/637308dd762131535d6884f7?full_name=osgpjw20iEaJn-L">processOn</a></p>
<h3 id="OLTP"><a href="#OLTP" class="headerlink" title="OLTP"></a>OLTP</h3><p>OLTP（Online Transaction Processing，联机事务处理）数据库是一种用于支持日常事务处理和业务操作的数据库系统。它旨在快速处理大量的在线事务，确保数据的完整性和一致性。OLTP数据库广泛应用于各种需要实时数据处理的场景，如银行系统、电子商务平台、企业资源规划（ERP）系统等。</p>
<p>OLTP数据库</p>
<ul>
<li>通常是业务侧使用的传统数据库，比如oracle,postgresql,mysql</li>
<li>小的业务多次执行，比如多个简单的插入，更新，查询</li>
</ul>
<h4 id="OLTP数据库的主要特点"><a href="#OLTP数据库的主要特点" class="headerlink" title="OLTP数据库的主要特点"></a>OLTP数据库的主要特点</h4><p>事务性：</p>
<ul>
<li>OLTP数据库的核心是事务处理。事务是一组操作的集合，要么全部成功，要么全部失败。OLTP系统支持ACID（原子性、一致性、隔离性、持久性）特性，确保事务的可靠性。</li>
<li>原子性（Atomicity）：事务中的所有操作要么全部成功，要么全部失败。</li>
<li>一致性（Consistency）：事务执行前后，数据库的状态保持一致。</li>
<li>隔离性（Isolation）：并发事务之间相互隔离，不会相互干扰。</li>
<li>持久性（Durability）：事务一旦提交，其结果是永久性的，即使系统故障也不会丢失。</li>
</ul>
<p>高性能：</p>
<ul>
<li>OLTP数据库设计用于快速处理大量的在线事务。它们通常具有高效的索引、优化的查询计划和低延迟的响应时间。</li>
<li>例如，银行系统需要在几毫秒内完成交易，OLTP数据库能够满足这种高性能要求。</li>
</ul>
<p>数据完整性：</p>
<ul>
<li>OLTP数据库通过各种完整性约束（如主键、外键、唯一约束、非空约束等）确保数据的准确性和一致性。</li>
<li>例如，一个订单表中的订单号必须是唯一的，客户表中的客户ID必须存在。</li>
</ul>
<p>并发处理：</p>
<ul>
<li>OLTP数据库支持高并发访问，允许多个用户同时进行事务操作。它们通过锁机制和事务隔离级别来管理并发事务，确保数据的一致性和完整性。</li>
<li>例如，多个用户可以同时在电子商务平台上下单，OLTP数据库能够处理这些并发请求。</li>
</ul>
<p>实时性：</p>
<ul>
<li>OLTP数据库提供实时数据处理，用户可以即时看到事务的结果。这使得OLTP系统适用于需要即时反馈的业务场景，如在线支付、库存管理等。</li>
<li>例如，用户在电子商务平台上下单后，系统立即更新库存信息并生成订单。</li>
</ul>
<h4 id="OLTP数据库的常见应用场景"><a href="#OLTP数据库的常见应用场景" class="headerlink" title="OLTP数据库的常见应用场景"></a>OLTP数据库的常见应用场景</h4><p>银行系统：</p>
<ul>
<li>用于处理日常的银行交易，如存款、取款、转账等。这些交易需要快速、准确地完成，确保数据的一致性和完整性。<br>电子商务平台：</li>
<li>用于处理用户的订单、支付、库存管理等。这些系统需要支持高并发访问，确保用户能够实时看到订单状态和库存信息。<br>企业资源规划（ERP）系统：</li>
<li>用于管理企业的各种资源，如人力资源、财务资源、生产资源等。这些系统需要处理大量的事务，确保数据的准确性和一致性。<br>客户关系管理（CRM）系统：</li>
<li>用于管理客户信息、销售机会、客户服务等。这些系统需要支持实时数据处理，确保客户信息的准确性和及时性。</li>
</ul>
<p>OLTP数据库是一种用于支持日常事务处理和业务操作的数据库系统。它具有事务性、高性能、数据完整性、并发处理和实时性等特点，广泛应用于银行系统、电子商务平台、企业资源规划（ERP）系统等。常见的OLTP数据库管理系统包括MySQL、PostgreSQL、Oracle Database、Microsoft SQL Server和SQLite。</p>
<h3 id="OLAP"><a href="#OLAP" class="headerlink" title="OLAP"></a>OLAP</h3><p>OLAP（Online Analytical Processing，联机分析处理）数据库是一种用于支持复杂的数据分析和报告的数据库系统。它旨在快速处理大量的数据，提供多维度的数据分析能力，帮助用户从不同角度理解数据。OLAP数据库广泛应用于数据仓库、商业智能（BI）和决策支持系统。</p>
<p>OLAP数据库</p>
<ul>
<li>通常是大数据，数据分析来使用，比如Hbase等，支持复杂的数据查询</li>
<li>OLAP位于OLTP的后方</li>
</ul>
<h4 id="OLAP数据库的主要特点"><a href="#OLAP数据库的主要特点" class="headerlink" title="OLAP数据库的主要特点"></a>OLAP数据库的主要特点</h4><p>多维数据分析：</p>
<ul>
<li>OLAP数据库支持多维数据分析，允许用户从不同角度（如时间、地区、产品等）查看数据。这种多维视图有助于用户发现数据中的模式和趋势。</li>
<li>例如，用户可以按季度、地区和产品类别分析销售数据。</li>
</ul>
<p>高性能查询：</p>
<ul>
<li>OLAP数据库优化了对大量数据的读取操作，能够快速响应复杂的查询请求。它们通常使用预计算的聚合数据和索引技术来提高查询性能。</li>
<li>例如，数据仓库中的销售数据可以按季度、地区和产品类别预计算，以便快速生成报告。</li>
</ul>
<p>数据聚合：</p>
<ul>
<li>OLAP数据库支持数据的聚合操作，如求和、平均、最大值、最小值等。这些聚合操作通常在数据加载时预先计算，以便快速生成报告。</li>
<li>例如，销售数据可以按季度、地区和产品类别进行汇总，以便快速生成销售报告。</li>
</ul>
<p>数据立方体（Data Cube）：</p>
<ul>
<li>OLAP数据库使用数据立方体（Data Cube）来组织数据。数据立方体是一个多维数据结构，允许用户从不同维度查看数据。</li>
<li>例如，一个销售数据立方体可以包含时间维度（年、季度、月）、地区维度（国家、城市）和产品维度（类别、品牌）。</li>
</ul>
<p>数据更新：</p>
<ul>
<li>OLAP数据库通常不需要实时更新，数据通常在定期的时间间隔内批量加载。这使得OLAP数据库能够优化读取操作，提高查询性能。</li>
<li>例如，销售数据可以在每天晚上批量加载到数据仓库中。</li>
</ul>
<h4 id="OLAP数据库的常见应用场景"><a href="#OLAP数据库的常见应用场景" class="headerlink" title="OLAP数据库的常见应用场景"></a>OLAP数据库的常见应用场景</h4><p>数据仓库：</p>
<ul>
<li>用于存储和管理企业的历史数据，支持复杂的查询和报告。数据仓库通常从多个数据源（如事务处理系统）提取数据，进行清洗和转换，然后加载到数据仓库中。</li>
<li>例如，企业可以使用数据仓库来分析销售趋势、客户行为等。</li>
</ul>
<p>商业智能（BI）：</p>
<ul>
<li>用于支持企业的决策支持系统，提供数据驱动的决策支持。商业智能工具通常与OLAP数据库集成，提供交互式的报告和分析功能。</li>
<li>例如，企业可以使用商业智能工具生成销售报告、市场分析报告等。</li>
</ul>
<p>决策支持系统（DSS）：</p>
<ul>
<li>用于支持企业的决策过程，提供数据驱动的决策支持。决策支持系统通常使用OLAP数据库来存储和分析数据。</li>
<li>例如，企业可以使用决策支持系统来优化生产计划、资源分配等。</li>
</ul>
<p>OLAP数据库是一种用于支持复杂的数据分析和报告的数据库系统。它具有多维数据分析、高性能查询、数据聚合、数据立方体和数据更新等特点，广泛应用于数据仓库、商业智能（BI）和决策支持系统。常见的OLAP数据库管理系统包括HBase,ClickHouse等。</p>
<h3 id="高级概念"><a href="#高级概念" class="headerlink" title="高级概念"></a>高级概念</h3><p>接下来在介绍一下MySQL中会用到的高级概念，这些能更好的帮助大家理解除了正常的表以外的其他东西。</p>
<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>在MySQL中，<strong>视图（View）</strong>是一种虚拟表，其内容由SQL查询定义。视图并不存储实际的数据，而是根据定义的查询动态生成数据。视图可以简化复杂的SQL操作，提供数据的逻辑抽象，并且可以限制对某些数据的访问，从而增强数据的安全性。</p>
<p>MySQL中的视图是虚拟视图，说白了就是一条SQL语句，当查询视图的时候执行SQL语句而已。</p>
<p>除此之外，还有一个东西叫做<code>物化视图</code>，MySQL并没有实现这个东西，物化视图就是一张真的表，而不是一个SQL语句，因此查询效率更好。</p>
<h5 id="视图的主要特点"><a href="#视图的主要特点" class="headerlink" title="视图的主要特点"></a>视图的主要特点</h5><p>虚拟表：</p>
<ul>
<li>视图是一个虚拟表，其内容由SQL查询定义。视图本身并不存储数据，而是根据定义的查询动态生成数据。</li>
</ul>
<p>简化复杂查询：</p>
<ul>
<li>视图可以简化复杂的SQL操作，将复杂的查询逻辑封装起来，使用户可以像查询普通表一样查询视图。</li>
</ul>
<p>数据抽象：</p>
<ul>
<li>视图提供数据的逻辑抽象，隐藏了底层表的复杂性，使用户可以更直观地访问数据。</li>
</ul>
<p>安全性：</p>
<ul>
<li>视图可以限制对某些数据的访问，增强数据的安全性。通过视图，用户只能访问视图定义的特定数据，而不能访问底层表的全部数据。</li>
</ul>
<p>更新限制：</p>
<ul>
<li>视图可以是可更新的，也可以是不可更新的。可更新视图允许用户通过视图插入、更新或删除数据，但需要满足一定的条件。不可更新视图则不允许用户通过视图修改数据。</li>
</ul>
<p>创建一个视图。下面的语句，创建一个视图，视图名称是<code>sales_employees</code>，内容就是后面的Select语句的结果。当原始表<code>employees</code>变化以后，视图的内容也会跟着变化。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> sales_employees <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;Sales&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><p>在MySQL中，<strong>触发器（Trigger）</strong>是一种特殊的存储过程，它在特定的数据库操作（如INSERT、UPDATE、DELETE）发生时自动执行。触发器可以用于实现复杂的业务逻辑，确保数据的完整性和一致性，以及自动维护数据的同步。</p>
<h5 id="触发器的主要特点"><a href="#触发器的主要特点" class="headerlink" title="触发器的主要特点"></a>触发器的主要特点</h5><p>自动执行：</p>
<ul>
<li>触发器在特定的数据库操作发生时自动执行，无需显式调用。这使得触发器可以用于实现自动化的数据处理和维护。</li>
</ul>
<p>数据完整性：</p>
<ul>
<li>触发器可以用于确保数据的完整性和一致性。例如，可以在插入或更新数据时自动检查数据的有效性，或者在删除数据时自动清理相关数据。</li>
</ul>
<p>业务逻辑：</p>
<ul>
<li>触发器可以用于实现复杂的业务逻辑。例如，可以在插入或更新数据时自动计算某些字段的值，或者在删除数据时自动更新相关表的数据。</li>
</ul>
<p>数据同步：</p>
<ul>
<li>触发器可以用于自动维护数据的同步。例如，可以在插入或更新数据时自动更新相关表的数据，或者在删除数据时自动清理相关表的数据。</li>
</ul>
<h5 id="触发器的类型"><a href="#触发器的类型" class="headerlink" title="触发器的类型"></a>触发器的类型</h5><ul>
<li>BEFORE INSERT：<ul>
<li>在插入数据之前执行触发器逻辑。</li>
</ul>
</li>
<li>AFTER INSERT：<ul>
<li>在插入数据之后执行触发器逻辑。</li>
</ul>
</li>
<li>BEFORE UPDATE：<ul>
<li>在更新数据之前执行触发器逻辑。</li>
</ul>
</li>
<li>AFTER UPDATE：<ul>
<li>在更新数据之后执行触发器逻辑。</li>
</ul>
</li>
<li>BEFORE DELETE：<ul>
<li>在删除数据之前执行触发器逻辑。</li>
</ul>
</li>
<li>AFTER DELETE：<ul>
<li>在删除数据之后执行触发器逻辑。</li>
</ul>
</li>
</ul>
<h5 id="触发器的限制"><a href="#触发器的限制" class="headerlink" title="触发器的限制"></a>触发器的限制</h5><p>性能影响：</p>
<ul>
<li>触发器的执行会增加数据库操作的开销，可能会影响性能。因此，应谨慎使用触发器，避免在高频操作的表上定义过多的触发器。<br>复杂性：</li>
<li>触发器的逻辑可以非常复杂，但过多的复杂逻辑可能导致触发器难以维护和调试。因此，应尽量保持触发器的逻辑简单明了。<br>调试困难：</li>
<li>触发器的调试相对困难，因为它们在特定的操作发生时自动执行，难以直接观察和调试。因此，建议在开发和测试阶段充分测试触发器的逻辑。</li>
</ul>
<p>因此，实际开发中基本不使用触发器。</p>
<h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><p>在MySQL中，<strong>存储过程（Stored Procedure）</strong>是一种预编译的SQL语句集合，它存储在数据库中，可以通过调用其名称并传递参数来执行。存储过程可以包含复杂的逻辑和多个SQL语句，用于完成特定的任务。它们类似于其他编程语言中的函数或方法。</p>
<p>可以把存储过程想成一个函数。只不过是在MySQL中的函数，这个函数可以实现各种功能。可以实现一些复杂的SQL处理，这样可以简化调用。</p>
<h5 id="存储过程的主要特点"><a href="#存储过程的主要特点" class="headerlink" title="存储过程的主要特点"></a>存储过程的主要特点</h5><p>预编译：</p>
<ul>
<li>存储过程在创建时被预编译并存储在数据库中，这使得它们的执行速度比单独的SQL语句更快。<br>代码重用：</li>
<li>存储过程可以被多次调用，减少了代码重复，提高了开发效率。<br>减少网络流量：</li>
<li>存储过程在服务器端执行，减少了客户端和服务器之间的网络流量，因为只需要发送存储过程的名称和参数，而不是大量的SQL语句。<br>安全性：</li>
<li>存储过程可以限制用户对底层数据的直接访问，只允许通过存储过程进行数据操作，从而增强数据的安全性。<br>事务管理：</li>
<li>存储过程可以包含事务控制语句，如COMMIT和ROLLBACK，确保数据操作的完整性和一致性。</li>
</ul>
<p>创建一个存储过程get_employee_details，用于根据员工ID获取员工的详细信息：</p>
<p>DELIMITER用来设置结束符，比如正常的句子结束符是句号。代码结束符是分号；</p>
<p>IN代表输入参数，也就是这个函数有一个输入参数emp_id，是int类型。<br>还有out代表输出参数，用于返回结果。<br>INOUT代表既可以输入参数也可以是输出参数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> get_employee_details(<span class="keyword">IN</span> emp_id <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> name, department, salary</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> id <span class="operator">=</span> emp_id;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>上面这个存储过程的函数体，就是一段select查询语句。</p>
<h5 id="存储过程的限制"><a href="#存储过程的限制" class="headerlink" title="存储过程的限制"></a>存储过程的限制</h5><p>性能影响：</p>
<ul>
<li>存储过程的执行会增加数据库操作的开销，可能会影响性能。因此，应谨慎使用存储过程，避免在高频操作的表上定义过多的存储过程。<br>复杂性：</li>
<li>存储过程的逻辑可以非常复杂，但过多的复杂逻辑可能导致存储过程难以维护和调试。因此，应尽量保持存储过程的逻辑简单明了。<br>调试困难：</li>
<li>存储过程的调试相对困难，因为它们在服务器端执行，难以直接观察和调试。因此，建议在开发和测试阶段充分测试存储过程的逻辑。</li>
</ul>
<h4 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h4><p>在MySQL中，<strong>存储函数（Stored Function）</strong>是一种预编译的SQL语句集合，类似于存储过程，但它返回一个值。存储函数可以被SQL语句直接调用，就像调用普通的函数一样。存储函数通常用于封装复杂的逻辑，并在查询中重用这些逻辑。</p>
<p>存储函数同样是一个函数，和上面的存储过程差不多。</p>
<h5 id="存储过程和存储函数的区别"><a href="#存储过程和存储函数的区别" class="headerlink" title="存储过程和存储函数的区别"></a>存储过程和存储函数的区别</h5><p>返回值的区别</p>
<ul>
<li>存储过程<ul>
<li>存储过程可以返回多个值，这些值通过OUT或INOUT参数返回。</li>
<li>存储过程可以执行多个SQL语句，但不直接返回一个单一的值。</li>
</ul>
</li>
<li>存储函数<ul>
<li>存储函数必须返回一个单一的值。</li>
<li>存储函数可以被SQL语句直接调用，就像调用普通的函数一样。</li>
</ul>
</li>
</ul>
<p>调用方式的区别</p>
<ul>
<li>存储过程<ul>
<li>存储过程通过CALL语句调用。</li>
<li>存储过程可以执行复杂的逻辑，包括多个SQL语句和事务控制。</li>
</ul>
</li>
<li>存储函数<ul>
<li>存储函数可以直接在SQL语句中调用，就像调用普通的函数一样。</li>
<li>存储函数通常用于封装复杂的逻辑，并在查询中重用这些逻辑。</li>
</ul>
</li>
</ul>
<h5 id="存储函数的主要特点"><a href="#存储函数的主要特点" class="headerlink" title="存储函数的主要特点"></a>存储函数的主要特点</h5><p>返回值：</p>
<ul>
<li>存储函数必须返回一个值，这使得它们可以被SQL语句直接调用。<br>代码重用：</li>
<li>存储函数可以被多次调用，减少了代码重复，提高了开发效率。<br>减少网络流量：</li>
<li>存储函数在服务器端执行，减少了客户端和服务器之间的网络流量，因为只需要发送函数的名称和参数，而不是大量的SQL语句。<br>安全性：</li>
<li>存储函数可以限制用户对底层数据的直接访问，只允许通过函数进行数据操作，从而增强数据的安全性。<br>事务管理：</li>
<li>存储函数可以包含事务控制语句，如COMMIT和ROLLBACK，确保数据操作的完整性和一致性。</li>
</ul>
<p>创建一个存储函数get_employee_salary，用于根据员工ID获取员工的薪资：</p>
<p>可以看到和上面存储过程的区别，声明了一个返回值，类型是DECIMAL,最后通过return返回了，并且声明了一个变量。参数也没有IN、OUT这种了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> get_employee_salary(emp_id <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> emp_salary <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> emp_salary</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> id <span class="operator">=</span> emp_id;</span><br><span class="line">    <span class="keyword">RETURN</span> emp_salary;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h4 id="window窗口函数"><a href="#window窗口函数" class="headerlink" title="window窗口函数"></a>window窗口函数</h4><p>窗口函数（Window Function）是SQL标准中的一种功能强大的工具，它允许在查询中对一组行进行计算，而不会像聚合函数那样消除行的个数。窗口函数在MySQL 8.0及更高版本中得到了支持，它们可以用于计算移动平均值、累积和、排名等复杂的分析任务。</p>
<h5 id="窗口函数的主要特点"><a href="#窗口函数的主要特点" class="headerlink" title="窗口函数的主要特点"></a>窗口函数的主要特点</h5><p>行级计算：</p>
<ul>
<li>窗口函数在每一行上执行计算，同时可以访问同一组中的其他行。</li>
<li>这与聚合函数不同，聚合函数会将多行数据合并为一行。<br>分区和排序：</li>
<li>窗口函数可以使用PARTITION BY子句将数据分成多个分区，每个分区独立计算。</li>
<li>可以使用ORDER BY子句在每个分区内对数据进行排序。<br>灵活的范围定义：</li>
<li>窗口函数可以定义计算的范围，如当前行的前几行或后几行。</li>
<li>使用ROWS或RANGE子句可以指定计算的范围。<br>多种功能：</li>
<li>窗口函数提供了多种功能，如ROW_NUMBER()、RANK()、DENSE_RANK()、NTILE()、SUM()、AVG()、LEAD()、LAG()等。</li>
</ul>
<p><code>ROW_NUMBER</code>和<code>RANK</code>都需要和<code>OVER</code>一起使用。</p>
<ul>
<li>ROW_NUMBER(): 显示当前行号</li>
<li>RANK() : 显示排序后的排名，如果没有排序，都是1</li>
<li>OVER()<ul>
<li>PARTITION BY 进行分组</li>
<li>GROUP BY 进行分组</li>
<li>ORDER BY 排序</li>
</ul>
</li>
</ul>
<p><img src="/../images/15445001.png" alt="001"></p>
<p><img src="/../images/15445002.png" alt="002"></p>
<p><img src="/../images/15445003.png" alt="003"></p>
<h4 id="获取每个课程中分数最高的学生信息"><a href="#获取每个课程中分数最高的学生信息" class="headerlink" title="获取每个课程中分数最高的学生信息"></a>获取每个课程中分数最高的学生信息</h4><p>下面的SQL，在postgresql中执行成功，mysql8执行报错。</p>
<p>首先查询所有课程信息，并按照课程分组，按照分数排序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line"><span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cid <span class="keyword">ORDER</span> <span class="keyword">BY</span> grade <span class="keyword">ASC</span>)</span><br><span class="line"><span class="keyword">AS</span> rank <span class="keyword">FROM</span> enrolled</span><br></pre></td></tr></table></figure>

<p><img src="/../images/15445004.png" alt="004"></p>
<p>接着搜索上表中分数为1，也就是分数最高的学生。也就是每个课分数最高的学生信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line">    <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cid</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> grade <span class="keyword">ASC</span>)</span><br><span class="line">    <span class="keyword">AS</span> rank <span class="keyword">FROM</span> enrolled) <span class="keyword">AS</span> ranking</span><br><span class="line"><span class="keyword">WHERE</span> ranking.rank <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="/../images/15445005.png" alt="005"></p>
<h4 id="CTE-common-table-expressions"><a href="#CTE-common-table-expressions" class="headerlink" title="CTE(common table expressions)"></a>CTE(common table expressions)</h4><p>在MySQL中，<strong>CTE（Common Table Expressions，公共表表达式）</strong>是一种临时的结果集，可以在查询中被引用。CTE通常用于简化复杂的查询，使查询更易于理解和维护。CTE在MySQL 8.0及更高版本中得到了支持。</p>
<h5 id="CTE的主要特点"><a href="#CTE的主要特点" class="headerlink" title="CTE的主要特点"></a>CTE的主要特点</h5><p>临时结果集：</p>
<ul>
<li>CTE是一个临时的结果集，可以在查询中被引用。它类似于子查询，但更易于阅读和维护。<br>简化复杂查询：</li>
<li>CTE可以将复杂的查询分解为多个简单的部分，使查询更易于理解和维护。<br>可重用性：</li>
<li>CTE可以被多次引用，减少了代码重复，提高了开发效率。<br>递归查询：</li>
<li>CTE支持递归查询，可以用于处理层次结构或递归数据。</li>
</ul>
<p>使用<code>CTE</code>实现获取每个课程中分数最高的学生信息。</p>
<p>通过<code>WITH</code>语句来声明一个临时表。表名<code>cteSource</code>，表的内容就是最的sid，通过<code>SELECT MAX(sid) FROM enrolled</code>查询出来的结果。字段名叫<code>maxId</code>。</p>
<p>然后在查询语句里面就可以连接<code>cteSource</code>表，然后通过sid &#x3D; cteSource.maxId 来获取到sid最大的用户信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> cteSource (maxId) <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(sid) <span class="keyword">FROM</span> enrolled</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> student, cteSource</span><br><span class="line"><span class="keyword">WHERE</span> student.sid <span class="operator">=</span> cteSource.maxId</span><br></pre></td></tr></table></figure>

<p>还有一些其他的用法，比如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> cte1 (col1) <span class="keyword">AS</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span></span><br><span class="line">),</span><br><span class="line">cte2 (col2) <span class="keyword">AS</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> cte1, cte2;</span><br></pre></td></tr></table></figure>

<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>介绍了上面的概念，我们现在明白了MySQL数据库是什么了吧。</p>
<p>MySQL数据库是</p>
<ul>
<li>OLTP数据库</li>
<li>基于关系模型的关系数据库管理系统</li>
<li>实现了SQL标准，可以使用SQL进行控制，并扩展了自己的东西。</li>
<li>可以使用ER图来设计关系模型</li>
<li>具有一些高级特性</li>
</ul>
<h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>以上就是整体的MySQL学习路线了。</p>
<p>关注我发送“MySQL知识图谱”领取完整的MySQL学习路线。</p>
<p>发送“电子书”即可领取价值上千的电子书资源。</p>
<p>部分电子书如图所示。</p>
<p><img src="/../images/bottom1.png" alt="概念学习"></p>
<p><img src="/../images/bottom2.png" alt="概念学习"></p>
<p><img src="/../images/bottom3.png" alt="概念学习"></p>
<p><img src="/../images/bottom4.png" alt="概念学习"></p>
]]></content>
      <categories>
        <category>CMU15445</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA中的函数式编程</title>
    <url>/JAVA%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html</url>
    <content><![CDATA[<h1 id="JAVA中的函数式编程"><a href="#JAVA中的函数式编程" class="headerlink" title="JAVA中的函数式编程"></a>JAVA中的函数式编程</h1>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>lambda</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-optional并非银弹</title>
    <url>/JAVA-optional%E5%B9%B6%E9%9D%9E%E9%93%B6%E5%BC%B9.html</url>
    <content><![CDATA[<h1 id="optional并非银弹"><a href="#optional并非银弹" class="headerlink" title="optional并非银弹"></a>optional并非银弹</h1><p>首先，我们都知道，<code>optional</code>类型要更加安全，如果使用的好，不会出现空指针异常，因为它不会返回null。</p>
<p>但是注意，这里的前提是<code>使用的好</code>。</p>
<p>比如 下面这两段代码。这里的 optionalInt.get().toString() 并不会比 num.toString() 安全，如果optionInt.get()返回的是一个null，还是会触发空指针异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Integer&gt; optionalInt = Optional.of(<span class="number">12</span>);</span><br><span class="line">optionalInt.get().toString();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">num.toString();</span><br></pre></td></tr></table></figure>

<p>所以，optional并不是处理空指针的银弹，而是需要正确的使用它。</p>
<h3 id="如果正确的使用optional"><a href="#如果正确的使用optional" class="headerlink" title="如果正确的使用optional"></a>如果正确的使用optional</h3><p><code>isPresent</code>和<code>ifPresent</code>这两个方法。</p>
<ul>
<li>isPresent 是一个判断，类似于 num !&#x3D; null</li>
<li>ifPresent 接受一个 lambda 表达式或者方法，如果存在的话就调用该方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Integer&gt; optionalInt = Optional.of(<span class="number">12</span>);</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">optionalInt.ifPresent(i -&gt; &#123;</span><br><span class="line">    num = i;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (optionalInt.isPresent()) &#123;</span><br><span class="line">    num = optionalInt.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里更推荐的是使用 ifPresent 方法，更加安全方便。</p>
<p>为什么呢？因为你只是为了判断这么一下的话，完全可以使用 <code>num != null</code> 来代替 <code>optionalInt.isPresent</code>。毕竟这样还省去了包装optional的步骤，效果则是一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (optionalInt.isPresent()) &#123;</span><br><span class="line">    num = optionalInt.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">    num = a * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是 <code>ifPresent</code> 方法只负责处理，并不返回任何值。</p>
<p>如果你想要返回值的话，可以使用<code>map</code>方法代替。他返回一个bool值，被封装到optional中的true或者false(根据optionalInt是否存在)，也可能是个空值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Boolean&gt; res = optionalInt.map(i -&gt; &#123;</span><br><span class="line">    num = i;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>那么在日常使用中，还会有默认值的情况，比如，如果int值存在我就赋值给num，不存在我就赋值0。这个时候就可以使用下面这三个方法</p>
<ul>
<li>orElse        如果有值，返回值，如果没有值，返回你给的默认值。</li>
<li>orElseGet     和上面的效果一样，只是可以传一个lambda表达式</li>
<li>orElseThrow   和上面的效果一样，没有值的时候返回一个异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Integer&gt; optionalInt = Optional.of(<span class="number">12</span>);</span><br><span class="line">num = optionalInt.orElse(<span class="number">0</span>); <span class="comment">//这里有值，所以返回12</span></span><br><span class="line"></span><br><span class="line">Optional&lt;Integer&gt; optionalInt = Optional.empty();</span><br><span class="line">num = optionalInt.orElse(<span class="number">0</span>); <span class="comment">//这里没有值，所以返回默认值0</span></span><br><span class="line"></span><br><span class="line">Optional&lt;Integer&gt; optionalInt = Optional.empty();</span><br><span class="line"><span class="comment">// 传一个默认值方法</span></span><br><span class="line">num = optionalInt.orElseGet(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Optional&lt;Integer&gt; optionalInt = Optional.empty();</span><br><span class="line"><span class="comment">// 如果没有值，返回一个异常</span></span><br><span class="line"><span class="keyword">return</span> optionalInt.orElseThrow(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;异常了&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>通过<code>faltMap</code>方法实现optional链式操作。首先通过of方法创建一个<code>Optional&lt;Integer&gt;</code>类型的12。然后通过flatMap方法把这个Integer的12传递给doubleInt方法。doubleInt方法处理完以后返回一个<code>Optional&lt;Integer&gt;</code>类型的24。</p>
<p>因为返回的还是一个<code>Optional</code>。所以还可以继续调用flatMap方法。将24传给intToStr方法。将24转换成String类型。然后返回一个<code>Optional&lt;String&gt;</code>类型的24.</p>
<p><code>ofNullable</code>方法的作用是如果你给的值存在就调用<code>of</code>方法创建一个<code>Optional</code>。如果不存在就调用<code>empty</code>方法创建一个空的<code>Optional</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">optionalMap</span><span class="params">()</span> &#123;</span><br><span class="line">    Optional&lt;String&gt; res = Optional.of(<span class="number">12</span>).flatMap(<span class="built_in">this</span>::doubleInt).flatMap(<span class="built_in">this</span>::intToStr);</span><br><span class="line">    <span class="keyword">return</span> res.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一个数转换成string</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title function_">intToStr</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(String.valueOf(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一个数 * 2</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;Integer&gt; <span class="title function_">doubleInt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(x &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>optional</tag>
      </tags>
  </entry>
  <entry>
    <title>转语言者速学java</title>
    <url>/JAVA-%E8%BD%AC%E8%AF%AD%E8%A8%80%E8%80%85%E9%80%9F%E5%AD%A6.html</url>
    <content><![CDATA[<h1 id="转语言者速学java"><a href="#转语言者速学java" class="headerlink" title="转语言者速学java"></a>转语言者速学java</h1><h3 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a>接口的默认方法</h3><p>java的接口里面可以写方法体，这样的话，所有实现了该接口的，都自动具有了该方法而不用实现方法内容。当然了，也可以重写方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IGuideService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> Integer <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuideService</span> <span class="keyword">implements</span> <span class="title class_">IGuideService</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span> &#123;</span><br><span class="line">        <span class="type">IGuideService</span> <span class="variable">guideService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuideService</span>;</span><br><span class="line">        System.out.println(guideService.getNum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>但是java可以实现多个接口，所以就可能会有<code>二义性</code>的问题，C++解决问题的方法是<code>虚基类</code>，java则是简单粗暴的。</p>
<ul>
<li>如果是父类中和接口中的方法冲突了。那么选择父类中的方法。</li>
<li>如果是多个接口中的方法冲突了，那么你必须通过覆盖该方法来手动解决冲突。</li>
</ul>
<p>看一下如果父类中也有<code>getNum</code>方法。创建一个父类返回2.再次执行以后会发现返回2了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseGuideService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuideService</span> <span class="keyword">extends</span> <span class="title class_">BaseGuideService</span> <span class="keyword">implements</span> <span class="title class_">IGuideService</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来不用父类，然后创建两个接口试试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IGuideNewService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> Integer <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现两个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuideService</span> <span class="keyword">implements</span> <span class="title class_">IGuideService</span>,IGuideNewService &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候编译就会报错了。</p>
<blockquote>
<p>GuideService 从 IGuideService 和 IGuideNewService 中继承了getNum() 的不相关默认值</p>
</blockquote>
<p>那如果这两个接口是父子接口呢？这个时候就不会报错了，因为相当于子接口重写了这个方法。所以只存在一个<code>getNum</code>方法了。</p>
<p>我们来看如果是单独的两个接口，那么需要我们手动来解决冲突。重写一下这个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现两个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuideService</span> <span class="keyword">implements</span> <span class="title class_">IGuideService</span>, IGuideNewService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在重写的时候也可以选择使用两个接口的某一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现两个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuideService</span> <span class="keyword">implements</span> <span class="title class_">IGuideService</span>, IGuideNewService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> IGuideService.<span class="built_in">super</span>.getNum();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//或者使用另一个</span></span><br><span class="line">        <span class="comment">//return IGuideNewService.super.getNum();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="日期时间"><a href="#日期时间" class="headerlink" title="日期时间"></a>日期时间</h3><p>在java中的时间，有几个概念</p>
<ul>
<li>某一个具体的时间点：Instant</li>
<li>持续时间，两个时间点之间的时间：Duration</li>
<li>本地时间，没有时区信息的：LocalDate,LocalTime,LocalDateTime</li>
<li>带时区的时间：ZonedDateTime</li>
<li>处理时区信息时，时间段使用 Period 而不是 Duration</li>
<li>时间格式化处理： DateTimeFormatter</li>
<li>日历计算，比如查找月份的第一天，第二天，第一周，第二周的星期二：TemporalAdjuster</li>
</ul>
<p>获取当前的一个时间点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Instant.now();</span><br></pre></td></tr></table></figure>

<p>获取一段时间，可以用来求运行速度。start是处理开始的时间点。end是处理完成的时间点。再通过Duration来求出一段时间.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">start</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"><span class="comment">//处理逻辑</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">end</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"></span><br><span class="line"><span class="type">Duration</span> <span class="variable">time</span> <span class="operator">=</span> Duration.between(start,end);</span><br><span class="line"><span class="type">long</span> <span class="variable">mills</span> <span class="operator">=</span> time.toMills();</span><br></pre></td></tr></table></figure>

<p>获取本地当前时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now();</span><br></pre></td></tr></table></figure>

<p>时间格式化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">time.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>获取带时区的当前时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">time</span> <span class="operator">=</span> ZonedDateTime.now();</span><br></pre></td></tr></table></figure>

<p>想看更多时间处理的，可以参考 <a href="https://thepatterraining.github.io/JAVA-spring%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93.html#valine-comments">LocalDateTime源码解析</a></p>
<h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h3><p>stream可以帮我们处理很多东西。比如</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">map</td>
<td align="left">循环。可以简单理解为foreach</td>
</tr>
<tr>
<td align="left">flatMap</td>
<td align="left">将二维数据展开成一维</td>
</tr>
<tr>
<td align="left">filter</td>
<td align="left">过滤数据</td>
</tr>
<tr>
<td align="left">distinct</td>
<td align="left">去重</td>
</tr>
<tr>
<td align="left">sorted</td>
<td align="left">排序</td>
</tr>
<tr>
<td align="left">limit</td>
<td align="left">限制只取n个元素</td>
</tr>
<tr>
<td align="left">skip</td>
<td align="left">跳过n个元素</td>
</tr>
</tbody></table>
<p>除了这些还可以实现比如把list转换成逗号分隔的字符串。把list经过处理以后转换成set或者map。</p>
<p>还可以变成指定值为key,指定值为value的map。比如id为key，name为值或者map为值的map。</p>
<p>具体的可以参考下面三个文章。</p>
<ul>
<li><a href="">stream数据结构和原理</a></li>
<li><a href="">stream的map,filter,sorted等使用和源码</a></li>
<li><a href="">stream的collect,foreach等使用和源码</a></li>
</ul>
<h3 id="optional"><a href="#optional" class="headerlink" title="optional"></a>optional</h3><p>java中的optional可以帮助你避免<code>空指针异常</code>.</p>
<p>具体的可以参考<a href="https://thepatterraining.github.io/JAVA-optional%E5%B9%B6%E9%9D%9E%E9%93%B6%E5%BC%B9.html">optional并非银弹</a></p>
<h3 id="函数式编程和lambda"><a href="#函数式编程和lambda" class="headerlink" title="函数式编程和lambda"></a>函数式编程和lambda</h3><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul>
<li>@Autowired  Spring提供的，基于类型注入的，可以放在setter方法上，变量上，构造函数上</li>
<li>@Inject     同@Autowired</li>
<li>@Qualifier  Spring提供的，基于名称注入的，一般和@Autowired配合使用来通过value参数指定名称</li>
<li>@Name       同@Qualifier，给@Inject配合使用</li>
<li>@Primary</li>
<li>@Resource   Java提供的，可以基于类型或名称注入的,可以通过name参数来指定名称，可以放在setter方法上</li>
<li>@RequiredArgsConstructor  lombok提供的，基于类型注入，通过增加一个构造函数来注入。</li>
<li>@Value      Spring提供的，注入基本类型的注解，一般用来从配置文件取值。</li>
<li>@Component 单纯的说我是一个<code>bean</code></li>
<li>@Service 和上面的一样，不过一般用在service类中，更加语义化</li>
<li>@Controller 和上面的一样，一般用在controller类中</li>
<li>@Repository 我也是一个<code>bean</code>，一般用在dao数据访问层</li>
<li>@Bean 我也是一个bean，导入第三方包里面的注解</li>
<li>@Import 导入组件</li>
<li>@ImportSelector 返回需要导入的组件的全类名数组</li>
<li>@ImportBeanDefinitionRegistrar 手动注册Bean到容器</li>
<li>@JsonIgnore  json的时候忽略属性</li>
<li>@Bean(initMethod&#x3D;”init”,destoryMethod&#x3D;”destory”) 设置初始化和销毁方法</li>
<li>@PostConstruct：初始化方法</li>
<li>@PreDestory：销毁方法</li>
<li>BeanPostProcessor：bean的后置处理器，在bean初始化前后进行一些处理工作</li>
<li>@Configuration 声明为配置类</li>
<li>@ComponentScan 扫描Component</li>
<li>@Aspect 声明一个切面</li>
<li>@After 在方法执行之后执行（方法上）</li>
<li>@Before 在方法执行之前执行（方法上）</li>
<li>@Around 在方法执行之前与之后执行（方法上）</li>
<li>@PointCut 声明切点</li>
<li>@EnableAspectJAutoProxy 启Spring对AspectJ代理的支持</li>
<li>@Profile 指定组件在哪个环境的情况下才能被注册到容器中，不指定，任何环境下都能注册这个组件。</li>
<li>@Conditional 通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。</li>
<li>@EnableAsync 配置类中通过此注解开启对异步任务的支持</li>
<li>@Async  在实际执行的bean方法使用该注解来声明其是一个异步任务</li>
<li>@EnableScheduling  在配置类上使用，开启计划任务的支持</li>
<li>@Scheduled  来申明这是一个任务，包括cron,fixDelay,fixRate等类型</li>
<li>@EnableConfigurationProperties：开启对@ConfigurationProperties注解配置Bean的支持；</li>
<li>@EnableJpaRepositories：开启对SpringData JPA Repository的支持；</li>
<li>@EnableTransactionManagement：开启注解式事务的支持；</li>
<li>@EnableCaching：开启注解式的缓存支持；</li>
<li>@EnableAspectAutoProxy：开启对AspectJ自动代理的支持；</li>
<li>@EnableWebMvc   在配置类中开启Web MVC的配置支持。</li>
<li>@RequestMapping   用于映射web请求，包括访问路径和参数。</li>
<li>@ResponseBody    支持将返回值放到response内，而不是一个页面，通常用户返回json数据。</li>
<li>@RequestBody           允许request的参数在request体中，而不是在直接连接的地址后面。</li>
<li>@PathVariable         用于接收路径参数，比如@RequestMapping(“&#x2F;hello&#x2F;{name}”)声明的路径，将注解放在参数前，即可获取该值，通常作为Restful的接口实现方法。</li>
<li>@RestController       该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。</li>
<li>@ControllerAdvice     全局异常处理 全局数据绑定 全局数据预处理</li>
<li>@ExceptionHandler     用于全局处理控制器里的异常。</li>
<li>@InitBinder           用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。</li>
<li>@ModelAttribute       </li>
<li>@Transactional <ul>
<li>name 当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。</li>
<li>propagation 事务的传播行为，默认值为 REQUIRED。<ul>
<li>REQUIRED  如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。( 也就是说如果A方法和B方法都添加了注解，在默认传播模式下，A方法内部调用B方法，会把两个方法的事务合并为一个事务 ）</li>
<li>SUPPORTS  如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。</li>
<li>MANDATORY 如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</li>
<li>REQUIRES_NEW  重新创建一个新的事务，如果当前存在事务，暂停当前的事务。</li>
<li>NOT_SUPPORTED 以非事务的方式运行，如果当前存在事务，暂停当前的事务。</li>
<li>NEVER         以非事务的方式运行，如果当前存在事务，则抛出异常。</li>
<li>NESTED        和 REQUIRED 效果一样。</li>
</ul>
</li>
<li>isolation 事务的隔离度，默认值采用 DEFAULT</li>
<li>timeout   事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</li>
<li>read-only 指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</li>
<li>rollback-for  用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。</li>
<li>no-rollback- for  抛出 no-rollback-for 指定的异常类型，不回滚事务。</li>
</ul>
</li>
<li>@Schema   表示此类对应的数据库表对应的schema。</li>
<li>@JsonFormat   可以方便的把Date类型直接转化为我们想要的模式</li>
<li>@Transient    如果一个属性并非数据库表的字段映射，就务必将其标示为@Transient</li>
<li>@JsonProperty 可以指定某个属性和json映射的名称</li>
<li>@Scope设置类型包括：</li>
</ul>
<p>设置Spring容器如何新建Bean实例（方法上，得有@Bean）</p>
<p>① Singleton</p>
<p>（单例,一个Spring容器中只有一个bean实例，默认模式）,</p>
<p>② Protetype</p>
<p>（每次调用新建一个bean）,</p>
<p>③ Request</p>
<p>（web项目中，给每个http request新建一个bean）,</p>
<p>④ Session</p>
<p>（web项目中，给每个http session新建一个bean）,</p>
<p>⑤ GlobalSession</p>
<p>（给每一个 global http session新建一个Bean实例）</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-stream中间态原理</title>
    <url>/JAVA-stream%E4%B8%AD%E9%97%B4%E6%80%81%E5%8E%9F%E7%90%86.html</url>
    <content><![CDATA[<h1 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h1><h3 id="stream的中间态"><a href="#stream的中间态" class="headerlink" title="stream的中间态"></a>stream的中间态</h3><p>中间态的主要作用是构建双向链表的中间节点。一个操作对应一个节点。比如map，就会创建一个节点。其中pre指针指向前一个节点也就是头节点。而头节点的next指针指向map节点。</p>
<p>filter操作的时候同样创建一个节点，pre指针指向上一个操作也就是map节点。map节点的next指针指向filter节点。</p>
<p>每个中间态节点中都存储了操作，也就是中间态的时候传入的函数。而数据则全部在头节点中。</p>
<p>比如下面这样：</p>
<p><img src="/../images/stream4.png" alt="strem"></p>
<p>每个中间态节点其实又分成两种</p>
<ul>
<li>有状态节点</li>
<li>无状态节点</li>
</ul>
<p>类图如下：</p>
<p><img src="/../images/stream12.png" alt="stream12"></p>
<p>中间态节点的几个操作如下：</p>
<p><img src="/../images/stream13.png" alt="stream13"></p>
<p>我们目前的代码中使用了两个中间态的方法。</p>
<ul>
<li>map</li>
<li>filter</li>
</ul>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>我们调用的是<code>ReferencePipeline</code>类的<code>map</code>方法。作为中间态方法，需要链式操作，所以返回值当然是一个stream了。接受一个函数作为入参，可以是一个写好的函数，也可以是一个lambda表达式的函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> P_OUT, ? extends R&gt; mapper)</span> &#123;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="comment">//创建一个无状态的对象</span></span><br><span class="line">    <span class="comment">//第一个参数是this，也就是刚才初始化好的只有一个头节点的双向链表。</span></span><br><span class="line">    <span class="comment">//第二个参数是一个常量 REFERENCE</span></span><br><span class="line">    <span class="comment">//第三个参数是 8 &amp; 2 = 1000 &amp; 0010 = 1010 = 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StatelessOp</span>&lt;P_OUT, R&gt;(<span class="built_in">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                    StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//增加了opWrapSink方法，第一个参数是标志 = 95，第二个是sink节点</span></span><br><span class="line">        <span class="comment">//这个方法会在结果态的时候调用</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        Sink&lt;P_OUT&gt; <span class="title function_">opWrapSink</span><span class="params">(<span class="type">int</span> flags, Sink&lt;R&gt; sink)</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个 Sink.ChainedReference类的对象并返回。具体的放在结果态里面讲。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sink</span>.ChainedReference&lt;P_OUT, R&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(P_OUT u)</span> &#123;</span><br><span class="line">                    downstream.accept(mapper.apply(u));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无状态节点的构造方法</span></span><br><span class="line"><span class="comment">//第一个参数是this，也就是刚才初始化好的只有一个头节点的双向链表。</span></span><br><span class="line"><span class="comment">//第二个参数是一个常量 REFERENCE</span></span><br><span class="line"><span class="comment">//第三个参数是 8 &amp; 2 = 1000 &amp; 0010 = 1010 = 10</span></span><br><span class="line">StatelessOp(AbstractPipeline&lt;?, E_IN, ?&gt; upstream,</span><br><span class="line">            StreamShape inputShape,</span><br><span class="line">            <span class="type">int</span> opFlags) &#123;</span><br><span class="line">    <span class="comment">//调用父类的构造函数</span></span><br><span class="line">    <span class="built_in">super</span>(upstream, opFlags);</span><br><span class="line">    <span class="comment">// upstream.getOutputShape() 返回的就是 REFERENCE， inputShape = REFERENCE，</span></span><br><span class="line">    <span class="comment">// 所以返回true</span></span><br><span class="line">    <span class="keyword">assert</span> upstream.getOutputShape() == inputShape;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//巧了，他的父类也是ReferencePipeline，所以又来到了它的构造方法，不过和上次那个不是同一个了。</span></span><br><span class="line"><span class="comment">//这个作用是构造一个中间态的节点，加入到双向链表也就是加入到流中。</span></span><br><span class="line"><span class="comment">//第一个参数是 双向链表</span></span><br><span class="line"><span class="comment">//第二个是 10</span></span><br><span class="line">ReferencePipeline(AbstractPipeline&lt;?, P_IN, ?&gt; upstream, <span class="type">int</span> opFlags) &#123;</span><br><span class="line">    <span class="comment">//再次调用父类的构造方法</span></span><br><span class="line">    <span class="built_in">super</span>(upstream, opFlags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里同样来到了AbstractPipeline的构造方法。</span></span><br><span class="line"><span class="comment">//这个方法的作用是构造一个中间态的节点。</span></span><br><span class="line"><span class="comment">//第一个参数是上一个节点，这里上一个就是头节点。</span></span><br><span class="line"><span class="comment">//第二个参数是10</span></span><br><span class="line">AbstractPipeline(AbstractPipeline&lt;?, E_IN, ?&gt; previousStage, <span class="type">int</span> opFlags) &#123;</span><br><span class="line">    <span class="comment">//判断上一个节点是否连接了消费者，如果连接了就报错。</span></span><br><span class="line">    <span class="keyword">if</span> (previousStage.linkedOrConsumed)</span><br><span class="line">        <span class="comment">//抛出非法状态异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(MSG_STREAM_LINKED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把上一个节点的是否连接消费者 = 1</span></span><br><span class="line">    previousStage.linkedOrConsumed = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//上一个节点的 next 指针指向当前节点。</span></span><br><span class="line">    previousStage.nextStage = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的头指针指向上一个节点</span></span><br><span class="line">    <span class="built_in">this</span>.previousStage = previousStage;</span><br><span class="line">    <span class="comment">//10 &amp; 16777407 = 10</span></span><br><span class="line">    <span class="built_in">this</span>.sourceOrOpFlags = opFlags &amp; StreamOpFlag.OP_MASK;</span><br><span class="line">    <span class="comment">//组合当前节点的标志和上一个节点的标志生成新的标志 生成的新标志 = 90</span></span><br><span class="line">    <span class="built_in">this</span>.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);</span><br><span class="line">    <span class="comment">//当前节点的数据 = 上一个节点的数据 = list</span></span><br><span class="line">    <span class="built_in">this</span>.sourceStage = previousStage.sourceStage;</span><br><span class="line">    <span class="comment">//当前节点是否是有状态的节点，这里是false</span></span><br><span class="line">    <span class="keyword">if</span> (opIsStateful())</span><br><span class="line">        sourceStage.sourceAnyStateful = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//深度+1 = 1</span></span><br><span class="line">    <span class="built_in">this</span>.depth = previousStage.depth + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组合当前节点的标志和上一个节点的标志生成新的标志</span></span><br><span class="line"><span class="comment">//第一个参数10</span></span><br><span class="line"><span class="comment">//第二个参数95</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">combineOpFlags</span><span class="params">(<span class="type">int</span> newStreamOrOpFlags, <span class="type">int</span> prevCombOpFlags)</span> &#123;</span><br><span class="line">    <span class="comment">// 0x01 or 0x10 nibbles are transformed to 0x11</span></span><br><span class="line">    <span class="comment">// 0x00 nibbles remain unchanged</span></span><br><span class="line">    <span class="comment">// Then all the bits are flipped</span></span><br><span class="line">    <span class="comment">// Then the result is logically or&#x27;ed with the operation flags.</span></span><br><span class="line">    <span class="comment">// 95 &amp; -16 ｜ 10 = 90</span></span><br><span class="line">    <span class="keyword">return</span> (prevCombOpFlags &amp; StreamOpFlag.getMask(newStreamOrOpFlags)) | newStreamOrOpFlags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> StreamShape <span class="title function_">getOutputShape</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> StreamShape.REFERENCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>到这里<code>map</code>方法就执行结束了。可以看到这里依然没有真正的执行map方法。只是封装成了一个中间态的节点并加入了双向链表。并将数据list和操作mapper都存入了节点。如下。</p>
<p><img src="/../images/stream3.png" alt="stream3.png"></p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter和map一样，作为中间态的方法。来看一下它的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同样需要返回一个stream对象。</span></span><br><span class="line"><span class="comment">// 同样接受一个方法或lambda表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> P_OUT&gt; predicate)</span> &#123;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    Objects.requireNonNull(predicate);</span><br><span class="line">    <span class="comment">//同样创建一个无状态的节点并返回</span></span><br><span class="line">    <span class="comment">//第一个参数是this，是包含了头节点和map节点的链表。</span></span><br><span class="line">    <span class="comment">//第二个参数是一个常量 REFERENCE</span></span><br><span class="line">    <span class="comment">//第三个参数是 128</span></span><br><span class="line">    <span class="comment">//具体的代码和map的执行是一样的创建。并没有区别。不再赘述。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StatelessOp</span>&lt;P_OUT, P_OUT&gt;(<span class="built_in">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                    StreamOpFlag.NOT_SIZED) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//增加了opWrapSink方法，第一个参数是标志 = 90，第二个是sink节点</span></span><br><span class="line">        <span class="comment">//这个方法会在结果态的时候调用</span></span><br><span class="line">        Sink&lt;P_OUT&gt; <span class="title function_">opWrapSink</span><span class="params">(<span class="type">int</span> flags, Sink&lt;P_OUT&gt; sink)</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个 Sink.ChainedReference类的对象并返回。具体的放在结果态里面讲。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sink</span>.ChainedReference&lt;P_OUT, P_OUT&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">                    downstream.begin(-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(P_OUT u)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (predicate.test(u))</span><br><span class="line">                        downstream.accept(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当filter完成以后，可以得到下面的数据结构。</p>
<p><img src="/../images/stream4.png" alt="stream4.png"></p>
<h3 id="其他的中间态方法"><a href="#其他的中间态方法" class="headerlink" title="其他的中间态方法"></a>其他的中间态方法</h3><p>总共有9个中间态方法，除了上面的两个还有</p>
<ul>
<li>无状态<ul>
<li>flatMap</li>
<li>unordered</li>
<li>peek</li>
</ul>
</li>
<li>有状态<ul>
<li>distinct</li>
<li>sorted</li>
<li>limit</li>
<li>skip</li>
</ul>
</li>
</ul>
<h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><p>先来看<code>flatMap</code>这个。他的作用是把给定的二维数组，转化成一维数组。比如</p>
<ul>
<li>给定输入：[[1],[2],[3],[4,5]]</li>
<li>要求输出：[1,2,3,4,5]</li>
</ul>
<p>来看应用层代码。首先构建一个二维数组，然后调用flatMap方法，传入<code>Collection::stream</code>方法进行处理元素，最后通过<code>collect</code>变成一个一维的list。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先初始化输入列表</span></span><br><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String &gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list1.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">list2.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">list3.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">list4.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">list4.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(list1);</span><br><span class="line">list.add(list2);</span><br><span class="line">list.add(list3);</span><br><span class="line">list.add(list4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始执行操作</span></span><br><span class="line">List&lt;String&gt; listT = list.stream().flatMap(Collection::stream).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> listT;</span><br></pre></td></tr></table></figure>

<p>看一下具体的执行流程。橙色的是stream的通用执行流程，不管你中间态用哪个方法，这里是不变的，蓝色的是<code>ArrayListSpliterator</code>分割器。红色的执行流程是flatMap的执行流程。</p>
<p><img src="/../images/stream14.png" alt="stream14.png"></p>
<p>可以看到<code>ArrayListSpliterator</code>先取出第一个元素<code>[1]</code>这个一维数组传递给<code>flatMap</code>，然后flatMap执行了我们传入的<code>Collection::stream</code>方法，该方法我们之前说过是初始化一个stream头节点。也就是再生成了一个stream</p>
<p>重点就是这里了。再次把[1]这个一维数组放入了新的stream里面。然后把结果态节点<code>ReduceOps</code>传递给了新的stream作为新的stream的结果态节点。</p>
<p>这个时候新的stream开始执行<code>ArrayListSpliterator</code>。从而把[1]一维数组进行for循环，取出了其中的<code>1</code>这个元素，然后把1传入了同一个<code>ReduceOps</code>进行处理从而组成了一个结果list-&gt;[1]。</p>
<p>把步骤总结如下：</p>
<ol>
<li>取出二维数组的第一个一维数组</li>
<li>把一维数组和结果态节点重新创建一个stream</li>
<li>执行stream把一维数组的元素循环放入结果态的list</li>
</ol>
<p>循环二维数组，不断重复上述步骤，就可以把二维数组展开成一维数组了。</p>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>来看方法的源码，可以看到接受一个方法，返回一个stream，标准的中间态处理。</p>
<p>可以看到参数校验以后就创建了一个无状态节点，节点的具体创建上面说过了。是一样的，不同的就是<code>accpet</code>这个方法。</p>
<p>这个处理逻辑，接受一个参数，这个参数就是上面传入的一维数组，第一次是[1]，第二次是[2]，第三次是[3]，第四次是[4,5]。因为我们传入的方法是 Collection.stream方法，所以会生成一个新的stream并返回给result。</p>
<p>这个时候的result就是一个只有一个头节点的stream。头节点中包含了一维数组[1]。然后判断stream不为空，则调用stream顺序流进行处理，并把collect结果态节点传入。</p>
<p>当<code>forEach</code>处理完以后，该<code>accept</code>方法处理完成。回到当前流也就是二维数组的流中。然后取出下一个一维数组[2]再次进入<code>accept</code>方法执行。直到当前二维数组的流处理完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; Stream&lt;R&gt; <span class="title function_">flatMap</span><span class="params">(Function&lt;? <span class="built_in">super</span> P_OUT, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span> &#123;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="comment">// We can do better than this, by polling cancellationRequested when stream is infinite</span></span><br><span class="line">    <span class="comment">// 创建无状态节点并返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StatelessOp</span>&lt;P_OUT, R&gt;(<span class="built_in">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                    StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        Sink&lt;P_OUT&gt; <span class="title function_">opWrapSink</span><span class="params">(<span class="type">int</span> flags, Sink&lt;R&gt; sink)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sink</span>.ChainedReference&lt;P_OUT, R&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="comment">// 初始化数据</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">                    downstream.begin(-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="comment">// 执行逻辑处理</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(P_OUT u)</span> &#123;</span><br><span class="line">                    <span class="comment">// 调用传入的方法进行处理元素 u ，u可能是 [1] [2] [3] [4,5]</span></span><br><span class="line">                    <span class="comment">// 并将执行结果新的stream赋值给 result</span></span><br><span class="line">                    <span class="keyword">try</span> (Stream&lt;? <span class="keyword">extends</span> <span class="title class_">R</span>&gt; result = mapper.apply(u)) &#123;</span><br><span class="line">                        <span class="comment">// We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it</span></span><br><span class="line">                        <span class="comment">// 如果执行成功 返回了一个有效的 stream，则调用stream顺序流循环处理 downstream</span></span><br><span class="line">                        <span class="comment">// 这里的 downstream就是 结果态节点 ReduceOp 也就是 collect 收集方法</span></span><br><span class="line">                        <span class="keyword">if</span> (result != <span class="literal">null</span>)</span><br><span class="line">                            result.sequential().forEach(downstream);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看一下<code>forEach</code>方法，这个方法很简单。如果不是并行流，那么调用<code>ArrayListSpliterator</code>的<code>forEachRemaining</code>进行处理，传入结果态节点collect。</p>
<p>而<code>forEachRemaining</code>这个方法我们很熟悉了，无非就是循环流中的元素并传入sink链处理。要注意的是这个时候的流是上面新创建的流，这个流里面的元素是[1]这个一维数组。而这个流里面是没有中间态节点的，只有一个传入的collect结果态节点组成的sink链。所以这个流处理完以后就会把[1]里面的<code>1</code>这个元素收集到collect结果态节点中。</p>
<p>当这个forEach处理完这个一维数组以后，返回到上面的accept方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E_OUT&gt; action)</span> &#123;</span><br><span class="line">    <span class="comment">//判断不是并行流</span></span><br><span class="line">    <span class="keyword">if</span> (!isParallel()) &#123;</span><br><span class="line">        <span class="comment">//使用ArrayListSpliterator的forEachRemaining方法，传入结果态节点进行处理。</span></span><br><span class="line">        sourceStageSpliterator().forEachRemaining(action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.forEach(action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="unordered"><a href="#unordered" class="headerlink" title="unordered"></a>unordered</h4><p>这个方法很少使用。主要是不保证流有序，而不是主动打乱流的顺序。直接看当前类中的方法源码吧。</p>
<p>如果有序，直接返回了，如果无序的话会返回一个无状态节点。而这里面并没有accept操作，而是直接返回了传入的sink节点。</p>
<p>比如传入 <code>reduceOp</code> 这个结果态的sink，那就返回这个。如果传入 <code>map</code> 的 sink 就返回这个sink。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Stream&lt;P_OUT&gt; <span class="title function_">unordered</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//判断是否有序，如果无序，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!isOrdered())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果有序，创建一个无状态节点，sink链直接返回。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StatelessOp</span>&lt;P_OUT, P_OUT&gt;(<span class="built_in">this</span>, StreamShape.REFERENCE, StreamOpFlag.NOT_ORDERED) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        Sink&lt;P_OUT&gt; <span class="title function_">opWrapSink</span><span class="params">(<span class="type">int</span> flags, Sink&lt;P_OUT&gt; sink)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sink;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否有有序的标志</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOrdered</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//判断标志位里面是否有ordered这个标志位</span></span><br><span class="line">    <span class="keyword">return</span> StreamOpFlag.ORDERED.isKnown(combinedFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h4><p>这个方法很少使用。主要是调试的时候使用来查看元素是否经过流，当然了也有其他的用法，如果你能保证它不出错的情况下。</p>
<p>来看一个debug的例子。他将打印每一个流经<code>peek</code>方法的元素，在当前场景下，所有元素都会执行打印操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先初始化输入列表</span></span><br><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String &gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list1.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">list2.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">list3.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">list4.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">list4.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(list1);</span><br><span class="line">list.add(list2);</span><br><span class="line">list.add(list3);</span><br><span class="line">list.add(list4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始执行操作</span></span><br><span class="line">List&lt;String&gt; listT = list.stream().flatMap(Collection::stream).peek(e -&gt; System.out.println(e)).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> listT;</span><br></pre></td></tr></table></figure>

<p>但是如果我们修改一下，比如增加<code>filter</code>方法。这个时候，第二个peek方法，就只有&gt;2的元素会流经了，从而只会打印出&gt;2的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开始执行操作</span></span><br><span class="line">List&lt;String&gt; listT = list.stream().flatMap(Collection::stream).peek(e -&gt; System.out.println(e)).filter(x -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">2</span>;</span><br><span class="line">&#125;).peek(e -&gt; System.out.println(e)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>来看一下peek的执行时序图。可以看到第一个元素1执行完filter由于不满足条件所以后面的peek和collect都没有再执行。</p>
<p>而第二个元素3执行完filter以后又执行了peek和collect。所以这就是为什么一般又来debug的原因，因为他不一定执行。</p>
<p><img src="/../images/stream15.png" alt="stream15"></p>
<p>接下来看一下它的源码.接受一个方法进行处理，返回一个stream。</p>
<p>而真正处理的时候，只是把流中的元素作为参数调用了peek的这个方法，然后不管结果，再次流动。相当于在流中间插入了一个方法。</p>
<p>所以理论上，你可以插入任何方法。但是要小心，如果因为某些原因导致流中的元素没有走到你的peek方法中，可能会产生印象不到的问题。</p>
<p>所以官方也更推荐用来debug。</p>
<blockquote>
<p>This method exists mainly to support debugging, where you want to see the elements as they flow past a certain point in a pipeline</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title function_">peek</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> P_OUT&gt; action)</span> &#123;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="comment">//创建一个无状态节点并返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StatelessOp</span>&lt;P_OUT, P_OUT&gt;(<span class="built_in">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                    <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        Sink&lt;P_OUT&gt; <span class="title function_">opWrapSink</span><span class="params">(<span class="type">int</span> flags, Sink&lt;P_OUT&gt; sink)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sink</span>.ChainedReference&lt;P_OUT, P_OUT&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(P_OUT u)</span> &#123;</span><br><span class="line">                    <span class="comment">//接受到流中的一个元素</span></span><br><span class="line">                    <span class="comment">//使用该元素作为参数调用peek传入的方法</span></span><br><span class="line">                    action.accept(u);</span><br><span class="line">                    <span class="comment">//调用完以后不管结果如何 继续流动下去</span></span><br><span class="line">                    downstream.accept(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p><code>distinct</code>的作用很明显了，是去重</p>
<p>看一下应用层代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先初始化输入列表</span></span><br><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String &gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list1.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">list2.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">list3.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">list4.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">list4.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(list1);</span><br><span class="line">list.add(list2);</span><br><span class="line">list.add(list3);</span><br><span class="line">list.add(list4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始执行操作</span></span><br><span class="line">List&lt;String&gt; listT = list.stream().flatMap(Collection::stream).peek(e -&gt; System.out.println(e)).distinct().collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> listT;</span><br></pre></td></tr></table></figure>

<p>接下来看源码。直接返回<code>DistinctOps</code>节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title function_">distinct</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> DistinctOps.makeRef(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下<code>makeRef</code>这个方法。</p>
<p>他首先是创建了一个有状态节点<code>stateFulOps</code>对象。接下来分为三种情况</p>
<ul>
<li>已经是去重的了，不再去重</li>
<li>有序去重</li>
<li>无序去重</li>
</ul>
<p>先看无序去重，在这个对象的<code>begin</code>初始化中，创建了一个<code>hashSet</code>对象。 </p>
<p><code>accept</code>执行方法中。首先判断了流中的这个元素是否存在<code>hashSet</code>中，如果存在了就不继续沿着sink链执行了。如果不存在，将元素放入<code>hashSet</code>中并继续执行sink链。</p>
<p>通过<code>hashSet</code>来达到去重的一个效果。这将输出1,3,5,4</p>
<p>再来看有序去重，在这个对象的<code>begin</code>初始化中，创建了<code>seenNull</code>和<code>lastSeen</code>属性。</p>
<ul>
<li>seenNull: 当前元素是否为null</li>
<li>lastSeen: 上一个元素</li>
</ul>
<p>在<code>accept</code>方法中。判断当前元素是null并且seenNull &#x3D; false，那么设置seenNull &#x3D; true 且 lastSeen &#x3D; null 并执行下一个操作。</p>
<p>否则，判断 lastSeen 是null也就是代表当前元素是<code>第一个元素</code>，或者 <code>当前元素</code>不等于<code>上一个元素</code>，那么自然是不重复的，所以执行下一个操作。</p>
<p>如果都不满足说明重复。那么不执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; ReferencePipeline&lt;T, T&gt; <span class="title function_">makeRef</span><span class="params">(AbstractPipeline&lt;?, T, ?&gt; upstream)</span> &#123;</span><br><span class="line">    <span class="comment">//生成有状态节点。传入stream，标志位传入IS_DISTINCT也就是要去重。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReferencePipeline</span>.StatefulOp&lt;T, T&gt;(upstream, StreamShape.REFERENCE,</span><br><span class="line">                                                    StreamOpFlag.IS_DISTINCT | StreamOpFlag.NOT_SIZED) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        Sink&lt;T&gt; <span class="title function_">opWrapSink</span><span class="params">(<span class="type">int</span> flags, Sink&lt;T&gt; sink)</span> &#123;</span><br><span class="line">            <span class="comment">//参数校验</span></span><br><span class="line">            Objects.requireNonNull(sink);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断标志位是否有DISTINCT标志</span></span><br><span class="line">            <span class="comment">//注意这里的flags是上一个节点的标志位，以我们的代码为例，这个是peek的标志位。所以这里返回false</span></span><br><span class="line">            <span class="comment">//这里的判断相当于如果你已经去重了，就不需要在去重了。比如distinct().distinct()。只会去重一次。</span></span><br><span class="line">            <span class="keyword">if</span> (StreamOpFlag.DISTINCT.isKnown(flags)) &#123;</span><br><span class="line">                <span class="keyword">return</span> sink;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StreamOpFlag.SORTED.isKnown(flags)) &#123;</span><br><span class="line">                <span class="comment">//判断是否有序的标志位，也就是判断前面是否已经有序 这里是无序，所以不走这里。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sink</span>.ChainedReference&lt;T, T&gt;(sink) &#123;</span><br><span class="line">                    <span class="type">boolean</span> seenNull;</span><br><span class="line">                    T lastSeen;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">                        seenNull = <span class="literal">false</span>;</span><br><span class="line">                        lastSeen = <span class="literal">null</span>;</span><br><span class="line">                        downstream.begin(-<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">                        seenNull = <span class="literal">false</span>;</span><br><span class="line">                        lastSeen = <span class="literal">null</span>;</span><br><span class="line">                        downstream.end();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span> &#123;</span><br><span class="line">                        <span class="comment">//有序的去重比无序简单很多</span></span><br><span class="line">                        <span class="comment">//因为有序，如果重复那么必然是形如 a a a 这种重复，也就是重复的一定在一起。</span></span><br><span class="line">                        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!seenNull) &#123;</span><br><span class="line">                                seenNull = <span class="literal">true</span>;</span><br><span class="line">                                downstream.accept(lastSeen = <span class="literal">null</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastSeen == <span class="literal">null</span> || !t.equals(lastSeen)) &#123;</span><br><span class="line">                            <span class="comment">//所以这里只需要判断lastSeen也就是上一个出现的这个元素是null</span></span><br><span class="line">                            <span class="comment">//或者当前元素不等于上一个出现的元素那么就是不重复的</span></span><br><span class="line">                            <span class="comment">//比如 2 1 1，当前元素是第一个1，上一个元素是2，不等于，所以流动下去</span></span><br><span class="line">                            <span class="comment">//当前元素是第二个1，上一个元素也是1,等于，所以重复，不走这里</span></span><br><span class="line">                            downstream.accept(lastSeen = t);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果上一个节点没有 DISTINCT 也没有 SORTED 标志，那么走这里。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sink</span>.ChainedReference&lt;T, T&gt;(sink) &#123;</span><br><span class="line">                    Set&lt;T&gt; seen;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">                        <span class="comment">//初始化 hashSet</span></span><br><span class="line">                        seen = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">                        downstream.begin(-<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">                        seen = <span class="literal">null</span>;</span><br><span class="line">                        downstream.end();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span> &#123;</span><br><span class="line">                        <span class="comment">// 这里的处理就是创建一个hashSet然后判断这个元素是否在hashSet中存在。</span></span><br><span class="line">                        <span class="keyword">if</span> (!seen.contains(t)) &#123;</span><br><span class="line">                            <span class="comment">//如果不存在就不重复，放入hashSet</span></span><br><span class="line">                            seen.add(t);</span><br><span class="line">                            <span class="comment">//继续执行</span></span><br><span class="line">                            downstream.accept(t);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看一下执行的时序图。</p>
<p><img src="/../images/stream16.png" alt="stream16"></p>
<h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><p><code>sorted</code>作用是按照给定的方法进行排序。其实底层就是调用的<code>List.sort</code>方法或<code>Arrays.sort</code>方法。</p>
<p>如果不传排序方法，将按照自然排序的方法来排序。</p>
<p>看一下应用层代码。</p>
<ul>
<li>输入 1 3 3 5 4</li>
<li>输出 1 3 3 4 5</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先初始化输入列表</span></span><br><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list1.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">list2.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">list3.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">list4.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">list4.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(list1);</span><br><span class="line">list.add(list2);</span><br><span class="line">list.add(list3);</span><br><span class="line">list.add(list4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始执行操作</span></span><br><span class="line">List&lt;String&gt; listT = list.stream().flatMap(Collection::stream).sorted(String::compareTo).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> listT;</span><br></pre></td></tr></table></figure>

<p>接下来看源码。有两个方法，一个是传入给定的排序方法，一个是不传。他们都会通过<code>SortedOps.makeRef</code>创建<code>OfRef</code>对象，这个是<code>StateFulOp</code>的子类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title function_">sorted</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> P_OUT&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SortedOps.makeRef(<span class="built_in">this</span>, comparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title function_">sorted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SortedOps.makeRef(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下SortedOps,就是直接创建<code>OfRef</code>对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">makeRef</span><span class="params">(AbstractPipeline&lt;?, T, ?&gt; upstream)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OfRef</span>&lt;&gt;(upstream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">makeRef</span><span class="params">(AbstractPipeline&lt;?, T, ?&gt; upstream,</span></span><br><span class="line"><span class="params">                            Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OfRef</span>&lt;&gt;(upstream, comparator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看这个类。有两个属性。最终根据是否有<code>SIZED</code>标志位，来决定使用array处理排序，还是array list处理排序。</p>
<ul>
<li>isNaturalSort 是否自然有序</li>
<li>comparator 排序比较方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">OfRef</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ReferencePipeline</span>.StatefulOp&lt;T, T&gt; &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Comparator used for sorting</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> isNaturalSort;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> T&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Sort using natural order of &#123;<span class="doctag">@literal</span> &lt;T&gt;&#125; which must be</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> Comparable&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">OfRef(AbstractPipeline&lt;?, T, ?&gt; upstream) &#123;</span><br><span class="line">    <span class="built_in">super</span>(upstream, StreamShape.REFERENCE,</span><br><span class="line">            StreamOpFlag.IS_ORDERED | StreamOpFlag.IS_SORTED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为自然有序</span></span><br><span class="line">    <span class="built_in">this</span>.isNaturalSort = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// Will throw CCE when we try to sort if T is not Comparable</span></span><br><span class="line">    <span class="comment">//设置排序方法为自然排序，如果是个不可排序的类型，将抛出异常</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> T&gt; comp = (Comparator&lt;? <span class="built_in">super</span> T&gt;) Comparator.naturalOrder();</span><br><span class="line">    <span class="built_in">this</span>.comparator = comp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Sort using the provided comparator.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> comparator The comparator to be used to evaluate ordering.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">OfRef(AbstractPipeline&lt;?, T, ?&gt; upstream, Comparator&lt;? <span class="built_in">super</span> T&gt; comparator) &#123;</span><br><span class="line">    <span class="built_in">super</span>(upstream, StreamShape.REFERENCE,</span><br><span class="line">            StreamOpFlag.IS_ORDERED | StreamOpFlag.NOT_SORTED);</span><br><span class="line">    <span class="comment">// 非自然排序</span></span><br><span class="line">    <span class="built_in">this</span>.isNaturalSort = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 将传入的排序方法赋值给排序方法</span></span><br><span class="line">    <span class="built_in">this</span>.comparator = Objects.requireNonNull(comparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Sink&lt;T&gt; <span class="title function_">opWrapSink</span><span class="params">(<span class="type">int</span> flags, Sink&lt;T&gt; sink)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(sink);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the input is already naturally sorted and this operation</span></span><br><span class="line">    <span class="comment">// also naturally sorted then this is a no-op</span></span><br><span class="line">    <span class="comment">// 如果已经是有序的并且是自然排序的，就直接返回sink节点</span></span><br><span class="line">    <span class="keyword">if</span> (StreamOpFlag.SORTED.isKnown(flags) &amp;&amp; isNaturalSort)</span><br><span class="line">        <span class="keyword">return</span> sink;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (StreamOpFlag.SIZED.isKnown(flags))</span><br><span class="line">    <span class="comment">// 如果标志位有 StreamOpFlag.SIZED，返回 SizedRefSortingSink 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SizedRefSortingSink</span>&lt;&gt;(sink, comparator);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果没有，返回 RefSortingSink 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RefSortingSink</span>&lt;&gt;(sink, comparator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下array流的sink节点。<br>有两个属性</p>
<ul>
<li>array 数据</li>
<li>offset 大小</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SizedRefSortingSink</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">AbstractRefSortingSink</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> offset;</span><br><span class="line"></span><br><span class="line">    SizedRefSortingSink(Sink&lt;? <span class="built_in">super</span> T&gt; sink, Comparator&lt;? <span class="built_in">super</span> T&gt; comparator) &#123;</span><br><span class="line">        <span class="comment">// 调用父类的构造器，创建一个 sink 节点</span></span><br><span class="line">        <span class="built_in">super</span>(sink, comparator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">        <span class="comment">// 在流开始的时候处理 如果流太大，就抛出异常，因为这里只处理有限流</span></span><br><span class="line">        <span class="keyword">if</span> (size &gt;= Nodes.MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(Nodes.BAD_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个Object的数组。</span></span><br><span class="line">        array = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[(<span class="type">int</span>) size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 当流结束的时候，就是所有元素都流动完成了</span></span><br><span class="line">        <span class="comment">// 使用给定的比较器对数组进行排序</span></span><br><span class="line">        Arrays.sort(array, <span class="number">0</span>, offset, comparator);</span><br><span class="line">        <span class="comment">// 这个时候流就是有序的流了，接下来在顺着donstream流动</span></span><br><span class="line">        downstream.begin(offset);</span><br><span class="line">        <span class="comment">// 如果cancellationWasRequested == false</span></span><br><span class="line">        <span class="keyword">if</span> (!cancellationWasRequested) &#123;</span><br><span class="line">            <span class="comment">// 每个元素调用 downstream 进行流动处理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; offset; i++)</span><br><span class="line">                downstream.accept(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果cancellationWasRequested == true</span></span><br><span class="line">            <span class="comment">// 先调用 downstream.cancellationRequested() 返回 false</span></span><br><span class="line">            <span class="comment">// 再执行元素调用 downstream 处理，</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; offset &amp;&amp; !downstream.cancellationRequested(); i++)</span><br><span class="line">                downstream.accept(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        downstream.end();</span><br><span class="line">        array = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="comment">// 当流元素经过的时候，存储到数组中，且offset++</span></span><br><span class="line">        array[offset++] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类 包含一个比较器，继承自 Sink.ChainedReference</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractRefSortingSink</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Sink</span>.ChainedReference&lt;T, T&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> T&gt; comparator;</span><br><span class="line">    <span class="comment">// @@@ could be a lazy final value, if/when support is added</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> cancellationWasRequested;</span><br><span class="line"></span><br><span class="line">    AbstractRefSortingSink(Sink&lt;? <span class="built_in">super</span> T&gt; downstream, Comparator&lt;? <span class="built_in">super</span> T&gt; comparator) &#123;</span><br><span class="line">        <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">        <span class="built_in">super</span>(downstream);</span><br><span class="line">        <span class="comment">// 比较器赋值</span></span><br><span class="line">        <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">cancellationRequested</span><span class="params">()</span> &#123;</span><br><span class="line">        cancellationWasRequested = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下array list的sink节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RefSortingSink</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">AbstractRefSortingSink</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;T&gt; list;</span><br><span class="line"></span><br><span class="line">    RefSortingSink(Sink&lt;? <span class="built_in">super</span> T&gt; sink, Comparator&lt;? <span class="built_in">super</span> T&gt; comparator) &#123;</span><br><span class="line">        <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">        <span class="built_in">super</span>(sink, comparator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果流太大就抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (size &gt;= Nodes.MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(Nodes.BAD_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 array list存储数据</span></span><br><span class="line">        list = (size &gt;= <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;((<span class="type">int</span>) size) : <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//对array listp排序</span></span><br><span class="line">        list.sort(comparator);</span><br><span class="line">        <span class="comment">//往下流动</span></span><br><span class="line">        downstream.begin(list.size());</span><br><span class="line">        <span class="comment">// 如果cancellationWasRequested == false</span></span><br><span class="line">        <span class="keyword">if</span> (!cancellationWasRequested) &#123;</span><br><span class="line">            <span class="comment">//循环每个元素进行流动</span></span><br><span class="line">            list.forEach(downstream::accept);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果cancellationWasRequested == true</span></span><br><span class="line">            <span class="comment">// 先调用 downstream.cancellationRequested() 返回 false</span></span><br><span class="line">            <span class="comment">// 再执行元素调用 downstream 处理，</span></span><br><span class="line">            <span class="keyword">for</span> (T t : list) &#123;</span><br><span class="line">                <span class="keyword">if</span> (downstream.cancellationRequested()) <span class="keyword">break</span>;</span><br><span class="line">                downstream.accept(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        downstream.end();</span><br><span class="line">        list = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="comment">// 把数据存入 array list</span></span><br><span class="line">        list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后看一下时序图。</p>
<p><img src="/../images/stream17.png" alt="steam17"></p>
<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p><code>limit</code>的作用是选取多少个元素。常常用在截取流的一部分。</p>
<p>还是以上面的排序代码为例，排序后只取前3个元素，就可以使用limit(3).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;String&gt; listT = list.stream().flatMap(Collection::stream).sorted(String::compareTo).limit(<span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单看一下源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果元素个数小于0，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (maxSize &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(Long.toString(maxSize));</span><br><span class="line">    <span class="comment">// 通过 SliceOps 创建一个 有状态节点</span></span><br><span class="line">    <span class="keyword">return</span> SliceOps.makeRef(<span class="built_in">this</span>, <span class="number">0</span>, maxSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下创建的节点。这个节点里面包含了一个sink节点。</p>
<p>sink节点中有两个属性</p>
<ul>
<li>n 也就是skip 跳过哪些，这里是0</li>
<li>m 也就是limit 取哪些，我们这里是3</li>
</ul>
<p>首先在初始化的时候限制了接下里节点初始化的大小。</p>
<p>真正处理的时候，如果有跳过的，先进行跳过，没有跳过的，就进行流动，当流动的元素数量达到limit个数量以后，不再流动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">makeRef</span><span class="params">(AbstractPipeline&lt;?, T, ?&gt; upstream,</span></span><br><span class="line"><span class="params">                                    <span class="type">long</span> skip, <span class="type">long</span> limit)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里 skip 是0，检查如果小于0就抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (skip &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Skip must be non-negative: &quot;</span> + skip);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回有状态节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReferencePipeline</span>.StatefulOp&lt;T, T&gt;(upstream, StreamShape.REFERENCE,</span><br><span class="line">                                                    flags(limit)) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        Sink&lt;T&gt; <span class="title function_">opWrapSink</span><span class="params">(<span class="type">int</span> flags, Sink&lt;T&gt; sink)</span> &#123;</span><br><span class="line">            <span class="comment">// 返回sink节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sink</span>.ChainedReference&lt;T, T&gt;(sink) &#123;</span><br><span class="line">                <span class="comment">//两个属性</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> skip;</span><br><span class="line">                <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> limit &gt;= <span class="number">0</span> ? limit : Long.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">                    <span class="comment">// 流的初始化 计算大小</span></span><br><span class="line">                    <span class="comment">// 这里size是流的大小，我们这里是5,skip是0，m是3 calcSize 返回的是 3</span></span><br><span class="line">                    <span class="comment">// 代表经过limit以后元素只有3个了，所以接下来节点的初始化只需要按3的大小来初始化就行了</span></span><br><span class="line">                    downstream.begin(calcSize(size, skip, m));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果跳过0个</span></span><br><span class="line">                    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 要取的元素 &gt; 0个</span></span><br><span class="line">                        <span class="keyword">if</span> (m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 按照顺序把每个元素流动</span></span><br><span class="line">                            <span class="comment">// m--，当3个元素流动完成以后，m == 0，就不再流动了。</span></span><br><span class="line">                            m--;</span><br><span class="line">                            downstream.accept(t);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果有要跳过的元素，n--，一直跳过，当全部跳过以后 n == 0 ，就不再跳过了</span></span><br><span class="line">                        n--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancellationRequested</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="type">return</span> <span class="variable">m</span> <span class="operator">=</span>= <span class="number">0</span> || downstream.cancellationRequested();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">flags</span><span class="params">(<span class="type">long</span> limit)</span> &#123;</span><br><span class="line">    <span class="comment">// 返回 NOT_SIZED 标志位 和 IS_SHORT_CIRCUIT 标志位</span></span><br><span class="line">    <span class="keyword">return</span> StreamOpFlag.NOT_SIZED | ((limit != -<span class="number">1</span>) ? StreamOpFlag.IS_SHORT_CIRCUIT : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">calcSize</span><span class="params">(<span class="type">long</span> size, <span class="type">long</span> skip, <span class="type">long</span> limit)</span> &#123;</span><br><span class="line">    <span class="comment">// size &gt;=0就 先取 size - skip 和 limit中最小的</span></span><br><span class="line">    <span class="comment">// 我们这里 5-0 = 5,和3比，最小的是3，这里的意思就是如果流的大小比limit小，就返回全部流</span></span><br><span class="line">    <span class="comment">// 然后 -1 和 5比，取大的，返回5</span></span><br><span class="line">    <span class="keyword">return</span> size &gt;= <span class="number">0</span> ? Math.max(-<span class="number">1</span>, Math.min(size - skip, limit)) : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p><code>skip</code>就是跳过多少个元素。可以和<code>limit</code>结合起来一起截取流。</p>
<p>还是以上面的代码为例.skip 1 , limit 3就代表取第2个元素到第4个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; listT = list.stream().flatMap(Collection::stream).sorted(String::compareTo).skip(<span class="number">1</span>).limit(<span class="number">3</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>简单看一下源码。如果skip小于0就抛出异常，如果&#x3D;&#x3D;0就直接返回，相当于不跳过。</p>
<p>创建节点的时候用的和上面<code>limit</code>的是一样的方法。只是参数变成了传skip，不传limit.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(Long.toString(n));</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//和limit一样</span></span><br><span class="line">        <span class="keyword">return</span> SliceOps.makeRef(<span class="built_in">this</span>, n, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>好了，到这里为止，就分析完了<code>stream</code>所有的<code>中间操作</code>。</p>
<p>从源码的角度分析了他们是如何运行的，都有什么作用。</p>
<p>总结一下。这些操作主要分为两大类</p>
<ul>
<li>有状态</li>
<li>无状态</li>
</ul>
<p>作为中间操作，他们的返回类型全部是 stream。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>‘stream&#39;</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-stream创建原理和数据结构操作</title>
    <url>/JAVA-stream%E5%8E%9F%E7%90%86%E5%88%9B%E5%BB%BA%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C.html</url>
    <content><![CDATA[<h1 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h1><p>stream是java8新增的非常重要的一个特性。并且非常的常用。它实现了<code>函数式编程</code>。具体函数式编程的概念已经很久了，比如js中的<code>箭头函数</code>。java中也通过stream做出了支持。想深入理解的可以参考cmu的课程<a href="http://www.cs.cmu.edu/~./15150/index.html">15-150</a>或者stanford的<a href="">CS 95SI</a>。</p>
<p>它可以帮助我们方便的处理很多东西。处理分为两种，中间态和结果态。</p>
<p><img src="/../images/stream1.png" alt="streamImg"></p>
<p>下面是一些中间态操作。他们位于链式操作的中间，当调用他们的时候并没有真正执行。只有当调用结果态的方法的时候才会真正的执行操作，也就是所谓的<code>延迟执行</code>。</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">map</td>
<td align="left">循环。可以简单理解为foreach</td>
</tr>
<tr>
<td align="left">flatMap</td>
<td align="left">将二维数据展开成一维</td>
</tr>
<tr>
<td align="left">filter</td>
<td align="left">过滤数据</td>
</tr>
<tr>
<td align="left">distinct</td>
<td align="left">去重</td>
</tr>
<tr>
<td align="left">sorted</td>
<td align="left">排序</td>
</tr>
<tr>
<td align="left">limit</td>
<td align="left">限制只取n个元素</td>
</tr>
<tr>
<td align="left">skip</td>
<td align="left">跳过n个元素</td>
</tr>
</tbody></table>
<h3 id="stream的初始化"><a href="#stream的初始化" class="headerlink" title="stream的初始化"></a>stream的初始化</h3><p>看一个例子，假设我们有一个需求。输出大于5的所有数。</p>
<ul>
<li>期望输入：2，5，7，1，3，2，8</li>
<li>期望输出：7，8</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先初始化输入列表</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始执行操作</span></span><br><span class="line">List&lt;Integer&gt; list2 = list.stream().map(Integer::valueOf).filter(x -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> x &gt; <span class="number">5</span>;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">System.out.println(list2);</span><br></pre></td></tr></table></figure>

<p>接下来看一下stream是如何执行的。下面是stream的一个类图。可以看到初始化需要使用到一个接口和6个类。主要分为三大类。</p>
<p><img src="/../images/stream8.png" alt="stream8.png"></p>
<h4 id="类介绍"><a href="#类介绍" class="headerlink" title="类介绍"></a>类介绍</h4><p>第一类是<code>ArrayList</code>类和<code>ArrayListSpliterator</code>类。这两个类是核心类。毕竟我们输入类型是ArrayList，这个就不用说了。</p>
<p>主要在于<code>ArrayListSpliterator</code>这个类，这个类是ArrayList的一个内部类。最主要的操作方法和数据都在里面。看一下几个属性</p>
<ul>
<li>list 我们要进行stream操作的list</li>
<li>fence 大小</li>
<li>expectedModCount 期望的处理数量</li>
<li>index</li>
</ul>
<p>最主要的循环处理方法同样在这个类里面。处理逻辑全部在<code>forEachRemaining</code>这个方法中。</p>
<p>第二大类是<code>StreamSupport</code>流的支持类，算是一个单独的类，提供了对stream的一些操作方法，比如初始化一个stream。</p>
<p>第三大类是<code>AbstractPipeline</code>抽象类为主的3个类，还有两个是继承自<code>AbstractPipeline</code>的<code>ReferencePipeline</code>类，主要负责处理引用类的流。和继承<code>ReferencePipeline</code>的<code>Head</code>类，实现了双向链表的头节点。他们的主要功能就是构造为流的双向链表数据结构。</p>
<p><img src="/../images/stream9.png" alt="stream9.png"></p>
<h4 id="执行流程介绍"><a href="#执行流程介绍" class="headerlink" title="执行流程介绍"></a>执行流程介绍</h4><p>这几个类的执行时序图如下。</p>
<p><img src="/../images/stream7.png" alt="stream7.png"></p>
<p>可以清晰的看到，通过<code>Collection</code>类的stream方法调用到了<code>ArrayList</code>的方法然后调用到了<code>ArrayListSpliterator</code>的方法，来初始化了<code>ArrayListSpliterator</code>对象，并存储到流中。</p>
<p>接下来<code>Collection</code>类将初始化好的<code>ArrayListSpliterator</code>对象传递给了<code>StreamSupport</code>类用来初始化stream。</p>
<p>StreamSupport将会创建一个双向链表的头节点。并将<code>ArrayListSpliterator</code>对象放入头节点。初始化以后的流如下图所示：</p>
<p><img src="/../images/stream2.png" alt="stream2.png"></p>
<h4 id="流介绍"><a href="#流介绍" class="headerlink" title="流介绍"></a>流介绍</h4><p>流分为两种，顺序流和并行流。</p>
<h5 id="顺序流"><a href="#顺序流" class="headerlink" title="顺序流"></a>顺序流</h5><p>顺序流顾名思义就是按照顺序执行。可以直接的类比为for循环。如下图，如果1，2，3三个元素，进入流以后，依然是1,2,3三个元素。</p>
<p><img src="/../images/stream10.png" alt="stream10.png"></p>
<h5 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h5><p>并行流是充分的利用现代多核计算机的性能而出的。它可以把流分散到各个进程&#x2F;线程中去执行。来达到并行执行的效果。如下图，1，2，3三个元素，可能会进入2个流中。</p>
<p><img src="/../images/stream11.png" alt="stream11.png"></p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>list的stream方法调用的是Collection类的stream方法。所以首先来看这个方法，该方法返回一个顺序流，顺序流中包含了list中的所有元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该方法返回一个顺序流，顺序流中包含了list中的所有元素。</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//调用了StreamSupport.stream方法，传入了一个分割迭代器，第二个参数false代表是顺序流，true是平行流。</span></span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成一个分割迭代器，该方法是ArrayList类中的方法。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//返回一个ArrayListSpliterator类的实例。</span></span><br><span class="line">    <span class="comment">//实例中包含4个属性</span></span><br><span class="line">    <span class="comment">//list = list</span></span><br><span class="line">    <span class="comment">//index = 0</span></span><br><span class="line">    <span class="comment">//fence = -1</span></span><br><span class="line">    <span class="comment">//expectedModCount = 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayListSpliterator</span>&lt;&gt;(<span class="built_in">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来来到StreamSupport类的stream方法。通过spliterator来创建一个顺序流。只有当结果态操作开始后，spliterator才会真正开始运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  通过spliterator来创建一个顺序流或者并行流，如果parallel=1就是并行流</span></span><br><span class="line"><span class="comment">*  只有当结果态操作开始后，spliterator才会真正开始运行</span></span><br><span class="line"><span class="comment">*  spliterator需要具有不可变性，并发性或延迟绑定性。</span></span><br><span class="line"><span class="comment">*  当前的spliterator就是上面生成的ArrayListSpliterator对象。且包含上面说的4个属性。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">stream</span><span class="params">(Spliterator&lt;T&gt; spliterator, <span class="type">boolean</span> parallel)</span> &#123;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    Objects.requireNonNull(spliterator);</span><br><span class="line">    <span class="comment">//返回一个ReferencePipeline.Head类型的头节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReferencePipeline</span>.Head&lt;&gt;(spliterator,</span><br><span class="line">                                        StreamOpFlag.fromCharacteristics(spliterator),</span><br><span class="line">                                        parallel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在生成Head对象的时候，第二个参数调用了<code>StreamOpFlag</code>类的<code>fromCharacteristics</code>方法。来看一下这个方法。<br>可以看到有一个判断是否是自然排序的，如果不是自然排序就会走到if里面，也就是不会将spliterator标记为已排序状态。<br>最终返回结果为80</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将spliterator的characteristic bit转换为stream flags</span></span><br><span class="line"><span class="comment">//当前的spliterator就是上面生成的 ArrayListSpliterator 对象。且包含上面说的4个属性。</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fromCharacteristics</span><span class="params">(Spliterator&lt;?&gt; spliterator)</span> &#123;</span><br><span class="line">    <span class="comment">//调用spliterator对象的characteristics方法。具体看下面 返回的characteristics = 16464</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">characteristics</span> <span class="operator">=</span> spliterator.characteristics();</span><br><span class="line">    <span class="comment">// 16464和4做按位与，即两个都是1才是1，100 0000 0101 0000 &amp; 100 = 000 0000 0000 0000 = 0说明不满足第一个条件，触发短路，走else</span></span><br><span class="line">    <span class="keyword">if</span> ((characteristics &amp; Spliterator.SORTED) != <span class="number">0</span> &amp;&amp; spliterator.getComparator() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Do not propagate the SORTED characteristic if it does not correspond</span></span><br><span class="line">        <span class="comment">// to a natural sort order</span></span><br><span class="line">        <span class="comment">// 如果不是自然排序的，则不传播有序状态。</span></span><br><span class="line">        <span class="keyword">return</span> characteristics &amp; SPLITERATOR_CHARACTERISTICS_MASK &amp; ~Spliterator.SORTED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//将16464和85做按位与，100 0000 0101 0000 &amp; 0101 0101 = 000 0000 0101 0000 = 80</span></span><br><span class="line">        <span class="comment">//返回80</span></span><br><span class="line">        <span class="keyword">return</span> characteristics &amp; SPLITERATOR_CHARACTERISTICS_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ArrayListSpliterator类的characteristics方法。</span></span><br><span class="line"><span class="comment">//三个数做按位或，即有1就是1，结果是 100 0000 0101 0000 = 16464</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">characteristics</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//Spliterator.ORDERED = 16 = 1 0000</span></span><br><span class="line">    <span class="comment">//Spliterator.SIZED = 64 = 100 0000</span></span><br><span class="line">    <span class="comment">//Spliterator.SUBSIZED = 16384 = 100 0000 0000 0000</span></span><br><span class="line">    <span class="keyword">return</span> Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来看<code>Head</code>类，它是<code>ReferencePipeline</code>类的一个内部类。主要作用是头节点的一些属性和操作。包括生成头节点等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Head</span>&lt;E_IN, E_OUT&gt; <span class="keyword">extends</span> <span class="title class_">ReferencePipeline</span>&lt;E_IN, E_OUT&gt; &#123;</span><br><span class="line">    <span class="comment">//这个是双向链表的头节点。也就是把最先创建的初始流作为头节点。</span></span><br><span class="line">    <span class="comment">//三个参数，第一个参数source = ArrayListSpliterator对象</span></span><br><span class="line">    <span class="comment">//第二个参数是流的标志，80</span></span><br><span class="line">    <span class="comment">//第三个参数是否并行流 0</span></span><br><span class="line">    Head(Spliterator&lt;?&gt; source,</span><br><span class="line">            <span class="type">int</span> sourceFlags, <span class="type">boolean</span> parallel) &#123;</span><br><span class="line">        <span class="comment">//调用了父类的构造函数，就是ReferencePipeline的构造方法。在下面。</span></span><br><span class="line">        <span class="built_in">super</span>(source, sourceFlags, parallel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ReferencePipeline的构造方法。参数同上，不再描述。</span></span><br><span class="line">ReferencePipeline(Spliterator&lt;?&gt; source,</span><br><span class="line">                    <span class="type">int</span> sourceFlags, <span class="type">boolean</span> parallel) &#123;</span><br><span class="line">    <span class="comment">//再次调用了父类的构造方法。ReferencePipeline的父类是AbstractPipeline类，放在下面了。</span></span><br><span class="line">    <span class="built_in">super</span>(source, sourceFlags, parallel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractPipeline类的构造方法。构造一个stream的头节点。</span></span><br><span class="line">AbstractPipeline(Spliterator&lt;?&gt; source,</span><br><span class="line">                     <span class="type">int</span> sourceFlags, <span class="type">boolean</span> parallel) &#123;</span><br><span class="line">    <span class="comment">//头节点的头指针为空。</span></span><br><span class="line">    <span class="built_in">this</span>.previousStage = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//数据 = ArrayListSpliterator对象</span></span><br><span class="line">    <span class="built_in">this</span>.sourceSpliterator = source;</span><br><span class="line">    <span class="comment">//头节点的数据 指向自己。</span></span><br><span class="line">    <span class="built_in">this</span>.sourceStage = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">//标志位 = 80 &amp; 85 = 80 二进制 0101 0000 &amp; 0101 0101 = 0101 0000 = 80</span></span><br><span class="line">    <span class="built_in">this</span>.sourceOrOpFlags = sourceFlags &amp; StreamOpFlag.STREAM_MASK;</span><br><span class="line">    <span class="comment">// The following is an optimization of:</span></span><br><span class="line">    <span class="comment">// StreamOpFlag.combineOpFlags(sourceOrOpFlags, StreamOpFlag.INITIAL_OPS_VALUE);</span></span><br><span class="line">    <span class="comment">//sourceOrOpFlags &lt;&lt; 1 = 160  左移一位就是 * 2</span></span><br><span class="line">    <span class="comment">//～160 = -161  按位去反</span></span><br><span class="line">    <span class="comment">// -161 &amp; 255 = 95</span></span><br><span class="line">    <span class="comment">// combinedFlags = 95</span></span><br><span class="line">    <span class="built_in">this</span>.combinedFlags = (~(sourceOrOpFlags &lt;&lt; <span class="number">1</span>)) &amp; StreamOpFlag.INITIAL_OPS_VALUE;</span><br><span class="line">    <span class="comment">// 双向链表深度 = 0 ，因为现在只有头节点。</span></span><br><span class="line">    <span class="built_in">this</span>.depth = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 是否并行流 = 0 不是</span></span><br><span class="line">    <span class="built_in">this</span>.parallel = parallel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>list.stream()函数的源码就完了。主要调用了构造函数，构造了一个含有list数据的头节点，头指针指向空，next指针指向自己。完成了流的初始化。当前数据结构如下。</p>
<p><img src="/../images/stream2.png" alt="stream2.png"></p>
<h3 id="stream的中间态"><a href="#stream的中间态" class="headerlink" title="stream的中间态"></a>stream的中间态</h3><p>中间态的具体源码和流程在后面介绍，这里只介绍中间态的作用。</p>
<p>中间态的主要作用是构建双向链表的中间节点。一个操作对应一个节点。比如map，就会创建一个节点。其中pre指针指向前一个节点也就是头节点。而头节点的next指针指向map节点。</p>
<p>filter操作的时候同样创建一个节点，pre指针指向上一个操作也就是map节点。map节点的next指针指向filter节点。</p>
<p>每个中间态节点中都存储了操作，也就是中间态的时候传入的函数。而数据则全部在头节点中。</p>
<p>比如下面这样：</p>
<p><img src="/../images/stream4.png" alt="strem"></p>
<p>每个中间态节点其实又分成两种</p>
<ul>
<li>有状态节点</li>
<li>无状态节点</li>
</ul>
<p>类图如下：</p>
<p><img src="/../images/stream12.png" alt="stream12"></p>
<h3 id="stream的结果态"><a href="#stream的结果态" class="headerlink" title="stream的结果态"></a>stream的结果态</h3><p>结果态的具体源码和流程在后面介绍，这里只介绍结果态的作用。</p>
<p>结果态的主要作用有三个</p>
<ol>
<li>构造结果态节点</li>
<li>构造sink链表</li>
<li>执行流。</li>
</ol>
<p>先说第一个，结果态节点是<code>ReduceOp</code>对象。这个结果态节点中包含了一个<code>makeSink</code>方法，用来构建结果态的sink节点。结果态的sink节点是一个<code>ReducingSink</code>对象。</p>
<p>第二个，当结果态节点和结果态的sink节点构造完成以后。接下来会根据之前构建好的双向链表来生成对应的sink链表。</p>
<p>一开始的双向链表我们知道是这样的</p>
<p><img src="/../images/stream4.png" alt="strem"></p>
<p>而sink链表则是反过来了，根据双向链表从后向前通过pre指针不断向前，把每个节点包裹在sink节点中并通过<code>downstream</code>指针来指向下个节点。这里因为在第一步的时候把源数据取出来了，所以sink中不包含头节点。创建完后如图所示：</p>
<p><img src="/../images/stream6.png" alt="strem"></p>
<p>第三步才是真正的执行流。根据sink链表来执行，每次把元素传递给第一个sink也就是map操作，当第一个sink节点处理完以后通过downstream流动到下一个sink节点执行。不断通过downsteram流动，直到最后到结果态的sink执行完以后。再次把第二个元素进行流动执行。直至所有元素执行完毕。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>因为是通过自顶向下的方式来了解stream。所以这里主要介绍了stream的执行流程和初始化的源码分析。中间态和结果态的源码分析放在了后面。</p>
<p>在执行流程中可以看到。首先创建了一个双向链表，然后在根据双向链表创建了sink链表。最后通过sink链表进行执行流的操作。也可以看出来确实是流动，传播，充满了stream的味道。</p>
<p>从这里也能看出来为何一开始是双向链表而不是单向的，因为要通过pre指针构造sink链表。</p>
<p>但是这里就有一个问题了，为什么不直接用一开始的双向链表，而要在创建一个sink链表呢？</p>
<p>我个人觉得有几个原因：</p>
<ol>
<li>因为当前处于结果态节点，想从头流动执行，需要当前指针先指向头节点，所以必须遍历一遍。</li>
<li>重新构建一个纯净的sink链表，来达到<code>不变性</code>的性质。保持之前的数据和节点等不可变。</li>
<li>双向链表只负责存储数据和操作。真正的执行通过sink链表来执行，达到<code>单一职责</code>和<code>分层清晰</code>。</li>
<li>其中或许还有并行流并发的问题。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>‘stream&#39;</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-LocalDateTime时间格式化，转换时间戳和源码分析</title>
    <url>/JAVA-spring%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<h1 id="JAVA-LocalDateTime时间格式化，转换时间戳和源码分析"><a href="#JAVA-LocalDateTime时间格式化，转换时间戳和源码分析" class="headerlink" title="JAVA-LocalDateTime时间格式化，转换时间戳和源码分析"></a>JAVA-LocalDateTime时间格式化，转换时间戳和源码分析</h1><h2 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h2><p><code>LocalDateTime</code>作为java8新加的时间类型，也是后面开发中常用的时间类型。</p>
<p>作为时间类型，最关注的点无非是这几个</p>
<ul>
<li>获取当前时间</li>
<li>获取指定时间</li>
<li>时间格式化</li>
<li>时间转时间戳</li>
<li>时间戳转时间</li>
<li>时间比较</li>
<li>时间加减</li>
</ul>
<p>这些点通过<code>LocalDateTime</code>来操作，都会比较简单</p>
<h3 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h3><p>只需要now一下就可以获取到当前的时间，还是很方便的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now();</span><br></pre></td></tr></table></figure>

<p>再看一下之前的<code>Date</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure>

<h3 id="获取指定时间"><a href="#获取指定时间" class="headerlink" title="获取指定时间"></a>获取指定时间</h3><p>这个有比较多的方式</p>
<ul>
<li>通过原来的<code>date</code>和<code>dateTime</code>类型来生成</li>
<li>通过传年月日时分秒生成</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2022</span>,<span class="number">11</span>,<span class="number">30</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>原来<code>Date</code>类的方式。比较奇怪，他的年份会+1900，所以2022年就得是122，月份也会+1,所以11月就是10.但是这个方法呢后面会被删除，已经被标记为弃用了，使用<code>Calendar</code>代替。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">122</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>看一下<code>Calendar</code>的使用。这个年份就正常了，是2022，但是月份还是会+1.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">calendar.set(<span class="number">2022</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<h3 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h3><p>时间格式化都是通过<code>format</code>函数,需要传一个<code>DateTimeFormatter</code>对象进去，我们可以通过<code>DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)</code>来生成自己想要的格式。</p>
<p>DateTimeFormatter类里面也有一些定义好的格式可以直接用,除了下面列出的还有一些其他的，感兴趣可以看一下，不过我觉得都没啥用。</p>
<ul>
<li>ISO_DATE_TIME         2011-12-03T10:15:30</li>
<li>ISO_OFFSET_DATE_TIME  2011-12-03T10:15:30+01:00</li>
<li>ISO_LOCAL_DATE_TIME   2011-12-03T10:15:30</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">time.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>看一下<code>Date</code>的格式化。这个需要借用<code>SimpleDateFormat</code>类来完成格式化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">format.format(date);</span><br></pre></td></tr></table></figure>

<h3 id="时间转时间戳"><a href="#时间转时间戳" class="headerlink" title="时间转时间戳"></a>时间转时间戳</h3><p>时间转时间戳分为两种，一种是当你已经有一个<code>LocalDateTime</code>类型的时间了，需要转换成秒或者毫秒的时间戳。</p>
<h4 id="时间转换秒级时间戳"><a href="#时间转换秒级时间戳" class="headerlink" title="时间转换秒级时间戳"></a>时间转换秒级时间戳</h4><p>只需要直接用<code>toEpochSecond</code>方法就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">time.toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>));</span><br></pre></td></tr></table></figure>

<p><code>Date</code>类型没有办法直接获取秒级时间戳，只能获取毫秒级再转秒。</p>
<h4 id="时间转换毫秒级时间戳"><a href="#时间转换毫秒级时间戳" class="headerlink" title="时间转换毫秒级时间戳"></a>时间转换毫秒级时间戳</h4><p>转换毫秒需要先转换成<code>instant</code>对象，然后才能转换成毫秒级时间戳。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">time.toInstant(ZoneOffset.ofHours(<span class="number">8</span>)).toEpochMilli();</span><br></pre></td></tr></table></figure>

<p><code>Date</code>获取毫秒就很简单了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">date.getTime();</span><br></pre></td></tr></table></figure>

<h3 id="字符串转换成时间戳"><a href="#字符串转换成时间戳" class="headerlink" title="字符串转换成时间戳"></a>字符串转换成时间戳</h3><p>时间转时间戳分为两种，除了上面的，还有一种是有一个格式化好的字符串，比如<code>2022-12-18 10:00:00</code>这种，但是这个是字符串并不是时间类型。所以要先转换成<code>LocalDateTime</code>类型，然后就可以转换成时间戳了。</p>
<p>其实就是上面格式化的一种反向操作。使用<code>parse</code>方法就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime.parse(<span class="string">&quot;2022-12-18 10:00:00&quot;</span>, DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">LocalDateTime.parse(<span class="string">&quot;2022-12-18&quot;</span>, DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><code>Date</code>类型的字符串转时间戳也是通过<code>SimpleDateFormat</code>类来完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> format.parse(<span class="string">&quot;2022-12-18 10:00:00&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="时间戳转时间"><a href="#时间戳转时间" class="headerlink" title="时间戳转时间"></a>时间戳转时间</h3><p>那如果我们现在转换成时间戳以后又想转换成时间呢？也可以通过<code>instant</code>对象来做到。</p>
<h4 id="毫秒时间戳转时间"><a href="#毫秒时间戳转时间" class="headerlink" title="毫秒时间戳转时间"></a>毫秒时间戳转时间</h4><p><code>Instant.ofEpochSecond(1671365543834)</code>是将一个毫秒时间戳转换成一个instant对象。在通过<code>ofInstant</code>方法就可以将instant对象转换成LocalDateTime对象了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime.ofInstant(Instant.ofEpochSecond(<span class="number">1671365543834</span>), ZoneOffset.ofHours(<span class="number">8</span>));</span><br></pre></td></tr></table></figure>

<p><code>Date</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1669759566000L</span>);</span><br></pre></td></tr></table></figure>

<h4 id="秒时间戳转时间"><a href="#秒时间戳转时间" class="headerlink" title="秒时间戳转时间"></a>秒时间戳转时间</h4><p><code>Instant.ofEpochMilli(1671365543)</code>是将一个秒时间戳转换成<code>instant</code>对象。和上面的区别就是使用的是<code>ofEpochMilli</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime.ofInstant(Instant.ofEpochMilli(<span class="number">1671365543</span>), ZoneOffset.ofHours(<span class="number">8</span>));</span><br></pre></td></tr></table></figure>

<p><code>Date</code>类不支持秒，只能把秒转成毫秒在转时间戳。</p>
<h3 id="时间比较"><a href="#时间比较" class="headerlink" title="时间比较"></a>时间比较</h3><p>通过<code>compareTo</code>方法可以进行时间的一个比较大小。如果大于会返回1，小于返回-1.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">time.compareTo(LocalDateTime.now());</span><br></pre></td></tr></table></figure>

<p><code>Date</code>也是通过<code>compareTo</code>方法进行比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1669759566000L</span>);</span><br><span class="line">date.compareTo(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure>

<h3 id="时间加减"><a href="#时间加减" class="headerlink" title="时间加减"></a>时间加减</h3><p>如果加上几天，就是<code>plusDays</code>。加几个小时就是<code>plusHours</code>。当然也可以使用<code>plus</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">time.plusDays(<span class="number">1</span>);</span><br><span class="line">time.plusHours(<span class="number">1</span>);</span><br><span class="line">time.plus(Period.ofDays(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>如果减去几天就是<code>minusDays</code>.减去几个小时就是<code>minusHours</code>。当然也可以使用<code>minus</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">time.minusDays(<span class="number">1</span>);</span><br><span class="line">time.minusHours(<span class="number">1</span>);</span><br><span class="line">time.minus(Period.ofDays(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p><code>Date</code>类不支持时间加减，只能通过<code>Calendar</code>类实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">calendar.setTime(date);</span><br><span class="line">calendar.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//减去</span></span><br><span class="line">calendar.add(Calendar.DAY_OF_MONTH, -<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="时间格式在入参出参中的使用"><a href="#时间格式在入参出参中的使用" class="headerlink" title="时间格式在入参出参中的使用"></a>时间格式在入参出参中的使用</h3><p>入参的时候需要通过<code>JsonFormat</code>注解来指定需要的是字符串类型和对应的时间格式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(shape = JsonFormat.Shape.STRING, pattern=&quot;yyyy-MM-dd&quot;)</span></span><br><span class="line"><span class="keyword">private</span> LocalDate date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonFormat(shape = JsonFormat.Shape.STRING, pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime time;</span><br></pre></td></tr></table></figure>

<p>出参的时候就很简单了，因为只是返回了一个字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String time;</span><br></pre></td></tr></table></figure>

<h3 id="格式化时间源码分析"><a href="#格式化时间源码分析" class="headerlink" title="格式化时间源码分析"></a>格式化时间源码分析</h3><p>格式化的时候这两个年是不一样的，具体的可以看一下源码。我们来找一下。</p>
<p>首先点进去是LocalDateTime这个类里面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>  <span class="comment">// override for Javadoc and performance</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">format</span><span class="params">(DateTimeFormatter formatter)</span> &#123;</span><br><span class="line">    <span class="comment">//判断参数是否空</span></span><br><span class="line">    Objects.requireNonNull(formatter, <span class="string">&quot;formatter&quot;</span>);</span><br><span class="line">    <span class="comment">//真正的执行格式化</span></span><br><span class="line">    <span class="keyword">return</span> formatter.format(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来点进去，看一下怎么执行的，可以看到又调用了<code>formatTo</code>这个函数，说明主要的格式化代码都在这里面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">format</span><span class="params">(TemporalAccessor temporal)</span> &#123;</span><br><span class="line">       <span class="comment">//创建了一个32长度的字符串构建器</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">32</span>);</span><br><span class="line">        <span class="comment">//格式化主要代码</span></span><br><span class="line">        formatTo(temporal, buf);</span><br><span class="line">        <span class="comment">//转成字符串</span></span><br><span class="line">        <span class="keyword">return</span> buf.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看一下<code>formatTo</code>函数，可以发现主要是调用<code>printerParser</code>这个对象的<code>format</code>方法，那我们这个对象是哪来的呢，是在一开始指定格式化类型的时候来的。不同的格式化类型对应不同的解析器，也就会执行不同的<code>format</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">formatTo</span><span class="params">(TemporalAccessor temporal, Appendable appendable)</span> &#123;</span><br><span class="line">        <span class="comment">//判断参数，这里不用管</span></span><br><span class="line">        Objects.requireNonNull(temporal, <span class="string">&quot;temporal&quot;</span>);</span><br><span class="line">        Objects.requireNonNull(appendable, <span class="string">&quot;appendable&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个DateTimePrintContext对象</span></span><br><span class="line">            <span class="type">DateTimePrintContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateTimePrintContext</span>(temporal, <span class="built_in">this</span>);</span><br><span class="line">            <span class="comment">//判断，显然我们之前传过来的就是一个StringBuilder</span></span><br><span class="line">            <span class="keyword">if</span> (appendable <span class="keyword">instanceof</span> StringBuilder) &#123;</span><br><span class="line">                <span class="comment">//主要看这个怎么处理  这里有个 printerParser 对象，这个对象是怎么来的呢，其实是上面DateTimeFormatter.ofPattern的时候给创建的。</span></span><br><span class="line">                printerParser.format(context, (StringBuilder) appendable);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//这里其实就是如果传的不是个StringBuilder，就在创建一个然后执行</span></span><br><span class="line">                <span class="comment">// buffer output to avoid writing to appendable in case of error</span></span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">32</span>);</span><br><span class="line">                printerParser.format(context, buf);</span><br><span class="line">                appendable.append(buf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DateTimeException</span>(ex.getMessage(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看一下<code>ofPattern</code>这个方法里面是怎样的吧。这里是创建了一个 时间格式化的建造者，然后把我们这个字符串添加进去了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里的字符串就是我们传的 yyyy-MM-dd HH:mm:ss</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DateTimeFormatter <span class="title function_">ofPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DateTimeFormatterBuilder</span>().appendPattern(pattern).toFormatter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下<code>appendPattern</code>里面是怎么把字符串加进去的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title function_">appendPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">    <span class="comment">//忽略</span></span><br><span class="line">    Objects.requireNonNull(pattern, <span class="string">&quot;pattern&quot;</span>);</span><br><span class="line">    <span class="comment">//主要的解析逻辑</span></span><br><span class="line">    parsePattern(pattern);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续追踪到<code>parsePattern</code>方法里面。这个方法代码比较多，这里只关注我们想知道的。其余的有兴趣的可以看一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parsePattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">    <span class="comment">//这里给字符串做循环，注意 pattern = yyyy-MM-dd HH:mm:ss 这个字符串。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>; pos &lt; pattern.length(); pos++) &#123;</span><br><span class="line">        <span class="comment">//取出字符 比如第一个就是 y 对应的ASCII码就是121</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">cur</span> <span class="operator">=</span> pattern.charAt(pos);</span><br><span class="line">        <span class="comment">//这里就是判断是否是大小写字母了，也就是A-Z或者a-z</span></span><br><span class="line">        <span class="keyword">if</span> ((cur &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; cur &lt;= <span class="string">&#x27;Z&#x27;</span>) || (cur &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; cur &lt;= <span class="string">&#x27;z&#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">//初始化变量 start = 0 pos = 1</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> pos++;</span><br><span class="line">            <span class="comment">//这里做一个循环，目的其实就是找出相同的字符有几个，比如y有4个，pos就会变成4</span></span><br><span class="line">            <span class="keyword">for</span> ( ; pos &lt; pattern.length() &amp;&amp; pattern.charAt(pos) == cur; pos++);  <span class="comment">// short loop</span></span><br><span class="line">            <span class="comment">//这里就是算出具体的数量 4 - 0 = 4</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> pos - start;</span><br><span class="line">            <span class="comment">// padding  这里忽略 我们这里面没有这个字符</span></span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="string">&#x27;p&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">pad</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (pos &lt; pattern.length()) &#123;</span><br><span class="line">                    cur = pattern.charAt(pos);</span><br><span class="line">                    <span class="keyword">if</span> ((cur &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; cur &lt;= <span class="string">&#x27;Z&#x27;</span>) || (cur &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; cur &lt;= <span class="string">&#x27;z&#x27;</span>)) &#123;</span><br><span class="line">                        pad = count;</span><br><span class="line">                        start = pos++;</span><br><span class="line">                        <span class="keyword">for</span> ( ; pos &lt; pattern.length() &amp;&amp; pattern.charAt(pos) == cur; pos++);  <span class="comment">// short loop</span></span><br><span class="line">                        count = pos - start;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pad == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                            <span class="string">&quot;Pad letter &#x27;p&#x27; must be followed by valid pad pattern: &quot;</span> + pattern);</span><br><span class="line">                &#125;</span><br><span class="line">                padNext(pad); <span class="comment">// pad and continue parsing</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//接下来是主要逻辑。</span></span><br><span class="line">            <span class="comment">// main rules</span></span><br><span class="line">            <span class="comment">//从hashMap里面取出对应的值，这个map放在下面了。y取出来就是 YEAR_OF_ERA</span></span><br><span class="line">            <span class="type">TemporalField</span> <span class="variable">field</span> <span class="operator">=</span> FIELD_MAP.get(cur);</span><br><span class="line">            <span class="comment">//判断map里面取出来的是否为空，如果不为空就直接解析，如果为空就接着往下走，看是不是 zvZOXxWwY 这几个，如果都不是就会报错了</span></span><br><span class="line">            <span class="keyword">if</span> (field != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//我们y是能取出来的，直接解析这里 cur = y, count = 4, field = YEAR_OF_ERA</span></span><br><span class="line">                parseField(cur, count, field);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">4</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">4</span>) &#123;</span><br><span class="line">                    appendZoneText(TextStyle.FULL);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    appendZoneText(TextStyle.SHORT);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;V&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count != <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Pattern letter count must be 2: &quot;</span> + cur);</span><br><span class="line">                &#125;</span><br><span class="line">                appendZoneId();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count &lt; <span class="number">4</span>) &#123;</span><br><span class="line">                    appendOffset(<span class="string">&quot;+HHMM&quot;</span>, <span class="string">&quot;+0000&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">4</span>) &#123;</span><br><span class="line">                    appendLocalizedOffset(TextStyle.FULL);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">5</span>) &#123;</span><br><span class="line">                    appendOffset(<span class="string">&quot;+HH:MM:ss&quot;</span>,<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                    appendLocalizedOffset(TextStyle.SHORT);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">4</span>) &#123;</span><br><span class="line">                    appendLocalizedOffset(TextStyle.FULL);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Pattern letter count must be 1 or 4: &quot;</span> + cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">                &#125;</span><br><span class="line">                appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count == <span class="number">1</span> ? <span class="number">0</span> : <span class="number">1</span>)], <span class="string">&quot;Z&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">zero</span> <span class="operator">=</span> (count == <span class="number">1</span> ? <span class="string">&quot;+00&quot;</span> : (count % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">&quot;+0000&quot;</span> : <span class="string">&quot;+00:00&quot;</span>));</span><br><span class="line">                appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count == <span class="number">1</span> ? <span class="number">0</span> : <span class="number">1</span>)], zero);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// Fields defined by Locale</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">                &#125;</span><br><span class="line">                appendInternal(<span class="keyword">new</span> <span class="title class_">WeekBasedFieldPrinterParser</span>(cur, count));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;w&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// Fields defined by Locale</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">                &#125;</span><br><span class="line">                appendInternal(<span class="keyword">new</span> <span class="title class_">WeekBasedFieldPrinterParser</span>(cur, count));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;Y&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// Fields defined by Locale</span></span><br><span class="line">                appendInternal(<span class="keyword">new</span> <span class="title class_">WeekBasedFieldPrinterParser</span>(cur, count));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown pattern letter: &quot;</span> + cur);</span><br><span class="line">            &#125;</span><br><span class="line">            pos--;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// parse literals</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> pos++;</span><br><span class="line">            <span class="keyword">for</span> ( ; pos &lt; pattern.length(); pos++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pattern.charAt(pos) == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pos + <span class="number">1</span> &lt; pattern.length() &amp;&amp; pattern.charAt(pos + <span class="number">1</span>) == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">                        pos++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;  <span class="comment">// end of literal</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pos &gt;= pattern.length()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Pattern ends with an incomplete string literal: &quot;</span> + pattern);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> pattern.substring(start + <span class="number">1</span>, pos);</span><br><span class="line">            <span class="keyword">if</span> (str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                appendLiteral(<span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                appendLiteral(str.replace(<span class="string">&quot;&#x27;&#x27;&quot;</span>, <span class="string">&quot;&#x27;&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            optionalStart();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (active.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Pattern invalid as it contains ] without previous [&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            optionalEnd();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;&#123;&#x27;</span> || cur == <span class="string">&#x27;&#125;&#x27;</span> || cur == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Pattern includes reserved character: &#x27;&quot;</span> + cur + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// - : 这两个符号就会走到这里了</span></span><br><span class="line">            appendLiteral(cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下通过不同的key取值的map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时代</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;G&#x27;</span>, ChronoField.ERA);                       <span class="comment">// SDF, LDML (different to both for 1/2 chars)</span></span><br><span class="line"><span class="comment">//这个时代的年份，也就是我们常用的年份yyyy</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;y&#x27;</span>, ChronoField.YEAR_OF_ERA);               <span class="comment">// SDF, LDML</span></span><br><span class="line"><span class="comment">//单纯的年份</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;u&#x27;</span>, ChronoField.YEAR);                      <span class="comment">// LDML (different in SDF)</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;Q&#x27;</span>, IsoFields.QUARTER_OF_YEAR);             <span class="comment">// LDML (removed quarter from 310)</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;q&#x27;</span>, IsoFields.QUARTER_OF_YEAR);             <span class="comment">// LDML (stand-alone)</span></span><br><span class="line"><span class="comment">//一年里面的月份，也是我们常用的月份 MM</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;M&#x27;</span>, ChronoField.MONTH_OF_YEAR);             <span class="comment">// SDF, LDML</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;L&#x27;</span>, ChronoField.MONTH_OF_YEAR);             <span class="comment">// SDF, LDML (stand-alone)</span></span><br><span class="line"><span class="comment">//一年里面的天，我们基本不用这个作为日子</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;D&#x27;</span>, ChronoField.DAY_OF_YEAR);               <span class="comment">// SDF, LDML</span></span><br><span class="line"><span class="comment">//一个月里面的天，我们常用这个获取多少号</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;d&#x27;</span>, ChronoField.DAY_OF_MONTH);              <span class="comment">// SDF, LDML</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;F&#x27;</span>, ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH);  <span class="comment">// SDF, LDML</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;E&#x27;</span>, ChronoField.DAY_OF_WEEK);               <span class="comment">// SDF, LDML (different to both for 1/2 chars)</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;c&#x27;</span>, ChronoField.DAY_OF_WEEK);               <span class="comment">// LDML (stand-alone)</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;e&#x27;</span>, ChronoField.DAY_OF_WEEK);               <span class="comment">// LDML (needs localized week number)</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;a&#x27;</span>, ChronoField.AMPM_OF_DAY);               <span class="comment">// SDF, LDML</span></span><br><span class="line"><span class="comment">//一天里面的小时，常用的小时 HH</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;H&#x27;</span>, ChronoField.HOUR_OF_DAY);               <span class="comment">// SDF, LDML</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;k&#x27;</span>, ChronoField.CLOCK_HOUR_OF_DAY);         <span class="comment">// SDF, LDML</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;K&#x27;</span>, ChronoField.HOUR_OF_AMPM);              <span class="comment">// SDF, LDML</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;h&#x27;</span>, ChronoField.CLOCK_HOUR_OF_AMPM);        <span class="comment">// SDF, LDML</span></span><br><span class="line"><span class="comment">//一个小时里面的分钟，常用的分钟 mm</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;m&#x27;</span>, ChronoField.MINUTE_OF_HOUR);            <span class="comment">// SDF, LDML</span></span><br><span class="line"><span class="comment">//一分钟里面的秒数，常用的秒数 ss</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;s&#x27;</span>, ChronoField.SECOND_OF_MINUTE);          <span class="comment">// SDF, LDML</span></span><br><span class="line"><span class="comment">//这个大S基本不用，这是秒里面的纳秒</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;S&#x27;</span>, ChronoField.NANO_OF_SECOND);            <span class="comment">// LDML (SDF uses milli-of-second number)</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;A&#x27;</span>, ChronoField.MILLI_OF_DAY);              <span class="comment">// LDML</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;n&#x27;</span>, ChronoField.NANO_OF_SECOND);            <span class="comment">// 310 (proposed for LDML)</span></span><br><span class="line">FIELD_MAP.put(<span class="string">&#x27;N&#x27;</span>, ChronoField.NANO_OF_DAY);               <span class="comment">// 310 (proposed for LDML)</span></span><br></pre></td></tr></table></figure>

<p>继续深入，直接解析y的方法<code>parseField</code>。可以看到这个是根据我们格式化的字母执行不同的代码，比如u,y都执行到一个代码块。4个y走到了<code>appendValue</code>方法里面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseField</span><span class="params">(<span class="type">char</span> cur, <span class="type">int</span> count, TemporalField field)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">standalone</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">switch</span> (cur) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">            <span class="comment">//判断数量</span></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">//yy走这里</span></span><br><span class="line">                appendValueReduced(field, <span class="number">2</span>, <span class="number">2</span>, ReducedPrinterParser.BASE_DATE);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &lt; <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="comment">//y or yyy走这里</span></span><br><span class="line">                appendValue(field, count, <span class="number">19</span>, SignStyle.NORMAL);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// yyyy走这里 field = YEAR_OF_ERA count = 4</span></span><br><span class="line">                appendValue(field, count, <span class="number">19</span>, SignStyle.EXCEEDS_PAD);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid pattern \&quot;cc\&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*fallthrough*/</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">            standalone = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">/*fallthrough*/</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            <span class="keyword">switch</span> (count) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="comment">//两个MM输出月份走到这里</span></span><br><span class="line">                    <span class="keyword">if</span> (cur == <span class="string">&#x27;c&#x27;</span> || cur == <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">                        appendInternal(<span class="keyword">new</span> <span class="title class_">WeekBasedFieldPrinterParser</span>(cur, count));</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">                        appendText(field, TextStyle.SHORT);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                            appendValue(field);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//经过判断走到这里</span></span><br><span class="line">                            appendValue(field, <span class="number">2</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    appendText(field, standalone ? TextStyle.SHORT_STANDALONE : TextStyle.SHORT);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    appendText(field, standalone ? TextStyle.FULL_STANDALONE : TextStyle.FULL);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                    appendText(field, standalone ? TextStyle.NARROW_STANDALONE : TextStyle.NARROW);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                appendText(field, TextStyle.SHORT);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:</span><br><span class="line">            <span class="keyword">switch</span> (count) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    appendText(field, TextStyle.SHORT);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    appendText(field, TextStyle.FULL);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                    appendText(field, TextStyle.NARROW);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">            appendFraction(NANO_OF_SECOND, count, count, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                appendValue(field);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;K&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                appendValue(field);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">//可以看到dd HH mm ss也是走到这里，最终也是通过NumberPrinterParser这个对象来格式化</span></span><br><span class="line">                appendValue(field, count);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                appendValue(field);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">                appendValue(field, count);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Too many pattern letters: &quot;</span> + cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                appendValue(field);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                appendValue(field, count);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下<code>appendValue</code>方法。field &#x3D; YEAR_OF_ERA,minWidth &#x3D; 4, maxWidth &#x3D; 19, signStyle &#x3D; SignStyle.EXCEEDS_PAD。前面是一些判断，重点是创建了一个<code>NumberPrinterParser</code>的对象。最后转换的时候其实就是通过这个对象来转换的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title function_">appendValue</span><span class="params">(</span></span><br><span class="line"><span class="params">    TemporalField field, <span class="type">int</span> minWidth, <span class="type">int</span> maxWidth, SignStyle signStyle)</span> &#123;</span><br><span class="line">    <span class="comment">//这里不执行 忽略</span></span><br><span class="line">    <span class="keyword">if</span> (minWidth == maxWidth &amp;&amp; signStyle == SignStyle.NOT_NEGATIVE) &#123;</span><br><span class="line">        <span class="keyword">return</span> appendValue(field, maxWidth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    Objects.requireNonNull(field, <span class="string">&quot;field&quot;</span>);</span><br><span class="line">    Objects.requireNonNull(signStyle, <span class="string">&quot;signStyle&quot;</span>);</span><br><span class="line">    <span class="comment">//一些校验规则</span></span><br><span class="line">    <span class="keyword">if</span> (minWidth &lt; <span class="number">1</span> || minWidth &gt; <span class="number">19</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;The minimum width must be from 1 to 19 inclusive but was &quot;</span> + minWidth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxWidth &lt; <span class="number">1</span> || maxWidth &gt; <span class="number">19</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;The maximum width must be from 1 to 19 inclusive but was &quot;</span> + maxWidth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxWidth &lt; minWidth) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;The maximum width must exceed or equal the minimum width but &quot;</span> +</span><br><span class="line">                maxWidth + <span class="string">&quot; &lt; &quot;</span> + minWidth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重点是这里，创建了一个 NumberPrinterParser的对象，把参数传进去了。</span></span><br><span class="line">    <span class="type">NumberPrinterParser</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberPrinterParser</span>(field, minWidth, maxWidth, signStyle);</span><br><span class="line">    appendValue(pp);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下<code>NumberPrinterParser</code>类。还记得最开始格式化的时候那一段代码<code>printerParser.format(context, (StringBuilder) appendable);</code>吗，实际调用的就是这里。？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//构造方法赋值</span></span><br><span class="line">NumberPrinterParser(TemporalField field, <span class="type">int</span> minWidth, <span class="type">int</span> maxWidth, SignStyle signStyle) &#123;</span><br><span class="line">    <span class="comment">// validated by caller</span></span><br><span class="line">    <span class="built_in">this</span>.field = field;</span><br><span class="line">    <span class="built_in">this</span>.minWidth = minWidth;</span><br><span class="line">    <span class="built_in">this</span>.maxWidth = maxWidth;</span><br><span class="line">    <span class="built_in">this</span>.signStyle = signStyle;</span><br><span class="line">    <span class="built_in">this</span>.subsequentWidth = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//格式化方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">format</span><span class="params">(DateTimePrintContext context, StringBuilder buf)</span> &#123;</span><br><span class="line">    <span class="comment">//从context上下文中获取字段 field = YEAR_OF_ERA  context实际包含了真正的时间 2022-12-01T00:00:00</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">valueLong</span> <span class="operator">=</span> context.getValue(field);</span><br><span class="line">    <span class="keyword">if</span> (valueLong == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取到以后 value = 2022</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> getValue(context, valueLong);</span><br><span class="line">    <span class="type">DecimalStyle</span> <span class="variable">decimalStyle</span> <span class="operator">=</span> context.getDecimalStyle();</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (value == Long.MIN_VALUE ? <span class="string">&quot;9223372036854775808&quot;</span> : Long.toString(Math.abs(value)));</span><br><span class="line">    <span class="keyword">if</span> (str.length() &gt; maxWidth) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DateTimeException</span>(<span class="string">&quot;Field &quot;</span> + field +</span><br><span class="line">            <span class="string">&quot; cannot be printed as the value &quot;</span> + value +</span><br><span class="line">            <span class="string">&quot; exceeds the maximum print width of &quot;</span> + maxWidth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转换一个格式类型</span></span><br><span class="line">    str = decimalStyle.convertNumberToI18N(str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这些条件都不满足，忽略</span></span><br><span class="line">    <span class="keyword">if</span> (value &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (signStyle) &#123;</span><br><span class="line">            <span class="keyword">case</span> EXCEEDS_PAD:</span><br><span class="line">                <span class="keyword">if</span> (minWidth &lt; <span class="number">19</span> &amp;&amp; value &gt;= EXCEED_POINTS[minWidth]) &#123;</span><br><span class="line">                    buf.append(decimalStyle.getPositiveSign());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ALWAYS:</span><br><span class="line">                buf.append(decimalStyle.getPositiveSign());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (signStyle) &#123;</span><br><span class="line">            <span class="keyword">case</span> NORMAL:</span><br><span class="line">            <span class="keyword">case</span> EXCEEDS_PAD:</span><br><span class="line">            <span class="keyword">case</span> ALWAYS:</span><br><span class="line">                buf.append(decimalStyle.getNegativeSign());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NOT_NEGATIVE:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DateTimeException</span>(<span class="string">&quot;Field &quot;</span> + field +</span><br><span class="line">                    <span class="string">&quot; cannot be printed as the value &quot;</span> + value +</span><br><span class="line">                    <span class="string">&quot; cannot be negative according to the SignStyle&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//填充0 也就是yyyy minWidth = 4就会填充0 MM minWidth = 2如果 1月就会填充01，一个M就不会走到循环填充0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; minWidth - str.length(); i++) &#123;</span><br><span class="line">        buf.append(decimalStyle.getZeroDigit());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出到buf中</span></span><br><span class="line">    buf.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上面的代码，但是<code>NumberPrinterParser</code>其实只是解析了<code>yMdHms</code>这些格式的。也可以再看一下<code>M</code>的确认一下。</p>
<p>首先是<code>appendValue</code>这个方法。大差不差，除了传到解析器的参数不一样，没啥区别，其实dd这些也都一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title function_">appendValue</span><span class="params">(TemporalField field, <span class="type">int</span> width)</span> &#123;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    Objects.requireNonNull(field, <span class="string">&quot;field&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (width &lt; <span class="number">1</span> || width &gt; <span class="number">19</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;The width must be from 1 to 19 inclusive but was &quot;</span> + width);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以发现MM也是用的yyyy这个解析器格式化的，但是后面三个参数不一样</span></span><br><span class="line">    <span class="type">NumberPrinterParser</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberPrinterParser</span>(field, width, width, SignStyle.NOT_NEGATIVE);</span><br><span class="line">    appendValue(pp);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们<code>-</code>,<code>:</code>这些格式化符号的输出呢？是通过另外一个解析器，它先是取到<code>char</code>类型的一个字符来判断的时候会走到else里面然后走<code>appendLiteral(cur);</code>这个方法。看一下这个方法里面。这里可以看到主要使用的是 CharLiteralPrinterParser 这个解析器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title function_">appendLiteral</span><span class="params">(<span class="type">char</span> literal)</span> &#123;</span><br><span class="line">    <span class="comment">//这里可以看到主要使用的是 CharLiteralPrinterParser 这个解析器</span></span><br><span class="line">    appendInternal(<span class="keyword">new</span> <span class="title class_">CharLiteralPrinterParser</span>(literal));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下 CharLiteralPrinterParser 这个解析器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">CharLiteralPrinterParser(<span class="type">char</span> literal) &#123;</span><br><span class="line">    <span class="built_in">this</span>.literal = literal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">format</span><span class="params">(DateTimePrintContext context, StringBuilder buf)</span> &#123;</span><br><span class="line">    <span class="comment">//简单粗暴 直接把 - : 这种符号添加到字符串里面</span></span><br><span class="line">    buf.append(literal);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看一下为啥我们刚才上面说的，y代表 YEAR_OF_ERA，为啥就能从<code>2022-12-01</code>里面取到<code>2022</code>呢？这个可以看到我们<code>NumberPrinterParser</code>这个解析器里面主要调用了一个<code>context.getValue(field)</code>方法。</p>
<p>主要是<code>temporal.getLong(field)</code>方法，其实temporal就是我们的日期时间，在我们一开始创建上下文的时候过来的。回忆一下上面的创建。这里的temporal可以再往上一层传过来的，传的其实就是<code>LocalDateTime的对象</code>。</p>
<blockquote>
<p>new DateTimePrintContext(temporal, this)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Long <span class="title function_">getValue</span><span class="params">(TemporalField field)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//主要是这里，其实temporal就是我们的日期时间，在我们一开始创建上下文的时候过来的。</span></span><br><span class="line">        <span class="keyword">return</span> temporal.getLong(field);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DateTimeException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (optional &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们再看一下<code>getLong</code>方法。可以看到有一个类型判断，<code>yMdHms</code>这几个类型就会走到if里面，如果是时间的 Hms这几个调用time.getLong方法，yMd日期的调用日期的getLong方法。Y的话就会走到 <code>getFrom</code> 这个方法。而且是通过<code>field</code>调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLong</span><span class="params">(TemporalField field)</span> &#123;</span><br><span class="line">    <span class="comment">//类型判断 yMdHms这几个走的这里面</span></span><br><span class="line">    <span class="keyword">if</span> (field <span class="keyword">instanceof</span> ChronoField) &#123;</span><br><span class="line">        <span class="type">ChronoField</span> <span class="variable">f</span> <span class="operator">=</span> (ChronoField) field;</span><br><span class="line">        <span class="comment">//如果是时间的 Hms这几个调用time.getLong方法，yMd日期的调用日期的getLong方法</span></span><br><span class="line">        <span class="keyword">return</span> (f.isTimeBased() ? time.getLong(field) : date.getLong(field));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Y走这个方法</span></span><br><span class="line">    <span class="keyword">return</span> field.getFrom(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下<code>getFrom</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getFrom</span><span class="params">(TemporalAccessor temporal)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rangeUnit == WEEKS) &#123;  <span class="comment">// day-of-week</span></span><br><span class="line">        <span class="keyword">return</span> localizedDayOfWeek(temporal);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rangeUnit == MONTHS) &#123;  <span class="comment">// week-of-month</span></span><br><span class="line">        <span class="keyword">return</span> localizedWeekOfMonth(temporal);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rangeUnit == YEARS) &#123;  <span class="comment">// week-of-year</span></span><br><span class="line">        <span class="keyword">return</span> localizedWeekOfYear(temporal);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rangeUnit == WEEK_BASED_YEARS) &#123;</span><br><span class="line">        <span class="keyword">return</span> localizedWeekOfWeekBasedYear(temporal);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rangeUnit == FOREVER) &#123;</span><br><span class="line">        <span class="comment">// YYYY 大写的Y走的是这里</span></span><br><span class="line">        <span class="keyword">return</span> localizedWeekBasedYear(temporal);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;unreachable, rangeUnit: &quot;</span> + rangeUnit + <span class="string">&quot;, this: &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果大写的<code>Y</code>格式化就会走下面的函数，主要就是取出年份以后计算周数，如果周数&#x3D;0就认为是上一年的，年份-1，如果周数大于等于下一年的周数就年份+1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">localizedWeekBasedYear</span><span class="params">(TemporalAccessor temporal)</span> &#123;</span><br><span class="line">    <span class="comment">//获取到这周的第几天 第5天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dow</span> <span class="operator">=</span> localizedDayOfWeek(temporal);</span><br><span class="line">    <span class="comment">//获取日期中的年份 2021</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> temporal.get(YEAR);</span><br><span class="line">    <span class="comment">//获取今年的第几天 2021-12-30 是 364天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">doy</span> <span class="operator">=</span> temporal.get(DAY_OF_YEAR);</span><br><span class="line">    <span class="comment">//这周开始的偏移量 5</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> startOfWeekOffset(doy, dow);</span><br><span class="line">    <span class="comment">//今年的第几周 53周</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">week</span> <span class="operator">=</span> computeWeek(offset, doy);</span><br><span class="line">    <span class="comment">//如果这周是0周，就是上一年的，年份就-1</span></span><br><span class="line">    <span class="keyword">if</span> (week == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Day is in end of week of previous year; return the previous year</span></span><br><span class="line">        <span class="keyword">return</span> year - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果接近年底，使用更高精度的逻辑</span></span><br><span class="line">        <span class="comment">//检查 如果年份的日期包含在下一年的部分的星期里面了</span></span><br><span class="line">        <span class="comment">// If getting close to end of year, use higher precision logic</span></span><br><span class="line">        <span class="comment">// Check if date of year is in partial week associated with next year</span></span><br><span class="line">        <span class="comment">//获取一年里面的天数 对象里面包含 最小1天 - 最大365天</span></span><br><span class="line">        <span class="type">ValueRange</span> <span class="variable">dayRange</span> <span class="operator">=</span> temporal.range(DAY_OF_YEAR);</span><br><span class="line">        <span class="comment">//获取到年份的长度，也就是365</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">yearLen</span> <span class="operator">=</span> (<span class="type">int</span>)dayRange.getMaximum();</span><br><span class="line">        <span class="comment">//下一年的周数 根据下面的计算公式得出 (7 + 5 + 366 - 1) / 7 = 53</span></span><br><span class="line">        <span class="comment">//这里为啥是366呢，因为yearLen是今年的天数也就是365 + 1，其实也就是到下一年去了。为的是计算下一年的第一周</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newYearWeek</span> <span class="operator">=</span> computeWeek(offset, yearLen + weekDef.getMinimalDaysInFirstWeek());</span><br><span class="line">        <span class="comment">//比较如果今年的这周大于等于下一年的周 就年份 +1 所以这里格式化就会出错了。</span></span><br><span class="line">        <span class="keyword">if</span> (week &gt;= newYearWeek) &#123;</span><br><span class="line">            <span class="keyword">return</span> year + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> year;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么是怎么计算今年的第几周的呢，看一下<code>computeWeek</code>方法。其实就是一个计算公式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//offset = 5 , day = 今年的第几天 364 天</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">computeWeek</span><span class="params">(<span class="type">int</span> offset, <span class="type">int</span> day)</span> &#123;</span><br><span class="line">    <span class="comment">//计算公式 ( 7 + 5 + （364 - 1）) / 7</span></span><br><span class="line">    <span class="keyword">return</span> ((<span class="number">7</span> + offset + (day - <span class="number">1</span>)) / <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个问题，就是我们用到了一个周的偏移量，这个偏移量怎么计算的呢，看一下这个方法<code>startOfWeekOffset</code>。以<code>2021-12-30</code>为例，day &#x3D; 364,dow &#x3D; 5</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">startOfWeekOffset</span><span class="params">(<span class="type">int</span> day, <span class="type">int</span> dow)</span> &#123;</span><br><span class="line">    <span class="comment">// offset of first day corresponding to the day of week in first 7 days (zero origin)</span></span><br><span class="line">    <span class="comment">//算出上一周 (364 - 5) % 7 = 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">weekStart</span> <span class="operator">=</span> Math.floorMod(day - dow, <span class="number">7</span>);</span><br><span class="line">    <span class="comment">// offset = -2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> -weekStart;</span><br><span class="line">    <span class="comment">//这里 2 + 1  &gt; 1会走进去</span></span><br><span class="line">    <span class="keyword">if</span> (weekStart + <span class="number">1</span> &gt; weekDef.getMinimalDaysInFirstWeek()) &#123;</span><br><span class="line">        <span class="comment">// The previous week has the minimum days in the current month to be a &#x27;week&#x27;</span></span><br><span class="line">        <span class="comment">//这里 7 - 2 = 5 返回的就是5</span></span><br><span class="line">        offset = <span class="number">7</span> - weekStart;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面看完了大写的<code>Y</code>，再来看一下小写的<code>y</code>。走的<code>getLong</code>方法。</p>
<p>日期的<code>getLong</code>方法。经过判断后主要看<code>get0</code>这个方法。可以看到这个命名就很随意了。。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLong</span><span class="params">(TemporalField field)</span> &#123;</span><br><span class="line">    <span class="comment">//这个判断也会走进来</span></span><br><span class="line">    <span class="keyword">if</span> (field <span class="keyword">instanceof</span> ChronoField) &#123;</span><br><span class="line">        <span class="comment">//这两个判断忽略</span></span><br><span class="line">        <span class="keyword">if</span> (field == EPOCH_DAY) &#123;</span><br><span class="line">            <span class="keyword">return</span> toEpochDay();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (field == PROLEPTIC_MONTH) &#123;</span><br><span class="line">            <span class="keyword">return</span> getProlepticMonth();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这里</span></span><br><span class="line">        <span class="keyword">return</span> get0(field);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> field.getFrom(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下日期的<code>get0</code>方法。可以发现了，这里主要处理了这几种类型。我们常用的</p>
<ul>
<li>y也就是YEAR_OF_ERA 处理很简单，判断了一下year &gt;&#x3D; 1就返回 year。</li>
<li>M也就是MONTH_OF_YEAR 处理很简单，返回日期的month.</li>
<li>d也就是DAY_OF_MONTH 返回日期的day.</li>
</ul>
<p>从这里也可以看出我们格式化成<code>YEAR</code>和<code>ERA</code>作为年其实也是可以的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">get0</span><span class="params">(TemporalField field)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> ((ChronoField) field) &#123;</span><br><span class="line">        <span class="keyword">case</span> DAY_OF_WEEK: <span class="keyword">return</span> getDayOfWeek().getValue();</span><br><span class="line">        <span class="keyword">case</span> ALIGNED_DAY_OF_WEEK_IN_MONTH: <span class="keyword">return</span> ((day - <span class="number">1</span>) % <span class="number">7</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> ALIGNED_DAY_OF_WEEK_IN_YEAR: <span class="keyword">return</span> ((getDayOfYear() - <span class="number">1</span>) % <span class="number">7</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> DAY_OF_MONTH: <span class="keyword">return</span> day;</span><br><span class="line">        <span class="keyword">case</span> DAY_OF_YEAR: <span class="keyword">return</span> getDayOfYear();</span><br><span class="line">        <span class="keyword">case</span> EPOCH_DAY: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedTemporalTypeException</span>(<span class="string">&quot;Invalid field &#x27;EpochDay&#x27; for get() method, use getLong() instead&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> ALIGNED_WEEK_OF_MONTH: <span class="keyword">return</span> ((day - <span class="number">1</span>) / <span class="number">7</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> ALIGNED_WEEK_OF_YEAR: <span class="keyword">return</span> ((getDayOfYear() - <span class="number">1</span>) / <span class="number">7</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> MONTH_OF_YEAR: <span class="keyword">return</span> month;</span><br><span class="line">        <span class="keyword">case</span> PROLEPTIC_MONTH: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedTemporalTypeException</span>(<span class="string">&quot;Invalid field &#x27;ProlepticMonth&#x27; for get() method, use getLong() instead&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> YEAR_OF_ERA: <span class="keyword">return</span> (year &gt;= <span class="number">1</span> ? year : <span class="number">1</span> - year);</span><br><span class="line">        <span class="keyword">case</span> YEAR: <span class="keyword">return</span> year;</span><br><span class="line">        <span class="keyword">case</span> ERA: <span class="keyword">return</span> (year &gt;= <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedTemporalTypeException</span>(<span class="string">&quot;Unsupported field: &quot;</span> + field);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完了日期的处理再看一下时间的吧，其实大同小异了。</p>
<p>时间的<code>getLong</code>方法。同样的经过判断走到<code>get0</code>里面，注意这是时间的<code>getLong</code>和<code>get0</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLong</span><span class="params">(TemporalField field)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (field <span class="keyword">instanceof</span> ChronoField) &#123;</span><br><span class="line">        <span class="keyword">if</span> (field == NANO_OF_DAY) &#123;</span><br><span class="line">            <span class="keyword">return</span> toNanoOfDay();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (field == MICRO_OF_DAY) &#123;</span><br><span class="line">            <span class="keyword">return</span> toNanoOfDay() / <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> get0(field);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> field.getFrom(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间的<code>get0</code>方法。处理的就是这些类型了。主要看我们关注的几个</p>
<ul>
<li>H 也就是 HOUR_OF_DAY, 直接返回时间的 hour</li>
<li>m 也就是MINUTE_OF_HOUR，直接返回时间的 minute</li>
<li>s 也就是 SECOND_OF_MINUTE, 直接返回时间的 second</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">get0</span><span class="params">(TemporalField field)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> ((ChronoField) field) &#123;</span><br><span class="line">        <span class="keyword">case</span> NANO_OF_SECOND: <span class="keyword">return</span> nano;</span><br><span class="line">        <span class="keyword">case</span> NANO_OF_DAY: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedTemporalTypeException</span>(<span class="string">&quot;Invalid field &#x27;NanoOfDay&#x27; for get() method, use getLong() instead&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> MICRO_OF_SECOND: <span class="keyword">return</span> nano / <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">case</span> MICRO_OF_DAY: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedTemporalTypeException</span>(<span class="string">&quot;Invalid field &#x27;MicroOfDay&#x27; for get() method, use getLong() instead&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> MILLI_OF_SECOND: <span class="keyword">return</span> nano / <span class="number">1000_000</span>;</span><br><span class="line">        <span class="keyword">case</span> MILLI_OF_DAY: <span class="keyword">return</span> (<span class="type">int</span>) (toNanoOfDay() / <span class="number">1000_000</span>);</span><br><span class="line">        <span class="keyword">case</span> SECOND_OF_MINUTE: <span class="keyword">return</span> second;</span><br><span class="line">        <span class="keyword">case</span> SECOND_OF_DAY: <span class="keyword">return</span> toSecondOfDay();</span><br><span class="line">        <span class="keyword">case</span> MINUTE_OF_HOUR: <span class="keyword">return</span> minute;</span><br><span class="line">        <span class="keyword">case</span> MINUTE_OF_DAY: <span class="keyword">return</span> hour * <span class="number">60</span> + minute;</span><br><span class="line">        <span class="keyword">case</span> HOUR_OF_AMPM: <span class="keyword">return</span> hour % <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">case</span> CLOCK_HOUR_OF_AMPM: <span class="type">int</span> <span class="variable">ham</span> <span class="operator">=</span> hour % <span class="number">12</span>; <span class="keyword">return</span> (ham % <span class="number">12</span> == <span class="number">0</span> ? <span class="number">12</span> : ham);</span><br><span class="line">        <span class="keyword">case</span> HOUR_OF_DAY: <span class="keyword">return</span> hour;</span><br><span class="line">        <span class="keyword">case</span> CLOCK_HOUR_OF_DAY: <span class="keyword">return</span> (hour == <span class="number">0</span> ? <span class="number">24</span> : hour);</span><br><span class="line">        <span class="keyword">case</span> AMPM_OF_DAY: <span class="keyword">return</span> hour / <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedTemporalTypeException</span>(<span class="string">&quot;Unsupported field: &quot;</span> + field);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，到这里我们知道了时间格式的各种使用方法和格式化的源码。</p>
<p>对于不同格式化的区别。总结一下。</p>
<ul>
<li><code>y</code> 处理简单，只是判断了year &gt; 1 就返回了year。</li>
<li><code>Y</code> 处理较复杂，还判断了周，根据情况对年份+1和-1。某些年份的某些日期会有坑。<strong>一定要注意！！！</strong></li>
<li><code>Md Hms</code>处理非常简单，直接返回了日期时间上面对应的数。</li>
<li><code>-: </code>一些特殊字符，格式化的时候是直接增加到字符串里面的。</li>
</ul>
<p>下面总结一下源码对应文件和方法的追踪链。感兴趣的可以自己在多翻翻源码。</p>
<p>ofPattern指定格式的调用链</p>
<ul>
<li>DateTimeFormatter.java -&gt; public static DateTimeFormatter ofPattern(String pattern)<ul>
<li>DateTimeFormatterBuilder.java -&gt; public DateTimeFormatterBuilder appendPattern(String pattern)</li>
<li>DateTimeFormatterBuilder.java -&gt; private void parsePattern(String pattern)</li>
<li>DateTimeFormatterBuilder.java -&gt; private void parseField(char cur, int count, TemporalField field)</li>
<li>DateTimeFormatterBuilder.java -&gt; public DateTimeFormatterBuilder appendValue(TemporalField field, int width)</li>
<li>在这里创建的解析器</li>
<li>DateTimeFormatterBuilder.java -&gt; <code>static class NumberPrinterParser implements DateTimePrinterParser</code></li>
<li>DateTimeFormatterBuilder.java -&gt; <code>static final class CharLiteralPrinterParser implements DateTimePrinterParser</code></li>
</ul>
</li>
</ul>
<p>format方法调用链</p>
<ul>
<li>LocalDateTime.java -&gt; public String format(DateTimeFormatter formatter)<ul>
<li>DateTimeFormatter.java -&gt; public String format(TemporalAccessor temporal)</li>
<li>DateTimeFormatter.java -&gt; public void formatTo(TemporalAccessor temporal, Appendable appendable)<ul>
<li>接下来根据不同的处理解析器进行处理，主要有两个解析器</li>
<li>DateTimeFormatterBuilder.java -&gt; <code>static class NumberPrinterParser implements DateTimePrinterParser</code></li>
<li>DateTimeFormatterBuilder.java -&gt; <code>static final class CharLiteralPrinterParser implements DateTimePrinterParser</code><ul>
<li>DateTimePrintContext.java -&gt; Long getValue(TemporalField field)<ul>
<li>LocalDateTime.java -&gt; public long getLong(TemporalField field)<ul>
<li>这里日期调日期的 LocalDate.java -&gt; public long getLong(TemporalField field)</li>
<li>LocalDate.java -&gt; private int get0(TemporalField field) </li>
<li>时间调时间的 LocalTime.java -&gt; public long getLong(TemporalField field)</li>
<li>LocalTime.java -&gt; private int get0(TemporalField field)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>LocalDateTime</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-spring-AOP</title>
    <url>/JAVA-spring-AOP.html</url>
    <content><![CDATA[<h1 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h1><h2 id="AOP切面"><a href="#AOP切面" class="headerlink" title="AOP切面"></a>AOP切面</h2>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-spring-IOC</title>
    <url>/JAVA-spring-IOC.html</url>
    <content><![CDATA[<h1 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h1><h2 id="IOC控制反转"><a href="#IOC控制反转" class="headerlink" title="IOC控制反转"></a>IOC控制反转</h2><p>这里先说一下<code>IOC</code>，再说<code>IOC</code>在<code>spring</code>框架中的使用。</p>
<h3 id="IOC的概念"><a href="#IOC的概念" class="headerlink" title="IOC的概念"></a>IOC的概念</h3><p><code>IOC</code>这个缩写有很多意思，比如</p>
<ul>
<li>智慧城市智能运行中心(IOC)</li>
<li>奥林匹克运动的领导机构</li>
</ul>
<p>但是呢，我们这里说的是<code>面向对象编程中的一种设计原则</code>。他的全称是<code>Inversion Of Control</code>即控制反转。这里有两个单词<code>控制</code>和<code>反转</code>。这两个单词单独拿出来会发现，都缺少主语。比如</p>
<ul>
<li>谁控制了谁?</li>
<li>什么东西发生反转了呢?</li>
</ul>
<h4 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h4><p>这里说一下第一个问题，谁控制了谁呢？看下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.setName(<span class="string">&quot;tony&quot;</span>);</span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>很显然，在这里，Person类的person对象的一切都控制在main函数里面。main函数创建它，使用它，销毁它。所以在当前上下文中，main控制了person。</p>
<h4 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h4><p>上面的写法main函数控制了person对象，这是一种紧耦合的关系，如果person发生了改变，我们就需要改变main。<code>反转</code>是控制权的反转。现在person的控制权在main这里，我们将它反转一下。不在用main控制它。那么我们加一个简单工厂看一下呢。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title function_">createPerson</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> Factory.createPerson();</span><br><span class="line">    person.setName(<span class="string">&quot;tony&quot;</span>);</span><br><span class="line">    System.out.println(person.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里可以看到person的控制权转交给了<code>Factory</code>工厂，而main只有使用权了。当然了作为示例代码，这里的控制只做了创建。</p>
<p>现在，由main控制person改为了Factory控制person。如果person发生了改变，我们只需要改变Factory，而不需要动业务逻辑。</p>
<p>当然了，这种程度的解耦依然不够，因为main还是和Factory有耦合关系，他还控制了Factory。我们可以扩大这个简单工厂，扩大后的简单工厂就不再是工厂了，而叫做<code>容器</code>。我们把所有的控制权都交给容器，让容器控制所有的类，对象。而在使用的时候我们去告诉容器我们要使用哪个对象，让容器给我们提供就可以了。</p>
<h4 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h4><p><code>依赖注入 DI</code>全称<code>Dependency Injection</code>就可以实现我们告诉容器我们需要的对象，然后容器把对象注入给我们的功能。</p>
<p>具体的依赖注入实现方式每个语言，每个框架可能都不一样，这里以spring为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        person.setName(<span class="string">&quot;tony&quot;</span>);</span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，我们通过<code>@Autowired</code>注解告诉容器，我们需要一个Person类型的对象，然后让容器把这个对象注入到我们的person属性中。这里仅做示例使用，具体情况请以实际开发中为准，实际开发中应使用接口类型。</p>
<p>容器中的实现方式就类似刚才工厂中的，假设你需要Person类型的对象，就<code>new Person</code>返回，当然了，要更加复杂，比如可以根据名称来反射创建对象，可以更好的管理对象的生命周期，可以实现单例对象等等。</p>
<h2 id="spring中的IOC"><a href="#spring中的IOC" class="headerlink" title="spring中的IOC"></a>spring中的IOC</h2><p><code>Spring</code>中的IOC实现也是通过容器，但是怎么把类注入到容器中呢，也就是怎么告诉容器，你需要实例化哪些类呢？有两种方式，一种是<code>XML配置方式</code>，一种是<code>注解方式</code>。</p>
<h3 id="XML配置方式"><a href="#XML配置方式" class="headerlink" title="XML配置方式"></a>XML配置方式</h3><p>先创建一个XML文件，比如:</p>
<blockquote>
<p>touch bean.xml</p>
</blockquote>
<p>接下来编辑它。</p>
<blockquote>
<p>vim bean.xml</p>
</blockquote>
<h4 id="无参数构造方式"><a href="#无参数构造方式" class="headerlink" title="无参数构造方式"></a>无参数构造方式</h4><p>重点在这个配置，通过<code>bean</code>这个标签来告诉容器我要把哪些类注册到容器中，其中id就是注册后的唯一标识，我们获取的时候也可以通过指定id来从容器中获取对象。而<code>class</code>是告诉容器，我们具体要注入的类的路径。但是这时候没有指定参数，也就是说类似于<code>Person person = new Person()</code>这样的注册，需要有无参构造器。</p>
<blockquote>
<p> <bean id="person" class="com.test.java.Person"></bean></p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.java.Person&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用的时候需要借助于<code>Spring</code>提供的容器获取,可以看一下效果是一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//这里先加载我们的XML配置文件</span></span><br><span class="line">        <span class="type">BeanFactory</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//通过容器获取一个对象,第一个参数也就是配置的id,第二个就是类</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line">        person.setName(<span class="string">&quot;tony&quot;</span>);</span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="构造器构造参数方式"><a href="#构造器构造参数方式" class="headerlink" title="构造器构造参数方式"></a>构造器构造参数方式</h4><p>同样在上面的XML文件中进行修改，但这次我们需要加上参数，并且告诉容器是通过构造器来构造参数的，而不是<code>set</code>的方式。</p>
<p>我们只需要在原来的<code>bean</code>标签中，加入我们要传给构造器的参数就可以了。</p>
<p>使用<code>constructor-arg</code>标签，<code>name</code>就是参数名，<code>value</code>是对应的值。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.java.Person&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tony&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们还需要改造一下原来的<code>Person</code>类，增加一个构造函数.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看一下现在的main函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//这里先加载我们的XML配置文件</span></span><br><span class="line">        <span class="type">BeanFactory</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//通过容器获取一个对象,第一个参数也就是配置的id,第二个就是类</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line">        <span class="comment">// 这里不需要setName了，因为通过构造器注入参数了</span></span><br><span class="line">        <span class="comment">// person.setName(&quot;tony&quot;);</span></span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是如果我们需要构造一个其他类的对象作为参数该怎么配置呢，毕竟我们总不能在<code>value</code>上面写<code>new Class()</code>吧哈哈。但是我们知道一个<code>bean</code>就是一个对象，那我们可以传一个<code>bean</code>进来就可以了。</p>
<p>来看一下配置方式.不再使用<code>value</code>了，因为<code>value</code>只能传基本类型这些，而其他的对象需要使用<code>ref</code>来传参。<code>ref</code>的值就是其他<code>bean</code>的<code>id</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;avatar&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.java.Avatar&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;http://baidu.com&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.java.Person&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tony&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;avatar&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;avatar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同样需要改造一下构造函数，增加一个<code>avatar</code>参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Avatar</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Avatar</span><span class="params">(String url)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Avatar avatar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, Avatar avatar)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.avatar = avatar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAvatar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.avatar.url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行一下<code>main</code>函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//这里先加载我们的XML配置文件</span></span><br><span class="line">        <span class="type">BeanFactory</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//通过容器获取一个对象,第一个参数也就是配置的id,第二个就是类</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line">        <span class="comment">// 这里不需要setName了，因为通过构造器注入参数了</span></span><br><span class="line">        <span class="comment">// person.setName(&quot;tony&quot;);</span></span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line">        System.out.println(person.getAvatar());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="set方式传参"><a href="#set方式传参" class="headerlink" title="set方式传参"></a>set方式传参</h4><p>除了通过构造器传参，我们还可以写<code>set</code>函数来传参，比如<code>setName</code>和<code>setAvatar</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Avatar</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="comment">// public Avatar(String url) &#123;</span></span><br><span class="line">    <span class="comment">//     this.url = url;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加set函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUrl</span><span class="params">(String url)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Avatar avatar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// public Person(String name, Avatar avatar) &#123;</span></span><br><span class="line">    <span class="comment">//     this.name = name;</span></span><br><span class="line">    <span class="comment">//     this.avatar = avatar;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAvatar</span><span class="params">(Avatar avatar)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.avatar = avatar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAvatar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.avatar.url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改XML配置文件，不在使用<code>constructor-arg</code>标签，而是换成<code>property</code>。不过除了标签名变了，其他的属性<code>name</code>,<code>value</code>,<code>ref</code>都是不变的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;avatar&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.java.Avatar&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;http://baidu.com&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.java.Person&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tony&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;avatar&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;avatar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行一下<code>main</code>函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//这里先加载我们的XML配置文件</span></span><br><span class="line">        <span class="type">BeanFactory</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//通过容器获取一个对象,第一个参数也就是配置的id,第二个就是类</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line">        <span class="comment">// 这里不需要setName了，因为通过构造器注入参数了</span></span><br><span class="line">        <span class="comment">// person.setName(&quot;tony&quot;);</span></span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line">        System.out.println(person.getAvatar());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自动注入"><a href="#自动注入" class="headerlink" title="自动注入"></a>自动注入</h4><p>可以通过配置XML文件来使用自动注入，就不需要手动增加<code>&lt;property name=&quot;url&quot; ref=&quot;avatar&quot;&gt;&lt;/property&gt;</code>或<code>&lt;constructor-arg name=&quot;avatar&quot; ref=&quot;avatar&quot;&gt;&lt;/constructor-arg&gt;</code>的标签了，只需要配置一个属性<code>autowire</code>就可以了。但是这种的只适用于注入其他的<code>bean</code>。</p>
<p><code>autowire</code>只有两个值，一个是<code>byName</code>，是通过bean的名称进行注入，比如你的属性名是<code>avatar</code>，就会查找<code>id=avatar</code>这个类。还有一个是<code>byType</code>，是通过bean的类型进行注入，比如类型是<code>Avatar</code>，那么就会查找<code>class=Avatar</code>的bean进行注入。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;avatar&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.java.Avatar&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;http://baidu.com&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.java.Person&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tony&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- &lt;property name=&quot;avatar&quot; ref=&quot;avatar&quot;&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="XML读取外部配置文件"><a href="#XML读取外部配置文件" class="headerlink" title="XML读取外部配置文件"></a>XML读取外部配置文件</h4><p>通过XML可以读取外部的配置文件，这样的话像数据库，redis连接这些就可以把<code>host</code>,<code>name</code>,<code>password</code>这些写到外部的配置文件中。</p>
<p>配置文件使用<code>.properties</code>后缀。比如<code>spring.properties</code>。</p>
<p>增加一个配置文件<code>spring.properties</code>。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.person.name</span>=<span class="string">tony</span></span><br></pre></td></tr></table></figure>

<p>修改XML直接从配置中读取<code>person.name</code>来注入。读取的时候还需要在XML中增加<code>context</code>命名空间。并通过context命名空间来读取配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 增加context命名空间 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context http://www.springframework.org/schema/beans/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 读取配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:spring.properties&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;avatar&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.java.Avatar&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;http://baidu.com&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.java.Person&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 读取配置文件的值 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;spring.person.name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- &lt;property name=&quot;avatar&quot; ref=&quot;avatar&quot;&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><p>注解方式要比<code>XML</code>方式简单的多，其中原理就是不再手动配置，而是通过注解告诉<code>Spring</code>我是一个<code>bean</code>。快来注册我吧。</p>
<p>主要是这4个注解告诉<code>Spring</code></p>
<ul>
<li>@Component 单纯的说我是一个<code>bean</code></li>
<li>@Service 和上面的一样，不过一般用在service类中，更加语义化</li>
<li>@Controller 和上面的一样，一般用在controller类中</li>
<li>@Repository 我也是一个<code>bean</code></li>
</ul>
<p>接下来我们告诉<code>Spring</code>，你需要扫描出所有带上面注解的类，把他们注册到容器中。这一步需要修改XML文件,需要配置<code>&lt;context:component-scan&gt;</code>标签，并且通过<code>base-package</code>属性告诉<code>Spring</code>我们要扫描哪个目录</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.test.java&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在类上面增加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Avatar</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="comment">// public Avatar(String url) &#123;</span></span><br><span class="line">    <span class="comment">//     this.url = url;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加set函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUrl</span><span class="params">(String url)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Avatar avatar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// public Person(String name, Avatar avatar) &#123;</span></span><br><span class="line">    <span class="comment">//     this.name = name;</span></span><br><span class="line">    <span class="comment">//     this.avatar = avatar;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAvatar</span><span class="params">(Avatar avatar)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.avatar = avatar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAvatar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.avatar.url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还可以自己指定扫描哪些注解，通过<code>context:include-filter</code>标签来指定。<code>type</code>类型写注解，<code>expression</code>指定扫描哪个注解。把标签放在<code>context:component-scan</code>这个里面就可以了。还需要在<code>context:component-scan</code>标签中指定，禁用默认的扫描方式。指定<code>use-default-filters</code>的属性为false.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.test.java&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Component&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还可以排除一些注解不进行扫描，通过<code>context:exclude-filter</code>标签来指定。<code>type</code>同样写注解，<code>expression</code>指定排除的注解。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.test.java&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Component&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>把类注册到容器中以后，我们还需要在使用的时候告诉容器，我们需要从容器中获取这个类，有5个注解</p>
<ul>
<li>@Autowired  Spring提供的，基于类型注入的，可以放在setter方法上</li>
<li>@Qualifier  Spring提供的，基于名称注入的，一般和@Autowired配合使用来通过value参数指定名称</li>
<li>@Resource   Java提供的，可以基于类型或名称注入的,可以通过name参数来指定名称，可以放在setter方法上</li>
<li>@RequiredArgsConstructor  lombok提供的，基于类型注入，通过增加一个构造函数来注入。</li>
<li>@Value      Spring提供的，注入基本类型的注解，一般用来从配置文件取值。</li>
</ul>
<p><code>@RequiredArgsConstructor</code>是lombok提供的，兼容性较差，像写单元测试的时候就用不了，它会给你的类增加一个构造方法，而且只会给<code>final</code>类型的属性进行注入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//增加注解</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误使用，因为没有final</span></span><br><span class="line">    <span class="comment">// private Avatar avatar;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//正确使用，加上final</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Avatar avatar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// public Person(String name, Avatar avatar) &#123;</span></span><br><span class="line">    <span class="comment">//     this.name = name;</span></span><br><span class="line">    <span class="comment">//     this.avatar = avatar;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAvatar</span><span class="params">(Avatar avatar)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.avatar = avatar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAvatar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.avatar.url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候可以编译完以后查看<code>.class</code>文件，看到的是这样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// 注解没有了</span></span><br><span class="line"><span class="comment">// @RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误使用，因为没有final</span></span><br><span class="line">    <span class="comment">// private Avatar avatar;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//正确使用，加上final</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Avatar avatar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加了一个构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="keyword">final</span> Avatar avatar)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.avatar = avatar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAvatar</span><span class="params">(Avatar avatar)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.avatar = avatar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAvatar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.avatar.url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Autowired</code>是spring提供的，在spring中不管是写业务还是写单元测试都可以使用，它可以放在要注入的属性上面，也可以放在setter方法上面。使用他的时候不需要<code>final</code>修饰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在需要的属性上面增加这个注解，不需要final修饰</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Avatar avatar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误使用，加上final</span></span><br><span class="line">    <span class="comment">// @Autowired</span></span><br><span class="line">    <span class="comment">// private final Avatar avatar;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public Person(String name, Avatar avatar) &#123;</span></span><br><span class="line">    <span class="comment">//     this.name = name;</span></span><br><span class="line">    <span class="comment">//     this.avatar = avatar;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以加在setter方法上面</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAvatar</span><span class="params">(Avatar avatar)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.avatar = avatar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAvatar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.avatar.url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>@Qualifier</code>注解配合<code>@Autowired</code>使用，比如我们有一个头像的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IAvatar</span> &#123;</span><br><span class="line">    String <span class="title function_">getUrl</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">maleAvatar</span> <span class="keyword">implements</span> <span class="title class_">IAvatar</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUrl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;male avatar&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">femaleAvatar</span> <span class="keyword">implements</span> <span class="title class_">IAvatar</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUrl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;female avatar&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个时候我们在注入的时候如果只根据<code>IAvatar</code>来注入，容器就不知道我们需要哪个实现类了，所以我们需要指定类名.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在需要的属性上面增加这个注解，不需要final修饰</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">//指定要注入的实现类</span></span><br><span class="line">    <span class="meta">@Qualifier(value=&quot;maleAvatar&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> IAvatar avatar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误使用，加上final</span></span><br><span class="line">    <span class="comment">// @Autowired</span></span><br><span class="line">    <span class="comment">// private final Avatar avatar;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public Person(String name, Avatar avatar) &#123;</span></span><br><span class="line">    <span class="comment">//     this.name = name;</span></span><br><span class="line">    <span class="comment">//     this.avatar = avatar;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以加在setter方法上面</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(value=&quot;maleAvatar&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAvatar</span><span class="params">(IAvatar avatar)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.avatar = avatar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAvatar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.avatar.url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Resource</code>更像是上面两个的合体，并且是由java提供的。也是可以放在属性和setter上面，并且不需要final修饰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在需要的属性上面增加这个注解，不需要final修饰</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Avatar avatar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误使用，加上final</span></span><br><span class="line">    <span class="comment">// @Resource</span></span><br><span class="line">    <span class="comment">// private final Avatar avatar;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以加在setter方法上面</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAvatar</span><span class="params">(Avatar avatar)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.avatar = avatar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAvatar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.avatar.url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，如果我们有多个实现类，需要指定可以通过它的<code>name</code>参数来指定。比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在需要的属性上面增加这个注解，不需要final修饰</span></span><br><span class="line">    <span class="meta">@Resource(name=&quot;femaleAvatar&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> IAvatar avatar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误使用，加上final</span></span><br><span class="line">    <span class="comment">// @Resource</span></span><br><span class="line">    <span class="comment">// private final Avatar avatar;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以加在setter方法上面</span></span><br><span class="line">    <span class="meta">@Resource(name=&quot;femaleAvatar&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAvatar</span><span class="params">(IAvatar avatar)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.avatar = avatar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAvatar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.avatar.url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Value</code>可以注入基本类型，比如字符串这种，但是更多的是从配置文件中取值。比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//直接注入tony字符串到name中</span></span><br><span class="line">    <span class="meta">@Value(&quot;tony&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从配置文件中取值</span></span><br><span class="line">    <span class="comment">//person:</span></span><br><span class="line">    <span class="comment">//  name: tony</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;person.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String nameFromConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在需要的属性上面增加这个注解，不需要final修饰</span></span><br><span class="line">    <span class="meta">@Resource(name=&quot;femaleAvatar&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> IAvatar avatar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误使用，加上final</span></span><br><span class="line">    <span class="comment">// @Resource</span></span><br><span class="line">    <span class="comment">// private final Avatar avatar;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以加在setter方法上面</span></span><br><span class="line">    <span class="meta">@Resource(name=&quot;femaleAvatar&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAvatar</span><span class="params">(IAvatar avatar)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.avatar = avatar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAvatar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.avatar.url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数学笔记</title>
    <url>/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h1 id="高等数学笔记"><a href="#高等数学笔记" class="headerlink" title="高等数学笔记"></a>高等数学笔记</h1><p>$y &#x3D; x^(m&#x2F;n) 相当于 y^n &#x3D; x^m$</p>
<h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><ul>
<li>sinx,tanx,cotx,cscx是奇函数</li>
<li>cosx,secx是偶函数</li>
<li>tanx &#x3D; sinx&#x2F;cosx</li>
<li>cotx &#x3D; cosx&#x2F;sinx</li>
<li>$cos^2x + sin^2x &#x3D; 1$</li>
<li>$1 + tan^2x &#x3D; sec^2x$</li>
<li>$cot^2x + 1 &#x3D; csc^2x$</li>
<li>$cos^2x &#x3D; (1 + cosx) &#x2F; 2$</li>
<li>$sin^2x &#x3D; (1 - cosx) &#x2F; 2$</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sin(a+b) = sina cosb + cosa sinb</span><br><span class="line">cos(a+b) = cosa cosb - sina sinb</span><br><span class="line">sin2x = 2sinxcosx</span><br><span class="line">cos2x = cosx^2 - sinx^2</span><br></pre></td></tr></table></figure>

<p>单位圆上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sinx = y/r</span><br><span class="line">cosx = x/r</span><br><span class="line">tanx = y/x</span><br><span class="line"></span><br><span class="line">余割 cscx = r/y</span><br><span class="line">正割 secx = r/x</span><br><span class="line">余切 cotx = x/y</span><br></pre></td></tr></table></figure>

<p>余弦定理</p>
<p>$$c^2 &#x3D; a^2 + b^2 -2ab * cosx$$</p>
<p>反函数</p>
<ul>
<li>$sec^-1 X &#x3D; cos^-1 (1&#x2F;X)$</li>
<li>$csc^-1 X &#x3D; sin^-1 (1&#x2F;x)$</li>
<li>$cot^-1 X &#x3D; π&#x2F;2 - tan^-1X$</li>
</ul>
<h2 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h2><ul>
<li>ln(a * b) &#x3D; lna + lnb</li>
<li>ln(a &#x2F; b) &#x3D; lna - lnb</li>
<li>lnx^n &#x3D; n * lnx</li>
<li>ln(ⁿ√x)&#x3D;lnx&#x2F;n</li>
<li>lne &#x3D; 1</li>
<li>ln1 &#x3D; 0</li>
<li>log<sub>a</sub>b &#x3D; log<sub>c</sub>b &#x2F; log<sub>c</sub>a</li>
<li>a^x &#x3D; log<sub>a</sub>X &#x3D; e^xlna</li>
<li>e^lnx &#x3D; x</li>
<li>lne^x &#x3D; x</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lnx = 3t+5</span><br><span class="line">e^lnx = e^3t+5</span><br><span class="line">x = e^3t+5</span><br><span class="line"></span><br><span class="line">e^2x = 10</span><br><span class="line">ln e^2x = ln 10</span><br><span class="line">2x = ln10</span><br><span class="line">x = 1/2 * ln10</span><br></pre></td></tr></table></figure>

<h2 id="幂函数"><a href="#幂函数" class="headerlink" title="幂函数"></a>幂函数</h2><ul>
<li>a^m * a^n &#x3D; a^m+n</li>
<li>a^m &#x2F; a^n &#x3D; a^m-n</li>
<li>(a^m)^n &#x3D; a^mn</li>
<li>(a^m * a^n)^p &#x3D; a^mp * b^np</li>
</ul>
<h2 id="求切线方程"><a href="#求切线方程" class="headerlink" title="求切线方程"></a>求切线方程</h2><p>公式 y-y0&#x3D;m(x-x0),m为斜率，也就是导数。代入点到x0,y0处求方程，比如y&#x3D;2^x在(0,1)点的切线方程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y = 2^x的导数为ln2 * 2^x，x = 0代入为ln2</span><br><span class="line">在点(0,1)处代入 y - 1 = ln2 (x - 0)</span><br><span class="line">y - 1 = ln2x - 0</span><br><span class="line">y - ln2x - 1 = 0</span><br></pre></td></tr></table></figure>

<h2 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h2><h3 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d/dx (a+b) = d/dx a + d/dx b</span><br><span class="line">d/dx (a*b) = d/dxa * b + a * d/dx b</span><br><span class="line">d/dx (a/b) = (d/dxa * b - a * d/dx b) / b^2</span><br><span class="line">d/dx (ca) = c * d/dx a, c为常数</span><br><span class="line">d/dx (1/v) = -v^-2 * d/dx v</span><br></pre></td></tr></table></figure>

<h3 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h3><p>d&#x2F;dx f(g(x)) &#x3D; d&#x2F;dx f(g) * d&#x2F;dx  g(x)</p>
<h3 id="隐函数微分法"><a href="#隐函数微分法" class="headerlink" title="隐函数微分法"></a>隐函数微分法</h3><p>对于不像<code>y=2x</code>这种直接的函数。比如<code>x^2 + y^2 = 1</code>这种函数，可以直接对每一项求导。在使用链式法则就可以得到y的导数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x^2 + y^2 = 1 对每一项求导后 x^2 = 2x, y^=2y , 1 = 0,因为y是函数，在对y使用链式法则，得:</span><br><span class="line">2x + 2y * d/dx y = 0</span><br><span class="line">2y * d/dx y = -2x</span><br><span class="line">d/dx y = -2x / 2y</span><br><span class="line">d/dx y = -x/y</span><br></pre></td></tr></table></figure>

<h3 id="对数微分法"><a href="#对数微分法" class="headerlink" title="对数微分法"></a>对数微分法</h3><h3 id="常见导数"><a href="#常见导数" class="headerlink" title="常见导数"></a>常见导数</h3><ul>
<li>常数导数为0</li>
<li>$sinx &#x3D; cosx$</li>
<li>$cosx &#x3D; -sinx$</li>
<li>$tanx &#x3D; sec^2x$</li>
<li>$1&#x2F;x &#x3D; -1&#x2F;x^2$</li>
<li>$x^a &#x3D; a*x^a-1$</li>
<li>$a^x &#x3D; lna(a^x)$</li>
<li>$lnx &#x3D; 1&#x2F;x$</li>
</ul>
<h3 id="线性近似"><a href="#线性近似" class="headerlink" title="线性近似"></a>线性近似</h3><p>f(x) &#x3D; f(x) + d&#x2F;dx f(x) (x - x0)</p>
<p>当x&#x3D;0时：<br>f(x) &#x3D; f(0) + d&#x2F;dx f(0) * x</p>
<p>lnx的线性近似，当x &#x3D; 1时:<br>lnx &#x3D; ln1 + d&#x2F;dx ln1 (x - 1)<br>lnx &#x3D; 0 + 1 * (x - 1) &#x3D; x - 1</p>
<p>当x &#x3D; 0时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lnx = ln(1 + x) = 1 + x - 1 = x</span><br><span class="line">sinx = 0 + cos0 * x = x</span><br><span class="line">cosx = 1 + 0 * x = 1</span><br><span class="line">e^x = 1 + 1 * x = 1 + x</span><br><span class="line">(1 + x)^r = 1 + rx</span><br></pre></td></tr></table></figure>

<h4 id="二阶近似"><a href="#二阶近似" class="headerlink" title="二阶近似"></a>二阶近似</h4><p>f(x) &#x3D; f(x) + d&#x2F;dx f(x) (x - x0) + f(x)’’&#x2F;2 * (x - x0)^2</p>
<p>当x&#x3D;0时：<br>f(x) &#x3D; f(0) + f(0)’ * x + f(0)’’&#x2F;2 * x^2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sinx = x</span><br><span class="line">cosx = 1 - 1/2 * x^2</span><br><span class="line">e^x = 1 + x + 1/2 * x^2  </span><br><span class="line">ln(1 + x) = x -  1/2 * x^2</span><br><span class="line">(1 + x)^r = 1 + rx + r(r-1)/2 * x^2</span><br></pre></td></tr></table></figure>

<h3 id="曲线构图"><a href="#曲线构图" class="headerlink" title="曲线构图"></a>曲线构图</h3><ul>
<li>if f’ &gt; 0, f 是递增的</li>
<li>if f’ &lt; 0, f 是递减的</li>
<li>if f’’ &gt; 0, f’ 是递增的</li>
<li>if f’’ &lt; 0, f’ 是递减的</li>
</ul>
<p>if f(x0)’ &#x3D; 0, 则 x0 为临界点， y0 &#x3D; f(x0) 为临界点值 。</p>
<p>if f(x0)’’ &#x3D; 0,则 x0为 拐点。</p>
<h4 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h4><ul>
<li>描点<ul>
<li>找出不连续的点</li>
<li>找出最远端的点</li>
<li>找出一些简单的点</li>
</ul>
</li>
<li>求出导数为0的点<ul>
<li>标出临界点的值</li>
</ul>
</li>
<li>判断f’在每个区间的正负性</li>
<li>判断f’’的正负性，以判断凹凸性<ul>
<li>求出f0’’，算出拐点</li>
</ul>
</li>
<li>组合所有信息</li>
</ul>
<h4 id="最大最小值"><a href="#最大最小值" class="headerlink" title="最大最小值"></a>最大最小值</h4><p>只需要求出临界点，最远端的点和不连续的点就可以找出最大最小值</p>
<h3 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h3><p>用来求函数f(x)在x轴上的交点x，对y点做一切线，切线交于X轴的点为X1,求出X1点，并对X1点的y点做切线交于X轴为X2点，不断重复，求出X点</p>
<p>X<sub>n+1</sub> &#x3D; Xn - f(Xn)&#x2F;f’(Xn)</p>
<p>x^2 &#x3D; 5</p>
<p>x &#x3D; 根号5</p>
<p>X1 &#x3D; X0 - (X0^2 - 5&#x2F;2X0)<br>X1 &#x3D; X0 - 1&#x2F;2 * X0 + 5&#x2F;2X0<br>X1 &#x3D; 1&#x2F;2 * X0 + 5&#x2F;2X0</p>
<p>X点的误差在<br>E1 &#x3D; |X - X1|<br>E2 &#x3D; |X - X2|</p>
<p>En &#x3D; |根号5 - Xn-1|</p>
<p>E2 约等于 E1^2   </p>
<p>f’不能太小 f’’不能太大并且X0要在X的附近</p>
<h3 id="中值定理"><a href="#中值定理" class="headerlink" title="中值定理"></a>中值定理</h3><p>(f(b) - f(a)) &#x2F; (b - a) &#x3D; f(c)’ 要求x在a &lt; x &lt; b 之间可微，在a &lt;&#x3D; x &lt;&#x3D; b之间连续</p>
<p>比如：一辆车从北京到上海，在路上，一定有一段时间的速度等于平均速度</p>
<p>如果f’ &gt; 0 则 f 增长<br>如果f’ &lt; 0 则 f 递减<br>如果f’ &#x3D; 0 则 f 是常数</p>
<h4 id="重要不等式"><a href="#重要不等式" class="headerlink" title="重要不等式"></a>重要不等式</h4><p>e^x &gt; 1+x</p>
<p>e^x &gt; 1+x+1&#x2F;2*x^2</p>
<h2 id="微分"><a href="#微分" class="headerlink" title="微分"></a>微分</h2><p>y &#x3D; f(x) 的微分记作 dy &#x3D; f(x)’dx </p>
<p>下面的例子，求解出来是fx &#x3D; y + dy，其实就是线性近似 fx &#x3D; fa + f’(x - a), x - a其实就是dx，f’ * dx就是dy,fa就是y</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例子1</span><br><span class="line">求 64.1的1/3次方</span><br><span class="line">令 y = x的1/3次方</span><br><span class="line">dy = 1/3X^-2/3 * dx</span><br><span class="line">当x=64的时候, y = 64^1/3 = 4</span><br><span class="line">dy = 1/3 * 64^-2/3 * dx</span><br><span class="line">   = 1/3 * 1/16 * dx</span><br><span class="line">   = 1/48 * dx</span><br><span class="line">如果x=64,求64.1，则dx = 0.1</span><br><span class="line">求 64.1的1/3次方, y = 64的1/3次方，那么 </span><br><span class="line">64.1的1/3次方 = y + dy   = 4 + (1/48 * dx)</span><br><span class="line">                        = 4 + (1/48 * 1/10)</span><br><span class="line">                        = 4 + 1/480</span><br><span class="line">                        约等于 4.002 </span><br></pre></td></tr></table></figure>

<h2 id="反导数-不定积分"><a href="#反导数-不定积分" class="headerlink" title="反导数(不定积分)"></a>反导数(不定积分)</h2><p>一阶导数微分的解就是函数，二阶导数微分的解就是一阶导数。式子 f’ &#x3D; f + C</p>
<p>G(x) &#x3D; 积分 g(x) dx, Gx 就是 gx 的<code>反导数</code></p>
<p>积分sinx dx &#x3D; -cosx，因为 -cosX的一阶导数是 sinX所以 积分sinX * dx &#x3D; -cosX</p>
<p><code>不定积分</code>的不定就是可以在后面加上一个常数C,也就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Gx = 积分 sinX * dx = -cosX + C也成立</span><br></pre></td></tr></table></figure>

<h4 id="重要积分"><a href="#重要积分" class="headerlink" title="重要积分"></a>重要积分</h4><ul>
<li>x^a的不定积分 &#x3D; (1&#x2F;a+1 * X ^ a+1) + C   当 a 不等于 - 1时成立，因为a &#x3D; -1分母为0</li>
<li>1&#x2F;X的不定积分 &#x3D; (ln|X|) + C </li>
<li>sec<sup>2</sup>X 的不定积分 &#x3D; tanX + C</li>
<li>1&#x2F;根号 1-X^2 的不定积分 &#x3D; sin<sup>-1</sup>X + C</li>
<li>1&#x2F;1+X^2的不定积分 &#x3D; tan<sup>-1</sup>X + C</li>
</ul>
<h4 id="积分换元法"><a href="#积分换元法" class="headerlink" title="积分换元法"></a>积分换元法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例子1</span><br><span class="line">求解 X^3 * (X^4 + 2)^5 * dx 的积分</span><br><span class="line"></span><br><span class="line">令 u = x^4 + 2, 则 du = u&#x27; + dx = 4x^3 * dx</span><br><span class="line"></span><br><span class="line">x^3 * (x^4 + 2)^5 * dx </span><br><span class="line">= u^5 * x^3 * dx </span><br><span class="line">= u^5 * 1/4 * du</span><br><span class="line">= 1/24 * u^6 + C</span><br><span class="line">= 1/24 * (x^4 + 2)^6 + C</span><br></pre></td></tr></table></figure>

<h4 id="提前猜测"><a href="#提前猜测" class="headerlink" title="提前猜测"></a>提前猜测</h4><p>例子2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">求解 e^6x 的积分</span><br><span class="line"></span><br><span class="line">e^6x的导数是 6*e^6x</span><br><span class="line">他的导数乘以 1/6就是 e^6x</span><br><span class="line">所以 积分就是 1/6 * e^6x + C</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>例子3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">求 x * e^-x^2的积分</span><br><span class="line"></span><br><span class="line">猜测 e^-x^2,求导 = e^-x^2 * -2x</span><br><span class="line">所以 积分 = 1/2 * e^-x^2 + C</span><br></pre></td></tr></table></figure>

<p>例子4</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">求 sinx cosx的积分</span><br><span class="line"></span><br><span class="line">猜测 sinX^2, 求导 = 2sinxcosx</span><br><span class="line">所以 积分 = 1/2sinx^2 + C</span><br><span class="line"></span><br><span class="line">也可以猜测 cosx^2,求导 = -2sinxcosx</span><br><span class="line">所以 积分 = -1/2cosx^2 + C</span><br><span class="line"></span><br><span class="line">两个都成立，两者可以相减 1/2 sinx^2 - (-1/2 cosx^2) = 1/2 所以 两个 C 相差 1/2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="高级猜测"><a href="#高级猜测" class="headerlink" title="高级猜测"></a>高级猜测</h4><p>例子4 求 (d&#x2F;dx + x) * y &#x3D; 0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(d/dx + x) * y = 0</span><br><span class="line">dy/dx + xy = 0</span><br><span class="line">dy/dx = -xy</span><br><span class="line">dy = -xy * dx</span><br><span class="line">dy/y = -x * dx                                           把y和x各放到一边</span><br><span class="line">积分 dy/y = 积分 -x * dx                                  对两边同时积分</span><br><span class="line">因为 lny的导数是1/y 所以 积分 dy/y  = lny</span><br><span class="line">因为 -x^2/2 的导数是 -x 所以 积分 -x * dx = -x^2/2</span><br><span class="line">则 ： lny = -x^2/2 + C                                   y &gt; 0</span><br><span class="line">e^lny = e^-x^2/2 + C                                     对两边同时取对数</span><br><span class="line">y = A * e^-x^2/2  (A = e^c)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="分离变量法"><a href="#分离变量法" class="headerlink" title="分离变量法"></a>分离变量法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dy/dx = f(x) * g(y) = -x * y</span><br><span class="line">dy/g(y) = f(x) * dx</span><br><span class="line">G(y) = 积分 dy/g(y)</span><br><span class="line">F(x) = 积分 f(x) * dx</span><br><span class="line">G(y) = F(x) + C</span><br><span class="line">上面是隐式方程，为了变成显式方程还需要求逆</span><br><span class="line">y = G^-1(F(x) + C)</span><br></pre></td></tr></table></figure>


<h2 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h2><p>几何意义是求函数曲线下的面积</p>
<ol>
<li>划分成多个矩形    所有矩形的底边一样长，都是b&#x2F;n</li>
<li></li>
<li></li>
</ol>
<p>例子1 y &#x3D; x^2 的定积分 a &#x3D; 0, b &#x3D; n</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">划分成多个矩形后，第一个矩形的面积 = 底 * 高 = b/n * f(x) = b/n * (b/n)^2</span><br><span class="line">第二个矩形的面积 = 底 * 高 = b/n * f(x) = b/n * f(2 * b/n) = b/n * (2b/n)^2</span><br><span class="line">第n个矩形的面积 = b/n * (nb/n)^2</span><br><span class="line">矩形面积的和 提取公因子 (b/n)^3 * (1^2 + 2^2 + .... + n^2)</span><br><span class="line">(1^2 + 2^2 + .... + n^2) 想成金字塔，其体积最小是 1/3 * n^3 ，体积最大是 1/3 * （n+1）^3 </span><br><span class="line">而矩形面积的和 =  (b/n)^3 * (1^2 + 2^2 + .... + n^2) = b^3 * (1^2 + 2^2 + .... + n^2)  / n^3</span><br><span class="line">1/3 &lt; (1^2 + 2^2 + .... + n^2)  / n^3 &lt; 1/3 * （n+1）^3 / n^3</span><br><span class="line">根据夹逼定理，左边的极限是 1/3 右边 1/3 * （n+1）^3 / n^3 = 1/3 * (n+1/n)^3 = 1/3 * (1 + 1/n)^3 当n趋于无穷的极限也是1/3所以中间的极限是1/3</span><br><span class="line">矩形面积的和 =  b^3 * (1^2 + 2^2 + .... + n^2)  / n^3 = b^3 * 1/3</span><br></pre></td></tr></table></figure>


<p>定积分</p>
<ul>
<li>x^2 &#x3D; b^3&#x2F;3</li>
<li>x &#x3D; b^2&#x2F;2</li>
<li>1 &#x3D; b</li>
</ul>
<h3 id="微积分第一基本定理"><a href="#微积分第一基本定理" class="headerlink" title="微积分第一基本定理"></a>微积分第一基本定理</h3><p>if F(x)’ &#x3D; f(x) , than 从a到b f(x) dx的定积分 &#x3D; F(b) - F(a) &#x3D; b的积分 - a的积分</p>
<p>例子1 x^2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从a到b x^2 dx 的定积分 = F(b) - F(a) = b^3/3 - a^3/3</span><br><span class="line">当a = 0,则 b^3/3 - 0/3 = b^3/3</span><br></pre></td></tr></table></figure>


<h4 id="运算法则"><a href="#运算法则" class="headerlink" title="运算法则"></a>运算法则</h4><ul>
<li>积分（fx + gx） &#x3D; 积分fx + 积分gx</li>
<li>积分（c * fx） &#x3D; c * 积分fx</li>
<li>如果 a &lt; b &lt; c 则 a到b的积分 + b到c的积分 &#x3D; a到c的积分</li>
<li>a到a的积分 &#x3D; 0</li>
<li>a到b的积分 &#x3D; -（b到a的积分）</li>
<li>如果 fx &lt;&#x3D; gx,那么从a到b fx的积分 &lt;&#x3D; gx的积分 a &lt; b</li>
</ul>
<h3 id="微积分第二基本定理"><a href="#微积分第二基本定理" class="headerlink" title="微积分第二基本定理"></a>微积分第二基本定理</h3><p>if f 是连续的函数，并且 G(x) &#x3D; 从a到x的积分 f(t) dt, than G(x)’ &#x3D; f(x)</p>
<h3 id="平均公式"><a href="#平均公式" class="headerlink" title="平均公式"></a>平均公式</h3><p>1&#x2F;(b - a) * 从a到b的积分f(x) dx</p>
<h3 id="加权平均公式"><a href="#加权平均公式" class="headerlink" title="加权平均公式"></a>加权平均公式</h3><p>从a到b的积分 f(x) w(x) dx &#x2F; 从a到b的积分 w(x) dx</p>
<h3 id="圆盘法"><a href="#圆盘法" class="headerlink" title="圆盘法"></a>圆盘法</h3><p>先求一个圆盘的体积，也就是 面积 * 高 &#x3D; πr^2 * dx，然后积分</p>
<h3 id="壳层法"><a href="#壳层法" class="headerlink" title="壳层法"></a>壳层法</h3><p>先求竖着的圆柱的体积，绕一圈在展开变成长方体，求体积就是 长 * 宽 * 高 &#x3D; 圆的周长 * dx * f(x)，然后积分</p>
<h3 id="数值积分"><a href="#数值积分" class="headerlink" title="数值积分"></a>数值积分</h3><h3 id="三角替换"><a href="#三角替换" class="headerlink" title="三角替换"></a>三角替换</h3><ul>
<li>tanx的积分 &#x3D; ln(cosx) + C</li>
<li>secx的积分 &#x3D; ln(secx + tanx) + C</li>
</ul>
<p>例题1</p>
<p>求secX的4次方的积分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为 sexX^2 = 1 + tanX^2，所以secx^4 dx的积分 = （1 + tanx^2）sexX^2 dx的积分</span><br><span class="line"></span><br><span class="line">令 u = tanx, du = secX^2 dx，则 = (1 + u^2) du的积分 = u + u^3/3 + C</span><br><span class="line">= tanx + tanx^3/3 + C</span><br></pre></td></tr></table></figure>

<p>例题2</p>
<p>1&#x2F;(x^2根号下1+x^2)的积分</p>
<p>例题3</p>
<p>tan (arc cscx) &#x3D; 1&#x2F; (根号x^2 - 1)</p>
<table>
<thead>
<tr>
<th align="left">被积函数</th>
<th align="left">三角替换</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">根号下a^2 - x^2</td>
<td align="left">x &#x3D; acosx or y &#x3D; asinx</td>
<td align="left">asinx or acosx</td>
</tr>
<tr>
<td align="left">根号下a^2 + x^2</td>
<td align="left">x &#x3D; atanx</td>
<td align="left">asecx</td>
</tr>
<tr>
<td align="left">根号下x^2 - a^2</td>
<td align="left">x &#x3D; asecx</td>
<td align="left">atanx</td>
</tr>
</tbody></table>
<p>例题4</p>
<p>dx&#x2F;根号x^2+4x</p>
<h3 id="部分分式"><a href="#部分分式" class="headerlink" title="部分分式"></a>部分分式</h3><p>如果分子项数 &lt; 分母项数，可以用掩盖法</p>
<ol>
<li>对分母因式分解成 x&#x2F;(x+1)(x-2)  的形式</li>
<li>设置未知数 变成 A&#x2F;x+1 和 B&#x2F;x-2</li>
<li>掩盖法解A,B,先同乘以一个分母 比如 x+1 则变成 A + B&#x2F;(x-2) * (x + 1),令x &#x3D; -1则 B这项为0从而解出A,同理解出B</li>
</ol>
<p>如果分子项数 &gt;&#x3D; 分母项数， 用直接除法变成 分子项数 &lt; 分母项数的形式</p>
<h1 id="常用积分"><a href="#常用积分" class="headerlink" title="常用积分"></a>常用积分</h1><table>
<thead>
<tr>
<th align="left">被积函数</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">lnx的积分</td>
<td align="left">xlnx - x + C</td>
</tr>
<tr>
<td align="left">(lnx)^2</td>
<td align="left">x(lnx)^2 - 2(xlnx - x) + C</td>
</tr>
<tr>
<td align="left">tanx的积分</td>
<td align="left">ln(cosx) + C</td>
</tr>
<tr>
<td align="left">cotx的积分</td>
<td align="left">ln(sinx) + C</td>
</tr>
<tr>
<td align="left">secx的积分</td>
<td align="left">ln(secx + tanx) + C</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>高等数学笔记</category>
      </categories>
      <tags>
        <tag>高等数学笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>php实现归并排序算法</title>
    <url>/php%E5%AE%9E%E7%8E%B0%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<h1 id="php实现归并排序算法"><a href="#php实现归并排序算法" class="headerlink" title="php实现归并排序算法"></a>php实现归并排序算法</h1><p>归并排序算法的复杂度是O(nlogn)。</p>
<p>代码如下,完整代码在<a href="https://github.com/Thepatterraining/design-pattern">github上面</a>，只需要clone下来执行<code>composer install</code>然后执行 <code>php artisan test:mergeSort</code> 就可以看到结果了</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序把数据逐步分解，然后对分解后的数据进行排序，最后合并到一起</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;a = [<span class="number">3</span>,<span class="number">70</span>,<span class="number">4</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">34</span>,<span class="number">4</span>];</span><br><span class="line">    <span class="title function_ invoke__">dump</span>(<span class="variable language_">$this</span>-&gt;a);</span><br><span class="line">    <span class="variable">$a</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">mergeSort</span>(<span class="variable language_">$this</span>-&gt;a, <span class="number">0</span>, <span class="title function_ invoke__">count</span>(<span class="variable language_">$this</span>-&gt;a));</span><br><span class="line">    <span class="title function_ invoke__">dd</span>(<span class="variable">$a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params"><span class="variable">$a</span>, <span class="variable">$lo</span>, <span class="variable">$hi</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="variable">$hi</span> - <span class="variable">$lo</span>) &lt; <span class="number">2</span>) <span class="keyword">return</span> [<span class="variable">$a</span>[<span class="variable">$lo</span>]];</span><br><span class="line">    <span class="variable">$mi</span> = (<span class="variable">$lo</span> + <span class="variable">$hi</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//把中点左边的进行归并</span></span><br><span class="line">    <span class="variable">$b</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">mergeSort</span>(<span class="variable">$a</span>, <span class="variable">$lo</span>, <span class="variable">$mi</span>);</span><br><span class="line">    <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;$b:&#x27;</span>,<span class="variable">$b</span>);</span><br><span class="line">    <span class="comment">//把中点右边的进行归并</span></span><br><span class="line">    <span class="variable">$c</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">mergeSort</span>(<span class="variable">$a</span>, <span class="variable">$mi</span>, <span class="variable">$hi</span>);</span><br><span class="line">    <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;$c:&#x27;</span>,<span class="variable">$c</span>);</span><br><span class="line">    <span class="comment">//把所有数据进行排序</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">merge</span>(<span class="variable">$b</span>, <span class="variable">$c</span>, <span class="variable">$lo</span>,<span class="variable">$mi</span>,<span class="variable">$hi</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 假设有一个数组$a分成了两个数组[3,4] [2,8]</span></span><br><span class="line"><span class="comment"> * 逐一比较，3and2，取出来2然后3and8取出来3然后4and8取出来4，最后取出来8</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> [type] $lo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> [type] $mi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> [type] $hi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params"><span class="variable">$b</span>, <span class="variable">$c</span>, <span class="variable">$lo</span>, <span class="variable">$mi</span>, <span class="variable">$hi</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$lb</span> = <span class="variable">$mi</span> - <span class="variable">$lo</span>; <span class="comment">//$b数组的边界</span></span><br><span class="line">    <span class="variable">$lc</span> = <span class="variable">$hi</span> - <span class="variable">$mi</span>; <span class="comment">//$c数组的边界</span></span><br><span class="line">    <span class="variable">$res</span> = [];</span><br><span class="line">    <span class="comment">//$i表示合并后数组的下标 $ib是b数组的下标 $ic是c数组的下标 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>,<span class="variable">$ib</span>=<span class="number">0</span>,<span class="variable">$ic</span>=<span class="number">0</span>;<span class="variable">$ib</span>&lt;<span class="variable">$lb</span> || <span class="variable">$ic</span> &lt; <span class="variable">$lc</span>;)&#123;</span><br><span class="line">        <span class="comment">//ib 下标没有越界 &amp;&amp; c的数组已经空了也就是$ic &gt;= $lc || 比较两个数组首位的大小 如果b的首元素 &lt; c的首元素，那么取出来b的首元素</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$ib</span> &lt; <span class="variable">$lb</span> &amp;&amp; ( <span class="variable">$ic</span> &gt;= <span class="variable">$lc</span> || <span class="variable">$b</span>[<span class="variable">$ib</span>] &lt;= <span class="variable">$c</span>[<span class="variable">$ic</span>])) &#123;</span><br><span class="line">            <span class="variable">$res</span>[<span class="variable">$i</span>++] = <span class="variable">$b</span>[<span class="variable">$ib</span>++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//k 下标没有越界 &amp;&amp; b的数组已经空了也就是$ib &gt;= $lb || 如果c的首元素 &lt; b的首元素，那么取出来c的首元素 </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$ic</span> &lt; <span class="variable">$lc</span> &amp;&amp; (<span class="variable">$ib</span> &gt;= <span class="variable">$lb</span> || <span class="variable">$b</span>[<span class="variable">$ib</span>] &gt; <span class="variable">$c</span>[<span class="variable">$ic</span>])) &#123;</span><br><span class="line">            <span class="variable">$res</span>[<span class="variable">$i</span>++] = <span class="variable">$c</span>[<span class="variable">$ic</span>++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$res</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="归并排序原理"><a href="#归并排序原理" class="headerlink" title="归并排序原理"></a>归并排序原理</h3><p>归并排序和快排刚好相反，是先将整个数组左右打散，然后在逐一合并进行排序，最终完成整个数组的排序，排序示意图如下：</p>
<p><img src="/images/mergesort01.png" alt="mergesort1"></p>
<p>首先将整个数组左右打散，变成单个元素，因为单个元素可以被认为是有序的。<br>对应代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="variable">$hi</span> - <span class="variable">$lo</span>) &lt; <span class="number">2</span>) <span class="keyword">return</span> [<span class="variable">$a</span>[<span class="variable">$lo</span>]];</span><br><span class="line"><span class="variable">$mi</span> = (<span class="variable">$lo</span> + <span class="variable">$hi</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="comment">//把中点左边的进行归并</span></span><br><span class="line"><span class="variable">$b</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">mergeSort</span>(<span class="variable">$a</span>, <span class="variable">$lo</span>, <span class="variable">$mi</span>);</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="string">&#x27;$b:&#x27;</span>,<span class="variable">$b</span>);</span><br><span class="line"><span class="comment">//把中点右边的进行归并</span></span><br><span class="line"><span class="variable">$c</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">mergeSort</span>(<span class="variable">$a</span>, <span class="variable">$mi</span>, <span class="variable">$hi</span>);</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="string">&#x27;$c:&#x27;</span>,<span class="variable">$c</span>);</span><br></pre></td></tr></table></figure>

<p>接下来对左右两个有序数组进行排序，假设有一个数组$a分成了两个数组[3,4] [2,8]，逐一比较，3and2，取出来2然后3and8取出来3然后4and8取出来4，最后取出来8，对应代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lb</span> = <span class="variable">$mi</span> - <span class="variable">$lo</span>; <span class="comment">//$b数组的边界</span></span><br><span class="line"><span class="variable">$lc</span> = <span class="variable">$hi</span> - <span class="variable">$mi</span>; <span class="comment">//$c数组的边界</span></span><br><span class="line"><span class="variable">$res</span> = [];</span><br><span class="line"><span class="comment">//$i表示合并后数组的下标 $ib是b数组的下标 $ic是c数组的下标 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>,<span class="variable">$ib</span>=<span class="number">0</span>,<span class="variable">$ic</span>=<span class="number">0</span>;<span class="variable">$ib</span>&lt;<span class="variable">$lb</span> || <span class="variable">$ic</span> &lt; <span class="variable">$lc</span>;)&#123;</span><br><span class="line">    <span class="comment">//ib 下标没有越界 &amp;&amp; c的数组已经空了也就是$ic &gt;= $lc || 比较两个数组首位的大小 如果b的首元素 &lt; c的首元素，那么取出来b的首元素</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$ib</span> &lt; <span class="variable">$lb</span> &amp;&amp; ( <span class="variable">$ic</span> &gt;= <span class="variable">$lc</span> || <span class="variable">$b</span>[<span class="variable">$ib</span>] &lt;= <span class="variable">$c</span>[<span class="variable">$ic</span>])) &#123;</span><br><span class="line">        <span class="variable">$res</span>[<span class="variable">$i</span>++] = <span class="variable">$b</span>[<span class="variable">$ib</span>++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//k 下标没有越界 &amp;&amp; b的数组已经空了也就是$ib &gt;= $lb || 如果c的首元素 &lt; b的首元素，那么取出来c的首元素 </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$ic</span> &lt; <span class="variable">$lc</span> &amp;&amp; (<span class="variable">$ib</span> &gt;= <span class="variable">$lb</span> || <span class="variable">$b</span>[<span class="variable">$ib</span>] &gt; <span class="variable">$c</span>[<span class="variable">$ic</span>])) &#123;</span><br><span class="line">        <span class="variable">$res</span>[<span class="variable">$i</span>++] = <span class="variable">$c</span>[<span class="variable">$ic</span>++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$res</span>;</span><br></pre></td></tr></table></figure>

<p>示意图如下：</p>
<p><img src="/images/mergesort02.png" alt="mergesort2"></p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>php</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>无序数组去重算法</title>
    <url>/%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<h1 id="无序数组去重算法"><a href="#无序数组去重算法" class="headerlink" title="无序数组去重算法"></a>无序数组去重算法</h1><p>无序数组去重算法的复杂度是O(n<sup>2</sup>)。</p>
<p>代码如下,首先进行外层循环，复杂度O(n)，然后查找这个元素之前的元素中有没有重复的，复杂度O(n)，如果有就删除，复杂度O(1)，没有就下一个元素，复杂度O(1)。加起来复杂度O(n<sup>2</sup>)。</p>
<p>完整代码在<a href="https://github.com/Thepatterraining/design-pattern">github上面</a>，只需要clone下来执行<code>composer install</code>然后执行 <code>php artisan test:unsortDeduplicate</code> 就可以看到结果了</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute the console command.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$a</span> = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">34</span>,<span class="number">10</span>,<span class="number">4</span>];</span><br><span class="line">    <span class="title function_ invoke__">dump</span>(<span class="variable">$a</span>);</span><br><span class="line">    <span class="variable">$i</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="variable">$len</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$a</span>);</span><br><span class="line">    <span class="title function_ invoke__">dump</span>(<span class="string">&quot;长度:&quot;</span>.<span class="variable">$len</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$i</span> &lt; <span class="variable">$len</span>) &#123; <span class="comment">//循环全部数据</span></span><br><span class="line">        <span class="comment">//在整个数组中寻找这个值，如果找到了就删除他，如果没找到就下一个</span></span><br><span class="line">        <span class="variable">$preIndex</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">find</span>(<span class="variable">$i</span>, <span class="variable">$a</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$preIndex</span>!==<span class="literal">false</span>) &#123;<span class="keyword">unset</span>(<span class="variable">$a</span>[<span class="variable">$preIndex</span>]);&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="variable">$i</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">dd</span>(<span class="variable">$a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params"><span class="variable">$i</span>, <span class="keyword">array</span> <span class="variable">$a</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$index</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环从0到这个下标</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$index</span> &lt; <span class="variable">$i</span>) &#123;</span><br><span class="line">        <span class="comment">//不存在说明被删除了</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">array_key_exists</span>(<span class="variable">$index</span>, <span class="variable">$a</span>)) &#123;<span class="variable">$index</span>++;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="comment">//如果找到了返回下标</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$a</span>[<span class="variable">$i</span>] == <span class="variable">$a</span>[<span class="variable">$index</span>]) <span class="keyword">return</span> <span class="variable">$index</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="variable">$index</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>php</tag>
        <tag>去重</tag>
      </tags>
  </entry>
  <entry>
    <title>有序数组去重算法</title>
    <url>/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<h1 id="有序数组去重算法"><a href="#有序数组去重算法" class="headerlink" title="有序数组去重算法"></a>有序数组去重算法</h1><p>有序数组去重算法的复杂度是O(n)。</p>
<p>代码如下,只进行一次循环，复杂度O(n)</p>
<p>完整代码在<a href="https://github.com/Thepatterraining/design-pattern">github上面</a>，只需要clone下来执行<code>composer install</code>然后执行 <code>php artisan test:sortDeduplicate</code> 就可以看到结果了</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 因为是有序数组，为了提高去重效率，取一个元素往后一直比对，如果相邻的相等表示是重复的</span></span><br><span class="line"><span class="comment"> * 继续往后，直到不相等，也就是遇到一个不重复的为止，将这个不重复的元素移动到该元素的下一个</span></span><br><span class="line"><span class="comment"> * 然后用这个不重复的元素为起始，重复上述操作。直到最后</span></span><br><span class="line"><span class="comment"> * 删除最后一个不重复元素后面所有的元素</span></span><br><span class="line"><span class="comment"> * 因为只循环一遍，复杂度O(n)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$a</span> = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">34</span>];</span><br><span class="line">    <span class="title function_ invoke__">dump</span>(<span class="variable">$a</span>);</span><br><span class="line">    <span class="comment">//分别代表第一个数据，和要比对的数据</span></span><br><span class="line">    <span class="variable">$i</span> = <span class="number">0</span>;<span class="variable">$j</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="variable">$len</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$a</span>);</span><br><span class="line">    <span class="title function_ invoke__">dump</span>(<span class="string">&quot;长度:&quot;</span>.<span class="variable">$len</span>);</span><br><span class="line">    <span class="keyword">while</span> ((++<span class="variable">$j</span>) &lt; <span class="variable">$len</span>) &#123; <span class="comment">//循环全部数据</span></span><br><span class="line">        <span class="comment">//从$i往后寻找，如果相邻的相等表示是重复的，继续往后，直到不相等，也就是遇到一个不重复的为止，将这个不重复的元素移动到该元素的下一个</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$a</span>[<span class="variable">$i</span>] != <span class="variable">$a</span>[<span class="variable">$j</span>]) &#123;</span><br><span class="line">            <span class="variable">$a</span>[++<span class="variable">$i</span>] = <span class="variable">$a</span>[<span class="variable">$j</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//截取前面去重过的数据</span></span><br><span class="line">    <span class="variable">$a</span> = <span class="title function_ invoke__">array_slice</span>(<span class="variable">$a</span>, <span class="number">0</span>, ++<span class="variable">$i</span>);</span><br><span class="line">    <span class="title function_ invoke__">dd</span>(<span class="variable">$a</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>php</tag>
        <tag>去重</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP-ES包分词功能实现</title>
    <url>/PHP-ES%E5%8C%85%E5%88%86%E8%AF%8D%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0.html</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>直接使用 composer 安装 ES 包就可以了，这里使用官方的 <code>elasticsearch/elasticsearch</code> 这个包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">composer require elasticsearch/elasticsearch</span><br></pre></td></tr></table></figure>

<p>安装好以后，创建一个客户端。hosts如果是多个节点的集群，那么可以配置一个二维数组。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$hosts</span> = [</span><br><span class="line">            <span class="string">&#x27;host&#x27;</span> =&gt; <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;port&#x27;</span> =&gt; <span class="string">&#x27;9200&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;scheme&#x27;</span> =&gt; <span class="string">&#x27;http&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;user&#x27;</span> =&gt; <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;pass&#x27;</span> =&gt; <span class="string">&#x27;&#x27;</span></span><br><span class="line">        ];</span><br><span class="line"><span class="variable">$client</span> = <span class="title class_">ClientBuilder</span>::<span class="title function_ invoke__">create</span>()  <span class="comment">//创建客户端</span></span><br><span class="line">                        -&gt;<span class="title function_ invoke__">setHosts</span>(<span class="variable">$hosts</span>) <span class="comment">//hosts连接地址</span></span><br><span class="line">                        -&gt;<span class="title function_ invoke__">build</span>();</span><br></pre></td></tr></table></figure>

<p>如果想跳过ssl证书校验，可以添加一些curl的参数放进客户端</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$curlParams</span> = [<span class="comment">//不校验ssl</span></span><br><span class="line">                CURLOPT_SSL_VERIFYPEER =&gt; <span class="number">0</span>,</span><br><span class="line">                CURLOPT_SSL_VERIFYHOST =&gt; <span class="number">0</span>,</span><br><span class="line">            ];</span><br><span class="line"><span class="variable">$client</span> = <span class="title class_">ClientBuilder</span>::<span class="title function_ invoke__">create</span>()</span><br><span class="line">            -&gt;<span class="title function_ invoke__">setConnectionParams</span>([<span class="string">&#x27;client&#x27;</span> =&gt; [<span class="string">&#x27;curl&#x27;</span> =&gt; <span class="variable">$curlParams</span>]]) <span class="comment">//设置curl参数</span></span><br><span class="line">            -&gt;<span class="title function_ invoke__">setHosts</span>(<span class="variable">$hosts</span>)</span><br><span class="line">            -&gt;<span class="title function_ invoke__">build</span>();</span><br></pre></td></tr></table></figure>

<h3 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h3><p>简单的增删改查在 elasticsearch 的文档中有介绍了，就不说了，可以看(<a href="https://www.elastic.co/guide/cn/elasticsearch/php/current/_quickstart.html)[%E6%96%87%E6%A1%A3]%E3%80%82">https://www.elastic.co/guide/cn/elasticsearch/php/current/_quickstart.html)[文档]。</a></p>
<p>分词的话隐藏的比较深，文档中没有介绍，他放在了<code>indices</code>这个 namespace 下面。如果看源码，可以在<code>Endpoints/Indices</code> 目录下面发现 <code>Analyze.php</code> 文件，当然了，除了分词，这里面还有其他功能，可以自己看。</p>
<p>这个文件也很简单啊，只有几个函数，就是设置请求的API地址，参数这些。</p>
<p>使用起来是这样的，我们用上面创建好的客户端。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$parmas</span>[<span class="string">&#x27;index&#x27;</span>] = <span class="string">&#x27;test&#x27;</span> <span class="comment">//这个是分词的index，也可以不加，加了请求的API就是 $index/_analyze</span></span><br><span class="line"><span class="comment">//请求体 这个就和你直接写DSL没区别了，参数啥的都一样，可以在 kibana里面试试参数</span></span><br><span class="line"><span class="variable">$parmas</span>[<span class="string">&#x27;body&#x27;</span>] = [</span><br><span class="line">  <span class="string">&#x27;text&#x27;</span> =&gt; <span class="string">&#x27;php开发&#x27;</span>, <span class="comment">//要分词的文字</span></span><br><span class="line">  <span class="string">&#x27;analyzer&#x27;</span> =&gt; <span class="string">&#x27;ik_smart&#x27;</span>, <span class="comment">//分词器，可以不写</span></span><br><span class="line">]; </span><br><span class="line"><span class="variable">$client</span>-&gt;<span class="title function_ invoke__">indices</span>()-&gt;<span class="title function_ invoke__">analyze</span>(<span class="variable">$params</span>);</span><br></pre></td></tr></table></figure>

<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>indices函数返回的就是 indices 文件夹的 namespace，对应文件在<code>namespace/IndicesNamespace.php</code>,然后后面的函数就相当于文件名，她会拼接在 indices 后面，像我们上面请求的文件就是<code>indices/Analyze.php</code>。具体的拼接就是在 <code>namespace/IndicesNamespace.php</code> 这个里面做的，有一个函数如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * $params[&#x27;index&#x27;] = (string) The name of the index to scope the operation</span></span><br><span class="line"><span class="comment">  * $params[&#x27;body&#x27;]  = (array) Define analyzer/tokenizer parameters and the text on which the analysis should be performed</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> array $params Associative array of parameters</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-analyze.html</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">analyze</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$params</span> = []</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取$params[&#x27;index&#x27;], $params[&#x27;body&#x27;]</span></span><br><span class="line">    <span class="variable">$index</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">extractArgument</span>(<span class="variable">$params</span>, <span class="string">&#x27;index&#x27;</span>);</span><br><span class="line">    <span class="variable">$body</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">extractArgument</span>(<span class="variable">$params</span>, <span class="string">&#x27;body&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置endpoints处理类</span></span><br><span class="line">    <span class="variable">$endpointBuilder</span> = <span class="variable language_">$this</span>-&gt;endpoints;</span><br><span class="line">    <span class="comment">//$endpoint 就相当于 indices/Analyze.php 这个文件了</span></span><br><span class="line">    <span class="variable">$endpoint</span> = <span class="variable">$endpointBuilder</span>(<span class="string">&#x27;Indices\Analyze&#x27;</span>);</span><br><span class="line">    <span class="comment">//设置参数，index, 请求体</span></span><br><span class="line">    <span class="variable">$endpoint</span>-&gt;<span class="title function_ invoke__">setParams</span>(<span class="variable">$params</span>);</span><br><span class="line">    <span class="variable">$endpoint</span>-&gt;<span class="title function_ invoke__">setIndex</span>(<span class="variable">$index</span>);</span><br><span class="line">    <span class="variable">$endpoint</span>-&gt;<span class="title function_ invoke__">setBody</span>(<span class="variable">$body</span>);</span><br><span class="line">    <span class="comment">//发起请求</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">performRequest</span>(<span class="variable">$endpoint</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$this-&gt;endpoints 是一个函数，外面传进来的，函数内容如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">$this</span>-&gt;endpoint = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$class</span></span>) <span class="keyword">use</span> (<span class="params"><span class="variable">$serializer</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//拼接处理类</span></span><br><span class="line">  <span class="variable">$fullPath</span> = <span class="string">&#x27;\\Elasticsearch\\Endpoints\\&#x27;</span> . <span class="variable">$class</span>;</span><br><span class="line">  <span class="comment">//反射获取</span></span><br><span class="line">  <span class="variable">$reflection</span> = <span class="keyword">new</span> <span class="title class_">ReflectionClass</span>(<span class="variable">$fullPath</span>);</span><br><span class="line">  <span class="variable">$constructor</span> = <span class="variable">$reflection</span>-&gt;<span class="title function_ invoke__">getConstructor</span>();</span><br><span class="line">  <span class="comment">//执行</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">$constructor</span> &amp;&amp; <span class="variable">$constructor</span>-&gt;<span class="title function_ invoke__">getParameters</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="variable">$fullPath</span>(<span class="variable">$serializer</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="variable">$fullPath</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>go学习第一章</title>
    <url>/go%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E7%AB%A0.html</url>
    <content><![CDATA[<h1 id="go学习第一章"><a href="#go学习第一章" class="headerlink" title="go学习第一章"></a>go学习第一章</h1><p>在go现在的版本里面可以使用<code>go mod</code>来管理依赖了</p>
<p>使用 <code>go mod</code> 意味着不需要设置多个 <code>GOPATH</code> 了</p>
<p><code>go mod</code> 对应的环境变量 <code>GO111MODULE</code> 有三个值，默认<code>auto</code></p>
<ul>
<li>on  模块支持，go命令行会使用modules，而一点也不会去GOPATH目录下查找</li>
<li>off 无模块支持，go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。</li>
<li>auto 只要当前目录或者父目录有<code>go.mod</code>文件，那么就以on的形式工作。</li>
</ul>
<h2 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h2><p>使用<code>fmt</code>包进行标准输出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>flag</code> 包进行标准输入</p>
<p>有两种方式</p>
<ul>
<li>一种是传入变量地址的<code>StringVar</code>，第二个参数是输入的变量名，第三个是默认值，第四个是描述</li>
<li>还有一种是<code>String</code>，除了第一个参数不同，是通过返回值接收参数，其他都一样</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;flag&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">    flag.StringVar(&amp;name, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;default&quot;</span>, <span class="string">&quot;desc&quot;</span>)</span><br><span class="line">    name = flag.String(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;default&quot;</span>,<span class="string">&quot;desc&quot;</span>)</span><br><span class="line">    flag.Parse()</span><br><span class="line">    fmt.Println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候<code>go run hello.go -name=123</code></p>
<p><code>-name</code>就是你输入的名称，前面要加<code>-</code> 或者 <code>--</code> 没有或者有三个都是不行的。每个输入默认自带<code>-h</code> 来获取命令帮助，帮助里面会显示描述和默认值</p>
<h2 id="go-mod-下的本地包拆分"><a href="#go-mod-下的本地包拆分" class="headerlink" title="go mod 下的本地包拆分"></a>go mod 下的本地包拆分</h2><p>如果我们想把代码分散到不同的文件中怎么做呢？</p>
<p>假设现在的目录如下</p>
<ul>
<li>main.go</li>
<li>test<ul>
<li>test.go</li>
</ul>
</li>
</ul>
<p>我们想要在<code>main.go</code>引用<code>test.go</code>的代码</p>
<p>首先在go里面通过首字母大小写决定访问权限<code>首字母大写 = public</code>，<code>首字母小写 = protected or private</code></p>
<p>假设<code>test.go</code>代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test <span class="comment">//包名和目录保持一致</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main.go</code>代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想使用<code>test</code>这个包里面的东西需要使用<code>go mod</code>了</p>
<p>执行<code>go mod init name</code>,<code>name</code> 表示当前包的名称，可以随便取</p>
<p>这个时候会生成<code>go.mod</code>文件，假设刚才执行的是<code>go mod init hello</code>，那么我们的<code>go.mod</code>文件如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module hello</span><br><span class="line"></span><br><span class="line">go 1.17</span><br></pre></td></tr></table></figure>

<p>这个时候我们就可以在<code>main.go</code>引入<code>test.go</code>了，<code>main.go</code>代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;hello/test&quot;</span>  <span class="comment">//引入hello这个包下面的test包</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test.Test() <span class="comment">//这里可以使用test包的Test方法了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然了，包名<code>test</code>也可以和目录<code>test</code>不一致，比如<code>test.go</code>文件内容如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test5 <span class="comment">//包名和目录不一致</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在<code>main.go</code>依然可以引入，但是需要更改一下调用，或者加个别名</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> test5 <span class="string">&quot;hello/test&quot;</span>  <span class="comment">//别名，不用也可以，不过有的会报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test5.Test() <span class="comment">//这里可以使用test5包的Test方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量的声明有两种方式</p>
<ul>
<li>var 可以使用在任何地方，不可以重复声明<ul>
<li>var [name] [type]</li>
<li>type在变量声明的时候如果有赋值，那么可以省略</li>
<li>var [name] &#x3D; 1</li>
<li>var 在外面的声明，可以在使用之后声明</li>
<li>var 在局部声明，必须在使用之前声明</li>
</ul>
</li>
<li>:&#x3D; 只能使用在函数等代码块里面，当有新的参数在左边声明的时候可以<code>重声明</code></li>
</ul>
<p>比如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> b = a <span class="comment">//b也是string</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;123&quot;</span> <span class="comment">// 报错，因为a已经声明过了</span></span><br><span class="line">a, c := <span class="string">&quot;123&quot;</span>,<span class="string">&quot;456&quot;</span> <span class="comment">//不会报错，因为:=可以重声明，但是必须有一个新变量，比如c</span></span><br><span class="line">a, c := <span class="string">&quot;456&quot;</span>, <span class="string">&quot;123&quot;</span> <span class="comment">//报错，因为a,c都已经声明过了，都是旧变量</span></span><br></pre></td></tr></table></figure>

<h3 id="简单指针变量"><a href="#简单指针变量" class="headerlink" title="简单指针变量"></a>简单指针变量</h3><p>比如声明一个变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br></pre></td></tr></table></figure>

<p>那么会产生一个内存块</p>
<table>
<thead>
<tr>
<th align="left">内存地址</th>
<th align="left">变量内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">001</td>
<td align="left">空</td>
</tr>
</tbody></table>
<p>这个时候可以通过<code>&amp;</code>操作符取地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">println(a) //打印变量内容 空</span><br><span class="line">println(&amp;a) //打印变量内存地址 001</span><br></pre></td></tr></table></figure>

<p>如果我们声明一个指针变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b *<span class="type">string</span></span><br><span class="line">b = &amp;a  <span class="comment">//指针变量只能存储内存地址</span></span><br></pre></td></tr></table></figure>

<p>那么内存块</p>
<table>
<thead>
<tr>
<th align="left">内存地址</th>
<th align="left">变量内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">001</td>
<td align="left">空</td>
</tr>
<tr>
<td align="left">002</td>
<td align="left">001</td>
</tr>
</tbody></table>
<p>这个时候输出，可以通过<code>*</code>操作符取指针的值</p>
<ul>
<li>第一步先找出指针变量的内容001</li>
<li>第二步将001作为内存地址查询对应地址的内容</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">println</span>(b)  <span class="comment">//输出的是变量b的内容001</span></span><br><span class="line"><span class="built_in">println</span>(*b) <span class="comment">//输出的是变量b的内容001作为内存地址的内容空</span></span><br><span class="line"><span class="built_in">println</span>(&amp;b) <span class="comment">//输出的是变量b的内存地址002</span></span><br></pre></td></tr></table></figure>

<h3 id="变量类型转换和类型断言"><a href="#变量类型转换和类型断言" class="headerlink" title="变量类型转换和类型断言"></a>变量类型转换和类型断言</h3><p>可以使用 <code>type</code> 创建新的类型和声明类型的别名</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> astring = <span class="type">string</span>  <span class="comment">//声明一个string类型的别名</span></span><br></pre></td></tr></table></figure>

<p>这个时候<code>astring</code> 和 <code>string</code> 这两个类型是完全一样的，没有任何区别</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;1234&quot;</span></span><br><span class="line">	as = a  <span class="comment">//可以赋值</span></span><br><span class="line">	as = astring(a) <span class="comment">//可以类型转换</span></span><br><span class="line">	as, ok := <span class="keyword">interface</span>&#123;&#125;(a).(astring) <span class="comment">//可以类型断言</span></span><br><span class="line">	fmt.Println(as, ok, as == a) <span class="comment">//可以比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是创建新的类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> astring <span class="type">string</span></span><br></pre></td></tr></table></figure>

<p>这个时候这两个类型没啥关系了，但是因为底层都是string 还是可以进行类型转换的，如果底层类型不是string，那么连转换都不行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;1234&quot;</span></span><br><span class="line">	as = a  <span class="comment">//不可以赋值</span></span><br><span class="line">	as = astring(a) <span class="comment">//可以类型转换</span></span><br><span class="line">	as, ok := <span class="keyword">interface</span>&#123;&#125;(a).(astring) <span class="comment">//类型断言失败</span></span><br><span class="line">	fmt.Println(as, ok, as == a) <span class="comment">//不可以比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>类型转换，比如int8转成int16，但是这种转换只适用于int和int之间，string和string之间转换，还有上面的别名和新类型之间底层类型一致的转换</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b <span class="type">int8</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line"><span class="type">int16</span>(b) <span class="comment">//直接转换</span></span><br></pre></td></tr></table></figure>

<p>如果是高类型像低类型转换，那么直接取后面的位数，高位会舍弃，比如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int16</span> <span class="comment">//</span></span><br><span class="line">a = <span class="number">3000</span> <span class="comment">//这个时候a在计算机存储的二进制 = 0000 1011 1011 1000‬</span></span><br><span class="line">b := <span class="type">uint8</span>(a) <span class="comment">//如果转换成8位int，那么是取后面的8位 1011 1000‬ b = 184</span></span><br></pre></td></tr></table></figure>

<p>当然了，一个int也是可以转成string的，但是会把int值当成一个<code>Unicode</code>值，如果不是一个<code>Unicode</code>能表示的，那么会显示成乱码，比如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b := <span class="number">69</span></span><br><span class="line">t := <span class="type">string</span>(b) <span class="comment">//t = E</span></span><br></pre></td></tr></table></figure>

<h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>类型断言，想要判断一个变量是什么类型，就可以使用类型断言。使用之前需要先转成<code>interface</code>类型，<code>interface</code>是所有类型的爸爸。<br>返回两个值，第一个是断言并转换后的值，第二个值表示是否是这个类型，如果ok &#x3D; true，那么v&#x3D;转换后的值，如果ok &#x3D; false, 那么v &#x3D; nil（空值）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a astring</span><br><span class="line">v, ok := <span class="keyword">interface</span>&#123;&#125;(a).(astring)  <span class="comment">//判断a是不是一个astring类型</span></span><br></pre></td></tr></table></figure>



<h3 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h3><p>切片的底层是一个数组，切片是对数组的引用。</p>
<ul>
<li>数组 [len]string 数组长度固定不可变</li>
<li>切片 []string 切片长度可变，可以看做可变长度的数组</li>
</ul>
<p>数组和切片都有<code>长度length</code>和<code>容量cap</code>的属性</p>
<ul>
<li>数组的长度和容量都是一样的</li>
<li>切片的长度表示现在数据的长度，容量表示底层数组的长度也就是切片的最大长度</li>
</ul>
<p>比如下面，可以看到只修改c[0]的值，但是其他的值也变了，因为是修改了底层数组a的值，所以底层数组和其他引用的值都变了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment">//3长度的数组</span></span><br><span class="line">b := a[<span class="number">0</span>,<span class="number">2</span>] <span class="comment">//2长度 3容量的切片</span></span><br><span class="line">c := a[<span class="number">0</span>,<span class="number">1</span>] <span class="comment">//1长度 3容量的切片</span></span><br><span class="line">d := b[<span class="number">0</span>,<span class="number">1</span>] <span class="comment">//1长度 3容量的切片</span></span><br><span class="line"><span class="comment">// b c d的底层都是数组a</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(a,b,c,d) <span class="comment">//a [100 2 3] b [100 2] c [100] d [100]</span></span><br></pre></td></tr></table></figure>

<h4 id="切片的扩容"><a href="#切片的扩容" class="headerlink" title="切片的扩容"></a>切片的扩容</h4><p>切片的容量变化，如果切片<code>b</code>现在变成一个5长度的会怎么样呢，底层会进行一个<code>扩容</code>，会创建一个新的底层数组，然后一个新的切片，返回这个新的切片给b。</p>
<p>扩容以后，容量如果小于1024，每次容量会乘以2，比如b的容量3乘以2变成6，如果大于1024，那么每次会乘以1.25，但是计算完以后还会进行一个内存对齐的操作。</p>
<h3 id="字典map"><a href="#字典map" class="headerlink" title="字典map"></a>字典map</h3><p>字典是一个hash表，声明方式如下,有着hash的优势，比如key-value是O(1)的复杂度，但是map是无序的，每次遍历的顺序不一定。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span> <span class="comment">//key是int,value是string的map，但是这样声明的map值是nil，并且不能赋值</span></span><br><span class="line">m1[<span class="number">1</span>] = <span class="string">&quot;2&quot;</span> <span class="comment">//报错</span></span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>:<span class="number">1</span>,<span class="number">2</span>:<span class="number">2</span>&#125;  <span class="comment">//key是int,value也是int的map</span></span><br><span class="line">m3 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">5</span>) <span class="comment">//创建一个key是int,value也是int,长度为5的map</span></span><br></pre></td></tr></table></figure>

<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>channel是一个并发安全的类型。channel分为带缓冲区的和不带缓冲区的。声明方式如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 示例1。</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="number">123</span>)</span><br><span class="line">		<span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">//里面可以传输int的channel，默认值nil，如果这样声明会造成一个永久阻塞的channel，后面的代码不会执行</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;ch1:%s&quot;</span>, ch1)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ch1 &lt;- 1</span></span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)  <span class="comment">//声明有一个缓冲区的channel</span></span><br><span class="line">    ch3 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">0</span>)  <span class="comment">//声明不带缓冲区的channel</span></span><br><span class="line">	ch2 &lt;- <span class="number">1</span></span><br><span class="line">	<span class="comment">// ch2 &lt;- 2</span></span><br><span class="line">	<span class="comment">// m1[&quot;2&quot;] = 3</span></span><br><span class="line">	fmt.Println(&lt;-ch2, ch3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把数据传给channel,使用<code>ch2 &lt;- 数据</code>的方式把数据传给ch2这个channel，channel的数据传递全部都是浅拷贝，下面的例子可以发现，修改s的值会使得s1的值也被修改。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">   ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">s1 := []<span class="type">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>&#125;</span><br><span class="line">ch2 &lt;- s1</span><br><span class="line"><span class="comment">// ch2 &lt;- 2</span></span><br><span class="line"><span class="comment">// m1[&quot;2&quot;] = 3</span></span><br><span class="line">s := &lt;-ch2</span><br><span class="line">s[<span class="number">1</span>] = <span class="string">&quot;34&quot;</span></span><br><span class="line">fmt.Println(s, s1)</span><br></pre></td></tr></table></figure>

<p>数据接收使用<code>变量 := &lt;- ch2</code> 来接收ch2的数据到一个变量中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := &lt;- ch2</span><br></pre></td></tr></table></figure>

<h4 id="单向channel"><a href="#单向channel" class="headerlink" title="单向channel"></a>单向channel</h4><p>单向channel可以限制函数的行为，比如<code>chan&lt;-</code>类型的只能发送数据到channel中，<code>&lt;-chan</code>类型的只能从channel中获取数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getChan</span><span class="params">(ch &lt;-<span class="keyword">chan</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//函数里面只能从 ch 这个 channel中获取数据而无法发送数据，这样限制了这个函数里面的行为</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setChan</span><span class="params">(ch <span class="keyword">chan</span>&lt;-)</span></span> &#123;</span><br><span class="line">    <span class="comment">//函数里面只能往 ch 这个 channel中发送数据而无法获取数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><code>go</code>中的函数是<code>一等公民</code>可以作为type类型，可以作为参数，可以作为返回值，可以赋值给变量,可以和nil做比较等等</p>
<p>函数的声明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(arg1 <span class="type">int</span>, arg2 <span class="type">int</span>)</span></span> (r <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的类型，声明一个类型 afunc afunc的底层类型是一个接受一个string参数，返回一个int参数和一个error类型参数的函数，<code>函数签名</code>是函数的参数列表和返回值列表，如果参数列表的类型一致并且返回值列表的参数类型一致就可以认为是一样的函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> afunc <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) <span class="comment">//声明一个类型 afunc afunc的底层类型是一个接受一个string参数，返回一个int参数和一个error类型参数的函数</span></span><br><span class="line"><span class="keyword">var</span> a afunc <span class="comment">//可以声明一个变量，类型是 afunc 的变量</span></span><br><span class="line">a = name <span class="comment">//可以把函数签名一致的函数赋值给这个函数变量</span></span><br><span class="line">a(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">//等于 name(1,2)</span></span><br></pre></td></tr></table></figure>

<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构体的声明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> as <span class="keyword">struct</span>&#123; <span class="comment">//声明一个名称叫 as 的结构体</span></span><br><span class="line">    a <span class="type">string</span> <span class="comment">//as 有 一个string的属性 a</span></span><br><span class="line">    b <span class="type">int</span> <span class="comment">//一个int的属性b</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明一个属于as结构体的方法String</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this as)</span></span> String() <span class="type">string</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(this.a) <span class="comment">//访问as的属性a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的声明可以看出来，可以把struct简单的类比成class，这个as的结构体有两个属性，一个方法</p>
<p>使用结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	as1 := as&#123; <span class="comment">//初始化as这个结构体</span></span><br><span class="line">		a: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">		b: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    as2 := as&#123;&#125; <span class="comment">//也可以不初始化</span></span><br><span class="line">	fmt.Println(as1, as2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体的组合，也可以类比成class的继承，不过组合比继承更有优势。组合进来以后，asT结构体就拥有了as类的属性和方法，但是由于asT有a，as也有a属性，asT的就把as的覆盖了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> asT <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="type">string</span> <span class="comment">//覆盖了as的a属性</span></span><br><span class="line">    as <span class="comment">//把as组合，嵌入进asT结构体，可以类比成 asT类继承了as类</span></span><br><span class="line">&#125;</span><br><span class="line">as2 := asT&#123;&#125;</span><br><span class="line">as2.a = <span class="string">&quot;3&quot;</span> <span class="comment">//修改的是as2的a属性</span></span><br><span class="line">as2.as.a = <span class="string">&quot;2&quot;</span> <span class="comment">//修改的是as2.as.a属性 可以类比成修改了父类的a属性</span></span><br><span class="line">as2.String() <span class="comment">//可以调用as2.String方法，因为as有这个方法，他组合进来也拥有了这个方法</span></span><br><span class="line"><span class="comment">//这样可以定义asT的String方法，这样的话上面的代码就会访问这个方法了，可以类比成重写了String方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this asT)</span></span> String() <span class="type">string</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(this.a) <span class="comment">//访问asT的属性a</span></span><br><span class="line">&#125;</span><br><span class="line">as2.as.String() <span class="comment">//就算覆盖了，依然可以这样调用as的String方法</span></span><br></pre></td></tr></table></figure>

<p>结构体可以组合多个结构体，也可以类比成多继承。但是这样有一个问题，比如组合的两个结构体内有同样名称的属性或者方法就会报错。声明的时候不会报错，只有使用的时候会报错，因为不知道使用哪个，如果指定相应的结构体进行使用就不会报错了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> asD <span class="keyword">struct</span>&#123;</span><br><span class="line">    as</span><br><span class="line">    asT</span><br><span class="line">&#125;</span><br><span class="line">as3 := asD&#123;&#125;</span><br><span class="line">as3.a := <span class="string">&quot;3&quot;</span> <span class="comment">//报错</span></span><br><span class="line">as3.as.a := <span class="string">&quot;4&quot;</span> <span class="comment">//正常</span></span><br></pre></td></tr></table></figure>

<p>还有一种方法，比如在新的结构体中定义一个同名的属性，就会覆盖其他的，所以就不会报错了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> asD <span class="keyword">struct</span>&#123;</span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">    as</span><br><span class="line">    asT</span><br><span class="line">&#125;</span><br><span class="line">as3 := asD&#123;&#125;</span><br><span class="line">as3.a := <span class="number">3</span> <span class="comment">//正常</span></span><br></pre></td></tr></table></figure>

<p>还有结构体中的覆盖是通过<code>名称</code>来判断覆盖的，跟数据类型没有关系，方法的覆盖也是一样，跟参数列表和返回值没有关系</p>
<p>结构体中指针的使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this asT)</span></span> String() <span class="type">string</span>&#123;</span><br><span class="line">    this.a = <span class="number">5</span> <span class="comment">//这里不可以赋值，因为this是一个值类型，这个赋值并不会真正的改变asT结构体的值，只是会改变当前this变量的值而已</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(this.a) <span class="comment">//访问asT的属性a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *asT)</span></span> String() <span class="type">string</span>&#123;</span><br><span class="line">    this.a = <span class="number">5</span> <span class="comment">//这里可以赋值，因为this是一个指针类型</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(this.a) <span class="comment">//访问asT的属性a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是有定义的时候有区别，因为在调用的时候<code>go</code>会自动转换，比如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">asT.String() <span class="comment">//如果接受的是一个*asT类型的值，这里go会转换成(&amp;asT).String()的调用</span></span><br></pre></td></tr></table></figure>



<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是<code>interface</code>和一般语言的接口没啥区别，但是go的接口是一种<code>无侵入式</code>实现，比如下面的代码我们声明了一个ai的接口，声明了一个as的结构体，这个结构体的方法和ai的方法一样，那么就算实现了ai的接口，可以赋值给ai接口类型的变量。</p>
<p>这里需要<code>方法名称</code>和<code>方法签名</code>这两个全部一致才算实现了这个接口，还有要注意，*as代表SetName是 *as的方法而不是as的方法，所以我们只能把&amp;as1赋值过去，如果赋值as1会报错。因为as1只有一个GetName方法</p>
<p>接口变量具有三个属性</p>
<ul>
<li>静态类型 ai</li>
<li>动态类型 赋值时候确定，比如赋值了&amp;as1，那么动态类型就是*as</li>
<li>动态值 也就是&amp;as1</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ai <span class="keyword">interface</span> &#123; <span class="comment">//声明一个名称叫 ai 的接口</span></span><br><span class="line">	SetName(<span class="type">string</span>)  <span class="comment">//该接口有一个SetName方法</span></span><br><span class="line">	GetName() <span class="type">string</span> <span class="comment">//有一个GetName方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> as <span class="keyword">struct</span> &#123; <span class="comment">//声明一个名称叫 as 的结构体</span></span><br><span class="line">	a <span class="type">string</span> <span class="comment">//as 有 一个string的属性 a</span></span><br><span class="line">	b <span class="type">int</span>    <span class="comment">//一个int的属性b</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个属于as结构体的方法 GetName</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this as)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(this.a) <span class="comment">//访问as的属性a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个属于as结构体的方法 SetName</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *as)</span></span> SetName(name <span class="type">string</span>) &#123;</span><br><span class="line">	this.a = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ai1 ai</span><br><span class="line">	as1 := as&#123;&#125;</span><br><span class="line">	ai1 = &amp;as1</span><br><span class="line">	fmt.Println(as1, ai1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口类型的nil值，接口只有声明的时候和赋值nil字面量的时候才是真正的nil值，看下面，输出结果a1是2，因为ai1不是真正的nil,ai1的动态值是nil，但是动态类型是*as，所以ai1不是nil</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">var</span> as2 *as <span class="comment">//as2是nil</span></span><br><span class="line">ai1 = as2</span><br><span class="line">   <span class="keyword">var</span> a1 <span class="type">int</span></span><br><span class="line"><span class="keyword">if</span> ai1 == <span class="literal">nil</span> &#123; <span class="comment">//ai1不是nil</span></span><br><span class="line">	a1 = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	a1 = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(as1, ai1, a1)</span><br></pre></td></tr></table></figure>



<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>goroutine 是一个 go的用户级线程，也叫协程。</p>
<p>使用的话就是下面这样 <code>go</code> 后面跟上协程需要执行的函数代码。首先启动go程序的时候，会启动一个主进程。然后主进程生成一个主线程来执行go程序的main函数。执行的时候是一个for循环。</p>
<ul>
<li>执行第一次循环的时候i &#x3D; 0</li>
<li>然后执行到了<code>go func</code>代码</li>
<li>由go的runtime查找是否有空闲的协程。如果没有那么创建一个协程。</li>
<li>然后把<code>go func</code>的代码放入创建好的协程。</li>
<li>最后把这个包含了<code>go func</code>代码的协程放入协程的等待队列中</li>
<li>直到有空闲的线程，从等待队列中取出一个协程，执行这个协程的代码</li>
</ul>
<p>可以看到下面这段代码的执行结果，是什么也不会发生。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为在for循环执行以后goroutine的代码还没有得到执行机会的时候，主线程main函数执行完了。那么这个时候系统的主线程就会关闭了，主进程也会关闭了。所以协程并没有执行。</p>
<p>看下面的代码，增加了定时器，这个时候会输出10个10，因为主线程执行到定时器的时候线程挂起，然后协程就有执行的时间了，但是协程开始执行的时候，for循环已经执行完了，这个时候变量i的值是10，所以10个协程打印出来的变量i的值都是10</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下面的代码，go func(i int){}(i)，增加了入参i int类型，并且在调用的时候把变量i传入了进去，那这个时候呢，执行的结果就是输出0-9的乱序，因为我们无法保证协程的执行顺序，但是由于传了当时的变量i，而go是浅拷贝，所以协程中的变量i的值被固定了。 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>for循环和别的语言一样</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有 range 可以循环数组，切片，map。这里range会复制一个 numbers3 来进行循环，也就是说如果numbers3是数组，那么修改numbers3[0] 的值不会影响到 numbers3[0] 的值，因为数组是值类型。如果是切片那么会影响到。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">   numbers2 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">numbers3 := numbers2[<span class="number">0</span>:<span class="built_in">len</span>(numbers2)]</span><br><span class="line">   maxIndex2 := <span class="built_in">len</span>(numbers2) - <span class="number">1</span></span><br><span class="line">   <span class="comment">// i v对应key value，也可以只有一个key，没有value for i := range numbers3 &#123;&#125;</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> numbers3 &#123; <span class="comment">//range 后面跟一个切片或者数组,map</span></span><br><span class="line">	<span class="keyword">if</span> i == maxIndex2 &#123;</span><br><span class="line">		numbers3[<span class="number">0</span>] += v</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		numbers3[i+<span class="number">1</span>] += v</span><br><span class="line">       &#125;</span><br><span class="line">       v = <span class="number">1</span> <span class="comment">//这里的v因为是int类型，所以修改他的值不会影响到numbers3切片里面的值</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(numbers2, numbers3)</span><br></pre></td></tr></table></figure>

<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>switch语句不需要使用 break 了，因为go的switch只执行一个case,并且case后面可以跟多个结果，用逗号分隔，只要命中一个结果就执行这个case，所以case后面的结果也不能重复。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line"><span class="keyword">switch</span> <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>:</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>, <span class="number">4</span>:</span><br><span class="line">	a = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a) <span class="comment">//输出2</span></span><br></pre></td></tr></table></figure>

<p>如果case后面重复，那么会报错</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">switch</span> <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>:</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>: <span class="comment">//报错</span></span><br><span class="line">	a = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为switch结果和case结果会进行判等的，所以他们两个的类型要是一样的，不然也会报错</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">switch</span> <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>:</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;21&quot;</span>, <span class="number">3</span>, <span class="number">4</span>: <span class="comment">//报错</span></span><br><span class="line">	a = <span class="number">2</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">uint8</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">switch</span> b &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>:</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>, <span class="number">40000</span>: <span class="comment">//报错，因为40000 不是uint8能表示的</span></span><br><span class="line">	a = <span class="number">2</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">var</span> b <span class="type">uint8</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">switch</span> <span class="number">40000</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>:</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>, b:  <span class="comment">//位置换了也是报错</span></span><br><span class="line">	a = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch十七--ES-bool查询</title>
    <url>/ES-%E5%A4%9A%E5%AD%97%E6%AE%B5bool%E6%9F%A5%E8%AF%A2.html</url>
    <content><![CDATA[<h1 id="bool查询"><a href="#bool查询" class="headerlink" title="bool查询"></a>bool查询</h1><p>一个bool查询里面可以包含多个查询子句</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">must</td>
<td align="left">必须匹配，贡献算分</td>
</tr>
<tr>
<td align="left">should</td>
<td align="left">选择性匹配，算分</td>
</tr>
<tr>
<td align="left">must_not</td>
<td align="left">filter context 查询子句，必须不能匹配，不算分</td>
</tr>
<tr>
<td align="left">filter</td>
<td align="left">filter context 必须匹配,但是不算分</td>
</tr>
</tbody></table>
<ul>
<li>子查询可以任意顺序出现</li>
<li>可以嵌套多个查询</li>
<li>如果bool查询中，没有must条件，should中必须满足一个查询</li>
<li>should是一个数组</li>
</ul>
<p>查询语句的结构，会对相关度算分产生影响</p>
<ul>
<li>同一层级下的竞争字段，具有相同的权重</li>
<li>通过嵌套bool查询，可以改变对算分的影响</li>
</ul>
<h2 id="单字符串-多字段查询"><a href="#单字符串-多字段查询" class="headerlink" title="单字符串 多字段查询"></a>单字符串 多字段查询</h2><p>可以通过 <code>bool</code> 的 <code>should</code> 来实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST test_home/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;bool&quot;:&#123;</span><br><span class="line">      &quot;should&quot;:[</span><br><span class="line">        &#123;&quot;match&quot;:&#123;&quot;title&quot;:&quot;php&quot;&#125;&#125;</span><br><span class="line">        &#123;&quot;match&quot;:&#123;&quot;body&quot;:&quot;php&quot;&#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样实现的算分过程可能不是我们想要的,算分过程如下</p>
<ul>
<li>查询 should 语句中的两个查询</li>
<li>加和两个查询的评分</li>
<li>乘以匹配语句的总数</li>
<li>除以所有语句的总数</li>
</ul>
<p>我们还可以使用最高算分 <code>dis_max</code>- <code>queries</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST test_home/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;dis_max&quot;:&#123;</span><br><span class="line">      &quot;queries&quot;:[</span><br><span class="line">        &#123;&quot;match&quot;:&#123;&quot;title&quot;:&quot;php&quot;&#125;&#125;</span><br><span class="line">        &#123;&quot;match&quot;:&#123;&quot;body&quot;:&quot;php&quot;&#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是有的时候，最高评分是一样的，那怎么办呢，可以通过<code>tie_breaker</code>参数来调整</p>
<ul>
<li>获得最佳匹配语句的评分</li>
<li>将其他匹配语句的评分与 <code>tie_breaker</code>相乘</li>
<li>对以上评分求和并规范化</li>
<li>tie_breaker 是一个 0 - 1的浮点数，0代表最佳匹配，1代表所有语句同等重要。</li>
</ul>
<h3 id="三种场景"><a href="#三种场景" class="headerlink" title="三种场景"></a>三种场景</h3><ul>
<li>最佳字段 best_fields 相当于 dis_max 查询<ul>
<li>当字段之间相互竞争，又相互关联。例如 title 和 body 这样的，评分来自最佳字段</li>
</ul>
</li>
<li>多数字段 most_fields<ul>
<li>处理英文内容时：一种常见的手段是，在主字段，抽取词干，加入同义词，以匹配更多的文档。相同的文本，加入子字段，以提供更加精确的匹配。其他字段作为匹配文档提高相关度的信号。匹配字段越多则越好</li>
</ul>
</li>
<li>混合字段 cross field<ul>
<li>对于某些实体，例如人名，地址，图书，需要在多个字段中确定信息，单个字段只能作为整体的一部分。希望在任何这些列出的字段中找到尽可能多的词</li>
</ul>
</li>
</ul>
<h4 id="multi-match"><a href="#multi-match" class="headerlink" title="multi_match"></a>multi_match</h4><blockquote>
<p>极客时间 ES 学习笔记</p>
</blockquote>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch十六--ES-搜索相关性算分</title>
    <url>/ES-%E6%90%9C%E7%B4%A2%E7%9B%B8%E5%85%B3%E6%80%A7%E7%AE%97%E5%88%86.html</url>
    <content><![CDATA[<h1 id="搜索相关性算分"><a href="#搜索相关性算分" class="headerlink" title="搜索相关性算分"></a>搜索相关性算分</h1><p>ES 会对搜索结果的相关性进行一个算分，算分结果放到<code>_score</code> 字段中。</p>
<p>算分是为了排序，ES5之前使用<code>TF-IDF</code>算法进行算分，之后使用<code>BM25</code>算法</p>
<h2 id="词频-TF"><a href="#词频-TF" class="headerlink" title="词频 (TF)"></a>词频 (TF)</h2><ul>
<li><p>term frequency: 检索词在一篇文档中出现的频率</p>
<ul>
<li>检索词出现的次数除以文档的总字数</li>
</ul>
</li>
<li><p>相关性：简单将搜索中每一个词的TF进行想加</p>
<ul>
<li>TF(区块链) + TF(的) + TF(作用)</li>
</ul>
</li>
<li><p>stop word： 没什么作用的词</p>
<ul>
<li><code>的</code> 可能会出现多次，但是他对于相关性并没有什么作用，应该不考虑他的词频， 可以作为一个 stop word</li>
</ul>
</li>
</ul>
<h2 id="逆文档频率-IDF"><a href="#逆文档频率-IDF" class="headerlink" title="逆文档频率 (IDF)"></a>逆文档频率 (IDF)</h2><ul>
<li><p>DF:检索词在所有文档中出现的频率</p>
<ul>
<li>区块链 在相对较少的文档中出现</li>
<li>作用 在相对较多的文档</li>
<li>的 作为 stop word 在大量的文档中出现</li>
</ul>
</li>
<li><p>inverse document frequency: 简单说 &#x3D; log(存储的全部文档数&#x2F;检索词出现过的文档数)</p>
</li>
<li><p>TF-IDF 就是将 TF 求和变成了加权求和</p>
</li>
</ul>
<p>比如，你ES里总共存储了10万条<code>职位信息</code>, 你检索 <code>php</code>，出现 php 的职位数量是1万，那么IDF &#x3D; log(10万&#x2F;1万) &#x3D; log(10) &#x3D; 1</p>
<ul>
<li>TF-IDF 就是算出分词后所有词的TF和 IDF 并进行处理，比如<code>区块链的作用</code> &#x3D; TF(区块链) * IDF(区块链) + TF(的) * IDF(的) + TF(作用) * IDF(作用)</li>
</ul>
<h2 id="BM25"><a href="#BM25" class="headerlink" title="BM25"></a>BM25</h2><p>BM25对之前的TF-IDF 算法进行了一个优化，当TF的词出现的越来越多的时候，如果是TF-IDF 算法，那么分值会增加很多，而如果是 BM25 算法，则会趋于一个极限。</p>
<h3 id="boosting"><a href="#boosting" class="headerlink" title="boosting"></a>boosting</h3><p><code>boosting</code>可以对算分结果进行影响</p>
<p>正常搜索<code>php首席</code>的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP首席架构师</span><br><span class="line">PHP架构师</span><br><span class="line">PHP架构师001</span><br><span class="line">首席软件架构师</span><br><span class="line">首席软件架构师</span><br><span class="line">首席科学家（科研副总经理）</span><br><span class="line">首席科学家（工业传动技术）</span><br><span class="line">商家端资深软件开发工程师（Go/PHP）</span><br></pre></td></tr></table></figure>

<p>如果我们想降低<code>首席</code>这个词在搜索结果中的算分占比，可以使用<code>boosting</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET job_ik/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;boosting&quot;: &#123;  //boosting 关键字</span><br><span class="line">      &quot;positive&quot;: &#123;  //positive 关键字</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;job_name&quot;: &quot;php&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;negative&quot;: &#123;  //negative 关键字</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;job_name&quot;: &quot;首席&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;negative_boost&quot;: 0.2   // 0 - 1，降低首席排序，1-100，提高首席排序</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>降低后的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP架构师</span><br><span class="line">PHP架构师001</span><br><span class="line">商家端资深软件开发工程师（Go/PHP）</span><br><span class="line">PHP首席架构师</span><br></pre></td></tr></table></figure>

<p>如果把<code>negative_boost</code>提升为2，那么结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP首席架构师</span><br><span class="line">PHP架构师</span><br><span class="line">PHP架构师001</span><br><span class="line">商家端资深软件开发工程师（Go/PHP）</span><br></pre></td></tr></table></figure>


<blockquote>
<p>极客时间 ES 学习笔记</p>
</blockquote>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch十五--ES-基于词项和基于全文的查询</title>
    <url>/ES-%E5%9F%BA%E4%BA%8E%E8%AF%8D%E9%A1%B9%E5%92%8C%E5%9F%BA%E4%BA%8E%E5%85%A8%E6%96%87%E7%9A%84%E6%9F%A5%E8%AF%A2.html</url>
    <content><![CDATA[<h1 id="term-query"><a href="#term-query" class="headerlink" title="term query"></a>term query</h1><p><code>term</code>是表达语义的最小单位 ,搜索和利用统计语言模型进行自然语言处理都需要处理 term</p>
<p>特点</p>
<ul>
<li>term level query: term query&#x2F;range query&#x2F; exists query &#x2F; prefix query &#x2F; wildcard query</li>
<li>在ES里面，term 查询不做分词，把term查询作为一个整体词汇进行查询，进行一个精确匹配，并对匹配结果进行算分</li>
<li>可以通过  <code>Constant Score</code> 将查询转换成一个 <code>filtering</code> ，避免算分，并利用缓存，提高性能</li>
</ul>
<h2 id="term-查询"><a href="#term-查询" class="headerlink" title="term 查询"></a>term 查询</h2><p>我们现在有数据如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;test&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;ID10032_1194_1634175220_535254&quot;,</span><br><span class="line">  &quot;_score&quot; : 6.151313,</span><br><span class="line">  &quot;_source&quot; : &#123;</span><br><span class="line">    &quot;user_id&quot; : 10032,</span><br><span class="line">    &quot;consultant_company_id&quot; : 1194,</span><br><span class="line">    &quot;type&quot; : 9,</span><br><span class="line">    &quot;source&quot; : 1,</span><br><span class="line">    &quot;operation_at&quot; : 1634175220,</span><br><span class="line">    &quot;create_time&quot; : &quot;2021-10-14 09:33:40&quot;,</span><br><span class="line">    &quot;update_time&quot; : &quot;2021-10-14 09:33:40&quot;,</span><br><span class="line">    &quot;login_type&quot; : 3,</span><br><span class="line">    &quot;true_name&quot; : &quot;张三&quot;,</span><br><span class="line">    &quot;id&quot; : &quot;ID10032_1194_1634175220_535254&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们使用<code>match</code>查询</p>
<p>这里<code>ID10032_1194_1634175220_535254</code>大写<code>id10032_1194_1634175220_535254</code>小写都可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET test_user_action_detail/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;id&quot;: &quot;ID10032_1194_1634175220_535254&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都可以得到搜索结果</p>
<p>如果使用 <code>term</code> 查询,<code>id10032_1194_1634175220_535254</code>可以查询到数据，但是如果是<code>ID10032_1194_1634175220_535254</code>大写，那么<code>term</code> 查询就查询不到数据了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET test_user_action_detail/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;id&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;id10032_1194_1634175220_535254&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因在于 该 id 字段的 <code>mapping</code> 是 text&#x2F;keyword</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;id&quot; : &#123;</span><br><span class="line">  &quot;type&quot; : &quot;text&quot;,</span><br><span class="line">  &quot;fields&quot; : &#123;</span><br><span class="line">    &quot;keyword&quot; : &#123;</span><br><span class="line">      &quot;type&quot; : &quot;keyword&quot;,</span><br><span class="line">      &quot;ignore_above&quot; : 256</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>text</code>数据类型会进行分词，也就是大写会被分词成小写。所以text的id数据实际会变成小写<code>id10032_1194_1634175220_535254</code>，而<code>term</code>查询区分大小写，会进行精确匹配，如果只有搜索小写才能搜索出来结果。如果不想进行分词，那么可以使用<code>keyword</code>字段类型搜索，把<code>term</code>查询语句改成下面这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET test_user_action_detail/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;id.keyword&quot;: &#123;   //这里使用keyword字段查询</span><br><span class="line">        &quot;value&quot;: &quot;ID10032_1194_1634175220_535254&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以得到结果了，因为<code>keyword</code>不进行分词，所以插入的<code>ID10032_1194_1634175220_535254</code>就还是<code>ID10032_1194_1634175220_535254</code>，不过注意，这样的话小写<code>id10032_1194_1634175220_535254</code>就搜索不到结果了</p>
<h2 id="filter-不进行算分"><a href="#filter-不进行算分" class="headerlink" title="filter 不进行算分"></a>filter 不进行算分</h2><p>对于term查询来说，其实没必要算分，因为是精确搜索，那么就可以使用<code>filter</code>查询来避免算分并可以有效利用缓存，可以提升性能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET test_user_action_detail/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;constant_score&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;term&quot;: &#123;</span><br><span class="line">          &quot;id.keyword&quot;: &#123;</span><br><span class="line">            &quot;value&quot;: &quot;ID10032_1194_1634175220_535254&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于全文查询"><a href="#基于全文查询" class="headerlink" title="基于全文查询"></a>基于全文查询</h2><ul>
<li><p>match query  &#x2F; match phrase query &#x2F; query string query</p>
</li>
<li><p>特点</p>
<ul>
<li>索引和搜索都会进行分词，查询字符串先传递到一个合适的分词器，然后生成一个供查询的词项列表</li>
<li>查询时，会先分词，然后对每个词都进行查询，最终将结果进行合并。并为每个文档生成一个算分。</li>
<li>例如查询<code>matrx reloaded</code> 会查询到 <code>matrx</code> 和 <code>reloaded</code>两个词的搜索结果，然后进行合并。</li>
</ul>
</li>
</ul>
<h2 id="range-query"><a href="#range-query" class="headerlink" title="range query"></a>range query</h2><p>range 可以进行范围查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">range: &#123;</span><br><span class="line">  created_at: &#123;</span><br><span class="line">    gt:&#x27;1889237773&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="exists-query"><a href="#exists-query" class="headerlink" title="exists query"></a>exists query</h2><p>可以判断值是否存在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exists:&#123;</span><br><span class="line">  field:&quot;created_at&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理多值字段"><a href="#处理多值字段" class="headerlink" title="处理多值字段"></a>处理多值字段</h2><p>比如有一个数组 <code>[北京市，上海市]</code></p>
<p>如果我们使用<code>term</code>查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET test_user_action_detail/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;city.keyword&quot;: &#123; </span><br><span class="line">        &quot;value&quot;: &quot;北京市&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>就会搜索出现上面的数据，因为对于数组来说，term 查询是只要包含那么就会搜索出来。</p>
<blockquote>
<p>极客时间 ES 学习笔记</p>
</blockquote>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx二 -- 初识nginx</title>
    <url>/nginx%E4%BA%8C.html</url>
    <content><![CDATA[<h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><h2 id="nginx的场景"><a href="#nginx的场景" class="headerlink" title="nginx的场景"></a>nginx的场景</h2><p>三个主要场景</p>
<ul>
<li>静态资源：通过本地文件系统提供服务</li>
<li>反向代理：nginx的强大性能，缓存，负载均衡</li>
<li>API服务：openresty</li>
</ul>
<h2 id="nginx的优点"><a href="#nginx的优点" class="headerlink" title="nginx的优点"></a>nginx的优点</h2><ul>
<li>高并发，高性能</li>
<li>可扩展性好</li>
<li>高可靠性</li>
<li>热部署</li>
<li>BSD许可证</li>
</ul>
<h2 id="nginx的组成"><a href="#nginx的组成" class="headerlink" title="nginx的组成"></a>nginx的组成</h2><ul>
<li>nginx二进制可执行文件：由各模块原码编译出的一个文件</li>
<li>nginx.conf:控制nginx行为</li>
<li>access.log</li>
<li>error.log</li>
</ul>
<h2 id="vim-nginx语法高亮"><a href="#vim-nginx语法高亮" class="headerlink" title="vim nginx语法高亮"></a>vim nginx语法高亮</h2><p>如果想要vim操作nginx的时候有语法高亮，那么只需要把nginx文件夹带的vim配置文件复制到自己的vim配置文件下面就可以了</p>
<p>找到nginx源码目录，注意这里是源码目录，下载的tar包解压出来的目录，而不是编译安装后的目录，下面有一个<code>contrib</code>文件夹，这个文件夹里面有<code>vim</code>文件夹，把这个里面的配置文件都复制一下就好了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -r nginx/contrib/vim/ ~/.vim/</span><br></pre></td></tr></table></figure>

<h2 id="已安装的nginx-增加模块"><a href="#已安装的nginx-增加模块" class="headerlink" title="已安装的nginx 增加模块"></a>已安装的nginx 增加模块</h2><p>首先到达源码目录<code>cd /usr/local/src/nginx1.19</code></p>
<p>然后开始编译</p>
<ul>
<li>–prefix 参数代表你的nginx安装目录，如果是已安装的nginx，那么这个目录就选择已安装的目录，没有安装的可以随便选想安装到的目录</li>
<li>–with 开头的代表你想开启的模块</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ./configure --with-file-aio --with-http_ssl_module --with-http_v2_module --with-http_realip_module --prefix=/usr/local/src/nginx</span><br></pre></td></tr></table></figure>

<p>然后执行<code>make</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo make</span><br></pre></td></tr></table></figure>

<p>接下来就可以复制nginx源文件了，这里只执行make，不需要执行make install</p>
<p>现在假设你已经在nginx源码目录了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ./objs  //移动到objs目录下</span><br><span class="line">cp nginx /usr/local/src/nginx/sbin/    //把objs目录下的nginx复制到你原来的nginx安装目录下面的sbin目录替换原来的nginx源文件</span><br></pre></td></tr></table></figure>

<p>如果是新安装，那么不需要复制，直接执行 sudo make install 就可以了</p>
<h2 id="配置语法"><a href="#配置语法" class="headerlink" title="配置语法"></a>配置语法</h2><ul>
<li>配置文件由指令和指令块构成</li>
<li>每条指令以;分号结尾，指令与参数间用空格分隔</li>
<li>指令块以{}大括号将多条指令组织在一起</li>
<li>include 语句允许组合多个配置文件以提升可维护性</li>
<li>使用 #井号添加注释，提高可读性</li>
<li>使用 $符号作为变量</li>
<li>部分指令的参数支持正则表达式</li>
</ul>
<h2 id="http配置的指令块"><a href="#http配置的指令块" class="headerlink" title="http配置的指令块"></a>http配置的指令块</h2><ul>
<li>http</li>
<li>server</li>
<li>upstream</li>
<li>location</li>
</ul>
<h2 id="nginx-命令行"><a href="#nginx-命令行" class="headerlink" title="nginx 命令行"></a>nginx 命令行</h2><ul>
<li>帮助 -h</li>
<li>指定配置文件 -c</li>
<li>指定配置指令 -g</li>
<li>指定运行目录 -p</li>
<li>发送信号 -s</li>
<li>测试配置文件语法 -t</li>
<li>打印版本信息 -v -V</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx             //启动</span><br><span class="line">nginx -s reload   // 重启</span><br><span class="line">nginx -s quit    //优雅停止</span><br><span class="line">nginx -s stop    //直接停止</span><br><span class="line">nginx -s reopen  //重新开始记录日志</span><br></pre></td></tr></table></figure>

<h4 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h4><p>当你需要升级nginx或者增加模块的时候可以使用热部署的方式平滑过渡，不需要重启</p>
<p>查看现在nginx进程的id</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef|grep nginx</span><br></pre></td></tr></table></figure>

<p>对现在的nginx进程发送<code>USR2</code>信号进行热部署</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -USR2 id</span><br></pre></td></tr></table></figure>

<p>现在可以看到新的nginx进程和老的nginx进程都存在了，这个时候我们需要让老的nginx进程平滑退出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -WINCH id</span><br></pre></td></tr></table></figure>

<p>接下来就可以看到老的nginx的worker进程全部平滑退出了，但是老的master进程还在，这是为了防止新的有问题，还可以退回老的</p>
<p>如果接下来新的有问题，那么我们退回老的，发送<code>HUP</code>信号，而不是直接reload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -HUP id</span><br></pre></td></tr></table></figure>

<p>接下来可以看到老的worker进程都起来了</p>
<p>如果热部署后没有问题的话，那么我们直接删除老的master进程就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -QUIT id</span><br></pre></td></tr></table></figure>

<h4 id="日志切割"><a href="#日志切割" class="headerlink" title="日志切割"></a>日志切割</h4><p>如果我们觉得日志太大可以进行日志切割，一种是发送<code>reopen</code>信号，还有一种是发送<code>USR1</code>信号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nginx -s reopen</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -USR1 id</span><br></pre></td></tr></table></figure>

<p>但是注意切割之前要把之前的日志备份一下，不然就会被删除啦</p>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理配置在<code>http</code>代码块中</p>
<p>首先通过<code>upstream</code>配置反向代理的服务器</p>
<p>test 是一个名称，可以随便取</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">upstream</span> test&#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span>     <span class="comment"># 上游服务器的地址，可以写多个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>proxy_pass</code> 进行反向代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://test;   # 这里填写上面的upstream名字</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候我们访问80端口实际上访问的是8080端口</p>
<h4 id="反向代理的缓存"><a href="#反向代理的缓存" class="headerlink" title="反向代理的缓存"></a>反向代理的缓存</h4><p>反向代理之后还可以在反向代理服务器做缓存</p>
<p>在<code>nginx.conf</code>文件的<code>http</code>代码块中设置缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置缓存路径 /tmp/nginxCache 缓存名称 my_cache</span><br><span class="line">proxy_cache_path /tmp/nginxCache levels=1:2 keys_zone=my_cache:10m max_size=10g inactive=60m use_temp_path=off;</span><br></pre></td></tr></table></figure>

<p>接下来在我们的反向代理<code>server/location</code>代码块里面使用这个缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_cache my_cache;   # 使用上面定义的缓存</span><br><span class="line">    proxy_cache_key $host$uri$is_args$args;  # 缓存的key值，根据host uri和参数来做key</span><br><span class="line">    proxy_cache_valid 200 304 302 1d;   # 缓存200 304 302状态 缓存时间1d = 1天</span><br><span class="line">    proxy_pass http://test;   # 这里填写上面的upstream名字</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="goaccess-日志可视化"><a href="#goaccess-日志可视化" class="headerlink" title="goaccess 日志可视化"></a>goaccess 日志可视化</h2><p>goaccess 是一个c语言写的日志可视化工具</p>
<p>直接编译安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://tar.goaccess.io/goaccess-1.2.tar.gz</span><br><span class="line">tar -xzvf goaccess-1.2.tar.gz</span><br><span class="line">cd goaccess-1.2/</span><br><span class="line">./configure --enable-utf8</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>然后就可以启动了，直接启动就可以</p>
<p>指定日志文件路径 <code>/usr/local/src/nginx/logs/access.log</code> -o 输出到某个html文件中 –real-time-html 代表实时刷新, –log-format 代表日志格式 ，–daemonize 代表守护进程后台执行 仅在 开启了 –real-time-html 实时刷新有效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goaccess /usr/local/src/nginx/logs/access.log -o ~/wwwroot/goaccess.html --real-time-html --log-format=COMBINED --daemonize</span><br></pre></td></tr></table></figure>

<p>这里要注意，如果开启了  –real-time-html 实时刷新，那么会启动一个 socket 进程监听 7890 端口，所以 7890 端口要开放才行</p>
<p>可以配置 nginx 文件访问这个输出的 html 文件了，就可以看到一个可视化界面了</p>
<h2 id="ssl"><a href="#ssl" class="headerlink" title="ssl"></a>ssl</h2><p>ssl(Secure Sosckets Layer)<br>tls(Transport Layer Security)</p>
<ul>
<li>1995年-ssl3.0</li>
<li>1999 - tls1.0</li>
<li>2006 - tls1.1</li>
<li>2008 - tls1.2</li>
<li>2018 - tls1.3</li>
</ul>
<p>ssl&#x2F;tls 运行在 <code>ISO7层模型的表示层中</code>，而http协议运行在表示层的上层<code>应用层</code>。在http的数据传输到<code>表示层</code>以后，ssl&#x2F;tls就会对数据进行加密</p>
<ul>
<li>握手</li>
<li>交换秘钥</li>
<li>告警</li>
<li>对称加密的应用数据</li>
</ul>
<p>tls安全套件</p>
<blockquote>
<p>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</p>
</blockquote>
<ul>
<li>tls代表tls加密</li>
<li>ECDHE 代表秘钥交换算法</li>
<li>RSA 代表身份验证算法</li>
<li>AES 代表对称加密算法</li>
<li>128 代表强度</li>
<li>GCM 代表分组模式</li>
<li>SHA256 代表签名 hash 算法</li>
</ul>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx一 -- 初识nginx</title>
    <url>/nginx%E4%B8%80.html</url>
    <content><![CDATA[<h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><h2 id="nginx的场景"><a href="#nginx的场景" class="headerlink" title="nginx的场景"></a>nginx的场景</h2><p>三个主要场景</p>
<ul>
<li>静态资源：通过本地文件系统提供服务</li>
<li>反向代理：nginx的强大性能，缓存，负载均衡</li>
<li>API服务：openresty</li>
</ul>
<h2 id="nginx的优点"><a href="#nginx的优点" class="headerlink" title="nginx的优点"></a>nginx的优点</h2><ul>
<li>高并发，高性能</li>
<li>可扩展性好</li>
<li>高可靠性</li>
<li>热部署</li>
<li>BSD许可证</li>
</ul>
<h2 id="nginx的组成"><a href="#nginx的组成" class="headerlink" title="nginx的组成"></a>nginx的组成</h2><ul>
<li>nginx二进制可执行文件：由各模块原码编译出的一个文件</li>
<li>nginx.conf:控制nginx行为</li>
<li>access.log</li>
<li>error.log</li>
</ul>
<h2 id="vim-nginx语法高亮"><a href="#vim-nginx语法高亮" class="headerlink" title="vim nginx语法高亮"></a>vim nginx语法高亮</h2><p>如果想要vim操作nginx的时候有语法高亮，那么只需要把nginx文件夹带的vim配置文件复制到自己的vim配置文件下面就可以了</p>
<p>找到nginx源码目录，注意这里是源码目录，下载的tar包解压出来的目录，而不是编译安装后的目录，下面有一个<code>contrib</code>文件夹，这个文件夹里面有<code>vim</code>文件夹，把这个里面的配置文件都复制一下就好了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -r nginx/contrib/vim/ ~/.vim/</span><br></pre></td></tr></table></figure>

<h2 id="已安装的nginx-增加模块"><a href="#已安装的nginx-增加模块" class="headerlink" title="已安装的nginx 增加模块"></a>已安装的nginx 增加模块</h2><p>首先到达源码目录<code>cd /usr/local/src/nginx1.19</code></p>
<p>然后开始编译</p>
<ul>
<li>–prefix 参数代表你的nginx安装目录，如果是已安装的nginx，那么这个目录就选择已安装的目录，没有安装的可以随便选想安装到的目录</li>
<li>–with 开头的代表你想开启的模块</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ./configure --with-file-aio --with-http_ssl_module --with-http_v2_module --with-http_realip_module --prefix=/usr/local/src/nginx</span><br></pre></td></tr></table></figure>

<p>然后执行<code>make</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo make</span><br></pre></td></tr></table></figure>

<p>接下来就可以复制nginx源文件了，这里只执行make，不需要执行make install</p>
<p>现在假设你已经在nginx源码目录了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ./objs  //移动到objs目录下</span><br><span class="line">cp nginx /usr/local/src/nginx/sbin/    //把objs目录下的nginx复制到你原来的nginx安装目录下面的sbin目录替换原来的nginx源文件</span><br></pre></td></tr></table></figure>

<p>如果是新安装，那么不需要复制，直接执行 sudo make install 就可以了</p>
<h2 id="配置语法"><a href="#配置语法" class="headerlink" title="配置语法"></a>配置语法</h2><ul>
<li>配置文件由指令和指令块构成</li>
<li>每条指令以;分号结尾，指令与参数间用空格分隔</li>
<li>指令块以{}大括号将多条指令组织在一起</li>
<li>include 语句允许组合多个配置文件以提升可维护性</li>
<li>使用 #井号添加注释，提高可读性</li>
<li>使用 $符号作为变量</li>
<li>部分指令的参数支持正则表达式</li>
</ul>
<h2 id="http配置的指令块"><a href="#http配置的指令块" class="headerlink" title="http配置的指令块"></a>http配置的指令块</h2><ul>
<li>http</li>
<li>server</li>
<li>upstream</li>
<li>location</li>
</ul>
<h2 id="nginx-命令行"><a href="#nginx-命令行" class="headerlink" title="nginx 命令行"></a>nginx 命令行</h2><ul>
<li>帮助 -h</li>
<li>指定配置文件 -c</li>
<li>指定配置指令 -g</li>
<li>指定运行目录 -p</li>
<li>发送信号 -s</li>
<li>测试配置文件语法 -t</li>
<li>打印版本信息 -v -V</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx             //启动</span><br><span class="line">nginx -s reload   // 重启</span><br><span class="line">nginx -s quit    //优雅停止</span><br><span class="line">nginx -s stop    //直接停止</span><br><span class="line">nginx -s reopen  //重新开始记录日志</span><br></pre></td></tr></table></figure>

<h4 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h4><p>当你需要升级nginx或者增加模块的时候可以使用热部署的方式平滑过渡，不需要重启</p>
<p>查看现在nginx进程的id</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef|grep nginx</span><br></pre></td></tr></table></figure>

<p>对现在的nginx进程发送<code>USR2</code>信号进行热部署</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -USR2 id</span><br></pre></td></tr></table></figure>

<p>现在可以看到新的nginx进程和老的nginx进程都存在了，这个时候我们需要让老的nginx进程平滑退出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -WINCH id</span><br></pre></td></tr></table></figure>

<p>接下来就可以看到老的nginx的worker进程全部平滑退出了，但是老的master进程还在，这是为了防止新的有问题，还可以退回老的</p>
<p>如果接下来新的有问题，那么我们退回老的，发送<code>HUP</code>信号，而不是直接reload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -HUP id</span><br></pre></td></tr></table></figure>

<p>接下来可以看到老的worker进程都起来了</p>
<p>如果热部署后没有问题的话，那么我们直接删除老的master进程就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -QUIT id</span><br></pre></td></tr></table></figure>

<h4 id="日志切割"><a href="#日志切割" class="headerlink" title="日志切割"></a>日志切割</h4><p>如果我们觉得日志太大可以进行日志切割，一种是发送<code>reopen</code>信号，还有一种是发送<code>USR1</code>信号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nginx -s reopen</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -USR1 id</span><br></pre></td></tr></table></figure>

<p>但是注意切割之前要把之前的日志备份一下，不然就会被删除啦</p>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理配置在<code>http</code>代码块中</p>
<p>首先通过<code>upstream</code>配置反向代理的服务器</p>
<p>test 是一个名称，可以随便取</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">upstream</span> test&#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span>     <span class="comment"># 上游服务器的地址，可以写多个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>proxy_pass</code> 进行反向代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://test;   # 这里填写上面的upstream名字</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候我们访问80端口实际上访问的是8080端口</p>
<h4 id="反向代理的缓存"><a href="#反向代理的缓存" class="headerlink" title="反向代理的缓存"></a>反向代理的缓存</h4><p>反向代理之后还可以在反向代理服务器做缓存</p>
<p>在<code>nginx.conf</code>文件的<code>http</code>代码块中设置缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置缓存路径 /tmp/nginxCache 缓存名称 my_cache</span><br><span class="line">proxy_cache_path /tmp/nginxCache levels=1:2 keys_zone=my_cache:10m max_size=10g inactive=60m use_temp_path=off;</span><br></pre></td></tr></table></figure>

<p>接下来在我们的反向代理<code>server/location</code>代码块里面使用这个缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_cache my_cache;   # 使用上面定义的缓存</span><br><span class="line">    proxy_cache_key $host$uri$is_args$args;  # 缓存的key值，根据host uri和参数来做key</span><br><span class="line">    proxy_cache_valid 200 304 302 1d;   # 缓存200 304 302状态 缓存时间1d = 1天</span><br><span class="line">    proxy_pass http://test;   # 这里填写上面的upstream名字</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="goaccess-日志可视化"><a href="#goaccess-日志可视化" class="headerlink" title="goaccess 日志可视化"></a>goaccess 日志可视化</h2><p>goaccess 是一个c语言写的日志可视化工具</p>
<p>直接编译安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://tar.goaccess.io/goaccess-1.2.tar.gz</span><br><span class="line">tar -xzvf goaccess-1.2.tar.gz</span><br><span class="line">cd goaccess-1.2/</span><br><span class="line">./configure --enable-utf8</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>然后就可以启动了，直接启动就可以</p>
<p>指定日志文件路径 <code>/usr/local/src/nginx/logs/access.log</code> -o 输出到某个html文件中 –real-time-html 代表实时刷新, –log-format 代表日志格式 ，–daemonize 代表守护进程后台执行 仅在 开启了 –real-time-html 实时刷新有效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goaccess /usr/local/src/nginx/logs/access.log -o ~/wwwroot/goaccess.html --real-time-html --log-format=COMBINED --daemonize</span><br></pre></td></tr></table></figure>

<p>这里要注意，如果开启了  –real-time-html 实时刷新，那么会启动一个 socket 进程监听 7890 端口，所以 7890 端口要开放才行</p>
<p>可以配置 nginx 文件访问这个输出的 html 文件了，就可以看到一个可视化界面了</p>
<h2 id="ssl"><a href="#ssl" class="headerlink" title="ssl"></a>ssl</h2><p>ssl(Secure Sosckets Layer)<br>tls(Transport Layer Security)</p>
<ul>
<li>1995年-ssl3.0</li>
<li>1999 - tls1.0</li>
<li>2006 - tls1.1</li>
<li>2008 - tls1.2</li>
<li>2018 - tls1.3</li>
</ul>
<p>ssl&#x2F;tls 运行在 <code>ISO7层模型的表示层中</code>，而http协议运行在表示层的上层<code>应用层</code>。在http的数据传输到<code>表示层</code>以后，ssl&#x2F;tls就会对数据进行加密</p>
<ul>
<li>握手</li>
<li>交换秘钥</li>
<li>告警</li>
<li>对称加密的应用数据</li>
</ul>
<p>tls安全套件</p>
<blockquote>
<p>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</p>
</blockquote>
<ul>
<li>tls代表tls加密</li>
<li>ECDHE 代表秘钥交换算法</li>
<li>RSA 代表身份验证算法</li>
<li>AES 代表对称加密算法</li>
<li>128 代表强度</li>
<li>GCM 代表分组模式</li>
<li>SHA256 代表签名 hash 算法</li>
</ul>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>学堂在线C++程序设计第十四章学习笔记</title>
    <url>/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0.html</url>
    <content><![CDATA[<h1 id="学堂在线C-程序设计第十四章学习笔记"><a href="#学堂在线C-程序设计第十四章学习笔记" class="headerlink" title="学堂在线C++程序设计第十四章学习笔记"></a>学堂在线C++程序设计第十四章学习笔记</h1><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="comment">//抛出异常</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (异常) &#123;</span><br><span class="line">    <span class="comment">//异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常接口声明</p>
<ul>
<li>一个函数显式声明可能抛出的异常，有利于函数的调用者为异常处理做好准备</li>
<li>void fun() throw(A,B,C)</li>
<li>若无异常接口声明，则可以抛出任何类型的异常</li>
<li>不抛任何类型异常的函数声明如下：<br>  void fun() throw()</li>
</ul>
<h3 id="异常处理的构造与析构"><a href="#异常处理的构造与析构" class="headerlink" title="异常处理的构造与析构"></a>异常处理的构造与析构</h3><p>自动的析构</p>
<ul>
<li>找到一个匹配的catch异常处理后</li>
<li>初始化异常参数</li>
<li>将从对应的try块开始到异常被抛出之间构造（且尚未析构）的所有自动对象进行析构</li>
<li>从最后一个catch处理之后开始恢复执行</li>
</ul>
<h3 id="标准程序库异常处理"><a href="#标准程序库异常处理" class="headerlink" title="标准程序库异常处理"></a>标准程序库异常处理</h3><p>基础</p>
<ul>
<li>exception</li>
<li>logic_error 表示可以被预先检测到的异常<ul>
<li>这类异常可以避免</li>
</ul>
</li>
<li>runtime_error 表示难以被预先检测到的异常</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>学堂在线C++程序设计第十三章学习笔记</title>
    <url>/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0.html</url>
    <content><![CDATA[<h1 id="学堂在线C-程序设计第十三章学习笔记"><a href="#学堂在线C-程序设计第十三章学习笔记" class="headerlink" title="学堂在线C++程序设计第十三章学习笔记"></a>学堂在线C++程序设计第十三章学习笔记</h1><h2 id="流类库与输入输出"><a href="#流类库与输入输出" class="headerlink" title="流类库与输入输出"></a>流类库与输入输出</h2><h3 id="IO流的概念"><a href="#IO流的概念" class="headerlink" title="IO流的概念"></a>IO流的概念</h3><p>当程序与外界环境进行信息交换时，存在着两个对象，一个是程序中的对象，另一个是文件对象</p>
<p><code>流</code>是信息流动的抽象，负责在数据的<code>生产者</code>和<code>消费者</code>之间建立联系，并管理数据的流动</p>
<p>流对象与文件操作</p>
<ul>
<li>建立流对象</li>
<li>指定这个流对象与某个文件对象建立连接</li>
<li>程序操作流对象</li>
<li>流对象通过文件系统对所连接的文件对象产生作用</li>
</ul>
<p>提取与插入</p>
<ul>
<li>读操作从流中提取</li>
<li>写操作向流中写入</li>
</ul>
<h3 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h3><p>最重要的三个输出流</p>
<ul>
<li>ostream</li>
<li>ofstream</li>
<li>ostringstream</li>
</ul>
<p>预先定义的输出流对象</p>
<ul>
<li>cout 标准输出</li>
<li>cerr 标准错误输出，没有缓冲，发送给它的内容立即被输出</li>
<li>clog 类似cerr，但是有缓冲，缓冲区满时被输出</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&#x27;123.log&#x27;</span>)</span></span>;</span><br><span class="line">streamBuf* old = cout.<span class="built_in">rdbuf</span>(fout.<span class="built_in">rdbuf</span>());</span><br><span class="line"><span class="comment">//cout 输出到123.log文件</span></span><br><span class="line">cout.<span class="built_in">rdbuf</span>(old); <span class="comment">//恢复输出到标准输出</span></span><br></pre></td></tr></table></figure>

<p>构造输出流对象</p>
<ul>
<li>ofstream 类支持磁盘文件输出</li>
<li>如果在构造函数中指定文件名，当构造这个文件时该文件时自动打开的<br>  ofstream fout(‘123.log’);</li>
<li>可以在调用默认构造函数后使用open打开文件<br>  ofstream fout;<br>  fout.open(123.log);</li>
<li>打开文件可以指定模式<br>  ofstream fout(‘123.log’, ios_base::out|ios_base::binary);</li>
</ul>
<p>文件输出流成员函数的三种类型</p>
<ul>
<li>与操纵符等价的成员函数</li>
<li>执行非格式化写操作的成员函数</li>
<li>其他修改流状态且不同于操纵符或插入运算符的成员函数</li>
</ul>
<p>成员函数</p>
<ul>
<li>open<ul>
<li>把流与磁盘文件关联</li>
<li>需要指定打开模式</li>
</ul>
</li>
<li>put<ul>
<li>把一个字符写到输出流</li>
</ul>
</li>
<li>write<ul>
<li>将内存中的一块内容写到一个文件输出，可以写二进制</li>
</ul>
</li>
<li>seekp和 tellp<ul>
<li>操作文件流的内部指针</li>
</ul>
</li>
<li>close<ul>
<li>关闭磁盘文件</li>
</ul>
</li>
<li>错误处理函数<ul>
<li>在写到一个流时进行错误处理</li>
</ul>
</li>
</ul>
<h4 id="向文本文件输出"><a href="#向文本文件输出" class="headerlink" title="向文本文件输出"></a>向文本文件输出</h4><p>插入运算符 &lt;&lt;</p>
<ul>
<li>为所有标准C++数据类型设计的，用于传送一个字节到输出流对象</li>
</ul>
<p>操纵符（manipulator）</p>
<ul>
<li>插入运算符和操纵符一起<br>  控制输出格式</li>
<li>很多操纵符都定义在 ios_base类中，如hex()，<iomanip>头文件中，如setprecision()</li>
<li>控制输出宽度<br>  在流中放入setw操纵符或调用width成员函数</li>
<li>setw和 width只影响紧随其后的输出项，但其他流格式操纵符保持有效直到发生改变</li>
<li>dec,oct和 hex操纵符设置输入输出的默认进制</li>
</ul>
<p>精度</p>
<ul>
<li>浮点数输出精度的默认值是6</li>
<li>改变精度使用 setprecision操纵符，定义在 <iomanip> 头文件中</li>
<li>如果不指定 fixed 或 scientifc,精度值表示有效数字位数</li>
<li>如果设置了 ios_base::fixed 定点形式 或 ios_base::scientifc 科学计数法 ，精度值表示小数点之后的位数</li>
</ul>
<h4 id="向二进制文件输出"><a href="#向二进制文件输出" class="headerlink" title="向二进制文件输出"></a>向二进制文件输出</h4><p>二进制文件流</p>
<ul>
<li>使用ofstream构造函数中的模式指定二进制</li>
<li>以通常方式构造一个流，然后使用setmode成员函数，在文件打开后改变模式</li>
<li>通过二进制文件输出流对象完成输出</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">3</span>] =&#123;<span class="number">912</span>,<span class="number">2456</span>,<span class="number">37890</span>&#125;;</span><br><span class="line">    <span class="function">ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;date.bat&quot;</span>, ios_base::binary)</span></span>;</span><br><span class="line">    file.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt; (&amp;b), <span class="built_in">sizeof</span>(b));</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="向字符串输出"><a href="#向字符串输出" class="headerlink" title="向字符串输出"></a>向字符串输出</h4><ul>
<li>用于构造字符串</li>
<li>功能<ul>
<li>支持ofstream类的除了open,close外的所有操作</li>
<li>str函数可以返回当前已构造的字符串</li>
</ul>
</li>
<li>典型应用<ul>
<li>将数值转换为字符串</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ostringstream os;</span><br><span class="line">os &lt;&lt; <span class="number">123</span>;</span><br><span class="line">string s = os.<span class="built_in">str</span>();</span><br></pre></td></tr></table></figure>

<h3 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h3><p>重要的输入流类</p>
<ul>
<li>istream 最适用于顺序文本输入，cin是他的实例</li>
<li>ifstream 支持磁盘文件输入</li>
<li>istringstream 字符串输入</li>
</ul>
<p>构造输入流对象</p>
<ul>
<li>如果在构造函数中指定文件，在构造对象时自动打开<br>  ifstream ifs(‘data.bat’);</li>
<li>调用默认构造函数后使用open打开<br>  ifstream ifs;<br>  ifs.open(‘data.bat’);</li>
<li>打开文件时可以指定模式</li>
</ul>
<p>输入流相关函数</p>
<ul>
<li>open 把输入流和文件关联</li>
<li>get 函数的功能与提取运算符(&gt;&gt;)很像，主要的不同点是get函数在读入数据时包括空白字符</li>
<li>getLine 的功能是读取多个字符，并且可以指定终止字符，读取完成后，从读取内容中删除终止字符</li>
<li>read 函数从一个文件读字节到内存中的指定区域，由长度确定要读的字节数。当遇到文件结束或在文本模式文件中遇到文件结束标记字符时结束读取。可以读取二进制。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">3</span>] =&#123;<span class="number">912</span>,<span class="number">2456</span>,<span class="number">37890</span>&#125;;</span><br><span class="line">    <span class="function">ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;date&quot;</span>, ios_base::binary)</span></span>;</span><br><span class="line">    file.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt; (b), <span class="built_in">sizeof</span>(b));</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">    <span class="type">int</span> i2;</span><br><span class="line">    <span class="function">ifstream <span class="title">mfile</span><span class="params">(<span class="string">&quot;date&quot;</span>, ios_base::binary)</span></span>;</span><br><span class="line">    mfile.<span class="built_in">seekg</span>(<span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    mfile.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;i2), <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    cout &lt;&lt; i2 &lt;&lt;endl;</span><br><span class="line">    mfile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符串输入"><a href="#字符串输入" class="headerlink" title="字符串输入"></a>字符串输入</h4><p>用于从字符串读取数据</p>
<h4 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h4><p>输入输出流都是从iostream派生的</p>
<ul>
<li>fstream</li>
<li>stringstream</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统原理第十三节</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E4%B8%89%E8%8A%82.html</url>
    <content><![CDATA[<h1 id="数据库系统原理第十三节"><a href="#数据库系统原理第十三节" class="headerlink" title="数据库系统原理第十三节"></a>数据库系统原理第十三节</h1><h2 id="数据库安全和保护"><a href="#数据库安全和保护" class="headerlink" title="数据库安全和保护"></a>数据库安全和保护</h2><h3 id="安全性与访问控制"><a href="#安全性与访问控制" class="headerlink" title="安全性与访问控制"></a>安全性与访问控制</h3><p>数据库安全：指保护数据库以防止不合法的使用而造成数据泄露，更改或破坏，所以安全性对于任何一个DBMS来说都是至关重要的</p>
<ul>
<li>身份验证</li>
<li>数据库用户权限确认</li>
</ul>
<p>查看用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">from</span> mysql.user</span><br></pre></td></tr></table></figure>

<p>创建用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="keyword">user</span>[identified <span class="keyword">by</span> [password]<span class="string">&#x27;password&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>create user ‘test‘@’%’ identified by ‘123’</p>
<p>create user ‘tset‘@’%’ identified by password ‘jdkfjalkdjskflajsdfa’</p>
<p>删除用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure>

<p>drop user ‘test‘@’%’</p>
<p>修改用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">rename <span class="keyword">user</span> old_user <span class="keyword">to</span> new_user</span><br></pre></td></tr></table></figure>

<p>修改密码</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> password <span class="keyword">for</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="operator">=</span> PASSWORD(<span class="string">&#x27;pass&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="账号权限管理"><a href="#账号权限管理" class="headerlink" title="账号权限管理"></a>账号权限管理</h4><p>使用grant 为用户授权</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span></span><br><span class="line">    priv_type[<span class="keyword">column</span>]</span><br><span class="line">    <span class="keyword">on</span> [object_type] priv_level</span><br><span class="line">    <span class="keyword">to</span> <span class="keyword">user</span></span><br><span class="line">    [<span class="keyword">with</span> <span class="keyword">grant</span> option]</span><br></pre></td></tr></table></figure>

<p>grant select (id, name)<br>on test.test_table<br>to test@’localhost’</p>
<h4 id="收回用户权限"><a href="#收回用户权限" class="headerlink" title="收回用户权限"></a>收回用户权限</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">revoke</span> </span><br><span class="line">    priv_type</span><br><span class="line">    <span class="keyword">on</span> [object_type]</span><br><span class="line">    <span class="keyword">from</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure>

<p>revoke select on test.test_table from ‘test‘@’localhost’</p>
<h3 id="事务与并发控制"><a href="#事务与并发控制" class="headerlink" title="事务与并发控制"></a>事务与并发控制</h3><p>所谓事务是用户定义的一个<code>数据操作序列</code>，这些操作可作为一个完整的工作单元，要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务中的操作一般是对数据的更新操作，包括<code>增删改</code></p>
<p>以 <code>begin transaction</code>开始<br>commit 或 rollback结束</p>
<p>事务的特征 </p>
<ul>
<li>A 原子性</li>
<li>C 一致性</li>
<li>I 隔离性</li>
<li>D 持续性</li>
</ul>
<h6 id="并发操作问题"><a href="#并发操作问题" class="headerlink" title="并发操作问题"></a>并发操作问题</h6><ul>
<li>丢失更新</li>
<li>不可重复读</li>
<li>读‘脏’数据</li>
</ul>
<h6 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h6><p>封锁 是最常用的并发控制技术</p>
<p>基本思想：需要时，事务通过向系统请求对它所希望的数据对象加锁，以确保它不被非预期改变</p>
]]></content>
      <categories>
        <category>数据库系统原理</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统原理第十四节</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E5%9B%9B%E8%8A%82.html</url>
    <content><![CDATA[<h1 id="数据库系统原理第十四节"><a href="#数据库系统原理第十四节" class="headerlink" title="数据库系统原理第十四节"></a>数据库系统原理第十四节</h1><h2 id="数据库安全和保护"><a href="#数据库安全和保护" class="headerlink" title="数据库安全和保护"></a>数据库安全和保护</h2><h3 id="事务与并发控制"><a href="#事务与并发控制" class="headerlink" title="事务与并发控制"></a>事务与并发控制</h3><p>所谓事务是用户定义的一个<code>数据操作序列</code>，这些操作可作为一个完整的工作单元，要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务中的操作一般是对数据的更新操作，包括<code>增删改</code></p>
<p>以 <code>begin transaction</code>开始<br>commit 或 rollback结束</p>
<p>事务的特征 </p>
<ul>
<li>A 原子性</li>
<li>C 一致性</li>
<li>I 隔离性</li>
<li>D 持续性</li>
</ul>
<h6 id="并发操作问题"><a href="#并发操作问题" class="headerlink" title="并发操作问题"></a>并发操作问题</h6><ul>
<li>丢失更新</li>
<li>不可重复读</li>
<li>读‘脏’数据</li>
</ul>
<h6 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h6><p>封锁 是最常用的并发控制技术</p>
<p>基本思想：需要时，事务通过向系统请求对它所希望的数据对象加锁，以确保它不被非预期改变</p>
<p>一个<code>锁</code>实质上就是允许或阻止一个事务对一个数据对象的存取特权</p>
<p>基本的封锁类型</p>
<ul>
<li>排它锁，用于写操作</li>
<li>共享锁，用于读操作</li>
</ul>
<p>封锁的粒度<br>粒度越细，并发性就越大，但软件复杂性和系统开销也就越大</p>
<p><code>封锁的级别</code>又称为一致性级别或隔离度</p>
<ul>
<li>0级封锁：不重写其他非0级封锁事务的未提交的更新数据</li>
<li>1级封锁：不允许重写未提交的更新数据。防止了丢失更新的发生</li>
<li>2级封锁：既不重写也不读未提交的更新数据（防止了读脏数据）</li>
<li>3级封锁：不读未提交的更新数据，不写任何（包括读操作）未提交数据</li>
</ul>
<p>活锁：先来先服务<br>死锁：预防</p>
<ul>
<li>一次性锁请求</li>
<li>锁请求排序</li>
<li>序列化处理</li>
<li>资源剥夺</li>
</ul>
<p>可串行性<br>一组事务的一个调度就是它们的基本操作的一种排序</p>
<p>在数据库系统中，可串行性就是并发执行的<code>正确性准则</code></p>
<p>两段封锁法</p>
<ul>
<li>发展或加锁阶段</li>
<li>收缩或释放锁阶段</li>
</ul>
<h3 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h3><p>备份</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">into</span> outfile <span class="string">&#x27;file_name&#x27;</span> export_options  </span><br><span class="line">              dumpfile <span class="string">&#x27;file_name&#x27;</span></span><br><span class="line">    fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span>  逗号分隔</span><br><span class="line">    optionally enclosed <span class="keyword">by</span> &quot;&quot;  字符串用双引号</span><br><span class="line">    lines terminated <span class="keyword">by</span> <span class="string">&#x27;?&#x27;</span>  问号分隔每行数据</span><br></pre></td></tr></table></figure>

<p>dumpfile 导出的备份文件里面所有的数据都彼此紧挨着</p>
<p>导入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">load data infile <span class="string">&#x27;file_name&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> table_name</span><br><span class="line">fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span>  逗号分隔</span><br><span class="line">    optionally enclosed <span class="keyword">by</span> &quot;&quot;  字符串用双引号</span><br><span class="line">    lines terminated <span class="keyword">by</span> <span class="string">&#x27;?&#x27;</span>  问号分隔每行数据</span><br></pre></td></tr></table></figure>

<p>数据库生命周期</p>
<ul>
<li>需求分析</li>
<li>系统功能与数据库的设计</li>
<li>系统功能与数据库的实现</li>
<li>测试与维护</li>
</ul>
<h4 id="php-mysql应用"><a href="#php-mysql应用" class="headerlink" title="php mysql应用"></a>php mysql应用</h4><p>连接数据库非持久连接</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$con</span> = <span class="title function_ invoke__">mysql_connect</span>(<span class="string">&quot;localhost:3306&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">持久连接 mysql_pconnect</span><br><span class="line"></span><br><span class="line">选择数据库 <span class="title function_ invoke__">mysql_select_db</span>(<span class="string">&quot;test&quot;</span>, <span class="variable">$con</span>)</span><br><span class="line"></span><br><span class="line">执行 sql <span class="title function_ invoke__">mysql_query</span>(<span class="string">&quot;set names &#x27;gbk&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable">$res</span> = <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>, <span class="variable">$con</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$array</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$res</span>, MYSQL_NUM);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">mysql_close</span>(<span class="variable">$con</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&quot;关闭失败&quot;</span>);</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>数据库系统原理</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>学堂在线C++程序设计第十二章学习笔记</title>
    <url>/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0.html</url>
    <content><![CDATA[<h1 id="学堂在线C-程序设计第十二章学习笔记"><a href="#学堂在线C-程序设计第十二章学习笔记" class="headerlink" title="学堂在线C++程序设计第十二章学习笔记"></a>学堂在线C++程序设计第十二章学习笔记</h1><h2 id="泛型程序设计和标准模板库"><a href="#泛型程序设计和标准模板库" class="headerlink" title="泛型程序设计和标准模板库"></a>泛型程序设计和标准模板库</h2><h3 id="泛型及STL"><a href="#泛型及STL" class="headerlink" title="泛型及STL"></a>泛型及STL</h3><p>泛型程序设计</p>
<ul>
<li>编写不依赖于具体数据类型的程序</li>
<li>将算法从特定的数据结构中抽象出来成为通用的</li>
<li>C++的模板为泛型程序设计奠定了关键的基础</li>
</ul>
<p>术语：概念</p>
<ul>
<li>可以比较大小的数据类型记作<code>Comparable</code></li>
<li>具有公有的复制函数并可以用 &#x3D; 赋值的记作<code>Assignable</code></li>
<li>将 可以比较大小 并且 具有公有复制函数可以用 &#x3D; 赋值的记作<code>Sortable</code></li>
</ul>
<p>对于两个不同的概念A，B,如果A所需求的所有功能也是B所需求的，那么B是A的子概念，比如，Sortable是 Comparable 的子概念，也是 Assignable的子概念</p>
<p>术语：模型</p>
<ul>
<li>符合一个概念的数据类型称为该概念的模型</li>
<li>比如 int 型是 Comparable的模型</li>
<li>静态数组不是 Assignable的模型</li>
</ul>
<h4 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h4><ul>
<li>标准模板库STL定义了一套概念体系，为泛型程序设计提供了逻辑基础</li>
<li>STL中的各个类模板，函数模板的参数都是用这个体系中的概念来规定的</li>
<li>使用STL模板时，类型参数既可以是C++标准库中已有的类型，也可以是自定义的类型–只要这些类型是所要求的概念的模型</li>
</ul>
<p>STL基本组件</p>
<ul>
<li>容器（container）：容纳，包含一组元素的对象<ul>
<li>顺序容器：<br>  array,vector,双端队列，单链表，列表</li>
<li>有序容器：<br>  集合，多重集合，map,多重映射</li>
<li>无序关联容器<br>  无序集合，无序多重集合，无序映射，无序多重映射</li>
</ul>
</li>
<li>迭代器（iterator）<ul>
<li>提供了顺序访问容器中每个元素的方法</li>
<li>可以使用 ++ 运算符来获得指向下一个元素的迭代器</li>
<li>可以使用 * 运算符访问迭代器指向的元素，如果元素类型是类或结构体，还可以使用 -&gt; 运算符直接访问成员</li>
<li>有些迭代器还支持通过 – 运算符获得指向上一个元素的迭代器</li>
<li>迭代器是泛化的指针：指针也具有同样的特性，因此指针本身就是一种迭代器</li>
<li>使用独立于STL容器的迭代器，需要包含头文件<iterator></li>
</ul>
</li>
<li>函数对象（function object）</li>
<li>算法（algorithms）</li>
</ul>
<p><code>迭代器</code>是<code>算法</code>和<code>容器</code>的桥梁</p>
<ul>
<li>将迭代器作为算法的参数，通过迭代器来访问容器而不是把容器直接作为算法参数</li>
<li>将<code>函数对象</code>作为算法参数而不是将函数所执行的运算作为算法的一部分。</li>
<li>使用STL中提供的或自定义的迭代器和函数对象，配合STL的算法，可以组合出各种各样的功能</li>
</ul>
<p>容器适配器</p>
<ul>
<li>栈</li>
<li>队列</li>
</ul>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是算法和容器的桥梁</p>
<ul>
<li>迭代器用作访问容器中的元素</li>
<li>算法不直接操作容器中的数据，而是通过迭代器间接操作</li>
</ul>
<p>算法和容器独立</p>
<ul>
<li>增加新的算法，无需影响容器的实现</li>
<li>增加新的容器，原有的算法也可以适用</li>
</ul>
<p>输入流迭代器</p>
<ul>
<li>istream_iterator<T></li>
<li>以输入流 如 cin 为参数构造</li>
<li>可用 *(p++) 获得下一个输入的元素</li>
</ul>
<p>输出流迭代器</p>
<ul>
<li>ostream_iterator<T></li>
<li>构造时需要提供输出流 如 cout</li>
<li>可用 (*p++) &#x3D; x 将 x 输出到输出流</li>
</ul>
<p>二者都属于适配器</p>
<ul>
<li>适配器是用来为已有对象提供新的接口的对象</li>
<li>输入流适配器和输出流适配器为流对象提供了迭代器的接口</li>
</ul>
<h3 id="容器的基本功能和分类"><a href="#容器的基本功能和分类" class="headerlink" title="容器的基本功能和分类"></a>容器的基本功能和分类</h3><ul>
<li>容器类是容纳，包含一组元素或元素集合的对象</li>
<li>基于容器中元素的组织方式分类：顺序容器，关联容器</li>
<li>按照与容器所关联的迭代器类型分类：可逆容器，随机访问容器</li>
</ul>
<h3 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h3><h5 id="顺序容器的基本功能"><a href="#顺序容器的基本功能" class="headerlink" title="顺序容器的基本功能"></a>顺序容器的基本功能</h5><ul>
<li>STL中的顺序容器<ul>
<li>向量</li>
<li>双端队列(deque)</li>
<li>列表(list)</li>
<li>单向链表(forward_list)</li>
<li>数组(array)</li>
</ul>
</li>
<li>元素线性排列，可以随时在指定位置插入元素和删除元素</li>
<li>必须符合 Assignable 这一概念（具有共有的复制构造函数并可以用 ‘&#x3D;’ 赋值）</li>
<li>array 对象的大小固定，forward_list有特殊的添加和删除操作</li>
</ul>
<p>顺序容器的接口（不包含单向链表和数组）</p>
<ul>
<li>构造函数</li>
<li>赋值函数：assign</li>
<li>插入函数: insert, push_front(只对list和deque)，push_back, emplace, emplace_front</li>
<li>删除函数：erase, clear, pop_front, pop_back, emplace_back</li>
<li>首尾元素的直接访问：front, back</li>
<li>改变大小：resize</li>
</ul>
<h4 id="顺序容器的特征"><a href="#顺序容器的特征" class="headerlink" title="顺序容器的特征"></a>顺序容器的特征</h4><p>向量</p>
<ul>
<li>特点<ul>
<li>一个可以扩展的动态数组</li>
<li>随机访问，在尾部插入或删除元素块</li>
<li>在中间或头部插入或删除元素慢</li>
</ul>
</li>
<li>容量<ul>
<li>容量：实际分配空间的大小</li>
<li>s.capacity: 返回当前容量</li>
<li>s.reserve(n): 容量小于n，则对s进行扩展，使其容量至少为n</li>
</ul>
</li>
</ul>
<p>双端队列</p>
<ul>
<li>特点<ul>
<li>在两端插入或删除元素快</li>
<li>在中间插入或删除元素慢</li>
<li>随机访问较快，但比向量慢</li>
</ul>
</li>
</ul>
<p>列表</p>
<ul>
<li>特点<ul>
<li>在任意位置插入和删除元素都很快</li>
<li>不支持随机访问</li>
</ul>
</li>
<li>接合操作（splice）<ul>
<li>s.splice(p, s2, q1, q2): 将s2中[q1,q2)移动到s1中p所指向元素之前</li>
</ul>
</li>
</ul>
<h4 id="顺序容器的插入迭代器与适配器"><a href="#顺序容器的插入迭代器与适配器" class="headerlink" title="顺序容器的插入迭代器与适配器"></a>顺序容器的插入迭代器与适配器</h4><p>顺序容器的插入迭代器</p>
<ul>
<li>用于向容器头部，尾部或中间指定位置插入元素的迭代器</li>
<li>包括前插迭代器（front_inserter），后插迭代器（back_inserter）和任意位置插入迭代器（inserter）</li>
<li>例子：<br>  list<int> s;<br>  back_iserter iter(s);<br>  *(iter++) &#x3D; 5; &#x2F;&#x2F;通过iter把5插入s末尾</li>
</ul>
<p>顺序容器的适配器</p>
<ul>
<li>以顺序容器为基础构建一些常用数据结构，是对顺序容器的封装<ul>
<li>栈</li>
<li>队列</li>
<li>优先级队列：最 <code>大</code> 的先弹出</li>
</ul>
</li>
</ul>
<p>栈和队列模板</p>
<ul>
<li>栈模板<br>  template &lt;class T, class Sequence &#x3D; deque<T>&gt; class stack;</li>
<li>队列模板<br>  template &lt;class T,class FrontInsertionSequence &#x3D; deque<T>&gt; class queue;</li>
<li>栈可以用任何一种顺序容器作为基础容器，而队列只允许用前插顺序容器（双端队列或列表）</li>
</ul>
<p>栈和队列共同支持的操作</p>
<ul>
<li>比较</li>
<li>返回元素个数</li>
<li>empty</li>
<li>push</li>
<li>pop</li>
<li>不支持迭代器，因为不允许对任意元素访问</li>
</ul>
<p>栈和队列不同的操作</p>
<ul>
<li>栈的操作<br>  s.top 返回栈顶元素的引用</li>
<li>队列操作<br>  s.front 获得队头元素的引用<br>  s.back 获得队尾元素的引用</li>
</ul>
<p>优先级队列</p>
<ul>
<li>优先级队列也像栈和队列一样支持元素的压入和弹出，但元素弹出顺序和元素大小有关，每次弹出最大的</li>
<li>template &lt;class T, class Sequence &#x3D; Vector<T>&gt; class priority_queue</li>
<li>优先级队列的基础容器必须是支持随机访问的顺序容器</li>
<li>支持栈和队列的size,empty, push, pop几个函数</li>
<li>优先级队列并不支持比较操作</li>
<li>与栈类似，优先级队列提供一个 top 函数，可以获得下一个即将被弹出元素的引用</li>
</ul>
<h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><h4 id="分类和基本功能"><a href="#分类和基本功能" class="headerlink" title="分类和基本功能"></a>分类和基本功能</h4><p>关联容器的特点</p>
<ul>
<li>每个关联容器都有一个key</li>
<li>可以根据key高效查找元素</li>
</ul>
<p>接口</p>
<ul>
<li>插入insert</li>
<li>删除 erase</li>
<li>查找 find</li>
<li>定界 lower_bound,upper_bound,equal_bound</li>
<li>计数 count</li>
</ul>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>集合用来存储一组无重复的数据。用于集合的元素本身是有序的，可以高效查找元素，也可以方便的得到指定大小范围的元素在容器中所处的区间</p>
<h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p>映射和集合的主要区别</p>
<ul>
<li><p>集合的元素类型是key本身</p>
</li>
<li><p>映射的元素类型是key,value二元组</p>
</li>
<li><p>在集合中按照key查找一个元素时，一般只是确定这个元素是否存在。</p>
</li>
<li><p>映射中按照key查找时，除了能确定是否存在外，还可以得到相应的附加数据</p>
</li>
</ul>
<h4 id="多重集合和多重映射"><a href="#多重集合和多重映射" class="headerlink" title="多重集合和多重映射"></a>多重集合和多重映射</h4><ul>
<li>多重集合允许有重复元素的集合，多重映射允许一个key对应多个value</li>
<li>多重集合与集合，多重映射与映射的用法差不多</li>
</ul>
<h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><p>函数对象</p>
<ul>
<li>一个行为类似函数的对象</li>
<li>可以没有参数，也可以带有若干参数</li>
<li>其功能是获取值，或者改变操作状态</li>
<li>普通函数就是函数对象</li>
<li>重载了 “()” 运算符的类的实例是函数对象</li>
</ul>
<h4 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h4><ul>
<li>绑定适配器<ul>
<li>bind1st, bind2nd: 将n元函数对象的指定参数绑定为一个常数，得到n-1元函数对象</li>
</ul>
</li>
<li>组合适配器<ul>
<li>not1,not2: 将指定谓词的结果取反</li>
</ul>
</li>
<li>函数指针适配器<ul>
<li>ptr_fun: 将一般函数指针转换为函数对象，使之能够作为其他函数适配器的输入</li>
<li>在进行参数绑定或其他转换的时候，通常需要函数对象的类型信息</li>
</ul>
</li>
<li>成员函数适配器:ptr_fun,ptr_fun_ref<ul>
<li>对成员函数指针使用，把n元成员函数适配为n + 1元函数对象，该函数对象的第一个参数为调用该成员函数时的目的对象</li>
<li>也就是 object-&gt;method() 变成 method(object)</li>
<li>将 object-&gt;method(arg1) 变成 method(object, arg1)</li>
</ul>
</li>
</ul>
<h4 id="STL算法"><a href="#STL算法" class="headerlink" title="STL算法"></a>STL算法</h4><p>本身是一种函数模板</p>
<ul>
<li>通过迭代器获得输入数据</li>
<li>通过函数对象对数据进行处理</li>
<li>通过迭代器将结果输出</li>
</ul>
<p>STL算法是通用的，独立于具体的数据类型，容器类型</p>
<p>分类</p>
<ul>
<li>不可变序列算法<ul>
<li>不直接修改所操作的容器内容的算法</li>
<li>用于查找指定元素，比较是否相等，对元素进行计数等</li>
</ul>
</li>
<li>可变序列算法<ul>
<li>可修改所操作的容器对象的算法</li>
<li>包括复制，删除，替换，洗牌及生成一个序列的算法</li>
</ul>
</li>
<li>排序和搜索算法<ul>
<li>对序列排序</li>
<li>搜索</li>
<li>堆算法</li>
</ul>
</li>
<li>数值算法<ul>
<li>求和，求差，积等</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统原理第十一节</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E4%B8%80%E8%8A%82.html</url>
    <content><![CDATA[<h1 id="数据库系统原理第十一节"><a href="#数据库系统原理第十一节" class="headerlink" title="数据库系统原理第十一节"></a>数据库系统原理第十一节</h1><h2 id="数据库编程"><a href="#数据库编程" class="headerlink" title="数据库编程"></a>数据库编程</h2><h3 id="存储过程体"><a href="#存储过程体" class="headerlink" title="存储过程体"></a>存储过程体</h3><p>使用 declare 声明局部变量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> cid <span class="type">int</span>(<span class="number">10</span>) <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>只能值begin end中声明</li>
<li>必须在存储过程开头声明</li>
<li>不同于用户变量</li>
<li>作用范围仅限于声明他的begin end语句块</li>
</ul>
<p>局部变量和用户变量的区别</p>
<ul>
<li>局部变量前面没有@符号，并且他只能被声明的begin end语句块中使用</li>
<li>用户变量在声明时前面有@符号，同时已声明的用户变量存在于整个会话之中</li>
</ul>
<p>使用 set 为局部变量赋值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> cid <span class="operator">=</span> <span class="number">910</span>;</span><br></pre></td></tr></table></figure>

<p>select id into cid table</p>
<p>流程控制语句</p>
<p>条件判断<br>if 条件 then<br>    表达式1<br>else<br>    表达式2<br>end if</p>
<p>循环语句</p>
<ul>
<li>while</li>
<li>repeat</li>
<li>loop</li>
</ul>
<p>iterate语句<br>用于表示退出当前循环</p>
<p>declare cursor创建游标</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> cursor_name <span class="keyword">cursor</span> <span class="keyword">for</span> select_statement</span><br></pre></td></tr></table></figure>

<p>open 打开游标</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> cursor_name</span><br></pre></td></tr></table></figure>

<p>使用 fetch into 读取游标数据<br>读取已打开的游标</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fetch</span> cursor_name <span class="keyword">into</span> var_name</span><br></pre></td></tr></table></figure>

<p>使用 close 关闭游标</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">close</span> cursor_name</span><br></pre></td></tr></table></figure>

<h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h3><p>由SQL语句和过程式语句组成</p>
<p>使用 create function 创建</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> sp_name(参数)</span><br><span class="line">    <span class="keyword">returns</span> type</span><br><span class="line">    routine_body <span class="operator">/</span><span class="operator">/</span>主体</span><br></pre></td></tr></table></figure>

<p>给定id号返回性别</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use test;</span><br><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> fn_search(cid <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">returns</span> <span class="type">char</span>(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">deterministic</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> sex <span class="type">char</span>(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">select</span> cust_sex <span class="keyword">into</span> sex <span class="keyword">from</span> customers <span class="keyword">where</span> id <span class="operator">=</span> cid;</span><br><span class="line">    if sex <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span>(<span class="keyword">select</span> <span class="string">&#x27;没有该客户&#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        if sex <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span>(<span class="keyword">select</span> <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span>(<span class="keyword">select</span> <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        <span class="keyword">end</span> if;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span> $$</span><br></pre></td></tr></table></figure>

<p>存储函数和存储过程的区别<br>存储函数不能有输出参数，存储过程有<br>存储函数必须包含一条return语句，存储过程不包含return<br>存储函数可以直接调用，不需要call，存储过程必须call</p>
<p>使用 select 调用存储函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> fn_search(<span class="number">1</span>)$$</span><br></pre></td></tr></table></figure>

<p>删除存储函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">function</span> fun_name</span><br></pre></td></tr></table></figure>

<h2 id="数据库安全和保护"><a href="#数据库安全和保护" class="headerlink" title="数据库安全和保护"></a>数据库安全和保护</h2><h3 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h3><p>正确性和相容性</p>
<ul>
<li>列级约束，包含列的类型，取值范围，精度</li>
<li>元组约束，指元组中各个字段之间的约束</li>
<li>表级约束，指若干元组，关系之间的联系的约束</li>
</ul>
<p>实体完整性：主键约束和候选键约束</p>
<p>主键</p>
<ul>
<li>一个表只能有一个主键</li>
<li>主键唯一，不能为NULL</li>
<li>复合主键不能包含不必要的多余列</li>
<li>一个列名在复合主键的列表中只能出现一次</li>
</ul>
<p>主键约束：primary key, create table 或 alter table,一个表只能创建一个主键<br>候选键约束：unique, create table 或 alter table，可以定义若干个候选键</p>
<h5 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">references</span> table_name(index_col_name)</span><br><span class="line">[<span class="keyword">on</span> <span class="keyword">delete</span> reference_option]</span><br><span class="line">[<span class="keyword">on</span> <span class="keyword">update</span> reference_option]</span><br><span class="line"></span><br><span class="line">restrict<span class="operator">|</span>cascade<span class="operator">|</span><span class="keyword">set</span> <span class="keyword">null</span><span class="operator">|</span><span class="keyword">no</span> action</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库系统原理</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统原理第十二节</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%8A%82.html</url>
    <content><![CDATA[<h1 id="数据库系统原理第十二节"><a href="#数据库系统原理第十二节" class="headerlink" title="数据库系统原理第十二节"></a>数据库系统原理第十二节</h1><h2 id="数据库安全和保护"><a href="#数据库安全和保护" class="headerlink" title="数据库安全和保护"></a>数据库安全和保护</h2><h3 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> orders</span><br><span class="line">order_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">cust_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line"><span class="keyword">primary</span> key(order_id),</span><br><span class="line"><span class="keyword">foreign</span> key(cust_id)</span><br><span class="line">refrences table_name(id)</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> restrict</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> restrict</span><br></pre></td></tr></table></figure>

<h4 id="用户定义完整性约束"><a href="#用户定义完整性约束" class="headerlink" title="用户定义完整性约束"></a>用户定义完整性约束</h4><p>非空 约束 not null<br>check 约束 check(sex &#x3D; ‘f’)</p>
<p>命名完整性约束 constraint[指定的约束名字]<br>只能给基于表的完整性约束指定名字<br>基于列的不行</p>
<p>更新完整性约束<br>使用<code>alter table</code>更新与列或表有关的各种约束</p>
<ul>
<li>完整性约束不能直接修改（先删除，再增加）</li>
<li>alter table 独立删除完整性约束，而不会删除表，drop table删除表也会删除完整性约束</li>
</ul>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>用户定义在关系表上的一类由事件驱动的数据对象，也是一种保证数据完整性的方法</p>
<h4 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> 名称 时间 事件</span><br><span class="line"><span class="keyword">on</span> 表 <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> 主体</span><br></pre></td></tr></table></figure>

<p>插入数据时改变变量值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> t_name after <span class="keyword">insert</span></span><br><span class="line"><span class="keyword">on</span> table_name <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> <span class="keyword">set</span> <span class="variable">@str</span> <span class="operator">=</span> <span class="string">&#x27;one customer added&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h4><p>insert 触发器</p>
<ul>
<li>可引用一个名为 <code>new</code> 的虚拟表，来访问被插入的行</li>
<li>before insert ， new 中的值<code>可以被更新</code><br>delete 触发器</li>
<li>可引用 <code>old</code>的虚拟表，来访问被删除的行</li>
<li>old 只读<br>update 触发器</li>
<li>可引用<code>old</code>的虚拟表来访问update执行前的值，也可以引用<code>new</code>访问更新后的值</li>
</ul>
<h3 id="安全性与访问控制"><a href="#安全性与访问控制" class="headerlink" title="安全性与访问控制"></a>安全性与访问控制</h3><p>数据库安全：指保护数据库以防止不合法的使用而造成数据泄露，更改或破坏，所以安全性对于任何一个DBMS来说都是至关重要的</p>
<ul>
<li>身份验证</li>
<li>数据库用户权限确认</li>
</ul>
<p>查看用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">from</span> mysql.user</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库系统原理</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>学堂在线C++程序设计第十一章学习笔记</title>
    <url>/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0.html</url>
    <content><![CDATA[<h1 id="学堂在线C-程序设计第十一章学习笔记"><a href="#学堂在线C-程序设计第十一章学习笔记" class="headerlink" title="学堂在线C++程序设计第十一章学习笔记"></a>学堂在线C++程序设计第十一章学习笔记</h1><h2 id="模板和群体数据"><a href="#模板和群体数据" class="headerlink" title="模板和群体数据"></a>模板和群体数据</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><p>如果不使用函数模板，需要写多个函数，比如求绝对值</p>
<ul>
<li>整数绝对值</li>
<li>浮点数绝对值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">abs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">0</span> ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">abs</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">0</span> ? -x : x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用模板函数可以只写一个函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">abs</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">0</span> ? -x : x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用int参数调用，那么编译器会根据上面的模板生成一个int型的绝对值函数，也就是将T类型换成int类型</p>
<p>函数模板定义语法</p>
<ul>
<li>语法<br>  template &lt;模板参数表&gt;<br>  函数定义</li>
<li>模板参数表的内容<ul>
<li>类型参数 class (或 typename) 标识符</li>
<li>常量参数 类型说明符 标识符</li>
<li>模板参数 template&lt;参数表&gt; class 标识符</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ul>
<li>一个函数模板并非自动可以处理所有类型的数据</li>
<li>只有能够进行函数模板中运算的类型 可以作为类型实参</li>
<li>自定义的类，需要重载模板中的运算符，才能作为类型实参</li>
</ul>
<h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><p>类模板的作用<br>使用类模板使用户可以为类声明一种模式，使得类中的某些数据成员，某些成员函数的参数，某些成员函数的返回值，能取任意类型</p>
<p>声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;模板参数表&gt;</span><br><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要再类模板以外定义其成员函数，则要求采用以下的形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;模板参数表&gt;</span><br><span class="line">类型名 类名&lt;模板参数标识符列表&gt;::函数名(参数)</span><br></pre></td></tr></table></figure>

<p>定义一个类模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T item;</span><br><span class="line">        <span class="type">bool</span> haveValue;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Store</span>();</span><br><span class="line">        <span class="function">T &amp;<span class="title">getElem</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">putElem</span><span class="params">(<span class="type">const</span> T &amp;x)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T Store&lt;T&gt;::<span class="built_in">getElem</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Store&lt;T&gt;::<span class="built_in">putElem</span>(<span class="type">const</span> T *x) &#123;</span><br><span class="line">    item = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Store&lt;T&gt;::<span class="built_in">Store</span>():<span class="built_in">haveValue</span>(<span class="literal">false</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>调用类模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Store&lt;<span class="type">int</span>&gt; s1,s2;</span><br><span class="line">    s1.<span class="built_in">putElem</span>(<span class="number">3</span>);</span><br><span class="line">    s2.<span class="built_in">putElem</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; s1.<span class="built_in">getElem</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="线性群体"><a href="#线性群体" class="headerlink" title="线性群体"></a>线性群体</h3><p>群体的概念</p>
<ul>
<li><code>群体</code>是指由多个数据元素组成的集合体<br>  群体可以分为两个大类：<code>线性群体</code>和<code>非线性群体</code></li>
<li><code>线性群体</code>中的元素按位置排列有序<br>  可以分为第一个元素，第二个元素等</li>
<li><code>非线性群体</code>不用位置顺序来标识元素</li>
</ul>
<p>线性群体中的元素次序和逻辑位置关系是对应的。按照访问元素的不同方法分为<code>直接访问</code>,<code>顺序访问</code>和<code>索引访问</code></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>直接访问的线性群体–数组类</p>
<ul>
<li>静态数组是具有固定元素个数的群体，其中的元素可以通过下标直接访问。</li>
<li>缺点：大小在编译时确定，在运行时无法修改</li>
<li>动态数组由一系列位置连续的，任意数量相同类型的元素组成</li>
<li>优点：其元素个数可在程序运行时改变</li>
</ul>
<h3 id="链表类"><a href="#链表类" class="headerlink" title="链表类"></a>链表类</h3><p>链表是一种动态数据结构，可以用来表示顺序访问的线性群体<br>链表是由系列结点组成的，结点可以在运行时动态生成<br>每一个结点包括数据域和指向链表中下一个结点的指针<br>如果链表每个结点只有一个指向后继结点的指针，则为单链表</p>
<p>单链表结点模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Node&lt;T&gt; *next;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T data;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">const</span> T&amp; item, Node&lt;T&gt;* next = <span class="number">0</span>);</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insertAfter</span><span class="params">(Node&lt;T&gt; *p)</span></span>;</span><br><span class="line">        <span class="function">Node&lt;T&gt; *<span class="title">deleteAfter</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">Node&lt;T&gt; *<span class="title">nextNode</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Node&lt;T&gt;::<span class="built_in">insertAfter</span>(Node&lt;T&gt; *p) &#123;</span><br><span class="line">    p-&gt;next = next;</span><br><span class="line">    next = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Node&lt;T&gt;* Node&lt;T&gt;::<span class="built_in">deleteAfter</span>() &#123;</span><br><span class="line">    Node&lt;T&gt; *tempPtr = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    next = tempPtr-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> tempPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="链表类模板"><a href="#链表类模板" class="headerlink" title="链表类模板"></a>链表类模板</h3><p>链表的基本操作</p>
<ul>
<li>生成链表</li>
<li>插入结点</li>
<li>查找结点</li>
<li>删除结点</li>
<li>遍历链表</li>
<li>清空链表</li>
</ul>
<h3 id="栈类模板"><a href="#栈类模板" class="headerlink" title="栈类模板"></a>栈类模板</h3><h3 id="队列模板"><a href="#队列模板" class="headerlink" title="队列模板"></a>队列模板</h3><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>每一步将一个待排序元素插入已排序序列的适当位置</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>每次从待排序序列中选择一个最小的元素，顺序排在已排序序列的最后</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统原理第十节</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%8D%81%E8%8A%82.html</url>
    <content><![CDATA[<h1 id="数据库系统原理第十节"><a href="#数据库系统原理第十节" class="headerlink" title="数据库系统原理第十节"></a>数据库系统原理第十节</h1><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>什么是视图</p>
<ul>
<li>视图是一个对象，他是数据库提供给用户的以多种角度观察数据库中数据的一种重要机制</li>
<li>视图不是数据库中真实的表，而是一张虚拟表，其自身并不存储数据</li>
</ul>
<p>视图的优点</p>
<ul>
<li>集中分散数据</li>
<li>简化查询语句</li>
<li>重用SQL语句</li>
<li>保护数据安全</li>
<li>共享所需数据</li>
<li>更改数据格式</li>
</ul>
<h5 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h5><p>or replace 防止报错，存在替换，不存在创建<br>with check option 增删改查的时候检查视图条件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> view_name [(col_list)]</span><br><span class="line"><span class="keyword">as</span> select_statement</span><br><span class="line"><span class="keyword">with</span> <span class="keyword">check</span> option</span><br></pre></td></tr></table></figure>

<h5 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h5><p>drop view view_name</p>
<h5 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> view_name [(col_list)]</span><br><span class="line"><span class="keyword">as</span> select_statement</span><br><span class="line"><span class="keyword">with</span> <span class="keyword">check</span> option</span><br></pre></td></tr></table></figure>

<h5 id="查看视图定义"><a href="#查看视图定义" class="headerlink" title="查看视图定义"></a>查看视图定义</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> view_name</span><br></pre></td></tr></table></figure>

<h5 id="更新视图数据"><a href="#更新视图数据" class="headerlink" title="更新视图数据"></a>更新视图数据</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name </span><br><span class="line"><span class="keyword">values</span>(value1,...);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> table_name <span class="keyword">set</span> col_name <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span></span><br></pre></td></tr></table></figure>

<h6 id="删除视图数据"><a href="#删除视图数据" class="headerlink" title="删除视图数据"></a>删除视图数据</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure>

<h6 id="查询视图数据"><a href="#查询视图数据" class="headerlink" title="查询视图数据"></a>查询视图数据</h6><p>select </p>
<h2 id="数据库编程"><a href="#数据库编程" class="headerlink" title="数据库编程"></a>数据库编程</h2><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p><code>存储过程</code> 是一组为了完成某项特定功能的 <code>SQL语句集</code></p>
<ul>
<li>可增强SQL语言的功能和灵活性</li>
<li>良好的封装性</li>
<li>高性能</li>
<li>可减少网络流量</li>
<li>可作为一种安全机制来确保数据库的安全性和数据的完整性<br>其实质就是一段存储在数据库中的 <code>代码</code><br>它可以由声明式的sql语句和过程式sql语句组成</li>
</ul>
<h4 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h4><p>DELIMITER $$ &#x2F;&#x2F;用户定义的MYSQL 结束符</p>
<p>参数：in|out|inout 参数名 参数类型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> sp_name(参数)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">body <span class="operator">/</span><span class="operator">/</span>存储过程代码</span><br><span class="line"><span class="keyword">END</span> $$</span><br></pre></td></tr></table></figure>

<h4 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h4><p>call sp_name(参数)</p>
<h4 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h4><p>drop procedure sp_name</p>
]]></content>
      <categories>
        <category>数据库系统原理</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统原理第九节</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B9%9D%E8%8A%82.html</url>
    <content><![CDATA[<h1 id="数据库系统原理第九节"><a href="#数据库系统原理第九节" class="headerlink" title="数据库系统原理第九节"></a>数据库系统原理第九节</h1><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><h4 id="where-子句和条件查询"><a href="#where-子句和条件查询" class="headerlink" title="where 子句和条件查询"></a>where 子句和条件查询</h4><p>between 2 and 4 包含2,4</p>
<p>in (1,2,4)</p>
<p>is null</p>
<p>is not null</p>
<h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><p>表子查询<br>行子查询<br>列子查询<br>标量子查询</p>
<p>比较运算符包括</p>
<ul>
<li>ALL</li>
<li>SOME</li>
<li>ANY</li>
</ul>
<p>结合exists</p>
<h6 id="group"><a href="#group" class="headerlink" title="group"></a>group</h6><p>group by id asc|desc with rollup</p>
<h5 id="having"><a href="#having" class="headerlink" title="having"></a>having</h5><p>group by id having count(*) &lt; 3</p>
<h5 id="order"><a href="#order" class="headerlink" title="order"></a>order</h5><p>order by id asc|desc</p>
<h5 id="group-和-order的差别"><a href="#group-和-order的差别" class="headerlink" title="group 和 order的差别"></a>group 和 order的差别</h5><table>
<thead>
<tr>
<th align="left">group</th>
<th align="left">order</th>
</tr>
</thead>
<tbody><tr>
<td align="left">分组行，但输出可能不是分组的排序</td>
<td align="left">排序产生的输出</td>
</tr>
<tr>
<td align="left">只能使用选择列或表达式列</td>
<td align="left">任意列都可以使用</td>
</tr>
<tr>
<td align="left">若与聚合函数一起使用列或表达式, 则必须使用group</td>
<td align="left">不一定需要</td>
</tr>
</tbody></table>
<h5 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h5><p>limit 1,10</p>
]]></content>
      <categories>
        <category>数据库系统原理</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>学堂在线C++程序设计第十章学习笔记</title>
    <url>/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%8D%81%E7%AB%A0.html</url>
    <content><![CDATA[<h1 id="学堂在线C-程序设计第十章学习笔记"><a href="#学堂在线C-程序设计第十章学习笔记" class="headerlink" title="学堂在线C++程序设计第十章学习笔记"></a>学堂在线C++程序设计第十章学习笔记</h1><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><h4 id="重载规则"><a href="#重载规则" class="headerlink" title="重载规则"></a>重载规则</h4><p>C++ 几乎可以重载全部的运算符，而且只能够重载C++中已经有的</p>
<ul>
<li>不能重载的：”.”,”.*”,”::”,”?:”</li>
</ul>
<p>重载之后运算符的优先级和结合性都不会改变</p>
<p>运算符重载是针对新类型数据的实际需要，对原有运算符进行适当的改造。</p>
<p>例如：</p>
<ul>
<li>使复数类的对象可以用 + 运算符实现加法</li>
<li>是时钟类对象可以用 ++ 运算符实现时间增加1秒</li>
</ul>
<p>重载为类的非静态成员函数<br>重载为非成员函数</p>
<h4 id="双目运算符重载为成员函数"><a href="#双目运算符重载为成员函数" class="headerlink" title="双目运算符重载为成员函数"></a>双目运算符重载为成员函数</h4><p>重载为类成员的运算符函数定义形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">函数类型 <span class="keyword">operator</span> 运算符(形参)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数个数 &#x3D; 原操作数个数 - 1(后置++,–除外)</p>
<p>双目运算符重载规则</p>
<ul>
<li>如果要重载B为类成员函数，使之能够实现表达式 oprd1 B oprd2,其中 oprd1 为 A类对象，则B则应被重载为A的成员函数，形参类型应该是 oprd2 所属类型</li>
<li>经重载后，表达式 oprd1 B oprd2 相当于 oprd1.operator B(oprd2)</li>
</ul>
<p>例子8-1 复数类加减法运算重载为成员函数</p>
<ul>
<li>要求<br>  将 +，-运算重载为复数类的成员函数</li>
<li>规则<br>  实部和虚部分别相加减</li>
<li>操作数<br>  两个操作数都是复数类的对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Complex</span>(<span class="type">double</span> r = <span class="number">0.0</span>, <span class="type">double</span> i = <span class="number">0.0</span>):<span class="built_in">real</span>(r),<span class="built_in">imag</span>(i) &#123;&#125;;</span><br><span class="line">        <span class="comment">//运算符+重载成员函数</span></span><br><span class="line">        Complex <span class="keyword">operator</span> +(<span class="type">const</span> Complex &amp;c2) <span class="type">const</span>;</span><br><span class="line">        <span class="comment">//运算符-重载</span></span><br><span class="line">        Complex <span class="keyword">operator</span> -(<span class="type">const</span> Complex &amp;c2) <span class="type">const</span>;</span><br><span class="line">        <span class="comment">//运算符 * 重载</span></span><br><span class="line">        Complex <span class="keyword">operator</span> *(<span class="type">const</span> Complex &amp;c2) <span class="type">const</span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">double</span> real;</span><br><span class="line">        <span class="type">double</span> imag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;c2) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(real + c2.real, imag + c2.imag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span>-(<span class="type">const</span> Complex &amp;c2) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(real - c2.real, imag - c2.imag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span>*(<span class="type">const</span> Complex &amp;c2) <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(real * c2.real, imag * c2.imag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Complex::display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; real &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; imag &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span>,<span class="title">c2</span><span class="params">(<span class="number">5</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line">    c1.<span class="built_in">display</span>();</span><br><span class="line">    c2.<span class="built_in">display</span>();</span><br><span class="line">    Complex c3 = c1 + c2;</span><br><span class="line">    c3.<span class="built_in">display</span>();</span><br><span class="line">    Complex c4 = c1 * c2;</span><br><span class="line">    c4.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="单目运算符重载成为成员函数"><a href="#单目运算符重载成为成员函数" class="headerlink" title="单目运算符重载成为成员函数"></a>单目运算符重载成为成员函数</h4><p>前置单目运算符重载规则</p>
<ul>
<li>如果要重载U为类成员函数，使之能够实现表达式 U oprd, 其中 oprd 为 A 类对象，则 U 应被重载为 A 类的成员函数，无形参。</li>
<li>重载后，表达式 U oprd 相当于 oprd.operator U()</li>
</ul>
<p>后置单目运算符 ++ 和 – 重载规则</p>
<ul>
<li>如果要重载 ++ 或 – 为类成员函数，使之能实现表达式 oprd++ 或 oprd–，其中 oprd 为 A 类对象，则 ++,–应被重载为A类的成员函数，且具有一个int类型的形参</li>
<li>经重载后，表达式 oprd++ 相当于 oprd.operator ++(0)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Complex &amp; Complex::operator++() &#123;</span><br><span class="line">    real++;</span><br><span class="line">    imag++;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex Complex::operator++(int ) &#123;</span><br><span class="line">    Complex that = *this;</span><br><span class="line">    ++(*this);</span><br><span class="line">    return that;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="运算符重载为非成员函数"><a href="#运算符重载为非成员函数" class="headerlink" title="运算符重载为非成员函数"></a>运算符重载为非成员函数</h4><p>规则</p>
<ul>
<li>函数的形参代表依自左至右次序排列的各操作数</li>
<li>重载为非成员函数时<ul>
<li>参数个数 &#x3D; 原操作个数（后置++，–除外）</li>
<li>至少应该有一个自定义类型的参数</li>
</ul>
</li>
<li>后置单目运算符 ++ 和 – 的重载函数，形参列表中要增加一个int, 但不必写形参名</li>
<li>如果在运算符的重载函数中需要操作某类对象的私有成员，可以将此函数声明为该类的友元</li>
</ul>
<p>双目运算符重载</p>
<ul>
<li>oprd1 B oprd2 等于 operator B(oprd1,oprd2)</li>
</ul>
<p>前置单目重载</p>
<ul>
<li>B oprd 等于 operator B(oprd)</li>
</ul>
<p>后置单目++，–重载</p>
<ul>
<li>oprd B 等于 operator B(oprd, 0)</li>
</ul>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>虚函数</p>
<ul>
<li>virtual 定义虚函数 使用运行时多态</li>
<li>虚函数必须在类外实现函数体</li>
<li>虚函数必须是非静态的成员函数，经过派生后，就可以实现运行时多态</li>
</ul>
<p>什么函数可以是虚函数</p>
<ul>
<li>一般成员函数</li>
<li>构造函数不能是虚函数</li>
<li>析构函数可以</li>
</ul>
<p>virtual 关键字</p>
<ul>
<li>派生类可以不显式的用virtual声明虚函数，这时系统就会用以下规则来判断派生类的一个函数成员是不是虚函数：<ul>
<li>该函数是否与基类的虚函数有相同的名称，参数个数及对应参数类型</li>
<li>该函数是否与基类的虚函数有相同的返回值或者满足类型兼容规则的指针，引用型的返回值</li>
</ul>
</li>
<li>如果从名称，参数及返回值三个方面检查之后，派生类的函数满足上述条件，就会自动确定为虚函数。这时，派生类虚函数便会覆盖基类的虚函数<ul>
<li>派生类中的虚函数还会隐藏基类中同名函数的所有其他重载形式</li>
<li>一般习惯于在派生类的函数中也使用 virtual 关键字，以增加程序的可读性</li>
</ul>
</li>
</ul>
<h4 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h4><p>通过基类指针调用对象的析构函数，就需要让基类的析构函数成为虚函数，否则 delete 的结果是不确定的</p>
<p>写成 虚析构函数，那么delete就会执行派生类的析构函数，不然只会静态绑定，永远执行基类的析构函数，派生类的成员就无法delete</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//基类 虚析构函数</span></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Base</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Base* B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    <span class="built_in">fun</span>(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="虚表和动态绑定"><a href="#虚表和动态绑定" class="headerlink" title="虚表和动态绑定"></a>虚表和动态绑定</h4><p>虚表</p>
<ul>
<li>每个多态类有一个虚表</li>
<li>虚表中有当前类的各个虚函数的入口地址</li>
<li>每个对象有一个指向当前类的虚表的指针（虚指针 vptr）</li>
</ul>
<p>动态绑定的实现</p>
<ul>
<li>构造函数中为对象的虚指针赋值</li>
<li>通过多态类型的指针或引用调用成员函数时，通过虚指针找到虚表，进而找到所调用的虚函数的入口地址</li>
<li>通过该入口地址调用虚函数</li>
</ul>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p><code>纯虚函数</code>是一个在基类中声明的虚函数，它在该基类中没有定义具体的操作内容，要求各派生类根据实际需要定义自己的版本</p>
<p>纯虚函数的声明：<br>virtual 函数类型 函数名（参数表） &#x3D; 0;</p>
<p>带有纯虚函数的就是<code>抽象类</code></p>
<p>抽象类的作用</p>
<ul>
<li>将有关的数据和行为组织在一个继承层次结构中，保证派生类具有要求的行为</li>
<li>对于暂时无法实现的函数，可以声明为纯虚函数，留给派生类去实现</li>
</ul>
<p>注意</p>
<ul>
<li>抽象类只能作为基类使用</li>
<li>不能定义抽象类的对象</li>
</ul>
<h4 id="override"><a href="#override" class="headerlink" title="override"></a>override</h4><p>override</p>
<ul>
<li><p>多态行为的基础：基类声明虚函数，派生类声明一个函数覆盖该虚函数</p>
</li>
<li><p>覆盖要求：函数签名（signature）完全一致</p>
</li>
<li><p>函数签名包括：函数名 参数列表 const</p>
</li>
<li><p>C++引入显式函数覆盖，在编译器而非运行期捕获此类错误</p>
</li>
<li><p>在虚函数显式重载中运用，编译器会检查基类是否存在一虚拟函数，与派生类中带有声明override的虚拟函数，有相同的函数签名；若不存在，则回报错误</p>
</li>
</ul>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>final 类</p>
<ul>
<li>不能被继承</li>
<li>继承出现编译错误</li>
</ul>
<p>final 方法</p>
<ul>
<li>不能被覆盖</li>
<li>覆盖出现编译错误</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>学堂在线C++程序设计第九章学习笔记</title>
    <url>/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B9%9D%E7%AB%A0.html</url>
    <content><![CDATA[<h1 id="学堂在线C-程序设计第九章学习笔记"><a href="#学堂在线C-程序设计第九章学习笔记" class="headerlink" title="学堂在线C++程序设计第九章学习笔记"></a>学堂在线C++程序设计第九章学习笔记</h1><h2 id="继承与派生"><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h2><h3 id="继承的基本概念和语法"><a href="#继承的基本概念和语法" class="headerlink" title="继承的基本概念和语法"></a>继承的基本概念和语法</h3><p>继承与派生</p>
<ul>
<li>继承与派生是同一过程从不同的角度看<ul>
<li>保持已有类的特性而构造新类的过程称为<code>继承</code></li>
<li>在已有类的基础上新增自己的特性而产生新类的过程称为<code>派生</code></li>
</ul>
</li>
<li>被继承的已有类称为<code>基类</code></li>
<li>派生出的新类称为<code>派生类</code></li>
<li>直接参与派生出某类的基类称为<code>直接基类</code></li>
<li>基类的基类甚至更高层的基类称为<code>间接基类</code></li>
</ul>
<p>继承的目的</p>
<ul>
<li>实现设计与代码重用</li>
</ul>
<p>派生的目的</p>
<ul>
<li>当新的问题出现，原有程序无法解决时，需要对原有程序进行改造</li>
</ul>
<p>单继承时候派生类的语法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名:继承方式 基类名</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多继承时语法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名:继承方式 基类名, 继承方式 基类名</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>派生类的构成</p>
<ul>
<li>吸收基类成员<ul>
<li>默认情况下派生类包含了全部基类中除构造和析构函数之外的所有成员</li>
<li>C++11 规定可以用using语句继承基类构造函数</li>
</ul>
</li>
<li>改造基类成员</li>
<li>添加新的成员</li>
</ul>
<h2 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h2><h3 id="公有继承"><a href="#公有继承" class="headerlink" title="公有继承"></a>公有继承</h3><p>不同继承方式区别</p>
<ul>
<li><code>派生类成员</code>对基类成员的访问权限</li>
<li>通过<code>派生类对象</code>对基类成员的访问权限</li>
</ul>
<p>三种继承方式</p>
<ul>
<li>公有</li>
<li>私有</li>
<li>保护</li>
</ul>
<p>公有继承</p>
<ul>
<li>继承的访问控制<ul>
<li>基类的 <code>public</code> 和 <code>protected</code> 成员 ：访问属性在派生类保持不变</li>
<li>基类的 <code>private</code> 成员：不可直接访问</li>
</ul>
</li>
<li>访问权限<ul>
<li>派生类中的成员函数：可以直接访问基类中的 <code>public</code> 和 <code>protected</code> 成员，但不能直接访问基类的 <code>private</code> 成员</li>
<li>通过派生类的对象：只能访问 <code>public</code> 成员</li>
</ul>
</li>
</ul>
<h3 id="私有继承和保护继承"><a href="#私有继承和保护继承" class="headerlink" title="私有继承和保护继承"></a>私有继承和保护继承</h3><p>私有继承</p>
<ul>
<li>继承的访问控制<ul>
<li>基类的 <code>public</code> 和 <code>protected</code> 成员：变成 <code>private</code> 成员</li>
<li>基类的 <code>private</code> 成员：不可直接访问</li>
</ul>
</li>
<li>访问权限<ul>
<li>派生类中的成员函数：可以直接访问基类中的 <code>public</code> 和 <code>protected</code> 成员，但不能直接访问基类的 <code>private</code> 成员</li>
<li>通过派生类的对象：不能访问任何成员</li>
</ul>
</li>
</ul>
<p>保护继承</p>
<ul>
<li>继承的访问控制<ul>
<li>基类的 <code>public</code> 和 <code>protected</code> 成员：变成 <code>private</code> 成员，都已变成 <code>protected</code> 成员</li>
<li>基类的 <code>private</code> 成员：不可直接访问</li>
</ul>
</li>
<li>访问权限<ul>
<li>派生类中的成员函数：可以直接访问基类中的 <code>public</code> 和 <code>protected</code> 成员，但不能直接访问基类的 <code>private</code> 成员</li>
<li>通过派生类的对象：不能直接访问</li>
</ul>
</li>
</ul>
<p>protected 成员的特点与作用</p>
<ul>
<li>对建立其所在类对象的模块来说，它与private的性质相同</li>
<li>对于其派生类来说，它与public性质相同</li>
<li>既实现了数据隐藏，又方便继承，实现代码重用</li>
</ul>
<h4 id="基类与派生类转换"><a href="#基类与派生类转换" class="headerlink" title="基类与派生类转换"></a>基类与派生类转换</h4><p>转换</p>
<ul>
<li>公有派生类对象可以被当做基类的对象使用，反之则不可<ul>
<li>派生类的对象可以隐含转换为基类对象</li>
<li>派生类对象可以初始化基类的引用</li>
<li>派生类的指针可以隐含转换为基类的指针</li>
</ul>
</li>
<li>通过基类对象名，指针只能使用从基类继承的成员</li>
</ul>
<h3 id="派生类的构造和析构"><a href="#派生类的构造和析构" class="headerlink" title="派生类的构造和析构"></a>派生类的构造和析构</h3><h4 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a>派生类的构造函数</h4><ul>
<li>基类的构造函数不被继承</li>
<li>派生类需要定义自己的构造函数</li>
</ul>
<p>C++11 规定</p>
<ul>
<li>可用 using 语句 继承基类构造函数</li>
<li>但是 只能 初始化从基类继承的成员</li>
<li>语法形式：<ul>
<li>using B::B</li>
</ul>
</li>
</ul>
<p>若不继承构造函数</p>
<ul>
<li>派生类新增成员：派生类定义构造函数初始化</li>
<li>继承来的成员：自动调用基类构造函数进行初始化</li>
<li>派生类的构造函数需要给基类的构造函数传递参数</li>
</ul>
<p>单继承 A继承与B</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a, <span class="type">int</span> b);</span><br><span class="line">&#125;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> a, <span class="type">int</span> b): <span class="built_in">B</span>(b),<span class="built_in">a</span>(a) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多继承 A 继承 B,C</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:<span class="keyword">public</span> B,<span class="keyword">public</span> C&#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c);</span><br><span class="line">&#125;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c): <span class="built_in">B</span>(b), <span class="built_in">C</span>(c), <span class="built_in">a</span>(a) &#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>当基类有默认构造函数时<ul>
<li>派生类构造函数可以不向基类构造函数传参</li>
<li>构造派生类对象，基类默认构造函数将被调用</li>
</ul>
</li>
<li>如需执行基类中带参数的构造函数<ul>
<li>派生类需要向基类构造函数传参</li>
</ul>
</li>
</ul>
<h4 id="派生类的复制构造函数"><a href="#派生类的复制构造函数" class="headerlink" title="派生类的复制构造函数"></a>派生类的复制构造函数</h4><p>若派生类没有声明复制构造函数</p>
<ul>
<li>编译器会在需要时生成一个隐含的复制构造函数</li>
<li>先调用基类的复制构造函数</li>
<li>再为派生类新增的成员执行复制</li>
</ul>
<p>若声明复制构造函数</p>
<ul>
<li>一般都要为基类的复制构造函数传递参数</li>
<li>复制构造函数只能接受一个参数，既用来初始化派生类定义的成员，也将传递给基类的复制构造函数</li>
<li>基类的复制构造函数形参类型是基类对象的引用，实参可以是派生类对象的引用</li>
</ul>
<h4 id="派生类的析构函数"><a href="#派生类的析构函数" class="headerlink" title="派生类的析构函数"></a>派生类的析构函数</h4><ul>
<li>析构函数不被继承，派生类如果需要，要自行声明析构函数</li>
<li>声明方法与无继承关系时类的析构函数相同</li>
<li>不需要显式调用基类的析构函数，系统会隐式调用</li>
<li>限制性派生类析构函数，在执行基类析构函数</li>
</ul>
<h3 id="派生类成员的标识和访问"><a href="#派生类成员的标识和访问" class="headerlink" title="派生类成员的标识和访问"></a>派生类成员的标识和访问</h3><h4 id="访问从基类继承的成员"><a href="#访问从基类继承的成员" class="headerlink" title="访问从基类继承的成员"></a>访问从基类继承的成员</h4><p>当派生类与基类中有相同成员时</p>
<ul>
<li>若未特别限定，则通过派生类对象使用的是派生类中的同名成员</li>
<li>如果通过派生类对象访问基类中被隐藏的同名成员，应使用基类名和作用域操作符：：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">    a.<span class="built_in">f</span>(); <span class="comment">//调用派生类 f 函数</span></span><br><span class="line">    a.B::<span class="built_in">f</span>(); <span class="comment">//调用基类 f 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>二义性问题</p>
<ul>
<li>如果从不同基类继承了同名成员，但是在派生类中没有定义同名成员 存在二义性<ul>
<li>派生类对象名或引用名.成员名</li>
<li>派生类指针-&gt;成员名</li>
</ul>
</li>
<li>解决方式：用类名限定</li>
</ul>
<h4 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h4><p>要解决的问题：</p>
<ul>
<li>当派生类从多个基类派生，而这些基类又有共同基类，则在访问此共同基类中的成员时，将产生冗余，并可能带来不一致性</li>
</ul>
<p>虚基类声明</p>
<ul>
<li>以 <code>virtual</code> 说明基类继承方式</li>
<li>例如： class B1:virtual public B</li>
</ul>
<p>作用</p>
<ul>
<li>主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题</li>
<li>为最远的派生类提供唯一的基类成员，而不重复产生多次复制</li>
</ul>
<p>注意</p>
<ul>
<li>在第一级继承时就要将共同基类设计为虚基类</li>
</ul>
<p>虚基类及派生类构造函数</p>
<ul>
<li>建立对象时候所指定的类称为<code>最远派生类</code></li>
<li>虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的</li>
<li>在整个继承结构中，直接或间接继承虚基类的所有派生类，都必须在构造函数的成员初始化表中为虚基类的构造函数列出参数。如果未列出，则表示调用该虚基类的默认构造函数</li>
<li>在建立对象时，只有 最远派生类 的构造函数调用虚基类的构造函数，其他类对虚基类构造函数的调用被忽略</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统原理第八节</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AB%E8%8A%82.html</url>
    <content><![CDATA[<h1 id="数据库系统原理第八节"><a href="#数据库系统原理第八节" class="headerlink" title="数据库系统原理第八节"></a>数据库系统原理第八节</h1><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h3><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><p>insert  values </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name[(col_name)] <span class="keyword">values</span> ();</span><br></pre></td></tr></table></figure>

<p>insert  set</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name</span><br><span class="line"><span class="keyword">set</span> col_name <span class="operator">=</span> <span class="string">&#x27;值&#x27;</span>, col_name <span class="operator">=</span> <span class="string">&#x27;值&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>insert  select</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure>

<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> table_name <span class="keyword">set</span> col_name <span class="operator">=</span> <span class="string">&#x27;值&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><h4 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h4><p>select * from table_name</p>
<h4 id="列的选择与指定"><a href="#列的选择与指定" class="headerlink" title="列的选择与指定"></a>列的选择与指定</h4><p>select col_name from table_name</p>
<h4 id="定义别名"><a href="#定义别名" class="headerlink" title="定义别名"></a>定义别名</h4><p>select col_name as alias from table_name</p>
<h4 id="替换查询结果集中的数据"><a href="#替换查询结果集中的数据" class="headerlink" title="替换查询结果集中的数据"></a>替换查询结果集中的数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> </span><br><span class="line"><span class="keyword">when</span> 条件<span class="number">1</span> <span class="keyword">then</span> 表达式<span class="number">1</span></span><br><span class="line"><span class="keyword">when</span> 条件<span class="number">2</span> <span class="keyword">then</span> 表达式<span class="number">2</span></span><br><span class="line"><span class="keyword">else</span> 表达式</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">as</span> alias</span><br></pre></td></tr></table></figure>

<h4 id="计算列值"><a href="#计算列值" class="headerlink" title="计算列值"></a>计算列值</h4><p>select col_name + 100 from table_name</p>
<h4 id="from-子句与多表连接查询"><a href="#from-子句与多表连接查询" class="headerlink" title="from 子句与多表连接查询"></a>from 子句与多表连接查询</h4><h5 id="交叉连接，笛卡尔积"><a href="#交叉连接，笛卡尔积" class="headerlink" title="交叉连接，笛卡尔积"></a>交叉连接，笛卡尔积</h5><p>select * from table_namme1 cross join table_name2</p>
<p>简写：<br>select * from table_name1,table_name2;</p>
<h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>select col_name from table_name inner join table_name2 on table_name.id &#x3D; table_name2.t_id;</p>
<h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>left join</p>
<p>right join</p>
]]></content>
      <categories>
        <category>数据库系统原理</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统原理第七节</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%83%E8%8A%82.html</url>
    <content><![CDATA[<h1 id="数据库系统原理第七节"><a href="#数据库系统原理第七节" class="headerlink" title="数据库系统原理第七节"></a>数据库系统原理第七节</h1><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h3><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><p>mysql -u root -p </p>
<h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><p>create database my_test;</p>
<h4 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h4><p>show databases;</p>
<h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><p>drop my_test;</p>
<h4 id="进入数据库"><a href="#进入数据库" class="headerlink" title="进入数据库"></a>进入数据库</h4><p>use my_test;</p>
<h4 id="表定义"><a href="#表定义" class="headerlink" title="表定义"></a>表定义</h4><p>创建表</p>
<p>数据表被定义为字段的集合<br>按 <code>行</code> 和<code>列</code>的格式存储<br>每一行代表一条记录<br>每一列代表记录中一个字段的取值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [temporary] <span class="keyword">table</span> tbl_name</span><br><span class="line">(</span><br><span class="line">    字段名<span class="number">1</span> 数据类型 [列完整性约束条件] [默认值]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<p>修改表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br></pre></td></tr></table></figure>

<p>字句</p>
<ul>
<li>ADD [COLUMN] 子句</li>
<li>change [COLUMN] 子句</li>
<li>alter [column] 子句 修改或删除表中指定列的默认值<ul>
<li>alter colum city set default ‘bj’</li>
</ul>
</li>
<li>modify [column] 子句 只修改指定列的数据类型，不会干涉它的列名<ul>
<li>modify column city char(50);</li>
</ul>
</li>
<li>drop [column] 子句 删除指定列<ul>
<li>drop column city;</li>
</ul>
</li>
<li>rename [to] 子句 修改表名<ul>
<li>rename to table_name</li>
</ul>
</li>
<li>add index index_name(column_name) 创建索引</li>
<li>drop index index_name</li>
</ul>
<p>修改表名：<br>rename table table_name to new_table_name</p>
<p>删除表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> [temporary] <span class="keyword">table</span> [if <span class="keyword">exists</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> colums <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure>

<h4 id="索引定义"><a href="#索引定义" class="headerlink" title="索引定义"></a>索引定义</h4><p>索引时提高数据文件访问效率的有效方法</p>
<p>缺点</p>
<ul>
<li><p>索引是以文件的形式存储的，如果有大量的索引，索引文件可能比数据文件更快达到最大的文件尺寸</p>
</li>
<li><p>索引在提高查询速度的同时，会降低更新表的速度</p>
</li>
<li><p>index 或 key 普通索引</p>
</li>
<li><p>unique 唯一性索引 候选码</p>
</li>
<li><p>primary key 主键</p>
</li>
</ul>
<p>创建索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>] index index_name</span><br><span class="line"><span class="keyword">on</span> table_name(index_col_name)</span><br></pre></td></tr></table></figure>

<p>索引删除</p>
<p>drop index index_name on table_name</p>
]]></content>
      <categories>
        <category>数据库系统原理</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念英语第一册</title>
    <url>/%E6%96%B0%E6%A6%82%E5%BF%B5%E8%8B%B1%E8%AF%AD%E7%AC%AC%E4%B8%80%E5%86%8C.html</url>
    <content><![CDATA[<h1 id="新概念英语第一册"><a href="#新概念英语第一册" class="headerlink" title="新概念英语第一册"></a>新概念英语第一册</h1><h2 id="21"><a href="#21" class="headerlink" title="21"></a>21</h2><h4 id="祈使句"><a href="#祈使句" class="headerlink" title="祈使句"></a>祈使句</h4><p>请给我一本书<br>give me a book please</p>
<p>请递给我一本书<br>pass me a book</p>
<p>pass me:递给</p>
<p>哪一本书<br>which book?</p>
<p>这一本书吗<br>this one?</p>
<p>红色的这本<br>the red one</p>
<p>不是那本<br>not that one</p>
<p>给你<br>here you are</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>you give me a book<br>主语 谓语 宾语</p>
<p>主语：人称代词主格 i you he she we they<br>宾语：人称代词宾格 me you him her us them</p>
<h5 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h5><p>cup:杯子</p>
<p>glass:玻璃杯</p>
<p>bottle:瓶子</p>
<p>knife:刀</p>
<p>sharp:锋利的</p>
<p>blunt:钝的</p>
<p>fork:叉子</p>
<p>spoon:勺子</p>
<h2 id="23"><a href="#23" class="headerlink" title="23"></a>23</h2><p>请给我一些玻璃杯<br>give me some glasses please</p>
<p>some glasses: 直接宾语<br>me: 间接宾语</p>
<p>架子上这些吗<br>the ones on the shelf</p>
<p>on : 介词 在…上面</p>
<p>on the shelf: 介词短语用来修饰名词</p>
<p>on the floor: 在地板上</p>
<h2 id="25"><a href="#25" class="headerlink" title="25"></a>25</h2><p>这是一个冰箱<br>there is a refrigerator</p>
<p>在厨房里面<br>in the kitchen</p>
<p>in:介词，在…里面</p>
<p>in the kitchen:介词短语 在厨房里面</p>
<p>in the middle of the room:复合介词，在房间的中间</p>
<p>这个杯子在桌子上<br>there is cup on the table<br>变疑问句<br>is there cup on the table?</p>
<p>他在哪？<br>where is it?</p>
<h5 id="单词-1"><a href="#单词-1" class="headerlink" title="单词"></a>单词</h5><p>refrigerator:冰箱<br>fridge:冰箱</p>
<p>electric cooker: 炊具</p>
<h2 id="27"><a href="#27" class="headerlink" title="27"></a>27</h2><p>在电视上有一些杂志<br>there are some magazines on the television</p>
<p>照片在墙上<br>the pictures are on the wall</p>
<p>on the wall:在墙上</p>
<p>near the window:离窗户很近</p>
<p>near the … : 介词，离…很近</p>
<p>他们在哪里<br>where are they</p>
<p>there is a …</p>
<p>there are some ..<br>变疑问句<br>are there any …?<br>变否定句<br>there are not any …?</p>
<p>some 疑问和否定变 any</p>
<h5 id="单词-2"><a href="#单词-2" class="headerlink" title="单词"></a>单词</h5><p>armchair: 扶手椅</p>
<p>bowl:碗</p>
<p>cooker:炉子</p>
<h2 id="29"><a href="#29" class="headerlink" title="29"></a>29</h2><p>请关门，祈使句<br>shut the door,please</p>
<p>铺床<br>make the bed</p>
<p>给化妆桌除尘<br>dust the dressing table</p>
<p>扫地<br>then sweep the floor</p>
<p>给房间通风<br>air the room</p>
<p>我必须要干什么？<br>what must i do?</p>
<p>must:情态动词,必须要，不可推卸</p>
<p>我一定要打扫我的房间<br>i must tidy my room</p>
<p>我必须要努力学习<br>i must study hard</p>
<p>打开电视<br>turn on the TV</p>
<p>短语动词<br>turn on: 打开…<br>turn off: 关闭…</p>
<p>穿上大衣<br>put on the coat<br>put on: 穿上…<br>take off: 脱下…</p>
<h5 id="形容词做动词"><a href="#形容词做动词" class="headerlink" title="形容词做动词"></a>形容词做动词</h5><p>empty :空的<br>这个杯子不是空的，倒空他<br>the cup is not empty, empty it!</p>
<p>clean<br>这个窗户不干净，弄干净他<br>the window is not clean. clean it!</p>
<p>shut<br>这个们没关上，关上他<br>the door is not shut, shut it!</p>
<p>open<br>这个窗户没打开，打开它<br>the wardrobe is not open.open it!</p>
<h5 id="单词-3"><a href="#单词-3" class="headerlink" title="单词"></a>单词</h5><p>wardrobe:衣柜</p>
<p>dust:给…除尘，灰尘</p>
<p>tidy:把…变整洁，整洁</p>
<p>untidy:不干净的，不整洁的</p>
<h2 id="31"><a href="#31" class="headerlink" title="31"></a>31</h2><p>xxxx 在哪里？<br>where is xxxx?</p>
<p>she is …</p>
<p>Tim 在公园里面吗？<br>is Tim in the garden?</p>
<p>现在进行时的疑问句<br>what’s she doing?</p>
<p>他现在正在树下面坐着<br>she’s sitting under the tree</p>
<p><code>现在进行时 be + ing</code></p>
<p>he is climbing the tree</p>
<p><code>现在分词</code> +ing</p>
<p>e 结尾的去 e + ing</p>
<p>辅音+元音+辅音的 双写辅音字母 + ing</p>
<p>短语动词，追逐<br>running after</p>
<p>看….东西<br>looking at</p>
<h2 id="33"><a href="#33" class="headerlink" title="33"></a>33</h2><p>今天是很好的一天<br>it’s a lovely day today</p>
<p>今天的天气很好<br>it’s lovely weather today</p>
<p>there be 这有，天空中有一些云<br>there are some clouds in the sky</p>
<p>jones和他的家人在一起<br>Mr.jones is with his family</p>
<p>他们正在桥上散步<br>they are walking over the bridge</p>
<p>what are the children doing?</p>
<p>they are doing …</p>
<h4 id="单词-4"><a href="#单词-4" class="headerlink" title="单词"></a>单词</h4><p>with:介词，和…在一起</p>
<p>over the bridge:在桥上</p>
<p>boat: 船</p>
<p>river: 河</p>
<p>ship: 轮船</p>
<p>aeroplane: 飞机</p>
<p>over: 在 … 上面，不接触的</p>
<p>over the river: 在河上空</p>
<p>on the river: 在河上，在河表面</p>
<p>wash dishes: 洗盘子</p>
<p>wait for: 等 …</p>
<h2 id="35"><a href="#35" class="headerlink" title="35"></a>35</h2><p>这是一张 我们的村庄 的照片<br>this is a photograph of our village</p>
<p>our village is in a valley</p>
<h5 id="单词-5"><a href="#单词-5" class="headerlink" title="单词"></a>单词</h5><p>photograph: 照片</p>
<p>village: 村庄</p>
<p>valley: 山谷</p>
<p>hills: 小山丘</p>
<p>alone: 沿着…</p>
<p>banks of the river: 河岸</p>
<p>across: </p>
<p>beside: 在…旁边</p>
<p>out of: 从 … 出来</p>
<p>into: 进入…</p>
<h2 id="37"><a href="#37" class="headerlink" title="37"></a>37</h2><p>你工作很努力<br>you are working hard</p>
<p>be going to: <code>一般将来时</code></p>
<p>你接下来要干啥？<br>what are you going to do now?</p>
<p>我要给他上颜色了<br>I’m going to paint it.</p>
<p>你现在正在干什么？<br>what are you doing now?</p>
<p>回答：i’m listening to music</p>
<p>I’m going to paint it pink<br>i:主语<br>paint:谓语动词<br>it:宾语<br>pink:宾语补足语</p>
<p>这个书架不是给我的<br>this bookcase isn’t for me</p>
<h5 id="单词-6"><a href="#单词-6" class="headerlink" title="单词"></a>单词</h5><p>hard: 副词 adv，修饰动词，努力的</p>
<p>paint: 上色，上油漆</p>
<p>for: 给某人，为某人准备的</p>
<h2 id="39"><a href="#39" class="headerlink" title="39"></a>39</h2><p>对那个花瓶做什么<br>to do with that vase</p>
<p>我不知道怎么办<br>i don’t konw what to do with it</p>
<p>对这个书做什么<br>do with a book</p>
<p><code>祈使句的否定形式</code><br>don’t do that</p>
<p>别摔了它<br>don’t drop it</p>
<p><code>双宾语</code> sb 间接宾语 sth 直接宾语<br>give sb sth<br>give sth to sb<br>比如：give me a book,  give the book to me</p>
<blockquote>
<p>give&#x2F;show&#x2F;send&#x2F;take 都一样</p>
</blockquote>
<p>send john that letter<br>send that letter to john</p>
<p>使用it 把 it 放中间<br>turn on the TV &#x3D; turn it on<br>turn off the TV &#x3D; turn it off<br>put on your trousers &#x3D; put it on<br>take off your shoes &#x3D; take it off</p>
<h2 id="41"><a href="#41" class="headerlink" title="41"></a>41</h2><p>那个包重吗<br>is that bag heavy</p>
<p>is there a … in&#x2F;on that …?</p>
<p>在房间里有一个椅子吗？<br>is there a chair in that room?</p>
<p>桌子上有一个花瓶吗？<br>is there a vase on that table?</p>
<p><code>不可数名词 a 替换成 any</code></p>
<p>are there any … in&#x2F;on that …？</p>
<p>there are some … in&#x2F;on that …</p>
<p>is there any … in&#x2F;on that …?</p>
<h3 id="短语"><a href="#短语" class="headerlink" title="短语"></a>短语</h3><p>p piece of 一片&#x2F;一块</p>
<p>a loaf of 一条&#x2F;长条</p>
<p>a bar of 一块</p>
<p>a bottle of 一瓶</p>
<p>a pound of 一磅</p>
<p>half 一半</p>
<p>a qurater of 四分之一</p>
<p>a tin of tobacco 一听烟丝</p>
<h3 id="单词-7"><a href="#单词-7" class="headerlink" title="单词"></a>单词</h3><p>certainly 当然</p>
<h2 id="43"><a href="#43" class="headerlink" title="43"></a>43</h2><p>你能泡茶吗<br>can you make the tea?</p>
<p>i can’t see any … 可以接可数名词复数也可以接不可数名词</p>
<h3 id="短语-1"><a href="#短语-1" class="headerlink" title="短语"></a>短语</h3><p>boil the kettle  烧水</p>
<p>hurry up 快点</p>
<h3 id="单词-8"><a href="#单词-8" class="headerlink" title="单词"></a>单词</h3><p>teapot 茶壶</p>
<p>behind 在 … 后面</p>
<h2 id="45"><a href="#45" class="headerlink" title="45"></a>45</h2><p>你能过来一下吗<br>can you come here a minute please?</p>
<p>她能为我打一下这个信吗<br>can she type this letter for me?</p>
<h2 id="47"><a href="#47" class="headerlink" title="47"></a>47</h2><h2 id="49"><a href="#49" class="headerlink" title="49"></a>49</h2><h2 id="51"><a href="#51" class="headerlink" title="51"></a>51</h2><p>what’s sth like &#x3D; be + like &#x3D; 像什么。。。，什么样子的</p>
<p>在你的国家气候是什么样子的?<br>what’s the climate like in your country?</p>
<h3 id="单词-9"><a href="#单词-9" class="headerlink" title="单词"></a>单词</h3><p>climate: 气候</p>
<p>pleasant: 宜人的</p>
<p>Brazil: 巴西</p>
<p>Brazilian: 巴西人</p>
<p>Holland: 荷兰</p>
<p>Dutch：荷兰人</p>
<p>Norway: 挪威</p>
<p>Norwagian: 挪威人</p>
<p>Spain: 西班牙</p>
<p>Spanish: 西班牙人</p>
<p>Sweden: 瑞典</p>
<p>Swedish: 瑞典人</p>
<h2 id="53"><a href="#53" class="headerlink" title="53"></a>53</h2><p>你最喜欢哪个季节？<br>which seasons do you like best?</p>
<h3 id="单词-10"><a href="#单词-10" class="headerlink" title="单词"></a>单词</h3><p>mild: 温和的</p>
<p>season: 季节</p>
<p>rise: 升起</p>
<p>early: 早期的</p>
<p>late: 晚的</p>
<p>Australia: 澳大利亚</p>
<p>Australian: 澳大利亚人</p>
<p>Austria: 奥地利</p>
<p>Austrian: 奥地利人</p>
<p>Finland: 芬兰</p>
<p>Finnish: 芬兰人</p>
<p>India: 印度</p>
<p>Indian: 印度人</p>
<p>Nigeria: 尼日利亚</p>
<p>Nigerian: 尼日利亚人 </p>
<p>Turkey: 土耳其</p>
<p>Turkish: 土耳其人</p>
<p>Poland: 波兰</p>
<p>Polish: 波兰人</p>
<p>Thailand: 泰国</p>
<p>Thai: 泰国人</p>
<h2 id="55"><a href="#55" class="headerlink" title="55"></a>55</h2><p>你经常做什么？<br>what do you usually do （in the morning&#x2F;afternoon&#x2F;evening）?</p>
<h3 id="单词-11"><a href="#单词-11" class="headerlink" title="单词"></a>单词</h3><h2 id="57"><a href="#57" class="headerlink" title="57"></a>57</h2><p>现在正在做某事…<br>be + v.-ing</p>
<p>现在什么时间？<br>what’s the time now?<br>what time is it?</p>
<h3 id="单词-12"><a href="#单词-12" class="headerlink" title="单词"></a>单词</h3><p>unurual : 不寻常的</p>
<p>at the moment: 此时此刻</p>
<h2 id="59"><a href="#59" class="headerlink" title="59"></a>59</h2><p>你有一些手写纸吗？<br>do you have any writing paper?</p>
<p>这就是你要的所有东西了吗？<br>is that all?</p>
<p>其他人呢？<br>who else?</p>
<p>其他东西呢？<br>anything else?</p>
<h3 id="单词-13"><a href="#单词-13" class="headerlink" title="单词"></a>单词</h3><p>envelope: 信封</p>
<p>glue: 胶水</p>
<p>writing paper: 书写纸</p>
<p>pad: 便签</p>
<p>chalk: 粉笔</p>
<p>size: 型号，尺寸</p>
<p>else: 其他</p>
<p>wine: 红酒</p>
<h2 id="61"><a href="#61" class="headerlink" title="61"></a>61</h2><p>他怎么了？<br>what’s the matter with him?</p>
<p>他还好吗？<br>Is he all right?</p>
<p>she has a headache</p>
<h3 id="单词-14"><a href="#单词-14" class="headerlink" title="单词"></a>单词</h3><p>feel: 感觉,联系动词，后面可以跟形容词</p>
<p>ill: 生病的，不舒服的</p>
<p>sick: 生病的</p>
<p>sad: 悲伤</p>
<p>stay in bed： 卧床</p>
<p>bad cold: 重感冒</p>
<p>good news: 好消息</p>
<p>stomach: 肚子</p>
<p>stomach ache : 肚子疼</p>
<p>medicine: 药</p>
<p>take some medicine: 吃点药</p>
<p>see a docter: 看医生</p>
<p>have a temperature: 发烧</p>
<p>flu: 流感</p>
<p>measles: 麻疹</p>
<h2 id="63"><a href="#63" class="headerlink" title="63"></a>63</h2><p>我能看看他吗<br>can i see him please</p>
<p>can + 动词原形</p>
<p>他可以每天下床两小时<br>he can get up for about two hours each day</p>
<h3 id="单词-15"><a href="#单词-15" class="headerlink" title="单词"></a>单词</h3><p>better: well的比较级，比上次更好点</p>
<p>yet: 仍然，一般用于否定句中</p>
<p>rich food: 大鱼大肉，油腻的食物</p>
<p>light food: 轻食</p>
<p>aspirins: 阿司匹林</p>
<p>take an aspirins: 吃阿司匹林</p>
<p>lean out of : 身体探出。。。</p>
<h2 id="65"><a href="#65" class="headerlink" title="65"></a>65</h2><p>一般将来时<br><code>be going to do</code> 你将要干什么 </p>
<p>你不能晚回家<br>you mustn’t come home late.</p>
<p>具体时间用 <code>at</code><br>日期用<code>on</code><br>月份年份用<code>in</code></p>
<h3 id="单词-16"><a href="#单词-16" class="headerlink" title="单词"></a>单词</h3><p>be home: 在家</p>
<p>come home: 回家</p>
<p>half past ten: 10点半</p>
<p>quarter past eleven: 11点十五</p>
<p>past: 过了</p>
<p>quarter to eleven: 10点45</p>
<p>half to ten: 9点半</p>
<h2 id="67"><a href="#67" class="headerlink" title="67"></a>67</h2><p><code>一般过去时</code><br>你刚才在肉店吗？<br>were you at the butcher’s?</p>
<h3 id="单词-17"><a href="#单词-17" class="headerlink" title="单词"></a>单词</h3><p>过去式<br>am - was<br>is - was<br>are - were</p>
<p>greengrocer: 蔬菜商人</p>
<p>last week: 上周</p>
<p>absent: 缺席</p>
<p>in the country: 在乡下</p>
<p>aren’t you luckly!： 你真幸运！</p>
<h2 id="69"><a href="#69" class="headerlink" title="69"></a>69</h2><p>回家的路上<br>on the way home</p>
<h3 id="单词-18"><a href="#单词-18" class="headerlink" title="单词"></a>单词</h3><p>race: 比赛，竞赛</p>
<p>handreds of: 成百上千</p>
<p>finish：完成，最后，结局</p>
<p>stationer’s:文具店</p>
<h2 id="71"><a href="#71" class="headerlink" title="71"></a>71</h2><p>他昨天给我打了4次电话<br>he telephoned me four times yesterday</p>
<p>前天给我打了3次电话<br>and three times the day before yesterday</p>
<p><code>过去式</code><br>规则动词 + ed<br>不规则动词</p>
<h3 id="单词-19"><a href="#单词-19" class="headerlink" title="单词"></a>单词</h3><p>yesterday: 昨天</p>
<p>the day before yesterday: 前天</p>
<p>four times: 四次</p>
<p>last night: 昨天晚上</p>
<p>the night before last: 前天晚上</p>
<h2 id="73"><a href="#73" class="headerlink" title="73"></a>73</h2><p>他很不了解伦敦<br>she does not know London very well</p>
<h3 id="单词-20"><a href="#单词-20" class="headerlink" title="单词"></a>单词</h3><p>very well：很好，非常好，修饰know,表示程度</p>
<p>lose: 过去式 lost 丢失</p>
<p>suddenly: 突然地</p>
<p>see: 过去式 saw</p>
<p>pleasantly: 副词，修饰动词，表示程度，开心的，愉快地，舒服的</p>
<p>speak: 过去式 spoke</p>
<p>phrasebook: 短语书</p>
<p>take: 过去式 took</p>
<p>slowly: 慢慢的</p>
<p>hurriedly: 副词，匆忙地</p>
<p>badly:副词，严重的</p>
<p>give-gave</p>
<p>drink- drank</p>
<p>thirstily: y 结尾 变i加ly 很渴的</p>
<p>meet-met</p>
<p>warmly: 温暖的，热情的</p>
<p>swim-swam</p>
<h2 id="75"><a href="#75" class="headerlink" title="75"></a>75</h2><p>他是在这里买的吗？<br>did she buy them here？</p>
<p>我恐怕没办法帮你<br>I’m afraid that i can’t</p>
<p>我恐怕。。。<br>i’m afraid … </p>
<p>你在什么时候做了什么事情<br>when did you …?</p>
<h3 id="单词-21"><a href="#单词-21" class="headerlink" title="单词"></a>单词</h3><p>a month age: 一个月之前</p>
<p>afraid: 恐怕</p>
<p>jump off: 跳下</p>
<h2 id="77"><a href="#77" class="headerlink" title="77"></a>77</h2><p>你不能一直等到下午吗？<br>can’t you wait till this afternoon?</p>
<h3 id="单词-22"><a href="#单词-22" class="headerlink" title="单词"></a>单词</h3><p>appointment: 预约</p>
<p>urgnet: 紧急的，急迫的</p>
<p>awful: 糟糕的</p>
<p>till: 一直到…</p>
<h2 id="79"><a href="#79" class="headerlink" title="79"></a>79</h2><p>much + 不可数名词 在否定和疑问句中表示没有很多了，只有一点了</p>
<p>many + 可数名词 在否定和疑问句中表示没有很多了，只有一点了</p>
<p>any 在否定句中表示一点也没有了</p>
<p>at all 在否定句中表示一点也没有了</p>
<h3 id="单词-23"><a href="#单词-23" class="headerlink" title="单词"></a>单词</h3><p>a lot of : 大量的，许多的</p>
<p>haven’t got &#x3D; don’t have: 没有</p>
<p>jam: 果酱</p>
<p>groceries: 杂货，零食</p>
<p>newsagent: 报刊亭</p>
<p>stationery: 文具</p>
<p>chemist: 药剂师，化学家</p>
<h2 id="81"><a href="#81" class="headerlink" title="81"></a>81</h2><p>be + doing : 现在进行时，现在正在做某事</p>
<p>have a cigaretee  抽个烟吧</p>
<p>have a glass of whisky 喝杯威士忌吧</p>
<p>have + 名词 替代相应的动作</p>
<p>have a bath 洗澡吧</p>
<p>have dinner 吃完餐吧</p>
<p>have a lesson 上个课吧</p>
<p>have a good time 玩的开心</p>
<h3 id="单词-24"><a href="#单词-24" class="headerlink" title="单词"></a>单词</h3><p>whisky: 威士忌</p>
<p>roast： 烘焙，烤</p>
<p>video game: 电子游戏，视频游戏</p>
<p>postcard: 明信片</p>
<h2 id="83"><a href="#83" class="headerlink" title="83"></a>83</h2><p>你想和我们一起吃午餐吗<br>do you want to have lunch with us?</p>
<p><code>现在完成时</code>  have&#x2F;has + 过去分词<br>我已经吃了午餐<br>I have already had lunch</p>
<p>不好意思，让你看到这么乱<br>Excuse the mess</p>
<p>我已经吃了一些…<br>I’ve already had some …</p>
<p>我已经吃了一个了<br>I’ve already had one</p>
<p>some + 不可数名词 one 是可数名词</p>
<p>变疑问句</p>
<p>你吃过午餐了吗<br>have you had lunch yet?</p>
<p>yet 用于现在完成时，表示到现在为止吃过午餐了吗</p>
<p>have you had any vegetables or fruit? 你到现在吃蔬菜或水果了吗？<br>i haven’t had any vegetables 我没有吃蔬菜<br>i’ve just had some fruit 我仅仅吃了一些水果 just:仅仅</p>
<h3 id="单词-25"><a href="#单词-25" class="headerlink" title="单词"></a>单词</h3><p>mess: 混乱，乱的</p>
<p>untidy: 不整洁的</p>
<p>suitcase: 行李箱</p>
<h2 id="85"><a href="#85" class="headerlink" title="85"></a>85</h2><p>你刚刚去看过电影了吗<br>have you just been to the cinema?<br>yes i have</p>
<p>你刚刚去过…<br>Have you just been to …</p>
<p>现在有什么电影上映?<br>What’s on?</p>
<p>我从未去过这里<br>i’ve never been there</p>
<p>你曾经去过这里吗？<br>have you ever been there?</p>
<h3 id="单词-26"><a href="#单词-26" class="headerlink" title="单词"></a>单词</h3><p>just: 刚刚，不久</p>
<p>never: 从未</p>
<p>ever: 曾经</p>
<h2 id="87"><a href="#87" class="headerlink" title="87"></a>87</h2><p>我的车准备好了吗？<br>is my car ready yet?</p>
<p>那个不是你的车吗？<br>isn’t that you car?</p>
<p>你做过什么事情了吗？<br>have you … yet?</p>
<h3 id="单词-27"><a href="#单词-27" class="headerlink" title="单词"></a>单词</h3><p>bring: 带来</p>
<p>mechanics: 机械师，修理工</p>
<p>still: 仍然</p>
<p>garage: 车库</p>
<p>crash: 车祸</p>
<p>lamp-post: 路灯</p>
<p>repair: 修理，修补</p>
<h2 id="89"><a href="#89" class="headerlink" title="89"></a>89</h2><p>我相信这个房子是待售的，that引导的从句，that引导的我相信的内容<br>i believe that this house is for sale</p>
<p>我可以看看他吗？ may引导的疑问句，表示有礼貌的<br>may i have a look at it, please?</p>
<p>你居住在这里多久了？ 回答要用现在完成时<br>How long have you lived here?</p>
<p>我已经居住在这里20年了  have lived 现在完成时，回答how long用for + 一段时间<br>i have lived here for twenty years</p>
<p>我自从1976年开始就在这里了<br>i have been here since 1976</p>
<p>他值得每一个便士<br>it’s worth every penny of it</p>
<h3 id="单词-28"><a href="#单词-28" class="headerlink" title="单词"></a>单词</h3><p>for sale: 待售的</p>
<p>since: 自从</p>
<p>retire: 退休</p>
<p>cost: 成本，花费，代价</p>
<p>worth: 价值，值得</p>
<p>decide: 决定</p>
<p>last word: 最后的话，遗言</p>
<h2 id="91"><a href="#91" class="headerlink" title="91"></a>91</h2><p>他到现在为止一直是一个好邻居<br>he has always been a good neighbor</p>
<p><code>一般将来时</code><br>will + do</p>
<p>我将来会想她的<br>i’ll miss him</p>
<p>你今天要去看lan吗<br>will you see lan today</p>
<h3 id="单词-29"><a href="#单词-29" class="headerlink" title="单词"></a>单词</h3><p>neighbor: 邻居</p>
<p>the day after tomorrow: 后天</p>
<p>poor: 贫穷的，可怜的</p>
<p>the night after next: 后天晚上</p>
<h2 id="93"><a href="#93" class="headerlink" title="93"></a>93</h2><p>你下个月要去东京吗<br>will you go to Tokyo next month?</p>
<p>不，我们不是下个月去，will 的否定用 won’t<br>No, we won’t go to Tokyo next month</p>
<h3 id="单词-30"><a href="#单词-30" class="headerlink" title="单词"></a>单词</h3><p>next-door: 下一家</p>
<p>pilot: 飞行员</p>
<p>the month after next: 下下个月</p>
<p>at the moment: 此时此刻</p>
<p>Madrid: 马德里</p>
<p>the week after next: 下下周</p>
<p>Athens: 雅典</p>
<p>Berlin: 柏林</p>
<p>Geneva: 日内瓦</p>
<p>Moscow: 莫斯科</p>
<p>Rome: 罗马</p>
<p>Seoul: 汉城，首尔</p>
<p>Stockholm: 斯德哥尔摩</p>
<p>Sydney: 悉尼</p>
<p>Tokyo: 东京</p>
<h2 id="95"><a href="#95" class="headerlink" title="95"></a>95</h2><p>请给我两张去伦敦的往返车票<br>two return tickets to London,please</p>
<p>赶火车<br>catch the train</p>
<p>我们想要赶8点19去伦敦的火车<br>we want to catch the eight nineteen to London</p>
<p>等待某人…<br>wait for sb</p>
<p>in + 一段时间表示未来一段时间内<br>i will go to Beijing in a year’s time</p>
<h3 id="单词-31"><a href="#单词-31" class="headerlink" title="单词"></a>单词</h3><p>plenty of:大量的，很多的</p>
<p>had better: 最好…</p>
<p>exact: 确切的，精确的</p>
<p>exact time: 确切的时间</p>
<h2 id="97"><a href="#97" class="headerlink" title="97"></a>97</h2><p>我那天在去往伦敦的火车上落下的箱子<br>i left a suitcase on the train to London the other day</p>
<p>is this case yours?</p>
<p>No, that’s not mine</p>
<p>yours 是<code>名词性物主代词</code> &#x3D; your suitcase &#x3D; 形容词性物主代词 + 名词<br>mine &#x3D; my suitcase</p>
<p>属于谁…<br>belong to …</p>
<h3 id="单词-32"><a href="#单词-32" class="headerlink" title="单词"></a>单词</h3><p>the other day: 那天</p>
<p>zip: 拉链</p>
<p>belong: 属于</p>
<h2 id="99"><a href="#99" class="headerlink" title="99"></a>99</h2><h3 id="单词-33"><a href="#单词-33" class="headerlink" title="单词"></a>单词</h3><p>slip: 滑到</p>
<p>sure: 确信的，确切的</p>
<h2 id="101"><a href="#101" class="headerlink" title="101"></a>101</h2><p>你知道 他是YHA的成员<br>you know he’s a member of the Y.H.A</p>
<h3 id="单词-34"><a href="#单词-34" class="headerlink" title="单词"></a>单词</h3><p>youth: 青年</p>
<p>member: 成员</p>
<p>association: 协会，社团</p>
<p>speak up: 大点声</p>
<h2 id="103"><a href="#103" class="headerlink" title="103"></a>103</h2><p>英语和数学试卷对我来说不是足够简单的<br>the english and Maths papers weren’t easy enough for me</p>
<h3 id="单词-35"><a href="#单词-35" class="headerlink" title="单词"></a>单词</h3><p>exam: 考试</p>
<p>easy enough: 足够简单</p>
<p>enough: 足够的</p>
<p>fail: 失败，挂科</p>
<p>too: 过于</p>
<p>rest: 剩余的</p>
<p>difficult: 困难的</p>
<p>hate: 恨</p>
<p>mark: 分数，记号，标记</p>
<p>cheer up: 振奋一点，开心一点</p>
<h2 id="105"><a href="#105" class="headerlink" title="105"></a>105</h2><p>to + do &#x3D; 动词不定式 可以用来做宾语</p>
<p>我想要某人做某事<br>i want you to do</p>
<p>告诉某人做某事<br>tell you to do</p>
<p>i don’t want you to do </p>
<p>tell you not to do </p>
<h3 id="单词-36"><a href="#单词-36" class="headerlink" title="单词"></a>单词</h3><p>at once: 马上来</p>
<p>intelligent: 聪明的</p>
<p>be full of: 充满了…</p>
<p>present: 礼物</p>
<p>correct: 正确，修正，纠正</p>
<h2 id="107"><a href="#107" class="headerlink" title="107"></a>107</h2><p>你想试一下吗？<br>Would you like to try it?</p>
<p>形容词比较级 + than<br>他比那个蓝色的更小<br>it’s <code>smarller than</code> the blud one</p>
<p>pretty 变比较级 y 变 i 加 er &#x3D; prettier</p>
<p>large 变比较级 直接 + r &#x3D; larger</p>
<p>最高级 + the</p>
<p>smarll - smarller - smarllest</p>
<p>large - larger - largest</p>
<p>tall - taller - tallest</p>
<p>hot - hotter - hottest</p>
<p>heavy - heavier - heaviest</p>
<h3 id="单词-37"><a href="#单词-37" class="headerlink" title="单词"></a>单词</h3><p>smart: 漂亮的，时髦的</p>
<p>smarller: 比…更小</p>
<p>suit: 适合</p>
<p>at all: 否定句最后表示一点也不</p>
<p>compare: 比较</p>
<p>crowd: 人群</p>
<p>ever seen: 见过</p>
<h2 id="109"><a href="#109" class="headerlink" title="109"></a>109</h2><p>a little: 一点点 + 不可数名词</p>
<p>a few: 一点点 几个 + 可数名词</p>
<p>what a pity!</p>
<p>what + 名词</p>
<p>数量比较</p>
<p>不可数名词，多<br>much - more - the moest</p>
<p>litte - less - the least</p>
<p>few - fewer - fewest</p>
<p>形容词比较级</p>
<p>good - better - best</p>
<p>bad - worse - worst</p>
<h3 id="单词-38"><a href="#单词-38" class="headerlink" title="单词"></a>单词</h3><p>teaspoonful: 满茶勺</p>
<p>pity: 可怜，遗憾</p>
<p>instead: 代替，反而</p>
<p>advice: 建议</p>
<h2 id="111"><a href="#111" class="headerlink" title="111"></a>111</h2><p>他多少钱？<br>how much does it cost?</p>
<p>他没有贵的那个好 as … as<br>it’s not as good as the expensive one</p>
<p>青苹果和红苹果一样甜 as sweet as 一样甜<br>the green apple is as sweet as the red one</p>
<p>白车不如黑车干净，not as clean as 没有那个干净<br>the white car is not as clean as the black one</p>
<p><code>多音节形容词</code><br>difficult - more difficult - the most difficult<br>interesting - less interesting - the least interesting</p>
<h3 id="单词-39"><a href="#单词-39" class="headerlink" title="单词"></a>单词</h3><p>cost: 价格,成本</p>
<p>afford: 买得起</p>
<p>instalment: 分期付款</p>
<p>deposit: 储蓄，存款，订金</p>
<p>price: 价格，单价</p>
<h2 id="113"><a href="#113" class="headerlink" title="113"></a>113</h2><p>我也没有  either 否定的也<br>i haven’t got any either</p>
<p>我也不能<br>neither can i &#x3D; i can’t either </p>
<p>我们的乘客没有人能找开这个钱<br>none of our passengers can change this note</p>
<p>我有一些零钱<br>i’ve got some shall change</p>
<h3 id="单词-40"><a href="#单词-40" class="headerlink" title="单词"></a>单词</h3><p>small change: 小额零钱</p>
<p>fare: 票价，车费</p>
<p>Square: 广场</p>
<p>note: 笔记，注意，纸币</p>
<p>passenger: 乘客，旅客</p>
<p>either：两，二者之一</p>
<p>none: 没有任何，一点也不</p>
<p>neither: 两者都不，也不</p>
<p>shall: 将，将要</p>
<h2 id="115"><a href="#115" class="headerlink" title="115"></a>115</h2><h3 id="单词-41"><a href="#单词-41" class="headerlink" title="单词"></a>单词</h3><p>复合不定代词<br>everything: 每个东西</p>
<p>impossible: 不可能的</p>
<p>anything: 任何东西</p>
<p>everyone: 每个人</p>
<p>everybody: 每个人</p>
<p>anyone: 任何人</p>
<p>someone: 某人</p>
<p>no one: 没有人</p>
<p>everywhere: 每个地方</p>
<p>nowhere: 无处，到处都无</p>
<h2 id="117"><a href="#117" class="headerlink" title="117"></a>117</h2><p><code>过去进行时</code> was&#x2F;were + doing</p>
<p><code>过去完成时</code> had + 过去分词</p>
<p>出来的小男孩<br>out little boy</p>
<p>那天早上晚些时候<br>later that morning</p>
<p>但是我还没有看到任何变化<br>but i haven’t had any change yet</p>
<p>正当我开门的时候，电话响了<br>just as i was opening the front door, the telephone rang</p>
<h3 id="单词-42"><a href="#单词-42" class="headerlink" title="单词"></a>单词</h3><p>dining room: 餐厅</p>
<p>look for: 寻找</p>
<p>swallow: 吞，吞噬，吞咽</p>
<p>toilet: 洗手间，厕所</p>
<p>rang: 响了</p>
<p>just as: 正当…</p>
<p>while: 正当… 只能接过去进行时</p>
<h2 id="119"><a href="#119" class="headerlink" title="119"></a>119</h2><p>我的一个朋友<br>a friend of mine</p>
<p>怎么啦<br>what’s up?</p>
<h3 id="单词-43"><a href="#单词-43" class="headerlink" title="单词"></a>单词</h3><p>thief: 小偷</p>
<p>torch: 火把，手电筒</p>
<p>exercise: 练习，锻炼，训练，习题</p>
<h2 id="121"><a href="#121" class="headerlink" title="121"></a>121</h2><p>戴着帽子的男人， in a hat 定语从句 戴帽子的<br>the man in a hat</p>
<p>站在柜台后面的这个女士 who 引导定语从句 指示人<br>the lady <code>who is standing behind the counter</code></p>
<p>在柜台上的这本书 which 引导定语从句，指示物的位置<br>the books <code>which are on the counter</code></p>
<p>that 引导的定语从句，关系代词，既可以指示人也可以指示物<br>is this man <code>that you served</code></p>
<h3 id="单词-44"><a href="#单词-44" class="headerlink" title="单词"></a>单词</h3><p>counter: 柜台</p>
<p>recognize: 认出，辨认</p>
<h2 id="123"><a href="#123" class="headerlink" title="123"></a>123</h2><p>看，Scott，这是我去澳大利亚旅游的照片  photograph在定语从句中做<code>宾语</code>，所以that可以省略<br>look,Scott,this is a photograph (that) i took during my trip to Australia</p>
<h3 id="单词-45"><a href="#单词-45" class="headerlink" title="单词"></a>单词</h3><p>during: 期间</p>
<p>bear: 胡子</p>
<h2 id="125"><a href="#125" class="headerlink" title="125"></a>125</h2><p>我必须先给花园浇水<br>i must water the garden first</p>
<p>have to 将来时 will have to<br>过去式 had to<br>过去完成时 have had to</p>
<p>don’t need to: 我不需要做，有其他的选择<br>don’t have to: 我没有责任做，不必要做</p>
<h3 id="单词-46"><a href="#单词-46" class="headerlink" title="单词"></a>单词</h3><p>nuisance: 讨厌的人</p>
<p>have to: 必须 表示客观的必须</p>
<p>immediately: 立即，马上</p>
<h2 id="127"><a href="#127" class="headerlink" title="127"></a>127</h2><p>must还可以表示猜测 我猜是…<br>i must be …</p>
<p>Karen Marsh 看起来真老呀，不是吗！<br>Doesn’t Karen Marsh look old!</p>
<p>没有那么久<br>not that long ago</p>
<p>我自己还没有29那么大呢<br>i’m not more than twenty-nine myself</p>
<p>不可能<br>can’t be</p>
<p>他不可能生病<br>he can’t be ill</p>
<p>他一定是累了<br>he must be tired</p>
<h3 id="单词-47"><a href="#单词-47" class="headerlink" title="单词"></a>单词</h3><p>actress: 女演员</p>
<p>at least: 至少</p>
<h2 id="129"><a href="#129" class="headerlink" title="129"></a>129</h2><p>must have been: 表示肯定，对过去的一件事情猜测</p>
<p>你肯定有开到每小时70米<br>you <code>must have been driving</code> at seventy miles an hour</p>
<p>我没有吧<br>i can’t have been</p>
<p>我肯定在梦游<br>i must have been dreaming</p>
<h3 id="单词-48"><a href="#单词-48" class="headerlink" title="单词"></a>单词</h3><p>wave: 波浪，海浪，挥手</p>
<p>overtake: 超过</p>
<p>speed limit: 限速</p>
<h2 id="131"><a href="#131" class="headerlink" title="131"></a>131</h2><p>度假<br>spend your holidays</p>
<p>我们不能下决心 make up sb minds<br>we can’t <code>make up our minds</code></p>
<p>别那么确定<br>don’t be so sure</p>
<p>我不确定<br>I’m not sure</p>
<p>may be: 可能<br>may have been: 过去可能，用在过去发生的事情里面</p>
<h3 id="单词-49"><a href="#单词-49" class="headerlink" title="单词"></a>单词</h3><p>aborad:国外</p>
<p>by sea: 坐船</p>
<p>by air: 坐飞机</p>
<p>cheap: 便宜的</p>
<p>might not: 也许不会</p>
<p>look after: 照顾</p>
<p>take care of sb: 照顾某人</p>
<p>in the end: 到最后</p>
<h2 id="133"><a href="#133" class="headerlink" title="133"></a>133</h2><p><code>间接引语</code>转述的时候，都要变成<code>过去式</code></p>
<h3 id="单词-50"><a href="#单词-50" class="headerlink" title="单词"></a>单词</h3><p>sensational：轰动性的，爆炸性的</p>
<p>airport: 飞机场</p>
<p>mink: 貂皮  </p>
<h2 id="135"><a href="#135" class="headerlink" title="135"></a>135</h2><p>我拿不定主意<br>i can’t make up my mind</p>
<p>were going to 转述变成 would</p>
<p>can 转述变成 could</p>
<h3 id="单词-51"><a href="#单词-51" class="headerlink" title="单词"></a>单词</h3><p>get married:结婚</p>
<h2 id="137"><a href="#137" class="headerlink" title="137"></a>137</h2><p>如果你赢了很多钱，你要怎么做？ if 引导的条件状语从句 if前面是一般将来时，后面跟一般现在时，主将从现<br>what will you do <code>if you win a lot of money</code>?</p>
<h3 id="单词-52"><a href="#单词-52" class="headerlink" title="单词"></a>单词</h3><p>football pools:足球赌注</p>
<p>nearly: 几乎</p>
<p>depend:依赖</p>
<p>depends on: 取决于…</p>
<p>seaside: 海边</p>
<h2 id="139"><a href="#139" class="headerlink" title="139"></a>139</h2><p>我不知道我什么时候会完成 when 引导的从句<br>i don’t konw when i’ll finish</p>
<p>by the way: 顺便说一下</p>
<p>他想知道你是否累了，if表示是否的意思<br>he wants to know if you are tired</p>
<p>疑问句转述变成陈述句，用if引导</p>
<p>如果疑问句中有特殊疑问词，那么直接用特殊疑问词引导从句</p>
<h2 id="141"><a href="#141" class="headerlink" title="141"></a>141</h2><p><code>被动语态</code> be + 过去分词<br>was invited to a children’s party</p>
<h3 id="单词-53"><a href="#单词-53" class="headerlink" title="单词"></a>单词</h3><p>middle-aged: 中年的</p>
<p>opposite: 对立的</p>
<p>curiously: 好奇的</p>
<p>powder: 粉</p>
<p>powder compact: 粉饼</p>
<p>put away: 收起来</p>
<p>kindly: 亲切的</p>
<p>amused: 被逗乐了</p>
<p>amuse: 动词，逗笑某人</p>
<h2 id="143"><a href="#143" class="headerlink" title="143"></a>143</h2><p>我居住在一个被美丽的森林环绕着的老小镇 被动语态用by表示主语，正常语句是 beautiful woods is surround …<br>i live in a very old town which <code>is surrounded by</code> beautiful woods</p>
<p>ask to do … 要求做某事<br>游客 be asked被要求做某事 have been现在完成时，游客到现在一直被要求保持森林干净和整洁<br>visitors <code>have been asked</code> to keep the woods clean and tidy</p>
<p>垃圾筐现在已经被摆放在树下面<br>litter baskets <code>have been placed</code> under the trees</p>
<p>我所看到的使我非常难过<br>what i saw made me very sad</p>
<p>我数了数有7辆旧车<br>i counted seven old cars</p>
<p>cover with sth 被什么东西覆盖<br>地面被很多纸<br>ground was covered with pieces of paper</p>
<p>任何留下垃圾在这个森林里的人都将被依法处置<br>anyone who leaves litter in these woods will be prosecuted</p>
<h3 id="单词-54"><a href="#单词-54" class="headerlink" title="单词"></a>单词</h3><p>beauty spot: 景点</p>
<p>litter:垃圾</p>
<p>go for a walk:去散步</p>
<p>sad:难过</p>
<p>cover:覆盖</p>
<p>rusty:生锈的</p>
<p>among: 在…之中</p>
<p>prosecute: 起诉</p>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>新概念英语第一册</tag>
      </tags>
  </entry>
  <entry>
    <title>新概念英语第二册</title>
    <url>/%E6%96%B0%E6%A6%82%E5%BF%B5%E8%8B%B1%E8%AF%AD%E7%AC%AC%E4%BA%8C%E5%86%8C.html</url>
    <content><![CDATA[<h1 id="新概念英语第二册"><a href="#新概念英语第二册" class="headerlink" title="新概念英语第二册"></a>新概念英语第二册</h1><h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><p>这个剧很令人感兴趣<br>the play was very interesting</p>
<p>interesting: 对事物感兴趣<br>interested: 对人感兴趣</p>
<p>不关你的事<br>none of you business</p>
<h3 id="简单陈述句语序"><a href="#简单陈述句语序" class="headerlink" title="简单陈述句语序"></a>简单陈述句语序</h3><p>主语 + 谓语动词 + 宾语 + 状语 时间，地点，程度都可以放到后面做状语</p>
<table>
<thead>
<tr>
<th align="left">主</th>
<th align="left">谓语动词</th>
<th align="left">宾语</th>
<th align="left">状语</th>
</tr>
</thead>
<tbody><tr>
<td align="left">i</td>
<td align="left">did not enjoyed</td>
<td align="left">it</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>主语 + 系动词 + 表语   表语一般是形容词</p>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><p>theatre: 剧院</p>
<p>watch a play: 看剧</p>
<p>bear: 动词有忍受，承担的意思，名词是熊</p>
<h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><p>频率副词，时间副词 位置在动词前面<br>now,sometimes可以放在句首或者句尾<br>now, still用现在进行时，其他的是一般现在时<br><code>现在进行时</code> be + doing</p>
<h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>what引导的感叹句 ，用来感叹名词<br>what + 名词 + 主语 + 谓语</p>
<h3 id="单词-1"><a href="#单词-1" class="headerlink" title="单词"></a>单词</h3><p>频率副词<br>never 从不<br>rarely 很少<br>sometimes 有时候<br>frequently 经常<br>often 常常<br>always 总是</p>
<p>感叹句：what + 名词<br>this is a wonderful garden!<br>变成感叹句： what a wonderful garden (this is)</p>
<p>you are a clever boy!<br>what a clever boy (you are)!</p>
<h2 id="03"><a href="#03" class="headerlink" title="03"></a>03</h2><p><code>一般过去时</code> was&#x2F;were + 动词过去式</p>
<h3 id="难点-1"><a href="#难点-1" class="headerlink" title="难点"></a>难点</h3><p>双宾语动词<br>he lent me a book, me是间接宾语，a book是直接宾语<br>可以变成 he lent a book to&#x2F;for me </p>
<h3 id="单词-2"><a href="#单词-2" class="headerlink" title="单词"></a>单词</h3><p>daught: 教<br>lend: 借给<br>whole: 整个的<br>spoil: 损坏，溺爱的</p>
<h2 id="04"><a href="#04" class="headerlink" title="04"></a>04</h2><p><code>现在完成时</code> have&#x2F;has + 动词过去分词</p>
<p>时间状语 just,already,ever,never放在动词前面， yet, so far, lately放在句尾<br>just 刚刚<br>already 已经<br>ever 曾经<br>never 从不<br>yet 仍然，还未，只能用在否定句和疑问句中<br>so far 到现在为止，可以用在肯定句，否定句，疑问句中<br>lately 最近的</p>
<p>yet 用在现在完成时，still用在现在进行时</p>
<h3 id="单词-3"><a href="#单词-3" class="headerlink" title="单词"></a>单词</h3><p>firm 商行，公司<br>a great of number: 许多</p>
<p>yet: 到目前为止还没有，还，仍然<br>so far: 到目前为止</p>
<h2 id="05"><a href="#05" class="headerlink" title="05"></a>05</h2><p>up to now: 到现在</p>
<p>way的短语<br>in this way: 这个方法<br>in the&#x2F;my way: 挡住我的路了<br>in a way: 在某种程度上<br>on the way: 在…的路上<br>by the way: 顺便，顺道</p>
<h3 id="单词-4"><a href="#单词-4" class="headerlink" title="单词"></a>单词</h3><p>pigeon: 鸽子<br>spare aprt: 备件<br>spare: 形容词：备用的，空闲的 动词：赦免<br>obtain: 获得</p>
<h2 id="06"><a href="#06" class="headerlink" title="06"></a>06</h2><p>ask sb for sth: 向某人索要某物<br>in return for this: 作为报答<br>stand on his head: 他倒立</p>
<p>a，an 泛指一个 放在可数名词单数前面<br>some 泛指一些 放在可数名词复数 or 不可数名词前面<br>the 特指这个</p>
<p>有些动词，加上介词或副词后就会改变词义<br>knock sb out: 把某人打昏<br>konck … over: 把…撞倒<br>knock off: 下班<br>konck … off… 把… 从…碰掉<br>konck at 敲<br>knock 20% off the price 让利，优惠20%</p>
<h2 id="07"><a href="#07" class="headerlink" title="07"></a>07</h2><p><code>过去进行时</code> was&#x2F;were + doing</p>
<p>时态副词，比如while,when,as代表当…的时候，可以用过去进行时或者一般过去时</p>
<p>有些动词短语可以把宾语放在中间,如果宾语是it，it必须在中间<br>put it out<br>put it away<br>put it on<br>put it off<br>take it on<br>take it off<br>有些是固定搭配，不能把宾语放在中间，比如<br>look at<br>look for<br>look after<br>wait for<br>ask for</p>
<h3 id="单词-5"><a href="#单词-5" class="headerlink" title="单词"></a>单词</h3><p>detective: 侦探<br>valuable: 贵重的<br>parcel: 包裹<br>daimond: 钻石<br>steal: 偷<br>precious: 珍贵的<br>prevent: 防止，避免</p>
<h2 id="08"><a href="#08" class="headerlink" title="08"></a>08</h2><p>形容词的比较级和最高级<br>大多数比较级是加er&#x2F;r<br>大多数最高级是加est&#x2F;st</p>
<p>单音节形容词只有一个元音字母并以一个辅音字母结尾的<br>其比较级和最高级的构成是将这个辅音字母双写，再加er,est</p>
<p>辅音字母+y结尾的，y变i+er,est</p>
<p>多音节形容词在前面+more or the most</p>
<p>副词做比较<br>变形副词 前面 + more or the most<br>rudely   more rudely  the most rudely</p>
<p>同形式副词<br>hard      harder      the hardest</p>
<p>grow sth<br>sth grows</p>
<p>interesting: …令人感兴趣的<br>interested: 我对…感兴趣</p>
<h3 id="单词-6"><a href="#单词-6" class="headerlink" title="单词"></a>单词</h3><p>neat:整齐的<br>competition: 比赛<br>enter for: 报名参加<br>grow up: 长大</p>
<h2 id="09"><a href="#09" class="headerlink" title="09"></a>09</h2><p>具体时间用 <code>at</code> at 9:00, at helf past one,at noon<br>具体日期用<code>on</code> on Sunday, on May 26th<br>月份年份用<code>in</code> in 2021, in May, in spring, in the morning<br>表示一段时间 in half an hour 半小时以后，in two weeks 两周以后, in twenty minutes’ time 20分钟以后<br>其他引导时间短语的介词<br>from…till: 从…到…<br>during: 在…期间<br>until: 直到…才</p>
<h3 id="难点-2"><a href="#难点-2" class="headerlink" title="难点"></a>难点</h3><p>any 的疑问句可以用<br>not any或者no回答<br>Is there any tea in the pot?<br>there is not any tea in the pot<br>there is no tea in the pot</p>
<h3 id="单词-7"><a href="#单词-7" class="headerlink" title="单词"></a>单词</h3><p>town hall: 市政厅<br>strike： 罢工,敲击<br>hand: 指针<br>a large crowd of: 一大群…<br>strike twelve: 敲击12下<br>in twenty minutes’ time: 20分钟以后</p>
<h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><p><code>被动语态</code> be + 过去分词<br>主动语态主语是人或物，被动语态中，动作是对主语执行的<br>prisoners of war built this bridge in 1942  战俘在1942年建造了这个桥<br>this bridge was built by prisoners of war in 1942 这个桥被战俘于1942年建造 was built 被建造 + by 通过…建造</p>
<p>made in: 表示产地<br>made of: 表示用某种材料制作的 made of silver 银质的<br>made from: 表示用数种材料制作的 made from sand and lime 由沙和石灰制作的<br>made by: 表示制作人 made by my sister 我姐姐做的</p>
<h3 id="难点-3"><a href="#难点-3" class="headerlink" title="难点"></a>难点</h3><p>双重所有格<br>he is one of my friends的双重所有格形式：<br>he is a friend of mine</p>
<h3 id="单词-8"><a href="#单词-8" class="headerlink" title="单词"></a>单词</h3><p>instrument: 乐器<br>struck：被击中</p>
<h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2><p>one good turn deserves another 礼尚往来</p>
<p>有些动词的后面用动词不定式(to do …)作宾语时，需要在前面的动词后面增加一个代词或名词<br>he wants me to ask you a question   &#x2F;&#x2F; to ask you a question 是 to do 动词不定式，所以wants 后面加代词 me</p>
<h3 id="单词-9"><a href="#单词-9" class="headerlink" title="单词"></a>单词</h3><p>deserve: 应得，值得<br>repay: 偿还<br>wage: 工资，指日薪，周薪，体力劳动者的现金工资<br>salary: 工资，指月薪，年薪<br>at once: 马上，立刻</p>
<h2 id="12"><a href="#12" class="headerlink" title="12"></a>12</h2><p><code>一般将来时</code> will or shall + 动词原形<br>shall 用在第一人称后面 will 用在所有人称后面</p>
<p>短语动词<br>be back: 回来<br>be on: 上映<br>be over: 过去<br>be not up to: 不能胜任，不能做<br>be away: 离开<br>set off: 出发<br>set out: 动身，出发<br>set up: 创造</p>
<h3 id="单词-10"><a href="#单词-10" class="headerlink" title="单词"></a>单词</h3><p>sail: 航行<br>take part in: 参与<br>plenty of time: 大量的时间<br>race across: 赛跑<br>the Atlantic: 大西洋<br>audience：观众<br>capable: 有能力的<br>compatibility：兼容性的</p>
<h2 id="13"><a href="#13" class="headerlink" title="13"></a>13</h2><p><code>将来进行时</code> will be doing<br>they will be coming by train 他们将坐火车来这里</p>
<h2 id="难点-4"><a href="#难点-4" class="headerlink" title="难点"></a>难点</h2><p>名词所有格<br>单数名词后面加’s<br>规则的复数名词-s后面加’<br>不是s结尾的人名后面加’s<br>是s结尾的人名后面可以加’s或’</p>
<h3 id="单词-11"><a href="#单词-11" class="headerlink" title="单词"></a>单词</h3><p>pop singers: 流行歌手<br>present： 现在，当前，表达，介绍<br>performances: 表演<br>keep order: 保持秩序<br>occasion: 场合<br>as usual: 和往常一样<br>have a diffcult time: 日子不好过<br>have a hard time: 日子不好过<br>attract：吸引，招引<br>recitals: 表演，演出<br>situations: 形势，处境</p>
<h2 id="14"><a href="#14" class="headerlink" title="14"></a>14</h2><p><code>过去完成时</code> had + 过去分词 表示过去发生的两个事件，动作中哪一个发生在前</p>
<p>ask: 问<br>ask for: 要求<br>except: 除了…<br>except用在句首常用except for</p>
<h3 id="单词-12"><a href="#单词-12" class="headerlink" title="单词"></a>单词</h3><p>apart from: 除了….之外<br>journey: 旅途<br>ask for a lift: 要求搭车<br>as i soon learnt: 我很快就知道<br>learnt: 知道，学到<br>regret: 后悔</p>
<h2 id="15"><a href="#15" class="headerlink" title="15"></a>15</h2><p>that引导的宾语从句<br>the secretary told me <code>that Mr. harmsworth would see me</code></p>
<p>that 引导的宾语从句，间接引语，要用过去式<br>he said <code>that business was very bad</code></p>
<h3 id="单词-13"><a href="#单词-13" class="headerlink" title="单词"></a>单词</h3><p>irritable： 易怒的<br>spare: 空闲的<br>study: 书房</p>
<h2 id="16"><a href="#16" class="headerlink" title="16"></a>16</h2><p>if 引导的条件状语从句 如果他没开罚单让你走了那你真的很幸运<br>you will be very lucky <code>if he lets you go without a ticket</code></p>
<h3 id="单词-14"><a href="#单词-14" class="headerlink" title="单词"></a>单词</h3><p>part: 停放（汽车）<br>let you go: 放你走<br>without a ticket: 没有票，没开票<br>fail: 无视，忘记<br>street sign: 交通标志<br>however: 然而<br>disturb: 打扰<br>blame: 责备</p>
<h2 id="17"><a href="#17" class="headerlink" title="17"></a>17</h2><p>他肯定至少35岁<br>she must be at least thirty-five years old</p>
<p>他经常出现在舞台上以一个年轻女孩的角色<br>she often appears on the stage as a young girl<br>as 以一个什么身份<br>i work as a teacher 我以一个老师的身份工作<br>as 当when用<br>as we were listening to the radio,someone knocked at the door<br>as 做因为用 我来不了因为我忙<br>i cannot come as i am busy</p>
<p><code>have to</code>: 不得不  可以和must 替换 也可以用 have got to<br>junnifer 将不得不参加一个<br>jennifer will have to take part in a new play soon</p>
<p>grow: 成长<br>grow up: 成年人<br>suit: 一套衣服，正装<br>custume: 服装，戏服</p>
<h3 id="单词-15"><a href="#单词-15" class="headerlink" title="单词"></a>单词</h3><p>at least: 至少<br>personally: 个人的，自己的<br>in spite of: 尽管…<br>an adult &#x3D; grown up  成年人<br>bright: 鲜艳的<br>must be: 一定是，表示对现在情况的一种推测，带有一听的肯定程度<br>fool: 傻子，呆瓜</p>
<h2 id="18"><a href="#18" class="headerlink" title="18"></a>18</h2><p>have &#x3D; have got, have got用于口语</p>
<p>umbrella  &#x3D; brolly, brolly 口语化</p>
<p>把…归还给…<br>return sth to sb</p>
<h3 id="单词-16"><a href="#单词-16" class="headerlink" title="单词"></a>单词</h3><p>give back： 归还<br>give away: 送出<br>give in: 交上，投降<br>give up: 放弃</p>
<h2 id="19"><a href="#19" class="headerlink" title="19"></a>19</h2><p>may&#x2F;might 表示猜测，可能<br>这个剧可能随时开始<br>the play may begin at any moment<br>may have + 动词过去分词 表示现在已经…<br>他可能已经开始了<br>it may have begun already</p>
<p>may&#x2F;might i …? 可以和 can&#x2F;could i … ? 替换</p>
<p>那我还是买了他们吧<br>i might as well have them</p>
<p>might as well:表示不是最好的选择，只好选这个了</p>
<p>表示请求<br>will you let me use your phone please?<br>可以用May<br>May i use your phone please?</p>
<p>表示推测<br>perhaps he will come tomorrow<br>可以用may<br>he may come tomorrow</p>
<h3 id="单词-17"><a href="#单词-17" class="headerlink" title="单词"></a>单词</h3><p>exclaim:惊呼 大声说<br>pity: 令人遗憾的事<br>sadly: 悲哀地<br>at once: 立刻<br>delighted: 高兴极了</p>
<h2 id="20"><a href="#20" class="headerlink" title="20"></a>20</h2><p>钓鱼是我最喜欢的运动<br>fishing is my favourite sport</p>
<p>什么也没抓住，没钓上来<br>without catching anything</p>
<p>代替钓鱼的是<br>instead of catching fish，they </p>
<h3 id="动名词"><a href="#动名词" class="headerlink" title="动名词"></a>动名词</h3><p><code>动名词</code> fishing, catching, having<br>动名词做主语<br>在床上看书是我一直享受的事情 i always enjoy做定语，解释什么事情<br>reading in bed is something <code>i always enjoy</code></p>
<p>动名词做宾语<br>介词without 后面跟宾语，名词可以做宾语，所以动词变成动名词catching<br>i often fish for hours without catching anything</p>
<p>动名词以简化繁<br>i often fish for hours, i don’t catch anything<br>如果两个主语一样，可以通过介词连接两句话然后介词后面跟宾语，把动词变成动名词做宾语放在介词后面<br>i often fish for hours <code>without catching</code> anything</p>
<h3 id="单词-18"><a href="#单词-18" class="headerlink" title="单词"></a>单词</h3><p>instead of catching fish： 而不是捕鱼<br>pastime: 业余时间<br>be interested in doing sth: 对做…感兴趣</p>
<h2 id="21"><a href="#21" class="headerlink" title="21"></a>21</h2><p>飞机慢慢把我逼疯了, drive sb mad&#x2F;crazy: 把某人逼疯<br>Aeroplanes are slowly driving me mad</p>
<p>一定已经有一百个人被噪音驱赶走了<br>must have been 表示猜测一定已经…，be driven 被动语态 被驱赶走了 drive sb sth 被动语态变成 sb be driven sth<br>Over a hundred people <code>must have been driven away from their homes by the noise</code></p>
<p>我已经被提供了一大笔钱让我离开<br>i have been offered a large sum of money to go away</p>
<p>但是我下定决心呆在这里<br>But i am determined to stay here</p>
<p>drive sb sth 被驱赶走了<br>drive into: 赶进去…<br>drive back: 赶回去..<br>drive out of: 赶出去…</p>
<h3 id="单词-19"><a href="#单词-19" class="headerlink" title="单词"></a>单词</h3><p>mad: crazy 疯狂的<br>determined: 下定决心的</p>
<h2 id="22"><a href="#22" class="headerlink" title="22"></a>22</h2><p>of her own age: 和她同龄的人</p>
<h3 id="单词-20"><a href="#单词-20" class="headerlink" title="单词"></a>单词</h3><p>dream of: 梦想，幻想<br>cost: 成本，花费<br>regularly: 定期的，经常<br>the Channel: 英吉利海峡</p>
<h2 id="23"><a href="#23" class="headerlink" title="23"></a>23</h2><p>我们现在正居住在一个乡下的美丽的新房子里面<br>we are now living in a beautiful new house in the country</p>
<p>名词前面有多个形容词的，顺序口诀:<code>好美小高状奇新，颜色国料特别亲</code></p>
<h3 id="单词-21"><a href="#单词-21" class="headerlink" title="单词"></a>单词</h3><p>modern: 现代的<br>strange: 奇怪的<br>to: 对于某人来说<br>district: 地区</p>
<h2 id="24"><a href="#24" class="headerlink" title="24"></a>24</h2><p>用现在进行时表示埋怨的语气</p>
<p>每个人这些天都在丢钱<br>everyone’s losing money these days</p>
<p>我妈妈总是认为我学习不够努力<br>My mon’s always thinking i don’t study hard</p>
<h3 id="单词-22"><a href="#单词-22" class="headerlink" title="单词"></a>单词</h3><p>wicked: 很坏的，邪恶的<br>honesty： 诚实的<br>upset: 不安，沮丧<br>sympathetic: 同情的<br>complain: 抱怨</p>
<h2 id="25"><a href="#25" class="headerlink" title="25"></a>25</h2><p>我不仅英语说的非常小心，而且也非常清楚。<br>I <code>not only</code> spoke English very carefully, <code>but</code> very clearly <code>as well</code></p>
<p>但是他说的既不慢也不清楚<br>but he spoke <code>neither</code> slowly <code>nor</code> clearly</p>
<p>他开始说的慢了，然而我还是不能听懂他说的， but代表然而，表示转折<br>Then he spoke slowly, <code>but</code> i could not understand him</p>
<p>不仅，而且<br>not only … but…as well<br>不仅，而且<br>not only … but also<br>neither … nor… 既不，也不</p>
<h3 id="单词-23"><a href="#单词-23" class="headerlink" title="单词"></a>单词</h3><p>at last: 最后，终于<br>several: 多次的，若干次<br>wonder: 疑惑，感到奇怪<br>porter: 搬运工</p>
<h2 id="26"><a href="#26" class="headerlink" title="26"></a>26</h2><p>他们总是告诉你这个图片的意思是什么， what引导的宾语从句保持陈述句语序<br>They always tell you <code>what a picture is &#39;about&#39;</code></p>
<p>他们能观察到更多<br>They notice more</p>
<p>我的妹妹只有7岁，但是他总能告诉我 我的图画是好的还是坏的，whether 引导的宾语从句 whether or not 是否<br>My sister is only seven, but she always tells me <code>whether my pictures are good or not</code></p>
<h3 id="单词-24"><a href="#单词-24" class="headerlink" title="单词"></a>单词</h3><p>critics: 批评者，评论家<br>critically: 批判的，质疑的<br>pretend: 假装<br>pattern: 图案<br>curtain: 窗帘<br>material: 材料<br>appreciate: 欣赏，鉴赏<br>just as: 正像…一样</p>
<h2 id="27"><a href="#27" class="headerlink" title="27"></a>27</h2><h3 id="单词-25"><a href="#单词-25" class="headerlink" title="单词"></a>单词</h3><p>put up: 搭建<br>tent: 帐篷<br>wonderful: 美妙的，美好的<br>campfire: 篝火 &#x3D; open fire<br>creep: 爬行<br>soundly: 香甜的<br>leap: 跳<br>stream: 小溪流<br>had formed: 已经形成了<br>wind: 蜿蜒，弯弯曲曲的<br>flow: 流</p>
<h2 id="28"><a href="#28" class="headerlink" title="28"></a>28</h2><p>Jasper White 是少见的相信古代神话的人之一， who引导的定语从句<br>Jasper White is one of those rare people <code>who believes in ancient myths</code></p>
<p>她是我见过的最丑的脸之一 定语从句<br>It is one of the ugliest faces <code>I have ever seen</code></p>
<p><code>定语从句</code> 由 关系代词 who, which ,that , whose, whom 引导， 修饰限定名词</p>
<p>这个飞行员落在了田野里没有受伤<br>The pilot <code>whose plane landed in a field</code> was not hurt</p>
<p><code>可省略的代词</code> who,which what 做宾语时候可以省略<br>你昨天见得这个男的是个演员 whom代表的the man在从句中做宾语，可以省略<br>The man <code>(whom) you met yesterday</code> is an actor</p>
<p>Jasper 希望 她将这些车和他们的车主变成石头 turn … to … 把…变成…<br>Jasper hopes <code>that she will turn cars and their owners to stone</code></p>
<h3 id="单词-26"><a href="#单词-26" class="headerlink" title="单词"></a>单词</h3><p>rare: 罕见的，少见的<br>ancient: 古代的<br>effect: 效果<br>have effect: 有效果<br>turn … to … 把…变成…<br>none of them: 没有任何一个人<br>reputation：名誉<br>affected: 影响，打动</p>
<h2 id="29"><a href="#29" class="headerlink" title="29"></a>29</h2><p>然而，最令人惊讶的是他能在任何地方着落，that引导的表语从句，主系表<br>The most surprising thing about it, however, is <code>that it can land anywhere</code></p>
<p>on another occasion: 在另外一次情景中，还有一次</p>
<h3 id="难点-5"><a href="#难点-5" class="headerlink" title="难点"></a>难点</h3><p>bring: 拿来，come from somewhere with something<br>take: 拿走, away from somewhere with something<br>fetch: 去哪拿来某物 go somewhere, pick something up and bring it back</p>
<p>very: i arrived very late but i caught the train 我来的很晚，但我赶上火车了<br>too: i arrived too late and i missed the train 我来的太晚，我错过火车了</p>
<h3 id="单词-27"><a href="#单词-27" class="headerlink" title="单词"></a>单词</h3><p>plough: 犁，耕<br>lonely: 偏远的，孤僻的，孤单的<br>flat: 公寓<br>deserted: 废弃的<br>desert: 沙漠<br>Welsh: 威尔士的<br>remarkable：卓越，杰出<br>sowing: 播种</p>
<h2 id="30"><a href="#30" class="headerlink" title="30"></a>30</h2><p>as usual: 像往常一样</p>
<p>on fine afternoons: 天气晴朗的下午</p>
<h3 id="单词-28"><a href="#单词-28" class="headerlink" title="单词"></a>单词</h3><p>in sight: 在我视野里<br>row: 划船<br>oars: 船桨</p>
<h2 id="31"><a href="#31" class="headerlink" title="31"></a>31</h2><p>Frank 当时正在跟我说… 过去进行时<br>Frank Hawkins <code>was telling</code> me</p>
<p>修车是他的工作，It作为形式主语，to do不定式做主语<br>It was his job <code>to repair bicycles</code></p>
<p>在他20多岁的时候<br>In his twenties</p>
<p>used to do: 过去常常做某事</p>
<h3 id="单词-29"><a href="#单词-29" class="headerlink" title="单词"></a>单词</h3><p>economise: 节约，节省</p>
<h2 id="32"><a href="#32" class="headerlink" title="32"></a>32</h2><p><code>比较状语从句</code><br>人们不再像以前那样诚实了 not so&#x2F;as + 形容词 + as … 是不如…那样…<br>People are <code>not so</code> honest <code>as</code> they once were</p>
<p>偷窃的诱惑比以前更强 to steal 是动词不定式做 temptation的定语<br>it is … for sb to do sth<br>The temptation to steal is greater than ever before</p>
<p>wrap it up: 收尾，打包</p>
<p>as…as possible: 尽可能…</p>
<h3 id="单词-30"><a href="#单词-30" class="headerlink" title="单词"></a>单词</h3><p>well-dressed: 穿着得体的<br>tempation: 诱惑<br>article：文章，物品，东西<br>wrap: 包裹<br>find out： 查出<br>simply: 仅仅<br>arrest: 逮捕<br>without paying: 没有付款</p>
<h2 id="33"><a href="#33" class="headerlink" title="33"></a>33</h2><p>遇上了暴风雨， catch做突然遇上讲 <code>be caught in</code> 被抓住了被困在了…<br>was caught in a storm</p>
<p>一到岸边…  <code>on + 动名词</code> 相当于一个由 as soon as 引导的时间状语从句<br>on arriving at the shore … </p>
<p>having spent: 现在分词的完成时，表示时间状语，表示已经完成的动作</p>
<h3 id="难点-6"><a href="#难点-6" class="headerlink" title="难点"></a>难点</h3><p>passed: 通过<br>past: 过去的</p>
<p>next: 下一个 next day：下一天<br>other: 另一个 other day: 前几天</p>
<h3 id="单词-31"><a href="#单词-31" class="headerlink" title="单词"></a>单词</h3><p>explain: 解释，叙述<br>storm：暴风雨<br>cliff: 悬崖<br>struggle: 挣扎<br>set out: 出发，动身</p>
<h2 id="34"><a href="#34" class="headerlink" title="34"></a>34</h2><p>他不再担心了<br>he is not worried anymore</p>
<p>现在正用火车给他运回家 <code>被动语态用在现在进行时中 要在be后面加ing</code><br>It is now being sent to his home by train</p>
<p>most 有 very的意思，常与起形容词作用的过去分词连用<br>most surprised</p>
<p>call at 拜访哪个地方<br>call on 拜访哪个人<br>call out 喊叫<br>call up 打电话<br>call off &#x3D; cancel 取消</p>
<h3 id="单词-32"><a href="#单词-32" class="headerlink" title="单词"></a>单词</h3><p>station: 警察局<br>amused: 被逗乐了<br>call at: 拜访，也可以用call on<br>pick up: 有意外找到的意思<br>robbed: 被偷窃了</p>
<h2 id="35"><a href="#35" class="headerlink" title="35"></a>35</h2><p>一段时间以后<br>a short while age</p>
<p>far more:</p>
<p>see sb do sth: 看见某人做某事用原型<br>他看见两个小偷从商店跑出来跑向一个停着的车<br>he <code>saw two thieves rush out</code> of a shop and run towards a waiting car</p>
<p>see sb doing sth: 看见某人正在做某事<br>当我通过窗户的时候，我看见他正和一个男人说话<br>When i passed the window, I <code>saw her talking to a man</code></p>
<p>such (a&#x2F;an) + adj. n. that… 如此…以至于…<br>拿着钱的那个受到如此的惊吓以至于他落下了包<br>The one with the money got <code>such a fright that he dropped the bag</code></p>
<p>so 修饰形容词或副词<br>such 修饰名词</p>
<h3 id="单词-33"><a href="#单词-33" class="headerlink" title="单词"></a>单词</h3><p>regret: 后悔<br>fright: 惊吓<br>battered: 损坏</p>
<h2 id="36"><a href="#36" class="headerlink" title="36"></a>36</h2><p><code>将来进行时</code> will be doing<br>明天他将会一直紧张的看着他当她游很长的距离去英国的时候<br>Tomorrow he <code>will be watching</code> her anxiously as she swims the long distance to England</p>
<p>他们当中将会有Debbie的妈妈，<code>倒装句</code> 正常应该是 Debbie’s mother will be among them<br>among them will be Debbie’s mother</p>
<h3 id="单词-34"><a href="#单词-34" class="headerlink" title="单词"></a>单词</h3><p>set up: 创造<br>intend: 打算<br>take rest: 休息</p>
<h2 id="37"><a href="#37" class="headerlink" title="37"></a>37</h2><p><code>将来完成时</code> will have + done<br>工人将在今年年末完成这个新路 by引导一个未来的时间<br>Workers <code>will have completed</code> the new roads by the end of this year</p>
<h3 id="单词-35"><a href="#单词-35" class="headerlink" title="单词"></a>单词</h3><p>hold: 举办<br>immense：巨大的<br>standard: 标准，规格<br>fantastic: 巨大的<br>look forward: 期待</p>
<h2 id="38"><a href="#38" class="headerlink" title="38"></a>38</h2><p>他一回来就买了一个房子住进去， no sooner than 相当于 as soon as 一…就… 主句过去完成时，从句一般过去时<br>He had <code>no sooner</code> returned <code>than</code> he bought a house and went to live there</p>
<p>他还没来得及安顿下来就卖掉了房子离开了这个国家 hardly … when … 几乎没来得及…就…<br>He had <code>hardly</code> had time to settle down <code>when</code> he sold the house and left the country</p>
<p>因为即使它还是夏天的时候，他也在下雨而且刺骨的冷<br>for even though it was still summer and it was often bitterly cold</p>
<p>他表现的就好像他之前从未居住在英国过<br>He acted as if he had never lived in England before</p>
<p>他超过我能忍受的程度了。。 它比我能忍受的更多，超过了我的忍受<br>it was more than he could bear</p>
<h3 id="单词-36"><a href="#单词-36" class="headerlink" title="单词"></a>单词</h3><p>settle down: 安居，定居<br>Mediterranean: 地中海的<br>even though: 即使<br>continually: 不断的,频繁的<br>continuously: 连续不断的<br>bitterly: 刺骨的<br>acted: 表现得<br>as if: 就好像<br>bear &#x3D; put up with: 忍受<br>any longer: 再也不…</p>
<h2 id="39"><a href="#39" class="headerlink" title="39"></a>39</h2><p>接下来一天<br>The following day</p>
<p>他问Gilbert先生的手术是否成功，转述疑问句用asked，if引导一般疑问句是否…<br>He <code>asked if</code> Mr. Gilbert’s operation had been successful<br>原话：has Mr. Gilberts’s operation been successful?</p>
<p>他这时候又问道 Gilbert先生将在什么时候能被允许回家呢 特殊疑问句直接跟上<br>He then <code>asked when</code> Mr. Gilbert would be allowed to go home<br>原话：When will Mr. Gilbert be allowed to go home</p>
<h3 id="单词-37"><a href="#单词-37" class="headerlink" title="单词"></a>单词</h3><p>in hospital: 住院<br>in the hospital: 在医院<br>exchange: 交接台<br>inquire: 询问<br>certain: 某位<br>surgeon: 外科医生</p>
<h2 id="40"><a href="#40" class="headerlink" title="40"></a>40</h2><p><code>虚拟语气 用过去时表示另外一种情况，和现在的不一样 虚拟语气里面be动词都是were</code><br>‘Young man, if you <code>ate</code> more and <code>talked</code> less, we <code>would</code> both enjoy our dinner’</p>
<h3 id="单词-38"><a href="#单词-38" class="headerlink" title="单词"></a>单词</h3><p>hostess: 女主人<br>unsmile: 不笑的<br>tight: 紧身的<br>take my seat: 拿我的椅子做下<br>look up: 抬头看<br>despair: 绝望<br>briefly: 简要的<br>do exercises: 做练习<br>do business: 做生意<br>do one’s best: 尽自己最大的努力<br>do some shopping: 买东西</p>
<h2 id="41"><a href="#41" class="headerlink" title="41"></a>41</h2><p>你不必说那样的话，我的妻子说 <code>needn&#39;t 情态动词 + 动词原形</code><br>needn’t have done 表示不用那么做，但是已经那么做了， need情态动词只能用在否定句和疑问句中<br>‘You <code>needn&#39;t</code> have said that,’ my wife answered</p>
<p>needn’t &#x3D; don’t have to</p>
<p>我觉得他很漂亮,我说，一个男人有再多的领带也不嫌多<br>‘I find it beautiful,’ I said. ‘A man can never have too many ties’</p>
<h3 id="单词-39"><a href="#单词-39" class="headerlink" title="单词"></a>单词</h3><p>mirror: 镜子<br>needn’t &#x3D; don’t have to</p>
<h2 id="42"><a href="#42" class="headerlink" title="42"></a>42</h2><p>have + 名词 &#x3D; 这个名词做动词时候的意思</p>
<p>pick you up: 接你</p>
<p>picked up a lot of English: 学习了很多英语</p>
<p>pick out: 挑出来，选出来</p>
<p>显然，他辨别不出印第安音乐和爵士乐的不同<br>It obviously could not tell the difference between Indian music and jazz</p>
<h3 id="单词-40"><a href="#单词-40" class="headerlink" title="单词"></a>单词</h3><p>have a long walk: 走了很长一段路<br>have a rest: 休息一下<br>charmer: 魔术师<br>snake charmer: 舞蛇人<br>pipe: 管道，笛子<br>tune: 曲子<br>movements: 运动，动作<br>obviously: 明显的，显然的<br>tell the difference between … 辨别…之间的不同</p>
<h2 id="43"><a href="#43" class="headerlink" title="43"></a>43</h2><p>run into trouble 遇到麻烦<br>it seemed certain: 他看起来肯定</p>
<p>表示动作已经完成用<br>was&#x2F;were able to 不能用 could 换，其他时候可以互换</p>
<p>steal sb’s handbag &#x3D; rob sb of his handbag</p>
<h3 id="单词-41"><a href="#单词-41" class="headerlink" title="单词"></a>单词</h3><p>Pole: 极<br>the South Pole: 南极<br>point: 地点<br>clear: 越过<br>at any rate：好歹，不管怎么说<br>be at a loss：不知所措<br>at time: 有时<br>at least: 至少<br>at present: 此时此刻</p>
<h2 id="44"><a href="#44" class="headerlink" title="44"></a>44</h2><p>她所冒的风险<br>the risk she was taking</p>
<p>喘不上气，上气不接下气<br>out of breath</p>
<p>to do 和 doing 有些时候可以互换，有时候不行，比如doing表示宽泛的做这个事情，to do 表示做了具体的某个事情</p>
<h3 id="单词-42"><a href="#单词-42" class="headerlink" title="单词"></a>单词</h3><p>take the risk: 冒…风险<br>risk: 危险，冒险<br>fright: 惊吓的<br>in one’s possession: 为…所有<br>possession: 所有<br>picnic: 野餐<br>strap: 皮带<br>breath: 呼吸<br>going through: 翻看<br>daring：大胆</p>
<h2 id="45"><a href="#45" class="headerlink" title="45"></a>45</h2><h3 id="单词-43"><a href="#单词-43" class="headerlink" title="单词"></a>单词</h3><p>pay back: 偿还，报仇<br>rob: 抢<br>rob sb of sth<br>clear: 无罪的，不亏心的<br>conscience: 良心<br>in time: 最后，终于</p>
<h2 id="46"><a href="#46" class="headerlink" title="46"></a>46</h2><p>account for: 解释<br>没人能解释这些箱子中的一个为什么是如此的重 <code>that引导的同位语从句说明这个事实</code><br>No one could account for the fact <code>that one of the boxes was extremely heavy</code></p>
<p>astonished at: 对于什么惊讶<br>superised at: 对于什么惊喜</p>
<h3 id="单词-44"><a href="#单词-44" class="headerlink" title="单词"></a>单词</h3><p>pile: 堆<br>astonish: 使惊讶<br>occur: 发生<br>occur to: 想起<br>extremely: 及其，非常<br>admit: 承认<br>confine: 关在</p>
<h2 id="47"><a href="#47" class="headerlink" title="47"></a>47</h2><p>因为他听到一个奇怪的声音，来自吧台的奇怪声音，宾语补足语<br>because he heard a strange noise <code>coming from the bar</code></p>
<h3 id="单词-45"><a href="#单词-45" class="headerlink" title="单词"></a>单词</h3><p>haunt: 来访，闹鬼<br>furniture: 家具<br>suggest: 暗示<br>shake: 摇动<br>shake one’s head: 摇头</p>
<h2 id="48"><a href="#48" class="headerlink" title="48"></a>48</h2><p>当你不能回答的时候牙医总问你问题 when引导时间状语从句，it是形式主语， 正确语序 to answer is impossible for you<br>Dentists always ask questions <code>when it is impossible for you to answer</code></p>
<p>他刚刚告诉我去休息一会，转述told的时候可以接 to do 不定式 说的实际是 rest for a while<br>he had told me <code>to rest for a while</code></p>
<p>他知道我收集火柴盒，他问我我的收藏是否增加了 whether 引导一般疑问句， 转述的时候，使用过去式陈述语序，正常问话：is you collection growing?<br>he knew (that) i collected match boxes and asked me <code>whether my collection was growing</code></p>
<h3 id="单词-46"><a href="#单词-46" class="headerlink" title="单词"></a>单词</h3><p>pull out: 拔牙<br>cotton: 棉花<br>cotton wool: 药棉<br>search out: 搜寻</p>
<h2 id="49"><a href="#49" class="headerlink" title="49"></a>49</h2><p>因为厌倦了睡地上，一个年轻人在 Teheran 存了很多年钱买了一个真床。前面的是原因，因为主语一样，所以前面的可以省略主语<br>Tired of sleeping on the floor, a young man in Teheran saved up for years to buy a real bed</p>
<p>Because + 句子<br>because of + 名词</p>
<p>他睡得很好， sleep weel 睡得好 第一二晚上睡得好<br>He slept very well for the first two nights</p>
<p>暴风雨来的猛烈<br>a storm blew up</p>
<p>这个男人知道床撞到地面才醒过来， not…until: 直到…才…<br>The young man did <code>not</code> wake up <code>until</code> the bed had struck the ground</p>
<p>一阵风把床从屋顶吹的撞到了院子下面 <code>crashing 现在分词短语做宾语补足语</code><br>A gust of wind swept the bed off the roof and sent it <code>crashing into the courtyard below</code></p>
<h3 id="单词-47"><a href="#单词-47" class="headerlink" title="单词"></a>单词</h3><p>be tired of: 厌倦了，疲倦了<br>springs: 弹簧<br>sleep weel 睡得好<br>gust: 阵风<br>courtyard: 院子<br>smashe: 粉碎，撞碎<br>miraculously: 奇迹般的<br>glance：撇一眼<br>metal: 金属<br>promptly: 及时，迅速地</p>
<h2 id="50"><a href="#50" class="headerlink" title="50"></a>50</h2><p>losing my way: 迷路</p>
<p>我最近去做了一次旅行，但是我的旅行花费的时间比我想的更长<br>i went on an excursion recently, but my trip took me longer than i expected</p>
<p>take做花费讲，花费某人一些时间做某事 to do sth做主语<br><code>it takes/took </code>me some time <code>to do sth</code></p>
<p>我坐在公交车里面的前面因为能看到乡村的好风景<br>i sat <code>in the front of</code> the bus to get a good view of the countryside</p>
<p>in the front of: 在…里面的前面<br>in front of: 在外面的前面</p>
<p>两句话的主语相同，可以把一个放在前面省略主语做状语，变成现在分词形式，<code>悬垂状语</code><br><code>Looking round</code>, i realized with a shock that i was the only passenger left on the bus</p>
<p>forget to do sth: 忘记做某事<br>forget doing: 忘记做过什么事</p>
<p>那我更喜欢呆在车上<br>i <code>prefer to stay</code> on the bus</p>
<p>宽泛的说相对于踢足球我更喜欢看足球<br>i <code>prefer watching</code> football to playing it</p>
<p>prefer to do: 更喜欢去做某事<br>prefer doing: 宽泛的说我更喜欢做这个事情</p>
<h3 id="单词-48"><a href="#单词-48" class="headerlink" title="单词"></a>单词</h3><p>excursion: 远足<br>in that case: 在这种情况下，既然如此</p>
<h2 id="51"><a href="#51" class="headerlink" title="51"></a>51</h2><p>实行节食<br>go on a diet &#x3D; be on a diet</p>
<p>我去拜访他<br>i <code>paid</code> him <code>a visit</code><br>paid sb a visit &#x3D; visit sb: 拜访某人</p>
<p>显然他干到很尴尬， it形式主语，that引导名词性从句做主语，同位语从句<br>it was obvious <code>that he was very embarrassed</code></p>
<h3 id="难点-7"><a href="#难点-7" class="headerlink" title="难点"></a>难点</h3><p>raise: 提起来，抬起来，形容放在后面的词<br>rise: 起来，升起来，形容放在前面的词<br>lie: 躺着，形容前面的词 sb lie<br>lay: 摆放，形容后面的词 lay sth<br>beat: 打败对方，beat sb<br>win: 赢得比赛，win sth</p>
<h3 id="单词-49"><a href="#单词-49" class="headerlink" title="单词"></a>单词</h3><p>reward: 报偿，给奖赏<br>diet: 节食<br>virtue: 美德<br>guiltily: 内疚的<br>occasionally: 偶尔的<br>led: 引导，领着<br>obvious： 显然的</p>
<h2 id="52"><a href="#52" class="headerlink" title="52"></a>52</h2><p><code>现在完成进行时</code> have been + doing 表示动作在某一时间段内一直在进行，到现在，可能不进行了也可能还在进行，句中常有all+时间 all morning等</p>
<p>我整个上午一直在努力工作<br>I <code>have been working</code> hard all morning</p>
<p>我一直在尝试整理好我的新房间<br>i <code>have been trying</code> to <code>get my new room in order</code></p>
<p>get…in order: 把….整理好</p>
<p>help sb to do sth<br>help sb do sth</p>
<h3 id="单词-50"><a href="#单词-50" class="headerlink" title="单词"></a>单词</h3><p>temporarily: 暂时的<br>gazed: 凝视<br>proved：证实<br>rather：相当<br>prettiest： 最漂亮的 pretty 的最高级<br>otherwise: 不同的</p>
<h2 id="53"><a href="#53" class="headerlink" title="53"></a>53</h2><p>throw…away: 把…扔掉<br>throw … to …:把…扔给…<br>throw…. at … 把…扔向… </p>
<p>quiet: 安静<br>quite: 十分，相当</p>
<p>cause: 原因<br>reason: 缘由，理由，说服，劝说</p>
<p>drop: 使掉下<br>fall：掉下，落下</p>
<h3 id="单词-51"><a href="#单词-51" class="headerlink" title="单词"></a>单词</h3><p>hot: 带电的<br>remains: 尸体<br>wire: 金属线，电线<br>power line: 电力线<br>snatch: 抓住<br>spark: 电火花<br>explanation: 解释<br>evidence：证据<br>wound: 缠绕</p>
<h2 id="54"><a href="#54" class="headerlink" title="54"></a>54</h2><p>我回到家的时候还挺早的。returned home 回家，home是副词，可以直接跟在return后面，回学校returned to school<br>it was still early when i <code>returned home</code></p>
<p>一会之后我正忙着混合黄油和面粉 be busy doing: 忙着做某事<br>In a short time I <code>was busy mixing</code> butter and flour</p>
<p>我刚回到厨房，门铃就响起来了，响的足够大可以把死人吵醒<br><code>no sooner ... than...</code> 一…就…<br>I had <code>no sooner</code> got back to the kitchen <code>than</code> the doorbell rang loud enough to wake the dead</p>
<p>没什么比这个更恼人的了<br>nothing could have been more annoying</p>
<h3 id="单词-52"><a href="#单词-52" class="headerlink" title="单词"></a>单词</h3><p>sticky: 黏黏的<br>pastry: 面糊<br>annoying: 恼人的<br>dismay: 沮丧的,失望<br>doorknobs: 门把手<br>receiver: 电话话筒<br>register letter: 挂号信</p>
<h2 id="55"><a href="#55" class="headerlink" title="55"></a>55</h2><p>尽管如此<br>in spite of this</p>
<p>come true: 实现，成真</p>
<p>一个新机器被叫做The Revealer已经被发明出来了，他被使用来探测被埋葬在底下的金子<br>A new machine <code>(which is) called</code> ‘The Revealer’ <code>has been invented</code> and it <code>has been used</code> to detect gold which <code>has been buried</code> in the ground </p>
<p>sth be used to do<br>sth be used for doing</p>
<p>据说，是海盗们过去常常藏金子的地方 it is said 是插入语，据说…<br>where - it is said - pirates used to hide gold</p>
<p>海盗们过去经常埋金子在山洞里 <code>would do</code>过去…<br>The pirates would often bury gold in the cave</p>
<p>Armed with 过去分词做状语，hoping to 现在分词做状语<br><code>Armed with</code> the new machine, a search party went into the cave <code>hoping to </code> find buried treasure</p>
<p><code>状语</code>：形容词做状语，被动语态用过去分词做状语，主动语态用现在分词做状语</p>
<h3 id="单词-53"><a href="#单词-53" class="headerlink" title="单词"></a>单词</h3><p>revealer: 探索者<br>pirate: 海盗<br>thoroughly: 彻底的<br>trunk: 行李箱<br>confident: 有信心的<br>fairly： 快</p>
<h2 id="56"><a href="#56" class="headerlink" title="56"></a>56</h2><p>每年<br>once a year</p>
<p>在他开始之前他们都很激动<br>there was <code>a great deal of</code> excitement just before it began</p>
<p>在许多响亮的爆炸声之后，比赛开始了<br>after <code>a great many</code> loud explosions, the race began</p>
<p>许多司机花费了更多的时间在车下面，而不是车里面<br>some drivers spent more time under their cars than in them</p>
<h3 id="单词-54"><a href="#单词-54" class="headerlink" title="单词"></a>单词</h3><p>a great deal of + 不可数名词： 大量的<br>a great many + 可数名词: 大量的<br>explosion: 爆炸<br>course: 赛道<br>rival: 对手<br>break down: 抛锚，出故障</p>
<h2 id="57"><a href="#57" class="headerlink" title="57"></a>57</h2><p>他享受自己做某事<br>she enjoyed onself doing</p>
<p>let 和 make 后面要跟不带to的动词不定式</p>
<h3 id="单词-55"><a href="#单词-55" class="headerlink" title="单词"></a>单词</h3><p>hesitate: 犹豫<br>scornfully: 轻蔑的<br>seek: 寻找<br>eager: 热情的</p>
<h2 id="58"><a href="#58" class="headerlink" title="58"></a>58</h2><p>it is … that … 强调句式，强调最近几年的时间，他才获得了一个邪恶的名声<br>but <code>it is</code> only in recent years <code>that</code> it has gained an evil reputation</p>
<p>这个牧师被要求找人把树砍掉 have sth done 是让别人做某事 如果是cut the tree down 是自己砍树<br>The vicar has been asked to <code>have</code> the tree <code>cut down</code></p>
<p>In spite of 和 Despite 可以互换</p>
<h3 id="单词-56"><a href="#单词-56" class="headerlink" title="单词"></a>单词</h3><p>bless: 保佑<br>disguise: 伪装<br>possess: 拥有<br>curse: 诅咒<br>mention：提到<br>gained：获得<br>reputation：名声<br>vicar：牧师<br>claim: 以….为后果<br>victim: 受害者<br>trunk: 树干</p>
<h2 id="59"><a href="#59" class="headerlink" title="59"></a>59</h2><p>spend 时间 doing:花费时间做某事</p>
<p>这次他正在叫，为的是有人能让他出去，so that引导目的状语，表示什么目的<br>This time he was barking <code>so that</code> someone would let him out</p>
<h3 id="单词-57"><a href="#单词-57" class="headerlink" title="单词"></a>单词</h3><p>bark: 叫<br>expert: 专家</p>
<h2 id="60"><a href="#60" class="headerlink" title="60"></a>60</h2><p>你一离开这里，你将会获得一个大惊喜， The moment引导时间状语，一…就…，主句一般将来时，从句一般现在时<br><code>The moment you leave</code> this tent, you <code>will get</code> a big surprise</p>
<p>that is all: 这就是全部</p>
<p>in less than an hour: 不到一个小时</p>
<h3 id="单词-58"><a href="#单词-58" class="headerlink" title="单词"></a>单词</h3><p>fair: 集市<br>village fair: 村庄集市<br>crystal: 水晶<br>impatiently: 不耐心地，不耐烦地</p>
<h2 id="61"><a href="#61" class="headerlink" title="61"></a>61</h2><p>哈勃望远镜1990-4-20通过NASA被发射到太空，花费了超过壹佰亿美元，at a cost of 花费多少钱<br>The Hubble telescope was launched into space by NASA on April 20,1990 <code>at a cost of</code> over a billion dollars</p>
<p>从最开始<br>Right from the start</p>
<p>当宇航员们做必要的修补的时候，一个机械臂将从Endeavour里面伸出来抓住他， <code>while引导时间状语从句，主将从现</code><br>A robot-arm from the Endeavour will grab the telescope and hold it while the astronauts make the necessary reparis</p>
<p>当你读到这的时候，哈勃的鹰眼将发送给我们成千上万的神奇的照片了<br><code>By the time</code> you read this,the hubble’s eagle eye will have sent us thousands and thousands of wonderful pictures</p>
<h3 id="单词-59"><a href="#单词-59" class="headerlink" title="单词"></a>单词</h3><p>launch: 发射<br>telescope：望远镜<br>space：太空<br>faulty: 有问题的<br>shuttle: 航天飞机<br>Endeavour: 奋进号<br>grab: 抓住<br>galaxy: 星系<br>eagle eye: 鹰眼<br>distant: 遥远的<br>atmosphere: 大气层</p>
<h2 id="62"><a href="#62" class="headerlink" title="62"></a>62</h2><p>消防员在他们能把火势控制住之前，已经和这个森林火灾对抗了几乎三周了<br><code>过去完成进行时</code> had been + doing 有一个过去的时间点，在这个时间点之前一直持续做某事，有一个持续的时间段<br>Firemen <code>had been fighting</code> the forest fire <code>for nearly three weeks</code> <code>before they could</code> get it under control</p>
<p>截止到这个时候之前，然而，许多地方的草都已经生根了<br><code>By + 时间表示截止到这个时间之前</code><br><code>By then</code>,however, in many places the grass had already taken root</p>
<p>替代这些已经生长了一个世纪的参天大树的，是一片片的绿色出现在了这片焦土上。<br>in place of the great trees which had been growing there for centuries,patches of green had begun to appear in the blackened soil</p>
<p>冬季即将来临<br>winter was coming on</p>
<h3 id="单词-60"><a href="#单词-60" class="headerlink" title="单词"></a>单词</h3><p>under control: 控制住，在控制之中<br>take root: 生根<br>in place of: 替代了<br>the great trees: 参天大树<br>patches of green： 一片片的绿色<br>flood: 洪水<br>spray：喷雾<br>quantily: 量<br>desolate: 荒凉的<br>threaten: 威胁</p>
<h2 id="63"><a href="#63" class="headerlink" title="63"></a>63</h2><p>这就是Jeremy喜欢的这类事情<br>This is the sort of thing that Jeremy loves</p>
<p>但是他还是按照他女儿要求的做了，<code>as 做连词引导状语从句，表示方式</code><br>but he did <code>as his daughter asked</code></p>
<p>她告诉他她不喜欢看到这么多人嘲笑他， <code>see so sb doing</code><br>she told him that she did not like to see so many people laughing at him</p>
<h3 id="结构难点"><a href="#结构难点" class="headerlink" title="结构难点"></a>结构难点</h3><p>当直接引语是祈使句，变成间接引语将谓语动词变成动词不定式<br>“Don’t make so much noise”<br>She told them not to make so much noise</p>
<p>如果主语的谓语动词是<code>suggest</code>或<code>insist</code>,间接引语变成<code>主语+should+动词原形</code><br>“Ask him about it,” he insisted<br>He insisted that i should ask him about it</p>
<h3 id="单词-61"><a href="#单词-61" class="headerlink" title="单词"></a>单词</h3><p>amused: 被逗乐了<br>sense of humor: 幽默感<br>circle of friends: 朋友圈<br>close: 紧密的<br>wedding reception：婚宴<br>sort: 种类<br>laughing at: 嘲笑</p>
<h2 id="64"><a href="#64" class="headerlink" title="64"></a>64</h2><p>如果高的烟囱被建造在海平面上方，这个隧道将有好的通风<br><code>真实条件句</code>：表示假设或愿望，主将从现，主句过去将来时，从句一般过去时<br>The tunnel <code>would be</code> well-ventilated if tall chimaneys were built above sea level</p>
<p>如果当时,英国人呢不害怕入侵，他将已经被完成了<br><code>虚拟条件句</code>：对于过去事实的假设，从句 if had 动词过去分词 主句 would have 动词过去分词<br>if at the time，the British <code>had not feared</code> invasion,it <code>would have been completed</code></p>
<h3 id="单词-62"><a href="#单词-62" class="headerlink" title="单词"></a>单词</h3><p>ventilate: 通风<br>chimney: 烟囱<br>put forward：提出<br>a double railway-tunnel should be built: 一个双轨铁路隧道应该被建造<br>draw in: 引进来<br>draw up: 起草<br>draw off: 开走<br>draw back: 退后<br>invasion: 入侵<br>officially: 正式的<br>continent: 大陆<br>propose：提出</p>
<h2 id="65"><a href="#65" class="headerlink" title="65"></a>65</h2><p><code>分词做状语</code> 过去分词被动语态做状语，现在分词主动语态做状语<br>他穿着圣诞老人的衣服，有6个漂亮的女孩陪着，坐着被叫做Jumbo的小象动身往城市的主路上走着<br><code>Dressed up</code> as Father Christmas and <code>accompanied</code> by a ‘guard of honour’ of six pretty girls,he set off down the main street of the city <code>riding</code> a baby elephant called Jumbo</p>
<p><code>should/ought to + have 动词过去分词 应该做某事，应当做某事</code><br>他应该知道警察绝对不会允许这类事情<br>He <code>should have known</code> that the police would never allow this sort of thing</p>
<p>所以他幸运的是我们可以不用扛着他<br>so it was fortunate that we didn’t have to carry him</p>
<h3 id="单词-63"><a href="#单词-63" class="headerlink" title="单词"></a>单词</h3><p>versus：相对，谁和谁比拼<br>circus: 马戏团<br>present: 礼物<br>guard of honour：仪仗队<br>set off：出发<br>ought: 应该，应当<br>side street: 辅路<br>holding up the traffic: 影响交通<br>furtunate: 幸运的<br>arrest：逮捕<br>let off: 放过<br>let down: 拒绝<br>let in：让…进入<br>let out：放出</p>
<h2 id="66"><a href="#66" class="headerlink" title="66"></a>66</h2><p>这场事故被遗忘了，残骸没有被人打扰还保持原状<br>the crash was forgotten and the wreck remained undisturbed</p>
<p>到现在为止，一个良好状况的Lancaster轰炸机是罕见的，值得拯救一下。<br><code>worth doing</code> 值得做某事, <code>in reasonable condition</code> 在良好的条件下，状况良好<br>By this time, a Lancaster bomber in reasonable condition was rare and worth resuing</p>
<p><code>使役动词 have sth done 是让别人做某事</code></p>
<p>一群蜜蜂在之前已经回到了这个引擎，进入了蜂房，所以它被蜂蜡完整地保存了下来<br>A colony of bees had turned the engine into a hive and it was totally preserved in beeswax</p>
<h3 id="单词-64"><a href="#单词-64" class="headerlink" title="单词"></a>单词</h3><p>badly：严重<br>wreck: 残骸<br>remain：保留<br>undisturbed: 不受干扰<br>accidentally：意外地<br>aerial survey：航空测量<br>reasonable：合理的<br>enthusiasts: 爱好者<br>packing case：包装箱<br>imagine: 想象<br>totally: 完全的<br>preserved: 保存<br>beeswax：蜂蜡</p>
<h2 id="67"><a href="#67" class="headerlink" title="67"></a>67</h2><p>Tazieff 能够成功把他的营地设置在火山附近当火山正猛烈喷发的时候 <code>was able to 代表费了一点周折成功做了某事</code><br>Tazieff <code>was able to</code> set up his camp very close to the volcano while it was erupting violently</p>
<p>尽管他成功的拍了许多杰出的照片 <code>managed to 代表费了一点周折成功做了某事</code><br>Though he <code>managed to</code> take a number of brilliant photographs</p>
<p>一股岩浆<br>a river of liquid rock</p>
<h3 id="单词-65"><a href="#单词-65" class="headerlink" title="单词"></a>单词</h3><p>volcanoes: 火山<br>erupt: 喷发<br>violently：猛烈地<br>brilliant: 杰出的<br>in time: 及时的<br>risk：冒险<br>tell a lie: 说谎<br>tell the time: 报时<br>tell the difference between: 区别</p>
<h2 id="68"><a href="#68" class="headerlink" title="68"></a>68</h2><p>避免做某事<br>avoid doing</p>
<p>享受某事<br>enjoy doing</p>
<p>prevent sb from doing sth 预防某人做某事</p>
<p>fancy doing: 表示对…干到惊奇</p>
<p>假装我之前没看到他是没必要的 <code>pretending 现在分词短语做主语</code><br>It was no use <code>pretending that i had not seen him</code></p>
<p>不管你有多忙，他总是坚持跟着你 <code>no matter</code> 引导的让步状语从句， no matter和how,when等连接，翻译成无论<br><code>No matter</code> how busy you are, he always insists on comming with you</p>
<p>我刚刚一直在思考如果度过这个早上<br>I was just wondering how to spend the morning</p>
<p>你介意我和你一起吗？<br>would you mind my coming with you</p>
<h3 id="单词-66"><a href="#单词-66" class="headerlink" title="单词"></a>单词</h3><p>pretend: 假装<br>prevent: 预防<br>fancy: 极好的<br>rush hour：高峰时间<br>insisted on:坚持做某事</p>
<h2 id="69"><a href="#69" class="headerlink" title="69"></a>69</h2><p>我当时正在被测试驾照考试，已经第三次了 被动语态在进行时里面be变成being<br>I <code>was being tested</code> for a driving licence for the third time</p>
<p>我之前被要求在高峰期开车<br>I <code>had been asked</code> to drive in heavy traffic</p>
<p>我被指示开出小镇之后，我开始有了自信 <code>After介词后要加动名词所以had变成having</code><br>After <code>having been instructed</code> to drive out of town，I began to acquire confidence</p>
<p>考官肯定觉得我的表现不错，很高兴 <code>must have 过去分词表示对过去的事情推测</code><br>The examiner <code>must have been pleased</code> with my performance</p>
<p>做出反应花了我很长时间 to react做主语<br>It took me a long time to react</p>
<h3 id="单词-67"><a href="#单词-67" class="headerlink" title="单词"></a>单词</h3><p>murder: 谋杀<br>instruct：指示<br>acquire: 获得<br>suppose: 假设<br>tap: 轻敲<br>pedal: 踏板<br>mournful: 悲伤的<br>confess：承认</p>
<h2 id="70"><a href="#70" class="headerlink" title="70"></a>70</h2><p>但是它突然看到这个醉汉<br>but it suddenly <code>caught sight of</code> the drunk who was shouting rude remarks and</p>
<p>显然对于批评很敏感 <code>sensitive to 对...敏感</code><br>Apparently <code>sensitive to</code> criticism</p>
<p>当这个公牛接近他的时候，他笨拙的移开了让它冲过去了<br>When the bull <code>got close to</code> him, he clumsily stepped aside to let it pass</p>
<p>人群突然爆发欢呼声，这个醉汉鞠躬<br>The crowd <code>broke into cheers</code> and the drunk bowed</p>
<p>即使这个公牛看起来像是为他感觉遗憾，因为它同情的看热闹直到这个醉汉被拖走，在注意力转到这个斗牛士之前<br>Even the bull seemed to <code>feel sorry for</code> him, for it looked on sympathetically until the drunk was out of the way before once more turning its <code>attention to</code> the matador</p>
<h3 id="单词-68"><a href="#单词-68" class="headerlink" title="单词"></a>单词</h3><p>bullfight: 斗牛<br>drunk: 醉汉<br>wandered: 慢慢的挪步<br>unaware: 不知道，意识不到<br>matador: 斗牛士<br>rude remarks: 说脏话<br>apparently：显然<br>grew quiet: 变得安静<br>clumsily: 笨拙的<br>clumsily stepped aside：笨拙的移动到旁边<br>got close to：接近了<br>bowed：鞠躬<br>sympathetically: 同情的<br>look on: 看热闹</p>
<h2 id="71"><a href="#71" class="headerlink" title="71"></a>71</h2><p>大本钟是用 Benjamin Hall 的名字来命名的<br>Big Ben takes its name from Sir Benjamin Hall</p>
<h3 id="单词-69"><a href="#单词-69" class="headerlink" title="单词"></a>单词</h3><p>burned down： 烧光了<br>erected: 竖立<br>accurate： 准确的<br>immense: 巨大的<br>extremely: 极其的<br>responsible： 负责任的</p>
<h2 id="72"><a href="#72" class="headerlink" title="72"></a>72</h2><p>开始的行程<br>the first run</p>
<p>追随他爸爸的足迹<br>Following in his father’s footsteps</p>
<h3 id="单词-70"><a href="#单词-70" class="headerlink" title="单词"></a>单词</h3><p>burst: 爆裂<br>footsteps: 足迹<br>skidded: 打滑的<br>overturned：推翻</p>
<h2 id="73"><a href="#73" class="headerlink" title="73"></a>73</h2><p>记录保持者<br>The record holder</p>
<p>安静钓一天鱼,或者8个小时在电影院一遍又一遍看一样的电影，是通常他们能做的最多的事情了<br><code>over and over again</code>一遍又一遍<br><code>as far as</code>表示到….程度<br>A quiet day’s fishing，or eight hours in a cinema seeing the same film over and over again,is usually as far as they get</p>
<p>他搭便车去Dover，快到晚上的时候，进入一个船寻找睡觉的地方<br><code>towards evening</code>快到晚上的时候<br><code>to find somewhere</code> to do 不定式做状语，找一些地方  <code>to sleep</code> to do不定式做定语，睡觉的地方<br>He hitchhiked to Dover and, towards evening, went into a boat <code>to find somewhere to sleep</code></p>
<p>在他第二天早上醒来的时候，他发现这个船在这段时间已经开往Calais了<br><code>in the meantime</code> 在这段时间<br>When he woke up next morning,he discovered <code>that the boat had, in the meantime, travelled to Calais</code></p>
<p>这个男孩截住的下一辆车没把他像他希望的那样带到巴黎市中心，而是去了在法国和西班牙的边界Perpignan<br><code>as he hoped it would</code> 方式状语从句，像他希望的那样<br>The next car the boy stopped did not take him into the centre of Paris <code>as he hoped it would,</code> but to Perpignan on the French-Spanish border</p>
<p>他无疑为成千上万梦想逃学的孩子创造了一个记录<br>He has surely set up a record for the thousands of children who dream of evading school</p>
<h3 id="单词-71"><a href="#单词-71" class="headerlink" title="单词"></a>单词</h3><p>truant: 逃学<br>unimaginative: 想象力不丰富的<br>hitchhike: 搭便车<br>lorry: 卡车<br>evade: 逃脱</p>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>新概念英语</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统原理第七节</title>
    <url>/%E8%8B%B1%E8%AF%AD%E7%9F%AD%E8%AF%AD.html</url>
    <content><![CDATA[<h3 id="短语"><a href="#短语" class="headerlink" title="短语"></a>短语</h3><p>pay attention to: 关注，注意, 后面加动名词，不能加动词</p>
<p>look forward to: 期待</p>
<p>so … that: 如此…以至于… so是副词后面加形容词或副词<br>such…that: 如此…以至于… such是形容词，后面可以加可数名词或不可数名词，名词前面可以有形容词</p>
<p>connect…with: 把….和…联系起来</p>
<p>unless: 连词，如果不，除非，等同于 if…not</p>
<p>put on: 穿上，表演，发胖<br>put away: 收起来<br>put out: 熄灭<br>put up:<br>put off: 脱下<br>put down: </p>
<p>warn sb to do sth: 警告某人做某事</p>
<p>end up：最终成为<br>end up doing sth: 最终做某事</p>
<p>take up: 占用<br>stay up: 熬夜<br>use up: 用完</p>
<p>or not 前面只能用whether</p>
<p>too to 和 so that是同义词</p>
<p>in order to: 为了，以便于</p>
<p>have the ability to do sth: 有能力做某事</p>
<p>became interested in…:变得对…感兴趣</p>
<p>keep doing sth: 坚持做某事</p>
<p>practice doing sth:练习做某事</p>
<p>sth cost&#x2F;cost sb + 钱数 主语是物</p>
<p>sb pay&#x2F;paid some money for sth 主语是人</p>
<p>sb spend&#x2F;spent some time on sth&#x2F;doing sth 花时间主语是人<br>sb spend&#x2F;spent some money on sth&#x2F;doing sth 花钱主语是人</p>
<p>It takes&#x2F;took on doing sth 花时间<br>it takes sb some time to do sth</p>
<p>反义疑问句前肯后否，前否后肯<br>回答依据事实，前否后肯的回答中，yes和no的意思相反</p>
<p>be used to: 习惯于<br>used to be:曾经常常做某事<br>didn’t use to do sth: 过去不常做某事<br>did use to do sth? 过去经常做某事吗？<br>be used to doing sth: 习惯于做某事</p>
<p>take up + 时间或地点表示占用占据<br>take up + 事物表示开始做某事，学着做某事<br>take out:取出<br>take off:起飞<br>take away: 带走<br>take after: 像<br>take part in: 参加，加入<br>take place:发生<br>take one’s temperature: 量体温</p>
<p>deal with: 处理，应付</p>
<p>in trouble: 处于困境<br>in time: 及时<br>in person: 亲自</p>
<p>seldom: 很少，不常，几乎不<br>hardly: 几乎不</p>
<p>be proud of: 为…感到自豪<br>take pride in: 为什么感到自豪</p>
<p>at the age of: 在…..岁时</p>
<p>came up with: 想出了…</p>
<p>trick or treat: 不给糖就捣蛋</p>
<p>promise to do sth: 承诺做某事</p>
<p>decide to do sth: 决定做某事</p>
<p>dress up as: 装扮成…</p>
<p>expect sb to do sth: 期待某人做某事</p>
<p>remind sb of sth: 使某人想起某事</p>
<p>admire sb for sth: </p>
<p>none of you business：不关你的事<br>admire sb for sth： 因某事而仰慕某人</p>
<p>suggest doing sth: 建议做某事</p>
<p>lend sb sth&#x2F; lend sth to sb<br>borrow sth&#x2F; borrow sth from sb</p>
<p>up to now: 到现在<br>up till now: 到目前为止</p>
<p>in this way: 这个方法<br>in the&#x2F;my way: 挡住我的路了<br>in a way: 在某种程度上<br>on the way: 在…的路上<br>by the way: 顺便，顺道</p>
<p>ask sb for sth: 向某人索要某物<br>in return for this: 作为报答<br>stand on one’s head: 倒立</p>
<p>knock sb out: 把某人打昏<br>konck … over: 把…撞倒<br>knock off: 下班<br>konck … off… 把… 从…碰掉<br>konck at 敲<br>knock 20% off the price 让利，优惠20%</p>
<p>a large crowd of: 一大群…</p>
<p>one good turn deserves another 礼尚往来</p>
<p>aprt from: 除了….之外<br>ask for a lift: 要求搭车<br>as i soon learnt: 我很快就知道</p>
<p>in spite of: 尽管…<br>be interested in doing sth: 对做…感兴趣</p>
<p>drive sb mad&#x2F;crazy: 把某人逼疯<br>drive into: 赶进去…<br>drive back: 赶回去..<br>drive out: 赶出去…</p>
<p>withdraw…from…: 从…提取，收回<br>comment on: 评论<br>include in: 包括<br>congratulate sb on sth: 为某事向某人祝贺<br>protect … from … :保护，使…免于<br>emerge from: 从…出现<br>dream of: 梦想，幻想<br>rely on: 依靠<br>prevent sb from doing sth : 阻止某人做某事<br>count on: 依赖<br>help sb in: 帮助某人<br>beware of: 谨慎，注意，当心<br>persisted in: 坚持<br>insist on: 坚持<br>get rid of: 摆脱<br>hear of: 获知…消息<br>separate…from:把…分开<br>cure…of: 治愈<br>operate on: 动手术，开刀<br>depend on: 依赖依靠<br>accuse … of…:控告…<br>suspect…of: 对…猜疑<br>think of： 思考<br>expect … of: 期望<br>smell of…: 闻到…<br>differ from: 与….不同<br>invest … in: 投资<br>based on: 在基础上<br>lean on: 依靠于<br>suffer from…: 受…之苦<br>embark on: 从事<br>belive in: 相信 信仰<br>be dismissed from: 被解雇<br>experiment on: 做尝试<br>concentrate on: 集中于<br>pride on: 为…感到自豪<br>fail in: 不成功<br>escape from: 从…逃出<br>economize on: 节约，节省<br>live on: 靠…为生<br>be employed in: 被雇佣<br>consist of: 由…组成<br>act on: 遵守<br>write on: 在…上写<br>boast of: 夸耀<br>encourage…in: 鼓励<br>instruct in : 指导，教导<br>be involved in: 使卷入<br>prohibit from: 不准许，禁止<br>assure … of: 让…放心<br>approve of: 赞成<br>despair of: 失望，丧失信心<br>perform on: 上演，扮演<br>warn … of: 警告…有危险<br>borrow from: 从…借<br>delight in: 喜欢</p>
<p>be tired of: 对…感到厌倦<br>be full of: 充满了…<br>turn … to … 把…变成…<br>on another occasion: 在另外一次情景中，还有一次<br>not so + 形容词 + as … 是不如…那样…</p>
<p>set out: 动身<br>call at: 拜访，也可以用call on<br>pick up: 有意外找到的意思<br><code>on + 动名词</code> 相当于一个由 as soon as 引导的时间状语从句<br>wrap it up: 收尾，打包</p>
<p>set up: 创造<br>take rest: 休息<br>look forward to do 期待…<br>any longer: 再也不…<br>tell the difference between … 辨别…之间的不同</p>
<p>take the risk: 冒…风险<br>in one’s possession: 为…所有<br>out of breath 喘不上气，上气不接下气<br>going through: 翻看<br>steal sb’s handbag &#x3D; rob sb of his handbag</p>
<p>sleep weel 睡得好</p>
<p>get…in order: 把….整理好<br>help sb to do sth<br>help sb do sth</p>
<p>forget to do sth: 忘记做某事<br>forget doing: 忘记做过什么事<br>in the front of: 在…里面的前面<br>in front of: 在外面的前面</p>
<p>avoid doing 避免做某事<br>enjoy doing 享受某事<br>prevent sb from doing sth 预防某人做某事</p>
<p>be unaware of: 没意识到…<br>caught sight of： 看到….</p>
]]></content>
      <categories>
        <category>数据库系统原理</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统原理第七节</title>
    <url>/%E8%8B%B1%E8%AF%AD%E8%BF%87%E5%8E%BB%E5%BC%8F%E9%9B%86%E5%90%88.html</url>
    <content><![CDATA[<h3 id="过去式"><a href="#过去式" class="headerlink" title="过去式"></a>过去式</h3><p>have - had - had</p>
<p>lose - lost 丢失</p>
<p>see -  saw - seen</p>
<p>speak - spoke - spoken</p>
<p>take - took - taken</p>
<p>give - gave - given</p>
<p>drink- drank</p>
<p>meet-met</p>
<p>swim - swam - swum</p>
<p>过去式<br>am - was - been<br>is - was - been<br>are - were - been</p>
<p>do - did - done</p>
<p>buy - bought</p>
<p>bring - brought - brought</p>
<p>drive - drove - driven</p>
<p>try - tried</p>
<p>get - got</p>
<p>leave - left</p>
<p>find - found</p>
<p>hear - heard</p>
<p>make - made</p>
<p>send - sent</p>
<p>sweep - swept</p>
<p>tell - told</p>
<p>come - came</p>
<p>eat - ate - eaten</p>
<p>rise - rose - risen 上升</p>
<p>fly - flew - flown</p>
<p>catch - caught - caught</p>
<p>slip - slipped - slipped 滑到</p>
<p>fall - fell - fallen</p>
<p>hurt - hurt - hurt</p>
<p>drop - dropped</p>
<p>swallow - swallowed - swllowed 吞下</p>
<p>forget - forgot - forgotten</p>
<p>grow - grew - grown</p>
<p>will - would</p>
<p>can - could</p>
<p>may - might</p>
<p>lend - lent 借给</p>
<p>teach - taught </p>
<p>think - thought</p>
<p>spend - spent</p>
<p>write - wrote - written</p>
<p>throw - threw - thrown</p>
<p>creep - crept - crept: 爬行</p>
<p>leap - leapt - leapt: 跳</p>
<p>wind - wound - wound 蜿蜒</p>
<p>strike - struck: 撞击，碰撞</p>
<p>hold - held - held: 举办</p>
<p>lie - lay - lain: 躺着，位于<br>lay - laid - laid: 摆放</p>
<p>wind - wound - wound: 缠绕</p>
<p>forbid - forbade - forbidden 禁止<br>lead - led - led: 领导，领着，引导<br>hide - hid - hidden: 隐藏</p>
<p>ring - rang - rung : 响</p>
<p>seek - sought - sought: 寻找</p>
<h3 id="过去分词"><a href="#过去分词" class="headerlink" title="过去分词"></a>过去分词</h3><p>air - aired</p>
<p>go - gone</p>
<p>sell - sold</p>
]]></content>
      <categories>
        <category>数据库系统原理</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>学堂在线C++程序设计第八章学习笔记</title>
    <url>/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%85%AB%E7%AB%A0.html</url>
    <content><![CDATA[<h1 id="学堂在线C-程序设计第八章学习笔记"><a href="#学堂在线C-程序设计第八章学习笔记" class="headerlink" title="学堂在线C++程序设计第八章学习笔记"></a>学堂在线C++程序设计第八章学习笔记</h1><h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><p>定义指向数组元素的指针<br>定义与赋值<br>例如: int a[10], *pa;<br>pa &#x3D; &amp;a[0] 或 pa &#x3D; &amp;a</p>
<p>*（pa +1）就是 a[1]</p>
<p>也可以 pa[1]</p>
<p>指针数组：数组的元素是指针类型<br>例如：Point *pa[2];<br>由pa[0],pa[1]两个指针构成</p>
<h3 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h3><p>为什么需要指针做参数</p>
<ul>
<li>需要数据双向传递时（引用传递也可以达到此效果）</li>
<li>需要传递一组数据，只传首地址运行效率比较高</li>
</ul>
<h4 id="指针类型的函数"><a href="#指针类型的函数" class="headerlink" title="指针类型的函数"></a>指针类型的函数</h4><p>若函数的返回类型是指针类型，该函数就是指针类型的函数</p>
<p>指针函数的定义形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">存储类型 数据类型 *函数名() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不要将非静态局部地址用作函数的返回值<ul>
<li>因为非静态局部地址<code>作用域</code>仅限于函数内部，离开函数就被<code>销毁</code>了</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> *<span class="title">function</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="type">int</span> *ptr = <span class="built_in">function</span>();</span><br><span class="line">    *ptr = <span class="number">5</span>; <span class="comment">//危险！！！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> local = <span class="number">0</span>; <span class="comment">//作用域只在函数内部有效</span></span><br><span class="line">    <span class="keyword">return</span> &amp;local; </span><br><span class="line">&#125; <span class="comment">//函数结束，变量local被释放</span></span><br></pre></td></tr></table></figure>


<ul>
<li>返回的指针要确保在主调函数中是<code>有效</code>，<code>合法</code>的地址</li>
</ul>
<p>在子函数中通过动态内存分配<code>new</code>操作取得的内存地址返回给主函数是合法有效的，但是<code>内存分配</code>和<code>释放</code>不在同一级别，要注意不能忘记<code>释放</code>，避免<code>内存泄露</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> *<span class="title">function</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="type">int</span> *ptr = <span class="built_in">function</span>();</span><br><span class="line">    *ptr = <span class="number">5</span>; <span class="comment">//如果返回的是 new 分配的，就可以了</span></span><br><span class="line">    <span class="keyword">delete</span> ptr; <span class="comment">//但是这里需要释放，避免内存泄露</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *local = <span class="keyword">new</span> <span class="built_in">int</span>(); <span class="comment">//new 分配的不会离开函数就释放</span></span><br><span class="line">    <span class="keyword">return</span> local; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h4><p>函数指针的定义</p>
<ul>
<li>定义形式<br>存储类型 数据类型 (*函数指针名)()</li>
<li>含义<br>函数指针指向的是程序代码存储区</li>
</ul>
<p>用途：函数回调</p>
<ul>
<li>通过函数指针调用的函数<ul>
<li>例如将函数的指针作为参赛传递给一个函数，使得在处理相似事件的时候可以灵活的使用不同方法</li>
</ul>
</li>
<li>调用者不关心谁是被调用者<ul>
<li>需要知道存在一个具有特定原型和限制条件的被调用函数。</li>
</ul>
</li>
</ul>
<h4 id="对象指针"><a href="#对象指针" class="headerlink" title="对象指针"></a>对象指针</h4><p>定义：<br>类名 *对象指针名;<br>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Point <span class="title">a</span><span class="params">(<span class="number">5</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">Point *ptr;</span><br><span class="line">ptr = &amp;a;</span><br></pre></td></tr></table></figure>

<p>通过指针访问对象成员<br>对象指针名-&gt;成员名<br>例如：<br>ptr-&gt;getX() 相当于 (*ptr).getX()</p>
<p>this 指针</p>
<ul>
<li>隐含于类的每一个非静态成员函数中</li>
<li>指出成员函数所操作的对象<ul>
<li>当通过一个对象调用成员函数时，系统先将该对象的地址赋给this指针，然后调用成员函数，成员函数对对象的数据成员进行操作时，就隐含的使用了this指针。</li>
</ul>
</li>
</ul>
<h4 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h4><p>动态申请内存<br>new 类型名T (初始化参数列表)</p>
<ul>
<li>功能：<br>在程序执行期间，申请用于存放T类型对象的内存空间，并依初值列表赋值</li>
<li>结果值：<br>成功：T类型的指针，指向新分配的内存，失败：抛出异常</li>
</ul>
<p>释放内存<br>delete 指针P</p>
<ul>
<li>功能：<br>释放指针P所指向的内存，p必须是new操作符的返回值</li>
</ul>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>C++11提供的</p>
<ul>
<li>unique_ptr<ul>
<li>不允许多个指针共享资源，可以用标准库中的move函数转移指针</li>
</ul>
</li>
<li>shared_ptr<ul>
<li>多个指针共享资源</li>
</ul>
</li>
<li>weak_ptr<ul>
<li>可复制 shared_ptr ，但其构造或者释放对资源不产生影响</li>
</ul>
</li>
</ul>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>为什么需要Vector</p>
<ul>
<li>封装任何类型的动态数组，自动创建和删除</li>
<li>数组下标越界检查</li>
</ul>
<p>定义</p>
<ul>
<li>vector&lt;元素类型&gt; 数组对象名(数组长度);</li>
<li>例子：<br>  vector<int> arr(5)  建立大小为5的int数组</li>
</ul>
<p>vector对象的使用</p>
<ul>
<li>对数组元素的引用<br>  与普通数组具有相同形式：<br>  vector对象名[下标表达式]<br>  vector数组对象名不表示数组首地址</li>
<li>获得数组长度<br>  用<code>size</code>函数<br>  vector对象名.size()</li>
</ul>
<h3 id="对象复制和移动"><a href="#对象复制和移动" class="headerlink" title="对象复制和移动"></a>对象复制和移动</h3><p>浅层复制</p>
<ul>
<li>实现对象间数据元素的一一对应复制</li>
</ul>
<p>深层复制</p>
<ul>
<li>当被复制的对象数据成员是指针类型时，不是复制该指针成员本身，而是将指针所指对象进行复制</li>
</ul>
<h4 id="申请和释放动态数组"><a href="#申请和释放动态数组" class="headerlink" title="申请和释放动态数组"></a>申请和释放动态数组</h4><p>分配和释放动态数组</p>
<ul>
<li>分配：new 类型名T [数组长度]<ul>
<li>数组长度可以是任何整数类型表达式，在运行时计算</li>
</ul>
</li>
<li>释放：delete[] 数组名p<ul>
<li>释放指针p所指向的数组</li>
<li>p必须是用new分配得到的数组首地址</li>
</ul>
</li>
</ul>
<p>动态创建多维数组<br>new 类型名T[第1维长度][第2维长度]</p>
<ul>
<li>如果内存申请成功，new 运算返回一个指向新分配内存首地址的指针</li>
<li>例如<br>  char (*fp)[3];<br>  fp &#x3D; new char[2][3]</li>
</ul>
<p>将动态数组封装成类</p>
<ul>
<li>更加简洁，便于管理</li>
<li>可以在访问数组元素前检查下标是否越界</li>
</ul>
<h4 id="移动构造"><a href="#移动构造" class="headerlink" title="移动构造"></a>移动构造</h4><p>C++11中提供了新的构造方法</p>
<p>C++11之前，如果要将源对象的状态转移到目标对象只能通过复制。在某些情况下，我们没有必要复制对象 – 只需要移动它们</p>
<p>移动构造</p>
<ul>
<li>C++11引入移动语义：<ul>
<li>源 对象资源的控制权全部交给目标对象</li>
</ul>
</li>
<li>移动构造函数</li>
</ul>
<p>移动构造函数<br>class_name(class_name &amp;&amp;)</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h4><p>字符串常量</p>
<ul>
<li>例如：”program”</li>
<li>各字符连续，顺序存放，每个字符占一个字节，以’\0’结尾，相当于一个隐含创建的字符常量数组</li>
<li>“program” 出现在表达式中，表示这个char数组的首地址</li>
<li>首地址可以赋给char常量指针</li>
<li>const char *STRING1 &#x3D; “program”</li>
</ul>
<p>用字符数组存储字符串</p>
<ul>
<li>例如<br>char str[8] &#x3D; {‘p’,’r’,’o’,’g’,’r’,’a’,’m’,’\0’}<br>char str[8] &#x3D; “program”</li>
<li>缺点<ul>
<li>执行连接，拷贝，比较等操作，都需要显式调用库函数，很麻烦</li>
<li>当字符串长度不确定时，需要用new 动态创建字符数组，最后要用delete释放，很繁琐</li>
<li>字符串实际长度大于为他分配的空间时，会产生数组下标越界的错误</li>
</ul>
</li>
</ul>
<h4 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h4><p>构造函数</p>
<ul>
<li>string() 默认的，建立长度为0的字符串<br>  例如 string s1;</li>
<li>string(const char *s); &#x2F;&#x2F;用指针s所指向的字符串常量初始化string对象<br>  例如 string s2 &#x3D; “abc”;</li>
<li>string(const string&amp; rhs); &#x2F;&#x2F;复制构造函数<br>  例如 string s3 &#x3D; s2;</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>学堂在线C++程序设计第七章学习笔记</title>
    <url>/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%83%E7%AB%A0.html</url>
    <content><![CDATA[<h1 id="学堂在线C-程序设计第七章学习笔记"><a href="#学堂在线C-程序设计第七章学习笔记" class="headerlink" title="学堂在线C++程序设计第七章学习笔记"></a>学堂在线C++程序设计第七章学习笔记</h1><h2 id="数组的定义与初始化"><a href="#数组的定义与初始化" class="headerlink" title="数组的定义与初始化"></a>数组的定义与初始化</h2><p>数组是具有一定顺序关系的若干相同类型变量的集合体，组成数组的变量称为该数组的元素</p>
<p>数组的定义</p>
<p>类型说明符 数组名[常量表达式] [常量表达式]…<br>数组名的构成方法与一般变量名相同</p>
<p>例如：</p>
<ul>
<li>int a[10]</li>
<li>int a[5][3]</li>
</ul>
<p>数组的使用</p>
<ul>
<li>数组必须先定义，后使用</li>
<li>可以逐个引用数组元素</li>
<li>例如：<br>a[0] &#x3D; a[5] + a[7]</li>
</ul>
<h3 id="数组的存储和初始化"><a href="#数组的存储和初始化" class="headerlink" title="数组的存储和初始化"></a>数组的存储和初始化</h3><p>一位数组的存储</p>
<p><code>数组元素</code>在内存中顺次存放，它们的<code>地址是连续</code>的。元素间物理地址上的相邻，对应着逻辑次序上的相邻</p>
<p><code>数组名字</code>是数组<code>首元素</code>的内存地址</p>
<p><code>数组名字</code>是一个常量，不能被赋值</p>
<p>一维数组初始化</p>
<ul>
<li>列出全部值<ul>
<li>static int a[5] &#x3D; {0,1,2,3,4}</li>
</ul>
</li>
<li>可以只给一部分元素初始化<ul>
<li>static int a[5] &#x3D; {0,1,2}</li>
</ul>
</li>
<li>列出全部值时，可以不指定长度<ul>
<li>static int a[] &#x3D; {0,1,2,3,4}</li>
</ul>
</li>
</ul>
<p>二维数组的存储</p>
<ul>
<li>按行存放</li>
</ul>
<p>二维数组的初始化</p>
<ul>
<li>列出全部值，按照顺序初始化<ul>
<li>static int a[3][2] &#x3D; {0,1,2,3,4,5}</li>
</ul>
</li>
<li>分行列出二维数组元素的初值<ul>
<li>static int a[3][2] &#x3D; { {0,1},{2,3},{4,5} }</li>
</ul>
</li>
<li>可以只对部分元素初始化<ul>
<li>static int a[3][2] &#x3D; { {0},{1,2},{3} }</li>
</ul>
</li>
<li>列出全部初始值，第一维下标可以省略<ul>
<li>static int a[][2] &#x3D; {0,1,2,3,4,5}</li>
<li>static int a[][2] &#x3D; { {0,1},{2,3},{4,5} }</li>
</ul>
</li>
<li>如果不做任何初始化，局部作用域非静态数组中会存在垃圾数据，static 数组中的数据默认初始化为0</li>
<li>如果只对部分元素初始化，剩下的将自动被初始化为0</li>
</ul>
<h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h3><p>对象数组的定义和访问</p>
<ul>
<li>定义对象数组<ul>
<li>类名 数组名[元素个数]</li>
</ul>
</li>
<li>访问对象数组<ul>
<li>通过下标访问 数组名[下标].成员名</li>
</ul>
</li>
</ul>
<p>对象数组初始化</p>
<ul>
<li>数组中每一个元素对象被创建时，系统都会调用类构造函数初始化该对象</li>
<li>通过初始化列表赋值<ul>
<li>例如：Point a[2] &#x3D; {Point{1,2}, Point{3,4}}</li>
</ul>
</li>
<li>如果没有为数组元素指定显式初始值，数组元素便使用默认值初始化（调用默认构造函数）</li>
</ul>
<p>数组元素的构造和析构</p>
<ul>
<li>构造数组时，元素所属的类未声明构造函数，则采用默认构造函数</li>
<li>各元素对象的初值要求为相同的值时，可以声明具有默认形参值得构造函数</li>
<li>各元素对象的初值要求为不同的值时，需要声明带形参的构造函数</li>
<li>当数组中每一个对象被删除时，系统需要调用一次析构函数</li>
</ul>
<h3 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h3><p>C++11 提供的</p>
<p>自动遍历整个容器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> array[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="keyword">for</span> (p = array;p &lt; array + <span class="built_in">sizeof</span>(array) / <span class="built_in">sizeof</span>(<span class="type">int</span>); ++p) &#123;</span><br><span class="line">        *p += <span class="number">2</span>;</span><br><span class="line">        std::cout &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用基于范围的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> array[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> &amp; e : array) &#123;</span><br><span class="line">        e+=<span class="number">2</span>;</span><br><span class="line">        std::cout &lt;&lt;e &lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针的定义和运算"><a href="#指针的定义和运算" class="headerlink" title="指针的定义和运算"></a>指针的定义和运算</h3><p>内存空间的访问形式：</p>
<ul>
<li>通过变量名访问</li>
<li>通过地址访问</li>
</ul>
<p>指针的概念：</p>
<ul>
<li>指针：内存地址，用于间接访问内存单元</li>
<li>指针变量：用于存放地址的变量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> i;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span>* ptr = &amp;i; <span class="comment">//指向int变量的指针</span></span><br></pre></td></tr></table></figure>

<p>指针运算符 *：表示该变量内存里存储的是地址，并操作存储地址对应的内存空间</p>
<p>地址运算符 &amp;: 表示该变量的地址</p>
<h3 id="指针的初始化和赋值"><a href="#指针的初始化和赋值" class="headerlink" title="指针的初始化和赋值"></a>指针的初始化和赋值</h3><p>指针变量的初始化</p>
<ul>
<li>语法形式<ul>
<li>存储类型 数据类型 *指针名 &#x3D; 初始地址</li>
<li>例如：int *pa &#x3D; &amp;a</li>
</ul>
</li>
<li>注意事项<ul>
<li>用变量地址作为初始值时，该变量必须在指针初始化之前已声明过，且变量类型应与指针类型一致</li>
<li>可以用一个已有合法值的指针去初始化另一个指针变量</li>
<li>不要用一个内部非静态变量去初始化 static 指针</li>
</ul>
</li>
</ul>
<p>指针变量的赋值运算</p>
<ul>
<li>语法形式 指针名 &#x3D; 地址</li>
<li>注意：<ul>
<li><code>地址</code> 中存放的数据类型与指针类型必须相符</li>
<li>向指针变量赋值必须是地址常量或变量，不能是普通整数</li>
</ul>
</li>
<li>例如：<ul>
<li>通过地址运算 <code>&amp;</code> 求得已定义的变量和对象的起始地址</li>
<li>动态内存分配成功时返回的地址</li>
</ul>
</li>
<li>例外：整数0可以赋值给指针，表示空指针</li>
<li>允许定义或声明指向 void 类型的指针。该指针可以被赋予任何类型对象的地址<ul>
<li>void *general;</li>
</ul>
</li>
</ul>
<p>指向常量的指针</p>
<ul>
<li>const 指针</li>
<li>不能通过指向常量的指针改变所指对象的值，但指针本身可以改变，可以指向另外的对象</li>
<li>例如：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">p = &amp;b</span><br><span class="line">*p = <span class="number">2</span>; <span class="comment">//编译出错</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>指针类型的常量</p>
<ul>
<li>声明指针常量，则指针本身的值不能被改变</li>
<li>例如：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p2 = *a;</span><br><span class="line">p2 = &amp;b; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="指针的运算"><a href="#指针的运算" class="headerlink" title="指针的运算"></a>指针的运算</h3><p>指针的算术运算</p>
<ul>
<li>指针与整数的加减运算<ul>
<li>指针p 加上或减去 n：指针当前指向位置的前方或后方第n个数据的起始位置</li>
</ul>
</li>
<li>指针++，–运算<ul>
<li>指向下一个或前一个完整数据的起始位置</li>
</ul>
</li>
<li>运算的结果值取决于指针指向的数据类型，总是指向一个完整数据的起始位置</li>
<li>当指针指向连续存储的同类型数据时，指针与整数的加减运算和自增自减才有意义</li>
</ul>
<p>指针的关系运算</p>
<ul>
<li>指向相同类型数据的指针之间可以进行各种关系运算</li>
<li>指向不同数据类型的指针，以及指针与一般整形变量之间的关系运算是无意义的</li>
<li>指针可以和零之间进行等于或不等于的关系运算，判断空指针</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统原理第五节</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E8%8A%82.html</url>
    <content><![CDATA[<h1 id="数据库系统原理第五节"><a href="#数据库系统原理第五节" class="headerlink" title="数据库系统原理第五节"></a>数据库系统原理第五节</h1><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="数据库设计概述"><a href="#数据库设计概述" class="headerlink" title="数据库设计概述"></a>数据库设计概述</h3><h4 id="数据库的生命周期"><a href="#数据库的生命周期" class="headerlink" title="数据库的生命周期"></a>数据库的生命周期</h4><ul>
<li>数据库分析与设计阶段<ul>
<li>需求分析</li>
<li>概念设计</li>
<li>逻辑设计</li>
<li>物理设计</li>
</ul>
</li>
<li>数据库实现与操作阶段<ul>
<li>实现</li>
<li>操作与监督</li>
<li>修改与调整</li>
</ul>
</li>
</ul>
<h4 id="数据库设计的目标"><a href="#数据库设计的目标" class="headerlink" title="数据库设计的目标"></a>数据库设计的目标</h4><ul>
<li>满足应用功能需求<ul>
<li>存，取，删，改</li>
</ul>
</li>
<li>良好的数据库性能<ul>
<li>高效率存取和空间的节省</li>
<li>共享性，完整性，一致性，安全保密性</li>
</ul>
</li>
</ul>
<h4 id="数据库设计的内容"><a href="#数据库设计的内容" class="headerlink" title="数据库设计的内容"></a>数据库设计的内容</h4><ul>
<li>静态的 数据库结构设计<ul>
<li>数据库概念结构设计</li>
<li>逻辑结构设计</li>
<li>物理结构设计</li>
</ul>
</li>
<li>动态的 数据库行为设计<ul>
<li>功能设计</li>
<li>事务设计</li>
<li>程序设计</li>
</ul>
</li>
</ul>
<h4 id="数据库设计的方法"><a href="#数据库设计的方法" class="headerlink" title="数据库设计的方法"></a>数据库设计的方法</h4><ul>
<li>直观设计法<ul>
<li>最原始的数据库设计方法</li>
</ul>
</li>
<li>规范设计法<ul>
<li>新奥尔良设计法：需求分析，概念结构设计，逻辑结构设计，物理结构设计</li>
<li>基于E-R模型</li>
<li>基于第三范式</li>
</ul>
</li>
<li>计算机辅助设计法<ul>
<li>辅助软件工程工具</li>
</ul>
</li>
</ul>
<h4 id="数据库设计的过程"><a href="#数据库设计的过程" class="headerlink" title="数据库设计的过程"></a>数据库设计的过程</h4><ul>
<li>需求分析</li>
<li>结构设计，行为设计</li>
<li>数据库实施<ul>
<li>加载数据库数据</li>
<li>调试运行应用程序</li>
</ul>
</li>
<li>数据库运行与维护</li>
</ul>
<h3 id="数据库设计的基本步骤"><a href="#数据库设计的基本步骤" class="headerlink" title="数据库设计的基本步骤"></a>数据库设计的基本步骤</h3><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>数据库设计的起点<br>目标：是了解与分析用户的信息及应用处理的要求，并将结果按一定格式整理而形成需求分析报告</p>
<p>该分析报告是后续概念设计，逻辑设计，物理设计，数据库建立与维护的依据</p>
<ul>
<li>确定数据范围<ul>
<li>有效的利用计算机设备及数据库系统的潜在能力</li>
<li>提高数据库的应变能力</li>
<li>避免应用过程中对数据库做太多或太大的修改</li>
<li>延长数据库的生命周期</li>
</ul>
</li>
<li>分析数据应用过程<ul>
<li>用到那些数据</li>
<li>数据使用的顺序</li>
<li>对数据作何处理和处理的策略以及结果</li>
<li><code>应用过程分析的结果是数据库结构设计的重要依据</code></li>
</ul>
</li>
<li>收集与分析数据<ul>
<li>数据收集与分析的<code>任务</code>是了解并分析数据的组成各式及操作特征，每个数据元素的语义及关系等，并将它们收集起来整理归档</li>
<li>静态结构 —不施加应用操作于其上时数据的原数始状况</li>
<li>动态结构 —将应用操作施加于数据之上后数据的状况</li>
<li>数据约束 —使用数据时的特殊要求<ul>
<li>数据的安全保密性</li>
<li>数据的完整性</li>
<li>响应时间</li>
<li>数据恢复</li>
</ul>
</li>
</ul>
</li>
<li>编写需求分析报告<ul>
<li>数据库的应用功能目标</li>
<li>标明不同用户视图范围</li>
<li>应用处理过程需求说明，包括：数据流程图；任务分类表；数据操作特征表；操作过程说明书。</li>
<li>数据字典，是数据库系统中存储三级结构定义的数据库，通常指的是数据库系统中各类数据详细描述的集合。功能是存储和检索各种数据描述，即元数据。包括数据分类表，数据元素表和各类原始资料</li>
<li>数据量</li>
<li>数据约束</li>
</ul>
</li>
</ul>
<h4 id="概念结构设计-重点"><a href="#概念结构设计-重点" class="headerlink" title="概念结构设计 重点"></a>概念结构设计 重点</h4><p>概念模型 – E-R图</p>
<ul>
<li>实体分析法 （自顶向下）</li>
<li>属性综合法 （自底向上）</li>
</ul>
<p>概念模型</p>
<ul>
<li>独立于任何软件与硬件</li>
<li>主要目标：最大限度的满足应用需求</li>
</ul>
<h4 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h4><p>目标：<br>将概念模型转换为等价的，并为特定DBMS所支持数据模型的结构</p>
<p>步骤：</p>
<ol>
<li>模型转换 是将概念模型等价的转换为特定DBMS支持的关系模型，网状模型或层次模型表示</li>
<li>子模式设计的目标是抽取或导出模式的子集，以构造不同用户使用的局部数据逻辑结构</li>
<li>编制应用程序设计说明的目的是为可实际运行的应用程序设计提供依据与指导，并作为设计评价的基础</li>
<li>设计评价的任务是分析并检验模式及子模式的正确性与合理性</li>
</ol>
<h4 id="物理设计"><a href="#物理设计" class="headerlink" title="物理设计"></a>物理设计</h4><p>具体任务主要是确定数据库在存储设备上的<code>存储结构</code>和<code>存取方法</code><br>因DBMS的不同还可能包括<code>建立索引</code>和<code>聚集</code>，以及<code>物理块大小</code>，<code>缓冲区个数和大小</code>，<code>数据压缩的选择</code>等</p>
<h4 id="数据库实施"><a href="#数据库实施" class="headerlink" title="数据库实施"></a>数据库实施</h4><ul>
<li>加载数据</li>
<li>应用程序设计</li>
<li>数据库试运行</li>
</ul>
<h4 id="数据库运行与维护"><a href="#数据库运行与维护" class="headerlink" title="数据库运行与维护"></a>数据库运行与维护</h4><p>保证数据库的正常运行</p>
<p>最困难：<code>数据库重组与重构</code></p>
<h3 id="关系数据库设计方法"><a href="#关系数据库设计方法" class="headerlink" title="关系数据库设计方法"></a>关系数据库设计方法</h3><h4 id="概念模型的表示方法"><a href="#概念模型的表示方法" class="headerlink" title="概念模型的表示方法"></a>概念模型的表示方法</h4><ul>
<li>矩形：实体</li>
<li>椭圆：属性</li>
<li>菱形：联系</li>
</ul>
]]></content>
      <categories>
        <category>数据库系统原理</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统原理第六节</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E5%85%AD%E8%8A%82.html</url>
    <content><![CDATA[<h1 id="数据库系统原理第六节"><a href="#数据库系统原理第六节" class="headerlink" title="数据库系统原理第六节"></a>数据库系统原理第六节</h1><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="关系数据库设计方法"><a href="#关系数据库设计方法" class="headerlink" title="关系数据库设计方法"></a>关系数据库设计方法</h3><h4 id="逻辑结构设计方法"><a href="#逻辑结构设计方法" class="headerlink" title="逻辑结构设计方法"></a>逻辑结构设计方法</h4><ul>
<li>将E-R图转换为关系模型<ul>
<li>一个实体转换为一个关系模式，实体的属性作为关系的属性，实体的码作为关系的码</li>
<li>一个一对一联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并</li>
<li>一个一对多联系可以转换为一个独立的关系模式，也可以与N端对应的关系模式合并</li>
<li>一个多对多联系可以转换为一个独立的关系模式，与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性</li>
<li>三个或以上实体间的一个多元联系可以转换为一个关系模式</li>
<li>具有相同码的关系模式可合并</li>
</ul>
</li>
<li>对关系数据模型进行优化<ul>
<li>数据库逻辑设计的结果，<code>不是唯一</code>的</li>
<li>确定各<code>属性</code>间的函数依赖关系</li>
<li>对于各个关系模式之间的数据依赖进行极小化处理，消除<code>冗余</code>的联系</li>
<li>判断每个关系模式的范式，根据实际需要确定最合适的范式</li>
<li>按照<code>需求分析</code>得到的处理要求，分析浙西模式对于这样的应用环境是否合适，确定是否要对某些模式进行合并或分解</li>
<li>对关系模式进行必要的分解，提高<code>数据操作</code>的效率和<code>存储空间</code>的利用率</li>
</ul>
</li>
<li>设计面向用户的外模式</li>
</ul>
<p>设计用户子模式</p>
<ul>
<li>可以通过视图机制在设计用户视图时，重新定义某些属性的别名，使其更符合用户的习惯，以方便使用</li>
<li>可以对不同级别的用户定义不同的视图，以保证系统的安全性。</li>
<li>简化用户对系统的使用</li>
</ul>
<h4 id="物理设计方法"><a href="#物理设计方法" class="headerlink" title="物理设计方法"></a>物理设计方法</h4><p>建立索引</p>
<ul>
<li>逻辑连接</li>
<li>静态建立索引</li>
<li>动态建立索引<br>建立聚集</li>
<li>聚集是将相关数据集中存放的<code>物理存储技术</code></li>
<li>数据聚集结构的一种有效方式是<code>块结构方式</code></li>
<li>数据聚集可在<code>一个或多个</code>关系上建立</li>
</ul>
<h2 id="SQL与关系数据库基本操作"><a href="#SQL与关系数据库基本操作" class="headerlink" title="SQL与关系数据库基本操作"></a>SQL与关系数据库基本操作</h2><h3 id="SQL概述"><a href="#SQL概述" class="headerlink" title="SQL概述"></a>SQL概述</h3><h4 id="什么是SQL"><a href="#什么是SQL" class="headerlink" title="什么是SQL"></a>什么是SQL</h4><p><code>结构化查询语言</code>是专门用来与数据库通信的语言，它可以帮助用户操作关系数据库</p>
<h4 id="SQL的特点"><a href="#SQL的特点" class="headerlink" title="SQL的特点"></a>SQL的特点</h4><p>SQL不是某个特定数据库供应商专有的语言<br>SQL简单易学<br>SQL强大，灵活，可以进行非常复杂和高级的数据库操作</p>
<h4 id="SQL的组成"><a href="#SQL的组成" class="headerlink" title="SQL的组成"></a>SQL的组成</h4><p>数据查询<br>数据定义 DDL</p>
<ul>
<li>CREATE 创建数据库或数据库对象</li>
<li>ALTER 对数据库或数据库对象进行修改</li>
<li>DROP 删除数据库或数据库对象<br>数据操纵 DML</li>
<li>SELECT 从表或视图中检索数据</li>
<li>INSERT 将数据插入到表或视图中</li>
<li>UPDATE 修改表或视图中的数据</li>
<li>DELETE 从表或视图中删除数据<br>数据控制 DCL</li>
<li>GRANT 用于授予权限</li>
<li>REVOKE 用于收回权限</li>
</ul>
<h3 id="MySql预备知识"><a href="#MySql预备知识" class="headerlink" title="MySql预备知识"></a>MySql预备知识</h3><h4 id="MySQL使用基础"><a href="#MySQL使用基础" class="headerlink" title="MySQL使用基础"></a>MySQL使用基础</h4><p>关系数据库管理系统 RDBMS</p>
<p>优点：体积小，速度快，开放源代码，遵循GPL</p>
<h4 id="MySQL扩展语言要素"><a href="#MySQL扩展语言要素" class="headerlink" title="MySQL扩展语言要素"></a>MySQL扩展语言要素</h4><p>常量：也称字面值或标量值</p>
<ul>
<li>字符串常量</li>
<li>数值常量</li>
<li>十六进制常量</li>
<li>时间日期常量</li>
<li>位字段值</li>
<li>布尔值</li>
<li>NULL值</li>
</ul>
<p>变量</p>
<ul>
<li>用户变量<br>用户变量前常添加@</li>
<li>系统变量<br>大多数系统变量前添加两个@@</li>
</ul>
<p>运算符</p>
<ul>
<li>算术运算符</li>
<li>位运算符</li>
<li>比较运算符</li>
<li>逻辑运算符<ul>
<li>NOT</li>
<li>AND</li>
<li>OR</li>
<li>XOR</li>
</ul>
</li>
</ul>
<p>表达式：是常量，变量，列名，复杂计算，运算符合函数的组合</p>
<ul>
<li>字符型表达式</li>
<li>数值型表达式</li>
<li>日期型表达式</li>
</ul>
<p>内置函数</p>
<ul>
<li>数学函数<ul>
<li>ABS</li>
</ul>
</li>
<li>聚合函数<ul>
<li>COUNT</li>
</ul>
</li>
<li>字符串函数</li>
<li>日期和时间函数</li>
<li>加密函数</li>
</ul>
<h3 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h3><h4 id="数据库模式定义"><a href="#数据库模式定义" class="headerlink" title="数据库模式定义"></a>数据库模式定义</h4><p>创建数据库<br>使用 <code>CREATE DATABASE</code> 或 <code>CREATE SCHEMA</code>语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> &#123;DATABASE <span class="operator">|</span> SCHEMA&#125; [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] db_name</span><br><span class="line">[<span class="keyword">DEFAULT</span>] <span class="type">CHARACTER</span> <span class="keyword">SET</span>[<span class="operator">=</span>]charset_name</span><br><span class="line"><span class="operator">|</span> [<span class="keyword">DEFAULT</span>] <span class="keyword">COLLATE</span>[<span class="operator">=</span>]collation_name</span><br></pre></td></tr></table></figure>

<p>查看数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> &#123;DATABASES <span class="operator">|</span> SCHEMAS&#125;</span><br><span class="line">[<span class="keyword">LIKE</span> <span class="keyword">pattern</span> <span class="operator">|</span> <span class="keyword">WHERE</span> expr] </span><br></pre></td></tr></table></figure>

<p>选择数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use db_name</span><br></pre></td></tr></table></figure>

<p>修改数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE db_name</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> gb2312</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> gb2312_chinese_ci;</span><br></pre></td></tr></table></figure>

<p>删除数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> &#123;DATABASE<span class="operator">|</span>SCHEMA&#125; [IF <span class="keyword">EXISTS</span>] db_name;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据库系统原理</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>学堂在线C++程序设计第六章学习笔记</title>
    <url>/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%85%AD%E7%AB%A0.html</url>
    <content><![CDATA[<h1 id="学堂在线C-程序设计第六章学习笔记"><a href="#学堂在线C-程序设计第六章学习笔记" class="headerlink" title="学堂在线C++程序设计第六章学习笔记"></a>学堂在线C++程序设计第六章学习笔记</h1><p>变量和对象定义在不同的位置</p>
<ul>
<li>其作用域，可见性，生存期都不同</li>
</ul>
<p>友元：</p>
<ul>
<li>对一些类外的函数，其他的类，给预授权，使之可以访问类的私有成员</li>
</ul>
<h2 id="标识符的作用域与可见性"><a href="#标识符的作用域与可见性" class="headerlink" title="标识符的作用域与可见性"></a>标识符的作用域与可见性</h2><p>作用域分类：</p>
<ul>
<li>函数原型作用域</li>
<li>局部作用域</li>
<li>类作用域</li>
<li>文件作用域</li>
<li>命名空间作用域</li>
</ul>
<p>函数原型作用域</p>
<ul>
<li>函数原型中的参数</li>
</ul>
<p>类的作用域</p>
<ul>
<li>类的成员具有类作用域，其范围包括类体和成员函数体</li>
<li>在类作用域以外访问类的成员<ul>
<li>静态成员：通过类名，或者该类的对象名，对象引用访问</li>
<li>非静态成员：通过类名，或该类的对象名，对象引用，对象指针访问</li>
</ul>
</li>
</ul>
<p>文件作用域</p>
<ul>
<li>不在前述各个作用域中出现的声明，就具有文件作用域</li>
<li>其作用域开始于声明点，结束于文件尾</li>
</ul>
<p>可见性</p>
<ul>
<li>可见性是从对标识符的引用角度来谈论的</li>
<li>可见性表示从内层作用域向外层作用域“看”时能看见什么</li>
<li>如果标识在某处可见，就可以在该处引用此标识符</li>
<li>如果某个标识符在外层中声明，且在内层中没有同一标识符的声明，则该标识符在内层可见</li>
<li>对于两个嵌套的作用域，如果在内层作用域内声明了与外层作用域中同名的标识符，则外层标识符在内层不可见</li>
</ul>
<h2 id="对象的生存期"><a href="#对象的生存期" class="headerlink" title="对象的生存期"></a>对象的生存期</h2><p>静态生存期</p>
<ul>
<li>这种生存期与程序的运行期相同</li>
<li>在文件作用域中声明的对象具有这种生存期</li>
<li>在函数内部声明静态生存期对象，要冠以关键字static</li>
</ul>
<p>动态生存期</p>
<ul>
<li>开始于程序执行到声明点时，结束于命名该标识符的作用域结束处</li>
<li>块作用域中声明的，没有用static修饰的对象是动态生存期的对象（也称局部生存期对象）</li>
</ul>
<h2 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h2><ul>
<li>用关键词static修饰</li>
<li>为该类的所有对象共享，静态数据成员具有静态生存期</li>
<li>必须在类外定义和初始化，用（::）来指明所属的类</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> count;  <span class="comment">//声明</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Point::count = <span class="number">0</span>; <span class="comment">//初始化</span></span><br></pre></td></tr></table></figure>

<h3 id="静态函数成员"><a href="#静态函数成员" class="headerlink" title="静态函数成员"></a>静态函数成员</h3><p>静态函数成员主要用来处理静态数据成员</p>
<p>静态函数成员要处理非静态数据成员，需要用对象调用</p>
<h2 id="类的友元"><a href="#类的友元" class="headerlink" title="类的友元"></a>类的友元</h2><ul>
<li>友元是C++提供的一种破坏数据封装和数据隐藏的机制</li>
<li>通过将一个模块声明为另一个模块的友元，一个模块能够引用到另一个模块中本是被隐藏的信息</li>
<li>可以声明友元函数和友元类</li>
<li>为了确保数据的完整性，及数据封装与隐藏的原则，建议慎用友元</li>
</ul>
<p>友元函数</p>
<ul>
<li>友元函数是在类声明中由关键字friend修饰说明的非成员函数，在它的函数体中能够通过对象名访问private和protected成员</li>
<li>作用：增加灵活性，使程序员可以在封装和快速性方面做合理选择</li>
<li>访问对象中的成员必须通过对象名</li>
</ul>
<p>友元类</p>
<ul>
<li>若一个类为另一个类的友元，则此类的所有成员都能访问对方类的私有成员</li>
<li>声明语法：将友元类名在另一个类中使用friend修饰说明</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; X &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        A a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::set</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    a.X = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>类的友元关系是单向的：</p>
<ul>
<li>声明B类是A类的友元 不等于 A类是B类的友元</li>
</ul>
<h2 id="共享数据的保护"><a href="#共享数据的保护" class="headerlink" title="共享数据的保护"></a>共享数据的保护</h2><p>常类型</p>
<ul>
<li>常对象：必须进行初始化，不能被更新。<br>  const 类名 对象名</li>
<li>常成员：<br>  用 const 进行修饰的类成员：常数据成员和常函数成员</li>
<li>常引用：被引用的对象不能被更新<br>  const 类型说明符 &amp;引用名；</li>
<li>常数组：数组元素不能被更新<br>  类型说明符 const 数组名[大小]</li>
<li>常指针：指向常量的指针</li>
</ul>
<p>常成员：用const修饰的对象成员</p>
<ul>
<li>常成员函数<ul>
<li>使用const 关键字说明的函数</li>
<li>常成员函数不更新对象的数据成员</li>
<li>常成员函数说明格式：<br>  类型说明符 函数名（参数表）const;<br>  这里，const是函数类型的一个组成部分，因此在实现部分也要带const关键字</li>
<li>const 关键字可以被用于参与对重载函数的区分</li>
<li>通过常对象只能调用它的常成员函数</li>
</ul>
</li>
<li>常数据成员<ul>
<li>使用 const 说明的数据成员</li>
</ul>
</li>
</ul>
<p>常引用</p>
<ul>
<li>在友元函数中用常引用做参数，既能获得较高的执行效率，又能保证实参的安全性</li>
</ul>
<h2 id="多文件结构和预编译处理命令"><a href="#多文件结构和预编译处理命令" class="headerlink" title="多文件结构和预编译处理命令"></a>多文件结构和预编译处理命令</h2><p>C++程序的一般组织结构</p>
<ul>
<li>一个工程可以划分为多个源文件<ul>
<li>类声明文件（.h文件）</li>
<li>类实现文件（.cpp文件）</li>
<li>类的使用文件（main()所在的.cpp文件）</li>
</ul>
</li>
<li>利用工程来组合各个文件</li>
</ul>
<p>文件1 Point.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="comment">//类的定义</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Point</span>(<span class="type">int</span> x =<span class="number">0</span>,<span class="type">int</span> y = <span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">        <span class="built_in">Point</span>(<span class="type">const</span> Point &amp;p);</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">showCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件2 Point.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Point.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Point::cout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">const</span> Point &amp;p):<span class="built_in">x</span>(p.x),<span class="built_in">y</span>(p.y)&#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::showCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object count =&quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件3 主函数 main.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Point.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">a</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Point A:&quot;</span> &lt; a.<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; a.<span class="built_in">getY</span>();</span><br><span class="line">    Point::<span class="built_in">showCount</span>();</span><br><span class="line">    <span class="function">Point <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Point B:&quot;</span> &lt;&lt; b.<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; b.<span class="built_in">getY</span>();</span><br><span class="line">    Point::<span class="built_in">showCount</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部变量</p>
<ul>
<li>除了在定义它的源文件中可以使用外，还能被其他文件使用</li>
<li>文件作用域中定义的变量，默认情况下都是外部变量</li>
<li>在其它文件中如果需要使用，需要用extern关键字声明</li>
</ul>
<p>外部函数</p>
<ul>
<li>在所有类之外声明的函数（也就是非成员函数），都是具有文件作用域的</li>
<li>这样的函数都可以在不同的编译单元中被调用</li>
<li>只要在调用之前进行引用性声明（即声明函数原型）即可</li>
</ul>
<p>将变量和函数限制在编译单元内</p>
<ul>
<li>在匿名命名空间中定义的变量和函数，都不会暴露给其它的编译单元</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="comment">//匿名的命名空间</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准C++库</p>
<ul>
<li>标准C++类库是一个极为灵活并可扩展的可重用软件模块的集合</li>
</ul>
<p>标准C++类与组件在逻辑上分为6种类型：</p>
<ul>
<li>输入&#x2F;输出类</li>
<li>容器类与抽象数据类型</li>
<li>存储管理类</li>
<li>算法</li>
<li>错误处理</li>
<li>运行环境支持</li>
</ul>
<p>编译预处理</p>
<ul>
<li>#include 包含指令<ul>
<li>将一个源文件嵌入到当前源文件中该点处</li>
<li>#include&lt;文件名&gt;<ul>
<li>按标准方式搜索，文件位于C++系统目录的include子目录下</li>
</ul>
</li>
<li>#include “文件名”<ul>
<li>首先在当前目录中搜索，若没有，再按标准方式搜索</li>
</ul>
</li>
</ul>
</li>
<li>#define 宏定义指令<ul>
<li>定义符号常量，很多情况下已被const定义语句取代</li>
<li>定义带参数宏，已被内联函数取代</li>
</ul>
</li>
<li>#under<ul>
<li>删除由 #define 定义的宏，使之不再起作用</li>
</ul>
</li>
</ul>
<p>条件编译指令  #if 和 #endif<br>#if 常量表达式<br>    &#x2F;&#x2F;当 常量表达式 非零时编译<br>    程序正文<br>#endif</p>
<p>条件编译指令 #else<br>#if 常量表达式<br>    &#x2F;&#x2F;当 常量表达式 非零时编译<br>    程序正文1<br>#else<br>    &#x2F;&#x2F;当 常量表达式 为零时编译<br>    程序正文2<br>#endif</p>
<p>条件编译指令 #elif<br>#if 常量表达式1<br>    &#x2F;&#x2F;当 常量表达式1 非零时编译<br>    程序正文1<br>#elif 常量表达式2<br>    &#x2F;&#x2F;当 常量表达式2 非零时编译<br>    程序正文2<br>#else<br>    &#x2F;&#x2F;其他情况下编译<br>    程序正文3<br>#endif</p>
<p>条件编译指令<br>#ifdef 标识符<br>    程序段1<br>#else<br>    程序段2<br>#endif</p>
<ul>
<li>如果 <code>标识符</code> 经 #define 定义过，且未经undef删除，则编译程序段1</li>
<li>否则编译程序段2</li>
</ul>
<p>条件编译指令<br>#ifndef 标识符<br>    程序段1<br>#else<br>    程序段2<br>#endif</p>
<ul>
<li>如果<code>标识符</code>未被定义过，则编译程序段1</li>
<li>否则编译程序段2</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程第二章</title>
    <url>/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0.html</url>
    <content><![CDATA[<h1 id="软件工程第二章"><a href="#软件工程第二章" class="headerlink" title="软件工程第二章"></a>软件工程第二章</h1><h2 id="编程过程与规范"><a href="#编程过程与规范" class="headerlink" title="编程过程与规范"></a>编程过程与规范</h2><p>编程是软件工程师的基本能力</p>
<p>编写优雅的代码是每一个程序员的不懈追求</p>
<p>编程是一门艺术，他能够展示结构之美，构造之美，表达之美</p>
<h3 id="软件变成工作"><a href="#软件变成工作" class="headerlink" title="软件变成工作"></a>软件变成工作</h3><p>软件编程是一个复杂而迭代的过程，它不仅仅是编写代码，还应该包括代码审查，单元测试，代码优化，集成调试等一系列工作。</p>
<p>系统模型到源代码</p>
<ul>
<li>编写代码</li>
<li>代码审查</li>
<li>单元测试</li>
<li>代码优化</li>
<li>系统构建</li>
<li>集成调试</li>
</ul>
<p>高质量软件开发之道</p>
<ul>
<li>规范的编码</li>
<li>高质量的设计</li>
<li>有效的测试</li>
</ul>
<h3 id="软件编程规范"><a href="#软件编程规范" class="headerlink" title="软件编程规范"></a>软件编程规范</h3><p>是与特定语言相关的描写如何编写代码的规则集合</p>
<p>目的</p>
<ul>
<li>提高编码质量，避免不必要的程序错误</li>
<li>增强程序代码的可读性，可重用性和可移植性</li>
</ul>
<p>学会只编写够用的注释，过犹不及，重视质量而不是数量</p>
<ul>
<li>好的注释解释为什么，而不是怎么样</li>
<li>不要在注释中重复描述代码</li>
<li>当自己在编写密密麻麻的注释来解释代码时，需要停下来看是否存在更大的问题</li>
<li>想一想在注释中写什么，不要不动脑筋就输入</li>
<li>写完注释之后要在代码得上下文中回顾一下，它们是否包含正确的信息</li>
<li>当修改代码时，维护代码周围的所有注释</li>
</ul>
<p>命名规范<br>好的名字一目了然，不需要读者去猜，甚至不需要注释</p>
<p>编写自文档化的代码</p>
<ul>
<li>唯一能完整并正确的描述代码的文档是代码本身</li>
<li>编写可以阅读的代码，其本身简单易懂</li>
</ul>
<h2 id="良好的编程实践"><a href="#良好的编程实践" class="headerlink" title="良好的编程实践"></a>良好的编程实践</h2><p>看：阅读优秀的代码，学习别人的代码<br>问：发现问题，提出问题<br>练：亲自动手编写代码，实践，实践，再实践</p>
<p>高质量的设计</p>
<ul>
<li>模块化设计：将一个大的程序按功能分拆成一系列小模块</li>
<li>面向抽象编程</li>
<li>错误与异常处理</li>
</ul>
<p>基于易变与稳定：认识和识别变与不变的部分，并将之科学地分离开<br>易变：业务逻辑<br>稳定：通用功能</p>
<p>基于单一职责：类或者函数应该只做一件事，并且做好这件事<br>单一职责：只有一个引起变化的原因</p>
<p>在模块化设计的基础上，先设计出各个模块的骨架，或者说对各个模块进行抽象，定义它们之间的接口</p>
<h2 id="代码静态检查"><a href="#代码静态检查" class="headerlink" title="代码静态检查"></a>代码静态检查</h2><p>代码审查是一种用来确认方案设计和代码实现的质量保证机制，它通过阅读代码来检查源代码与编码规范的符合性以及代码得质量。</p>
<p>代码审查的作用：</p>
<ul>
<li>检查设计的合理性</li>
<li>互为Backup</li>
<li>分享知识，设计，技术</li>
<li>增加代码可读性</li>
<li>处理代码中的“地雷区”</li>
</ul>
<p>检查编码规范<br>面向对象设计<br>性能方面<br>资源释放处理<br>程序流程<br>线程安全<br>数据库处理<br>通讯方面<br>异常处理<br>方法<br>安全方面<br>其他</p>
<h2 id="代码性能分析"><a href="#代码性能分析" class="headerlink" title="代码性能分析"></a>代码性能分析</h2><p>优化师对代码进行等价变换，使得变换后的代码运行结果与变换前的代码运行结果相同，但执行速度加快或存储开销减少</p>
<ul>
<li>代码性能优化师一门复杂的学问</li>
<li>根据80&#x2F;20原则，实现程序的重构，优化，扩展以及文档相关的事情通常需要消耗80%的工作量</li>
</ul>
<p>满足正确性，可靠性，健壮性，可读性等质量因素的前提下，设法提高程序的效率<br>以提高程序的全局效率为主，提高局部效率为辅<br>在优化程序效率时，应先找出限制效率的“瓶颈”<br>先优化数据结构和算法，再优化执行代码</p>
<p>从一开始就要考虑程序性能，不要期待在开发结束后在做一些快速调整<br>正确的代码要比速度快的代码重要，任何优化都不能破坏代码得正确性</p>
<ul>
<li>证明需要进行优化</li>
<li>找出优化关键部门</li>
<li>测试代码</li>
<li>优化代码</li>
<li>评测优化后的代码</li>
</ul>
<p>认真选择测试数据<br>永远不要在没有执行前后性能评估的情况下尝试对代码进行优化</p>
<p>性能优化的关键是如何发现问题，寻找解决问题的方法<br>有效的测试是不可缺少的，通过测试找出真正的瓶颈，并分析优化结果<br>要避免不必要的优化，避免不成熟的优化，不成熟的优化师错误的来源</p>
<p>改进算法，选择合适的数据结构</p>
<ul>
<li>良好的算法对性能起到关键作用，因此性能改进的首要点是对算法改进</li>
</ul>
<p>循环优化的基本原则：尽量减少循环过程中的计算量，在多重循环的时候，尽量将内层的计算提到上一层</p>
<h2 id="结对编程"><a href="#结对编程" class="headerlink" title="结对编程"></a>结对编程</h2><p>结对编程是由两名程序员在同一台电脑上结对编写解决同一问题的代码</p>
<p>驾驶员：负责用键盘编写程序<br>领航员：起到领航，提醒的作用</p>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库原理第三节</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E8%8A%82.html</url>
    <content><![CDATA[<h1 id="数据库原理第三节"><a href="#数据库原理第三节" class="headerlink" title="数据库原理第三节"></a>数据库原理第三节</h1><h2 id="关系数据模型"><a href="#关系数据模型" class="headerlink" title="关系数据模型"></a>关系数据模型</h2><h3 id="关系数据结构"><a href="#关系数据结构" class="headerlink" title="关系数据结构"></a>关系数据结构</h3><p>码或键：<br><code>属性（属性组）的值</code>都能用来<code>唯一标识</code>该关系的元组，则称这些属性为该关系的<code>码或键</code></p>
<p>超码或超键：<br>在码中去除某个属性，他仍然是这个关系的码</p>
<p>候选码或候选键：<br>在码中不能从中移去任何一个属性，否则它就不再是这个关系的码或键。候选码或候选键是这个关系的最小超码或超键</p>
<p>主属性或码属性：</p>
<p>主码或主键：<br>在若干个候选码中指定一个唯一标识关系的元组（行）</p>
<p>全码或全键：<br>一个关系模式的所有属性集合是这个关系的主码或主键，这样的主码或主键称为全码或全键</p>
<p>外码或外键：<br>某个属性不是这个关系的主码或候选码，而是另一个关系的主码</p>
<p><code>参照关系</code>和<code>被参照关系</code>:<br>参照关系称为从关系，被参照关系称为主关系，它们是指以外码相关联的两个关系</p>
<p>域：<br>表示属性的取值范围</p>
<p>数据类型：<br>每个列都有相应的数据类型，它用于限制（或容许）该列中存储的数据</p>
<p>关系模式：<br>关系模式是<code>型</code>，关系是<code>值</code>，即关系模式是对关系的描述。</p>
<p>关系模式是静态的，稳定的</p>
<p>关系是动态的，随时间不断变化的。</p>
<p>关系数据库：<br>所有关系的集合，构成一个关系数据库<br>以关系模型作为数据的逻辑模型，并采用关系作为数据组织方式的一类数据库，其数据库操作建立在关系代数的基础上</p>
<p>关系数据库对关系的限定&#x2F;要求：</p>
<ul>
<li>每一个属性都是不可分解的</li>
<li>每一个关系仅仅有一种关系模式</li>
<li>每一个关系模式中的属性必须命名，属性名不同</li>
<li>同一个关系中不允许出现候选码或候选键值完全相同的元组</li>
<li>在关系中元组的顺序是无关紧要的，可以任意交换</li>
<li>在关系中属性的顺序是无关紧要的，可以任意交换</li>
</ul>
<h3 id="基本的关系操作"><a href="#基本的关系操作" class="headerlink" title="基本的关系操作"></a>基本的关系操作</h3><p>查询Query:</p>
<ul>
<li>选择</li>
<li>投影</li>
<li>并</li>
<li>差</li>
<li>笛卡尔积<br>从上面的基本的组合：</li>
<li>连接</li>
<li>除</li>
<li>交</li>
</ul>
<p>特点：集合操作方式</p>
<h3 id="关系数据语言的分类"><a href="#关系数据语言的分类" class="headerlink" title="关系数据语言的分类"></a>关系数据语言的分类</h3><p>关系代数语言</p>
<p>关系演算语言</p>
<ul>
<li>元组关系演算</li>
<li>域关系演算</li>
</ul>
<p>SQL结构化查询语言</p>
<p>共同特点：具有完备的表达能力，是非过程化的集合操作语言，功能强，能够独立使用也可以嵌入高级语言中使用。</p>
<h3 id="关系代数的运算符"><a href="#关系代数的运算符" class="headerlink" title="关系代数的运算符"></a>关系代数的运算符</h3><p>任何一种操作都包含三大要素</p>
<ul>
<li>操作对象</li>
<li>操作符</li>
<li>操作结果</li>
</ul>
<h3 id="传统的集合运算"><a href="#传统的集合运算" class="headerlink" title="传统的集合运算"></a>传统的集合运算</h3><p>并，差，交，笛卡尔积</p>
<h3 id="专门的关系运算"><a href="#专门的关系运算" class="headerlink" title="专门的关系运算"></a>专门的关系运算</h3><p>选择，投影，连接，除</p>
<p>选择 select：a<br>a id &#x3D; 1 (user) &#x2F;&#x2F;获取id &#x3D; 1的user表的数据<br>相当于这个SQL：select * from user where id &#x3D; 1<br>a id &#x3D; 1 ^ name &#x3D; ‘abc’ (user)<br>SQL: select * from user where id &#x3D; 1 and name &#x3D; ‘abc’</p>
<p>投影 projection：π<br>projection 关系名（属性名1，。。。） 选出要展示的列<br>π id,name (id &#x3D; 1 ^ name &#x3D; ‘abc’ (user))<br>SQL: select id,name from (select * from user where id &#x3D; 1 and name &#x3D; ‘abc’)</p>
<p>并集 union：union 需要两个表的属性值一样才可以，假设两个表都是id,name字段那么可以，如果一个表有三个字段就不行<br>t1 union t2, 就是把两个表合并<br>SQL: (select * from t1) union all (select * from t2)  &#x2F;&#x2F;和union不完全一样</p>
<p>交集 intersection：和union要求一样，选的是交集<br>t1 intersect t2</p>
<p>差集 difference: 和union要求一样，取得是第一个表出现过第二表没出现的数据<br>t1 except t2</p>
<p>笛卡尔积 product: 把两个表所有的组合列出来<br>t1 * t2<br>SQL: select * from t1 cross join t2</p>
<p>连接 join: 取某个字段值相同的数据，和sql的join差不多<br>t1 join t2<br>SQL: select * from t1 natural join t2</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库原理第四节</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E8%8A%82.html</url>
    <content><![CDATA[<h1 id="数据库原理第四节"><a href="#数据库原理第四节" class="headerlink" title="数据库原理第四节"></a>数据库原理第四节</h1><h2 id="关系数据模型"><a href="#关系数据模型" class="headerlink" title="关系数据模型"></a>关系数据模型</h2><h3 id="关系的完整性约束"><a href="#关系的完整性约束" class="headerlink" title="关系的完整性约束"></a>关系的完整性约束</h3><p>数据库的数据完整性是指数据库中数据的<code>正确性</code>，<code>相容性</code>，<code>一致性</code></p>
<p>分类：</p>
<ul>
<li>实体完整性约束：主码的组成不能为空，主属性不能是空值NULL</li>
<li>参照完整性约束：要么外码等于主码某个元组的主码值，要么为空值</li>
<li>用户定义完整性约束</li>
<li>域完整性约束</li>
</ul>
<p>执行插入操作检查：</p>
<ul>
<li>检查实体完整性约束</li>
<li>插入外码表的时候检查参照完整性约束</li>
<li>检查用户定义完整性约束</li>
</ul>
<p>执行删除操作：<br>一般只需要对被参照关系检查参照完整性约束</p>
<h2 id="关系数据库的规范化理论"><a href="#关系数据库的规范化理论" class="headerlink" title="关系数据库的规范化理论"></a>关系数据库的规范化理论</h2><h3 id="关系模式中可能存在的冗余和异常问题"><a href="#关系模式中可能存在的冗余和异常问题" class="headerlink" title="关系模式中可能存在的冗余和异常问题"></a>关系模式中可能存在的冗余和异常问题</h3><ul>
<li>数据冗余</li>
<li>更新异常</li>
<li>插入异常</li>
<li>删除异常</li>
</ul>
<h3 id="函数依赖与关键字"><a href="#函数依赖与关键字" class="headerlink" title="函数依赖与关键字"></a>函数依赖与关键字</h3><p>设R为任一给定关系，如果对于R中属性X的每一个值，R中的属性Y只有唯一值与之对应，则称X函数决定Y或称Y函数依赖于X，记作X-&gt;Y.其中X称为<code>决定因素</code></p>
<p>分类：</p>
<ul>
<li>完全函数依赖</li>
<li>部分函数依赖</li>
<li>传递函数依赖</li>
</ul>
<p> 完全函数依赖：<br> 设R为任一给定关系，X,Y为其属性集，若X-&gt;Y，且对X中的任何真子集X’，都有X’不依赖Y,则称Y完全函数依赖于X</p>
<p> 部分函数依赖：<br> 设R为任一给定关系，X,Y为其属性集，若X-&gt;Y,且X中存在一个真子集X’,都有X’-&gt;Y，则称Y部分依赖于X</p>
<p> 传递函数依赖：<br> 设R为任一给定关系，X,Y,Z为其不同属性子集，若X-&gt;Y,Y不决定X,Y-&gt;Z,则有X-&gt;Z，称为Z传递函数依赖于X。</p>
<p> 关键字的定义：<br> 设R为任一给定关系，U为其所含的全部属性集合，X为U的子集，若有完全函数依赖X-&gt;U，则X为R的一个候选关键字。</p>
<h3 id="范式与关系规范化过程"><a href="#范式与关系规范化过程" class="headerlink" title="范式与关系规范化过程"></a>范式与关系规范化过程</h3><p>一个低一级范式的关系模式通过<code>模式分解</code>可以转换为若干个高一级范式的关系模式的集合，这种过程就叫<code>规范化</code></p>
<p>第一范式1NF:<br>设R为任一给定关系，如果R中每个列与行的交点处的取值都是不可再分的基本元素，则R为第一范式</p>
<p>第二范式2NF:<br>设R为任一给定关系，若R为1NF<br>且其所有非主属性都完全函数依赖于候选关键字，则R为第二范式。</p>
<p>第三范式3NF:<br>设R为任一给定关系，若R为2NF<br>且其每一个非主属性都不传递函数依赖于候选关键字，则R为第三范式。</p>
<p>第三范式的改进形式BCNF:<br>设R为任意给定关系，X,Y为其属性集，F为其函数依赖集，若R为3NF<br>且其F中所有函数依赖X-&gt;Y(Y不属于X)中的X比包含候选关键字，则R为BCNF</p>
<p>有部分函数依赖就是1NF，没有就是2NF，没有传递函数依赖就是3NF</p>
<p>1NF-&gt;2NF<br>找到候选关键字，看其余的属性是否完全函数依赖候选关键字<br>是的，与候选关键字一同抄下来形成一个表格<br>不是的，抄下来，形成第二个表格，并且将候选关键字里能够唯一决定表格2的属性组抄在第一列</p>
<p>2NF-&gt;3NF<br>找到表格中的传递函数依赖关系的三个属性组，设为X,Y,Z<br>将这三个属性组拆成两个表格<br>第一个表格为X,Y<br>第二个表格为Y,Z</p>
<p>3NF-&gt;BCNF<br>列出表格中的所有函数依赖关系<br>每个关系拆出一个表格</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>学堂在线C++程序设计第五章学习笔记</title>
    <url>/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%BA%94%E7%AB%A0.html</url>
    <content><![CDATA[<h1 id="学堂在线C-程序设计第五章学习笔记"><a href="#学堂在线C-程序设计第五章学习笔记" class="headerlink" title="学堂在线C++程序设计第五章学习笔记"></a>学堂在线C++程序设计第五章学习笔记</h1><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>对象：现实中对象的模拟，具有属性和行为。<br>类：同一类对象的共同属性和行为</p>
<p>定义对象时：通过构造函数初始化<br>删除对象时：通过析构函数释放资源</p>
<h3 id="面向对象程序的基本特点"><a href="#面向对象程序的基本特点" class="headerlink" title="面向对象程序的基本特点"></a>面向对象程序的基本特点</h3><p>抽象：对同一类对象的共同属性和行为进行概括，形成类</p>
<p>封装：将抽象出的数据，代码封装在一起，形成类</p>
<p>继承：在已有类的基础上，进行扩展形成新的类</p>
<p>多态：同一名称，不同的功能实现方式</p>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>设计类就是设计类型</p>
<ul>
<li>此类型的“合法值”是什么</li>
<li>此类型应该有什么样的函数和操作符</li>
<li>新类型的对象该如何被创建和销毁</li>
<li>如何进行对象的初始化和赋值</li>
<li>对象作为函数的参数如何以值传递</li>
<li>谁将使用此类型的对象成员</li>
</ul>
<p>类定义的语法形式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名称</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        公有成员（外部接口）</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        私有成员</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        保护型成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的成员函数</p>
<ul>
<li>在类中声明函数原型</li>
<li>可以在类外给出函数体实现，并在函数名前使用类名加以限定</li>
<li>也可以直接在类中给出函数体，形成内联成员函数</li>
<li>允许声明重载函数和带默认参数值得函数</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>类中的特殊函数<br>用于描述初始化算法</p>
<p>作用：</p>
<ul>
<li>在对象被创建时使用特定的值构造对象，将对象<code>初始化</code>为一个特定的初始状态</li>
</ul>
<p>形式：</p>
<ul>
<li>函数名与类名相同</li>
<li>不能定义返回值类型，也不能有return语句</li>
<li>可以有形式参数，也可以没有形式参数</li>
<li>可以是内联函数</li>
<li>可以重载</li>
<li>可以带默认参数值</li>
</ul>
<p>调用时机</p>
<ul>
<li>在对象创建时被自动调用</li>
<li>例如：<br>  Clock myClock(0,0,0)</li>
</ul>
<p>默认构造函数</p>
<ul>
<li>调用时可以不需要实参的构造函数<ul>
<li>参数表为空的构造函数</li>
<li>全部参数都有默认值的构造函数</li>
</ul>
</li>
</ul>
<p>隐含生成的构造函数</p>
<ul>
<li>如果程序中未定义构造函数，编译器将自动生成一个默认构造函数</li>
<li>参数列表为空，不为数据成员设置初始值</li>
<li>如果类内定义了成员的初始值，则使用内类定义的初始值</li>
<li>如果没有定义类内的初始值，则以默认方式初始化</li>
<li>基本类型的数据默认初始化的值是不确定的</li>
</ul>
<p>复制构造函数</p>
<ul>
<li>复制构造函数是一种特殊的构造函数，其形参为本类的对象引用。作用是用一个已存在的对象去初始化同类型的新对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        类名（<span class="type">const</span> 类名 &amp;对象名）; <span class="comment">//复制构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">类名::类（<span class="type">const</span> 类名 &amp;对象名） &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制构造函数被调用的三种情况</p>
<ul>
<li>定义一个对象时，以本类另一个对象作为初始值，发生复制构造</li>
<li>如果函数的形参是类的对象，调用函数时，将使用实参对象初始化形参对象，发生复制构造</li>
<li>如果函数的返回值是类的对象，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主调函数，此时发生复制构造</li>
</ul>
<p>隐含的复制改造函数</p>
<ul>
<li>如果没有为类声明拷贝初始化构造函数，则编译器自己生成一个隐含的复制构造函数</li>
<li>这个构造函数执行的功能是：用初始值对象的每个数据成员，初始化将要建立的对象的对应数据成员</li>
</ul>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ul>
<li>完成对象被删除前的一些清理工作。</li>
<li>在对象的生存期结束的时刻系统自动调用它，然后再释放此对象所属的空间。</li>
<li>如果程序中未声明析构函数，编译器将自动产生一个默认的析构函数，其函数体为空。</li>
<li>析构函数的原型：~类名（）</li>
<li>析构函数没有参数，没有返回类型</li>
</ul>
<h3 id="类的组合"><a href="#类的组合" class="headerlink" title="类的组合"></a>类的组合</h3><ul>
<li>类中的成员是另一个类的对象</li>
<li>可以在已有抽象的基础上实现更复杂的抽象</li>
</ul>
<p>类组合的构造函数设计</p>
<ul>
<li>原则:不仅要对本类中的基本类型成员数据初始化，也要对对象成员初始化</li>
<li>声明形式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类名::类名（对象成员所需的形参，本类成员的形参）：</span><br><span class="line">对象1（参数），对象2（参数）,...</span><br><span class="line">&#123;</span><br><span class="line">    //函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造组合类对象时的初始化次序</p>
<ul>
<li>首先对构造函数初始化列表中列出的成员（包括基本类型和对象成员）进行初始化，初始化次序是成员在类体中定义的次序<ul>
<li>成员对象构造函数调用顺序：按对象成员的定义顺序，先声明者先构造</li>
<li>初始化列表中未出现的成员对象，调用默认构造函数（即无形参）的初始化</li>
</ul>
</li>
<li>处理完初始化列表后，再执行构造函数的函数体</li>
</ul>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体是一种特殊形态的类<br>与类的唯一区别</p>
<ul>
<li>类的缺省访问权限是private</li>
<li>结构体的缺省访问权限是public</li>
</ul>
<p>什么时候用结构体</p>
<ul>
<li>定义主要用来保存数据，而没有什么操作的类型</li>
<li>人们习惯将结构体的数据成员设为公有，因此这时用结构体更方便</li>
</ul>
<p>定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> 结构体名称&#123;</span><br><span class="line">    共有成员</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    保护型成员</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    私有成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体中可以有数据成员和函数成员</p>
<p>结构体的初始化<br>如果：</p>
<ul>
<li>一个结构体的全部数据成员都是公共成员</li>
<li>没有用户定义的构造函数</li>
<li>没有基类和虚函数</li>
</ul>
<p>这个结构体的变量可以用下面的语法形式初始化<br>类型名 变量名 &#x3D; {成员数据1初始值,…}</p>
<h3 id="联合体"><a href="#联合体" class="headerlink" title="联合体"></a>联合体</h3><p>定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> 联合体名称&#123;</span><br><span class="line">    共有成员</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    保护型成员</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    私有成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>成员共用同一组内存单元</li>
<li>任何两个成员不会同时有效</li>
</ul>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>定义<br>enum class 枚举类型名：底层类型{枚举值列表}<br>例子：<br>enum class Type{General,Light}<br>enum class Type:char{General,Light}</p>
<p>枚举类的优势</p>
<ul>
<li>强作用域：作用域限制在枚举类中</li>
<li>转换限制：枚举类对象不可以与整型隐式转换</li>
<li>可以指定底层类型</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>学堂在线C++程序设计第四章学习笔记</title>
    <url>/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%AB%A0.html</url>
    <content><![CDATA[<h1 id="学堂在线C-程序设计第四章学习笔记"><a href="#学堂在线C-程序设计第四章学习笔记" class="headerlink" title="学堂在线C++程序设计第四章学习笔记"></a>学堂在线C++程序设计第四章学习笔记</h1><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>函数：定义好的可重用功能模块</p>
<p>定义函数：将一个模块的算法用C++描述出来</p>
<p>函数的返回值：需要返回的计算结果</p>
<p>定义函数的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类型标识符 函数名（形式参数表）</span><br><span class="line">&#123;</span><br><span class="line">    语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形式参数表</p>
<ul>
<li>&lt;类型名&gt; 参数名，…</li>
</ul>
<p>返回值</p>
<ul>
<li>return 一个计算结果</li>
<li>返回的类型是类型标识符的类型</li>
<li>没有返回值，类型标识符写<code>void</code></li>
</ul>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>调用函数前需要先声明函数原型</p>
<p>函数原型</p>
<ul>
<li>类型标识符</li>
<li>被调用函数名</li>
<li>（类型说明的形参表）</li>
</ul>
<p>函数调用</p>
<ul>
<li>函数名（实参列表）</li>
</ul>
<h3 id="计算x的n次方"><a href="#计算x的n次方" class="headerlink" title="计算x的n次方"></a>计算x的n次方</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">pow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum = x * sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> sum = <span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p>输入一个8位二进制，输出十进制</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">pow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum *= x;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x:&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;n:&quot;</span>&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">char</span> d;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;输入：&quot;</span>;</span><br><span class="line">        cin &gt;&gt; d;</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//转换进制</span></span><br><span class="line">            h += <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">pow</span>(<span class="number">2</span>, i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; h;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计算圆周率"><a href="#计算圆周率" class="headerlink" title="计算圆周率"></a>计算圆周率</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">arctan</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="type">double</span> sqr = x * x;</span><br><span class="line"></span><br><span class="line">          <span class="type">double</span> e = x;</span><br><span class="line"></span><br><span class="line">          <span class="type">double</span> r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span> (e / i &gt; <span class="number">1e-15</span>) &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="type">double</span> f = e / i;</span><br><span class="line"></span><br><span class="line">                   r = (i % <span class="number">4</span> == <span class="number">1</span>) ? r + f : r - f;</span><br><span class="line"></span><br><span class="line">                   e = e * sqr;</span><br><span class="line"></span><br><span class="line">                   i += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="type">double</span> a = <span class="number">16.0</span> * <span class="built_in">arctan</span>(<span class="number">1</span>/<span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line">          <span class="type">double</span> b = <span class="number">4.0</span> * <span class="built_in">arctan</span>(<span class="number">1</span>/<span class="number">239.0</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//注意：因为整数相除结果取整，如果参数写1/5，1/239，结果就都是0</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;PI = &quot;</span> &lt;&lt; a - b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求回文"><a href="#求回文" class="headerlink" title="求回文"></a>求回文</h3><p>寻找并输出11~999之间的数M，它满足M、M<sup>2</sup>和M<sup>3</sup>均为回文数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是回文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">symm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i = n;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        m = m * <span class="number">10</span> + i % <span class="number">10</span>;</span><br><span class="line">        i /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m == n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">11</span>; i &lt;= <span class="number">999</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">symm</span>(i) &amp;&amp; <span class="built_in">symm</span>(i * i) &amp;&amp; <span class="built_in">symm</span>(i * i *i)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;m = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;m * m =&quot;</span> &lt;&lt; i * i &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;m * m * m = &quot;</span> &lt;&lt; i * i*i &lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计算分段函数，并输出结果"><a href="#计算分段函数，并输出结果" class="headerlink" title="计算分段函数，并输出结果"></a>计算分段函数，并输出结果</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> IINY_VALUE = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">tsin</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> g = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> t = x;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        g += t;</span><br><span class="line">        n++;</span><br><span class="line">        t = -t * x * x/(<span class="number">2</span>*n<span class="number">-1</span>)/(<span class="number">2</span> * n <span class="number">-2</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">fabs</span>(t) &gt;= IINY_VALUE);</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> k,r,s;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;r =&quot;</span>;</span><br><span class="line">    cin &gt;&gt; r;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s=&quot;</span>;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (r * r &lt;= s * s) &#123;</span><br><span class="line">        k = <span class="built_in">sqrt</span>(<span class="built_in">tsin</span>(r) * <span class="built_in">tsin</span>(r) + <span class="built_in">tsin</span>(s) * <span class="built_in">tsin</span>(s));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        k = <span class="built_in">tsin</span>(r * s) /<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; k &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="摇筛子游戏"><a href="#摇筛子游戏" class="headerlink" title="摇筛子游戏"></a>摇筛子游戏</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">gameStatus</span> &#123;WIN,LOSE,PLAYING&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rollDice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> rand1 = <span class="built_in">rand</span>() % <span class="number">6</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> rand2 = <span class="built_in">rand</span>() % <span class="number">6</span> + <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rand1 + rand2 = &quot;</span> &lt;&lt; rand1 + rand2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> rand1 + rand2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> seed, sum, myPoint;</span><br><span class="line">    gameStatus status;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;enter is seed:&quot;</span>;</span><br><span class="line">    cin &gt;&gt; seed;</span><br><span class="line">    <span class="built_in">srand</span>(seed);</span><br><span class="line">    sum = <span class="built_in">rollDice</span>();</span><br><span class="line">    <span class="keyword">switch</span> (sum)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        status = WIN;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        status = LOSE;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        status = PLAYING;</span><br><span class="line">        myPoint = sum;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (status == PLAYING)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        sum = <span class="built_in">rollDice</span>();</span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">7</span>) &#123;</span><br><span class="line">            status = LOSE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum == myPoint) &#123;</span><br><span class="line">            status = WIN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == WIN) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;WIN&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == LOSE) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;LOSE&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++程序设计第三章</title>
    <url>/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%89%E7%AB%A0.html</url>
    <content><![CDATA[<h1 id="C-程序设计第三章"><a href="#C-程序设计第三章" class="headerlink" title="C++程序设计第三章"></a>C++程序设计第三章</h1><h2 id="数据的输入输出"><a href="#数据的输入输出" class="headerlink" title="数据的输入输出"></a>数据的输入输出</h2><p>输入输出看成是数据的流动</p>
<p>IO流</p>
<ul>
<li>将数据从一个对象到另一个对象的流动抽象为<code>流</code></li>
<li>流在使用前要建立，使用后要删除</li>
<li>数据的输入输出是通过IO流来实现的，cin和cout是预定义的流类对象。cin用来处理标准输入，即键盘输入。cout用来处理标准输出，即屏幕输出</li>
<li>从流中获取数据的操作称为</li>
</ul>
<p>预定义的插入符和提取符</p>
<ul>
<li><code>&lt;&lt;</code> 是预定义的插入符，作用在流对象cout上就可以向标准输出设备输出</li>
<li><code>&gt;&gt;</code> 是预定义的提取符，作用在流对象cin上</li>
<li>可以写多个</li>
</ul>
<p>常用的IO流类库操纵符</p>
<table>
<thead>
<tr>
<th align="left">操纵符名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">dec</td>
<td align="left">数值数据采用十进制表示</td>
</tr>
<tr>
<td align="left">hex</td>
<td align="left">数值数据采用十六进制表示</td>
</tr>
<tr>
<td align="left">oct</td>
<td align="left">数值数据采用八进制表示</td>
</tr>
<tr>
<td align="left">ws</td>
<td align="left">提取空白符</td>
</tr>
<tr>
<td align="left">endl</td>
<td align="left">插入换行符并刷新流</td>
</tr>
<tr>
<td align="left">ends</td>
<td align="left">插入空字符</td>
</tr>
<tr>
<td align="left">setprecision(int)</td>
<td align="left">设置浮点数的小数位数(包括小数点)</td>
</tr>
<tr>
<td align="left">setw(int)</td>
<td align="left">设置域宽</td>
</tr>
</tbody></table>
<h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>if语句的语法形式</p>
<ul>
<li>if (表达式)语句<br>  if (x &gt; y) cout  &lt;&lt; x;</li>
<li>if (表达式) 语句1 else 语句2<br>  if (x &lt; y) cout &lt;&lt; x;<br>  else cout &lt;&lt;y;</li>
<li>if (表达式1) 语句1 else if (表达式2) 语句2 else 语句n</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (表达式<span class="number">1</span>) </span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (表达式<span class="number">2</span>) </span><br><span class="line">    语句<span class="number">2</span> </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    语句n</span><br></pre></td></tr></table></figure>

<p>上面的表达式等同于下面的表达式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (表达式<span class="number">1</span>) </span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">if</span> (表达式<span class="number">2</span>) </span><br><span class="line">        语句<span class="number">2</span> </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        语句n</span><br></pre></td></tr></table></figure>

<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> （表达式<span class="number">1</span>） &#123;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">1</span>：</span><br><span class="line">        语句<span class="number">1</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">2</span>：</span><br><span class="line">        语句<span class="number">2</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        默认语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表达式和常量值都是int或char型</p>
<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><p>计算0到10之和</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> （<span class="type">int</span> i &lt;= <span class="number">10</span>） &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行顺序</p>
<ul>
<li>先判断while表达式的值，若为true，执行语句</li>
<li>执行完语句在判断while表达式的值，直到为false,不再执行</li>
</ul>
<p>while里面可以是<code>复合语句</code>，其中必须含有改变<code>条件表达式</code>值得语句</p>
<h3 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do-while语句"></a>do-while语句</h3><p>计算0到10之和</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="keyword">while</span> （ i &lt;= <span class="number">10</span>）</span><br></pre></td></tr></table></figure>

<p>执行顺序</p>
<ul>
<li>先执行语句</li>
<li>执行完语句判断while表达式的值，如果为true，那么接着执行语句</li>
<li>执行完语句后再次判断while表达式的值，直到为false</li>
<li>语句至少会执行一次</li>
</ul>
<h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><p>输入一个整数，求出他的所有因子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Number:&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;Factors\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= n;k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % k == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套的控制结构"><a href="#嵌套的控制结构" class="headerlink" title="嵌套的控制结构"></a>嵌套的控制结构</h3><p>输入一系列整数，统计出正整数个数i和负整数个数j,读入0则结束</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;<span class="type">int</span> z = <span class="number">0</span>;<span class="type">int</span> f = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            z++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            f++;</span><br><span class="line">        &#125;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;n:&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;正数数量：&quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;负数数量：&quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>类型别名：为已有类型另外命名</p>
<ul>
<li>typedef 已有类型名 新类型名表</li>
<li>例子：typedef double area</li>
<li>using 新类型名 &#x3D; 已有类型名</li>
<li>例子：using area &#x3D; double</li>
</ul>
<p>枚举类型：</p>
<ul>
<li>定义方式：<br>  将全部可取值列出来</li>
<li>语法形式：<br>  enum 枚举类型名 {变量值列表}</li>
<li>例子<br>  enum week {1,2,3,4,5,6,7}</li>
</ul>
<p>C++包含两种枚举类型：</p>
<ul>
<li>不限定作用域</li>
<li>限定作用域</li>
</ul>
<p>不限定作用域枚举类型</p>
<ul>
<li>枚举元素是常量，不能赋值</li>
<li>枚举元素具有默认值，依次为0,1,2,3</li>
<li>也可以在声明时另行指定枚举元素的值</li>
<li>枚举值可以进行关系运算</li>
<li>整数值不能赋值为枚举变量，如需要，应该进行强制转换</li>
<li>枚举可以给整形赋值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">GameResult</span> &#123;WIN,LOSE,TIE,CANCEL&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    GameResult Result;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">GameResult</span> omit = CANCEL;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count = WIN; count &lt;= CANCEL; count++) &#123;</span><br><span class="line">        Result = <span class="built_in">GameResult</span>(count);</span><br><span class="line">        <span class="keyword">if</span> (Result == omit) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;The game was canceld&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;The game was played&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span> (Result == WIN) cout &lt;&lt; <span class="string">&quot;and we Win&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span> (Result == LOSE) cout &lt;&lt; <span class="string">&quot;and we lose&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>auto 类型 与 decltype类型</p>
<ul>
<li>auto ：编译器通过初始值自动推断变量的类型<br>  例如：auto val &#x3D; val1 + val2<br>  如果val1 val2是int，那么val是int<br>  如果val1 val2是double，那么val是double</li>
<li>decltype:定义一个变量与某一表达式的类型相同，单并不用该表达式初始化变量<br>  例如：decltype(i)j &#x3D; 2;<br>  表示j 用 2 作为初始值，但是类型和i一致</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++程序设计第二章</title>
    <url>/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%BA%8C%E7%AB%A0.html</url>
    <content><![CDATA[<h1 id="C-程序设计第二章"><a href="#C-程序设计第二章" class="headerlink" title="C++程序设计第二章"></a>C++程序设计第二章</h1><h2 id="C-简单程序设计"><a href="#C-简单程序设计" class="headerlink" title="C++简单程序设计"></a>C++简单程序设计</h2><p>C++的基本数据类型</p>
<ul>
<li>整数类型</li>
<li>实数类型</li>
<li>字符类型</li>
<li>布尔类型</li>
</ul>
<p>C++的基本运算</p>
<ul>
<li>算术运算</li>
<li>逻辑运算</li>
</ul>
<p>程序要能输入数据，输出数据</p>
<p>C++的输入输出可以调用预定义的功能模块实现</p>
<p>程序的执行流程不总是顺序的因此程序要能够</p>
<ul>
<li>对执行流程进行选择（选择&#x2F;开关语句）</li>
<li>反复用同一算法依次处理大批量数据（循环语句）</li>
</ul>
<p>基本数据类型能表示的有限 </p>
<p>程序员要能够自定义类型</p>
<p>枚举类型</p>
<ul>
<li>通过列出所有可取值来定义一种新类型</li>
</ul>
<h2 id="C-特点和程序实例"><a href="#C-特点和程序实例" class="headerlink" title="C++特点和程序实例"></a>C++特点和程序实例</h2><ul>
<li>从C语言发展而来，最初称为<code>带类的C</code></li>
<li>1983年正式取名为C++；</li>
<li>1998年11月被国际标准化组织（ISO）批准为国际标准；</li>
<li>2003年10月15日发布第2版C++标准ISO&#x2F;IEC 14882:2003；</li>
<li>2011年8月12日ISO公布了第三版C++标准C++11，包含核心语言的新机能、扩展C++标准程序库。</li>
<li>2014年8月18日ISO公布了C++14，其正式名称为”International Standard ISO&#x2F;IEC 14882:2014(E) Programming Language C++”。</li>
<li>C++14作为C++11的一个小扩展，主要提供漏洞修复和小的改进。</li>
</ul>
<p>C++的特点</p>
<ul>
<li>兼容C,支持面向过程的程序设计</li>
<li>支持面向对象的方法</li>
<li>支持泛型程序设计方法</li>
</ul>
<p>命名空间</p>
<ul>
<li>避免命名冲突</li>
<li>std是C++标准库的命名空间名</li>
<li>using namespace std 表示打开std命名空间</li>
</ul>
<p>输出Hello</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Welcome to C++!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-字符集和词法记号"><a href="#C-字符集和词法记号" class="headerlink" title="C++字符集和词法记号"></a>C++字符集和词法记号</h2><p>词法记号</p>
<ul>
<li>关键字<br>  C++预定义的单词</li>
<li>标志符<br>  程序员声明的单词，它命名程序正文中的一些实体</li>
<li>文字<br>  在程序中直接使用符号表示的数据</li>
<li>分隔符<br>  （）{}；：，用于分隔各个词法记号或程序正文</li>
<li>运算符（操作符）<br>  用于实现各种运算的符号</li>
<li>空白符<br>  空格， 制表符,垂直制表符，换行符，回车符和注释的总称</li>
</ul>
<p>标识符的构成规则</p>
<ul>
<li>以大写字母，小写字母或下划线开始</li>
<li>可以由大写字母，小写字母，下划线或数字组成</li>
<li>大写字母和小写字母代表不同的标识符</li>
<li>不能是C++关键字或操作符</li>
</ul>
<h2 id="基本数据类型，常量，变量"><a href="#基本数据类型，常量，变量" class="headerlink" title="基本数据类型，常量，变量"></a>基本数据类型，常量，变量</h2><p>程序中的数据</p>
<ul>
<li>常量<br>  在源程序中直接写明的数据<br>  其值在整个程序运行期间不可改变</li>
<li>变量<br>  在程序运行过程中可以改变</li>
</ul>
<p>整数类型</p>
<ul>
<li>基本的INT型 </li>
<li>按照符号分<ul>
<li>有符号</li>
<li>无符号</li>
</ul>
</li>
<li>按照数据范围分<ul>
<li>短整数 short</li>
<li>长整数 long</li>
<li>长长整数 longlong</li>
</ul>
</li>
</ul>
<p>字符类型</p>
<ul>
<li>字符容纳单个字符的编码</li>
<li>实质上存储的也是整数</li>
</ul>
<p>浮点数类型</p>
<ul>
<li>单精度 float</li>
<li>双精度 double</li>
<li>扩展精度 long double</li>
</ul>
<p>字符串类型</p>
<ul>
<li>有字符串常量</li>
<li>基本类型中没有字符串变量</li>
<li>采用字符数组存储字符串</li>
<li>标准C++库中的String类</li>
</ul>
<p>布尔类型</p>
<ul>
<li>只有两个值，真 true 假 false</li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul>
<li>在程序运行中不可改变的量</li>
<li>直接使用符号（文字）表示的值</li>
<li>例如：12,3.5，’A’都是常量</li>
</ul>
<p>整数常量</p>
<ul>
<li>十进制</li>
<li>八进制</li>
<li>十六进制</li>
</ul>
<p>后缀</p>
<ul>
<li>L &#x3D; long</li>
<li>LL &#x3D; longlong </li>
<li>U &#x3D; 无符号</li>
</ul>
<p>浮点数常量</p>
<ul>
<li>以文字形式出现的实数</li>
<li>默认double ，如果后缀F可以指定成float</li>
</ul>
<p>C风格字符串</p>
<ul>
<li>一对双引号的字符</li>
<li>在内存中按串中字符的排列次序顺序存放，每个字符占一个字节</li>
<li>在末尾添加’\0’作为结尾标记</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在程序运行过程中可改变的量</p>
<p>变量定义</p>
<ul>
<li>类型 变量名</li>
</ul>
<p>在定义变量的同时可以初始化</p>
<p>C++多种初始化</p>
<ul>
<li>int a &#x3D; 0;</li>
<li>int a(0)</li>
<li>int a &#x3D; {0}</li>
<li>int a{0}</li>
</ul>
<p>列表初始化</p>
<ul>
<li>使用大括号的初始化方式</li>
<li>不允许信息的丢失</li>
</ul>
<h3 id="符号常量"><a href="#符号常量" class="headerlink" title="符号常量"></a>符号常量</h3><p>常量定义语句的形式：</p>
<ul>
<li>const 数据类型说明符 常量名 &#x3D; 值</li>
<li>数据类型说明符 const 常量名 &#x3D; 值</li>
</ul>
<p>符号常量定义一定需要初始化，在程序中不能改变值</p>
<h3 id="程序举例"><a href="#程序举例" class="headerlink" title="程序举例"></a>程序举例</h3><h4 id="读入并显示整数"><a href="#读入并显示整数" class="headerlink" title="读入并显示整数"></a>读入并显示整数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> radius;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please enter the radius\n&quot;</span>;</span><br><span class="line">    cin &gt;&gt; radius;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The radius is:&quot;</span> &lt;&lt; radius &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;PI is:&quot;</span> &lt;&lt; <span class="number">3.14</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please enter a different radius\n&quot;</span>;</span><br><span class="line">    cin &gt;&gt; radius;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Now the radius is changed to:&quot;</span> &lt;&lt; radius &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运算与表达式"><a href="#运算与表达式" class="headerlink" title="运算与表达式"></a>运算与表达式</h2><h3 id="算术运算与赋值运算"><a href="#算术运算与赋值运算" class="headerlink" title="算术运算与赋值运算"></a>算术运算与赋值运算</h3><p>基本算术运算</p>
<ul>
<li>+-*&#x2F;（整数相除，结果为整数）</li>
<li>%取余运算（结果为整数）</li>
</ul>
<p>优先级与结合性</p>
<ul>
<li>先乘除，后加减，同级自左至右</li>
</ul>
<p>自增自减操作</p>
<p>赋值操作<br>通过赋值运算符&#x3D;赋值给变量</p>
<p>复合赋值运算符有10种</p>
<ul>
<li>+&#x3D;， -&#x3D;， *&#x3D;， &#x2F;&#x3D;， &lt;&lt;&#x3D;, &gt;&gt;&#x3D;, &amp;&#x3D;, ^&#x3D;, |&#x3D;</li>
</ul>
<h3 id="符号运算，关系运算，逻辑运算和条件运算"><a href="#符号运算，关系运算，逻辑运算和条件运算" class="headerlink" title="符号运算，关系运算，逻辑运算和条件运算"></a>符号运算，关系运算，逻辑运算和条件运算</h3><p>逗号运算和逗号表达式</p>
<ul>
<li>格式<br>  表达式1，表达式2</li>
<li>求解顺序及结果<br>  先求解表达式1，在求解表达式2<br>  用表达式2的结果作为结果</li>
<li>例子<br>  a &#x3D; 3 * 5, a * 4 最终结果为60</li>
</ul>
<p>赋值运算符优先级比逗号低</p>
<p>关系运算</p>
<ul>
<li>优先级<br>  高的：&lt; &lt;&#x3D; &gt;&#x3D; &gt;<br>  低的：&#x3D;&#x3D; !&#x3D;</li>
<li>关系表达式是一种最简单的逻辑表达式</li>
<li>结果是布尔类型，true or false</li>
</ul>
<p>逻辑运算符</p>
<ul>
<li>优先级从高到低：！ &amp;&amp; ||</li>
<li>结果是布尔类型</li>
<li>&amp;&amp; 的运算规则<ul>
<li>两侧表达式都为真，结果为真</li>
<li>有一侧表达式为假，结果为假</li>
</ul>
</li>
<li>|| 的运算规则<ul>
<li>两侧表达式都为假，结果为假</li>
<li>有一侧表达式为真，结果为真</li>
</ul>
</li>
</ul>
<p>&amp;&amp; 的<code>短路</code>特性</p>
<ul>
<li>先求解表达式1,</li>
<li>若表达式1的值为false,则最终结果为false,不再求解表达式2</li>
<li>若表达式1的值为true,则求解表达式2，以表达式2的结果作为最终结果</li>
</ul>
<p>|| 的<code>短路</code>特性</p>
<ul>
<li>先求解表达式1</li>
<li>若表达式1的值为true,则最终结果为true,不在求解表达式2</li>
<li>若表达式1的值为false,则求解表达式2，以表达式2的结果作为最终结果</li>
</ul>
<p>条件运算符</p>
<ul>
<li>一般形式<ul>
<li>表达式1 ？ 表达式2 ： 表达式3</li>
<li>表达式1必须是bool类型</li>
</ul>
</li>
<li>执行顺序<ul>
<li>先求解表达式1</li>
<li>若表达式1的值为true,则求解表达式2，表达式2的结果作为最终结果</li>
<li>若表达式1的值为false，则求解表达式3，表达式3的结果作为最终结果</li>
</ul>
</li>
<li>条件运算符优先级高于赋值运算符，低于逻辑运算符</li>
</ul>
<h3 id="sizeof运算，位运算"><a href="#sizeof运算，位运算" class="headerlink" title="sizeof运算，位运算"></a>sizeof运算，位运算</h3><p>sizeof运算符</p>
<ul>
<li>语法形式<br>  sizeof(类型名) 或 sizeof 表达式</li>
<li>结果值<br>  类型名 所指定的类型，或 表达式 的结果类型所占的字节数</li>
</ul>
<p>按位与</p>
<ul>
<li>运算规则<br>  将两个运算量的每一个位进行逻辑与操作</li>
<li>例子<br>  计算 3 &amp; 5<br>  0000 0011<br>  0000 0101<br>  结果0000 0001</li>
<li>用途，将某一位置0，取出某一位</li>
</ul>
<p>按位或</p>
<ul>
<li>运算规则<br>  将两个运算量的每一个位进行逻辑或操作</li>
<li>用途，将某一位置1</li>
</ul>
<p>按位异或</p>
<ul>
<li>运算规则<br>  两个操作数进行异或<br>  若对应位相同，结果为0<br>  若对应位不同，结果为1</li>
<li>计算 071 ^ 052<br>      0011 1001<br>      0010 1010<br>  结果    0001 0011</li>
<li>用途，特定位翻转</li>
</ul>
<p>按位取反</p>
<ul>
<li>运算规则<br>  0 变 1， 1 变 0</li>
</ul>
<p>移位操作</p>
<ul>
<li>左移后，低位补0，高位舍弃</li>
<li>右移后，低位舍弃，高位无符号数补0，有符号为补符号位</li>
</ul>
<h3 id="运算优先级，类型转换"><a href="#运算优先级，类型转换" class="headerlink" title="运算优先级，类型转换"></a>运算优先级，类型转换</h3><p>一些运算符要求数据类型一致<br>隐含转换的基本原则是低类型转换到高类型</p>
<p>浮点数换成整数，小数部分直接丢弃<br>整数换成浮点数，小数为0，可能丢失精度</p>
<p>显示转换</p>
<ul>
<li>类型说明符（表达式）</li>
<li>（类型说明符）表达式</li>
<li>类型转换操作符 &lt;类型说明符&gt; （表达式） C++的转换方式<ul>
<li>类型转换操作符：const_cast,dynamic_cast ,reinterpret_cast,static_cast</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程第一章</title>
    <url>/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0.html</url>
    <content><![CDATA[<h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><h2 id="软件无处不在"><a href="#软件无处不在" class="headerlink" title="软件无处不在"></a>软件无处不在</h2><p><code>软件</code>是软件工程的研究对象，也是软件工程的产品形态与客观存在</p>
<p><code>工程</code>是将理论和知识应用于实践的科学，其目的是经济有效的解决实际问题</p>
<h2 id="软件的本质特性"><a href="#软件的本质特性" class="headerlink" title="软件的本质特性"></a>软件的本质特性</h2><p>软件 &#x3D; 程序 + 数据 + 文档</p>
<ul>
<li>程序：计算机可以接受的一系列指令，运行时可以提供所要求的的功能和性能</li>
<li>数据：使得程序能够适当地操作信息的数据结构</li>
<li>文档：描述程序的研制过程，方法和使用的图文资料</li>
</ul>
<p>软件具有</p>
<ul>
<li>复杂性</li>
<li>一致性</li>
<li>可变性</li>
<li>不可见性</li>
</ul>
<p>上面是软件开发困难的根本原因</p>
<p>一致性</p>
<ul>
<li>软件不能独立存在，需要依附于一定的环境（如硬件，网络以及其他软件）</li>
<li>软件必须遵从人为的惯例并适应已有的技术和系统</li>
<li>软件需要随接口不同而改变，随时间推移而变化，而这些变化是不同人设计的结果</li>
</ul>
<p>可变性</p>
<ul>
<li>软件一直在变化更新</li>
<li>人们总认为软件是容易修改的，但忽视了修改的副作用</li>
<li>不断的修改最终导致软件的退化，从而结束其生命周期</li>
</ul>
<p>不可见性</p>
<ul>
<li>软件是一种<code>看不见</code>摸不着的逻辑实体，不具有空间的形体特征</li>
<li>开发人员可以直接看到程序代码，但是源代码并不是软件本身</li>
<li>软件是以机器代码得形式运行，但是开发人员无法看到源代码是如何执行的</li>
</ul>
<p>软件所具有的复杂性，一致性，可变性，不可见性等特性，使得软件开发过程变得难以控制，开发团队如同在焦油坑中挣扎的巨兽</p>
<h2 id="软件工程的产生与发展"><a href="#软件工程的产生与发展" class="headerlink" title="软件工程的产生与发展"></a>软件工程的产生与发展</h2><p>软件开发面临的挑战</p>
<ul>
<li>客户不满意<ul>
<li>交付的许多功能不是客户需要的</li>
<li>交付的日期没有保障</li>
<li>客户使用时发现许多bug</li>
</ul>
</li>
<li>项目过程失控<ul>
<li>客户需求变化频繁，无力应对</li>
<li>无法预见软件的交付质量</li>
<li>对流程盲目遵从，忽视客户业务价值</li>
</ul>
</li>
<li>风险与成本问题<ul>
<li>开发团队专注技术，忽视风险</li>
<li>无能力预测成本，导致预算超支</li>
</ul>
</li>
<li>无力管理团队 <ul>
<li>无法评估开发人员能力及工作进度</li>
<li>困扰于如何提升团队的能力与效率</li>
</ul>
</li>
</ul>
<p><code>软件工程</code>一直致力于探索软件开发问题的解决之道</p>
<p>1968年，北大西洋公约组织提出<code>软件工程</code>概念和术语</p>
<h2 id="软件工程的基本概念"><a href="#软件工程的基本概念" class="headerlink" title="软件工程的基本概念"></a>软件工程的基本概念</h2><p>软件工程</p>
<ul>
<li>将系统的，规范的，可定量的方法应用与软件的开发，运行和维护，即工程化应用到软件上</li>
<li>对1中所述方法的研究</li>
</ul>
<p>好的软件</p>
<ul>
<li>较低的开发成本</li>
<li>按时完成开发任务并及时交付</li>
<li>实现客户要求的功能</li>
<li>具有良好性能，可靠性，可扩展性，可移植性等</li>
<li>软件维护费用低</li>
</ul>
<p>软件工程的基本要素</p>
<ul>
<li>过程<br>  支持软件开发各个环节的控制和管理</li>
<li>方法<br>  完成软件开发任务的技术手段</li>
<li>工具<br>  为软件开发方法提供自动或半自动的软件支撑环境</li>
</ul>
<p>软件开发的基本策略</p>
<ul>
<li>软件复用</li>
<li>分而治之</li>
<li>逐步演进</li>
<li>优化折中</li>
</ul>
<p>软件工程的wasserman规范</p>
<ul>
<li>抽象</li>
<li>软件建模方法</li>
<li>用户界面原型化</li>
<li>软件体系结构</li>
<li>软件过程</li>
<li>软件复用</li>
<li>度量</li>
<li>工具与集成环境</li>
</ul>
<h2 id="软件质量实现"><a href="#软件质量实现" class="headerlink" title="软件质量实现"></a>软件质量实现</h2><p>什么是好的软件</p>
<ul>
<li>功能质量<ul>
<li>软件符合指定需求</li>
<li>软件几乎没有缺陷</li>
<li>软件性能正常</li>
<li>软件容易上手，操作方便</li>
</ul>
</li>
<li>结构质量<ul>
<li>代码可测试性</li>
<li>可维护性</li>
<li>可读性</li>
<li>代码效率：高效管理资源</li>
<li>代码安全：可预防常见威胁</li>
</ul>
</li>
<li>过程质量<ul>
<li>软件按时交付</li>
<li>软件满足预算</li>
<li>可复用的开发过程，确保交付质量</li>
</ul>
</li>
</ul>
<p>产品质量维度</p>
<ul>
<li>性能</li>
<li>特色</li>
<li>可靠性</li>
<li>符合型</li>
<li>耐久性</li>
<li>可服务性</li>
<li>审美</li>
<li>感知</li>
</ul>
<p>ISO9126质量模型</p>
<ul>
<li>功能性<ul>
<li>适合性：当软件在指定条件下使用，其满足明确和隐含要求功能的能力</li>
<li>准确性：软件提供给用户功能的精确度是否符合目标</li>
<li>互操作性：软件与其他系统进行交互的能力</li>
<li>安全性：软件保护信息和数据的安全能力</li>
</ul>
</li>
<li>可靠性<ul>
<li>成熟性：软件产品避免因软件错误发生而导致失效的能力</li>
<li>容错性：防止外部接口错误扩散而导致系统失效的能力</li>
<li>可恢复性：系统失效后，重新恢复原有的功能和性能的能力</li>
</ul>
</li>
<li>易用性<ul>
<li>易理解性</li>
<li>易学习性</li>
<li>易操作性</li>
<li>吸引性</li>
</ul>
</li>
<li>效率<ul>
<li>时间特性</li>
<li>资源利用</li>
</ul>
</li>
<li>可维护性<ul>
<li>易分析性</li>
<li>易改变性</li>
<li>稳定性</li>
<li>易测试性</li>
</ul>
</li>
<li>可移植性<ul>
<li>适应性</li>
<li>易安装性</li>
<li>共存性</li>
<li>替换性</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统原理第二节</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E8%8A%82.html</url>
    <content><![CDATA[<h1 id="数据库系统原理第二节"><a href="#数据库系统原理第二节" class="headerlink" title="数据库系统原理第二节"></a>数据库系统原理第二节</h1><h2 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h2><h3 id="客户服务器结构"><a href="#客户服务器结构" class="headerlink" title="客户服务器结构"></a>客户服务器结构</h3><p>客户端，前台或<code>表示层</code>主要完成与数据库使用者的交互任务</p>
<p>服务器，后台或<code>数据层</code>主要负责数据管理</p>
<p>单机方式<br>网络方式</p>
<h3 id="浏览器服务器结构"><a href="#浏览器服务器结构" class="headerlink" title="浏览器服务器结构"></a>浏览器服务器结构</h3><p>一种基于Web应用的客户&#x2F;服务器结构，也称为<code>三层</code>客户&#x2F;服务器结构</p>
<p>三层</p>
<ul>
<li>表示层</li>
<li>处理层（中间层）</li>
<li>数据层</li>
</ul>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p><code>模型</code>是现实世界特征的模拟和抽象表达</p>
<p><code>数据模型</code>是对现实世界数据特征的抽象，描述的是数据的<code>共性内容</code></p>
<h4 id="数据的特征"><a href="#数据的特征" class="headerlink" title="数据的特征"></a>数据的特征</h4><p>静态特征</p>
<ul>
<li>数据的基本结构</li>
<li>数据间的联系</li>
<li>数据取值范围的约束</li>
</ul>
<p>动态特征</p>
<ul>
<li>指对数据可以进行符合一定规则的操作</li>
</ul>
<h4 id="数据模型组成要素"><a href="#数据模型组成要素" class="headerlink" title="数据模型组成要素"></a>数据模型组成要素</h4><p><code>数据结构</code>描述的是系统的<code>静态特征</code>,即数据对象的<code>数据类型</code>，<code>内容</code>,<code>属性</code>以及数据对象之间的<code>联系</code></p>
<p><code>数据操作</code>描述的是系统的<code>动态特征</code></p>
<p><code>数据约束</code>描述数据结构中数据间的<code>语法和语义关联</code></p>
<h4 id="数据模型的分类"><a href="#数据模型的分类" class="headerlink" title="数据模型的分类"></a>数据模型的分类</h4><p><code>数据模型</code>是模型化数据和信息的工具，也是数据库系统的<code>核心和基础</code></p>
<p>满足三点：</p>
<ul>
<li>比较真实地模拟现实世界</li>
<li>容易为人们理解</li>
<li>便于在计算机上实现</li>
</ul>
<h4 id="概念层数据模型"><a href="#概念层数据模型" class="headerlink" title="概念层数据模型"></a>概念层数据模型</h4><p><code>概念层</code>是数据抽象级别的最高层。概念层数据模型，也称为数据的<code>概念模型</code>或<code>信息模型</code>，这类模型主要用于数据库的设计阶段</p>
<h4 id="信息世界涉及的基本概念"><a href="#信息世界涉及的基本概念" class="headerlink" title="信息世界涉及的基本概念"></a>信息世界涉及的基本概念</h4><p>实体<br>属性<br>码或键<br>域<br>实体型<br>实体集<br>联系</p>
<p>数据模型中有<code>型</code>和<code>值</code>两个概念</p>
<p>型 是表头，字段名称<br>值 是内容，字段值</p>
<h4 id="逻辑层数据模型"><a href="#逻辑层数据模型" class="headerlink" title="逻辑层数据模型"></a>逻辑层数据模型</h4><p>逻辑层是数据抽象级别的<code>中间层</code>，逻辑层数据模型，也称为数据的<code>逻辑模型</code>。任何DBMS都是基于某种逻辑数据模型。</p>
<h5 id="逻辑模型的类型"><a href="#逻辑模型的类型" class="headerlink" title="逻辑模型的类型"></a>逻辑模型的类型</h5><p>层次模型</p>
<ul>
<li>是<code>最早</code>使用的一种数据模型</li>
<li>有且仅有一个结点没有父结点，称作<code>根结点</code></li>
<li>其他结点有且仅有一个父结点</li>
</ul>
<p>网状模型</p>
<ul>
<li>以网状结构表示实体与实体间的联系</li>
<li>允许结点有多与一个父结点</li>
<li>可以有一个以上的结点没有父结点</li>
</ul>
<p>关系模型</p>
<ul>
<li>用<code>二维表结构</code>来表示实体间的联系</li>
<li>建立在严格的<code>数学概念</code>的基础上，概念单一</li>
<li>存取路径对用户透明，有更高的数据独立性，更好的安全保密性</li>
</ul>
<p>面向对象模型 &#x3D; 面向对象方法 &amp; 数据库</p>
<ul>
<li>既是<code>概念模型</code>又是<code>逻辑模型</code></li>
<li>表达能力丰富，对象可复用，维护方便</li>
</ul>
<h4 id="物理层数据模型"><a href="#物理层数据模型" class="headerlink" title="物理层数据模型"></a>物理层数据模型</h4><p>物理模型</p>
<p>最底层的抽象</p>
<p>设计目标是<code>提高数据库性能</code>和<code>有效利用存储空间</code></p>
<h4 id="简述概念模型，逻辑模型，物理模型之间的关系"><a href="#简述概念模型，逻辑模型，物理模型之间的关系" class="headerlink" title="简述概念模型，逻辑模型，物理模型之间的关系"></a>简述概念模型，逻辑模型，物理模型之间的关系</h4><p>这三个不同的数据模型之间既相互独立，又存在着关联。从现实世界到概念模型的转换是由数据库设计人员完成的。<br>从概念模型到逻辑模型的转换可以由数据库设计人员完成，也可以用数据库设计工具协助设计人员完成；<br>从逻辑模型到物理模型的转换主要用数据库管理系统完成。</p>
<h2 id="关系数据库-1"><a href="#关系数据库-1" class="headerlink" title="关系数据库"></a>关系数据库</h2><h3 id="关系数据库概述"><a href="#关系数据库概述" class="headerlink" title="关系数据库概述"></a>关系数据库概述</h3><h4 id="关系数据库的历史"><a href="#关系数据库的历史" class="headerlink" title="关系数据库的历史"></a>关系数据库的历史</h4><p>1970 提出了关系模型<br>20世纪70年代末 重大突破<br>1981年 证实了关系数据库的优点：高级的非过程语言接口，较好的数据独立性<br>20世纪80年代后 网状模型和层次模型与底层实现的紧密结合，关系模型具有坚实理论基础，成为主流数据模型</p>
<h4 id="关系数据模型的组成要素"><a href="#关系数据模型的组成要素" class="headerlink" title="关系数据模型的组成要素"></a>关系数据模型的组成要素</h4><p>关系数据结构<br>关系操作集合<br>关系完整性约束</p>
<h4 id="关系数据结构"><a href="#关系数据结构" class="headerlink" title="关系数据结构"></a>关系数据结构</h4><p>关系的三种类型</p>
<p>实际存在的表</p>
<p>基本关系（基本表，基表）<br>查询表<br>视图表 导出的虚表</p>
<h3 id="关系数据模型"><a href="#关系数据模型" class="headerlink" title="关系数据模型"></a>关系数据模型</h3><p>列 也称为 字段 或 属性</p>
<p>属性  &#x3D; 列</p>
<p>8元 &#x3D; 8度 &#x3D; 8列</p>
<p>分量 &#x3D; 具体的数据项<br>元组（行）中的一个属性值，称为分量</p>
]]></content>
      <categories>
        <category>数据库系统原理</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>C++程序设计第一章</title>
    <url>/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%80%E7%AB%A0.html</url>
    <content><![CDATA[<h1 id="C-程序设计第一章"><a href="#C-程序设计第一章" class="headerlink" title="C++程序设计第一章"></a>C++程序设计第一章</h1><h2 id="计算机语言"><a href="#计算机语言" class="headerlink" title="计算机语言"></a>计算机语言</h2><p>程序员与计算机沟通的语言<br>描述解决问题的方法和相关数据</p>
<h3 id="计算机语言的级别"><a href="#计算机语言的级别" class="headerlink" title="计算机语言的级别"></a>计算机语言的级别</h3><ul>
<li>二进制代码得机器语言</li>
<li>使用助记符的汇编语言</li>
<li>使用类似英语单词和语句的高级语言</li>
</ul>
<p>C++是面向对象的高级语言</p>
<ul>
<li>封装</li>
<li>消息通信</li>
</ul>
<p>C++支持的程序设计方法</p>
<ul>
<li>面向过程的程序设计方法</li>
<li>面向对象的程序设计方法</li>
<li>泛型程序设计方法</li>
</ul>
<p>C++程序的开发过程</p>
<ul>
<li>算法设计</li>
<li>源程序编辑</li>
<li>编译</li>
<li>连接</li>
</ul>
<p>信息在计算机中的表示存储</p>
<ul>
<li>计算机中的数据都是二进制的</li>
<li>逻辑数据，字符数据也用二进制码表示</li>
</ul>
<h2 id="计算机系统简介"><a href="#计算机系统简介" class="headerlink" title="计算机系统简介"></a>计算机系统简介</h2><ul>
<li>输入设备</li>
<li>内存储器</li>
<li>外存储器</li>
<li>CPU</li>
<li>输出设备</li>
</ul>
<p>计算机的工作需要人来指挥</p>
<ul>
<li>计算机解决问题是软件控制的</li>
<li>软件的程序就是操作步骤</li>
<li>程序要使用语言来表达</li>
</ul>
<p>计算机能识别的是机器语言<br>机器语言指令是由0和1编码的<br>例如：<br>    加法指令可能是 0001</p>
<p>计算机指令系统</p>
<ul>
<li>机器硬件能够识别的语言（机器语言）的集合</li>
<li>它是软件和硬件的主要界面</li>
</ul>
<p>计算机软件：</p>
<ul>
<li>应用软件</li>
<li>系统软件 操作系统</li>
<li>中间件 提供系统软件和应用软件之间链接的软件</li>
</ul>
<p>软件 &#x3D; 程序 + 文档</p>
<p>计算机程序</p>
<ul>
<li>指令的序列</li>
<li>描述解决问题的方法和数据</li>
</ul>
<h2 id="计算机语言和程序设计方法的发展"><a href="#计算机语言和程序设计方法的发展" class="headerlink" title="计算机语言和程序设计方法的发展"></a>计算机语言和程序设计方法的发展</h2><p>机器语言</p>
<ul>
<li>由二进制代码构成</li>
<li>计算机硬件可以识别</li>
<li>可以表示简单的操作</li>
<li>例如：<br>  加法，减法，数据移动等等</li>
</ul>
<p>最初的计算机语言–机器语言和人类的自然语言之间存在巨大鸿沟</p>
<p>汇编语言</p>
<ul>
<li>将机器指令映射为一些助记符。如ADD,SUB,MOV等</li>
<li>抽象层次低，需要考虑机器细节</li>
</ul>
<p>高级语言</p>
<ul>
<li>关键字，语句容易理解</li>
<li>有含义的数据命名和算式</li>
<li>抽象层次高，例如 A + B</li>
<li>屏蔽了机器的细节，例如 count &lt;&lt; a + b + c</li>
</ul>
<p>C++语言</p>
<ul>
<li>是高级语言</li>
<li>支持面向对象的观点和方法</li>
<li>将客观事物看做对象</li>
<li>对象间通过消息传送进行沟通</li>
<li>支持分类和抽象</li>
</ul>
<h3 id="程序设计方法和发展历程"><a href="#程序设计方法和发展历程" class="headerlink" title="程序设计方法和发展历程"></a>程序设计方法和发展历程</h3><p>面向过程的程序设计方法</p>
<ul>
<li>机器语言，汇编语言，高级语言都支持</li>
<li>最初的目的，用于数学计算</li>
<li>主要工作，设计求解问题的过程</li>
</ul>
<p>大型复杂的软件，难以用面向过程的方式编写</p>
<p>面向对象的程序设计方法</p>
<ul>
<li>面向对象的高级语言支持</li>
<li>一个系统有对象构成</li>
<li>对象与对象之间通过消息通信</li>
</ul>
<h2 id="面向对象的基本概念"><a href="#面向对象的基本概念" class="headerlink" title="面向对象的基本概念"></a>面向对象的基本概念</h2><p>对象（Object）</p>
<ul>
<li>一般意义上的对象：<br>  是现实世界中一个实际存在的事物</li>
<li>面向对象方法中的对象：<br>  是系统中用来描述客观事物的一个实体</li>
</ul>
<p>抽象与分类</p>
<ul>
<li>分类所依据的原则–抽象</li>
<li>抽象出同一类对象的共同属性和行为，形成类</li>
</ul>
<p>类与对象的关系</p>
<ul>
<li>类型与实例的关系</li>
</ul>
<p>封装</p>
<ul>
<li>隐蔽对象的内部细节</li>
<li>对外形成一个边界</li>
<li>只保留有限的对外接口</li>
<li>使用方便，安全性好</li>
</ul>
<p>继承</p>
<ul>
<li>软件复用</li>
<li>改造，扩展已有类行成新的类</li>
</ul>
<p>多态</p>
<ul>
<li>同样的消息作用在不同对象上有可能引起不同的行为</li>
</ul>
<h2 id="程序的开发过程"><a href="#程序的开发过程" class="headerlink" title="程序的开发过程"></a>程序的开发过程</h2><p>高级语言 要翻译成 机器语言</p>
<p>源程序</p>
<ul>
<li>用源语言写的，有待翻译的程序</li>
</ul>
<p>目标程序</p>
<ul>
<li>源程序通过翻译加工以后生成的机器语言程序</li>
</ul>
<p>可执行程序</p>
<ul>
<li>连接目标程序以及库中的某些文件，生成的可执行程序</li>
</ul>
<p>三种不同类型的翻译程序</p>
<ul>
<li>汇编程序<br>  将汇编语言源程序翻译成目标程序</li>
<li>编译程序<br>  将高级语言源程序翻译成目标程序</li>
<li>解释程序<br>  将高级语言源程序翻译成机器指令，是边翻译边执行</li>
</ul>
<p>JAVA语言是半编译半解释的，目的是为了跨平台</p>
<p>C++程序是直接编译成本地机器语言代码</p>
<p>C++程序开发过程</p>
<ul>
<li>算法与数据结构设计</li>
<li>源程序编辑</li>
<li>编译<br>  先做语法检查<br>  编译</li>
<li>连接</li>
<li>测试</li>
<li>调试</li>
</ul>
<h2 id="信息的表示和存储"><a href="#信息的表示和存储" class="headerlink" title="信息的表示和存储"></a>信息的表示和存储</h2><h3 id="计算机中的信息与存储单位"><a href="#计算机中的信息与存储单位" class="headerlink" title="计算机中的信息与存储单位"></a>计算机中的信息与存储单位</h3><p>计算机中的基本功能</p>
<ul>
<li>算术运算</li>
<li>逻辑运算</li>
</ul>
<p>计算机中的信息</p>
<ul>
<li>控制信息<br>  指挥计算机操作</li>
<li>数据信息</li>
</ul>
<p>信息的存储单位</p>
<ul>
<li>位 bit<br>  数据的最小单位</li>
<li>字节 Byte<br>  8位二进制 1Byte &#x3D; 8bit</li>
<li>千字节<br>  1KB &#x3D; 1024B</li>
<li>兆字节<br>  1MB &#x3D; 1024KB</li>
<li>吉字节<br>  1GB &#x3D; 1024MB</li>
</ul>
<h3 id="计算机的数字系统"><a href="#计算机的数字系统" class="headerlink" title="计算机的数字系统"></a>计算机的数字系统</h3><p>数字系统是二进制系统，基本符合0,1</p>
<p>三个二进制 &#x3D; 一个八进制 四个二进制 &#x3D; 一个十六进制</p>
<p>R进制 转 十进制：</p>
<ul>
<li>各位数字与他的权相乘，其积想加</li>
</ul>
<p>例如：<br>11111111.11 &#x3D; 1 * 2<sup>7</sup> + 1 * 2<sup>6</sup> + 1 * 2<sup>5</sup> + 1 * 2<sup>4</sup> + 1 * 2<sup>3</sup> + 1 * 2<sup>2</sup> + 1 * 2<sup>1</sup> + 1 * 2<sup>0</sup> + 1 * 2<sup>-1</sup> + 1 * 2<sup>-2</sup><br>&#x3D; 255.75</p>
<p>十进制 转 R进制：</p>
<ul>
<li>除以R 取余</li>
</ul>
<p>十进制小数 转 R进制小数：</p>
<ul>
<li>乘以R 取整</li>
</ul>
<h3 id="数据的编码表示"><a href="#数据的编码表示" class="headerlink" title="数据的编码表示"></a>数据的编码表示</h3><p>0 表示正数<br>1 表示负数</p>
<p>原码：</p>
<ul>
<li>符号 – 绝对值 表示的编码</li>
<li>缺点<ul>
<li>0的表示不唯一</li>
<li>进行四则运算时，符号位需单独处理且运算规则复杂</li>
</ul>
</li>
</ul>
<p>补码:</p>
<ul>
<li>0的表示唯一</li>
<li>符号位可作为数值参加运算</li>
<li>补码运算结果还是补码</li>
</ul>
<p>模数：<br>n位二进制整数的模数为2的n次方<br>n位小数的模数是2</p>
<p>补数：<br>一个数减去另一个数（加上一个负数）<br>等于第一个数加第二个数的补数</p>
<p>例如：<br>8 + （-2） &#x3D; 8 + 10 （mod 12） &#x3D; 6</p>
<h4 id="补码的计算规则"><a href="#补码的计算规则" class="headerlink" title="补码的计算规则"></a>补码的计算规则</h4><p>反码：作为中间码</p>
<p>反码的计算规则：<br>负整数</p>
<ul>
<li>原码符号位不变（仍是1）</li>
<li>其余各位取反（0 变 1 ， 1 变 0）</li>
</ul>
<p>例如：<br>X &#x3D; -1100110<br>原码 &#x3D; 11100110<br>反码 &#x3D; 10011001</p>
<p>正整数<br>原码就是反码就是补码</p>
<p>补码的计算规则</p>
<ul>
<li>反码作为中间码</li>
<li>负数补码 &#x3D; 反码 + 1</li>
<li>正数补码 &#x3D; 原码 &#x3D; 反码</li>
</ul>
<p>如果负数之和得正数或正数之和为负数说明运算结果溢出</p>
<h4 id="小数的表示"><a href="#小数的表示" class="headerlink" title="小数的表示"></a>小数的表示</h4><h5 id="浮点方案"><a href="#浮点方案" class="headerlink" title="浮点方案"></a>浮点方案</h5><p>N &#x3D; M * 2<sup>E</sup></p>
<p>E:2的幂次，称数N的阶码，反映了该浮点数所表示的数据范围<br>M:N的尾数 位数反映了数据的精度</p>
<h4 id="字符的表示"><a href="#字符的表示" class="headerlink" title="字符的表示"></a>字符的表示</h4><p>字符在计算机中通过编码表示</p>
<ul>
<li>ASCII码：<br>  常用的西文字符编码，7位二进制表示一个字符，最多可表示 2的7次方 &#x3D; 128个字符</li>
<li>汉字编码<br>  中国国家标准</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统原理第一节</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E8%8A%82.html</url>
    <content><![CDATA[<h1 id="数据库系统原理第一节"><a href="#数据库系统原理第一节" class="headerlink" title="数据库系统原理第一节"></a>数据库系统原理第一节</h1><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>什么是数据？</p>
<p><code>数据</code>是描述事物的<code>符号记录</code>，是指利用<code>物理符号</code>记录下来的，可以<code>鉴别的信息</code>。</p>
<p>数据是<code>信息</code>存在的一种形式，只有通过解释或处理的数据才能成为有用的信息。</p>
<p>什么是数据库？</p>
<p><code>数据库</code>是指<code>长期储存</code>在计算机中的<code>有组织</code>的，<code>可共享</code>的数据集合。</p>
<p>数据要按照一定的<code>数据模型组织</code>，<code>描述和存储</code>，具有较小的<code>冗余度</code>，较高的<code>数据独立性</code>，系统易于<code>扩展</code>，并可以被多个用户<code>分享</code>.</p>
<p>数据库的三个特点：</p>
<ul>
<li>永久存储</li>
<li>有组织</li>
<li>可共享</li>
</ul>
<h3 id="数据库管理系统（DBMS）"><a href="#数据库管理系统（DBMS）" class="headerlink" title="数据库管理系统（DBMS）"></a>数据库管理系统（DBMS）</h3><p>数据库管理系统 是专门用于<code>建立</code>和<code>管理</code>数据库的一套软件，介于<code>应用程序</code>和<code>操作系统</code>之间</p>
<p>1.数据定义功能<br>2.数据操纵功能<br>3.数据库的运行管理功能<br>4.数据库的建立和维护功能<br>5.数据组织，存储和管理功能<br>6.其他功能</p>
<h3 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h3><p>组成：</p>
<ul>
<li>用户</li>
<li>数据库管理系统</li>
<li>数据库</li>
<li>数据库管理员</li>
<li>应用程序</li>
</ul>
<h2 id="数据库管理技术的发展"><a href="#数据库管理技术的发展" class="headerlink" title="数据库管理技术的发展"></a>数据库管理技术的发展</h2><ul>
<li>人工管理阶段<ol>
<li>数据不保存</li>
<li>应用程序管理数据</li>
<li>数据面向应用程序</li>
</ol>
</li>
<li>文件系统阶段<br>  把数据变成文件存在磁盘<br>  优点：<code>物理数据独立性</code></li>
<li>数据库系统阶段<ol>
<li><code>数据集成</code>（主要目的）</li>
<li>数据共享性（高）</li>
<li>数据冗余（小）</li>
<li>数据一致性</li>
<li>数据独立性高</li>
<li>实施统一管理与控制</li>
</ol>
</li>
</ul>
<h2 id="数据库系统的结构"><a href="#数据库系统的结构" class="headerlink" title="数据库系统的结构"></a>数据库系统的结构</h2><h3 id="数据库系统结构的分类"><a href="#数据库系统结构的分类" class="headerlink" title="数据库系统结构的分类"></a>数据库系统结构的分类</h3><h4 id="用户视角"><a href="#用户视角" class="headerlink" title="用户视角"></a>用户视角</h4><ul>
<li>CS结构</li>
<li>BS结构</li>
</ul>
<h4 id="DBA视角"><a href="#DBA视角" class="headerlink" title="DBA视角"></a>DBA视角</h4><h5 id="内部系统结构"><a href="#内部系统结构" class="headerlink" title="内部系统结构"></a>内部系统结构</h5><p>采用三级模式</p>
<ul>
<li>模式  也称为<code>概念模式</code>或<code>逻辑模式</code>  <code>概念视图</code>，数据库的<code>核心</code>，数据库设计的<code>关键</code></li>
<li>内模式 <code>存储模式</code>，<code>物理模式</code>  <code>内部视图或存储视图</code></li>
<li>外模式 给应用使用，不是唯一的，也称为<code>子模式</code>或<code>用户模式</code>，<code>数据视图即用户视图</code></li>
</ul>
<h5 id="外部系统结构"><a href="#外部系统结构" class="headerlink" title="外部系统结构"></a>外部系统结构</h5><ul>
<li>集中式结构</li>
<li>分布式结构</li>
<li>并行结构</li>
</ul>
<h3 id="三级模式结构的两层映像与数据独立性"><a href="#三级模式结构的两层映像与数据独立性" class="headerlink" title="三级模式结构的两层映像与数据独立性"></a>三级模式结构的两层映像与数据独立性</h3><p>所谓<code>映像</code>,就是一种<code>对应规则</code>,它指出映像双方是如何进行转换的。</p>
<p><code>模式</code> - <code>内模式</code>映像：保证了数据与程序的<code>物理独立性</code></p>
<p><code>外模式</code> - <code>模式</code>映像：保证了数据与程序的<code>逻辑独立性</code></p>
]]></content>
      <categories>
        <category>数据库系统原理</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库原理</tag>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenResty的安装</title>
    <url>/OpenResty%E7%9A%84%E5%AE%89%E8%A3%85.html</url>
    <content><![CDATA[<h1 id="OpenResty的安装"><a href="#OpenResty的安装" class="headerlink" title="OpenResty的安装"></a>OpenResty的安装</h1><p>wsl 使用的是ubuntu 20的版本，所以可以直接使用<code>apt</code>进行安装，OpenResty官网的安装也是推荐使用的apt进行安装。</p>
<p>添加openresty的公钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y install --no-install-recommends wget gnupg ca-certificates</span><br></pre></td></tr></table></figure>

<p>导入 GPG 秘钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -O - https://openresty.org/package/pubkey.gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>

<p>添加 Openresty 的源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;deb http://openresty.org/package/ubuntu $(lsb_release -sc) main&quot; &gt; openresty.list</span><br><span class="line">sudo cp openresty.list /etc/apt/sources.list.d/</span><br></pre></td></tr></table></figure>

<p>更新apt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p>安装openresty</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y install --no-install-recommends openresty</span><br></pre></td></tr></table></figure>

<p>检查版本确认是否安装成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openresty -V</span><br></pre></td></tr></table></figure>

<p>启动 openresty</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service openresty start</span><br></pre></td></tr></table></figure>

<p>访问 localhost 查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl localhost</span><br></pre></td></tr></table></figure>

<p>安装 resty 命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y install openresty-resty</span><br></pre></td></tr></table></figure>

<p>执行 hello world看看是否安装成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resty -e &#x27;print(&quot;Hello Resty&quot;)&#x27;</span><br></pre></td></tr></table></figure>


<p>安装 resty-doc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y install openresty-restydoc</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OpenResty</category>
      </categories>
      <tags>
        <tag>OpenResty</tag>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenResty的目录介绍和helloworld</title>
    <url>/OpenResty%E7%9A%84%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D%E5%92%8Chelloworld.html</url>
    <content><![CDATA[<h1 id="OpenResty的目录介绍和helloworld"><a href="#OpenResty的目录介绍和helloworld" class="headerlink" title="OpenResty的目录介绍和helloworld"></a>OpenResty的目录介绍和helloworld</h1><h2 id="安装目录介绍"><a href="#安装目录介绍" class="headerlink" title="安装目录介绍"></a>安装目录介绍</h2><p>上文提到是 ubuntu apt 安装的 openresty</p>
<p>可以查看安装目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openresty -V</span><br></pre></td></tr></table></figure>

<p>安装目录是<code>/usr/local/openresty</code></p>
<p>目录：</p>
<ul>
<li>bin 这个目录里面是可执行文件，比如openresty,resty,restydoc这些程序</li>
<li>pod 这个目录存放的是openresty的文档</li>
<li>nginx 存放的就是nginx得相关文件</li>
<li>luajit 存放的luajit的相关文件</li>
<li>lualib 这个目录放的是lua库，主要分为 ngx 和 resty 两个子目录<ul>
<li>ngx 存放 lua-resty-core 这个官方项目中的lua代码，里面都是基于FFI重新实现的 openresty API</li>
<li>resty 存放各种 lua-resty-* 项目包含的lua代码</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>OpenResty</category>
      </categories>
      <tags>
        <tag>OpenResty</tag>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl安装docker</title>
    <url>/wsl%E5%AE%89%E8%A3%85docker.html</url>
    <content><![CDATA[<h1 id="wsl安装docker"><a href="#wsl安装docker" class="headerlink" title="wsl安装docker"></a>wsl安装docker</h1><p>wsl 使用的是ubuntu 20的版本，所以可以直接使用<code>apt</code>进行安装，docker官网的安装也是推荐使用的apt进行安装。</p>
<p>需要先更新apt安装包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p>安装一些依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br></pre></td></tr></table></figure>

<p>添加Docker官方的GPG密钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br></pre></td></tr></table></figure>

<p>添加docker的源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo \</span><br><span class="line">  &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span><br><span class="line">  $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure>

<p>更新apt安装包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p>安装docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<p>安装完成后启动docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service docker start</span><br></pre></td></tr></table></figure>

<p>测试，运行hello world</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>wsl</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch十四--ES-index template</title>
    <url>/ES-index%20template.html</url>
    <content><![CDATA[<h1 id="index-template"><a href="#index-template" class="headerlink" title="index template"></a>index template</h1><h2 id="index-template-1"><a href="#index-template-1" class="headerlink" title="index template"></a>index template</h2><p>index template 可以帮助你设定 Mappings 和 Settins ，并按照一定的规则，自动匹配到新创建的索引上</p>
<ul>
<li>模板仅在一个索引被新创建时，才会产生作用。修改模板不会影响已经创建的索引</li>
<li>可以设定多个索引模板，这些设置会根据一定的规则 合并到一起</li>
<li>可以指定 Order的数值 控制 合并 的过程</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT _template/template_default</span><br><span class="line">&#123;</span><br><span class="line">  &quot;index_patterns&quot;:[&quot;*&quot;],</span><br><span class="line">  &quot;order&quot;: 0,</span><br><span class="line">  &quot;version&quot;: 1,</span><br><span class="line">  &quot;settings&quot;:&#123;</span><br><span class="line">    &quot;number_of_shards&quot;:1,</span><br><span class="line">    &quot;number_of_replicas&quot;:1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="index-templalte-的工作方式"><a href="#index-templalte-的工作方式" class="headerlink" title="index templalte 的工作方式"></a>index templalte 的工作方式</h3><p>当一个新索引被创建</p>
<ul>
<li>应用 ES 的默认 settins 和 mappings</li>
<li>应用 order 数值低的 index template 的 settings mappings</li>
<li>应用 order 数值高的 index template 的 settings mappings</li>
<li>应用 用户 自定义的 settings mappings</li>
</ul>
<h2 id="Dynamic-template"><a href="#Dynamic-template" class="headerlink" title="Dynamic template"></a>Dynamic template</h2><p>根据 ES 识别的数据类型，结合字段名称，来动态设定字段类型</p>
<ul>
<li>所有的字符串类型都设定成 keyword 或者关闭 keyword 字段</li>
<li>is 开头的字段都设置成 boolean</li>
<li>long_ 开头的都设置成 long 类型</li>
</ul>
<h2 id="Aggregation-聚合"><a href="#Aggregation-聚合" class="headerlink" title="Aggregation 聚合"></a>Aggregation 聚合</h2><p>ES 除了搜索以外提供了统计分析的功能</p>
<ul>
<li>实时性高</li>
<li>Hadoop</li>
</ul>
<p>通过聚合可以得到数据的概览，是分析和总结全套的数据，而不是寻找单个文档</p>
<p>高性能，只需要一条语句，就可以从 ES 得到结果</p>
<ul>
<li>无需在客户端自己去实现分析逻辑</li>
</ul>
<p>比如 Kibana 中的可视化报表就是使用 聚合 实现的</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>Bucket Aggregation : 一些满足特定条件的集合，相当于 sql 里面的 group by 分组功能</p>
<p>Metric Aggregatino : 提供数学运算，比如最大值，最小值，平均值 相当于 sql 里面的 count(),max()等函数功能</p>
<p>Pipeline Aggregation: 可以二次聚合</p>
<p>Matrix Aggregation: 支持对多个字段的操作并提供一个结果矩阵</p>
<blockquote>
<p>极客时间 ES 学习笔记</p>
</blockquote>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch十三--ES--自定义Analyzer</title>
    <url>/ES-%E8%87%AA%E5%AE%9A%E4%B9%89Analyzer.html</url>
    <content><![CDATA[<h1 id="自定义Analyzer"><a href="#自定义Analyzer" class="headerlink" title="自定义Analyzer"></a>自定义Analyzer</h1><h2 id="多字段特性"><a href="#多字段特性" class="headerlink" title="多字段特性"></a>多字段特性</h2><p>实现精确匹配</p>
<ul>
<li>增加一个 keyword 字段</li>
</ul>
<p>使用不同的analyzer</p>
<ul>
<li>不同语言</li>
<li>pinyin 字段的搜索</li>
<li>还支持为 搜索 和 索引 指定不同的 analyzer</li>
</ul>
<h3 id="Exact-Values-vs-Full-Text"><a href="#Exact-Values-vs-Full-Text" class="headerlink" title="Exact Values vs Full Text"></a>Exact Values vs Full Text</h3><p>Exact Value 包括数字 &#x2F; 日期 &#x2F; 具体一个字符串（例如 Apple Store）  精确值 不需要分词</p>
<ul>
<li>ES 中的 keyword</li>
</ul>
<p>全文本，非结构化的文本数据  需要分词</p>
<ul>
<li>ES 中的 text</li>
</ul>
<h3 id="自定义分词"><a href="#自定义分词" class="headerlink" title="自定义分词"></a>自定义分词</h3><p>当 ES 自带的分词器无法满足时，可以自定义分词器。通过自己组合不同的组件实现</p>
<ul>
<li><p>Character Filter</p>
</li>
<li><p>Tokenizer</p>
</li>
<li><p>Token Filter</p>
</li>
</ul>
<p>通过自己组合上面不同的组件，可以实现出不同的分词器效果。</p>
<h4 id="Character-Filter"><a href="#Character-Filter" class="headerlink" title="Character Filter"></a>Character Filter</h4><p>在 Tokenizer 之前对文本进行处理。可以配置多个进行不同的文本处理。会影响 Tokenizer 的 position 和 offset 信息</p>
<p>下面是一些自带的 Character Filter</p>
<ul>
<li>HTML strip  去除 html 标签</li>
<li>Mapping  字符串替换</li>
<li>Pattern replace   正则匹配替换</li>
</ul>
<h4 id="Tokenizer"><a href="#Tokenizer" class="headerlink" title="Tokenizer"></a>Tokenizer</h4><p>将原始的文本按照一定的规则，切分为词</p>
<p>下面是一些ES内置的 Tokenizer</p>
<ul>
<li>whitespace</li>
<li>standard</li>
<li>uax_url_email</li>
<li>pattern</li>
<li>keyword</li>
<li>path hierarchy</li>
</ul>
<p>也可以用 JAVA 开发插件，实现自己的 Tokenizer</p>
<h4 id="Token-filter"><a href="#Token-filter" class="headerlink" title="Token filter"></a>Token filter</h4><p>将 Tokenizer 输出的单词 进行增加修改删除等操作</p>
<p>下面是ES 自带的</p>
<ul>
<li>Lowercase 小写</li>
<li>stop 停止词</li>
<li>synonym 近义词</li>
</ul>
<p>这几个操作简单来说就是</p>
<ul>
<li>Character Filter 在分词前进行处理</li>
<li>Tokenizer 分词</li>
<li>Token Filter 分词后进行处理</li>
</ul>
<h4 id="自定义分词器"><a href="#自定义分词器" class="headerlink" title="自定义分词器"></a>自定义分词器</h4><p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT test_home</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;:&#123;</span><br><span class="line">    &quot;analysis&quot;:&#123;</span><br><span class="line">      &quot;analyzer&quot;:&#123;</span><br><span class="line">        my_analyzer:&#123;    //自定义分词器</span><br><span class="line">          &quot;type&quot;:&quot;custom&quot;,</span><br><span class="line">          &quot;char_filter&quot;:[</span><br><span class="line">            &quot;test&quot;    //自定义 character filter</span><br><span class="line">          ],</span><br><span class="line">          &quot;tokenizer&quot;:&quot;test_tokenizer&quot;,  //自定义 tokenizer</span><br><span class="line">          &quot;filter&quot;:[         //token filter</span><br><span class="line">            &quot;lowercase&quot;,</span><br><span class="line">            &quot;english_stop&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;tokenizer&quot;:&#123;         //自定义 tokenizer</span><br><span class="line">          &quot;test_tokenizer&quot;:&#123;</span><br><span class="line">            &quot;type&quot;:&quot;pattern&quot;,</span><br><span class="line">            &quot;pattern&quot;:&quot;[?]&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;char_filter&quot;:&#123;        //自定义 character filter -替换成_</span><br><span class="line">          &quot;test&quot;:&#123;</span><br><span class="line">            &quot;type&quot;:&quot;mapping&quot;,</span><br><span class="line">            &quot;mappings&quot;:[</span><br><span class="line">              &quot;-&quot; =&gt; &quot;_&quot;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;，</span><br><span class="line">        &quot;filter&quot;:&#123;       //设置 停止词</span><br><span class="line">          &quot;english_stop&quot;:&#123;</span><br><span class="line">            &quot;type&quot;:&quot;stop&quot;,</span><br><span class="line">            &quot;stopwords&quot;:&quot;_englsh_&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>极客时间 ES 学习笔记</p>
</blockquote>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch六--ES--Analyzer分词</title>
    <url>/ES-Analyzer%E5%88%86%E8%AF%8D.html</url>
    <content><![CDATA[<h1 id="Analyzer分词"><a href="#Analyzer分词" class="headerlink" title="Analyzer分词"></a>Analyzer分词</h1><h2 id="Analysis-和-Analyzer"><a href="#Analysis-和-Analyzer" class="headerlink" title="Analysis 和 Analyzer"></a>Analysis 和 Analyzer</h2><p>Analysis - 文本分析是把全文本转换成一系列单词（term&#x2F;token）的过程，也叫分词</p>
<p>Analysis 是通过 Analyzer 来实现的</p>
<ul>
<li>可使用 Elasticsearch 内置的分析器，或者按需制定分析器</li>
</ul>
<p>除了在数据写入时转换词条，匹配 Query 语句时候也需要用相同的分析器对查询语句进行分析</p>
<h2 id="Analyzer-的组成"><a href="#Analyzer-的组成" class="headerlink" title="Analyzer 的组成"></a>Analyzer 的组成</h2><p>分词器是专门处理分词的组件，由三部分组成</p>
<ul>
<li>Character Filters (针对原始文本处理，例如去除html)</li>
<li>Tokenizer (按照规则切分为单词)</li>
<li>Token Filter(将切分的单词进行加工，小写，删除 stopwords,增加同义词)</li>
</ul>
<p>例子：</p>
<p>将 <code>Mastering Elasticsearch &amp; Elasticsearch in Action</code> 经过上面的步骤就会产生</p>
<ul>
<li>master</li>
<li>elasticsearch</li>
<li>action</li>
</ul>
<h2 id="ES的内置分词器"><a href="#ES的内置分词器" class="headerlink" title="ES的内置分词器"></a>ES的内置分词器</h2><ul>
<li>Standard Analyzer - 默认分词器，按词切分，小写处理</li>
<li>Simple Analyzer - 按照非字母切分（符号被过滤），小写处理</li>
<li>Stop Analyzer - 小写处理，停用词过滤（the a is）</li>
<li>WhiteSpace Analyzer - 按照空格切分，不转小写</li>
<li>Keyword Analyzer - 不分词，直接将输入当做输出</li>
<li>Patter Analyzer - 正则表达式，默认\W+(非字符分隔)</li>
<li>Language - 提供了30多种常见语言的分词器</li>
<li>Customer Analyzer 自定义分词器</li>
</ul>
<h2 id="使用-analyzer-API"><a href="#使用-analyzer-API" class="headerlink" title="使用 _analyzer API"></a>使用 _analyzer API</h2><p>直接指定 Analyzer 进行测试</p>
<p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">    &quot;analyzer&quot;:&quot;standard&quot;,</span><br><span class="line">    &quot;text&quot;:&quot;Mastering Elasticsearch &amp; Elasticsearch in Action&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;mastering&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 9,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 10,</span><br><span class="line">      &quot;end_offset&quot; : 23,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 25,</span><br><span class="line">      &quot;end_offset&quot; : 38,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;in&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 39,</span><br><span class="line">      &quot;end_offset&quot; : 41,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;action&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 42,</span><br><span class="line">      &quot;end_offset&quot; : 48,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 4</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指定索引的字段进行测试</p>
<p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST test_home/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field&quot;: &quot;job_name&quot;,</span><br><span class="line">  &quot;text&quot;:&quot;Mastering Elasticsearch, Elasticsearch in Action&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;mastering&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 9,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 10,</span><br><span class="line">      &quot;end_offset&quot; : 23,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 25,</span><br><span class="line">      &quot;end_offset&quot; : 38,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;in&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 39,</span><br><span class="line">      &quot;end_offset&quot; : 41,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;action&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 42,</span><br><span class="line">      &quot;end_offset&quot; : 48,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 4</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义分词进行测试</p>
<p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;filter&quot;: [&quot;lowercase&quot;],</span><br><span class="line">  &quot;text&quot;:&quot;Mastering Elasticsearch, Elasticsearch in Action&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;mastering&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 9,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 10,</span><br><span class="line">      &quot;end_offset&quot; : 23,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 25,</span><br><span class="line">      &quot;end_offset&quot; : 38,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;in&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 39,</span><br><span class="line">      &quot;end_offset&quot; : 41,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;action&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 42,</span><br><span class="line">      &quot;end_offset&quot; : 48,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 4</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中文分词的难点"><a href="#中文分词的难点" class="headerlink" title="中文分词的难点"></a>中文分词的难点</h2><p>中文句子，切分成一个个词（不是一个个字）</p>
<p>英文字，单词有自然地空格进行切分</p>
<p>一句中文，在不同的上下文，有不同的理解</p>
<p>推荐的一些中文分词器：</p>
<ul>
<li>icu</li>
<li>ik : <a href="https://github.com/medcl/elasticsearch-analysis-ik">https://github.com/medcl/elasticsearch-analysis-ik</a></li>
<li>thulac : <a href="https://github.com/microbun/elasticsearch-thulac-plugin">https://github.com/microbun/elasticsearch-thulac-plugin</a></li>
</ul>
<blockquote>
<p>极客时间 ES 学习笔记</p>
</blockquote>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch十一--Dynamic Mapping和常见字段类型</title>
    <url>/ES-Dynamic%20Mapping.html</url>
    <content><![CDATA[<h1 id="Dynamic-Mapping和常见字段类型"><a href="#Dynamic-Mapping和常见字段类型" class="headerlink" title="Dynamic Mapping和常见字段类型"></a>Dynamic Mapping和常见字段类型</h1><h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><p>Mapping 类似数据库中的 <code>schema</code>的定义，作用如下：</p>
<ul>
<li>定义索引中的字段的名称</li>
<li>定义字段的数据类型，例如字符串，数字，布尔等</li>
<li>字段，倒排索引的相关配置</li>
</ul>
<p>Mapping 会把 JSON 文档映射成 Lucene 所需要的扁平格式</p>
<p>一个Mapping 属于一个索引的 Type</p>
<ul>
<li>每个文档都属于一个Type</li>
<li>一个 Type 有一个 Mapping 定义</li>
<li>7.0开始，不需要在 Mapping 定义中指定 Type信息</li>
</ul>
<h3 id="字段的数据类型"><a href="#字段的数据类型" class="headerlink" title="字段的数据类型"></a>字段的数据类型</h3><h5 id="简单类型"><a href="#简单类型" class="headerlink" title="简单类型"></a>简单类型</h5><ul>
<li>Text&#x2F;Keyword</li>
<li>Date</li>
<li>Interger&#x2F;Floating</li>
<li>Boolean</li>
<li>IPv4 &amp; IPv6</li>
</ul>
<h5 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h5><ul>
<li>对象类型</li>
<li>嵌套类型</li>
</ul>
<h5 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h5><p>geo 是用于存储地理位置信息的类型</p>
<ul>
<li>geo_point &amp; geo_shape&#x2F; percolator</li>
</ul>
<h3 id="Dynamic-Mapping"><a href="#Dynamic-Mapping" class="headerlink" title="Dynamic Mapping"></a>Dynamic Mapping</h3><p>这个就是动态的Mapping，可以不需要手动指定，由 ES 动态识别数据类型，来生成对应的Mapping。</p>
<p>但是这样生成的 Mappping 不一定正确。</p>
<p>如果想要修改Mapping</p>
<ul>
<li>新增加字段<ul>
<li>Dynamic 设为 true,一旦有新字段，Mapping会自动更新</li>
<li>Dynamic 设为 false,一旦有新字段，Mapping不会更新，新增加的字段无法被索引，但是_source里面有数据</li>
<li>Dynamic 设为 Strict,文档写入失败</li>
</ul>
</li>
<li>已有字段，一旦已经有数据就不支持修改了<ul>
<li>Lucene实现的倒排索引，一旦生成就不能修改</li>
</ul>
</li>
<li>如果想要修改，需要Reindex API ，重建索引</li>
</ul>
<p>原因：</p>
<ul>
<li>如果修改了字段的数据类型，会导致已被索引的数据无法被搜索</li>
<li>但是如果是增加新的字段，就不会有这种情况</li>
</ul>
<p>注意!!!：<br>如果<code>Dynamic</code>设为false,那么新增字段无法被索引，也就意味着不能拿这个字段去搜索，比如新增加一个<code>name</code>字段，那么无法搜索<code>name</code>这个字段，比如你想搜索name是张三的，是搜索不出来的。</p>
<blockquote>
<p>极客时间 ES 学习笔记</p>
</blockquote>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch九--RequestBody和Query DSL简介</title>
    <url>/ES-RequestBody%E5%92%8CQuery%20DSL%E7%AE%80%E4%BB%8B.html</url>
    <content><![CDATA[<h1 id="RequestBody和Query-DSL简介"><a href="#RequestBody和Query-DSL简介" class="headerlink" title="RequestBody和Query DSL简介"></a>RequestBody和Query DSL简介</h1><p>通过RequestBody 实现搜索</p>
<p>参数：</p>
<ul>
<li>q:指定查询语句，使用Query String Syntax</li>
<li>df:默认字段，不指定会对所有字段进行查询</li>
<li>sort:排序</li>
<li>from&#x2F;size: 用来分页</li>
<li>Profile 可以查看查询是如何被执行的</li>
</ul>
<p>这个方法的参数和URI是一样的，比如我们在kibana里面执行下面的指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET test_home/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;from&quot;:0,</span><br><span class="line">  &quot;size&quot;:10,</span><br><span class="line">  &quot;sort&quot;:[&#123;&quot;id&quot;:&quot;desc&quot;&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查询指定字段"><a href="#查询指定字段" class="headerlink" title="查询指定字段"></a>查询指定字段</h2><p>这种方式还可以查询指定字段，通过<code>_source</code>参数来指定。支持通配符</p>
<p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET test_home/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;match_all&quot;:&#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_source&quot;:[&#x27;job_name&#x27;,&#x27;id&#x27;] //指定字段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="脚本字段"><a href="#脚本字段" class="headerlink" title="脚本字段"></a>脚本字段</h2><p>可以进行一些简单运算，拼接字符串等操作</p>
<p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET test_home/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;match_all&quot;:&#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;script_fields&quot;:&#123;</span><br><span class="line">    &quot;new_field&quot;:&#123;</span><br><span class="line">      &quot;script&quot;:&#123;</span><br><span class="line">        &quot;lang&quot;:&quot;painless&quot; //使用这个脚本</span><br><span class="line">        &quot;source&quot;: &quot;doc[&#x27;job_name&#x27;].value+&#x27;_hello&#x27;&quot; //在职位名称后面拼接_hello</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;fields&quot;:&#123;</span><br><span class="line">  &quot;new_fields&quot;:[</span><br><span class="line">    &quot;产品_hello&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="query-DSL"><a href="#query-DSL" class="headerlink" title="query DSL"></a>query DSL</h2><p>通过DSL查询产品怎么办呢，可以使用query参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET test_home/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;match&quot;:&#123;   //使用match 而不是 match_all</span><br><span class="line">      &quot;job_name&quot;:&quot;产品&quot;  //这里就相当于出现产 或者 品 都会搜出来 左边的 job_name 就是搜索的字段</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_source&quot;:[&#x27;job_name&#x27;,&#x27;id&#x27;] //指定字段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想使用<code>AND</code>可以增加参数，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET test_home/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;match&quot;:&#123;   //使用match 而不是 match_all</span><br><span class="line">      &quot;job_name&quot;: &#123;  //这里变成一个对象 左边的 job_name 就是搜索的字段</span><br><span class="line">        &quot;query&quot;:&quot;产品&quot;, //这里是搜索内容</span><br><span class="line">        &quot;operator&quot;:&quot;AND&quot;  //这里指定AND OR NOT</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_source&quot;:[&#x27;job_name&#x27;,&#x27;id&#x27;] //指定字段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="短语搜索-match-phrase"><a href="#短语搜索-match-phrase" class="headerlink" title="短语搜索 match phrase"></a>短语搜索 match phrase</h3><p>这里就是短语，单词搜索，等价于URI的phrase search</p>
<p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET test_home/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;match_phrase&quot;:&#123;   //使用match_phrase</span><br><span class="line">      &quot;job_name&quot;: &#123;  //这里变成一个对象 左边的 job_name 就是搜索的字段</span><br><span class="line">        &quot;query&quot;:&quot;产品&quot;, //这里是搜索内容</span><br><span class="line">        &quot;slop&quot;:1, //代表可以有一个错误</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_source&quot;:[&#x27;job_name&#x27;,&#x27;id&#x27;] //指定字段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>极客时间 ES 学习笔记</p>
</blockquote>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch七--ES--Search API</title>
    <url>/ES-Search%20API.html</url>
    <content><![CDATA[<h1 id="Search-API"><a href="#Search-API" class="headerlink" title="Search API"></a>Search API</h1><h2 id="两种方法"><a href="#两种方法" class="headerlink" title="两种方法"></a>两种方法</h2><p>URI Search</p>
<ul>
<li>通过Url参数来进行查询</li>
</ul>
<p>url指定参数q&#x3D;field:搜索内容</p>
<p>例子：<br><a href="http://localhost:9200/%7Bindex%7D/_search?q=%7Bfield%7D:%E6%90%9C%E7%B4%A2%E5%86%85%E5%AE%B9">http://localhost:9200/{index}/_search?q={field}:搜索内容</a></p>
<p>url:<br><a href="http://localhost:9200/test_home/_search?q=job_name:php">http://localhost:9200/test_home/_search?q=job_name:php</a></p>
<p>Request Body Search</p>
<ul>
<li>通过ES提供的JSON格式的DSL语句进行查询</li>
</ul>
<table>
<thead>
<tr>
<th align="left">语法</th>
<th align="left">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x2F;_search</td>
<td align="left">集群上所有索引</td>
</tr>
<tr>
<td align="left">&#x2F;{index}&#x2F;_search</td>
<td align="left">对应index上的数据</td>
</tr>
<tr>
<td align="left">&#x2F;{index},{index}&#x2F;_search</td>
<td align="left">对应多个index上的数据</td>
</tr>
<tr>
<td align="left">&#x2F;test*&#x2F;_search</td>
<td align="left">所有test开头的index上的数据</td>
</tr>
</tbody></table>
<p>支持GET POST两种方式</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET/POST test_home/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="搜索返回的结果"><a href="#搜索返回的结果" class="headerlink" title="搜索返回的结果"></a>搜索返回的结果</h2><ul>
<li>took: 查询花的时间</li>
<li>hits-total: 符合条件的总文档数</li>
<li>hints: 结果集</li>
<li>_score: 相关度评分</li>
</ul>
<h3 id="相关度"><a href="#相关度" class="headerlink" title="相关度"></a>相关度</h3><p>Infomation Retrieval</p>
<ul>
<li>Precision(查准率) - 尽可能返回较少的无关文档</li>
<li>Recall (查全率) - 尽量返回较多的相关文档</li>
<li>Ranking - 是否能按相关度进行排序</li>
</ul>
<blockquote>
<p>极客时间 ES 学习笔记</p>
</blockquote>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch八--ES--URI Search 详解</title>
    <url>/ES-URI%20Search%20%E8%AF%A6%E8%A7%A3.html</url>
    <content><![CDATA[<h1 id="URI-Search"><a href="#URI-Search" class="headerlink" title="URI Search"></a>URI Search</h1><p>通过URI query 实现搜索</p>
<p>参数：</p>
<ul>
<li>q:指定查询语句，使用Query String Syntax</li>
<li>df:默认字段，不指定会对所有字段进行查询</li>
<li>sort:排序</li>
<li>from&#x2F;size: 用来分页</li>
<li>Profile 可以查看查询是如何被执行的</li>
</ul>
<h2 id="Query-String-Syntax"><a href="#Query-String-Syntax" class="headerlink" title="Query String Syntax"></a>Query String Syntax</h2><p>指定字段和泛查询</p>
<h3 id="泛查询"><a href="#泛查询" class="headerlink" title="泛查询"></a>泛查询</h3><p>q参数后面只跟着查询内容会对所有字段进行搜索，可以看到返回值里面<code>profile</code>-<code>query</code>-<code>type</code>是 <code>DisjunctionMaxQuery</code>。 <code>description</code>是<code>(customer_name.keyword:产品 | (job_name:产 job_name:品) | job_name.keyword:产品 | (customer_name:产 customer_name:品) | MatchNoDocsQuery(&quot;failed [id] query, caused by number_format_exception:[For input string: &quot;产品&quot;]&quot;) | (city_names:产 city_names:品) | city_names.keyword:产品)</code></p>
<p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET test_home/_search?q=产品</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指定字段"><a href="#指定字段" class="headerlink" title="指定字段"></a>指定字段</h3><p>指定字段有两种方式，一种是df参数</p>
<p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET test_home/_search?q=产品&amp;df=job_name</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种是q参数使用冒号<code>：</code>来分隔</p>
<p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET test_home/_search?q=job_name:产品</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指定字段的返回参数可以看到<code>type</code>是<code>BooleanQuery</code>,<code>description</code>是<code>job_name:产 job_name:品</code></p>
<h2 id="term-query-amp-PhraseQuery"><a href="#term-query-amp-PhraseQuery" class="headerlink" title="term query &amp; PhraseQuery"></a>term query &amp; PhraseQuery</h2><p>term query 是 or的关系，比如上面搜索产品，只要包含<code>产</code>或者<code>品</code>就都会搜索出来，可以用()小括号把搜索内容括起来</p>
<p>phrase query 是 and 的关系，需要再搜索内容上加双引号。这样只会搜索出<code>产品</code>的结果。</p>
<p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET test_home/_search?q=job_name:&quot;产品&quot;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="boolean-query"><a href="#boolean-query" class="headerlink" title="boolean query"></a>boolean query</h2><p>boolean query可以用<code>AND</code>,<code>OR</code>,<code>NOT</code>来操作<br>比如既要<code>产</code>又要<code>品</code><br>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET test_home/_search?q=job_name:(产 AND 品)</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如只有一个就行<br>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET test_home/_search?q=job_name:(产 OR 品)</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如只有品没有产</p>
<p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET test_home/_search?q=job_name:(品 NOT 产)</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h2><p>区间表示  []闭区间 {}开区间</p>
<ul>
<li>year:[2019 TO 2.18]</li>
</ul>
<h2 id="算术符号"><a href="#算术符号" class="headerlink" title="算术符号"></a>算术符号</h2><p>可以使用<code>&gt;</code>,<code>&lt;</code>,<code>=</code>等数学符号</p>
<h2 id="通配符查询"><a href="#通配符查询" class="headerlink" title="通配符查询"></a>通配符查询</h2><p>通配符查询效率低，占用内存大，不建议使用。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>可以用正则进行匹配搜索查询</p>
<ul>
<li>job_name:[bt]oy</li>
</ul>
<h2 id="模糊匹配与近似查询"><a href="#模糊匹配与近似查询" class="headerlink" title="模糊匹配与近似查询"></a>模糊匹配与近似查询</h2><p>模糊查询允许用户输错<code>查询关键字</code></p>
<p>比如上面的查询<code>产品</code>，用户打错了，输成了<code>品阶</code>。我们通过模糊匹配依旧可以查询出来内容.就是通过在查询内容后面输入<code>~1</code>代表允许1个字的错误</p>
<p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET test_home/_search?q=job_name:品阶~1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>极客时间 ES 学习笔记</p>
</blockquote>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch十--ES--query string和simple query string</title>
    <url>/ES-queryString.html</url>
    <content><![CDATA[<h1 id="query-string和simple-query-string"><a href="#query-string和simple-query-string" class="headerlink" title="query string和simple query string"></a>query string和simple query string</h1><h2 id="query-string"><a href="#query-string" class="headerlink" title="query string"></a>query string</h2><p>类似URI query</p>
<p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST users/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;query_string&quot;:&#123;</span><br><span class="line">      &quot;default_field&quot;:&quot;job_name&quot;,  //相当于URI的 df</span><br><span class="line">      &quot;query&quot;:&quot;产品&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以搜索多个字段</p>
<p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST users/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;query_string&quot;:&#123;</span><br><span class="line">      &quot;query&quot;:&quot;产品&quot;,</span><br><span class="line">      &quot;fields&quot;:[&#x27;job_name&#x27;] //搜索job_name是产品的</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以直接在query里面使用<code>AND</code>,<code>OR</code>,<code>NOT</code>的操作符</p>
<p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST users/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;query_string&quot;:&#123;</span><br><span class="line">      &quot;query&quot;:&quot;产 OR 品&quot;,</span><br><span class="line">      &quot;fields&quot;:[&#x27;job_name&#x27;] //搜索job_name是产品的</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="simple-query-string"><a href="#simple-query-string" class="headerlink" title="simple query string"></a>simple query string</h2><p>类似 <code>query string</code> ，但是会忽略错误的语法，同时只支持部分查询语法</p>
<ul>
<li>不支持AND OR NOT ，会当做字符处理</li>
<li>Term 之间默认的关系是OR，可以指定 <code>operator</code></li>
<li>支持 部分逻辑<ul>
<li>+代替AND</li>
<li>|代替OR</li>
<li>-代替NOT</li>
</ul>
</li>
</ul>
<p>这里如果使用了<code>+</code>或者<code>AND</code>还有<code>OR</code>，那么会使用<code>AND</code>，而<code>OR</code>不生效。</p>
<p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST users/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;query_string&quot;:&#123;</span><br><span class="line">      &quot;query&quot;:&quot;产-品&quot;, //这里-代表OR</span><br><span class="line">      &quot;fields&quot;:[&#x27;job_name&#x27;] //搜索job_name是产品的</span><br><span class="line">      &quot;default_operator&quot;: &quot;OR&quot;  //指定默认操作符</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<blockquote>
<p>极客时间 ES 学习笔记</p>
</blockquote>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch五--ES--倒排索引</title>
    <url>/ES-%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95.html</url>
    <content><![CDATA[<h1 id="正排索引和倒排索引"><a href="#正排索引和倒排索引" class="headerlink" title="正排索引和倒排索引"></a>正排索引和倒排索引</h1><h2 id="正排索引"><a href="#正排索引" class="headerlink" title="正排索引"></a>正排索引</h2><p>正排索引就是通过索引id找到内容，比如通过书本的目录找到内容。</p>
<h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>倒排索引就是把正排索引倒过来，通过内容找到索引id.</p>
<h3 id="建立一个倒排索引"><a href="#建立一个倒排索引" class="headerlink" title="建立一个倒排索引"></a>建立一个倒排索引</h3><table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">php java go</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">php es</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">php 开发</td>
</tr>
</tbody></table>
<p>把上面的内容可以建立成下面的倒排索引</p>
<table>
<thead>
<tr>
<th align="left">内容</th>
<th align="left">Count</th>
<th align="left">id</th>
</tr>
</thead>
<tbody><tr>
<td align="left">php</td>
<td align="left">3</td>
<td align="left">1:0,2:0,3:0</td>
</tr>
<tr>
<td align="left">java</td>
<td align="left">1</td>
<td align="left">1:1</td>
</tr>
<tr>
<td align="left">go</td>
<td align="left">1</td>
<td align="left">1:2</td>
</tr>
<tr>
<td align="left">es</td>
<td align="left">1</td>
<td align="left">2:1</td>
</tr>
<tr>
<td align="left">开发</td>
<td align="left">1</td>
<td align="left">3:1</td>
</tr>
</tbody></table>
<h3 id="倒排索引的核心组成"><a href="#倒排索引的核心组成" class="headerlink" title="倒排索引的核心组成"></a>倒排索引的核心组成</h3><p><code>单词词典</code> 记录所有文档的单词 记录单词到倒排列表的关联关系。<br>单词词典一般比较大，可以通过B+树或hash拉链法实现，以满足高性能的插入和查询</p>
<p><code>倒排列表</code>记录了单词对应的文档结合，由倒排索引项组成</p>
<p><code>倒排索引项</code></p>
<ul>
<li>文档id</li>
<li>词频 该单词在文档中出现的次数，用于相关性评分</li>
<li>位置 单词在文档中分词的位置。用于语句搜索</li>
<li>偏移 记录单词的开始结束位置，实现高亮显示</li>
</ul>
<h2 id="ES中的倒排索引"><a href="#ES中的倒排索引" class="headerlink" title="ES中的倒排索引"></a>ES中的倒排索引</h2><p>ES的JSON文档中的每个字段，都有自己的倒排索引<br>可以指定对某些字段不做索引</p>
<ul>
<li>优点：节省存储空间</li>
<li>缺点：字段无法被搜索</li>
</ul>
<blockquote>
<p>极客时间 ES 学习笔记</p>
</blockquote>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch十二--ES--显式mapping</title>
    <url>/ES-%E6%98%BE%E5%BC%8Fmapping.html</url>
    <content><![CDATA[<h1 id="显式mapping"><a href="#显式mapping" class="headerlink" title="显式mapping"></a>显式mapping</h1><h2 id="设置mapping"><a href="#设置mapping" class="headerlink" title="设置mapping"></a>设置mapping</h2><p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT &#123;index&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;:&#123;</span><br><span class="line">    &quot;properties&quot;:&#123;                 //设置mapping</span><br><span class="line">      &quot;job_name&quot;:&#123;</span><br><span class="line">        &quot;type&quot;:&quot;text&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;                                 </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义Mapping"><a href="#自定义Mapping" class="headerlink" title="自定义Mapping"></a>自定义Mapping</h2><p>可以参考 API 手册，纯手写</p>
<p>也可以复制现有的动态Mapping：</p>
<ul>
<li>创建一个临时的index,写入一些样本数据</li>
<li>通过访问 Mapping API 获得该临时文件的动态 Mapping 定义</li>
<li>修改后，使用该配置创建你的索引</li>
<li>删除临时索引</li>
</ul>
<h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>index 控制当前字段是否被索引。默认为true,如果设置成false，就不会被索引，不能被搜索。</p>
<p>优点：不会建立倒排索引，更节省内存空间<br>缺点：该字段不能被搜索</p>
<p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT &#123;index&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;:&#123;</span><br><span class="line">    &quot;properties&quot;:&#123;                 //设置mapping</span><br><span class="line">      &quot;job_name&quot;:&#123;</span><br><span class="line">        &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">        &quot;index&quot;:false             //这里设置false，这个字段就不能被搜索</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;                                 </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="index-options"><a href="#index-options" class="headerlink" title="index options"></a>index options</h3><p>有四种不同级别的 index options 配置，可以控制倒排索引记录的内容</p>
<ul>
<li>docs - 记录 doc id</li>
<li>freqs - 记录 doc id 和 term frequencies</li>
<li>positions - 记录 doc id &#x2F; term frequencies &#x2F; term position</li>
<li>offsets - 记录 doc id &#x2F; term frequencies &#x2F; term position &#x2F; character offects</li>
</ul>
<p>Text类型默认记录 positions ,其他默认为 docs</p>
<p>记录内容越多，占用存储空间越大。</p>
<p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT &#123;index&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;:&#123;</span><br><span class="line">    &quot;properties&quot;:&#123;                 //设置mapping</span><br><span class="line">      &quot;job_name&quot;:&#123;</span><br><span class="line">        &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">        &quot;index_options&quot;:&quot;offsets&quot;             //这里设置index_options</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;                                 </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="null-value"><a href="#null-value" class="headerlink" title="null value"></a>null value</h3><p> 如果需要对 NULL 值进行搜搜，那么只有 <code>Keyword</code> 类型支持设定 null_value</p>
<p> 指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT &#123;index&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;:&#123;</span><br><span class="line">    &quot;properties&quot;:&#123;                 //设置mapping</span><br><span class="line">      &quot;job_name&quot;:&#123;</span><br><span class="line">        &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">        &quot;null_value&quot;:&quot;NULL&quot;             //这里设置null_value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;                                 </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="copy-to"><a href="#copy-to" class="headerlink" title="copy_to"></a>copy_to</h3><p>copy_to 相当于以前的 _all 。可以满足一些特定的搜索需求。copy_to 将字段的数值拷贝到目标字段，实现类似_all的作用。copy_to的目标字段不会出现在_source中</p>
<p> 指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT &#123;index&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;:&#123;</span><br><span class="line">    &quot;properties&quot;:&#123;                 //设置mapping</span><br><span class="line">      &quot;job_name&quot;:&#123;</span><br><span class="line">        &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">        &quot;copy_to&quot;:&quot;fullName&quot;             //这里设置copy_to</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;                                 </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>ES不提供专门的数组类型。但是任何字段，都可以包含多个相同类型的数值。</p>
<p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT test_home/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;job_name&quot;:&quot;php&quot;,</span><br><span class="line">  &quot;city&quot;:[</span><br><span class="line">    &quot;北京市&quot;,&quot;上海市&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 city 就是一个数组。但是如果查看 mapping 会发现 city 是一个 text&#x2F;Keyword 类型。</p>
<blockquote>
<p>极客时间 ES 学习笔记</p>
</blockquote>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch四--ES--基本操作和批量操作</title>
    <url>/ES--%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%92%8C%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C.html</url>
    <content><![CDATA[<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="文档的CRUD"><a href="#文档的CRUD" class="headerlink" title="文档的CRUD"></a>文档的CRUD</h2><ul>
<li>Create 如果id 已经存在，会失败</li>
<li>Index 如果id不存在，创建新的文档。否则先删除在创建新的，版本会增加</li>
<li>Update 文档必须已经存在，更新只会对相应字段做增量修改</li>
</ul>
<h3 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h3><p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT &#123;index&#125;/_doc/&#123;id&#125;?op_type=create  //只是创建</span><br><span class="line">&#123;JSON&#125;</span><br><span class="line"></span><br><span class="line">PUT &#123;index&#125;/_doc/&#123;id&#125; //创建或更新</span><br><span class="line">&#123;JSON&#125;</span><br><span class="line"></span><br><span class="line">PUT &#123;index&#125;/_create/&#123;id&#125; //只是创建</span><br><span class="line">&#123;JSON&#125;</span><br><span class="line"></span><br><span class="line">POST &#123;index&#125;/_doc/  //只是创建 自动生成id</span><br></pre></td></tr></table></figure>

<ul>
<li>如果通过op_type参数指定<code>create</code>那么就只会创建，如果存在会报错</li>
<li>支持自动生成文档ID，和指定ID两种方式</li>
<li>通过调用 <code>POST /index/_doc</code>.不指定ID系统就会自动生成</li>
<li>使用 HTTP PUT index&#x2F;_create&#x2F;1 创建，URI中显式指定 <code>_create</code>,如果该ID的文档已经存在，则操作失败。</li>
</ul>
<p><img src="/../images/ES01.png" alt="ES"></p>
<h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET &#123;index&#125;/&#123;type&#125;/&#123;id&#125; index/_doc/1</span><br></pre></td></tr></table></figure>

<p>找到文档。HTTP 200,找不到就返回 404</p>
<p>元信息</p>
<ul>
<li>_index&#x2F;_type</li>
<li>版本信息，同一个ID的文档，即使被删除，Version也会不断增加</li>
<li>_source 中默认包含了文档的所有原始信息</li>
</ul>
<p><img src="/../images/ES02.png" alt="ES"></p>
<h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT &#123;index&#125;/&#123;type&#125;/&#123;id&#125; index/_doc/1</span><br><span class="line">&#123;JSON&#125;</span><br></pre></td></tr></table></figure>

<p>Index和Create不一样的地方就在于存在就删除在创建，并且版本号增加。</p>
<h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p> Update 是直接更新</p>
<p> 指令<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST &#123;index&#125;/_update/&#123;id&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;doc&quot;:&#123;JSON&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> <img src="/../images/ES03.png" alt="ES"></p>
<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p> Delete是删除操作</p>
<p> 指令<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE &#123;index&#125;/_doc/&#123;id&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="批量操作-Bulk-API"><a href="#批量操作-Bulk-API" class="headerlink" title="批量操作 Bulk API"></a>批量操作 Bulk API</h2><p> 支持一次调用，对不同的索引进行操作<br> 支持</p>
<ul>
<li>Index</li>
<li>Create</li>
<li>Update</li>
<li>Delete</li>
</ul>
<p> 只有一次网络请求，单条失败不会影响其他操作结果</p>
<p> 返回结果包括每一条的执行结果</p>
<p> 指令<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST _bulk</span><br><span class="line">&#123; &quot;index&quot;:&#123;&quot;_index&quot;:&quot;test&quot;, &quot;_id&quot;:&quot;1&quot;&#125; &#125;  //指定index和_id</span><br><span class="line">&#123; &quot;field1&quot;:&quot;value1&quot; &#125;                     //index 的数据</span><br><span class="line">&#123; &quot;delete&quot; : &#123;&quot;_index&quot;:&quot;test&quot; &quot;_id&quot;:&quot;2&quot;&#125;&#125; //delete 的 index 和id</span><br><span class="line">&#123; &quot;create&quot;: &#123;&quot;_index&quot;:&quot;test2&quot;,&quot;_id&quot;:1&#125;&#125;              //create 的index id</span><br><span class="line">&#123; &quot;field1&quot;:&quot;value3&quot;&#125;                      //create 的数据</span><br><span class="line">&#123; &quot;update&quot;:&#123;&quot;_id&quot;:1,&quot;_index&quot;:&quot;test&quot;&#125;&#125;     //update 的id index</span><br><span class="line">&#123; &quot;doc&quot;:&#123;&quot;field2&quot;:&quot;value2&quot;&#125;&#125;              //update 的数据</span><br></pre></td></tr></table></figure></p>
<p>  <img src="/../images/ES04.png" alt="ES"></p>
<h2 id="批量获取-mget"><a href="#批量获取-mget" class="headerlink" title="批量获取 mget"></a>批量获取 mget</h2><p>批量操作，可减少网络开销</p>
<p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST _mget</span><br><span class="line">&#123;</span><br><span class="line">    &quot;docs&quot;:[</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;_index&quot;:&quot;user&quot;</span><br><span class="line">            &quot;_id&quot;:1</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <img src="/../images/ES05.png" alt="ES"></p>
<h2 id="批量查询-msearch"><a href="#批量查询-msearch" class="headerlink" title="批量查询 msearch"></a>批量查询 msearch</h2><p>指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST &#123;index&#125;/_msearch</span><br><span class="line">&#123;&#125;                             //注意这里需要加上这个 不加会报错</span><br><span class="line">&#123;&quot;query&quot;: &#123;&quot;match_all&quot;:&#123;&#125;&#125;,&quot;size&quot;:1&#125;</span><br><span class="line">&#123;&quot;index&quot;: user &#125;</span><br><span class="line">&#123;&quot;query&quot;: &#123;&quot;match_all&quot;:&#123;&#125;&#125;,&quot;size&quot;:1&#125;</span><br></pre></td></tr></table></figure>

<p>  <img src="/../images/ES06.png" alt="ES"></p>
<h2 id="常见错误返回"><a href="#常见错误返回" class="headerlink" title="常见错误返回"></a>常见错误返回</h2><table>
<thead>
<tr>
<th align="left">问题</th>
<th align="left">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="left">无法连接</td>
<td align="left">网络故障或集群挂了</td>
</tr>
<tr>
<td align="left">连接无法关闭</td>
<td align="left">网络故障或节点出错</td>
</tr>
<tr>
<td align="left">429</td>
<td align="left">集群过于繁忙</td>
</tr>
<tr>
<td align="left">4xx</td>
<td align="left">请求体格式有错</td>
</tr>
<tr>
<td align="left">500</td>
<td align="left">集群内部错误</td>
</tr>
</tbody></table>
<blockquote>
<p>极客时间 ES 学习笔记</p>
</blockquote>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch三--ES-基本概念-节点集群分片副本</title>
    <url>/ES--%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BA%8C.html</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="分布式系统的可用性与扩展性"><a href="#分布式系统的可用性与扩展性" class="headerlink" title="分布式系统的可用性与扩展性"></a>分布式系统的可用性与扩展性</h2><p>高可用性</p>
<ul>
<li>服务可用性：允许有节点停止服务。</li>
<li>数据可用性：部分节点丢失，不会丢失数据。</li>
</ul>
<p>可扩展性</p>
<ul>
<li>请求量提升&#x2F;数据的不断增长（将数据分布到所有节点上）</li>
</ul>
<h2 id="分布式特性"><a href="#分布式特性" class="headerlink" title="分布式特性"></a>分布式特性</h2><p>Elasticsearch 的分布式架构好处</p>
<ul>
<li>存储的水平扩容</li>
<li>提高系统的可用性，部分节点停止服务，整个集群的服务不受影响</li>
</ul>
<p>Elasticsearch的分布式架构</p>
<ul>
<li>不同的集群通过不同的名字来区分，默认名字“Elasticsearch”</li>
<li>通过配置文件修改，或者在命令行中 -E cluster.name&#x3D;xxx来设置</li>
<li>一个集群可以有一个或多个节点</li>
</ul>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>节点是一个Elasticsearch 的实例</p>
<ul>
<li>本质上就是一个JAVA进程</li>
<li>一台机器上可以运行多个Elasticsearch进程，但是线上建议一个机器一个节点</li>
</ul>
<p>每一个节点都有名字，通过配置文件配置，或者启动时 -E node.name&#x3D;xxx 来设置</p>
<p>每个节点在启动之后会有一个UID，保存在data目录下</p>
<h3 id="Master-eligible-nodes-和-Master-Node"><a href="#Master-eligible-nodes-和-Master-Node" class="headerlink" title="Master-eligible nodes 和 Master Node"></a>Master-eligible nodes 和 Master Node</h3><p>每个节点启动后，默认是一个 Master eligible 节点。</p>
<ul>
<li>可以设置 node.master:false 禁止<br>Master-eligible 节点可以参加选主流程，成为 master 节点</li>
</ul>
<p>当第一个节点启动时候，它会将自己选举成为 master 节点</p>
<p>每个节点上都保存了集群的状态，只有 master 节点才能修改。</p>
<ul>
<li>集群状态(Cluster State)，维护了一个集群中必要的信息<ul>
<li>所有的节点信息</li>
<li>所有的索引和其相关的 Mapping 与 Settings 信息</li>
<li>分片的路由信息</li>
</ul>
</li>
<li>任意节点都可以修改会导致数据的不一致</li>
</ul>
<h3 id="Data-Node-和-Coordinating-Node"><a href="#Data-Node-和-Coordinating-Node" class="headerlink" title="Data Node 和 Coordinating Node"></a>Data Node 和 Coordinating Node</h3><p>Data Node</p>
<ul>
<li>可以保存数据的节点，叫做Data Node。 负责保存分片数据。在数据扩展上起到了至关重要的作用。</li>
</ul>
<p>Coordinating Node</p>
<ul>
<li>负责接受Client 的请求，将请求分发到合适的节点，最终把结果汇集到一起。</li>
<li>每个节点默认都起到了Coordinating Node的职责</li>
</ul>
<h3 id="其他的节点类型"><a href="#其他的节点类型" class="headerlink" title="其他的节点类型"></a>其他的节点类型</h3><p>Hot &amp; Warm Node</p>
<ul>
<li>不同硬件配置的Data Node ，用来实现 Hot &amp; Warm 架构，降低集群部署的成本。</li>
</ul>
<p>Machine Learning Node</p>
<ul>
<li>负责跑机器学习的Job,用来做异常检测</li>
</ul>
<p>Tribe Node</p>
<ul>
<li>(5.3开始使用 Cross Cluster Search) Tribe Node 连接到不同的Elasticsearch 集群，并且支持将这些集群当成一个单独的集群处理</li>
</ul>
<h3 id="配置节点类型"><a href="#配置节点类型" class="headerlink" title="配置节点类型"></a>配置节点类型</h3><p>生产环境建议一个节点担任一个角色</p>
<table>
<thead>
<tr>
<th align="left">节点类型</th>
<th align="left">配置参数</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">maste eligible</td>
<td align="left">node.master</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">data</td>
<td align="left">node.data</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">ingest</td>
<td align="left">node.ingest</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">coordinating only</td>
<td align="left">无</td>
<td align="left">每个节点默认都是coordinating节点，设置其他类型全部为false</td>
</tr>
<tr>
<td align="left">machine learning</td>
<td align="left">node.ml</td>
<td align="left">true(需要 enable x-pack)</td>
</tr>
</tbody></table>
<h2 id="分片（Primary-Shard-amp-Replica-Shard）"><a href="#分片（Primary-Shard-amp-Replica-Shard）" class="headerlink" title="分片（Primary Shard &amp; Replica Shard）"></a>分片（Primary Shard &amp; Replica Shard）</h2><p>主分片，用以解决数据水平扩展的问题。通过主分片，可以将数据分布到集群内的所有节点之上。</p>
<ul>
<li>一个分片是一个运行的Lucene的实例</li>
<li>主分片数在索引创建时指定，后续不允许修改，除非Reindex</li>
</ul>
<p>副本，用以解决数据高可用的问题。分片是主分片的拷贝</p>
<ul>
<li>副本分片数，可以动态调整</li>
<li>增加副本数，还可以在一定程度上提高服务的可用性（读取的吞吐）</li>
</ul>
<h3 id="分片的设定"><a href="#分片的设定" class="headerlink" title="分片的设定"></a>分片的设定</h3><p>对于生产环境，需要提前做好容量规划</p>
<p>分片数设置过小</p>
<ul>
<li>导致后续无法增加节点实现水平扩展</li>
<li>单个分片的数据量太大，导致数据重新分配耗时</li>
</ul>
<p>分片数设置过大，7.0开始，默认分片设置为1，解决了over-sharding的问题</p>
<ul>
<li>影响搜索结果的相关性打分，影响统计结果的准确性</li>
<li>单个节点上过多的分片，会导致资源浪费，同时也会影响性能</li>
</ul>
<h3 id="查询集群的健康状态"><a href="#查询集群的健康状态" class="headerlink" title="查询集群的健康状态"></a>查询集群的健康状态</h3><p>使用GET方法访问 _cluster&#x2F;health</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /_cluster/health</span><br></pre></td></tr></table></figure>

<p>或者访问 <code>http://localhost:9200/_cluster/health</code></p>
<p>Green : 集群健康<br>Yello : 主分片分配，副本未分配<br>Red   : 主分片未分配</p>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch三--ES-基本概念-索引文档REST API</title>
    <url>/ES--%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%80.html</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="文档-Document"><a href="#文档-Document" class="headerlink" title="文档(Document)"></a>文档(Document)</h2><p>Elasticsearch 是面向<code>文档</code>的，文档是所有可搜索数据的最小单位。</p>
<ul>
<li>日志文件中的日志项。</li>
<li>电影的具体信息&#x2F;唱片的具体信息</li>
<li>MP3播放器里的一首歌&#x2F;一篇PDF文档中的具体内容</li>
</ul>
<p>文档会被序列化成 JSON 格式，保存在Elasticsearch中。</p>
<ul>
<li>JSON对象由字段组成</li>
<li>每个字段都有对应的字段类型（字符串&#x2F;数值&#x2F;布尔&#x2F;日期&#x2F;二进制&#x2F;范围类型）</li>
</ul>
<p>每个文档都有一个Unique ID</p>
<ul>
<li>你可以自己指定ID</li>
<li>或者通过Elasticsearch自己生成</li>
</ul>
<h3 id="文档的元数据"><a href="#文档的元数据" class="headerlink" title="文档的元数据"></a>文档的元数据</h3><ul>
<li>元数据，用于标注文档的相关信息<ul>
<li>_index - 文档所属的索引名</li>
<li>_type - 文档所属的类型名</li>
<li>_id - 文档唯一的ID</li>
<li>_source - 文档的原始JSON数据</li>
<li>_all - 整合所有字段内容到该字段，已被废除</li>
<li>_version - 文档的版本信息</li>
<li>_score - 相关性打分</li>
</ul>
</li>
</ul>
<h2 id="索引（Index）"><a href="#索引（Index）" class="headerlink" title="索引（Index）"></a>索引（Index）</h2><p><code>索引</code>是<code>文档</code>的容器，是一类文档的集合。</p>
<ul>
<li>Index 体现了逻辑空间的概念：每个索引都有自己的Mapping定义，用于定义包含的文档的字段名和字段类型</li>
<li>Shard 体现了物理空间的概念：索引中的数据分散在Shard上</li>
</ul>
<p>索引的 Mapping 和 Settings</p>
<ul>
<li>Mapping 定义文档字段的类型</li>
<li>Setting 定义不同的数据分布</li>
</ul>
<h4 id="索引的不同语意"><a href="#索引的不同语意" class="headerlink" title="索引的不同语意"></a>索引的不同语意</h4><ul>
<li>名词：一个Elasticsearch中，有多个不同的索引。</li>
<li>动词：保存一个文档到Elasticsearch的过程也叫索引（indexing）<ul>
<li>ES中，创建一个倒排索引的过程</li>
</ul>
</li>
<li>名词：一个B树索引，一个倒排索引</li>
</ul>
<h2 id="类型Type"><a href="#类型Type" class="headerlink" title="类型Type"></a>类型Type</h2><ul>
<li>7.0 开始 每个索引只能 创建一个 Type - “_doc”</li>
</ul>
<h2 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h2><p>Elasticsearch提供了REST API的方式进行调用，这样不管什么语言都可以通过HTTP的方式进行调用。</p>
<p>这些API的文档可以在<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html">Elasticsearch的文档</a>里面找到.</p>
<p>可以在Kibana里面的<code>dev tools</code>进行REST API的测试。</p>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch二--ES-Kibana安装</title>
    <url>/ES--kibana%E5%AE%89%E8%A3%85.html</url>
    <content><![CDATA[<h1 id="Kibana安装"><a href="#Kibana安装" class="headerlink" title="Kibana安装"></a>Kibana安装</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>从官网（<a href="https://www.elastic.co/cn/downloads/kibana)%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85">https://www.elastic.co/cn/downloads/kibana)可以进行下载安装</a></p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/kibana</span><br></pre></td></tr></table></figure>

<p>启动后可以访问 <code>localhost:5601</code> 进行查看信息</p>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch二--ES安装</title>
    <url>/ES--%E5%AE%89%E8%A3%85.html</url>
    <content><![CDATA[<h1 id="ES–安装"><a href="#ES–安装" class="headerlink" title="ES–安装"></a>ES–安装</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li><p>运行ElasticSearch, 需安装并配置JDK</p>
<ul>
<li>设置 $JAVA_HOME</li>
</ul>
</li>
<li><p>各个版本对 Java的依赖</p>
<ul>
<li>ElasticSearch 5 需要 Java 8 以上的版本</li>
<li>ElasticSearch 从6.5开始支持 Java 11</li>
<li><a href="https://www.elastic.co/support/matrix#matrix_jvm">https://www.elastic.co/support/matrix#matrix_jvm</a></li>
<li>7.0开始，内置了Java环境</li>
</ul>
</li>
</ul>
<p>从官网（<a href="https://www.elastic.co/cn/downloads/elasticsearch)%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85">https://www.elastic.co/cn/downloads/elasticsearch)可以进行下载安装</a></p>
<h2 id="目录说明"><a href="#目录说明" class="headerlink" title="目录说明"></a>目录说明</h2><ul>
<li>bin : 脚本文件，包括启动 ElasticSearch，安装插件。运行统计数据等。</li>
<li>config : 配置文件：elasticsearch.yml。集群配置文件，user,role based相关配置</li>
<li>JDK: Java运行环境</li>
<li>data: path.data 数据文件</li>
<li>lib : Java类库</li>
<li>logs: path.log 日志文件</li>
<li>modules: 包含所有ES模块</li>
<li>plugins: 包含所有已安装插件</li>
</ul>
<h2 id="JVM配置"><a href="#JVM配置" class="headerlink" title="JVM配置"></a>JVM配置</h2><ul>
<li><p>修改JVM - config&#x2F;jvm.options</p>
<ul>
<li>7.1 下载的默认设置是1GB</li>
</ul>
</li>
<li><p>配置的建议</p>
<ul>
<li>Xmx 和 Xms设置成一样</li>
<li>Xmx 不要超过机器内存的50%</li>
<li>不要超过 30GB - <a href="https://www.elastic.co/blog/a-heap-of-trouble">https://www.elastic.co/blog/a-heap-of-trouble</a></li>
</ul>
</li>
</ul>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h4 id="单节点启动"><a href="#单节点启动" class="headerlink" title="单节点启动"></a>单节点启动</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/elasticsearch</span><br></pre></td></tr></table></figure>

<p>启动后可以访问 <code>localhost:9200</code> 进行查看信息</p>
<h4 id="多节点启动"><a href="#多节点启动" class="headerlink" title="多节点启动"></a>多节点启动</h4><p>cluster.name 指定同一个集群，node.name指定每个节点的名称，path.data指定数据存放位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/elasticsearch -E node.name=node1 -E cluster.name=test -E path.data=node1_data -d</span><br><span class="line">/bin/elasticsearch -E node.name=node2 -E cluster.name=test -E path.data=node2_data -d</span><br><span class="line">/bin/elasticsearch -E node.name=node3 -E cluster.name=test -E path.data=node3_data -d</span><br></pre></td></tr></table></figure>

<p>启动完成以后可以直接访问<code>localhost:9200/_cat/nodes</code>查看node信息</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>使用elasticsearch-plugin进行插件的安装和查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/elasticsearch-plugin list   //查询已安装的插件列表</span><br><span class="line">/bin/elasticsearch-plugin install analysis-icu  //安装analysis-icu插件</span><br></pre></td></tr></table></figure>

<p>还可以通过api进行查看已安装的插件，访问<code>localhost:9200/_cat/plugins</code>可以查看已安装的插件</p>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch一--ES简介</title>
    <url>/ES--%E7%AE%80%E4%BB%8B.html</url>
    <content><![CDATA[<h1 id="ES–简介"><a href="#ES–简介" class="headerlink" title="ES–简介"></a>ES–简介</h1><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>ES起源于Lucene.Lucene是基于JAVA开发的搜索引擎类库。</p>
<p>Lucene具有高性能，易扩展的优点。</p>
<p>Lucene的局限性：</p>
<ol>
<li>只能基于JAVA开发</li>
<li>类库的接口学习曲线陡峭</li>
<li>原生并不支持水平扩展</li>
</ol>
<h2 id="ES的诞生"><a href="#ES的诞生" class="headerlink" title="ES的诞生"></a>ES的诞生</h2><p>ES的创始人<code>Shay Banon</code>说过：<code>Search is something that any application should have</code>。</p>
<p>2004年基于Lucene开发了 Compass</p>
<p>2010年重写了 Compass ，取名 ElasticSearch</p>
<ul>
<li>支持分布式，可水平扩展</li>
<li>降低全文检索的学习曲线，可以被任何编程语言调用</li>
</ul>
<h2 id="ES的分布式架构"><a href="#ES的分布式架构" class="headerlink" title="ES的分布式架构"></a>ES的分布式架构</h2><p>集群规模可以从单个扩展至数百个节点</p>
<p>高可用 &amp; 水平扩展<br>    - 服务和数据两个维度</p>
<p>支持不同的节点类型<br>    - 支持 Hot &amp; Warm架构</p>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ul>
<li><p>海量数据的分布式存储以及集群管理</p>
<ul>
<li>服务与数据的高可用，水平扩展</li>
</ul>
</li>
<li><p>近实时搜索，性能卓越</p>
<ul>
<li>结构化&#x2F;全文&#x2F;地理位置&#x2F;自动完成</li>
</ul>
</li>
<li><p>海量数据的近实时分析</p>
<ul>
<li>聚合功能</li>
</ul>
</li>
</ul>
<h3 id="新特性5-x"><a href="#新特性5-x" class="headerlink" title="新特性5.x"></a>新特性5.x</h3><ul>
<li>Lucene 6.x ，性能提升，默认打分机制从TF-IDF改为BM25</li>
<li>支持Ingest节点&#x2F; Painless Scripting &#x2F; Completion suggested 支持&#x2F; 原生的JAVA REST客户端</li>
<li>Type 标记成 deprecated ，支持了keyword类型</li>
<li>性能优化<ul>
<li>内部引擎移除了避免同一文档并发更新的竞争锁，带来15 - 20%的性能提升</li>
<li>Instant aggregation，支持分片上聚合的缓存</li>
<li>新增了Profile API</li>
</ul>
</li>
</ul>
<h3 id="新特性6-x"><a href="#新特性6-x" class="headerlink" title="新特性6.x"></a>新特性6.x</h3><ul>
<li>Lucene 7.x</li>
<li>新功能<ul>
<li>跨集群复制（CCR）</li>
<li>索引生命周期管理</li>
<li>SQL的支持</li>
</ul>
</li>
<li>更友好的升级及数据迁移<ul>
<li>在主要版本之间的迁移更为简化，体验升级</li>
<li>全新的基于操作的数据复制框架，可加快回复数据。</li>
</ul>
</li>
<li>性能优化<ul>
<li>有效存储稀疏字段的新方法，降低了存储成本</li>
<li>在索引时进行排序，可加快排序的查询性能</li>
</ul>
</li>
</ul>
<h3 id="新特性7-x"><a href="#新特性7-x" class="headerlink" title="新特性7.x"></a>新特性7.x</h3><ul>
<li>Lucene 8.x</li>
<li>重大改进 - 正式废除单个索引下多Type的支持</li>
<li>7.1开始，Security功能免费使用</li>
<li>ECK - ElasticSearch Operator on Kubernetes</li>
<li>新功能<ul>
<li>New Cluster coordination</li>
<li>Feature-Complete High Level Rest Client</li>
<li>Script Score Query</li>
</ul>
</li>
<li>性能优化<ul>
<li>默认的Primary Shard 数从5变为1，避免Over Sharding</li>
<li>性能优化，更快的Top K</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>数据链路层CRC(循环冗余码)差错校验码详解</title>
    <url>/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82CRC%E5%B7%AE%E9%94%99%E6%A0%A1%E9%AA%8C%E7%A0%81%E8%AF%A6%E8%A7%A3.html</url>
    <content><![CDATA[<h1 id="数据链路层CRC-循环冗余码-差错校验码详解"><a href="#数据链路层CRC-循环冗余码-差错校验码详解" class="headerlink" title="数据链路层CRC(循环冗余码)差错校验码详解"></a>数据链路层CRC(循环冗余码)差错校验码详解</h1><p><code>CRC</code>差错校验码是数据链路层用来进行差错校验的一个码。</p>
<h3 id="CRC编码过程"><a href="#CRC编码过程" class="headerlink" title="CRC编码过程"></a>CRC编码过程</h3><p>假设要编码的<code>数据D</code>，有<code>d个比特</code>，发送节点要将它发送给接收节点。发送方和接收方要先协商一个<code>r + 1</code>比特模式，成为<code>生成多项式</code>。我们将其表示为<code>G</code>。我们将要求G的最高有效位（最左边）的比特是1。</p>
<p>我们要有一个数据D，比如 1001<br>这个数据有d个比特，也就是4个比特<br>需要附加 r 个比特作为校验码 R<br>编码过后会变成数据会变成D + R<br>数据有d + r个比特<br>使得得到的数据D+R进行模2运算恰好能被G整除</p>
<h3 id="CRC差错检测过程"><a href="#CRC差错检测过程" class="headerlink" title="CRC差错检测过程"></a>CRC差错检测过程</h3><p>接收方用G去除接收到的D+R数据，如果余数为非0，则有差错，如果余数为0，则无差错</p>
<h3 id="CRC计算"><a href="#CRC计算" class="headerlink" title="CRC计算"></a>CRC计算</h3><p>所有CRC计算采用模2算术来做，在加法中不进位，在减法中不借位。这意味着加法和减法是相同的，而且这两种操作等价于<code>异或</code>（XOR）操作。</p>
<p>1011 XOR 0101 &#x3D; 1110</p>
<p><code>异或</code>操作：不同的为1，相同为0。也就是0 XOR 0 &#x3D; 0,1 XOR 1 &#x3D; 0,0 XOR 1 &#x3D; 1。</p>
<p>乘法和除法是相同的。</p>
<p>给定D 和 R, D * 2<sup>r</sup> XOR R就等于 D + R数据。</p>
<h3 id="如何计算R"><a href="#如何计算R" class="headerlink" title="如何计算R"></a>如何计算R</h3><p>我们要求出R使得对于n有：<br>D * 2<sup>r</sup> XOR R &#x3D; nG</p>
<p>也就是说，我们要选择 R 使得G能除 D * 2<sup>r</sup> XOR R 而没有余数。如果对上面的等式两边都 XOR R.</p>
<p>D * 2<sup>r</sup> &#x3D; nG XOR R</p>
<p>根据上面的等式可以得出，如果我们用G 除 D * 2<sup>r</sup>，余数刚好是R</p>
<p>R &#x3D; remainder (D * 2<sup>r</sup> &#x2F; G)</p>
<p>也就是使用D * 2<sup>r</sup>去除以 G。余数就是R。</p>
<h3 id="如何计算G"><a href="#如何计算G" class="headerlink" title="如何计算G"></a>如何计算G</h3><p>G 作为多项式，有两种写法，一种是x<sup>2</sup> + x + 1的写法，一种是二进制写法 111。</p>
<p>我们需要用 D * 2<sup>r</sup> 除以 G 。所以我们需要求出G的二进制写法，才能做除法运算。</p>
<p>这个转换的方法：</p>
<ol>
<li>首先把末尾的1看成x<sup>0</sup>，也就是x的0次幂</li>
<li>这样提取出x的所有幂</li>
<li>对应幂的位置填1，如果没有对应幂的位置则填0</li>
</ol>
<h5 id="转换例子1"><a href="#转换例子1" class="headerlink" title="转换例子1"></a>转换例子1</h5><p>G &#x3D; x<sup>4</sup> + x + 1</p>
<p>提取出来的幂分别是 4,1,0。<br>没有的幂是3,2。<br>在对应的位置填上1或0。<br>4 3(无) 2(无) 1 0<br>1 0     0     1 1<br>这个G的二进制就是 10011。</p>
<p>其实很简单，0次幂对应个位，1次幂对应十位，一直往上加就行了，有1次幂十位就是1，没有就是0.</p>
<h5 id="转换例子2"><a href="#转换例子2" class="headerlink" title="转换例子2"></a>转换例子2</h5><p>G &#x3D; x<sup>6</sup> + x<sup>4</sup> + x<sup>2</sup> + 1</p>
<p>6 5(无) 4 3(无) 2 1(无) 0<br>1 0     1 0     1 0     1</p>
<p>对应的二进制就是 1010101</p>
<h3 id="计算CRC编码"><a href="#计算CRC编码" class="headerlink" title="计算CRC编码"></a>计算CRC编码</h3><p>给定 D &#x3D; 101110, G &#x3D; 1001, d &#x3D; 6, r &#x3D; 3。计算D的CRC编码后的数据</p>
<p>首先求R。</p>
<p>用D&#x2F;G可以得出结果为101011，余数为011，余数就是R。</p>
<p>然后把R放到D后面。</p>
<p>编码后就是 101110 011</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络原理自顶向下四网络层</title>
    <url>/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%9B%9B%E7%BD%91%E7%BB%9C%E5%B1%82.html</url>
    <content><![CDATA[<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>网络层核心功能：转发与路由</p>
<p>转发：将分组从路由器的输入端口转移到合适的输出端口</p>
<p>转发表确定在本路由器如何转发分组</p>
<p>路由：确定分组从源到目的经过的路径。</p>
<ul>
<li>路由算法：确定通过网络的端到端路径。</li>
</ul>
<p>某些网络的重要功能：连接建立</p>
<p>数据分组传输前需要建立连接，和运输层不一样的是所有网络设备路由器都会参与建立连接。</p>
<p>网络层是两个主机建立连接</p>
<p>运输层是两个应用进程建立连接</p>
<p>无连接服务</p>
<ul>
<li>不事先为分组确定传输路径</li>
<li>每个分组独立路径</li>
<li>不同分组可能传输路径不同</li>
<li>数据报网络</li>
</ul>
<p>连接服务：</p>
<ul>
<li>首先为分组确定传输路径</li>
<li>沿这个路径传输</li>
<li>系列分组传输路径相同</li>
<li>传输结束后拆除</li>
<li>虚电路网络</li>
</ul>
<p><code>数据报网络</code>和<code>虚电路网络</code>是典型两类分组交换网络。</p>
<p>类似UDP和TCP。但是网络层是<code>主机到主机</code>.<code>网络核心实现</code>.</p>
<h3 id="虚电路"><a href="#虚电路" class="headerlink" title="虚电路"></a>虚电路</h3><p>一条从源主机到目的主机，类似于电路的路径。</p>
<ul>
<li>分组交换</li>
<li>每个分组的传输利用链路的全部带宽</li>
<li>源主机到目的主机的所有网络设备完成虚电路连接和功能</li>
</ul>
<p>通信过程：</p>
<ul>
<li>呼叫建立（call setup） -》 数据传输 -》 拆除呼叫</li>
<li>每个分组携带虚电路标识（VC ID），而不是目的主机地址</li>
<li>虚电路经过的每个网络设备，维护每条经过他的虚电路连接状态</li>
<li>链路，网络设备资源可以面向VC进行预分配<ul>
<li>预分配资源 &#x3D; 可预期服务性能</li>
<li>如ATM的电路仿真（CBR）</li>
</ul>
</li>
</ul>
<p>每条虚电路包括：</p>
<ul>
<li>从源主机到目的主机的一条路径</li>
<li>虚电路号（VCID），沿路每段链路一个编号</li>
<li>沿路每个网络层设备，利用转发表记录经过的每条虚电路</li>
</ul>
<p>分组携带虚电路号VCID，而不是目的地址。<br>同一条VC,在每段链路上的VCID通常不同。</p>
<ul>
<li>路由器转发分组时依据转发表改写&#x2F;替换虚电路号</li>
</ul>
<h5 id="虚电路信令协议"><a href="#虚电路信令协议" class="headerlink" title="虚电路信令协议"></a>虚电路信令协议</h5><p>用于VC的建立，维护与拆除</p>
<ul>
<li>路径选择</li>
</ul>
<p>应用于虚电路网络</p>
<ul>
<li>如ATM</li>
</ul>
<p>目前的internet不采用</p>
<h3 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h3><ul>
<li>无连接</li>
<li>每个分组携带目的地址</li>
<li>路由器根据分组的目的地址转发分组<ul>
<li>基于路由协议&#x2F;算法构建转发表</li>
<li>检索转发表</li>
<li>每个分组独立选路</li>
</ul>
</li>
<li>Internet网络是数据报网络</li>
<li>路由算法<ul>
<li>根据地址范围进行转发</li>
<li>最长前缀匹配优先</li>
</ul>
</li>
</ul>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>Internet(数据报网络) </p>
<ul>
<li>计算机之间的数据交换<ul>
<li>弹性服务，没有严格要求</li>
</ul>
</li>
<li>链路类型众多<ul>
<li>特点性能各异</li>
<li>同一服务困难</li>
</ul>
</li>
</ul>
<p>ATM(虚电路网络)</p>
<ul>
<li>电话网络演变而来</li>
<li>核心业务是实时对话<ul>
<li>严格的时间，可靠性需求</li>
<li>需要有保障的服务</li>
</ul>
</li>
<li>非智能端系统<ul>
<li>电话机</li>
<li>传真机</li>
</ul>
</li>
</ul>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>路由协议</p>
<ul>
<li>路径选择</li>
<li>RIP OSPF BGP</li>
</ul>
<p>IP协议</p>
<ul>
<li>寻址规约</li>
<li>数据报格式</li>
<li>分组处理规约</li>
</ul>
<p>ICMP协议</p>
<ul>
<li>差错报告</li>
<li>路由器“信令”</li>
</ul>
<h3 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h3><ul>
<li>首部<ul>
<li>版本号 4比特 ipv4就是4</li>
<li>首部长度 4比特 首部的长度，以4字节为单位 默认是5 表示20字节</li>
<li>服务类型 8比特 期望获得哪种类型的服务 只有在网络提供区分服务时使用 通常是0</li>
<li>总长度 16比特 IP数据报的长度（首部 + 数据），以字节为单位， 最大IP分组总长度 65535B 最小分组首部 20B IP分组数据最大可以是 65515B</li>
<li>标识 16比特 ID，计数器+1</li>
<li>标志位 3比特 保留1比特 DF &#x3D; 1禁止分片 0 允许分片 MF &#x3D; 1非最后一片 0 最后一片或未分片</li>
<li>片偏移 13比特 IP分组分片封装原IP分组数据的相对偏移量 以8字节为单位</li>
<li>生存时间 8比特 IP分组在网络中可以通过的路由器数（跳步数）</li>
<li>协议 8比特 指示IP分组封装的是哪个协议的数据包 6是TCP或者17是UDP</li>
<li>首部校验和 16比特 IP分组首部的差错检测 逐步计算</li>
<li>源IP地址 32比特  </li>
<li>目的IP地址 32比特</li>
<li>选项字段 变长 范围 1 - 40B 携带安全，源选路径，时间戳和路由记录等内容 实际很少被使用</li>
<li>填充字段 变长 范围 0 - 3B 补齐整个首部，保证32位对齐</li>
</ul>
</li>
<li>数据</li>
</ul>
<h3 id="IP分片"><a href="#IP分片" class="headerlink" title="IP分片"></a>IP分片</h3><p>链路最大数据单元MTU。如果现在的IP分组大于下个链路的MTU就可以进行分片。</p>
<ul>
<li>如果进行分片就分片，然后重组</li>
<li>如果不可以分片则丢弃分组</li>
</ul>
<p>分片过程：<br>假设IP分组长L，带转发MTU为M<br>若L &gt; M且DF &#x3D; 0,则可以分片<br>分片时每个分片的标识复制原IP分组的标识<br>通常分片时，除最后一个分片，都为MTU允许的最大分片<br>一个最大分片可封装的应该是 8 的倍数。<br>d &#x3D; M - 20 &#x2F; 8 * 8<br>n &#x3D; L - 20 &#x2F; d<br>分片偏移量<br>Fi &#x3D; d &#x2F; 8 * (i - 1)<br>每片总长度<br>d + 20<br>最后一个<br>L - （n - 1）d</p>
<h3 id="IP编址"><a href="#IP编址" class="headerlink" title="IP编址"></a>IP编址</h3><p>32比特（IPv4） 11011111 00000001 00000001 00000001 &#x3D; 233.1.1.1<br>IP地址与每个接口关联</p>
<ul>
<li>网络号：高位比特</li>
<li>主机号：低位比特</li>
</ul>
<h3 id="IP子网"><a href="#IP子网" class="headerlink" title="IP子网"></a>IP子网</h3><p>IP子网：</p>
<ul>
<li>IP地址具有相同的网络号</li>
<li>不跨越路由器可以彼此物理联通</li>
<li>233.1.1.0&#x2F;24</li>
</ul>
<p><code>有类编址</code><br>A类地址：</p>
<ul>
<li>网络号 8比特 主机号 24比特 50% 0.0.0.0 - 127.255.255.255<br>B类地址：</li>
<li>网络号 16比特 主机号 16比特 25% 128.0.0.0 - 191.255.255.255<br>C类地址：</li>
<li>网络号 24比特 主机号 8比特 12.5% 192。0.0.0 - 223.255.255.255<br>D类地址：</li>
<li>6.25% 224.0.0.0 - 239.255.255.255<br>E类地址：</li>
<li>6.25% 240.0.0.0 - 255.255.255.255</li>
</ul>
<p>私有IP地址：</p>
<ul>
<li>A类：网络号10开头的 10.<em>.</em>.*</li>
<li>B类：172.16 - 172.31 16个</li>
<li>C类：192.168.0 - 192.168.255</li>
</ul>
<p>IP地址：</p>
<ul>
<li>网络号：高位比特</li>
<li>子网号：原主机号的部分</li>
<li>主机号：地位比特</li>
</ul>
<p>子网掩码：网络号和子网号取255，主机号取0</p>
<ul>
<li>A类网络子网掩码 255.255.255.0</li>
</ul>
<p>子网地址 + 子网掩码 &#x3D; 准确确定子网大小</p>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p>子网 201.2.3.0 子网掩码 255.255.255.0，划分为4个等长的子网。</p>
<ul>
<li>201.2.3.0 &#x3D; 201.2.3.00000000 255.255.255.11000000 &#x3D; 255.255.255.192</li>
<li>201.2.3.64 &#x3D; 201.2.3.01000000 255.255.255.11000000 &#x3D; 255.255.255.192</li>
<li>201.2.3.128 &#x3D; 201.2.3.10000000 255.255.255.11000000 &#x3D; 255.255.255.192</li>
<li>201.2.3.192 &#x3D; 201.2.3.11000000 255.255.255.11000000 &#x3D; 255.255.255.192</li>
</ul>
<p>将IP分组的目的IP地址与子网掩码<code>按位与</code>运算，提取子网地址。<br>目的IP:172.32.1.112 &#x3D; 10101100.00100000.00000001.01110000<br>子网掩码：255.255.254.0 &#x3D; 11111111.11111111.11111110.00000000<br>子网地址：10101100.00100000.00000000.00000000 &#x3D; 172.32.0.0<br>地址范围：172.32.0.0 - 172.32.1.255<br>可分配地址范围：172.32.0.1 - 172.32.1.254<br>广播地址：172.32.1.255</p>
<h3 id="CIDR与路由聚合"><a href="#CIDR与路由聚合" class="headerlink" title="CIDR与路由聚合"></a>CIDR与路由聚合</h3><p>无类域间路由CIDR</p>
<ul>
<li>消除传统的A类，B类，C类地址划分</li>
<li>网络号 + 子网号 &#x3D; 网络前缀 可以任意长度</li>
<li>融合子网地址和子网掩码，方便子网划分<ul>
<li>无类地址格式：a.b.c.d&#x2F;x 其中x为网络前缀长度</li>
</ul>
</li>
<li>提高IPv4地址空间分配效率</li>
<li>提高路由效率<ul>
<li>将多个子网构成一个大的子网</li>
<li>构造超网</li>
<li>路由聚合</li>
</ul>
</li>
</ul>
<p>例如：<br>前23位是网络前缀，后9位是主机号<br>11001000 00010111 00010000 00000000<br>200.23.16.0&#x2F;23</p>
<p>11001000.00010111.00010010.00000000<br>200.23.18.0&#x2F;23</p>
<p>11001000.00010111.00010100.00000000<br>200.23.20.0&#x2F;23<br>聚合成超网：<br>11001000 00010111 00010000 00000000<br>200.23.16.0&#x2F;20</p>
<p>如果有一个子网不在也没事，路由记录两条信息。根据<code>最长前缀匹配优先</code>。不会出错。</p>
<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>动态分配路由协议：<br>客户：DHCP discover</p>
<ul>
<li>src:0.0.0.0:68</li>
<li>dest:255.255.255.255:67 广播</li>
<li>yiaddr:0.0.0.0</li>
<li>transactionID:654</li>
</ul>
<p>DHCP服务器：DHCP offer</p>
<ul>
<li>src:223.1.2.5:67 DHCP服务器的IP</li>
<li>dest:255.255.255.255:68 广播</li>
<li>yiaddr:223.1.2.4  分配的IP</li>
<li>transactionID:654</li>
<li>lifetime:3600 secs</li>
</ul>
<p>客户：DHCP req</p>
<ul>
<li>src:0.0.0.0:68</li>
<li>dest:255.255.255.255:67 广播</li>
<li>yiaddr:223.1.2.4  分配的IP</li>
<li>transactionID:655</li>
<li>lifetime:3600 secs</li>
</ul>
<p>DHCP服务器：DHCP ACK</p>
<ul>
<li>src:223.1.2.5:67 DHCP服务器的IP</li>
<li>dest:255.255.255.255:68 广播</li>
<li>yiaddr:223.1.2.4  分配的IP</li>
<li>transactionID:655</li>
<li>lifetime:3600 secs</li>
</ul>
<h3 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h3><p>子网使用一个公共IP。发送网络数据的时候路由器替换源IP地址。</p>
<p>动机：</p>
<ul>
<li>只需从ISP申请一个IP地址<ul>
<li>IPv4地址耗尽</li>
</ul>
</li>
<li>本地网络地址是私有的，局部的，IP地址变更根外界没有影响</li>
<li>变更ISP时候，无需修改内部网络IP</li>
<li>内部网络设备对外界网络不可见，更加安全</li>
</ul>
<p>实现：</p>
<ul>
<li>替换<ul>
<li>利用（NAT IP地址，新端口号）替换每一个<code>外出IP数据报</code>的（源IP地址，源端口号）</li>
</ul>
</li>
<li>记录<ul>
<li>将每对（NAT IP地址，新端口号）和（源IP地址，源端口号）记录在<code>NAT转换表</code>中</li>
</ul>
</li>
<li>替换<ul>
<li>根据<code>NAT转换表</code>，利用（源IP地址，源端口号）替换（NAT IP地址，新端口号）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络原理自顶向下四网络层</title>
    <url>/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%BA%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.html</url>
    <content><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>负责通过一条链路从一个节点向另一个物理链路直接相连的相邻节点传送数据报</p>
<p>组帧</p>
<ul>
<li>封装数据报，加首部和尾部</li>
<li>帧同步</li>
</ul>
<p>链路接入</p>
<ul>
<li>如果是共享介质，需要解决信道接入</li>
<li>帧首部的MAC地址，用于标识帧的源和目的，不同于IP地址</li>
</ul>
<p>相邻节点间可靠交付</p>
<ul>
<li>在低误码率的有线链路上很少采用（如光纤，某些双绞线）</li>
<li>无线链路：误码率高，需要可靠交付</li>
</ul>
<p>流量控制</p>
<ul>
<li>协调相邻的发送和接受</li>
</ul>
<p>差错检测</p>
<ul>
<li>信号衰减和噪声会引起差错</li>
<li>接收端检测到差错<ul>
<li>通知发送端重传或丢弃</li>
</ul>
</li>
</ul>
<p>差错纠正</p>
<ul>
<li>接收端直接纠正比特差错</li>
</ul>
<p>全双工和半双工通信控制</p>
<ul>
<li>全双工:链路两端节点同时双向传输数据</li>
<li>半双工：链路两端节点交替双向传输数据</li>
</ul>
<h2 id="差错检测：差错编码"><a href="#差错检测：差错编码" class="headerlink" title="差错检测：差错编码"></a>差错检测：差错编码</h2><p>差错编码基本原理：<br>D -&gt; D<code>R</code> ，其中R为差错检测与纠正比特</p>
<p>差错编码分为<code>检错码</code>和<code>纠错码</code><br>对于检错码：如果编码集的汉明距离ds &#x3D; r + 1，则可以检测r位的错误<br>对于纠错码：ds &#x3D; 2r + 1则可以检测r位的错误</p>
<h2 id="MAC协议"><a href="#MAC协议" class="headerlink" title="MAC协议"></a>MAC协议</h2><p>两类<code>链路</code></p>
<p>点对点链路</p>
<ul>
<li>拨号接入的PPP</li>
<li>以太网交换机与主机间的点对点链路</li>
</ul>
<p>广播链路（共享介质）</p>
<ul>
<li>早期的总线以太网</li>
<li>HFC的上行链路</li>
<li>802.11 无线网</li>
</ul>
<p>单一共享广播信道</p>
<ul>
<li>两个或者两个以上节点同时传输：干扰</li>
<li>冲突：节点同时接收到两个或者多个信号 &#x3D;》 接收失败</li>
</ul>
<p>多路访问控制协议MAC解决这些问题：</p>
<ul>
<li>采用分布式算法决定节点如何共享信道，及决策节点何时可以传输数据</li>
<li>必须基于信道本身，通信信道共享协调信息<ul>
<li>无带外信道协调</li>
</ul>
</li>
</ul>
<h4 id="理想MAC协议"><a href="#理想MAC协议" class="headerlink" title="理想MAC协议"></a>理想MAC协议</h4><p>给定：速率为R bps的广播信道<br>期望：</p>
<ol>
<li>当只有一个节点希望传输数据时，他可以以速率R发送</li>
<li>当有M个节点发送，每个节点R&#x2F;M速率</li>
<li>完全分散控制<ul>
<li>无需特定节点协调</li>
<li>无需时钟、时隙同步</li>
</ul>
</li>
<li>简单</li>
</ol>
<h4 id="MAC协议分类"><a href="#MAC协议分类" class="headerlink" title="MAC协议分类"></a>MAC协议分类</h4><p>三大类：</p>
<ul>
<li>信道划分MAC协议<ul>
<li>多路复用</li>
<li>TDMA,FDMA,CDMA,WDMA等</li>
</ul>
</li>
<li>随机访问MAC协议<ul>
<li>信道不划分，允许冲突</li>
<li>采用<code>冲突</code>恢复机制</li>
</ul>
</li>
<li>轮转MAC协议<ul>
<li>节点轮流使用信道</li>
</ul>
</li>
</ul>
<h5 id="随机访问MAC协议"><a href="#随机访问MAC协议" class="headerlink" title="随机访问MAC协议"></a>随机访问MAC协议</h5><p>发送时候使用信道全部速率</p>
<p>需要定义：</p>
<ul>
<li>如果检测冲突</li>
<li>如何从冲突恢复（通过延迟重传）</li>
</ul>
<p>典型的协议</p>
<ul>
<li>时隙 ALOHA</li>
<li>ALOHA</li>
<li>CSMA CSMA&#x2F;CD CSMA&#x2F;CA</li>
</ul>
<h6 id="时隙-ALOHA"><a href="#时隙-ALOHA" class="headerlink" title="时隙 ALOHA"></a>时隙 ALOHA</h6><p>假定：</p>
<ul>
<li>所有帧大小相同</li>
<li>时间被划分为等长的时隙</li>
<li>节点只能在时隙开始时刻发送数据</li>
<li>节点间时钟同步</li>
<li>如果2个或2个以上节点在同一时隙发送帧，节点就检测到冲突</li>
</ul>
<p>运行：</p>
<ul>
<li>当节点有新的帧时，在下一个时隙发送<ul>
<li>无冲突：发送成功</li>
<li>冲突：节点在下一个时隙以概率P重传该帧，直至成功</li>
</ul>
</li>
</ul>
<p>优点：</p>
<ul>
<li>单个节点活动时，可以连续以信道全部速率发送</li>
<li>高度分散化：只需同步时隙</li>
<li>简单</li>
</ul>
<p>缺点：</p>
<ul>
<li>冲突，浪费时隙</li>
<li>空闲时隙</li>
<li>节点也许能以远小于分组传输时间检测到冲突</li>
</ul>
<p>最大效率<code>0.37</code></p>
<h6 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h6><p>非时隙，更简单，无需同步<br>当有新的帧，立即发送<br>冲突可能增大</p>
<p>最大效率<code>0.18</code></p>
<h6 id="CSMA"><a href="#CSMA" class="headerlink" title="CSMA"></a>CSMA</h6><p>载波监听多路访问协议</p>
<ul>
<li>发送帧之前，监听信道（载波）<ul>
<li>信道空闲：发送完整帧</li>
<li>信道忙：推迟发送<ul>
<li>1-坚持CSMA 一直监听信道</li>
<li>非坚持CSMA 随机等待一段时间再监听信道</li>
<li>P-坚持CSMA 以概率P监听信道，概率1-P不监听信道</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>冲突仍可能发生：</p>
<ul>
<li>信号传播延迟</li>
</ul>
<p>继续发送冲突帧：浪费信道资源</p>
<h6 id="CSMA-x2F-CD"><a href="#CSMA-x2F-CD" class="headerlink" title="CSMA&#x2F;CD"></a>CSMA&#x2F;CD</h6><p>带有冲突检测的载波监听多路访问协议</p>
<ul>
<li>短时间内可以检测到冲突</li>
<li>冲突后传输中止，减少信道浪费</li>
</ul>
<p>运行：</p>
<ol>
<li>适配器从网络获取一条数据报，准备链路层帧，并放入帧适配器缓存中。</li>
<li>如果适配器侦听到信道空闲（即无信号能量从信道进入适配器），他开始传输帧。另一方面，如果适配器侦听到信道正在忙，他将等待，直到侦听到没有信号能量时才开始传输帧。</li>
<li>在传输过程中，适配器监视来自其他使用该广播信道的适配器的信号能量的存在。</li>
<li>如果适配器传输整个帧而未检测到来自其他适配器的信号能量，该适配器就完成了该帧。另一方面，如果适配器在传输时检测到来自其他适配器的信号能量，他中指传输（即他停止了传输帧）</li>
<li>中止传输后，适配器等待一个随机时间量，然后返回步骤2.<ul>
<li>等待一个随机（而不是固定）的时间量的需求是明确的–如果两个结点同时传输帧，然后这两个结点等待相同固定的时间量，他们将持续碰撞下去。但选择随机回退时间的时间间隔多大为好呢？如果时间间隔大而碰撞结点数量小，在重复“侦听-当空闲时传输”的步骤前。</li>
</ul>
</li>
</ol>
<p>冲突检测</p>
<ul>
<li>有线局域网易于实现：测量信号强度，比较发射信号与接收信号</li>
<li>无线信号很难实现：接收信号强度淹没在本地发射信号强度下</li>
</ul>
<p>边发送边监听，不发送就不监听</p>
<p>网络带宽：R bps<br>数据帧最小长度：Lmin(bits)<br>信号传播速度：V(m&#x2F;s)<br>信道长度：Dmax</p>
<p>满足：<br>L &#x2F;R &gt;&#x3D; 2 Dmax &#x2F; V<br>Lmin &#x2F; R &#x3D; 2 Dmax &#x2F; V<br>Lmin &#x2F; R &#x3D; RTT max</p>
<p>远优于ALOAH，并且简单，分散。</p>
<h5 id="轮转MAC"><a href="#轮转MAC" class="headerlink" title="轮转MAC"></a>轮转MAC</h5><p>轮询：</p>
<ul>
<li>主节点轮流“邀请”从属节点发送数据</li>
<li>典型应用：<ul>
<li>“哑”从属设备</li>
</ul>
</li>
</ul>
<p>优点：</p>
<ul>
<li>不会冲突</li>
<li>使用全部带宽</li>
</ul>
<p>问题：</p>
<ul>
<li>轮询开销</li>
<li>等待延迟</li>
<li>单点故障</li>
</ul>
<h6 id="令牌传递"><a href="#令牌传递" class="headerlink" title="令牌传递"></a>令牌传递</h6><p>控制令牌依次从一个节点传递到下一个节点<br>令牌：特殊帧<br>获取令牌才可以发送数据</p>
<p>优点：</p>
<ul>
<li>不会冲突</li>
<li>使用全部带宽</li>
</ul>
<p>缺点：</p>
<ul>
<li>令牌开销</li>
<li>等待延迟</li>
<li>单点故障</li>
</ul>
<h5 id="MAC协议总结"><a href="#MAC协议总结" class="headerlink" title="MAC协议总结"></a>MAC协议总结</h5><p>信道划分协议：<br>优点：网络负载高，利用率高，性能高<br>缺点：网络负载低，利用率低，性能低</p>
<p>随机访问MAC协议：<br>优点：网络负载低，利用率高，性能高<br>缺点：网络负载高，会冲突</p>
<p>轮转MAC:<br>主节点轮询：令牌传递<br>结合两者优点，不是最好也不是最坏</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络原理自顶向下三可靠数据传输原理实现GBN滑动窗口协议</title>
    <url>/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B8%89%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0GBN%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE.html</url>
    <content><![CDATA[<h1 id="网络原理自顶向下三可靠数据传输原理实现GBN滑动窗口协议"><a href="#网络原理自顶向下三可靠数据传输原理实现GBN滑动窗口协议" class="headerlink" title="网络原理自顶向下三可靠数据传输原理实现GBN滑动窗口协议"></a>网络原理自顶向下三可靠数据传输原理实现GBN滑动窗口协议</h1><p>在GBN中，允许发送方发送多个分组而不需等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数N。</p>
<p>我们需要</p>
<ul>
<li>base 基序号 最早未确认分组的序号</li>
<li>nextSeqNum下一个序号 最小的未使用序号</li>
</ul>
<p>则可以将序号范围分割成四段</p>
<ul>
<li>0 至 base - 1 已经发送并被确认的分组</li>
<li>base 至 nextSeqNum - 1 已经发送没有被确认的分组</li>
<li>nextSeqNum 至 base + N - 1 可以被发送的分组序号</li>
<li>base + N 至 无穷大  不能使用的序号</li>
</ul>
<p>已经被发送的可以但未被确认的可以看成是一个在序号范围内长度为N的窗口。随着协议允许，窗口往前滑动。因此N常被成为<code>窗口长度</code>，GBN协议也被称为<code>滑动窗口协议</code></p>
<h4 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h4><p>GBN的发送方必须响应三种类型的事件</p>
<ul>
<li>上层的调用。检测有没有可以使用的序号，如果有就发送。</li>
<li>收到ACK。GBN使用<code>累计确认</code>。即收到的N之前的全部确认。</li>
<li>超时事件。如果出现超时，就重传所有已发送未确认的分组。</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序号</span></span><br><span class="line"><span class="variable">$base</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable">$nextSeqNum</span> = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_send</span>(<span class="params"><span class="variable">$data</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//生成校验和</span></span><br><span class="line">    <span class="variable">$checkSum</span> = <span class="title function_ invoke__">generateCheckSum</span>(<span class="variable">$data</span>);</span><br><span class="line">    <span class="comment">//组装报文</span></span><br><span class="line">    <span class="variable">$packet</span>[<span class="variable">$nextSeqNum</span>] = <span class="title function_ invoke__">make_pkt</span>(<span class="variable">$data</span>, <span class="variable">$checkSum</span>, <span class="variable">$nextSeqNum</span>);</span><br><span class="line">    <span class="comment">//调用网络层传输 </span></span><br><span class="line">    <span class="title function_ invoke__">udt_send</span>(<span class="variable">$packet</span>[<span class="variable">$nextSeqNum</span>]);</span><br><span class="line">    <span class="comment">//只启动一个定时器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$base</span> == <span class="variable">$nextSeqNum</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">start_timer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果超时</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">timeout</span>()) &#123;</span><br><span class="line">        <span class="comment">//重传所有已发送的分组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="variable">$base</span>; <span class="variable">$i</span> &lt;= <span class="variable">$nextSeqNum</span> - <span class="number">1</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="title function_ invoke__">udt_send</span>(<span class="variable">$packet</span>[<span class="variable">$i</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">$isAck</span> = <span class="title function_ invoke__">rdt_rev</span>() &amp;&amp; <span class="title function_ invoke__">check</span>(<span class="variable">$isAck</span>)) &#123;</span><br><span class="line">        <span class="comment">//等待接收方回传ack 并且没有出现错误</span></span><br><span class="line">        <span class="comment">//获取确认的序号</span></span><br><span class="line">        <span class="variable">$ackNum</span> = <span class="title function_ invoke__">getAckNum</span>(<span class="variable">$isAck</span>);</span><br><span class="line">        <span class="comment">//确认这个序号之前所有的分组</span></span><br><span class="line">        <span class="variable">$base</span> = <span class="variable">$ackNum</span>;</span><br><span class="line">        <span class="comment">//如果确认了最新的分组，那么停止定时器</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$base</span> == <span class="variable">$nextSeqNum</span>) &#123;</span><br><span class="line">            <span class="title function_ invoke__">stop_timer</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">start_timer</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h4><p>GBN的接收端较为简单，因为接收端只需要按序号交付数据就可以了。如果数据没有按序到达接收端，接收端只需要直接丢弃，因为发送端会重传所有分组。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//期望的序号</span></span><br><span class="line"><span class="variable">$expackNum</span> = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_rev</span>(<span class="params"><span class="variable">$packet</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//差错检测通过了并且报文序号正确</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">check</span>(<span class="variable">$packet</span>) &amp;&amp; <span class="variable">$packet</span>[<span class="string">&#x27;num&#x27;</span>] == <span class="variable">$expackNum</span>) &#123;</span><br><span class="line">        <span class="comment">//解析报文</span></span><br><span class="line">        <span class="variable">$data</span> = <span class="title function_ invoke__">extract</span>(<span class="variable">$packet</span>);</span><br><span class="line">        <span class="comment">//序号对的</span></span><br><span class="line">        <span class="comment">//没有错，把数据交付给应用层并回传ack</span></span><br><span class="line">        <span class="comment">//把数据给应用层</span></span><br><span class="line">        <span class="title function_ invoke__">deliver_data</span>(<span class="variable">$data</span>);</span><br><span class="line">        <span class="comment">//回传ACK</span></span><br><span class="line">        <span class="variable">$ack</span> = <span class="title function_ invoke__">make_pkt</span>(<span class="number">1</span>, <span class="variable">$expackNum</span>);</span><br><span class="line">        <span class="variable">$expackNum</span>++;</span><br><span class="line">        <span class="title function_ invoke__">udt_send</span>(<span class="variable">$ack</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没通过差错检测或者序号错误，我们回传一个上一个ack，告诉发送端上一个分组我们收到了，当前分组没收到。</span></span><br><span class="line">        <span class="comment">//回传ACK</span></span><br><span class="line">        <span class="variable">$ack</span> = <span class="title function_ invoke__">make_pkt</span>(<span class="number">1</span>, <span class="variable">$expackNum</span>);</span><br><span class="line">        <span class="title function_ invoke__">udt_send</span>(<span class="variable">$ack</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="SR"><a href="#SR" class="headerlink" title="SR"></a>SR</h3><p>在SR中，和GBN不同，SR是给每一个分组设置定时器，发送端只确认重传当前分组，而不是所有分组。接收端在接收到乱序的分组的时候会进行缓存，当前面的分组到达以后一起提交给应用层。</p>
<h4 id="发送端-1"><a href="#发送端-1" class="headerlink" title="发送端"></a>发送端</h4><ul>
<li>等待上层调用。这里和GBN一样</li>
<li>超时。超时哪个重传哪个</li>
<li>收到ACK。如果收到的是最小序号的ACK，那么base可以往前移动，也就是窗口滑动。如果收到其他序号的ACK。那么把这些ACK缓存。</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序号</span></span><br><span class="line"><span class="variable">$base</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable">$nextSeqNum</span> = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_send</span>(<span class="params"><span class="variable">$data</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//生成校验和</span></span><br><span class="line">    <span class="variable">$checkSum</span> = <span class="title function_ invoke__">generateCheckSum</span>(<span class="variable">$data</span>);</span><br><span class="line">    <span class="comment">//组装报文</span></span><br><span class="line">    <span class="variable">$packet</span>[<span class="variable">$nextSeqNum</span>] = <span class="title function_ invoke__">make_pkt</span>(<span class="variable">$data</span>, <span class="variable">$checkSum</span>, <span class="variable">$nextSeqNum</span>);</span><br><span class="line">    <span class="comment">//调用网络层传输 </span></span><br><span class="line">    <span class="title function_ invoke__">udt_send</span>(<span class="variable">$packet</span>[<span class="variable">$nextSeqNum</span>]);</span><br><span class="line">    <span class="comment">//每个启动一个定时器</span></span><br><span class="line">    <span class="title function_ invoke__">start_timer</span>(<span class="variable">$nextSeqNum</span>);    </span><br><span class="line">    <span class="comment">//如果超时</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$timeNum</span> = <span class="title function_ invoke__">timeout</span>()) &#123;</span><br><span class="line">        <span class="comment">//重传超时的分组</span></span><br><span class="line">        <span class="title function_ invoke__">udt_send</span>(<span class="variable">$packet</span>[<span class="variable">$timeNum</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">$isAck</span> = <span class="title function_ invoke__">rdt_rev</span>() &amp;&amp; <span class="title function_ invoke__">check</span>(<span class="variable">$isAck</span>)) &#123;</span><br><span class="line">        <span class="comment">//等待接收方回传ack 并且没有出现错误</span></span><br><span class="line">        <span class="comment">//获取确认的序号</span></span><br><span class="line">        <span class="variable">$ackNum</span> = <span class="title function_ invoke__">getAckNum</span>(<span class="variable">$isAck</span>);</span><br><span class="line">        <span class="title function_ invoke__">stop_timer</span>(<span class="variable">$ackNum</span>);</span><br><span class="line">        <span class="comment">//判断这个ACK是不是base</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$ackNum</span> == <span class="variable">$base</span>) &#123;</span><br><span class="line">            ++<span class="variable">$base</span>;</span><br><span class="line">            <span class="comment">//判断缓存有没有</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="title function_ invoke__">array_key_exists</span>(++<span class="variable">$ackNum</span>, <span class="variable">$cache</span>)) &#123;</span><br><span class="line">                <span class="comment">//如果下一个ack已经收到了，那么就把base接着往前移动</span></span><br><span class="line">                ++<span class="variable">$base</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//缓存起来</span></span><br><span class="line">            <span class="variable">$cache</span>[<span class="variable">$ackNum</span>] = <span class="variable">$ackNum</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接收端-1"><a href="#接收端-1" class="headerlink" title="接收端"></a>接收端</h4><ul>
<li>序号在rcv_base 至 rcv_base + N - 1内的分组被正确接受。如果该分组不是期望的分组，那么缓存，如果是，那么给应用层并且看缓存里面有没有后续，有就直接一起给应用层</li>
<li>序号在rcv_base - N 至 rcv_base - 1内的分组被正确接受。返回一个确认ACK。表示我已经收到了。</li>
<li>其他情况。忽略分组</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//期望的序号</span></span><br><span class="line"><span class="variable">$expackNum</span> = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_rev</span>(<span class="params"><span class="variable">$packet</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//差错检测通过了并且报文序号正确</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">check</span>(<span class="variable">$packet</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$packet</span>[<span class="string">&#x27;num&#x27;</span>] &gt; <span class="variable">$expackNum</span> &amp;&amp; <span class="variable">$packet</span>[<span class="string">&#x27;num&#x27;</span>] &lt; <span class="variable">$expackNum</span> + N - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$packet</span>[<span class="string">&#x27;num&#x27;</span>] == <span class="variable">$expackNum</span>) &#123;</span><br><span class="line">                <span class="comment">//是我们期望的，直接给应用层</span></span><br><span class="line">                <span class="comment">//解析报文</span></span><br><span class="line">                <span class="variable">$data</span> = <span class="title function_ invoke__">extract</span>(<span class="variable">$packet</span>);</span><br><span class="line">                <span class="comment">//序号对的</span></span><br><span class="line">                <span class="comment">//没有错，把数据交付给应用层并回传ack</span></span><br><span class="line">                <span class="comment">//把数据给应用层</span></span><br><span class="line">                <span class="title function_ invoke__">deliver_data</span>(<span class="variable">$data</span>);</span><br><span class="line">                <span class="comment">//回传ACK</span></span><br><span class="line">                <span class="variable">$ack</span> = <span class="title function_ invoke__">make_pkt</span>(<span class="number">1</span>, <span class="variable">$expackNum</span>);</span><br><span class="line">                <span class="variable">$expackNum</span>++;</span><br><span class="line">                <span class="title function_ invoke__">udt_send</span>(<span class="variable">$ack</span>);</span><br><span class="line">                <span class="comment">//查询缓存里面有没有</span></span><br><span class="line">                <span class="variable">$key</span> = <span class="variable">$expackNum</span> + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="title function_ invoke__">array_key_exists</span>(<span class="variable">$key</span>, <span class="variable">$cache</span>)) &#123;</span><br><span class="line">                    <span class="comment">//如果下一个分组已经收到了，那么给应用层，并且滑动窗口</span></span><br><span class="line">                    <span class="title function_ invoke__">deliver_data</span>(<span class="variable">$cache</span>[<span class="variable">$expackNum</span>]);</span><br><span class="line">                    ++<span class="variable">$expackNum</span>;</span><br><span class="line">                    <span class="variable">$key</span>++;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//缓存分组</span></span><br><span class="line">                <span class="variable">$cache</span>[<span class="variable">$packet</span>[<span class="string">&#x27;num&#x27;</span>]] = <span class="variable">$packet</span>;</span><br><span class="line">                <span class="comment">//回传ACK</span></span><br><span class="line">                <span class="variable">$ack</span> = <span class="title function_ invoke__">make_pkt</span>(<span class="number">1</span>, <span class="variable">$packet</span>[<span class="string">&#x27;num&#x27;</span>]);</span><br><span class="line">                <span class="title function_ invoke__">udt_send</span>(<span class="variable">$ack</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没通过差错检测或者序号错误，我们回传一个上一个ack，告诉发送端上一个分组我们收到了，当前分组没收到。</span></span><br><span class="line">        <span class="comment">//回传ACK</span></span><br><span class="line">        <span class="variable">$ack</span> = <span class="title function_ invoke__">make_pkt</span>(<span class="number">1</span>, <span class="variable">$expackNum</span>);</span><br><span class="line">        <span class="title function_ invoke__">udt_send</span>(<span class="variable">$ack</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络原理自顶向下三可靠数据传输原理实现SR选择重传协议</title>
    <url>/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B8%89%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0SR%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0%E5%8D%8F%E8%AE%AE.html</url>
    <content><![CDATA[<h1 id="网络原理自顶向下三可靠数据传输原理实现SR选择重传协议"><a href="#网络原理自顶向下三可靠数据传输原理实现SR选择重传协议" class="headerlink" title="网络原理自顶向下三可靠数据传输原理实现SR选择重传协议"></a>网络原理自顶向下三可靠数据传输原理实现SR选择重传协议</h1><h3 id="SR"><a href="#SR" class="headerlink" title="SR"></a>SR</h3><p>在SR中，和GBN不同，SR是给每一个分组设置定时器，发送端只确认重传当前分组，而不是所有分组。接收端在接收到乱序的分组的时候会进行缓存，当前面的分组到达以后一起提交给应用层。</p>
<h4 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h4><ul>
<li>等待上层调用。这里和GBN一样</li>
<li>超时。超时哪个重传哪个</li>
<li>收到ACK。如果收到的是最小序号的ACK，那么base可以往前移动，也就是窗口滑动。如果收到其他序号的ACK。那么把这些ACK缓存。</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序号</span></span><br><span class="line"><span class="variable">$base</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable">$nextSeqNum</span> = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_send</span>(<span class="params"><span class="variable">$data</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//生成校验和</span></span><br><span class="line">    <span class="variable">$checkSum</span> = <span class="title function_ invoke__">generateCheckSum</span>(<span class="variable">$data</span>);</span><br><span class="line">    <span class="comment">//组装报文</span></span><br><span class="line">    <span class="variable">$packet</span>[<span class="variable">$nextSeqNum</span>] = <span class="title function_ invoke__">make_pkt</span>(<span class="variable">$data</span>, <span class="variable">$checkSum</span>, <span class="variable">$nextSeqNum</span>);</span><br><span class="line">    <span class="comment">//调用网络层传输 </span></span><br><span class="line">    <span class="title function_ invoke__">udt_send</span>(<span class="variable">$packet</span>[<span class="variable">$nextSeqNum</span>]);</span><br><span class="line">    <span class="comment">//每个启动一个定时器</span></span><br><span class="line">    <span class="title function_ invoke__">start_timer</span>(<span class="variable">$nextSeqNum</span>);    </span><br><span class="line">    <span class="comment">//如果超时</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$timeNum</span> = <span class="title function_ invoke__">timeout</span>()) &#123;</span><br><span class="line">        <span class="comment">//重传超时的分组</span></span><br><span class="line">        <span class="title function_ invoke__">udt_send</span>(<span class="variable">$packet</span>[<span class="variable">$timeNum</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">$isAck</span> = <span class="title function_ invoke__">rdt_rev</span>() &amp;&amp; <span class="title function_ invoke__">check</span>(<span class="variable">$isAck</span>)) &#123;</span><br><span class="line">        <span class="comment">//等待接收方回传ack 并且没有出现错误</span></span><br><span class="line">        <span class="comment">//获取确认的序号</span></span><br><span class="line">        <span class="variable">$ackNum</span> = <span class="title function_ invoke__">getAckNum</span>(<span class="variable">$isAck</span>);</span><br><span class="line">        <span class="title function_ invoke__">stop_timer</span>(<span class="variable">$ackNum</span>);</span><br><span class="line">        <span class="comment">//判断这个ACK是不是base</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$ackNum</span> == <span class="variable">$base</span>) &#123;</span><br><span class="line">            ++<span class="variable">$base</span>;</span><br><span class="line">            <span class="comment">//判断缓存有没有</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="title function_ invoke__">array_key_exists</span>(++<span class="variable">$ackNum</span>, <span class="variable">$cache</span>)) &#123;</span><br><span class="line">                <span class="comment">//如果下一个ack已经收到了，那么就把base接着往前移动</span></span><br><span class="line">                ++<span class="variable">$base</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//缓存起来</span></span><br><span class="line">            <span class="variable">$cache</span>[<span class="variable">$ackNum</span>] = <span class="variable">$ackNum</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h4><ul>
<li>序号在rcv_base 至 rcv_base + N - 1内的分组被正确接受。如果该分组不是期望的分组，那么缓存，如果是，那么给应用层并且看缓存里面有没有后续，有就直接一起给应用层</li>
<li>序号在rcv_base - N 至 rcv_base - 1内的分组被正确接受。返回一个确认ACK。表示我已经收到了。</li>
<li>其他情况。忽略分组</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//期望的序号</span></span><br><span class="line"><span class="variable">$expackNum</span> = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_rev</span>(<span class="params"><span class="variable">$packet</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//差错检测通过了并且报文序号正确</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">check</span>(<span class="variable">$packet</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$packet</span>[<span class="string">&#x27;num&#x27;</span>] &gt; <span class="variable">$expackNum</span> &amp;&amp; <span class="variable">$packet</span>[<span class="string">&#x27;num&#x27;</span>] &lt; <span class="variable">$expackNum</span> + N - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$packet</span>[<span class="string">&#x27;num&#x27;</span>] == <span class="variable">$expackNum</span>) &#123;</span><br><span class="line">                <span class="comment">//是我们期望的，直接给应用层</span></span><br><span class="line">                <span class="comment">//解析报文</span></span><br><span class="line">                <span class="variable">$data</span> = <span class="title function_ invoke__">extract</span>(<span class="variable">$packet</span>);</span><br><span class="line">                <span class="comment">//序号对的</span></span><br><span class="line">                <span class="comment">//没有错，把数据交付给应用层并回传ack</span></span><br><span class="line">                <span class="comment">//把数据给应用层</span></span><br><span class="line">                <span class="title function_ invoke__">deliver_data</span>(<span class="variable">$data</span>);</span><br><span class="line">                <span class="comment">//回传ACK</span></span><br><span class="line">                <span class="variable">$ack</span> = <span class="title function_ invoke__">make_pkt</span>(<span class="number">1</span>, <span class="variable">$expackNum</span>);</span><br><span class="line">                <span class="variable">$expackNum</span>++;</span><br><span class="line">                <span class="title function_ invoke__">udt_send</span>(<span class="variable">$ack</span>);</span><br><span class="line">                <span class="comment">//查询缓存里面有没有</span></span><br><span class="line">                <span class="variable">$key</span> = <span class="variable">$expackNum</span> + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="title function_ invoke__">array_key_exists</span>(<span class="variable">$key</span>, <span class="variable">$cache</span>)) &#123;</span><br><span class="line">                    <span class="comment">//如果下一个分组已经收到了，那么给应用层，并且滑动窗口</span></span><br><span class="line">                    <span class="title function_ invoke__">deliver_data</span>(<span class="variable">$cache</span>[<span class="variable">$expackNum</span>]);</span><br><span class="line">                    ++<span class="variable">$expackNum</span>;</span><br><span class="line">                    <span class="variable">$key</span>++;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//缓存分组</span></span><br><span class="line">                <span class="variable">$cache</span>[<span class="variable">$packet</span>[<span class="string">&#x27;num&#x27;</span>]] = <span class="variable">$packet</span>;</span><br><span class="line">                <span class="comment">//回传ACK</span></span><br><span class="line">                <span class="variable">$ack</span> = <span class="title function_ invoke__">make_pkt</span>(<span class="number">1</span>, <span class="variable">$packet</span>[<span class="string">&#x27;num&#x27;</span>]);</span><br><span class="line">                <span class="title function_ invoke__">udt_send</span>(<span class="variable">$ack</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没通过差错检测或者序号错误，我们回传一个上一个ack，告诉发送端上一个分组我们收到了，当前分组没收到。</span></span><br><span class="line">        <span class="comment">//回传ACK</span></span><br><span class="line">        <span class="variable">$ack</span> = <span class="title function_ invoke__">make_pkt</span>(<span class="number">1</span>, <span class="variable">$expackNum</span>);</span><br><span class="line">        <span class="title function_ invoke__">udt_send</span>(<span class="variable">$ack</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络原理自顶向下三可靠数据传输原理实现停等协议</title>
    <url>/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B8%89%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E5%81%9C%E7%AD%89%E5%8D%8F%E8%AE%AE.html</url>
    <content><![CDATA[<h1 id="网络原理自顶向下三可靠数据传输原理实现停等协议"><a href="#网络原理自顶向下三可靠数据传输原理实现停等协议" class="headerlink" title="网络原理自顶向下三可靠数据传输原理实现停等协议"></a>网络原理自顶向下三可靠数据传输原理实现停等协议</h1><p>这里仅考虑<code>单向可靠数据传输</code>。而不是<code>双向可靠数据传输</code>。</p>
<h2 id="构造可靠数据传输协议"><a href="#构造可靠数据传输协议" class="headerlink" title="构造可靠数据传输协议"></a>构造可靠数据传输协议</h2><h3 id="经完全可靠信道的可靠数据传输-rdt1-0版本"><a href="#经完全可靠信道的可靠数据传输-rdt1-0版本" class="headerlink" title="经完全可靠信道的可靠数据传输 rdt1.0版本"></a>经完全可靠信道的可靠数据传输 rdt1.0版本</h3><p>首先考虑最简单的版本，底层信道完全可靠。</p>
<h4 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h4><p>发送端应用层只需要调用<code>rdt_send</code>函数。网络层提供了一个函数<code>udt_send</code>来给运输层调用。现在假设<code>udt_send</code>是可靠的。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_send</span>(<span class="params"><span class="variable">$data</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//组装报文</span></span><br><span class="line">    <span class="variable">$packet</span> = <span class="title function_ invoke__">make_pkt</span>(<span class="variable">$data</span>);</span><br><span class="line">    <span class="comment">//调用网络层传输</span></span><br><span class="line">    <span class="title function_ invoke__">udt_send</span>(<span class="variable">$packet</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h4><p>接收端网络层只需要调用<code>rdt_rev</code>函数。应用层提供了一个<code>deliver_data</code>函数来接受运输层的数据。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_rev</span>(<span class="params"><span class="variable">$packet</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//解析报文</span></span><br><span class="line">    <span class="variable">$data</span> = <span class="title function_ invoke__">extract</span>(<span class="variable">$packet</span>);</span><br><span class="line">    <span class="comment">//把数据给应用层</span></span><br><span class="line">    <span class="title function_ invoke__">deliver_data</span>(<span class="variable">$data</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h4><p>再来画一下对应的有限状态机（FSM）.</p>
<p>发送端只有一个状态，<code>等待调用</code>。</p>
<p><img src="/"></p>
<p>接收端也只有一个状态，<code>等待调用</code>。</p>
<p><img src="/"></p>
<h3 id="经比特差错信道的可靠数据传输rdt2-0"><a href="#经比特差错信道的可靠数据传输rdt2-0" class="headerlink" title="经比特差错信道的可靠数据传输rdt2.0"></a>经比特差错信道的可靠数据传输rdt2.0</h3><p>现在底层信道有可能造成比特的错误。</p>
<p>回想一下打电话的时候，如果我们说的话对方没听清，会怎么样。会<code>再说一遍</code>也就是<code>重传</code>。</p>
<p>那么什么情况下会<code>重传</code>。当接收方说<code>我没听清</code>的时候。</p>
<p>所以在<code>rdt2.0</code>里面我们让接收方接受完信息后回传一个标志，告诉我们<code>正确</code>还是<code>错误</code>。</p>
<p>如果正确，那么我们继续等待调用。</p>
<p>如果错误，那么我们<code>重传</code>。</p>
<p>基于这样重传机制的可靠数据传输协议称为<code>自动重传请求协议</code>（Automatic Repeat reQuest）ARQ,需要下面三个功能</p>
<ul>
<li>差错检测</li>
<li>接收方回传ack或者nak</li>
<li>重传</li>
</ul>
<h4 id="发送端-1"><a href="#发送端-1" class="headerlink" title="发送端"></a>发送端</h4><p>看一下发送端的简单实现</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_send</span>(<span class="params"><span class="variable">$data</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//生成校验和</span></span><br><span class="line">    <span class="variable">$checkSum</span> = <span class="title function_ invoke__">generateCheckSum</span>(<span class="variable">$data</span>);</span><br><span class="line">    <span class="comment">//组装报文</span></span><br><span class="line">    <span class="variable">$packet</span> = <span class="title function_ invoke__">make_pkt</span>(<span class="variable">$data</span>, <span class="variable">$checkSum</span>);</span><br><span class="line">    <span class="comment">//调用网络层传输 </span></span><br><span class="line">    <span class="title function_ invoke__">udt_send</span>(<span class="variable">$packet</span>);</span><br><span class="line">    <span class="comment">//等待接收方回传ack或者nak</span></span><br><span class="line">    <span class="variable">$isAck</span> = <span class="title function_ invoke__">rdt_rev</span>();</span><br><span class="line">    <span class="comment">//判断ack</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$isAck</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//收到了Ack分组，可以结束了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">$isAck</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//收到了Nak分组，需要重传</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">rdt_send</span>(<span class="variable">$data</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接收端-1"><a href="#接收端-1" class="headerlink" title="接收端"></a>接收端</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_rev</span>(<span class="params"><span class="variable">$packet</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//差错检测</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">check</span>(<span class="variable">$packet</span>)) &#123;</span><br><span class="line">        <span class="comment">//解析报文</span></span><br><span class="line">        <span class="variable">$data</span> = <span class="title function_ invoke__">extract</span>(<span class="variable">$packet</span>);</span><br><span class="line">        <span class="comment">//没有错，把数据交付给应用层并回传ack</span></span><br><span class="line">        <span class="comment">//把数据给应用层</span></span><br><span class="line">        <span class="title function_ invoke__">deliver_data</span>(<span class="variable">$data</span>);</span><br><span class="line">        <span class="comment">//回传ACK</span></span><br><span class="line">        <span class="variable">$ack</span> = <span class="title function_ invoke__">make_pkt</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="title function_ invoke__">udt_send</span>(<span class="variable">$ack</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//有错，回传一个nak，不交付数据</span></span><br><span class="line">        <span class="variable">$nak</span> = <span class="title function_ invoke__">make_pkt</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="title function_ invoke__">udt_send</span>(<span class="variable">$nak</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><p>现在发送端有两个状态</p>
<ul>
<li>等待调用</li>
<li>等待返回ack或nak</li>
</ul>
<p>接收端还是一个状态</p>
<ul>
<li>等待调用</li>
</ul>
<p>rdt2.0也被称为<code>停等协议</code>。因为发送端处于<code>等待ack</code>状态是不能被上层调用的。</p>
<h3 id="ack受损rdt2-1"><a href="#ack受损rdt2-1" class="headerlink" title="ack受损rdt2.1"></a>ack受损rdt2.1</h3><p>从上面的代码可以看出来，接收端发送<code>ack</code>使用的是<code>udt_send</code>函数，这个函数是不可靠的。那么如果我们的<code>ack</code>或者<code>nak</code>损坏了怎么办。</p>
<p>这时候可以像处理损坏分组一样。我们校验ack是否受损，如果受损，那么我们重传分组。</p>
<p>可是重传分组就会造成接收方不知道这个分组我有没有收到过。所以我们需要增加<code>分组序号</code>。</p>
<p>对于停等协议来说，0和1就够用了。因为停等协议只有两个状态，发完会等待ack。</p>
<h4 id="发送端-2"><a href="#发送端-2" class="headerlink" title="发送端"></a>发送端</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序号</span></span><br><span class="line"><span class="variable">$num</span> = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_send</span>(<span class="params"><span class="variable">$data</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//生成校验和</span></span><br><span class="line">    <span class="variable">$checkSum</span> = <span class="title function_ invoke__">generateCheckSum</span>(<span class="variable">$data</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//组装报文</span></span><br><span class="line">    <span class="variable">$packet</span> = <span class="title function_ invoke__">make_pkt</span>(<span class="variable">$data</span>, <span class="variable">$checkSum</span>, <span class="variable">$num</span>);</span><br><span class="line">    <span class="comment">//调用网络层传输 </span></span><br><span class="line">    <span class="title function_ invoke__">udt_send</span>(<span class="variable">$packet</span>);</span><br><span class="line">    <span class="comment">//等待接收方回传ack或者nak</span></span><br><span class="line">    <span class="variable">$isAck</span> = <span class="title function_ invoke__">rdt_rev</span>();</span><br><span class="line">    <span class="comment">//差错检测</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">check</span>(<span class="variable">$isAck</span>)) &#123;</span><br><span class="line">        <span class="comment">//没出问题，那么把改变序号</span></span><br><span class="line">        <span class="variable">$num</span> = !<span class="variable">$num</span>;</span><br><span class="line">        <span class="comment">//判断ack</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$isAck</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//收到了Ack分组，可以结束了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">$isAck</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//收到了Nak分组，需要重传</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">rdt_send</span>(<span class="variable">$data</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//ack出问题了，那么这个时候重传</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">rdt_send</span>(<span class="variable">$data</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接收端-2"><a href="#接收端-2" class="headerlink" title="接收端"></a>接收端</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序号</span></span><br><span class="line"><span class="variable">$num</span> = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_rev</span>(<span class="params"><span class="variable">$packet</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//差错检测</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">check</span>(<span class="variable">$packet</span>)) &#123;</span><br><span class="line">        <span class="comment">//判断报文序号</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$packet</span>[<span class="string">&#x27;num&#x27;</span>] == <span class="variable">$num</span>) &#123;</span><br><span class="line">            <span class="comment">//解析报文</span></span><br><span class="line">            <span class="variable">$data</span> = <span class="title function_ invoke__">extract</span>(<span class="variable">$packet</span>);</span><br><span class="line">            <span class="comment">//序号对的</span></span><br><span class="line">            <span class="comment">//没有错，把数据交付给应用层并回传ack</span></span><br><span class="line">            <span class="comment">//把数据给应用层</span></span><br><span class="line">            <span class="title function_ invoke__">deliver_data</span>(<span class="variable">$data</span>);</span><br><span class="line">            <span class="comment">//回传ACK</span></span><br><span class="line">            <span class="variable">$ack</span> = <span class="title function_ invoke__">make_pkt</span>(<span class="number">1</span>, <span class="variable">$num</span>);</span><br><span class="line">            <span class="title function_ invoke__">udt_send</span>(<span class="variable">$ack</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//序号错了，说明这不是我们要的，我们回传一个ack，告诉发送端这个分组我们收到了。</span></span><br><span class="line">            <span class="comment">//回传ACK</span></span><br><span class="line">            <span class="variable">$ack</span> = <span class="title function_ invoke__">make_pkt</span>(<span class="number">1</span>, <span class="variable">$num</span>);</span><br><span class="line">            <span class="title function_ invoke__">udt_send</span>(<span class="variable">$ack</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//有错，回传一个nak，不交付数据</span></span><br><span class="line">        <span class="variable">$nak</span> = <span class="title function_ invoke__">make_pkt</span>(<span class="number">0</span>, <span class="variable">$num</span>);</span><br><span class="line">        <span class="title function_ invoke__">udt_send</span>(<span class="variable">$nak</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="状态机-1"><a href="#状态机-1" class="headerlink" title="状态机"></a>状态机</h4><p>发送端有4个状态</p>
<ul>
<li>等待调用0</li>
<li>等待ack0或者nak0</li>
<li>等待调用1</li>
<li>等待ack1或者nak1</li>
</ul>
<p>接收端有2个状态</p>
<ul>
<li>等待调用0</li>
<li>等待调用1</li>
</ul>
<h3 id="去掉nak分组的rdt2-2"><a href="#去掉nak分组的rdt2-2" class="headerlink" title="去掉nak分组的rdt2.2"></a>去掉nak分组的rdt2.2</h3><p>从上面的代码可以看出来，发送端在接收到<code>nak</code>的时候和丢失<code>ack</code>或者<code>nak</code>的时候都是重传。<br>所以我们只需要判断<code>ack</code>就可以了。那么同样接收方只需要回传<code>ack</code>就可以了。<br>这样一来，代码更见简单了。</p>
<h4 id="发送端-3"><a href="#发送端-3" class="headerlink" title="发送端"></a>发送端</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序号</span></span><br><span class="line"><span class="variable">$num</span> = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_send</span>(<span class="params"><span class="variable">$data</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//生成校验和</span></span><br><span class="line">    <span class="variable">$checkSum</span> = <span class="title function_ invoke__">generateCheckSum</span>(<span class="variable">$data</span>);</span><br><span class="line">    <span class="comment">//组装报文</span></span><br><span class="line">    <span class="variable">$packet</span> = <span class="title function_ invoke__">make_pkt</span>(<span class="variable">$data</span>, <span class="variable">$checkSum</span>, <span class="variable">$num</span>);</span><br><span class="line">    <span class="comment">//调用网络层传输 </span></span><br><span class="line">    <span class="title function_ invoke__">udt_send</span>(<span class="variable">$packet</span>);</span><br><span class="line">    <span class="comment">//等待接收方回传ack</span></span><br><span class="line">    <span class="variable">$isAck</span> = <span class="title function_ invoke__">rdt_rev</span>();</span><br><span class="line">    <span class="comment">//差错检测</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">check</span>(<span class="variable">$isAck</span>) &amp;&amp; <span class="variable">$isAck</span>[<span class="string">&#x27;num&#x27;</span>] == <span class="variable">$num</span>) &#123;</span><br><span class="line">        <span class="comment">//没出问题，那么把改变序号</span></span><br><span class="line">        <span class="variable">$num</span> = !<span class="variable">$num</span>;</span><br><span class="line">        <span class="comment">//收到了Ack分组，可以结束了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//ack出问题了，那么这个时候重传</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">rdt_send</span>(<span class="variable">$data</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接收端-3"><a href="#接收端-3" class="headerlink" title="接收端"></a>接收端</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序号</span></span><br><span class="line"><span class="variable">$num</span> = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_rev</span>(<span class="params"><span class="variable">$packet</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//差错检测通过了并且报文序号正确</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">check</span>(<span class="variable">$packet</span>) &amp;&amp; <span class="variable">$packet</span>[<span class="string">&#x27;num&#x27;</span>] == <span class="variable">$num</span>) &#123;</span><br><span class="line">        <span class="comment">//解析报文</span></span><br><span class="line">        <span class="variable">$data</span> = <span class="title function_ invoke__">extract</span>(<span class="variable">$packet</span>);</span><br><span class="line">        <span class="comment">//序号对的</span></span><br><span class="line">        <span class="comment">//没有错，把数据交付给应用层并回传ack</span></span><br><span class="line">        <span class="comment">//把数据给应用层</span></span><br><span class="line">        <span class="title function_ invoke__">deliver_data</span>(<span class="variable">$data</span>);</span><br><span class="line">        <span class="comment">//回传ACK</span></span><br><span class="line">        <span class="variable">$ack</span> = <span class="title function_ invoke__">make_pkt</span>(<span class="number">1</span>, <span class="variable">$num</span>);</span><br><span class="line">        <span class="title function_ invoke__">udt_send</span>(<span class="variable">$ack</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没通过差错检测或者序号错误，我们回传一个上一个ack，告诉发送端上一个分组我们收到了，当前分组没收到。</span></span><br><span class="line">        <span class="comment">//回传ACK</span></span><br><span class="line">        <span class="variable">$ack</span> = <span class="title function_ invoke__">make_pkt</span>(<span class="number">1</span>, !<span class="variable">$num</span>);</span><br><span class="line">        <span class="title function_ invoke__">udt_send</span>(<span class="variable">$ack</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="状态机-2"><a href="#状态机-2" class="headerlink" title="状态机"></a>状态机</h4><p>发送端有4个状态</p>
<ul>
<li>等待调用0</li>
<li>等待ack0或者nak0</li>
<li>等待调用1</li>
<li>等待ack1或者nak1</li>
</ul>
<p>接收端有2个状态</p>
<ul>
<li>等待调用0</li>
<li>等待调用1</li>
</ul>
<h3 id="经具有比特差错的丢包信道的可靠数据传输rdt3-0"><a href="#经具有比特差错的丢包信道的可靠数据传输rdt3-0" class="headerlink" title="经具有比特差错的丢包信道的可靠数据传输rdt3.0"></a>经具有比特差错的丢包信道的可靠数据传输rdt3.0</h3><p>现在底层信道除了会出错，还会丢包了。</p>
<p>如果遇到丢包怎么办呢，也就是接收方接收不到数据了。这个时候也就回传不了<code>ack</code>。</p>
<p>那么可以在发送端加上超时机制。如果长时间没收到<code>ack</code>。那么就重传分组。</p>
<h4 id="发送端-4"><a href="#发送端-4" class="headerlink" title="发送端"></a>发送端</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序号</span></span><br><span class="line"><span class="variable">$num</span> = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_send</span>(<span class="params"><span class="variable">$data</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//生成校验和</span></span><br><span class="line">    <span class="variable">$checkSum</span> = <span class="title function_ invoke__">generateCheckSum</span>(<span class="variable">$data</span>);</span><br><span class="line">    <span class="comment">//组装报文</span></span><br><span class="line">    <span class="variable">$packet</span> = <span class="title function_ invoke__">make_pkt</span>(<span class="variable">$data</span>, <span class="variable">$checkSum</span>, <span class="variable">$num</span>);</span><br><span class="line">    <span class="comment">//调用网络层传输 </span></span><br><span class="line">    <span class="title function_ invoke__">udt_send</span>(<span class="variable">$packet</span>);</span><br><span class="line">    <span class="comment">//启动一个定时器</span></span><br><span class="line">    <span class="title function_ invoke__">start_timer</span>();</span><br><span class="line">    <span class="comment">//等待接收方回传ack 并且没有超时</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$isAck</span> = <span class="title function_ invoke__">rdt_rev</span>() &amp;&amp; !<span class="title function_ invoke__">timeout</span>()) &#123;</span><br><span class="line">        <span class="comment">//差错检测</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">check</span>(<span class="variable">$isAck</span>) &amp;&amp; <span class="variable">$isAck</span>[<span class="string">&#x27;num&#x27;</span>] == <span class="variable">$num</span>) &#123;</span><br><span class="line">            <span class="comment">//没出问题，那么把改变序号</span></span><br><span class="line">            <span class="variable">$num</span> = !<span class="variable">$num</span>;</span><br><span class="line">            <span class="comment">//收到了Ack分组，可以结束了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//ack出问题了，那么这个时候重传</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">rdt_send</span>(<span class="variable">$data</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没接收到ack或者超时 重发</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">rdt_send</span>(<span class="variable">$data</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接收端-4"><a href="#接收端-4" class="headerlink" title="接收端"></a>接收端</h4><p>无变化</p>
<h4 id="状态机-3"><a href="#状态机-3" class="headerlink" title="状态机"></a>状态机</h4><p>发送端</p>
<h2 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h2><p>停等协议的缺点是性能受限。因为每次要等待上一个ack回来才能发送下一个报文。</p>
<p>而采用<code>流水线</code>就是不等待ack直接发送下一个报文。</p>
<p>这样会有下面的影响</p>
<ul>
<li>必须增加序号范围，因为每个分组必须有序号</li>
<li>协议的发送方和接收方两端也许不得不缓存多个分组。</li>
<li>所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失，损坏及时延大的分组。解决流水线的差错恢复有两种基本方法：<ul>
<li>回退N步（Go Back N）GBN</li>
<li>选择重传（Selective Repeat）SR</li>
</ul>
</li>
</ul>
<h3 id="GBN"><a href="#GBN" class="headerlink" title="GBN"></a>GBN</h3><p><a href="https://blog.csdn.net/Thepatterraining/article/details/111138785">滑动窗口协议</a></p>
<h3 id="SR"><a href="#SR" class="headerlink" title="SR"></a>SR</h3><p><a href="https://blog.csdn.net/Thepatterraining/article/details/111138684">选择重传协议</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络原理自顶向下三运输层</title>
    <url>/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B8%89%E8%BF%90%E8%BE%93%E5%B1%82.html</url>
    <content><![CDATA[<h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="运输层和网络层的关系"><a href="#运输层和网络层的关系" class="headerlink" title="运输层和网络层的关系"></a>运输层和网络层的关系</h2><p>网络层是主机到主机，端到端的逻辑传输。</p>
<p>运输层是应用到应用，端口到端口的逻辑传输。</p>
<p>先由网络层送到主机，再通过运输层送到对应的端口程序中。</p>
<p>运输层将应用层报文封装成报文段交给网络层</p>
<p>将主机间交付扩展到进程间交付被称为<code>运输层的多路复用和多路分解</code></p>
<p>UDP提供不可靠服务</p>
<ul>
<li>差错检测</li>
<li>数据交付</li>
</ul>
<p>TCP提供可靠服务</p>
<ul>
<li>流量控制</li>
<li>序号</li>
<li>确认</li>
<li>定时器</li>
<li>拥塞控制</li>
</ul>
<h2 id="多路复用和多路分解"><a href="#多路复用和多路分解" class="headerlink" title="多路复用和多路分解"></a>多路复用和多路分解</h2><p>源主机使用多路复用把多个套接字进程的报文发送给目的主机</p>
<p>目的主机使用多路分解把报文发送给多个套接字进程</p>
<p>运输层需要再首部信息加入</p>
<ul>
<li>源端口号</li>
<li>目的端口号</li>
</ul>
<p>通过端口号来区分进程</p>
<p>UDP套接字通过二元组来标识</p>
<ul>
<li>目的端口号</li>
<li>目的ip<br>只要你的目的ip和端口号相同就算你的源ip和端口不一样，也会分解到同一个套接字</li>
</ul>
<p>TCP通过四元组来标识</p>
<ul>
<li>源ip</li>
<li>源端口</li>
<li>目的Ip</li>
<li>目的端口</li>
</ul>
<p>这是因为TCP会创建链接，一个TCP进程有一个“欢迎套接字”，用来等待程序过来，然后创建一个新的套接字来进行通信。</p>
<p>如果四元组一致会分解到一个套接字，不一致，会分解到另外的套接字。</p>
<h3 id="web服务器和TCP"><a href="#web服务器和TCP" class="headerlink" title="web服务器和TCP"></a>web服务器和TCP</h3><p>现在的计算机有线程的概念，所以TCP链接一般也不会创建多个进程来服务不同的客户端，而是创建多个线程套接字，通过分解到不同的线程套接字来服务多个客户端。</p>
<h2 id="无连接运输：UDP"><a href="#无连接运输：UDP" class="headerlink" title="无连接运输：UDP"></a>无连接运输：UDP</h2><p>UDP只提供了运输层最低限度的东西。</p>
<ul>
<li>差错检测</li>
<li>复用分解</li>
</ul>
<p>DNS是使用UDP的一个应用层协议.</p>
<p>UDP存在的意义及优势：</p>
<ul>
<li>关于发送什么数据以及何时发送的应用层控制更为精细。<br>采用UDP时，只要应用将数据给UDP,UDP就会直接传递给IP网络层。TCP有<code>拥塞控制</code>和重发机制，但是这样会需要更长的时间。因为实时应用通常要求最小的发送速率，不希望过分的延迟报文段的传送，且能容忍一部分数据丢失，TCP服务模型并不是特别适合这些应用的需要。这些应用使用UDP，并可以再应用层实现所需的，超出UDP的额外功能。</li>
<li>无需链接建立<br>TCP需要三次握手建立链接，UDP不需要。因此没有建立链接的时延。</li>
<li>无连接状态<br>TCP需要再端系统中维护链接状态。此链接状态包括接受和发送缓存，拥塞控制参数以及序号与确认号的参数。UDP一般能支持更多的活跃用户。</li>
<li>分组首部开销小<br>每个TCP报文段首部有20字节，UDP只有8字节</li>
</ul>
<p>UDP也可以通过应用层实现<code>可靠性传输</code>。比如chrome的<code>QUIC协议</code>。</p>
<h3 id="UDP报文段结构"><a href="#UDP报文段结构" class="headerlink" title="UDP报文段结构"></a>UDP报文段结构</h3><ul>
<li>首部字段 8字节<ul>
<li>源端口号 2字节</li>
<li>目的端口号 2字节</li>
<li>长度 2字节 数据长度</li>
<li>校验和 2字节 差错检测</li>
</ul>
</li>
<li>数据</li>
</ul>
<h3 id="UDP校验和"><a href="#UDP校验和" class="headerlink" title="UDP校验和"></a>UDP校验和</h3><p>发送方的UDP对报文段中的所有16比特字的和进行反码运算，求和时候遇到的任何溢出都被回卷。得到的结果被放在UDP报文段中的校验和字段。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>如果有三个16比特的字：</p>
<p>0110011001100000<br>0101010101010101<br>1000111100001100</p>
<p>计算他们的和</p>
<p> 0110011001100000<br>+0101010101010101<br>&#x3D;1011101110110101<br>+1000111100001100<br>&#x3D;0100101011000001</p>
<p>这个时候溢出了，把溢出的1加到后面<br>&#x3D;0100101011000010</p>
<p>进行反码运输，把1变0，0变1<br>&#x3D;1011010100111101</p>
<p>这就变成了校验和。</p>
<p>接收方将三个16比特和校验和加在一起，如果全是1，那么就没问题。如果有0，那么就有差错。</p>
<p>把上面的和加上校验和算一下<br> 0100101011000010<br>+1011010100111101<br>&#x3D;1111111111111111</p>
<p>UDP虽然实现了<code>差错检测</code>，但是没有<code>差错恢复</code>。他只是丢弃受损的报文段。其他实现是将受损的报文段交给应用程序并给出警告。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP提供<code>全双工服务</code>。双方都可以发送数据。</p>
<p>TCP首先建立连接。然后把数据引导到<code>发送缓存</code>中。从发送缓存中取出数据进行发送。取出的数量受限于<code>最大报文段长度</code>MSS。MSS一般根据<code>最大链路层帧长度</code>MTU。以太网和PPP链路层都具有1500MTU。所以MSS的典型值在1460 + 40字节的TCP&#x2F;IP首部长度。</p>
<p>TCP报文段结构：</p>
<ul>
<li>源端口号 16比特</li>
<li>目的端口号 16比特</li>
<li>序号 32比特</li>
<li>确认号 32比特</li>
<li>接收窗口 16比特 用于流量控制</li>
<li>首部长度 4比特</li>
<li>选项字段 可选变长</li>
<li>标志字段 6比特<ul>
<li>ACK用于确认</li>
<li>RST, SYN, FIN用于连接建立和删除</li>
<li>拥塞通告中使用 CWR和ECE字段</li>
<li>PSH置位标识接收方应立即将数据交给上层</li>
<li>URG用来指示紧急数据</li>
</ul>
</li>
<li>紧急数据指针字段 16比特</li>
<li>校验和 16比特</li>
</ul>
<h3 id="往返时间的估计与超时"><a href="#往返时间的估计与超时" class="headerlink" title="往返时间的估计与超时"></a>往返时间的估计与超时</h3><h4 id="估计往返时间"><a href="#估计往返时间" class="headerlink" title="估计往返时间"></a>估计往返时间</h4><p>估计一个SampleRTT作为样本，根据SampleRTT取平均值，也就是EstimatedRTT。</p>
<p>EstimatedRTT &#x3D; (1 - a) * EstimatedRTT + a * SmapleRTT</p>
<p>a的推荐值是0.125。</p>
<p>RTT的偏差用DevRTT表示</p>
<p>DevRTT &#x3D; (1 - b) * DevRTT + b * |SampleRTT - EstimatedRTT|</p>
<p>b的推荐值是0.25</p>
<h4 id="设置和管理重传超时间隔"><a href="#设置和管理重传超时间隔" class="headerlink" title="设置和管理重传超时间隔"></a>设置和管理重传超时间隔</h4><p>超时间隔应该 &gt;&#x3D; EstimatedRTT。但是也不能大太多</p>
<p>TimeoutInterval &#x3D; EstimatedRTT + 4 * DevRTT</p>
<p>TCP设置单一的定时器，每当超时一次超时时间会加倍，以免造成网络拥塞。</p>
<p>TCP收到同一个ACK三次，会进行快速重传而不等待定时器超时。</p>
<p>TCP采用的是GBN和SR的混合体。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>TCP有发送缓存和接收缓存。接收方把数据放入接收缓存，然后读取到应用层。</p>
<p>当发送数据太多，为防止接收缓存装不下，需要控制发送端发送数量。</p>
<p><code>接收窗口</code>字段就是这个作用，用来控制接收方还有多少空间。发送方就可以根据这个调整发送数量。</p>
<p>如果接收缓存已经满了。那么发送方依旧会发送1比特的数据。这样才能知道接收方变化后的接收缓存大小。</p>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><ul>
<li>第一步：发送一个SYN &#x3D; 1 Seq &#x3D; 随机序号</li>
<li>第二步：返回一个SYN &#x3D; 1 Seq &#x3D; 随机序号 Ack &#x3D; Seq + 1</li>
<li>第三步：SYN &#x3D; 0 Seq &#x3D; Ack Ack &#x3D; Seq + 1 可以携带数据</li>
</ul>
<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><ul>
<li>第一步：发送一个FIN &#x3D; 1</li>
<li>第二步：接收一个ACK</li>
<li>第三步：接收一个FIN &#x3D; 1</li>
<li>第四步：发送一个ACK</li>
</ul>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><ul>
<li><p>端到端的拥塞控制。网络层不提供支持，端系统观察网络层得到结果。</p>
</li>
<li><p>网络辅助的拥塞控制。</p>
</li>
<li><p>丢失的报文段表示拥塞，降低发送速率。</p>
</li>
<li><p>确认报文段表示顺利，提高发送速率</p>
</li>
<li><p>带宽检测，逐步提高发送速率，如果丢失超时就降低然后接着提高。</p>
</li>
</ul>
<h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>开始速率较小。大概MSS&#x2F;RTT.<br>每当收到一个确认，就增加一个MSS。也就是指数级增长，不断翻倍。<br>何时结束？</p>
<ul>
<li>遇到丢包超时</li>
<li>达到一个阈值</li>
</ul>
<p>结束慢启动进入拥塞避免模式</p>
<h4 id="拥塞避免模式"><a href="#拥塞避免模式" class="headerlink" title="拥塞避免模式"></a>拥塞避免模式</h4><p>不再郑家指数级，而是一个一个增长。线性增长</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu安装supervisor守护进程</title>
    <url>/ubuntu%E5%AE%89%E8%A3%85supervisor%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B.html</url>
    <content><![CDATA[<h1 id="supervisor"><a href="#supervisor" class="headerlink" title="supervisor"></a>supervisor</h1><p>supervisor是一个守护进程软件。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>ubuntu安装很简单。直接apt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install supervisor</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>修改配置项，加入我们的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/supervisor/conf.d/test.conf</span><br></pre></td></tr></table></figure>

<p>复制下面的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[program:命令名称]</span><br><span class="line">;目录</span><br><span class="line">;directory=/test 这里我注释掉了，如果你加上以后报错可以注释掉试试</span><br><span class="line">;执行的命令如果没有配置环境变量或者软连接请使用全路径</span><br><span class="line">command=php /test/think queue:listen --queue im</span><br><span class="line">process_name=%(program_name)s_%(process_num)02d;</span><br><span class="line">numprocs = 3</span><br><span class="line">autostart = true</span><br><span class="line">startsecs = 5</span><br><span class="line">autorestart = true</span><br><span class="line">startretries = 3</span><br><span class="line">;执行的linux用户</span><br><span class="line">user=root</span><br><span class="line">redirect_stderr = true</span><br><span class="line">stdout_logfile_maxbytes = 50MB</span><br><span class="line">stdout_logfile_backups = 20</span><br><span class="line">;日志位置</span><br><span class="line">stdout_logfile = /var/log/supervisor/queue_worker.log</span><br><span class="line">loglevel=info</span><br></pre></td></tr></table></figure>

<p>然后启动supervisor，因为是apt安装的，所以很好启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service supervisor start</span><br></pre></td></tr></table></figure>

<p>查看启动了没有，有两种方法，一种status命令，还有一种查看linux进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service supervisor status</span><br></pre></td></tr></table></figure>

<p>查看进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -aux |grep super</span><br></pre></td></tr></table></figure>

<p>再查看我们的命令挂起来没有。我们执行的php命令所以直接查看php</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -aux|grep php</span><br></pre></td></tr></table></figure>
<p>如果看见刚刚的命令就成功了。</p>
]]></content>
      <categories>
        <category>小工具</category>
      </categories>
      <tags>
        <tag>supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title>php-simplexml解析一个或多个结构的坑</title>
    <url>/php-simplexml%E8%A7%A3%E6%9E%90%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E7%BB%93%E6%9E%84%E7%9A%84%E5%9D%91.html</url>
    <content><![CDATA[<h1 id="php-simplexml解析一个或多个结构的坑"><a href="#php-simplexml解析一个或多个结构的坑" class="headerlink" title="php-simplexml解析一个或多个结构的坑"></a>php-simplexml解析一个或多个结构的坑</h1><p>php解析xml还是挺方便的，不管是正常的xml，还是加了一个命名空间或者前缀的xml。都可以通过<code>simplexml_load_string</code>函数来解析成数组或者对象。</p>
<h2 id="simplexml-load-string"><a href="#simplexml-load-string" class="headerlink" title="simplexml_load_string"></a>simplexml_load_string</h2><p>来看一下使用方法。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$xml</span> = <span class="string">&quot;&lt;reports&gt;&lt;report&gt;&lt;id&gt;1&lt;/id&gt;&lt;name&gt;张三&lt;/name&gt;&lt;/report&gt;&lt;/reports&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$arr</span> = (<span class="keyword">array</span>)<span class="title function_ invoke__">simplexml_load_string</span>(<span class="variable">$xml</span>);</span><br></pre></td></tr></table></figure>

<p>是不是很简单，如果你的带啦前缀或者命名空间也可以使用。下面带了s前缀</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$xml</span> = <span class="string">&quot;&lt;s:reports&gt;&lt;s:report&gt;&lt;s:id&gt;1&lt;/id&gt;&lt;s:name&gt;张三&lt;/name&gt;&lt;/report&gt;&lt;/reports&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$arr</span> = (<span class="keyword">array</span>)<span class="title function_ invoke__">simplexml_load_string</span>(<span class="variable">$xml</span>,<span class="string">&#x27;SimpleXMLElement&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;s&#x27;</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>但是如果带了多个前缀，这个函数就无能为力了，可以使用别的方法解析。</p>
<h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><p>不过这个函数解析一个和多个结果是不一样的，这里解析出来一定要做判断！！！</p>
<p>下面有两个report，解析出的结果是一个数组。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$xml</span> = <span class="string">&quot;&lt;reports&gt;&lt;report&gt;&lt;id&gt;1&lt;/id&gt;&lt;name&gt;张三&lt;/name&gt;&lt;/report&gt;&lt;report&gt;&lt;id&gt;1&lt;/id&gt;&lt;name&gt;张三&lt;/name&gt;&lt;/report&gt;&lt;/reports&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$arr</span> = (<span class="keyword">array</span>)<span class="title function_ invoke__">simplexml_load_string</span>(<span class="variable">$xml</span>);</span><br></pre></td></tr></table></figure>

<p>而上面只有一个report的时候，解析出来就是一个对象！！！</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title>php-thinkphp-报错Creating default object from empty value</title>
    <url>/php-thinkphp-%E6%8A%A5%E9%94%99Creating%20default%20object%20from%20empty%20value.html</url>
    <content><![CDATA[<h1 id="php-thinkphp-报错Creating-default-object-from-empty-value"><a href="#php-thinkphp-报错Creating-default-object-from-empty-value" class="headerlink" title="php-thinkphp-报错Creating default object from empty value"></a>php-thinkphp-报错Creating default object from empty value</h1><p>报错第一步，打印，打印日志，在你用到对象的地方，把对象都打印出来看看，你以为他是个对象，但他。。。不一定是个对象！！！</p>
<p>如果你确定你从数据库查询出来的没有错，是个对象，那么。。请看一下你别的对象是不是一个对象！！！</p>
<p>要相信报错，一定是对象错了，但你不确定，所以，请打印日志，如果你这里没问题，别人那里有问题，那么可能是参数的问题。打印日志在别人那就能看到你想的对象可能在他那里不是一个对象！！！</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title>thinkphp-queue队列使用</title>
    <url>/thinkphp-queue%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<h1 id="thinkphp-queue队列使用"><a href="#thinkphp-queue队列使用" class="headerlink" title="thinkphp-queue队列使用"></a>thinkphp-queue队列使用</h1><p>在我们写程序的时候，经常会用到队列来完成一些操作，关于队列的介绍和使用场景，注意事项可以看我的这个文章<a href="https://blog.csdn.net/Thepatterraining/article/details/105344675">你不知道的队列使用技巧</a></p>
<h2 id="在tp里面使用队列"><a href="#在tp里面使用队列" class="headerlink" title="在tp里面使用队列"></a>在tp里面使用队列</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>tp</code>框架提供了一个扩展包，叫做<code>think-queue</code>。我们先来安装这个扩展包。</p>
<blockquote>
<p>composer require topthink&#x2F;think-queue</p>
</blockquote>
<h3 id="配置消息队列"><a href="#配置消息队列" class="headerlink" title="配置消息队列"></a>配置消息队列</h3><p>等待安装完成之后，我们需要进行配置，消息队列的消息存放在哪里，可以配置成redis。</p>
<p>配置在你的<code>config/queue.php</code>里面。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&#x27;default&#x27;</span>     =&gt; <span class="string">&#x27;redis&#x27;</span>,  <span class="comment">//默认是sync，改成redis</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;connections&#x27;</span> =&gt; [</span><br><span class="line">        <span class="string">&#x27;redis&#x27;</span>    =&gt; [</span><br><span class="line">            <span class="string">&#x27;type&#x27;</span>       =&gt; <span class="string">&#x27;redis&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;queue&#x27;</span>      =&gt; <span class="string">&#x27;default&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;host&#x27;</span>       =&gt; <span class="title function_ invoke__">env</span>(<span class="string">&#x27;queue.host&#x27;</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;port&#x27;</span>       =&gt; <span class="title function_ invoke__">env</span>(<span class="string">&#x27;queue.port&#x27;</span>, <span class="number">6379</span>),</span><br><span class="line">            <span class="string">&#x27;password&#x27;</span>   =&gt; <span class="title function_ invoke__">env</span>(<span class="string">&#x27;queue.password&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;select&#x27;</span>     =&gt; <span class="number">0</span>,      <span class="comment">// 使用哪一个 db，默认为 db0</span></span><br><span class="line">            <span class="string">&#x27;timeout&#x27;</span>    =&gt; <span class="number">0</span>,      <span class="comment">// redis连接的超时时间</span></span><br><span class="line">            <span class="string">&#x27;persistent&#x27;</span> =&gt; <span class="literal">false</span>,  <span class="comment">// 是否是长连接</span></span><br><span class="line">        ],</span><br><span class="line">    ],</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="创建消息"><a href="#创建消息" class="headerlink" title="创建消息"></a>创建消息</h3><p>配置完成以后我们就可以开始使用了。</p>
<p>在我们的<code>controller</code>里面把一个消息推送到队列里面。这里我们定义一个队列名称叫做<code>message</code>,定义一个处理队列消息的消费者类<code>app\common\queue\consumer</code>。然后调用<code>Queue</code>门面的<code>push</code>方法，把消费者，队列名称，数据传入进去就可以了。这个时候就会把数据放到<code>message</code>这个队列里面。然后消费者取出数据进行处理。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">api</span>\<span class="title class_">controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">app</span>\<span class="title">BaseController</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">facade</span>\<span class="title">Queue</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">BaseController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$consumer</span> = <span class="string">&#x27;app\common\queue\consumer&#x27;</span>;  <span class="comment">//消费者类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$queue</span> = <span class="string">&#x27;message&#x27;</span>; <span class="comment">//队列名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;request-&gt;<span class="title function_ invoke__">isPost</span>()) &#123;</span><br><span class="line">            <span class="comment">//要推送到队列里面的数据</span></span><br><span class="line">            <span class="variable">$jobData</span> = [];</span><br><span class="line">            <span class="variable">$jobData</span>[<span class="string">&quot;a&quot;</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="variable">$jobData</span>[<span class="string">&#x27;b&#x27;</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="variable">$res</span> = <span class="title class_">Queue</span>::<span class="title function_ invoke__">push</span>(<span class="variable language_">$this</span>-&gt;consumer, <span class="variable">$data</span>, <span class="variable language_">$this</span>-&gt;queue);</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">json</span>([]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h3><p>我们接下来实现我们上面定义的消费者。来处理我们的逻辑。</p>
<p>消费者<code>app\common\queue\consumer</code>类。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">common</span>\<span class="title class_">queue</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">use</span> <span class="title">think</span>\<span class="title">queue</span>\<span class="title">Job</span>;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">consumer</span> </span>&#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * fire方法是消息队列默认调用的方法</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> Job            $job      当前的任务对象</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> array|mixed    $data     发布任务时自定义的数据</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">fire</span>(<span class="params">Job <span class="variable">$job</span>,<span class="variable">$data</span></span>)</span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="comment">// 有些消息在到达消费者时,可能已经不再需要执行了</span></span><br><span class="line">         <span class="variable">$isJobStillNeedToBeDone</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">check</span>(<span class="variable">$data</span>);</span><br><span class="line">         <span class="keyword">if</span>(!<span class="variable">$isJobStillNeedToBeDone</span>)&#123;</span><br><span class="line">             <span class="variable">$job</span>-&gt;<span class="title function_ invoke__">delete</span>();  <span class="comment">//删除任务</span></span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">       </span><br><span class="line">         <span class="comment">//执行任务</span></span><br><span class="line">         <span class="variable">$isJobDone</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">doJob</span>(<span class="variable">$data</span>);</span><br><span class="line">       </span><br><span class="line">         <span class="keyword">if</span> (<span class="variable">$isJobDone</span>) &#123;</span><br><span class="line">             <span class="comment">// 如果任务执行成功， 记得删除任务</span></span><br><span class="line">             <span class="variable">$job</span>-&gt;<span class="title function_ invoke__">delete</span>();</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (<span class="variable">$job</span>-&gt;<span class="title function_ invoke__">attempts</span>() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                 <span class="comment">//通过这个方法可以检查这个任务已经重试了几次了</span></span><br><span class="line"> 				  <span class="variable">$job</span>-&gt;<span class="title function_ invoke__">delete</span>();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 有些消息在到达消费者时,可能已经不再需要执行了</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> array|mixed    $data     发布任务时自定义的数据</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span> boolean                 任务执行的结果</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"><span class="variable">$data</span></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 根据消息中的数据进行实际的业务处理...</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">doJob</span>(<span class="params"><span class="variable">$data</span></span>) </span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="title function_ invoke__">dump</span>(<span class="variable">$data</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样我们就完成了代码的逻辑，也就是发布消息，消费消息。</p>
<p>接下来我们启动这个队列。</p>
<h3 id="启动队列"><a href="#启动队列" class="headerlink" title="启动队列"></a>启动队列</h3><p>启动队列有两种方式。</p>
<ul>
<li>work</li>
<li>listen</li>
</ul>
<p><code>work</code>方式启动。这种方式是单进程运行。如果你更新了代码需要手动重启队列。</p>
<blockquote>
<p>php think queue:work –queue message  &#x2F;&#x2F;我们刚刚定义的队列名称</p>
</blockquote>
<p><code>listen</code>方式启动。这种方式是master-worker模型。一个master主进程来监听，当请求进来了启动一个work子进程来运行上面的work方式启动。</p>
<blockquote>
<p>php think queue:listen –queue message</p>
</blockquote>
<p>我更推荐listen方式来运行。这种方式更新代码后也不需要手动重启。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>thinkphp</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>thinkphp-queue队列导致MySQL server has gone away</title>
    <url>/thinkphp-queue%E9%98%9F%E5%88%97%E5%AF%BC%E8%87%B4MySQL%20server%20has%20gone%20away.html</url>
    <content><![CDATA[<h1 id="thinkphp-queue队列导致MySQL-server-has-gone-away"><a href="#thinkphp-queue队列导致MySQL-server-has-gone-away" class="headerlink" title="thinkphp-queue队列导致MySQL server has gone away"></a>thinkphp-queue队列导致MySQL server has gone away</h1><p>虽然队列一时爽，不过还是有缺点的，比如当队列运行时间长了会报错 MySQL server has gone away</p>
<p>原因是使用<code>work</code>模式运行时间长了以后没有释放mysql数据库的链接，导致时间长了以后被mysql server端判断超时切断了链接。</p>
<p>可以改用<code>listen</code>模式运行，这样每次都是启动一个新的work进程来运行程序，每次都会新链接数据库。</p>
<p>可以使用tp的断线重连功能。修改配置文件<code>config/database.php</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 数据库连接配置信息</span></span><br><span class="line">    <span class="string">&#x27;connections&#x27;</span>     =&gt; [</span><br><span class="line">        <span class="string">&#x27;mysql&#x27;</span> =&gt; [</span><br><span class="line">            <span class="comment">// 是否需要断线重连</span></span><br><span class="line">            <span class="string">&#x27;break_reconnect&#x27;</span>   =&gt; <span class="literal">true</span>,</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>thinkphp</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>php-mpdf扩展包中文乱码问题</title>
    <url>/php-mpdf%E6%89%A9%E5%B1%95%E5%8C%85%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h1 id="php-mpdf扩展包中文乱码问题"><a href="#php-mpdf扩展包中文乱码问题" class="headerlink" title="php-mpdf扩展包中文乱码问题"></a>php-mpdf扩展包中文乱码问题</h1><p><a href="http://mpdf.github.io/fonts-languages/fonts-in-mpdf-7-x.html">mpdf</a>是一个可以把html网页转换成pdf文件的扩展包。一开始使用的时候，发现中文乱码了。。在网上查了半天，好多方法都不管用。</p>
<p>最后，在他的文档里面找到了问题原因。</p>
<p>想要输出中文，有两个参数至关重要！！！</p>
<ul>
<li>autoLangToFont 这个值一定要设置为true才可以</li>
<li>autoScriptToLang 这个值也一定要设置为true才可以</li>
</ul>
<p>只要上面两个设置为true，那么你的中文就可以正常输出了。相信我，不能正常输出你来打我。</p>
<p>看一下mpdf文档上面的描述。</p>
<p><img src="/images/mpdf1.png" alt="mpdf"></p>
<p><img src="/images/mpdf2.png" alt="mpdf"></p>
<p>可以看到默认值是false，所以我们使用的时候需要改成true。</p>
<p>设置这两个值也很简单。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Mpdf</span>\<span class="title">Mpdf</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$pdf</span> = <span class="keyword">new</span> Mpdf;</span><br><span class="line">    <span class="variable">$pdf</span>-&gt;autoLangToFont = <span class="literal">true</span>;</span><br><span class="line">    <span class="variable">$pdf</span>-&gt;autoScriptToLang = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$pdf</span>-&gt;<span class="title function_ invoke__">writeHTML</span>(<span class="string">&#x27;&lt;h1&gt;123&lt;/h1&gt;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="variable">$pdf</span>-&gt;<span class="title function_ invoke__">output</span>(<span class="string">&#x27;./test.pdf&#x27;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，mpdf的文档最开始是有错误的，他的文档中写的默认值是<code>true</code>而不是现在的<code>false</code>。不过从他的源码上可以看到他的默认值其实是<code>false</code>。</p>
<p>源码位置：<code>vendor/mpdf/mpdf/src/Config/ConfigVariables.php</code>里面。<br>这个文件里面是很多变量的默认值，在这里面搜索可以看到这两个值是false。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// AUTOMATIC FONT SELECTION</span></span><br><span class="line"><span class="comment">// Based on script and/or language</span></span><br><span class="line"><span class="comment">// mPDF 6.0 (similar to previously using function SetAutoFont() )</span></span><br><span class="line"><span class="string">&#x27;autoScriptToLang&#x27;</span> =&gt; <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// mPDF 6.0 (similar to old useLang)</span></span><br><span class="line"><span class="string">&#x27;autoLangToFont&#x27;</span> =&gt; <span class="literal">false</span>,</span><br></pre></td></tr></table></figure>

<p>我给他们的github上面提了一个issue，他们才把文档改过来了。</p>
<p><img src="/images/mpdf3.png" alt="mpdf"></p>
<p>最后附上mpdf官方文档：</p>
<blockquote>
<p><a href="http://mpdf.github.io/fonts-languages/fonts-in-mpdf-7-x.html">http://mpdf.github.io/fonts-languages/fonts-in-mpdf-7-x.html</a></p>
</blockquote>
<p>我给他们提的issue:</p>
<blockquote>
<p><a href="https://github.com/mpdf/mpdf.github.io/issues/141">https://github.com/mpdf/mpdf.github.io/issues/141</a></p>
</blockquote>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>mpdf</tag>
      </tags>
  </entry>
  <entry>
    <title>thinkphp-tp6使用chunk分块操作数据的坑</title>
    <url>/thinkphp-tp6%E4%BD%BF%E7%94%A8chunk%E5%88%86%E5%9D%97%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9D%91.html</url>
    <content><![CDATA[<h1 id="thinkphp-tp6使用chunk分块操作数据的坑"><a href="#thinkphp-tp6使用chunk分块操作数据的坑" class="headerlink" title="thinkphp-tp6使用chunk分块操作数据的坑"></a>thinkphp-tp6使用chunk分块操作数据的坑</h1><p>有的时候我们会遇到需要定时操作数据的需求，比如定时更新所有用户的权益，徽章等等。这个时候你不能一次性取出所有数据来进行操作，因为数据量太大了，我们一次取出全部，先不说mysql数据库会很慢，就算取出来传给你，网络开销也很大。这时候你通过网络接收到数据以后，会把这些数据放到一个变量里面。这个变量是存在内存中的，如果过大还会导致内存溢出，内存不足的问题。</p>
<p>所以我们就需要分页取出数据来进行操作，比如每次取出100条，操作完了再取出下100条。而tp框架提供了一个方便的<code>chunk</code>方法来供我们使用，免去了我们需要手动<code>limit</code>分页的麻烦。</p>
<p>我之前使用过laravel的chunk，以为两个差不多，看了文档也觉得差不多。下图是tp6文档的描述。</p>
<p><img src="/../images/tp-chunk1.png" alt="tp"></p>
<p>其实单表这么写也没有什么问题，不过一旦你使用了连表查询，就出现问题了。。而他的文档并没有说连表的问题。</p>
<p>虽然他的文档有这么一段也说明了主键和排序的问题。</p>
<p><img src="/../images/tp-chunk2.png" alt="tp"></p>
<p>但是，没想到连表的时候是必须，注意，必须！！！传主键，不然他不知道是哪个表的主键。而laravel就没有这个问题。。</p>
<p>我当时写的时候去找了他的源码，才看到这个问题，因为我正常写完后一直报错。。</p>
<p>看一下他的源码。源码位置在<code>./vendor/topthink/think-orm/src/db/query.php</code>里面的<code>chunk</code>方法。</p>
<p><img src="/../images/tp-chunk3.png" alt="tp"></p>
<p><img src="/../images/tp-chunk4.png" alt="tp"></p>
<p>从这里可以看到他有4个参数。</p>
<ul>
<li>count 每次处理的数量</li>
<li>callback 处理的回调函数</li>
<li>column 处理的字段名 默认 null</li>
<li>order 字段排序 默认asc</li>
</ul>
<p>前两个我们必传，后面的可选。</p>
<p>他的第二行代码，如果你传了第三个参数，那么使用你传的，不然调用getPk这个函数。这个函数在源码里面也有，就是获取主键。假设你不传，你的主键是id，那么<code>column</code>这个变量就是id。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$column</span>  = <span class="variable">$column</span> ?: <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getPk</span>();</span><br></pre></td></tr></table></figure>

<p>接下来的代码你会发现你的<code>column</code>参数，还可以传一个数组。如果是一个数组，那么他在这里不使用这个参数。</p>
<p>如果你传的不是一个数组，那么看有没有<code>.</code>也就是连不连表。因为连表你传的是<code>a.id</code>。如果连表那么<code>explode</code>分割成数组[a,id]的形式。</p>
<p>如果你传的就是<code>id</code>那么直接赋值给变量<code>key</code>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">is_array</span>(<span class="variable">$column</span>)) &#123;</span><br><span class="line">    <span class="variable">$times</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="variable">$query</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">options</span>(<span class="variable">$options</span>)-&gt;<span class="title function_ invoke__">page</span>(<span class="variable">$times</span>, <span class="variable">$count</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$query</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">options</span>(<span class="variable">$options</span>)-&gt;<span class="title function_ invoke__">limit</span>(<span class="variable">$count</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">strpos</span>(<span class="variable">$column</span>, <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">        [<span class="variable">$alias</span>, <span class="variable">$key</span>] = <span class="title function_ invoke__">explode</span>(<span class="string">&#x27;.&#x27;</span>, <span class="variable">$column</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$key</span> = <span class="variable">$column</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是真正获取数据，然后调用回调函数，再重复获取数据的过程了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$resultSet</span> = <span class="variable">$query</span>-&gt;<span class="title function_ invoke__">order</span>(<span class="variable">$column</span>, <span class="variable">$order</span>)-&gt;<span class="title function_ invoke__">select</span>();</span><br></pre></td></tr></table></figure>

<p>这里可以看到，我们传数组，那么数组就会直接给<code>order</code>函数，如果是连表的主键<code>a.id</code>，那么就会把[a,id]给<code>order</code>函数，如果是单表，那么默认<code>id</code>主键给<code>order</code>函数。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>tp</tag>
      </tags>
  </entry>
  <entry>
    <title>2022年终总结</title>
    <url>/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<h1 id="2022年终总结"><a href="#2022年终总结" class="headerlink" title="2022年终总结"></a>2022年终总结</h1><p>2022年天灾人祸不断，疫情严重，年中的时候就居家办公了一个月，十一之后又开始了居家办公。好消息是年终的时候疫情结束了，大家一起阳。</p>
<p>这一年里钱没挣到，没攒下。工作也是稀里哗啦。开始了从php转java的路子。刚开始转java很不适应。很多写法，习惯不一样，很多工具不知道，不会用。不断的踩坑，填坑。</p>
<p>到年终的时候总算把java搞得差不多了，写项目也没有在踩坑之类的了。不过关于java的内存，gc，多线程这些还是有待提高。</p>
<p>同样的，因为java的不适应和踩坑，再加上作为第一批转java的，接了难活等等，年底绩效背了c。</p>
<p>2022年花钱如流水，换了3部手机，买了一个mac pro。</p>
<p>也完成了我的求婚。结婚也要提上日程了。</p>
<p>新的一年希望越来越好。</p>
<h2 id="2023年小目标"><a href="#2023年小目标" class="headerlink" title="2023年小目标"></a>2023年小目标</h2><p>学习</p>
<ul>
<li>csapp</li>
<li>伯克利cs61b</li>
<li>cmu 15-445</li>
</ul>
<p>自考本科完成</p>
<p>读书</p>
<ul>
<li>离散数学及其应用</li>
<li>概率论</li>
<li>csapp</li>
<li>每个人的经济学</li>
<li>置身事内</li>
</ul>
<p>证书</p>
<ul>
<li>公共英语三级</li>
<li>软考高级</li>
</ul>
<p>java</p>
<ul>
<li>内存</li>
<li>gc</li>
<li>多线程</li>
</ul>
]]></content>
      <categories>
        <category>2022年终总结</category>
      </categories>
      <tags>
        <tag>2022年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-stream创建原理和数据结构操作</title>
    <url>/JAVA-stream%E7%BB%93%E6%9E%9C%E6%80%81%E5%8E%9F%E7%90%86.html</url>
    <content><![CDATA[<h1 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h1><h3 id="stream的结果态"><a href="#stream的结果态" class="headerlink" title="stream的结果态"></a>stream的结果态</h3><p>当前使用的结果态方法是<code>collect</code>。主要作用是收集。看一下源码。作为结果态方法，不再返回stream类型的对象。接受一个<code>Collector</code>类型的对象作为参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R, A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> P_OUT, A, R&gt; collector)</span> &#123;</span><br><span class="line">    <span class="comment">//声明一个变量</span></span><br><span class="line">    A container;</span><br><span class="line">    <span class="comment">//判断是否并行流。短路，直接走else</span></span><br><span class="line">    <span class="keyword">if</span> (isParallel()</span><br><span class="line">            &amp;&amp; (collector.characteristics().contains(Collector.Characteristics.CONCURRENT))</span><br><span class="line">            &amp;&amp; (!isOrdered() || collector.characteristics().contains(Collector.Characteristics.UNORDERED))) &#123;</span><br><span class="line">        container = collector.supplier().get();</span><br><span class="line">        BiConsumer&lt;A, ? <span class="built_in">super</span> P_OUT&gt; accumulator = collector.accumulator();</span><br><span class="line">        forEach(u -&gt; accumulator.accept(container, u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//调用evaluate方法</span></span><br><span class="line">        container = evaluate(ReduceOps.makeRef(collector));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)</span><br><span class="line">            ? (R) container</span><br><span class="line">            : collector.finisher().apply(container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看一下<code>ReduceOps</code> 类的 <code>makeRef</code>方法。构造一个结果态对象，对引用类型的值执行可变的计算，规约。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** Constructs a TerminalOp that implements a mutable reduce on reference values.</span></span><br><span class="line"><span class="comment">    形参:</span></span><br><span class="line"><span class="comment">    collector – a Collector defining the reduction</span></span><br><span class="line"><span class="comment">    返回值:</span></span><br><span class="line"><span class="comment">    a ReduceOp implementing the reduction</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, I&gt; TerminalOp&lt;T, I&gt; <span class="title function_">makeRef</span><span class="params">(Collector&lt;? <span class="built_in">super</span> T, I, ?&gt; collector)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数校验不为空并且获取到collector的 supplier</span></span><br><span class="line">    Supplier&lt;I&gt; supplier = Objects.requireNonNull(collector).supplier();</span><br><span class="line">    <span class="comment">// 获取到 collector的 accumulator</span></span><br><span class="line">    BiConsumer&lt;I, ? <span class="built_in">super</span> T&gt; accumulator = collector.accumulator();</span><br><span class="line">    <span class="comment">// 获取到 collector的 combiner</span></span><br><span class="line">    BinaryOperator&lt;I&gt; combiner = collector.combiner();</span><br><span class="line">    <span class="comment">// 内部类 </span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ReducingSink</span> <span class="keyword">extends</span> <span class="title class_">Box</span>&lt;I&gt;</span><br><span class="line">            <span class="keyword">implements</span> <span class="title class_">AccumulatingSink</span>&lt;T, I, ReducingSink&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">            state = supplier.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span> &#123;</span><br><span class="line">            accumulator.accept(state, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">combine</span><span class="params">(ReducingSink other)</span> &#123;</span><br><span class="line">            state = combiner.apply(state, other.state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个 ReduceOp 的对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReduceOp</span>&lt;T, I, ReducingSink&gt;(StreamShape.REFERENCE) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ReducingSink <span class="title function_">makeSink</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReducingSink</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOpFlags</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> collector.characteristics().contains(Collector.Characteristics.UNORDERED)</span><br><span class="line">                    ? StreamOpFlag.NOT_ORDERED</span><br><span class="line">                    : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看一下<code>ReduceOp</code>类。他根据指定的流类型创建ReduceOp对象。 使用指定的<code>supplier</code>创建 accumulating sinks。 对流进行预估并将结果发送至 accumulating sinks。然后执行计算操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ReduceOp</span>&lt;T, R, S <span class="keyword">extends</span> <span class="title class_">AccumulatingSink</span>&lt;T, R, S&gt;&gt;</span><br><span class="line">            <span class="keyword">implements</span> <span class="title class_">TerminalOp</span>&lt;T, R&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StreamShape inputShape;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Create a &#123;<span class="doctag">@code</span> ReduceOp&#125; of the specified stream shape which uses</span></span><br><span class="line"><span class="comment">        * the specified &#123;<span class="doctag">@code</span> Supplier&#125; to create accumulating sinks.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> shape The shape of the stream pipeline</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    ReduceOp(StreamShape shape) &#123;</span><br><span class="line">        <span class="comment">//这里 shape 是 REFERENCE 也就是引用类型</span></span><br><span class="line">        inputShape = shape;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建完结果态对象以后，将结果态对象传入<code>evaluate</code>方法。预估管道的结果态操作并产生一个结果。</p>
<ul>
<li>container &#x3D; evaluate(ReduceOps.makeRef(collector));</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Evaluate the pipeline with a terminal operation to produce a result.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &lt;R&gt; the type of result</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> terminalOp the terminal operation to be applied to the pipeline.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the result</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//这里的参数就是上面刚生成的结果态对象。</span></span><br><span class="line"><span class="keyword">final</span> &lt;R&gt; R <span class="title function_">evaluate</span><span class="params">(TerminalOp&lt;E_OUT, R&gt; terminalOp)</span> &#123;</span><br><span class="line">    <span class="comment">//断言类型是否是引用类型</span></span><br><span class="line">    <span class="comment">//getOutputShape是ReferencePipeline类的方法，直接返回的就是 REFERENCE, 刚才生成的结果态的shape也是 REFERENCE</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="title function_">getOutputShape</span><span class="params">()</span> == terminalOp.inputShape();</span><br><span class="line">    <span class="comment">//判断是否已经消费 如果已经消费了 抛出非法状态异常。</span></span><br><span class="line">    <span class="keyword">if</span> (linkedOrConsumed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(MSG_STREAM_LINKED);</span><br><span class="line">    <span class="comment">//标记为已消费</span></span><br><span class="line">    linkedOrConsumed = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//如果是并行流调用结果态的并行流方法，否则调用顺序流方法。</span></span><br><span class="line">    <span class="keyword">return</span> isParallel()</span><br><span class="line">            ? terminalOp.evaluateParallel(<span class="built_in">this</span>, sourceSpliterator(terminalOp.getOpFlags()))</span><br><span class="line">            : terminalOp.evaluateSequential(<span class="built_in">this</span>, sourceSpliterator(terminalOp.getOpFlags()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用顺序流处理方法之前，参数先调用了<code>sourceSpliterator</code>方法。而在调用<code>sourceSpliterator</code>之前，还调用了结果态的<code>getOpFlags</code>方法。</p>
<p><code>getOpFlags</code>方法在创建结果态的时候增加的，代码在下面，一起回顾一下。这个方法很简单，就是看collector的characteristics是否无序。</p>
<ul>
<li>如果无序，返回StreamOpFlag.NOT_ORDERED标志，即32</li>
<li>否则返回0</li>
</ul>
<p>我们这里返回的是0，因为list并不需要有序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//创建一个 ReduceOp 的对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReduceOp</span>&lt;T, I, ReducingSink&gt;(StreamShape.REFERENCE) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReducingSink <span class="title function_">makeSink</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReducingSink</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOpFlags</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> collector.characteristics().contains(Collector.Characteristics.UNORDERED)</span><br><span class="line">                ? StreamOpFlag.NOT_ORDERED</span><br><span class="line">                : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来看<code>sourceSpliterator</code>方法。作用如下：</p>
<ul>
<li>如果是一个顺序流或无状态并行流，返回初始化的spliterator对象。</li>
<li>如果是一个有状态并行流，返回一个spliterator对象，包含所有最近状态操作的计算结果。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the source spliterator for this pipeline stage.  For a sequential or</span></span><br><span class="line"><span class="comment"> * stateless parallel pipeline, this is the source spliterator.  For a</span></span><br><span class="line"><span class="comment"> * stateful parallel pipeline, this is a spliterator describing the results</span></span><br><span class="line"><span class="comment"> * of all computations up to and including the most recent stateful</span></span><br><span class="line"><span class="comment"> * operation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="comment">//参数是0</span></span><br><span class="line"><span class="keyword">private</span> Spliterator&lt;?&gt; sourceSpliterator(<span class="type">int</span> terminalFlags) &#123;</span><br><span class="line">    <span class="comment">// Get the source spliterator of the pipeline</span></span><br><span class="line">    <span class="comment">//声明 spliterator = null</span></span><br><span class="line">    Spliterator&lt;?&gt; spliterator = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//判断 sourceStage指针的sourceSpliterator是否为null</span></span><br><span class="line">    <span class="comment">//sourceStage指针指向头节点，所以是判断 头节点的 sourceSpliterator是否为null。</span></span><br><span class="line">    <span class="comment">//在最开始初始化的时候，头节点的 sourceSpliterator 指向了一个 ArrayListSpliterator 对象，所以这里不是null</span></span><br><span class="line">    <span class="comment">//不是null的话我们会取出 头节点的 sourceSpliterator</span></span><br><span class="line">    <span class="keyword">if</span> (sourceStage.sourceSpliterator != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 本地变量 spliterator = 头节点的 ArrayListSpliterator 对象 里面包含我们的源数据 list。</span></span><br><span class="line">        spliterator = sourceStage.sourceSpliterator;</span><br><span class="line">        <span class="comment">// 删除头节点的 sourceSpliterator</span></span><br><span class="line">        sourceStage.sourceSpliterator = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里在初始化的时候并没有 初始化 头节点的 sourceSupplier ，所以这里是null，并不会走到这里</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sourceStage.sourceSupplier != <span class="literal">null</span>) &#123;</span><br><span class="line">        spliterator = (Spliterator&lt;?&gt;) sourceStage.sourceSupplier.get();</span><br><span class="line">        sourceStage.sourceSupplier = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(MSG_CONSUMED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否是并行流，触发短路。</span></span><br><span class="line">    <span class="keyword">if</span> (isParallel() &amp;&amp; sourceStage.sourceAnyStateful) &#123;</span><br><span class="line">        <span class="comment">// Adapt the source spliterator, evaluating each stateful op</span></span><br><span class="line">        <span class="comment">// in the pipeline up to and including this pipeline stage.</span></span><br><span class="line">        <span class="comment">// The depth and flags of each pipeline stage are adjusted accordingly.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="type">AbstractPipeline</span> <span class="variable">u</span> <span class="operator">=</span> sourceStage, p = sourceStage.nextStage, e = <span class="built_in">this</span>;</span><br><span class="line">             u != e;</span><br><span class="line">             u = p, p = p.nextStage) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">thisOpFlags</span> <span class="operator">=</span> p.sourceOrOpFlags;</span><br><span class="line">            <span class="keyword">if</span> (p.opIsStateful()) &#123;</span><br><span class="line">                depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (StreamOpFlag.SHORT_CIRCUIT.isKnown(thisOpFlags)) &#123;</span><br><span class="line">                    <span class="comment">// Clear the short circuit flag for next pipeline stage</span></span><br><span class="line">                    <span class="comment">// This stage encapsulates short-circuiting, the next</span></span><br><span class="line">                    <span class="comment">// stage may not have any short-circuit operations, and</span></span><br><span class="line">                    <span class="comment">// if so spliterator.forEachRemaining should be used</span></span><br><span class="line">                    <span class="comment">// for traversal</span></span><br><span class="line">                    thisOpFlags = thisOpFlags &amp; ~StreamOpFlag.IS_SHORT_CIRCUIT;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                spliterator = p.opEvaluateParallelLazy(u, spliterator);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Inject or clear SIZED on the source pipeline stage</span></span><br><span class="line">                <span class="comment">// based on the stage&#x27;s spliterator</span></span><br><span class="line">                thisOpFlags = spliterator.hasCharacteristics(Spliterator.SIZED)</span><br><span class="line">                        ? (thisOpFlags &amp; ~StreamOpFlag.NOT_SIZED) | StreamOpFlag.IS_SIZED</span><br><span class="line">                        : (thisOpFlags &amp; ~StreamOpFlag.IS_SIZED) | StreamOpFlag.NOT_SIZED;</span><br><span class="line">            &#125;</span><br><span class="line">            p.depth = depth++;</span><br><span class="line">            p.combinedFlags = StreamOpFlag.combineOpFlags(thisOpFlags, u.combinedFlags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接到这里，由于传进来的是0，所以直接返回了</span></span><br><span class="line">    <span class="keyword">if</span> (terminalFlags != <span class="number">0</span>)  &#123;</span><br><span class="line">        <span class="comment">// Apply flags from the terminal operation to last pipeline stage</span></span><br><span class="line">        <span class="comment">// 合并结果态操作到最后一个流操作的标志</span></span><br><span class="line">        combinedFlags = StreamOpFlag.combineOpFlags(terminalFlags, combinedFlags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接到这里返回 头节点的 ArrayListSpliterator</span></span><br><span class="line">    <span class="keyword">return</span> spliterator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到上面<code>evaluate</code>方法的这段代码<code>terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags()));</code></p>
<ul>
<li>第一个参数是this</li>
<li>第二个参数是刚才返回的 头节点的 ArrayListSpliterator</li>
<li>复习一下ArrayListSpliterator的属性<ul>
<li>list &#x3D; list</li>
<li>index &#x3D; 0</li>
<li>fence &#x3D; -1</li>
<li>expectedModCount &#x3D; 0</li>
</ul>
</li>
</ul>
<p>接下来走到了 结果态 对象的 <code>evaluateSequential</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;P_IN&gt; R <span class="title function_">evaluateSequential</span><span class="params">(PipelineHelper&lt;T&gt; helper,</span></span><br><span class="line"><span class="params">                                    Spliterator&lt;P_IN&gt; spliterator)</span> &#123;</span><br><span class="line">    <span class="comment">//调用stream流的wrapAndCopyInto方法</span></span><br><span class="line">    <span class="comment">//第一个参数是 makeSink 方法生成的 ReducingSink 对象，第二个参数是 ArrayListSpliterator</span></span><br><span class="line">    <span class="keyword">return</span> helper.wrapAndCopyInto(makeSink(), spliterator).get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//makeSink是上面生成 结果态 对象的时候在 ReduceOp 对象里面加的</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ReducingSink <span class="title function_">makeSink</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 返回了一个 ReducingSink 对象。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReducingSink</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个类，提供了三个方法。等用到的时候说。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReducingSink</span> <span class="keyword">extends</span> <span class="title class_">Box</span>&lt;I&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">AccumulatingSink</span>&lt;T, I, ReducingSink&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">        state = supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        accumulator.accept(state, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">combine</span><span class="params">(ReducingSink other)</span> &#123;</span><br><span class="line">        state = combiner.apply(state, other.state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下流的<code>wrapAndCopyInto</code>方法。这个方法在 <code>AbstractPipeline</code> 类里面。</p>
<ul>
<li>第一个参数是 ReducingSink 对象</li>
<li>第二个参数是 ArrayListSpliterator 对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN, S <span class="keyword">extends</span> <span class="title class_">Sink</span>&lt;E_OUT&gt;&gt; S <span class="title function_">wrapAndCopyInto</span><span class="params">(S sink, Spliterator&lt;P_IN&gt; spliterator)</span> &#123;</span><br><span class="line">    <span class="comment">//调用过来 copyInfo 方法，第一个参数又调用了 wrapSink方法</span></span><br><span class="line">    copyInto(wrapSink(Objects.requireNonNull(sink)), spliterator);</span><br><span class="line">    <span class="keyword">return</span> sink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数是 ReducingSink 对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; Sink&lt;P_IN&gt; <span class="title function_">wrapSink</span><span class="params">(Sink&lt;E_OUT&gt; sink)</span> &#123;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    Objects.requireNonNull(sink);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for循环 p = 当前节点，如果p的深度 &gt; 0, 就循环，然后p = p的前一个节点</span></span><br><span class="line">    <span class="comment">// 也就是从当前节点往前遍历，一直到头节点。</span></span><br><span class="line">    <span class="comment">// 当前节点按照我们写的就是 filter 节点。</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> AbstractPipeline p=AbstractPipeline.<span class="built_in">this</span>; p.depth &gt; <span class="number">0</span>; p=p.previousStage) &#123;</span><br><span class="line">        <span class="comment">// 调用每个节点的 opWrapSink 方法，传入前一个节点的标志位和 sink 对象。第一次是 ReducingSink</span></span><br><span class="line">        <span class="comment">// 调用 filter 节点的结束后 把包装好的 sink链 也就是 ChainedReference 对象赋值给 sink。</span></span><br><span class="line">        <span class="comment">// 调用 map 节点的时候，传入的sink变成了 filter 返回的 ChainedReference 对象。</span></span><br><span class="line">        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Sink&lt;P_IN&gt;) sink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回顾一下 <code>filter</code> 节点的 <code>opWrapSink</code> 方法 。这是在中间态节点生成的时候，创建无状态对象的时候添加的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StatelessOp</span>&lt;P_OUT, P_OUT&gt;(<span class="built_in">this</span>, StreamShape.REFERENCE, StreamOpFlag.NOT_SIZED) &#123;</span><br><span class="line">    <span class="comment">//增加了opWrapSink方法，第一个参数是标志 = 90，第二个是 ReducingSink 对象</span></span><br><span class="line">    <span class="comment">//这个方法会在结果态的时候调用</span></span><br><span class="line">    Sink&lt;P_OUT&gt; <span class="title function_">opWrapSink</span><span class="params">(<span class="type">int</span> flags, Sink&lt;P_OUT&gt; sink)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个 Sink.ChainedReference类的对象并返回。传入 ReducingSink 对象</span></span><br><span class="line">        <span class="comment">//简单来说就是包装 sink 对象，并创建出一个 sink 执行链。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sink</span>.ChainedReference&lt;P_OUT, P_OUT&gt;(sink) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">//这里重写了 ChainedReference 的 begin 方法</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">                <span class="comment">//调用 ReducingSink 的 begin 并传入 -1</span></span><br><span class="line">                downstream.begin(-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重写了 accept 方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(P_OUT u)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (predicate.test(u))</span><br><span class="line">                    downstream.accept(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ChainedReference</span>&lt;T, E_OUT&gt; <span class="keyword">implements</span> <span class="title class_">Sink</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Sink&lt;? <span class="built_in">super</span> E_OUT&gt; downstream;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里的 downstream = ReducingSink 赋值给对象的 downstream 属性。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChainedReference</span><span class="params">(Sink&lt;? <span class="built_in">super</span> E_OUT&gt; downstream)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.downstream = Objects.requireNonNull(downstream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">        downstream.begin(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">        downstream.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancellationRequested</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> downstream.cancellationRequested();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下现在的 sink 链</p>
<p><img src="/../images/stream5.png" alt="stream5.png"></p>
<p>回顾一下 <code>map</code> 节点的 <code>opWrapSink</code> 方法 。这是在中间态节点生成的时候，创建无状态对象的时候添加的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StatelessOp</span>&lt;P_OUT, R&gt;(<span class="built_in">this</span>, StreamShape.REFERENCE,StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加了opWrapSink方法，第一个参数是标志 = 95，第二个是 ChainedReference 对象</span></span><br><span class="line">    <span class="comment">//这个方法会在结果态的时候调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Sink&lt;P_OUT&gt; <span class="title function_">opWrapSink</span><span class="params">(<span class="type">int</span> flags, Sink&lt;R&gt; sink)</span> &#123;</span><br><span class="line">        <span class="comment">//再次创建一个 Sink.ChainedReference类的对象并返回。传入一个 ChainedReference 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sink</span>.ChainedReference&lt;P_OUT, R&gt;(sink) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里重写了 accpet方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(P_OUT u)</span> &#123;</span><br><span class="line">                downstream.accept(mapper.apply(u));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ChainedReference</span>&lt;T, E_OUT&gt; <span class="keyword">implements</span> <span class="title class_">Sink</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Sink&lt;? <span class="built_in">super</span> E_OUT&gt; downstream;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里的 downstream = ChainedReference 赋值给对象的 downstream 属性。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChainedReference</span><span class="params">(Sink&lt;? <span class="built_in">super</span> E_OUT&gt; downstream)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.downstream = Objects.requireNonNull(downstream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">        downstream.begin(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">        downstream.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancellationRequested</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> downstream.cancellationRequested();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看一下现在的 sink 链。</p>
<p><img src="/../images/stream6.png" alt="stream6.png"></p>
<p>现在来到 <code>copyInto</code> 方法。这个方法两个参数</p>
<ul>
<li>第一个是包装好的 sink 链。</li>
<li>第二个是 ArrayListSpliterator 对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="keyword">void</span> <span class="title function_">copyInto</span><span class="params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> &#123;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    Objects.requireNonNull(wrappedSink);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getStreamAndOpFlags方法获取标志位 154</span></span><br><span class="line">    <span class="comment">//isKnown返回false</span></span><br><span class="line">    <span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class="line">        <span class="comment">// getExactSizeIfKnown = 7 因为list的大小是 7</span></span><br><span class="line">        <span class="comment">// 调用了 sink 的 begin。现在的 sink 是 map 的 sink，没有重写 begin</span></span><br><span class="line">        <span class="comment">// 所以 begin 是 downstream.begin(size); size = 7</span></span><br><span class="line">        <span class="comment">// 而map sink的 downstream指向了 filter 的 sink，所以调用了filter sink 的 begin</span></span><br><span class="line">        <span class="comment">// filter 重写了，是 downstream.begin(-1); 调用了 ReducingSink 的 begin</span></span><br><span class="line">        <span class="comment">// ReducingSink 的 begin 是给 state 赋值 supplier.get()的值 是 0</span></span><br><span class="line">        wrappedSink.begin(spliterator.getExactSizeIfKnown());</span><br><span class="line">        <span class="comment">// 循环剩余的数据，传入 sink 链</span></span><br><span class="line">        spliterator.forEachRemaining(wrappedSink);</span><br><span class="line">        <span class="comment">// 执行结束方法</span></span><br><span class="line">        <span class="comment">// 先调用 map sink, 然后 filter sink 然后 collect 的end</span></span><br><span class="line">        wrappedSink.end();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        copyIntoWithCancel(wrappedSink, spliterator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断这个标志是否在流上设置，是否在操作上设置。是否在流和操作的组合上设置。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isKnown</span><span class="params">(<span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="comment">// 154 &amp; 50331648 == 16777216</span></span><br><span class="line">    <span class="comment">// 返回 false</span></span><br><span class="line">    <span class="keyword">return</span> (flags &amp; preserve) == set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果能获取到size 就返回 size，不然返回 -1</span></span><br><span class="line"><span class="keyword">default</span> <span class="type">long</span> <span class="title function_">getExactSizeIfKnown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (characteristics() &amp; SIZED) == <span class="number">0</span> ? -<span class="number">1L</span> : estimateSize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">estimateSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">long</span>) (getFence() - index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看循环方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">    <span class="comment">//声明变量</span></span><br><span class="line">    <span class="type">int</span> i, hi, mc; <span class="comment">// hoist accesses and checks from loop</span></span><br><span class="line">    ArrayList&lt;E&gt; lst; Object[] a;</span><br><span class="line">    <span class="comment">//参数校验，空指针</span></span><br><span class="line">    <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//list 是我们的数据 不为空并且取出一个元素也不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((lst = list) != <span class="literal">null</span> &amp;&amp; (a = lst.elementData) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//把大小赋值给hi = 7</span></span><br><span class="line">        <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mc = lst.modCount;</span><br><span class="line">            hi = lst.size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// mc = 7</span></span><br><span class="line">            mc = expectedModCount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// index &gt;=0 并且 hi &lt;= list的数量</span></span><br><span class="line">        <span class="comment">// i = 0 index = hi = 7</span></span><br><span class="line">        <span class="keyword">if</span> ((i = index) &gt;= <span class="number">0</span> &amp;&amp; (index = hi) &lt;= a.length) &#123;</span><br><span class="line">            <span class="comment">//开始循环 0 &lt; 7, 执行完循环后 ++i, i = 1</span></span><br><span class="line">            <span class="keyword">for</span> (; i &lt; hi; ++i) &#123;</span><br><span class="line">                <span class="comment">//取出一个元素</span></span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) a[i];</span><br><span class="line">                <span class="comment">//调用 sink 链的 accpet方法 传入 该元素。</span></span><br><span class="line">                action.accept(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环完以后判断一下是否全部都处理完了 完成就返回</span></span><br><span class="line">            <span class="keyword">if</span> (lst.modCount == mc)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//map的 accpet方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(P_OUT u)</span> &#123;</span><br><span class="line">    <span class="comment">//先进行处理 mapper.apply相当于调用了我们map传入的方法</span></span><br><span class="line">    <span class="comment">//将结果沿着sink链传播</span></span><br><span class="line">    downstream.accept(mapper.apply(u));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//filter的 accept 方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(P_OUT u)</span> &#123;</span><br><span class="line">    <span class="comment">//predicate.test就相当于调用了我们 filter 的时候传入的方法。</span></span><br><span class="line">    <span class="comment">//看过滤结果是否成功，如果成功继续沿着sink链流动。</span></span><br><span class="line">    <span class="comment">//不成功则不流动。</span></span><br><span class="line">    <span class="keyword">if</span> (predicate.test(u))</span><br><span class="line">        downstream.accept(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果态的collect的 accept 方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReducingSink</span> <span class="keyword">extends</span> <span class="title class_">Box</span>&lt;I&gt; <span class="keyword">implements</span> <span class="title class_">AccumulatingSink</span>&lt;T, I, ReducingSink&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        state = supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="comment">// 执行累加器的 accpet</span></span><br><span class="line">        <span class="comment">// 这个就是 state.add(t) 具体后面会讲</span></span><br><span class="line">        accumulator.accept(state, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>最后，回到开始的collect方法中。evaluate会返回我们刚才一系列操作以后收集到的满足条件的list</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R, A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> P_OUT, A, R&gt; collector)</span> &#123;</span><br><span class="line">    <span class="comment">//声明一个变量</span></span><br><span class="line">    A container;</span><br><span class="line">    <span class="comment">//判断是否并行流。短路，直接走else</span></span><br><span class="line">    <span class="keyword">if</span> (isParallel()</span><br><span class="line">            &amp;&amp; (collector.characteristics().contains(Collector.Characteristics.CONCURRENT))</span><br><span class="line">            &amp;&amp; (!isOrdered() || collector.characteristics().contains(Collector.Characteristics.UNORDERED))) &#123;</span><br><span class="line">        container = collector.supplier().get();</span><br><span class="line">        BiConsumer&lt;A, ? <span class="built_in">super</span> P_OUT&gt; accumulator = collector.accumulator();</span><br><span class="line">        forEach(u -&gt; accumulator.accept(container, u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//调用evaluate方法</span></span><br><span class="line">        container = evaluate(ReduceOps.makeRef(collector));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断标志位，collector.characteristics() = IDENTITY_FINISH</span></span><br><span class="line">    <span class="comment">// 所以这里直接返回 收集的 list</span></span><br><span class="line">    <span class="keyword">return</span> collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)</span><br><span class="line">            ? (R) container</span><br><span class="line">            : collector.finisher().apply(container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>‘stream&#39;</tag>
      </tags>
  </entry>
  <entry>
    <title>php yii2框架前端加载css和js文件的方法</title>
    <url>/php%20yii2%E6%A1%86%E6%9E%B6%E5%89%8D%E7%AB%AF%E5%8A%A0%E8%BD%BDcss%E5%92%8Cjs%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
    <content><![CDATA[<h1 id="php-yii2框架前端加载css和js文件的方法"><a href="#php-yii2框架前端加载css和js文件的方法" class="headerlink" title="php yii2框架前端加载css和js文件的方法"></a>php yii2框架前端加载css和js文件的方法</h1><p>这两天有一个以前的项目是用<code>yii2</code>框架写的，前后端没有做分离，现在需要用vue接手后续的前端开发。</p>
<p>把vue的项目放到yii2里面，这时候遇到一个加载静态资源的问题，原来html的引用方式不管用了。</p>
<p>后来看到yii2官方文档里面，需要改一下引用方式。</p>
<p>改成下面这样就可以了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">registerCssFile</span>(<span class="string">&quot;@web/static_vue/css/index.css&quot;</span>)</span><br><span class="line"><span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">registerJsFile</span>(<span class="string">&quot;@web/static_vue/js/index.js&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>所有都使用这两个php代码进行引入，引入后就可以了。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>js</tag>
        <tag>yii2</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl安装go环境</title>
    <url>/wsl%E5%AE%89%E8%A3%85go%E7%8E%AF%E5%A2%83.html</url>
    <content><![CDATA[<h1 id="wsl"><a href="#wsl" class="headerlink" title="wsl"></a>wsl</h1><p>wsl是可以在windows里面运行linux的一个软件。是微软官方发行的。</p>
<h2 id="安装go"><a href="#安装go" class="headerlink" title="安装go"></a>安装go</h2><p>先去到安装目录<code>/usr/local/src</code>。</p>
<p>从go官网下载go tar包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo wget https://golang.org/dl/go1.16.3.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p>然后解压</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo tar -zxvf go1.16.3.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p>接下来需要配置环境变量。可以设置在&#x2F;etc&#x2F;profile文件里面也可以设置在其他地方，我用的是zsh，所以我的环境变量配置在~&#x2F;.zshrc文件里面。</p>
<p>执行<code>vim ~/.zshrc</code>。然后添加变量信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export GOROOT=&quot;/usr/local/src/go&quot;</span><br><span class="line">export PATH=&quot;$PATH:$GOROOT/bin&quot;</span><br></pre></td></tr></table></figure>

<p>接下来重新加载一下配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>

<p>现在go就安装好了。可以执行<code>go version</code>查看go的版本。</p>
<h2 id="创建第一个go-项目"><a href="#创建第一个go-项目" class="headerlink" title="创建第一个go 项目"></a>创建第一个go 项目</h2><p>我把项目放在<code>~/go</code>目录下。所以把这个目录添加到配置文件里面。因为这个目录也相当于<code>$HOME/go</code>。所以我们直接添加。</p>
<p>执行<code>vim ~/.zshrc</code>。然后添加变量信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export GOPATH=&quot;$HOME/go&quot;</span><br></pre></td></tr></table></figure>


<p>接下来重新加载一下配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>

<p>在项目目录下面创建第一个文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/go/hello.go</span><br></pre></td></tr></table></figure>

<p>添加下面的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main () &#123;</span><br><span class="line">        fmt.Printf(&quot;hello world\n&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go build ~/go/hello.go</span><br></pre></td></tr></table></figure>

<p>编译完成出现<code>hello</code>文件，直接执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/go/hello</span><br></pre></td></tr></table></figure>

<p>就可以看到输出了。</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl安装php环境</title>
    <url>/wsl%E5%AE%89%E8%A3%85php%E7%8E%AF%E5%A2%83.html</url>
    <content><![CDATA[<h1 id="wsl"><a href="#wsl" class="headerlink" title="wsl"></a>wsl</h1><p>wsl是可以在windows里面运行linux的一个软件。是微软官方发行的。</p>
<h2 id="安装php"><a href="#安装php" class="headerlink" title="安装php"></a>安装php</h2><p>从php官网下载php tar包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo wget https://www.php.net/distributions/php-7.4.12.tar.gz</span><br></pre></td></tr></table></figure>

<p>然后解压</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo tar -zxvf php-7.4.12.tar.gz</span><br></pre></td></tr></table></figure>

<p>接下来需要安装一些扩展来支持php。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gcc make pkg-config libxml2-dev libssl-dev libsqlite3-dev libcurl4-openssl-dev libonig-dev zlib1g-dev libffi-dev libpng-dev libzip-dev</span><br></pre></td></tr></table></figure>

<p>不安装上面的扩展会导致接下来报错。</p>
<p>切换目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ./php-7.4.12</span><br></pre></td></tr></table></figure>

<p>执行configure,注意这里<code>prefix</code>一定要是&#x2F;usr&#x2F;local&#x2F;php7，要不然找不到配置文件php.ini。这里有这个坑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ./configure --enable-fpm --with-mysql --with-pear --with-zip --enable-sockets --enable-soap --with-pdo-mysql  --enable-gd --enable-ftp --with-ffi  --with-zlib  --with-curl --with-openssl --enable-mbstring --prefix=/usr/local/php7 --with-config-file-path=/usr/local/php7 --with-external-gd --with-webp  --with-jpeg  --with-xpm  --with-freetype  --enable-bcmath</span><br></pre></td></tr></table></figure>

<p>执行完上面一步如果没有错误就可以了。</p>
<p>接下来执行make</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>

<p>复制一些配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo cp /usr/local/src/php7/etc/php-fpm.conf.default /usr/local/src/php7/etc/php-fpm.conf</span><br><span class="line">sudo cp /usr/local/src/php7/etc/php-fpm.d/www.conf.default /usr/local/src/php7/etc/php-fpm.d/www.conf</span><br></pre></td></tr></table></figure>

<p>修改php-fpm的用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/local/src/php7/etc/php-fpm.d/www.conf</span><br></pre></td></tr></table></figure>

<p>找到 <code>user</code> 和 <code>group</code> 这两个参数，原来的值是 <code>nobody</code>改成<code>www-data</code>，然后保存退出。</p>
<p>建立软连接或者环境变量。我们要配置全局的环境变量有两种方式。</p>
<ul>
<li>在环境变量目录里面增加软连接</li>
<li>把php目录增加到环境变量里面</li>
</ul>
<p>我采用的是软连接的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/local/php7/bin/php /usr/local/bin/php</span><br><span class="line">sudo ln -s /usr/local/php7/bin/phpize /usr/local/bin/phpize</span><br><span class="line">sudo ln -s /usr/local/php7/sbin/php-fpm /usr/local/bin/php-fpm</span><br></pre></td></tr></table></figure>

<p>接下来就可以全局使用php命令了</p>
<h3 id="php-fpm启动，重启方法"><a href="#php-fpm启动，重启方法" class="headerlink" title="php-fpm启动，重启方法"></a>php-fpm启动，重启方法</h3><p>启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo php-fpm</span><br></pre></td></tr></table></figure>

<p>重启 先找到进程 然后发送<code>USR2</code>信号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -aux | grep php</span><br><span class="line"></span><br><span class="line">sudo kill -USR2 进程id</span><br></pre></td></tr></table></figure>


<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p>访问nginx的<a href="https://nginx.org/en/download.html">官网</a>进行下载。</p>
<p>复制下载地址。比如我下载的1.19.5,直接下载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo wget https://nginx.org/download/nginx-1.19.5.tar.gz</span><br></pre></td></tr></table></figure>

<p>然后解压</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo tar -zxvf nginx-1.19.5.tar.gz</span><br></pre></td></tr></table></figure>

<p>接下来需要安装一些扩展来支持php。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libpcre3 libpcre3-dev</span><br></pre></td></tr></table></figure>

<p>切换目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ./nginx-1.19.5</span><br></pre></td></tr></table></figure>

<p>执行安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ./configure --with-file-aio --with-http_ssl_module --with-http_v2_module --with-http_realip_module --prefix=/usr/local/src/nginx</span><br><span class="line">sudo make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>

<p>好了，安装完成。</p>
<p>同意，建立软连接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/local/src/nginx/sbin/nginx /usr/local/bin/nginx</span><br></pre></td></tr></table></figure>

<p>接下来启动nginx看看效果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nginx</span><br></pre></td></tr></table></figure>

<p>访问localhost就可以看到效果了。</p>
<h2 id="配置网站"><a href="#配置网站" class="headerlink" title="配置网站"></a>配置网站</h2><p>接下来配置一下网站。</p>
<p>修改nginx.conf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/local/src/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>

<p>在http块里面加上这句话，引入其他的配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include     conf.d/*.conf;</span><br></pre></td></tr></table></figure>

<p>然后我们创建这个目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir /usr/local/src/nginx/conf/conf.d</span><br></pre></td></tr></table></figure>

<p>配置我们的网站文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/local/src/nginx/conf/conf.d/test.com.conf</span><br></pre></td></tr></table></figure>

<p>复制下面内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  test.com;</span><br><span class="line">        root   &quot;/home/wwwroot/test/public/&quot;;</span><br><span class="line">        location / &#123;</span><br><span class="line">            index index.php index.html error/index.html;</span><br><span class="line">            autoindex  off;</span><br><span class="line">            if (!-e $request_filename) &#123;</span><br><span class="line">                rewrite ^(.*)$ /index.php?s=/$1 last;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        location ~ \.php(.*)$ &#123;</span><br><span class="line">            fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">            fastcgi_index  index.php;</span><br><span class="line">            fastcgi_split_path_info  ^((?U).+\.php)(/?.+)$;</span><br><span class="line">            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">            fastcgi_param  PATH_INFO  $fastcgi_path_info;</span><br><span class="line">            fastcgi_param  PATH_TRANSLATED  $document_root$fastcgi_path_info;</span><br><span class="line">            include        fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在修改hosts文件就好了。</p>
<h2 id="redis扩展"><a href="#redis扩展" class="headerlink" title="redis扩展"></a>redis扩展</h2><p>如果要装redis扩展，那么手动下载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://pecl.php.net/package/redis</span><br></pre></td></tr></table></figure>

<p>找到tar包下载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo wget http://pecl.php.net/get/redis-5.3.2.tgz</span><br></pre></td></tr></table></figure>

<p>解压缩</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo tar -zxvf redis-5.3.2.tgz</span><br></pre></td></tr></table></figure>

<p>进去执行phpize</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ./redis-5.3.2</span><br><span class="line">sudo phpize</span><br></pre></td></tr></table></figure>

<p>然后编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ./configure --with-php-config=/usr/local/php7/bin/php-config</span><br><span class="line">sudo make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>

<p>接下来会出现下面的目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/php7/lib/php/extensions/no-debug-non-zts-20190902</span><br></pre></td></tr></table></figure>

<p>修改我们的php.ini</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/local/php7/lib/php.ini</span><br></pre></td></tr></table></figure>

<p>修改下面这个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extension_dir=/usr/local/php7/lib/php/extensions/no-debug-non-zts-20190902</span><br></pre></td></tr></table></figure>

<p>增加redis扩展</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extension=&quot;redis.so&quot;</span><br></pre></td></tr></table></figure>

<p>重启nginx和php-fpm就好了。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>如何生成ssh-key</title>
    <url>/%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90ssh-key.html</url>
    <content><![CDATA[<h1 id="如何生成ssh-key"><a href="#如何生成ssh-key" class="headerlink" title="如何生成ssh-key"></a>如何生成ssh-key</h1><p>打开命令终端，或者使用<code>git bash</code>都可以。</p>
<p>打开以后先查看你之前是否生成过<code>ssh-key</code>。生成之后会在目录<code>~/.ssh/</code>下面出现两个文件<code>id_rsa</code>私钥和<code>id_rsa.pub</code>公钥。</p>
<blockquote>
<p>cd ~&#x2F;.ssh&#x2F;<br>ls</p>
</blockquote>
<p>如果没看到这两个文件，那么开始执行生成指令。</p>
<blockquote>
<p> ssh-keygen -t rsa -C “你的邮箱” &#x2F;&#x2F;这里一般使用github的邮箱</p>
</blockquote>
<p>运行之后，会出现提示让你输入一些东西，这里不需要管，不需要输入，直接<code>回车</code>即可。</p>
<p>一直回车。直到指令执行完。</p>
<p>再次查看，发现已经生成了两个文件。接下来使用的时候只需要把公钥给到别人就可以了。</p>
]]></content>
      <categories>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统一--Amdahl定律</title>
    <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%80--Amdahl%E5%AE%9A%E5%BE%8B.html</url>
    <content><![CDATA[<h1 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h1><p>Gene Amdal，计算领域的早期先锋之一，对提升系统某一部分性能所带来的效果做出了简单却有见地的观察。</p>
<p>这个观察被称为<code>Amdahl定律</code>。该定律的主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。</p>
<p>若系统执行某应用程序需要时间为<code>T</code><sub><code>old</code></sub>。假设系统某部分执行所需时间与该时间的比例为<code>a</code>，而该部分性能提升比例为<code>k</code>。即该部分初始所需执行时间为<code>aT</code><sub><code>old</code></sub>，现在所需时间为(<code>aT</code><sub><code>old</code></sub>)&#x2F;<code>k</code>。因此，总的执行时间应为：</p>
<blockquote>
<p>T<sub>new</sub> &#x3D; (1 - a)T<sub>old</sub> + (aT<sub>old</sub>)&#x2F;k &#x3D; T<sub>old</sub> [(1 - a) + a&#x2F;k]</p>
</blockquote>
<p>由此，可以计算加速比 S &#x3D; T<sub>old</sub> &#x2F; T<sub>new</sub> 为</p>
<blockquote>
<p>S &#x3D; 1 &#x2F; [(1 - a) + a&#x2F;k]</p>
</blockquote>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>考虑这样一种情况，系统的某个部分初始耗时比例为60%（a &#x3D; 0.6），其加速比例因子为3，也就是性能提升了300%。则我们可以获得的整体系统加速比为：</p>
<blockquote>
<p>1 &#x2F; [(1 - 0.6) + 0.6 &#x2F; 3] &#x3D; 1 &#x2F; (0.4 + 0.2) &#x3D; 1 &#x2F; 0.6 &#x3D; 1.66666666 约等于 1.67倍</p>
</blockquote>
<p>可以看到虽然我们优化的部分提升了3倍性能，但是整体性能只提升了1.67倍。</p>
<p>虽然我们对系统的一个主要部分做了重大改进，但是获得的加速比却明显小于这部分的加速比。这就是<code>Amdahl</code>定律的主要观点–<code>要想显著加速整个系统，必须提升系统中相当大的部分的速度</code>。</p>
<h2 id="练习题1-1"><a href="#练习题1-1" class="headerlink" title="练习题1.1"></a>练习题1.1</h2><p>假设你要把土豆从爱达荷州送到明尼苏达州，全程2500公里。在限速范围内，你估计平均速度为100公里&#x2F;小时，整个行程需要25个小时。</p>
<blockquote>
<p>A:新闻说蒙大拿州取消了限速，这使得行程有1500公里速度可以达到150公里&#x2F;小时，那么加速比是多少？</p>
</blockquote>
<p>答：根据题目可知：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 1500 / 2500 = 0.6 k = 1.5 求S</span><br><span class="line"></span><br><span class="line">公式 S = 1 / [(1 - a) + a/k] 代入：</span><br><span class="line"></span><br><span class="line">S = 1 / (0.4 + 0.4)</span><br><span class="line">S = 1 / 0.8</span><br><span class="line">S = 1.25</span><br></pre></td></tr></table></figure>
<p>加速比是 1.25倍</p>
<blockquote>
<p>B:你可以购买道具，想让加速比达到1.67倍，那么你必须以多快的速度通过蒙大拿州？</p>
</blockquote>
<p>答：根据题目可知：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S = 1.67 a = 0.6 求k</span><br><span class="line"></span><br><span class="line">1.67 = 1 / (0.4 + 0.6 / k)</span><br><span class="line">1.67 * (0.4 + 0.6 / k) = 1</span><br><span class="line">0.668 + 1.002 / k = 1</span><br><span class="line">1.002 / k = 0.332</span><br><span class="line">k = 1.002 / 0.332</span><br><span class="line">k = 3.02</span><br></pre></td></tr></table></figure>
<p>也就是蒙大拿州的速度必须达到 100 * 3.02 &#x3D; 302公里&#x2F;小时才行。</p>
<h2 id="练习题1-2"><a href="#练习题1-2" class="headerlink" title="练习题1.2"></a>练习题1.2</h2><p>公司说下个版本的软件性能将提升2倍。这个任务分配给你，你已经确认只有80%的系统可以进行改进，那么，这部分需要改进多少才可以达到要求？</p>
<p>根据题目可以知道:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 0.8, S = 2,求k</span><br><span class="line"></span><br><span class="line">公式 S = 1 / [(1 - a) + a/k] 代入：</span><br><span class="line">2 = 1/ [(1 - 0.8) + 0.8/k]</span><br><span class="line">2 = 1 / (0.2 + 0.8 / k)</span><br><span class="line">2 (0.2 + 0.8 / k) = 1</span><br><span class="line">0.4 + 1.6 / k = 1</span><br><span class="line">1.6 / k = 0.6</span><br><span class="line">1.6 = 0.6k</span><br><span class="line">16 / 6 = k</span><br><span class="line">k = 2.67</span><br></pre></td></tr></table></figure>
<p>所以我们需要改进这部分至少2.67倍才能达到要求。</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统一--c程序发生了什么</title>
    <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%80--c%E7%A8%8B%E5%BA%8F%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88.html</url>
    <content><![CDATA[<h1 id="计算机系统漫游"><a href="#计算机系统漫游" class="headerlink" title="计算机系统漫游"></a>计算机系统漫游</h1><p>计算机系统是由硬件和系统软件组成的，它们共同工作来运行应用程序。。虽然系统的 具体实现方式随着时间不断变化，但是系统内在的概念却没有改变。所有计算机系统都有 相似的硬件和软件组件，它们又执行着相似的功能。</p>
<h2 id="第一个c程序"><a href="#第一个c程序" class="headerlink" title="第一个c程序"></a>第一个c程序</h2><p>一般第一个程序都是输出<code>hello world</code>，这里我们使用c语言输出一个<code>hello world</code>。后面在来讲这里面都发生了什么。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终程序都会被转成2进制代码，一般都根据ASCII码来转换，下图是上面的代码根据ASCII码转换成的二进制代码。</p>
<p><img src="/../images/csapp1-1.png" alt="coursera"></p>
<h2 id="程序被翻译成不同格式"><a href="#程序被翻译成不同格式" class="headerlink" title="程序被翻译成不同格式"></a>程序被翻译成不同格式</h2><p>计算机最后能执行的是二进制文件，所以需要把c文件转换成二进制文件，这是经过几个步骤的转换，而不是一次性转换成的。当然了，我们使用gcc编译的时候他是一下子执行了所有步骤的。</p>
<p>分为4个阶段</p>
<ul>
<li>hello.c 经过 预处理器(cpp) 输出 hello.i (修改了的源程序)</li>
<li>hello.i 经过 编译器(ccl) 输出 hello.s (汇编程序)</li>
<li>hello.s 经过 汇编器(as) 输出 hello.o (可重定位目标程序)</li>
<li>hello.o 和 引入的其他库的文件 经过 连接器(ld) 输出 hello.exe (可执行程序)</li>
</ul>
<h4 id="预处理阶段"><a href="#预处理阶段" class="headerlink" title="预处理阶段"></a>预处理阶段</h4><p>预处理器根据以字符<code>#</code>开头的命令，修改原始的c程序。把你引入的文件插入到原始文件中。生成新的hello.i文件。</p>
<h4 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h4><p>编译器把hello.i这个c程序文件编译成汇编程序文件。生成新的hello.s文件。</p>
<h4 id="汇编阶段"><a href="#汇编阶段" class="headerlink" title="汇编阶段"></a>汇编阶段</h4><p>汇编器把hello.s这个汇编程序翻译成机器语言指令，把这些指令打包成可重定位目标程序。生成新的hello.o文件，它包含的17个字节是函数main的指令编码。</p>
<h4 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h4><p>我们的c程序调用了别的函数，调用了printf这个输出函数，这个函数是标准c库里面的函数，这个函数存在于printf.o这个预先编译好的文件里面，而我们要把这两个文件合并到一起，链接器就负责这种合并。最后得到一个可执行程序 hello.exe</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统一--系统的硬件组成</title>
    <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%80--%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90.html</url>
    <content><![CDATA[<h1 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h1><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p>总线贯穿整个计算机系统，负责在各个部件之间传递数据。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数是一个基本的系统参数，现在大多数机器都是8个字节（64）位的了，4个字节（32）位的机器已经很少见了。</p>
<h2 id="I-x2F-O设备"><a href="#I-x2F-O设备" class="headerlink" title="I&#x2F;O设备"></a>I&#x2F;O设备</h2><p>I&#x2F;O(输入&#x2F;输出)设备是系统和外部连接的通道。下图包括四个I&#x2F;O设备。分别是</p>
<ul>
<li>作为用户输入的键盘</li>
<li>作为用户输入的鼠标</li>
<li>作为用户输出的显示器</li>
<li>存储数据和程序的磁盘<br>最开始，可执行程序就是存储在磁盘上面的。</li>
</ul>
<p>每个I&#x2F;O设备都通过适配器或者控制器和I&#x2F;O总线相连。控制器和适配器的区别主要在于封装方式上面。<code>控制器是I/O设备本身或者系统的主印制电路板（通常称作主板）</code>上的芯片组。而<code>适配器是一块插在主板插槽上的卡</code>。</p>
<h2 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h2><p>主存是一个临时存储设备，在处理器执行程序时，用来存放数据。</p>
<p>从物理上来说，主存是<code>一组动态随机存储器（DRAM）</code>芯片组成的。从逻辑上来说，存储器是<code>一个线性的字节数组，每个字节都有其唯一的地址，这些地址是从零开始的</code>。</p>
<h2 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h2><p>中央处理单元（CPU），简称处理器。是解释或执行存储在主存中指令的引擎。处理器的核心是<code>一个大小为一个字的存储设备或寄存器，称为程序计数器（PC）</code>。在任何时刻，PC都指向主存中的某条指令。</p>
<p>从电脑开机开始，PC就指向一条指令，执行指令后执行下一条指令，不断运行。</p>
<p>这样的简单操作不多，都围绕着主存，寄存器文件和算术&#x2F;逻辑运算单元（ALU）进行。下面是一些简单操作的例子。</p>
<ul>
<li>加载：从主存复制一个字节到寄存器。</li>
<li>存储：从寄存器复制一个字节到主存。以覆盖原来的值。</li>
<li>操作：把两个寄存器的内容复制到ALU做运算，将结果存在一个寄存器中。</li>
<li>跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，覆盖PC原来的值。</li>
</ul>
<p><img src="/../images/csapp1-2.png" alt="coursera"></p>
<h1 id="运行hello程序"><a href="#运行hello程序" class="headerlink" title="运行hello程序"></a>运行hello程序</h1><p>程序通过shell进行执行。</p>
<blockquote>
<p>.&#x2F;hello</p>
</blockquote>
<p>这个时候系统把这个字符通过<code>键盘</code>逐一读入寄存器，然后再放入主存。</p>
<p>当我们按下回车，这个时候系统开始执行<code>hello</code>的内容，把<code>hello world</code>从磁盘读入主存。利用直接存储器存取技术（DMA），可以直接从磁盘读入主存，而不需要经过寄存器。</p>
<p>把程序内容读入主存后，开始执行main函数的内容，把<code>hello world</code>从主存复制到寄存器，最后显示在<code>屏幕</code>上面。</p>
<h1 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h1><p>这个运行过程说明程序多次在主存和寄存器之间复制移动代码。这些重复操作如果能变得更快，那么整个程序就能变得更快。这就是高速缓存的作用。</p>
<p>根据机械原理，较大的设备比较小的设备速度慢，而快速设备的造价也远高于低速设备。比如，磁盘的容量可以比主存大1000倍，但是主存的速度可能比磁盘大1000万倍。同样的，寄存器比主存的速度也要更快。</p>
<p>针对这些速度的差异，系统的设计者采用了高速缓存设备，作为暂时的集结区域，存放处理器近期可能会需要的信息。系统有L1,L2,L3三级缓存。L1最快最小，L3最慢最大，</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络原理-自顶向下一</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B8%80.html</url>
    <content><![CDATA[<h1 id="计算机网络和因特网"><a href="#计算机网络和因特网" class="headerlink" title="计算机网络和因特网"></a>计算机网络和因特网</h1><h2 id="什么是因特网"><a href="#什么是因特网" class="headerlink" title="什么是因特网"></a>什么是因特网</h2><p>什么是因特网？回答这个问题有两种方式：其一，从具体构成上看：可以分成<code>基本硬件</code>和<code>软件组件</code>。其二，我们能够根据为分布式应用提供服务的联网基础设施来描述因特网。</p>
<p>因特网是网络的网络，是<code>通信技术</code>和<code>计算机技术</code>紧密结合的产物。是<code>互连的</code>，<code>自治的</code>。</p>
<ul>
<li>自治：无主从关系</li>
<li>互连：互联互通</li>
</ul>
<h3 id="具体构成描述"><a href="#具体构成描述" class="headerlink" title="具体构成描述"></a>具体构成描述</h3><p>因特网是世界范围的计算机网络。互联了世界的计算机网络。在之前计算设备多是电脑，发展到现在，加入了手机，电视，平板，汽车等设备。这些都被称为<code>主机（host）</code>或<code>端系统（end system）</code>。</p>
<p>端系统通过<code>通信链路</code>和<code>分组交换机</code>连接到一起。通信链路由<code>同抽电缆</code>，<code>铜线</code>,<code>光纤</code>等物理媒体组成。不同物理媒体的传输速率不同，传输速率以（比特&#x2F;秒度量)。</p>
<p>端系统要发送的时候，把<code>发送信息</code>分段，每段和<code>首部字节</code>包裹到一起称为一个分组，把分组通过网络从发送端系统发送到接收端系统。</p>
<p>分组交换机分成<code>路由器</code>和<code>链路层交换机</code>。路由器用于网络核心，链路层交换机用于接入网。</p>
<p>端系统通过<code>因特网服务提供商ISP</code>接入，包括家庭ISP，公司ISP等。每个ISP由多个分组交换机和多个通信链路组成。</p>
<ul>
<li>从范围分：局域网，城域网，广域网</li>
<li>从拓扑结构分：星型，主线型，树形，网状。</li>
<li>从交换网络分：电路交换，报文交换，分组交换。</li>
</ul>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>协议控制着网络之间计算机的通信。不同的协议完成不同的通信任务。</p>
<p>协议的三要素：</p>
<ul>
<li>语法：数据与控制信息的结构和格式</li>
<li>语义：需要发出何种控制信息，完成何种动作何种响应。差错控制</li>
<li>时序：事件顺序，速度匹配</li>
</ul>
<h4 id="问问题"><a href="#问问题" class="headerlink" title="问问题"></a>问问题</h4><p>当你发出<code>你好</code>的时候，发送了一条请求报文。当对方回复<code>你好，你有什么事吗</code>的时候，回复了一条响应报文。</p>
<p>这时候你问问题<code>你知道天安门在哪里吗</code>。发送了一条请求报文。对方回复<code>天安门在这里呀，......</code>。回复了一条响应报文。</p>
<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p>我们的手机，电视，智能设备这些端系统联网，都处于网络边缘。端系统也叫做主机，可以分成客户端和服务端。</p>
<h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><p>接入网是链接网络边缘的端系统到<code>边缘路由器</code>的物理链路。边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器。</p>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>网络核心是网络之网络，无数的路由器和交换机相互连接在一起。</p>
<p>三种交换方式：</p>
<ul>
<li>电路交换，建立连接-通信-释放链接，独占信道，不应对突发性。不用的时候浪费。通过多路复用技术来实现共享物理链路。</li>
<li>报文交换，发送整个报文。 时间 M&#x2F;R *　h h是跳步数。发送时间长，和跳步数成正比，并且随着报文越大，路由器存储也需要越大。</li>
<li>分组交换，报文切成一个个分组，一个分组过一个路由器的时间是 L&#x2F;R 。整个报文的时间是 M&#x2F;R + nL&#x2F;R ，n是路由器数量。</li>
</ul>
<p>多路复用技术：</p>
<ul>
<li>频分多路复用（FDM）根据不同的频率划分</li>
<li>时分多路复用（TDM）根据不同的时间划分</li>
<li>波分多路复用（WDM）根据不同的波划分</li>
<li>码分多路复用（CDM）每个手机分配码片，通过码片加密传输，再解密。用于手机网络。</li>
</ul>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>报文：包含从源主机到目的主机传输的任何东西。源主机将长报文划分为较小的一个个<code>分组</code>。分组通过通信链路和分组交换机（路由器和链路层交换机）传送。</p>
<p>分组以最大传输速率传输。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传输时间 = 分组长度 / 传输速率</span><br><span class="line">传输时间 = L / R</span><br></pre></td></tr></table></figure>

<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>一个报文大小7.5Mbps。一个分组1500bits。总共有5000个分组。传输速率R &#x3D; 1.5Mbps。会经过3段链路，2个路由器。</p>
<p>报文交换时间 &#x3D; M &#x2F; R &#x3D; 7.5 &#x2F; 1.5 &#x3D; 5s 3段链路总共就是 5 * 3 &#x3D; 15s。</p>
<p>分组交换时间 &#x3D; L &#x2F; R &#x3D; 1500 &#x2F; (1.5 * 10<sup>6</sup>) &#x3D; 0.001s<br>5000个分组就是 5000 * 0.001s &#x3D; 5s，再加上2个路由器，总共是 5.002s</p>
<p>分组交换公式：M&#x2F;R + nL&#x2F;R n&#x3D;路由器数量<br>报文交换公式：hM&#x2F;R h&#x3D;链路数量（跳步数）</p>
<h3 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h3><p><code>速率</code>即<code>数据率</code>或称<code>数据传输速率</code>或<code>比特率</code>。单位时间（秒）传输信息（比特）量。</p>
<ul>
<li>b&#x2F;s(bps)</li>
<li>kb&#x2F;s(kbps)</li>
<li>Mb&#x2F;s(Mb&#x2F;s)</li>
<li>Gb&#x2F;s(Gb&#x2F;s)</li>
<li>k &#x3D; 10<sup>3</sup>, M &#x3D; 10<sup>6</sup>, G &#x3D; 10<sup>9</sup></li>
</ul>
<p><code>带宽</code>原本指信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（HZ）。<br>网络的<code>带宽</code>通常是数字信道所能传输的<code>最高数据率</code>，单位b&#x2F;s。</p>
<h4 id="延迟-x2F-时延"><a href="#延迟-x2F-时延" class="headerlink" title="延迟&#x2F;时延"></a>延迟&#x2F;时延</h4><p>分组交换为什么会丢包和时延？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">路由器的缓存队列满了，在接到分组就会丢弃，产生丢包。</span><br><span class="line">分组进行排队的时间延迟。</span><br></pre></td></tr></table></figure>

<p>d<sub>proc</sub> :节点处理延迟</p>
<ul>
<li>差错检测</li>
<li>确定输出链路</li>
<li>通常 &lt; msec</li>
</ul>
<p>d<sub>queue</sub>:排队延迟，在路由器里面排队</p>
<ul>
<li>等待输出链路可用</li>
<li>取决于路由器拥塞程度</li>
<li>a:平均分组到达速率</li>
<li>La&#x2F;R流量强度 &#x3D; 0 平均排队延迟很小</li>
<li>La&#x2F;R &#x3D; 1平均排队延迟很大</li>
<li>La&#x2F;R &gt; 1超出服务能力</li>
</ul>
<p>d<sub>trans</sub>:传输延迟</p>
<ul>
<li>L:分组长度(bits)</li>
<li>R:链路带宽(bps)</li>
<li>d<sub>trans</sub> &#x3D; L&#x2F;R</li>
</ul>
<p>d<sub>prop</sub>:传播延迟</p>
<ul>
<li>d:物理链路长度</li>
<li>s:信号传播速度(2 * 10<sup>8</sup> m&#x2F;sec)</li>
<li>d<sub>prop</sub> &#x3D; d&#x2F;s</li>
</ul>
<h4 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">时延带宽积 = 传播时延 * 带宽</span><br><span class="line">          = d&lt;sub&gt;prop&lt;/sub&gt; * R(btis)</span><br><span class="line">          = 以比特为单位的链路长度，也就是链路里面有多少个比特</span><br></pre></td></tr></table></figure>

<h4 id="分组丢失-丢包"><a href="#分组丢失-丢包" class="headerlink" title="分组丢失 丢包"></a>分组丢失 丢包</h4><ul>
<li>队列缓存容量有限，队列满了</li>
<li>分组到达已满队列将丢弃</li>
<li>丢弃分组可能由前序节点或源重发（也可能不重发）</li>
</ul>
<p>丢包率 &#x3D; 丢包数 &#x2F; 已发分组总数</p>
<h4 id="吞吐量-x2F-率"><a href="#吞吐量-x2F-率" class="headerlink" title="吞吐量&#x2F;率"></a>吞吐量&#x2F;率</h4><p><code>吞吐量</code>表示在发送端与接收端之间传送数据速率(b&#x2F;s)<br><code>即时吞吐量</code>是给定时刻的速率<br><code>平均吞吐量</code>是一段时间的平均速率</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">吞吐量取较小的一段链路的带宽吞吐量。</span><br></pre></td></tr></table></figure>


<h3 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h3><p>实体：表示任何可发送或接收信息的硬件或软件。<br>协议：控制两个对等实体通信的规则的集合，协议是“水平的”。<br>实体需要使用下层服务，对上层提供服务，遵循本层协议，实现本层功能。服务是“垂直的”<br>下层实现对上层服务是“透明”的</p>
<h4 id="OSI7层结构"><a href="#OSI7层结构" class="headerlink" title="OSI7层结构"></a>OSI7层结构</h4><p>从功能上描述网络结构：分层结构</p>
<ul>
<li>应用层 http https ftp  报文</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层 tcp upd 报文段</li>
<li>网络层 ip 数据报</li>
<li>数据链路层 mac 帧</li>
<li>物理层</li>
</ul>
<p>每层进行数据封装，增加头信息，也就是<code>控制信息</code>：</p>
<ul>
<li>地址：发送和接收</li>
<li>差错检测编码：差错检测或纠正</li>
<li>协议控制：附加信息，优先级，服务质量，安全控制<br>构造协议数据单元（PDU）</li>
</ul>
<h5 id="物理层功能"><a href="#物理层功能" class="headerlink" title="物理层功能"></a>物理层功能</h5><ul>
<li>接口特性</li>
<li>比特编码</li>
<li>数据率</li>
<li>比特同步<ul>
<li>时钟同步</li>
</ul>
</li>
<li>传输模式<ul>
<li>单工 只能单向通信</li>
<li>半双工 可以双向通信，但只能交替进行</li>
<li>全双工</li>
</ul>
</li>
</ul>
<h5 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h5><p>物理链路直接相连的两个节点之间的数据传输。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络原理-自顶向下一课后作业解析</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B8%80%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E8%A7%A3%E6%9E%90.html</url>
    <content><![CDATA[<h1 id="第一章课后复习题"><a href="#第一章课后复习题" class="headerlink" title="第一章课后复习题"></a>第一章课后复习题</h1><ol>
<li>“主机”和“端系统”之间有什么不同？列举几种不同类型的端系统。web服务器是一种端系统吗？</li>
</ol>
<p>没什么不同，主机即端系统。<br>手机是端系统，ipad是端系统，智能音箱是端系统。<br>web服务器也是一种端系统。</p>
<ol start="2">
<li>“协议”一词常被用于描述外交关系。维基百科是怎样描述外交协议的。</li>
</ol>
<p>直接去维基百科看</p>
<ol start="3">
<li>标准对于协议为什么重要？</li>
</ol>
<p>如果都使用不同的协议，那么就没法交互了。所以需要标准来统一协议。</p>
<ol start="4">
<li>列出6种接入技术，将它们分为住宅接入，公司接入或广域无线网络接入。</li>
</ol>
<p>同轴电缆 住宅接入<br>混合光纤同轴电缆（HFC）住宅接入<br>FTTH 住宅接入，公司接入<br>双绞线 住宅接入<br>WIFI 住宅接入，公司接入，广域无线网络接入<br>4G 广域无线网络接入</p>
<ol start="5">
<li>HFC传输速率在用户间是专用的还是共享的？在下行HFC信道中，可能出现碰撞吗？为什么？</li>
</ol>
<p>共享的。<br>不会，在下行信道，所有的分组从头到尾有同一个源发出，因此不会发生冲突。</p>
<ol start="6">
<li>略</li>
<li>以太LAN的传输速率是多少</li>
</ol>
<p>用户10Mbps,100Mbps,服务器1Gbps,10Gbps</p>
<ol start="8">
<li>能够运行以太网的一些物理媒体是什么？</li>
</ol>
<p>同轴电缆，光纤，双绞铜线</p>
<ol start="9">
<li>拨号调制解调器，HFC，DSL和FTTH都用于住宅接入，对于这些技术中的每一种，给出传输速率的范围，并讨论有关带宽是共享的还是专用的</li>
</ol>
<p>拨号是专用的<br>HFC,DSL,FTTH都是用户共享的</p>
<ol start="10">
<li><p>略</p>
</li>
<li><p>假定在发送主机和接收主机间只有一台分组交换机。发送主机和交换机间以及交换机和接收主机间的传输速率分别是R1和R2。假设该交换机使用存储转发分组交换方式，发送一个长度为L的分组的端到端总时延是什么？（忽略排队时延，传播时延和节点处理时延）</p>
</li>
</ol>
<p>从发送主机到交换机的传输时延是 L&#x2F;R1<br>从交换机到接受主机的传输时延是 L&#x2F;R2<br>端到端总时延 &#x3D; L&#x2F;R1 + L&#x2F;R2</p>
<ol start="12">
<li>与分组交换网络相比，电路交换网络有哪些优点？在电路交换网络中，TDM比FDM有哪些优势？</li>
</ol>
<p>电路交换网络独占带宽，速率更加稳定，建立好链接好只需要传输数据，不需要拥塞控制，流量控制，丢包等问题。</p>
<p>FDM是划分频率，TDM是划分时隙。发生丢失数据的话，TDM只会丢失一个时隙的数据，而FDM可能是大部分。</p>
<ol start="13">
<li>假定用户共享一条2Mbps链路。同时假定当每个用户传输时连续以1Mbps传输，但每个用户仅传输20%的时间。<br>a. 当使用电路交换时，能够支持多少用户？<br>b. 作为该题的遗留问题，假定使用分组交换。为什么如果两个或更少的用户同时传输的话，在链路前面基本没有排队时延？为什么如果3个用户同时传输的话，将会有排队时延？<br>c. 求出某指定用户正在传输的概率。<br>d. 假定现在有3个用户。求出在任何给定时间，所有3个用户在同时传输的概率。求出队列增长的时间比率。</li>
</ol>
<p>a: 电路交换可以支持两个用户。<br>b: 因为两个用户每个用户1Mbps传输速率，两个刚好2Mbps占满了链路，当3个的时候，对于交换机来说输入速率就变成了3Mbps，而输出还是2Mbps,所以会产生排队。<br>C: 20%<br>d: 0.2 * 0.2 * 0.2 &#x3D; 0.008</p>
<ol start="14">
<li>为什么在等级结构相同级别的两个ISP通常互相对等？某IXP是如何挣钱的？</li>
</ol>
<p>因为互相对等可以直接连接，节省从上层ISP的时间和钱。<br>IXP通过流量对ISP收费</p>
<ol start="15">
<li>某些内容提供商构建了自己的网络。描述谷歌的网络。内容提供商构建这些网络的动机是什么？</li>
</ol>
<p>绕过顶层ISP，直接和接入ISP互联，减少向顶层ISP的付费，并且可以对网络有更多的控制和操作。</p>
<ol start="16">
<li>考虑从某源主机跨越一条固定路由向某目的主机发送一分组。列出端到端时延组成部分。这些时延中的哪些是固定的，哪些是变化的？</li>
</ol>
<p>总时延 &#x3D; 节点处理时延 + 排队时延 + 传输时延 + 传播时延<br>变化的是节点处理时延 + 排队时延<br>固定的是传输时延 + 传播时延</p>
<ol start="17">
<li>访问在配套Web网站上有关传输时延与传播时延的Java小程序。在可用速率、传播时延和可用的分组长度之中找出一种组合，使得该分组的第一个比特到达接收方之前发送方结束了传输。找出另一种组合，使得发送方完成传输之前，该分组的第一个比特到达了接收方。</li>
</ol>
<p>传输时延 &lt; 传播时延的时候，传输完了第一个比特还没有到达接收方。<br>传输时延 &gt; 传播时延的时候，传播完了还没传输完，也就是第一个比特到达接收方还在传输。</p>
<ol start="18">
<li>一个长度为1000字节的分组经距离2500km的链路传播，传播速率为2.5x10^8m&#x2F;s并且传输速率为2Mbps，它需要多长时间？更为一般地，一个长度为L的分组经距离为d的链路传播，传输速率为s并且传播速率为Rbps，它需要用多长时间？该时延与传输速率相关吗？</li>
</ol>
<p>传输时延 &#x3D; 1000 &#x2F; 2000000 &#x3D; 0.0005s<br>传播时延 &#x3D; 2500 &#x2F; 250000 &#x3D; 0.01s<br>需要 0.0105s 忽略节点处理时延和传播时延<br>L&#x2F;s + d&#x2F;Rbps<br>相关</p>
<ol start="19">
<li>假定主机A要向主机B发送一个大文件。从主机A到主机B的路径上有3段链路，其速率分别为R1 &#x3D; 500kbps，R2 &#x3D; 2Mbps，R3 &#x3D; 1Mbps。<br>a. 假定该网络中没有其他流量，该文件传送的吞吐量是多少？<br>b. 假定该文件为4MB。传输该文件到主机B大致需要多长时间？<br>c. 重复(a)和(b)，只是这时R2减小到100kbps。</li>
</ol>
<p>a: 吞吐量取决于最小的速率也就是500kbps。<br>b: 4000 * 8 &#x2F; 500 &#x3D; 64s<br>c: 吞吐量 &#x3D; 100kbps 传输时间 &#x3D; 4000 * 8 &#x2F; 100 &#x3D; 320s</p>
<ol start="20">
<li>假定端系统A要向端系统B发送一个大文件。在一个非常高的层次上，描述端系统怎样从该文件生成分组。当这些分组之一到达某分组交换机时，该交换机使用分组中的什么信息来决定将该分组转发到哪一条路上？因特网中的分组交换为什么可以与驱车从一个城市到另一个城市并沿途询问方向相类比？</li>
</ol>
<p>报文-段-数据报-帧<br>使用目的ip地址和路由转发协议决定<br>路由转发协议使用了转发表，查询转发表和问路类似，一个路由器和一个城市类似</p>
<ol start="21">
<li>访问配套Web站点的排队和丢包Java小程序。最大发送速率和最小的传输速率是什么？对于这些速率，流量强度是多少？用这些速率运行该Java小程序并确定出现丢包要花费多长时间？然后第二次重复该实验，再次确定出现丢包花费多长时间。这些值有什么不同？为什么会有这种现象？</li>
</ol>
<p>略</p>
<ol start="22">
<li>列出一个层次能执行的5个任务。这些任务中的一个（或两个）可能由两个（或更多）层次执行吗？</li>
</ol>
<p>传输层 tcp协议：差错检测，分组重传，流量控制，拥塞控制，建立连接</p>
<p>可能，传输层有差错检测，网络层也有差错检测。</p>
<ol start="23">
<li>因特网协议栈中的5个层次有哪些？在这些层次中，每层的主要任务是什么？</li>
</ol>
<p>应用层：完成自己的应用功能 http,icmp,ftp应用执行<br>传输层：完成端到端传输 tcp udp协议 确定源和目的端口号 进程传输<br>网络层：完成网络的端到端传输 IP协议 源和目的ip地址 主机传输<br>数据链路层：完成数据的端到端传输 MAC协议 到下一个节点的传输<br>物理层：完成比特流的端到端传输 实际物理传输</p>
<ol start="24">
<li>什么是应用层报文？什么是传输层报文段？什么是网络层数据报？什么是链路层帧？</li>
</ol>
<p>应用层报文就是数据报文<br>传输层：增加源和目的端口号封装成段<br>网络层：增加源和目的ip地址，封装成数据报<br>链路层：增加MAC地址，封装成帧</p>
<ol start="25">
<li>路由器处理因特网协议栈中的哪些层次？链路层交换机处理的是哪些层次？主机处理的是哪些层次？</li>
</ol>
<p>主机处理所有层次<br>路由器处理物理层，链路层，网络层三层<br>交换机处理物理层，链路层两层</p>
<ol start="26">
<li>病毒和蠕虫之间有什么不同？</li>
</ol>
<p>病毒：需要用户交互才能感染设备<br>蠕虫：不需要用户交互</p>
<ol start="27">
<li>描述如何产生一个僵尸网络，以及僵尸网络是怎样被用于DDoS攻击的。</li>
</ol>
<p>恶意软件控制网络设备产生僵尸网络<br>恶意软件控制僵尸网络不断攻击服务器，发送大量分组，创建大量链接，让正常请求被服务器忽略或拒绝。</p>
<ol start="28">
<li>假定Alice和Bob经计算机网络相互发送分组。假定Trudy将自己安置在网络中，使得她能够俘获由Alice发送的所有分组，并发送她希望给Bob的东西；她也能俘获Bob发送的所有分组，并发送她希望给Alice的东西。列出在这种情况下Trudy能够做的某些恶意的事情。</li>
</ol>
<p>假扮成Alice或者Bob发送恶意软件<br>盗取Alice和Bob的信息</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络原理-自顶向下二</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%BA%8C.html</url>
    <content><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><p>两种架构</p>
<ul>
<li>C&#x2F;S 客户-服务器架构</li>
<li>P2P 对等架构</li>
</ul>
<p>P2P的<code>自扩展性</code>：尽管每个对等方都请求文件产生工作量，但每个对等方也向其他对等方分发文件增加系统服务能力。</p>
<p>未来P2P面临的三大挑战：</p>
<ul>
<li>ISP友好。<br>大多数ISP都是下载比上传快。但是P2P加大了上传流量，给ISP带来了压力。需要设计对ISP友好的P2P。</li>
<li>安全性。<br>因为高度分布和开放特性。给安全带来了挑战。</li>
<li>激励<br>未来P2P的成功也取决于说服用户自愿向应用提供带宽，存储和计算资源。这对激励设计带来挑战。</li>
</ul>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>实际通信的是计算机上面的进程。<br>通过IP地址确定一个主机。通过端口号确定一个进程。<br>计算机提供了一套socket套接字。</p>
<h3 id="使用的运输层服务"><a href="#使用的运输层服务" class="headerlink" title="使用的运输层服务"></a>使用的运输层服务</h3><p>看几个方面：</p>
<ul>
<li>可靠数据传输</li>
<li>吞吐量 带宽敏感</li>
<li>时延</li>
<li>安全</li>
</ul>
<h3 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul>
<li>建立连接</li>
<li>可靠数据传输</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>轻量级，全部由应用层实现</p>
<h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><ul>
<li>交换的报文类型， 例如请求报文和响应报文</li>
<li>各种报文类型的语法，如报文的各个字段及这些字段是如何描述的。</li>
<li>字段的语义，这些字段中包含的信息的含义。</li>
<li>一个进程何时以及如何发送报文，对报文进行响应的规则。</li>
</ul>
<h2 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h2><p>HTTP的RFC文档</p>
<ul>
<li>RFC 1945</li>
<li>RFC 2616</li>
</ul>
<h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p>请求报文</p>
<ul>
<li>请求行</li>
<li>首部行</li>
<li>空行</li>
<li>请求体</li>
</ul>
<p>响应报文</p>
<ul>
<li>状态行</li>
<li>首部行</li>
<li>响应体</li>
</ul>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>HTTP本身是无状态的，通过cookie可以实现身份记录。</p>
<p>cookie技术有4个组件</p>
<ul>
<li>HTTP响应报文中的一个cookie首部行</li>
<li>HTTP请求报文中的一个cookie首部行</li>
<li>用户端系统有一个cookie文件</li>
<li>WEB站点的一个后端数据库</li>
</ul>
<h3 id="WEB缓存"><a href="#WEB缓存" class="headerlink" title="WEB缓存"></a>WEB缓存</h3><p>WEB缓存器也叫代理服务器，它是能代表初始WEB服务器来满足HTTP请求的实体。WEB缓存服务器有自己的磁盘空间，保存最近请求过的对象的副本。</p>
<p>CDN就是一种WEB缓存。</p>
<h3 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h3><p>尽管高速缓存能快速响应，但是存储的副本可能是陈旧的，过期的。</p>
<p>HTTP协议有一种机制，允许缓存器证实它是最新的。这种机制就是<code>条件GET方法</code></p>
<ul>
<li>请求报文使用GET方法</li>
<li>请求报文中包含一个“if-Modified-Since”首部行，内容是上次服务器返回的最新修改时间</li>
</ul>
<p>WEB服务器会检查如果没有修改就返回一个304状态码，缓存就知道还是最新的。</p>
<h2 id="文件传输FTP"><a href="#文件传输FTP" class="headerlink" title="文件传输FTP"></a>文件传输FTP</h2><p>HTTP和FTP都是文件传输协议。(RFC959)</p>
<p>一些重要的区别，最显著的是<code>FTP</code>使用两个并行的TCP连接来传输文件，一个是<code>控制连接</code>，一个是<code>数据连接</code>。</p>
<p>控制连接用于在俩主机之间传输控制信息，如用户标识、口令、改变远程目录的命令以及<code>存放</code>和<code>获取</code>文件的命令。</p>
<p>数据连接用于实际发送一个文件。</p>
<p>因为FTP使用一个独立的控制连接，所以我们也称FTP的控制信息是<code>带外传送</code>的。</p>
<p>FTP首先在21端口建立一个<code>控制连接</code>。<br>FTP的客户端通过控制连接发送用户标识和口令，命令。<br>FTP的服务端收到传输文件的命令后，建立数据连接用来传输文件。<br>每个数据连接传输一个文件后关闭。</p>
<h3 id="FTP命令和回答"><a href="#FTP命令和回答" class="headerlink" title="FTP命令和回答"></a>FTP命令和回答</h3><p>命令和回答都是以<code>7比特的ASCII格式</code>在控制连接上发送的。为了区分连续的命令，每个命令后跟回车换行符。</p>
<ul>
<li>USER username: 用于向服务器发送用户标识</li>
<li>PASS password: 用于向服务器发送用户口令</li>
<li>LIST ：用于请求服务器回送当前远程目录中的所有文件列表。该文件列表是一个数据连接发送的。</li>
<li>RETR filename: 用于从远程主机当前目录检索文件。该命令引起远程主机发起数据连接传输该文件到本地客户端。</li>
<li>STOR filename: 用于在远程主机当前目录存放文件。就是往远程主机传输文件。</li>
</ul>
<p>一些典型回答：</p>
<ul>
<li>331 Username OK, Password required(用户名Ok，需要口令)</li>
<li>125 Data connection already open: transfer starting (数据连接已经打开，开始传送)</li>
<li>425 Can’t open data connection (无法打开数据连接)</li>
<li>452 Error Writing File (写文件出错)</li>
</ul>
<h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p>邮件有三部分</p>
<ul>
<li>用户代理</li>
<li>邮件服务器</li>
<li>简单邮件传输协议</li>
</ul>
<p>发送邮件过程</p>
<ul>
<li>发送方的用户代理 到 发送方的邮件服务器</li>
<li>发送方的邮件服务器 到 接收方的邮件服务器</li>
<li>接收方的邮件服务器 到 接收方的用户代理邮箱</li>
</ul>
<h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>RFC 5321 给出了SMTP的定义。SMTP使用TCP协议。只能传输7比特的ASCII表示。</p>
<p>发送过程：</p>
<ul>
<li>客户端建立连接</li>
<li>S:220 hamburger.edu</li>
<li>C:HELO crepes.fr</li>
<li>S:250 Hello crepes.fr,pleased to meet you</li>
<li>C:MAIL FROM: <a href="mailto:&#97;&#x6c;&#105;&#x63;&#101;&#64;&#x63;&#x72;&#x65;&#x70;&#x65;&#x73;&#46;&#102;&#x72;">&#97;&#x6c;&#105;&#x63;&#101;&#64;&#x63;&#x72;&#x65;&#x70;&#x65;&#x73;&#46;&#102;&#x72;</a></li>
<li>S:250 <a href="mailto:&#97;&#108;&#105;&#99;&#101;&#x40;&#x63;&#114;&#x65;&#x70;&#101;&#115;&#x2e;&#102;&#x72;">&#97;&#108;&#105;&#99;&#101;&#x40;&#x63;&#114;&#x65;&#x70;&#101;&#115;&#x2e;&#102;&#x72;</a> … sender ok</li>
<li>C:RCPT TO: <a href="mailto:&#98;&#111;&#98;&#x40;&#104;&#117;&#x6d;&#98;&#x75;&#x72;&#103;&#x65;&#114;&#46;&#101;&#x64;&#x75;">&#98;&#111;&#98;&#x40;&#104;&#117;&#x6d;&#98;&#x75;&#x72;&#103;&#x65;&#114;&#46;&#101;&#x64;&#x75;</a></li>
<li>S:250 <a href="mailto:&#x62;&#111;&#x62;&#x40;&#104;&#x75;&#x6d;&#x62;&#117;&#114;&#x67;&#101;&#x72;&#46;&#x65;&#x64;&#x75;">&#x62;&#111;&#x62;&#x40;&#104;&#x75;&#x6d;&#x62;&#117;&#114;&#x67;&#101;&#x72;&#46;&#x65;&#x64;&#x75;</a> …. Recipient ok</li>
<li>C:DATA</li>
<li>S:354 Enter mail, end with “.” on a line by itself</li>
<li>C:Do you like ketchup?</li>
<li>C:How about you pickets?</li>
<li>C:.</li>
<li>S:250 Message accepted for delivery</li>
<li>C:QUIT</li>
<li>S:221 hamburger.edu closeing connection</li>
</ul>
<h3 id="和HTTP对比"><a href="#和HTTP对比" class="headerlink" title="和HTTP对比"></a>和HTTP对比</h3><p>HTTP 是一个拉协议，从服务器拉取数据。<br>SMTP 是一个推协议，往服务器推送邮件。</p>
<p>HTTP 可以任意表示<br>SMTP 只能7比特ASCII表示。</p>
<p>HTTP 每个对象一个响应<br>SMTP 一个邮件多个对象</p>
<h3 id="SMTP典型的首部报文"><a href="#SMTP典型的首部报文" class="headerlink" title="SMTP典型的首部报文"></a>SMTP典型的首部报文</h3><p>FROM:<br>TO:<br>Subject:</p>
<h3 id="获取邮件协议"><a href="#获取邮件协议" class="headerlink" title="获取邮件协议"></a>获取邮件协议</h3><p>POP3 和 IMAP</p>
<h4 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h4><p>pop3分为3个阶段</p>
<ul>
<li>特许：用户代理发送用户名和口令（明文）</li>
<li>事务处理：用户代理取回报文，做删除报文的标记，取消删除标记，获取邮件的统计信息。</li>
<li>更新阶段：发生在客户端QUIT指令后，结束会话，删除那些标记的报文。</li>
</ul>
<p>特许阶段有两个主要命令</p>
<ul>
<li>user <username></li>
<li>pass <password></li>
</ul>
<p>事务处理阶段有4个主要命令</p>
<ul>
<li>list 列出邮件列表</li>
<li>retr id 读取邮件内容</li>
<li>delete 删除邮件</li>
<li>quit 退出</li>
</ul>
<h4 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h4><p>imap比pop3更加复杂，增加了远程文件夹功能。imap支持用户读取报文的一部分，比如只读取首部，或多部分MIME的一部分。当宽度低的时候非常有用。</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS使用UDP协议。</p>
<p>DNS完成域名和ip地址的转换。</p>
<p>域名分为</p>
<ul>
<li>根DNS服务器</li>
<li>顶级DNS服务器 com,org,edu,cn</li>
<li>权威DNS服务器</li>
</ul>
<h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><p>迭代请求</p>
<ul>
<li>请求根服务器</li>
<li>根服务器返回</li>
<li>请求顶级服务器</li>
<li>顶级服务器返回</li>
<li>请求权威</li>
<li>权威返回</li>
</ul>
<p>递归请求</p>
<ul>
<li>请求根</li>
<li>根请求顶级</li>
<li>顶级请求权威</li>
<li>权威返回顶级</li>
<li>顶级返回根</li>
<li>根返回</li>
</ul>
<h2 id="TCP套接字"><a href="#TCP套接字" class="headerlink" title="TCP套接字"></a>TCP套接字</h2><p>遵守RFC协议文档的应用程序是“开放”的。不遵循RFC文档中的协议的应用程序是“专用”的。</p>
<h3 id="UDP套接字"><a href="#UDP套接字" class="headerlink" title="UDP套接字"></a>UDP套接字</h3>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之享元模式--共享内存来节省空间</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%9D%A5%E8%8A%82%E7%9C%81%E7%A9%BA%E9%97%B4.html</url>
    <content><![CDATA[<h1 id="设计模式之享元模式–共享内存来节省空间"><a href="#设计模式之享元模式–共享内存来节省空间" class="headerlink" title="设计模式之享元模式–共享内存来节省空间"></a>设计模式之享元模式–共享内存来节省空间</h1><p><code>享元模式</code>是说共享单元，如果有一样的部分那么共享一个组件而不是复制，也就是传址不传值。</p>
<blockquote>
<p>运用共享技术有效地支持大量细粒度的对象。</p>
</blockquote>
<h2 id="为什么要使用享元模式"><a href="#为什么要使用享元模式" class="headerlink" title="为什么要使用享元模式"></a>为什么要使用享元模式</h2><p>享元模式体现在很多地方，比如后端共享一套代码给前端各个平台，很多接口都是同一个。</p>
<p>享元模式是复用性的体现，大量节省了空间。</p>
<p>比如棋牌游戏，棋子和牌都是一样的，那么他们就可以复用同一个。</p>
<h4 id="五子棋游戏"><a href="#五子棋游戏" class="headerlink" title="五子棋游戏"></a>五子棋游戏</h4><p>五子棋只有<code>黑子</code>和<code>白子</code>，虽然我们用到了很多，但是他们其实指向了同一个内存空间，只不过创建了很多对象而已。</p>
<h4 id="象棋游戏"><a href="#象棋游戏" class="headerlink" title="象棋游戏"></a>象棋游戏</h4><p>象棋也只有<code>车马炮</code>这些棋子，同样可以复用，不然如果你每个棋局重新创建，那么内存很容易溢出。</p>
<h4 id="扑克牌游戏"><a href="#扑克牌游戏" class="headerlink" title="扑克牌游戏"></a>扑克牌游戏</h4><p>扑克牌也只有<code>123</code>到大王这些固定的牌。</p>
<h4 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h4><p>很多递归算法也可以通过享元模式来优化，递归到最后其实有很多是重复的值，而如果每个重复的值都需要重新占用空间，那么造成了大量的空间浪费，这也是递归慢和容易内存溢出的原因之一。</p>
<p>享元模式其实很简单，就是有需要的时候把已经存在的东西拿出来复用。</p>
<p>比如可以通过数组存储，然后需要的时候直接复用就好了。</p>
<p>比如通过<code>简单工厂</code>来创建对象的时候，如果有很多请求过来访问这个工厂，那么工厂需要创建很多对象返回。</p>
<p>而如果通过数组存起来，那么只返回一个对象，就节省了空间。</p>
<p>当然了，享元模式共享的只能是<code>可读对象</code>，一定是不可修改的。</p>
<p>如果可以修改就会造成某个地方修改而其他地方不可用的bug。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之组合模式--树形结构的最佳实践</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html</url>
    <content><![CDATA[<h1 id="设计模式之组合模式–树形结构的最佳实践"><a href="#设计模式之组合模式–树形结构的最佳实践" class="headerlink" title="设计模式之组合模式–树形结构的最佳实践"></a>设计模式之组合模式–树形结构的最佳实践</h1><p><code>组合模式</code>是部分组合成整体。</p>
<blockquote>
<p>将对象组合成树形结构以表示’部分’-‘整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
</blockquote>
<h2 id="为什么要使用组合模式"><a href="#为什么要使用组合模式" class="headerlink" title="为什么要使用组合模式"></a>为什么要使用组合模式</h2><p>最常用到组合模式的应该就是树形结构了。</p>
<p>比如公司-部门的结构，文件夹-文件的结构。</p>
<p>首先有一个共同的父类。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组合模式</span></span><br><span class="line"><span class="comment"> * 组合抽象类</span></span><br><span class="line"><span class="comment"> * 组合的部件和整体都继承这个抽象类，组合出这个抽象类的整体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$name</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加一个Component类型的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">Component <span class="variable">$component</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除一个Component类型的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">Component <span class="variable">$component</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"><span class="keyword">int</span> <span class="variable">$depth</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后实现支节点和叶子节点两个类</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Arr</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组合模式</span></span><br><span class="line"><span class="comment"> * 组合的支节点，可以有子节点，字节的需要是Component类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$arr</span> = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加一个Component类型的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">Component <span class="variable">$component</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;arr[] = <span class="variable">$component</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除一个Component类型的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">Component <span class="variable">$component</span></span>) </span>&#123;</span><br><span class="line">        <span class="title class_">Arr</span>::<span class="title function_ invoke__">where</span>(<span class="variable language_">$this</span>-&gt;arr, <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$value</span>, <span class="variable">$key</span></span>) <span class="keyword">use</span> (<span class="params"><span class="variable">$component</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$value</span> == <span class="variable">$component</span>) &#123;</span><br><span class="line">                <span class="keyword">unset</span>(<span class="variable language_">$this</span>-&gt;arr[<span class="variable">$key</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"><span class="keyword">int</span> <span class="variable">$depth</span></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="title function_ invoke__">str_repeat</span>(<span class="string">&#x27;-&#x27;</span>,<span class="variable">$depth</span>) . <span class="variable language_">$this</span>-&gt;name);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable language_">$this</span>-&gt;arr <span class="keyword">as</span> <span class="variable">$k</span> =&gt; <span class="variable">$v</span>) &#123;</span><br><span class="line">            <span class="variable">$v</span>-&gt;<span class="title function_ invoke__">show</span>(<span class="number">2</span>+<span class="variable">$depth</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组合模式</span></span><br><span class="line"><span class="comment"> * 组合的叶子节点</span></span><br><span class="line"><span class="comment"> * 叶子节点不能添加和移除字节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加一个Component类型的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">Component <span class="variable">$component</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除一个Component类型的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">Component <span class="variable">$component</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"><span class="keyword">int</span> <span class="variable">$depth</span></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="title function_ invoke__">str_repeat</span>(<span class="string">&#x27;-&#x27;</span>,<span class="variable">$depth</span>) . <span class="variable language_">$this</span>-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端通过任意添加子节点的方式来完成组合。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">$root</span> = <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$root</span>);</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="variable">$root</span>-&gt;<span class="title function_ invoke__">add</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$root</span>);</span><br><span class="line"><span class="variable">$root</span>-&gt;<span class="title function_ invoke__">remove</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$root</span>);</span><br><span class="line"><span class="variable">$root</span>-&gt;<span class="title function_ invoke__">add</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="variable">$ab</span> = <span class="keyword">new</span> <span class="title class_">Leaf</span>(<span class="string">&#x27;ab&#x27;</span>);</span><br><span class="line"><span class="variable">$a</span>-&gt;<span class="title function_ invoke__">add</span>(<span class="variable">$ab</span>);</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="variable">$root</span>-&gt;<span class="title function_ invoke__">add</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="variable">$root</span>-&gt;<span class="title function_ invoke__">show</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/../images/composite.png" alt="composite"></p>
<p>代码放在了我的github上面。</p>
<ul>
<li><a href="https://github.com/Thepatterraining/design-pattern">设计模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之外观模式--抽象出高层接口更加易用</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%87%BA%E9%AB%98%E5%B1%82%E6%8E%A5%E5%8F%A3%E6%9B%B4%E5%8A%A0%E6%98%93%E7%94%A8.html</url>
    <content><![CDATA[<h1 id="设计模式之外观模式–抽象出高层接口更加易用"><a href="#设计模式之外观模式–抽象出高层接口更加易用" class="headerlink" title="设计模式之外观模式–抽象出高层接口更加易用"></a>设计模式之外观模式–抽象出高层接口更加易用</h1><p><code>外观模式</code>是套个壳子，隐藏细节。</p>
<blockquote>
<p>为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使子系统更加易用。</p>
</blockquote>
<h2 id="为什么要使用外观模式"><a href="#为什么要使用外观模式" class="headerlink" title="为什么要使用外观模式"></a>为什么要使用外观模式</h2><p>外观模式是对底层的抽象，隐藏你不该知道的东西，暴露你应该知道的东西，更加符合<code>迪米特法则</code>，<code>接口隔离原则</code>。</p>
<p>外观模式的本质同样是套壳子，比如你有一个缓存系统。</p>
<p>这个缓存系统存入数据需要</p>
<ol>
<li>加锁</li>
<li>存数据</li>
<li>释放锁</li>
</ol>
<p>我们的客户端实现</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line"><span class="variable">$lock</span> = <span class="keyword">new</span> lock;</span><br><span class="line"><span class="variable">$lock</span>-&gt;<span class="title function_ invoke__">lock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//存入数据</span></span><br><span class="line"><span class="variable">$redis</span> = <span class="keyword">new</span> redis;</span><br><span class="line"><span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">set</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line"><span class="variable">$lock</span>-&gt;<span class="title function_ invoke__">unlock</span>();</span><br></pre></td></tr></table></figure>

<p>这只是比较简单的几步，有的可能会更加复杂，你需要调用多个接口。</p>
<p>这样的话可以使用外观模式封装一下这些细节。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 外观模式</span></span><br><span class="line"><span class="comment"> * 外观的封装，对底层模块的封装</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对存入缓存进行封装</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        <span class="variable">$lock</span> = <span class="keyword">new</span> lock;</span><br><span class="line">        <span class="variable">$lock</span>-&gt;<span class="title function_ invoke__">lock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存入数据</span></span><br><span class="line">        <span class="variable">$redis</span> = <span class="keyword">new</span> redis;</span><br><span class="line">        <span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">set</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        <span class="variable">$lock</span>-&gt;<span class="title function_ invoke__">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用外观的客户端</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">$facade</span> = <span class="keyword">new</span> Facade;</span><br><span class="line"><span class="variable">$facade</span>-&gt;<span class="title function_ invoke__">set</span>();</span><br></pre></td></tr></table></figure>

<p>其实外观就是封装的思想体现。</p>
<p>代码放在了我的github上面。</p>
<ul>
<li><a href="https://github.com/Thepatterraining/design-pattern">设计模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之适配器模式--不兼容变兼容接口</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-%E4%B8%8D%E5%85%BC%E5%AE%B9%E5%8F%98%E5%85%BC%E5%AE%B9%E6%8E%A5%E5%8F%A3.html</url>
    <content><![CDATA[<h1 id="设计模式之适配器模式–不兼容变兼容接口"><a href="#设计模式之适配器模式–不兼容变兼容接口" class="headerlink" title="设计模式之适配器模式–不兼容变兼容接口"></a>设计模式之适配器模式–不兼容变兼容接口</h1><p><code>适配器模式</code>可以增加接口的易用性，使得不兼容的接口变得兼容。</p>
<blockquote>
<p>将一个接口转换成另外的接口，使得原本不兼容的接口变得兼容。</p>
</blockquote>
<h2 id="为什么要使用适配器模式"><a href="#为什么要使用适配器模式" class="headerlink" title="为什么要使用适配器模式"></a>为什么要使用适配器模式</h2><p>比如你的接口设计存在缺点，不够易用，不能复用但又希望复用的时候。</p>
<p>比如你要对接多个平台的接口他们互不兼容的时候。</p>
<p>现实中也有很多适配器，比如安卓苹果的转换头，比如usb到type-c的转换头，都是因为两边的接口不同，不兼容所以需要一个适配器。</p>
<p>下面是一个手机类，现在需要充电，但是手机的充电需要typec接口。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器模式</span></span><br><span class="line"><span class="comment"> * 手机类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mobile</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给手机充电操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">charge</span>(<span class="params">ITypec <span class="variable">$typec</span></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;使用typec接口给手机充电&#x27;</span>);</span><br><span class="line">        <span class="variable">$typec</span>-&gt;<span class="title function_ invoke__">typec</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在只有一个usb接口可以充电。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器模式</span></span><br><span class="line"><span class="comment"> * 需要适配的类</span></span><br><span class="line"><span class="comment"> * usb接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">usb</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">usb</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;电脑usb接口&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们增加一个适配器，也就是typec转usb的头。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器模式</span></span><br><span class="line"><span class="comment"> * 适配器接口</span></span><br><span class="line"><span class="comment"> * typec接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITypec</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">typec</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器模式</span></span><br><span class="line"><span class="comment"> * 适配器类，typec转换usb的适配器</span></span><br><span class="line"><span class="comment"> * typec接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">typec</span> <span class="keyword">implements</span> <span class="title">ITypec</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$usb</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;usb = <span class="keyword">new</span> usb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">typec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;接口适配器&#x27;</span>);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;usb-&gt;<span class="title function_ invoke__">usb</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的客户端就可以使用这个适配器了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">$mobile</span> = <span class="keyword">new</span> <span class="title class_">mobile</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$mobile</span>-&gt;<span class="title function_ invoke__">charge</span>(<span class="keyword">new</span> typec);</span><br></pre></td></tr></table></figure>

<p>这是<code>对象适配器</code>，还有类适配器，类适配器的话需要继承要适配的类。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器模式</span></span><br><span class="line"><span class="comment"> * 适配器类，typec转换usb的适配器</span></span><br><span class="line"><span class="comment"> * typec接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">typec</span> <span class="keyword">extends</span> <span class="title">usb</span> <span class="keyword">implements</span> <span class="title">ITypec</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不再需要存储对象，直接继承了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">typec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;接口适配器&#x27;</span>);</span><br><span class="line">        <span class="comment">//$this-&gt;usb-&gt;usb();</span></span><br><span class="line">        <span class="comment">//这里改成使用父类的usb方法。</span></span><br><span class="line">        <span class="built_in">parent</span>::<span class="title function_ invoke__">usb</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="适配器和代理模式还有装饰器模式的区别"><a href="#适配器和代理模式还有装饰器模式的区别" class="headerlink" title="适配器和代理模式还有装饰器模式的区别"></a>适配器和代理模式还有装饰器模式的区别</h3><p>这几个设计模式其实都差不多，你也可以说使用了typec代理了usb。只是角度不同所以名字不同罢了。</p>
<ul>
<li>代理模式 更注重代理，代理了原有类。</li>
<li>装饰器模式 比代理模式更加灵活多样。</li>
<li>适配器模式 更注重兼容性，为了兼容别的类，而不是代理和装饰功能。</li>
</ul>
<p>虽然角度不同，但是我觉得核心都差不多。<strong>这几个设计模式都是需要修改原有类的时候，没有选择修改，而是套了壳子，来扩展功能</strong>。这是一种好的思想，灵活运用思想更重要。</p>
<p>代码放在了我的github上面。</p>
<ul>
<li><a href="https://github.com/Thepatterraining/design-pattern">设计模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之装饰器模式--各种功能随意扩展</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F-%E5%90%84%E7%A7%8D%E5%8A%9F%E8%83%BD%E9%9A%8F%E6%84%8F%E6%89%A9%E5%B1%95.html</url>
    <content><![CDATA[<h1 id="设计模式之装饰器模式–各种功能随意扩展"><a href="#设计模式之装饰器模式–各种功能随意扩展" class="headerlink" title="设计模式之装饰器模式–各种功能随意扩展"></a>设计模式之装饰器模式–各种功能随意扩展</h1><p><code>装饰器模式</code>是灵活给原有类装饰新功能。</p>
<blockquote>
<p>动态的给对象添加额外职责，就增加功能来说，装饰模式比生成子类更为灵活。</p>
</blockquote>
<h2 id="为什么要使用装饰器模式"><a href="#为什么要使用装饰器模式" class="headerlink" title="为什么要使用装饰器模式"></a>为什么要使用装饰器模式</h2><p>如果你需要添加一些额外的功能，再不修改原有类的基础上，给原有类套个壳。并且可以套多个壳，我觉得装饰器模式有点像中间件。</p>
<p>比如你现在有一个登录的功能。</p>
<p>你现在需要给登录加一个权限控制。然后还要增加一个登录日志。还要增加登录微信通知。如果修改原有类可能引起未知bug。</p>
<p>可以使用装饰器模式。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 装饰器模式</span></span><br><span class="line"><span class="comment"> * 装饰器父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$compent</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;compent = <span class="variable">$compent</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;compent-&gt;<span class="title function_ invoke__">login</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 装饰器模式</span></span><br><span class="line"><span class="comment"> * 权限装饰器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginAuth</span> <span class="keyword">extends</span> <span class="title">Decorate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;判断登录权限&#x27;</span>);</span><br><span class="line">        <span class="built_in">parent</span>::<span class="title function_ invoke__">login</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 装饰器模式</span></span><br><span class="line"><span class="comment"> * 登录日志装饰器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginLog</span> <span class="keyword">extends</span> <span class="title">Decorate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">parent</span>::<span class="title function_ invoke__">login</span>();</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;记录登录日志&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 装饰器模式</span></span><br><span class="line"><span class="comment"> * 微信通知装饰器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginWechat</span> <span class="keyword">extends</span> <span class="title">Decorate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">parent</span>::<span class="title function_ invoke__">login</span>();</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;发送微信登录通知&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是原来的登录功能</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 装饰器模式</span></span><br><span class="line"><span class="comment"> * 核心代码</span></span><br><span class="line"><span class="comment"> * 登录功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">login</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;用户登录&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>原来的客户端直接调用login，只有登录功能。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$login</span> = <span class="keyword">new</span> <span class="title class_">login</span>();</span><br><span class="line"><span class="variable">$login</span>-&gt;<span class="title function_ invoke__">login</span>();</span><br></pre></td></tr></table></figure>

<p>增加了装饰器以后可以把登录功能放入装饰器。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$login</span> = <span class="keyword">new</span> login;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用权限装饰器</span></span><br><span class="line"><span class="variable">$login</span> = <span class="keyword">new</span> <span class="title class_">LoginAuth</span>(<span class="variable">$login</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用登录日志装饰器</span></span><br><span class="line"><span class="variable">$login</span> = <span class="keyword">new</span> <span class="title class_">LoginLog</span>(<span class="variable">$login</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用微信通知装饰器</span></span><br><span class="line"><span class="variable">$login</span> = <span class="keyword">new</span> <span class="title class_">LoginWechat</span>(<span class="variable">$login</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$login</span>-&gt;<span class="title function_ invoke__">login</span>();</span><br></pre></td></tr></table></figure>

<p><img src="/../images/decorator1.png" alt="decorate"></p>
<p>还可以任意调换装饰器的位置，可以先发送微信通知在记录登录日志。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">$login</span> = <span class="keyword">new</span> login;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用微信通知装饰器</span></span><br><span class="line"><span class="variable">$login</span> = <span class="keyword">new</span> <span class="title class_">LoginWechat</span>(<span class="variable">$login</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用登录日志装饰器</span></span><br><span class="line"><span class="variable">$login</span> = <span class="keyword">new</span> <span class="title class_">LoginLog</span>(<span class="variable">$login</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用权限装饰器</span></span><br><span class="line"><span class="variable">$login</span> = <span class="keyword">new</span> <span class="title class_">LoginAuth</span>(<span class="variable">$login</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$login</span>-&gt;<span class="title function_ invoke__">login</span>();</span><br></pre></td></tr></table></figure>

<p><img src="/../images/decorator2.png" alt="decorate"></p>
<p>这个模式就非常灵活，可以任意组装自己的装饰，比如购买支付的时候，需要装饰积分发放，账单通知这些。而且每个装饰器的职责单一，方便插拔，如果不需要一个装饰器的时候把这个装饰器去掉就可以了。</p>
<p>代码放在了我的github上面。</p>
<ul>
<li><a href="https://github.com/Thepatterraining/design-pattern">设计模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之桥接模式--组合优于继承的体现</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E4%BC%98%E4%BA%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BD%93%E7%8E%B0.html</url>
    <content><![CDATA[<h1 id="设计模式之桥接模式–组合优于继承的体现"><a href="#设计模式之桥接模式–组合优于继承的体现" class="headerlink" title="设计模式之桥接模式–组合优于继承的体现"></a>设计模式之桥接模式–组合优于继承的体现</h1><p><code>桥接模式</code>是灵活运用组合对象而不是继承类来实现功能。</p>
<blockquote>
<p>将抽象与实现部分分离，使他们都可以独立变化。</p>
</blockquote>
<h2 id="为什么要使用桥接模式"><a href="#为什么要使用桥接模式" class="headerlink" title="为什么要使用桥接模式"></a>为什么要使用桥接模式</h2><p><code>继承</code>这个面向对象的特性使得我们继承父类可以继承父类的功能，在使用多态特性可以自由修改子类，使得我们的设计很好用。</p>
<p>但是<code>继承</code>有一个问题，就是<code>强耦合</code>。继承一个父类代表拥有这个父类的能力，但这个父类的很多能力你可能并不需要。</p>
<p>还有如果继承关系很复杂的时候，使用继承会导致关系复杂到破裂，无法继承。</p>
<p>比如<code>华为</code>手机和<code>小米</code>手机都具有玩游戏，听音乐等功能。按照继承设计就会有下面4个类，如果再实现拍照功能又需要增加2个类。这个继承关系太过复杂。</p>
<ul>
<li><p>手机父类</p>
</li>
<li><p>软件父类</p>
</li>
<li><p>华为游戏手机</p>
</li>
<li><p>华为音乐手机</p>
</li>
<li><p>小米游戏手机</p>
</li>
<li><p>小米音乐手机</p>
</li>
</ul>
<p>如果使用组合的方式，只有4个类。</p>
<ul>
<li>华为手机类</li>
<li>小米手机类</li>
<li>游戏类</li>
<li>音乐类</li>
</ul>
<p>让这4个类互相组合就可以了。如果增加个拍照，只需要增加拍照类。这就是抽象和实现分离。手机类就是手机类，软件类就是软件类，互相组合实现功能而不是互相继承。</p>
<p>桥接模式可以理解成连接两个部分，比如连接手机和软件两个部分。像一座桥一样。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桥接模式</span></span><br><span class="line"><span class="comment"> * 桥的一端</span></span><br><span class="line"><span class="comment"> * 手机类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mobile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$soft</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行手机功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置相应的软件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setSoft</span>(<span class="params">Soft <span class="variable">$soft</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;soft = <span class="variable">$soft</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桥接模式</span></span><br><span class="line"><span class="comment"> * 桥的一端</span></span><br><span class="line"><span class="comment"> * 软件类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Soft</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行软件功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是手机类的具体实现和软件的具体实现。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桥接模式</span></span><br><span class="line"><span class="comment"> * 桥的一端</span></span><br><span class="line"><span class="comment"> * 华为手机类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaWei</span> <span class="keyword">extends</span> <span class="title">Mobile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行手机功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;华为手机&#x27;</span>);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;soft-&gt;<span class="title function_ invoke__">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桥接模式</span></span><br><span class="line"><span class="comment"> * 桥的一端</span></span><br><span class="line"><span class="comment"> * 小米手机类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoMi</span> <span class="keyword">extends</span> <span class="title">Mobile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行手机功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;小米手机&#x27;</span>);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;soft-&gt;<span class="title function_ invoke__">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桥接模式</span></span><br><span class="line"><span class="comment"> * 游戏软件类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> <span class="keyword">extends</span> <span class="title">Soft</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行软件功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;玩王者荣耀&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桥接模式</span></span><br><span class="line"><span class="comment"> * 音乐软件类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Music</span> <span class="keyword">extends</span> <span class="title">Soft</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行软件功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;打开网易云音乐&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端调用根据需要注入不同的软件就可以实现不同的软件功能而不再需要增加新的类来实现。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">$obj1</span> = <span class="keyword">new</span> HuaWei;</span><br><span class="line"><span class="variable">$obj1</span>-&gt;<span class="title function_ invoke__">setSoft</span>(<span class="keyword">new</span> Game);</span><br><span class="line"><span class="variable">$obj1</span>-&gt;<span class="title function_ invoke__">run</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj1</span>-&gt;<span class="title function_ invoke__">setSoft</span>(<span class="keyword">new</span> Music);</span><br><span class="line"><span class="variable">$obj1</span>-&gt;<span class="title function_ invoke__">run</span>();</span><br></pre></td></tr></table></figure>

<p><img src="/../images/bridge.png" alt="bridge"></p>
<p>桥接模式解决了继承过于复杂的问题，体现了组合优于继承的思想。</p>
<p>代码放在了我的github上面。</p>
<ul>
<li><a href="https://github.com/Thepatterraining/design-pattern">设计模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之代理模式--代理转发中间层</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E4%B8%AD%E9%97%B4%E5%B1%82.html</url>
    <content><![CDATA[<h1 id="设计模式之代理模式–代理转发中间层"><a href="#设计模式之代理模式–代理转发中间层" class="headerlink" title="设计模式之代理模式–代理转发中间层"></a>设计模式之代理模式–代理转发中间层</h1><p><code>代理模式</code>是代理原来的类或对象，在不改变原有类或对象的基础上增加新的功能。</p>
<blockquote>
<p>为其他对象提供一种代理以控制对这个对象的访问。</p>
</blockquote>
<h2 id="为什么要使用原型模式"><a href="#为什么要使用原型模式" class="headerlink" title="为什么要使用原型模式"></a>为什么要使用原型模式</h2><p>代理模式最常用的场景比如我们开发的代理中间层，来代理前端的请求，隐藏真正的后端接口。还有很多远程代理，科学上网也属于代理的一种。</p>
<p>还有虚拟代理，比如浏览器的图片会先出现图片框在加载图片，图片框其实就是一个对图片的代理。</p>
<p>安全代理，用来控制真实对象的访问权限，这个也是代理中间层会做到的。</p>
<p>在我们的代码中一般会使用代理模式做一些原有类做不到的事情，对原有类的扩展。</p>
<p>比如<code>打印sql</code>，<code>打印日志</code>，<code>发送通知</code>这些跟具体业务无关的功能增加。</p>
<p>这也更加符合<code>开闭原则</code>。通过增加代理类的方式来增加功能而不是修改原来的类。</p>
<p>代理模式要求<code>代理类</code>和<code>原类</code>都实现同一个接口，也是对接口实现才能实现用代理类来替换原类。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//代理接口，代理类和原类都需要实现这个接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IProxy</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类，实现代理接口，代理原类，客户端访问代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">proxy</span> <span class="keyword">implements</span> <span class="title">IProxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$proxy</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">IProxy <span class="variable">$proxy</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//把要代理的原类传进来</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;proxy = <span class="variable">$proxy</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//前置功能</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//访问原类</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;proxy-&gt;<span class="title function_ invoke__">proxy</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后置功能</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">product</span> <span class="keyword">implements</span> <span class="title">IProxy</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//原类的功能</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>原来没有代理的时候，直接调用原类。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">$product</span> = <span class="keyword">new</span> <span class="title class_">product</span>();</span><br><span class="line"><span class="variable">$product</span>-&gt;<span class="title function_ invoke__">proxy</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有了代理类之后，客户端调用代理类，隐藏原类。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$proxy</span> = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">new</span> <span class="title class_">product</span>());</span><br><span class="line"><span class="variable">$proxy</span>-&gt;<span class="title function_ invoke__">proxy</span>();</span><br></pre></td></tr></table></figure>

<p>其实就是套了一层壳。</p>
<p>代码放在了我的github上面。</p>
<ul>
<li><a href="https://github.com/Thepatterraining/design-pattern">设计模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之原型模式--打印机快速复制的原理</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E6%89%93%E5%8D%B0%E6%9C%BA%E5%BF%AB%E9%80%9F%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86.html</url>
    <content><![CDATA[<h1 id="设计模式之原型模式–打印机快速复制的原理"><a href="#设计模式之原型模式–打印机快速复制的原理" class="headerlink" title="设计模式之原型模式–打印机快速复制的原理"></a>设计模式之原型模式–打印机快速复制的原理</h1><p><code>原型模式</code>是一个克隆模式，以一个原型进行克隆，复制。</p>
<blockquote>
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
</blockquote>
<h2 id="为什么要使用原型模式"><a href="#为什么要使用原型模式" class="headerlink" title="为什么要使用原型模式"></a>为什么要使用原型模式</h2><p>因为原型模式可以克隆整个对象而不用重新生成。</p>
<p>如果有一个订单对象，你要是重新生成，需要再次查询数据库，这是一个很耗时的操作，如果直接复制就不需要耗时了。</p>
<p>在php里面实现很简单，每个类有<code>__clone</code>魔术方法，实现这个方法就好了。</p>
<p>先看不实现这个方法的克隆。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原型模式</span></span><br><span class="line"><span class="comment"> * 实现__clone魔术方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$arr</span> = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj1</span> = <span class="keyword">new</span> PrototypeClass;</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$obj1</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj2</span> = <span class="keyword">clone</span> <span class="variable">$obj1</span>;</span><br><span class="line"><span class="variable">$obj2</span>-&gt;name = <span class="string">&#x27;456&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$obj2</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/../images/prototype.png" alt="原型模式"></p>
<p>可以看到成功克隆过来了，两个对象互不影响。</p>
<p>我们看一下修改第二个对象的<code>arr</code>属性呢</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">$obj1</span> = <span class="keyword">new</span> PrototypeClass;</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$obj1</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj2</span> = <span class="keyword">clone</span> <span class="variable">$obj1</span>;</span><br><span class="line"><span class="variable">$obj2</span>-&gt;name = <span class="string">&#x27;456&#x27;</span>;</span><br><span class="line"><span class="variable">$obj2</span>-&gt;arr = [<span class="string">&#x27;1&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$obj2</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../images/prototype2.png" alt="原型模式"></p>
<p>修改数组也没问题，也就是说，直接使用clone就可以完成深复制的拷贝操作。php本身通过clone关键字完成了原型模式。</p>
<p>代码放在了我的github上面。</p>
<ul>
<li><a href="https://github.com/Thepatterraining/design-pattern">设计模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之建造者模式--比工厂更精细的流水线生成</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-%E6%AF%94%E5%B7%A5%E5%8E%82%E6%9B%B4%E7%B2%BE%E7%BB%86%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%94%9F%E6%88%90.html</url>
    <content><![CDATA[<h1 id="设计模式之建造者模式–比工厂更精细的流水线生成"><a href="#设计模式之建造者模式–比工厂更精细的流水线生成" class="headerlink" title="设计模式之建造者模式–比工厂更精细的流水线生成"></a>设计模式之建造者模式–比工厂更精细的流水线生成</h1><p><code>建造者模式</code>是创建一个稳定流程的复杂对象，隐藏创建的具体流程、过程、细节。</p>
<blockquote>
<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
</blockquote>
<h2 id="为什么要使用建造者模式"><a href="#为什么要使用建造者模式" class="headerlink" title="为什么要使用建造者模式"></a>为什么要使用建造者模式</h2><p><strong>当你需要创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化</strong>。</p>
<p>建造者分离了构建和表示，他把如何创建隐藏了起来，你只要告诉建造者你需要什么，他就会给你建造什么。</p>
<h3 id="建造者模式和工厂模式有什么区别"><a href="#建造者模式和工厂模式有什么区别" class="headerlink" title="建造者模式和工厂模式有什么区别"></a>建造者模式和工厂模式有什么区别</h3><p>工厂模式更像一个大工厂，比如<code>口罩工厂</code>负责生产<code>雾霾口罩</code>，<code>防毒口罩</code>等等。<strong>根据你需要的类型来判断给你什么</strong>。</p>
<p>那<code>雾霾口罩</code>怎么生产呢？假设需要123三个步骤，那么建造者就是负责这三个步骤的，你告诉建造者你需要<code>雾霾口罩</code>，那么他会给你一个完整的，建造好的<code>雾霾口罩</code>而不是<code>口罩半成品</code>。</p>
<p>所以建造者更像一个完整的流水线，按照步骤建造好成品给你。</p>
<p>再比如你去饭店点餐，<code>工厂模式</code>是你点哪个菜就给你哪个菜。<code>建造者模式</code>是你点的菜怎么做。你点了<code>鱼香肉丝</code>，建造者会按照步骤，哪一步该放肉，哪一步该放盐，最后做好了把菜给你。</p>
<p><code>建造者模式</code>还有一个作用就是<code>约束</code>。抽象出的建造流程不可改变，<code>口罩</code>不能少个过滤网，<code>饭菜</code>不能没有放盐。</p>
<p><code>建造者模式</code>也避免了复杂对象创建流程的缺失。</p>
<h3 id="php实现建造者模式"><a href="#php实现建造者模式" class="headerlink" title="php实现建造者模式"></a>php实现建造者模式</h3><p>假设现在有一个对接第三方支付的需求。使用建造者模式。</p>
<p>我们要先抽象出一个建造流程。使用抽象类，对接第三方支付大概需要一个加密，一个读取配置信息，然后把这些参数合并发送出去。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建造者模式</span></span><br><span class="line"><span class="comment"> * 建造者抽象类</span></span><br><span class="line"><span class="comment"> * 抽象出整个建造流程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Build</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密流程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">buildHash</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取配置流程，比如appid这些</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">buildConfig</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们的第三方支付类继承这个抽象建造者来实现具体的第三方支付建造者。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建造者模式</span></span><br><span class="line"><span class="comment"> * 建造者抽象类</span></span><br><span class="line"><span class="comment"> * 抽象出整个建造流程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadBuild</span> <span class="keyword">extends</span> <span class="title">Build</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密流程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">buildHash</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//省略加密代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hash&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取配置流程，比如appid这些</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">buildConfig</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//省略配置代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;config&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送http请求流程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">http</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//省略发送代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;success&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了建造者，我们现在需要一个组装这整个建造流程的<code>监工</code>，<code>指挥者</code>。来保证整个流程不出错。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建造者模式</span></span><br><span class="line"><span class="comment"> * 指挥者类</span></span><br><span class="line"><span class="comment"> * 按照流程建造，返回建造后的类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span></span>&#123;</span><br><span class="line">    <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createBuild</span>(<span class="params">Build <span class="variable">$build</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$build</span>-&gt;<span class="title function_ invoke__">buildHash</span>();</span><br><span class="line">        <span class="variable">$build</span>-&gt;<span class="title function_ invoke__">buildConfig</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$build</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们的客户端调用。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">$threadPay</span> = <span class="title class_">Director</span>::<span class="title function_ invoke__">createBuild</span>(<span class="keyword">new</span> <span class="title class_">ThreadBuild</span>());  </span><br><span class="line"><span class="variable">$threadPay</span>-&gt;<span class="title function_ invoke__">http</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果接入了别的第三方支付，那么我们只需要增加具体建造者就可以了，如果和抽象建造者冲突，那么说明没有抽象好。在客户端只需要更改具体建造者就可以了。</p>
<p>代码放在了我的github上面。</p>
<ul>
<li><a href="https://github.com/Thepatterraining/design-pattern">设计模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之工厂方法模式--更加符合开闭原则的工厂模式</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-%E6%9B%B4%E5%8A%A0%E7%AC%A6%E5%90%88%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%E7%9A%84%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="设计模式之工厂方法模式–更加符合开闭原则的工厂模式"><a href="#设计模式之工厂方法模式–更加符合开闭原则的工厂模式" class="headerlink" title="设计模式之工厂方法模式–更加符合开闭原则的工厂模式"></a>设计模式之工厂方法模式–更加符合开闭原则的工厂模式</h1><p><code>工厂方法模式</code>是简单工厂模式的升级版本，更加符合开闭原则。</p>
<blockquote>
<p>定义一个创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</p>
</blockquote>
<h2 id="为什么要使用工厂方法模式"><a href="#为什么要使用工厂方法模式" class="headerlink" title="为什么要使用工厂方法模式"></a>为什么要使用工厂方法模式</h2><p>之前说了<code>简单工厂模式</code>，<a href="https://blog.csdn.net/Thepatterraining/article/details/105904797">简单工厂模式</a>的工厂类是这样的。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//简单工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">static</span> <span class="title">createPay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (小程序) &#123;</span><br><span class="line">            <span class="comment">//小程序支付</span></span><br><span class="line">            <span class="variable">$pay</span> = <span class="keyword">new</span> miniWechatPay;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (公众号) &#123;</span><br><span class="line">            <span class="comment">//公众号支付</span></span><br><span class="line">            <span class="variable">$pay</span> = <span class="keyword">new</span> jsAPIPay;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pc) &#123;</span><br><span class="line">            <span class="comment">//扫码支付</span></span><br><span class="line">            <span class="variable">$pay</span> = <span class="keyword">new</span> nativePay;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$pay</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的工厂类是违反了开闭原则的，如果需要增加支付方法就需要修改这个工厂类，<strong>工厂方法模式就是解决这个问题的，使用工厂方法模式后不需要修改工厂类，只需要新增工厂类</strong>。</p>
<h2 id="改成工厂方法模式"><a href="#改成工厂方法模式" class="headerlink" title="改成工厂方法模式"></a>改成工厂方法模式</h2><p>为了符合开闭原则，我们需要创建多个工厂类和一个工厂接口。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span></span>&#123;</span><br><span class="line">    <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createPay</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">miniFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;</span><br><span class="line">    <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createPay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> miniWechatPay;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">jsAPIFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;</span><br><span class="line">    <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createPay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> jsAPIPay;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">nativeFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;</span><br><span class="line">    <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createPay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> nativePay;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好了，我们把实例化放到了这些子类中，如果增加实例化的需求只需要增加工厂类就可以了。这就是工厂方法模式。</p>
<p>相比简单工厂来说，这有一个缺点就是需要修改的时候虽然不需要修改工厂类了，但是需要修改客户端了。</p>
<p>下面的是原来的客户端。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//微信支付方法 省略了类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wechatPay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...省略</span></span><br><span class="line">    <span class="variable">$pay</span> = factory::<span class="title function_ invoke__">createPay</span>();</span><br><span class="line">    <span class="variable">$pay</span>-&gt;<span class="title function_ invoke__">pay</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的是工厂方法模式的客户端</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//微信支付方法 省略了类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wechatPay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...省略</span></span><br><span class="line">    <span class="variable">$pay</span> = mini<span class="title class_">Factory</span>::<span class="title function_ invoke__">createPay</span>(); <span class="comment">//需要修改这里</span></span><br><span class="line">    <span class="variable">$pay</span>-&gt;<span class="title function_ invoke__">pay</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果不想修改客户端也可以再增加一个简单工厂类来实例化工厂方法模式的类。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">factory</span></span>&#123;</span><br><span class="line">    <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (小程序) &#123;</span><br><span class="line">            <span class="keyword">return</span> mini<span class="title class_">Factory</span>::<span class="title function_ invoke__">createPay</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//省略其他判断和实例化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是我觉得这样还不如直接用简单工厂来的好。</p>
<p>总的来说，简单工厂和工厂方法模式各有优缺点吧，不过对于php来说我觉得简单工厂就足以，虽然有修改代码的风险。但是也还好，而且通过封装成数组来实例化也不需要这一堆if-else。</p>
<p>代码放在了我的github上面。</p>
<ul>
<li><a href="https://github.com/Thepatterraining/design-pattern">设计模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>解决composer-npm等包管理工具下载失败的问题</title>
    <url>/%E8%A7%A3%E5%86%B3composer-npm%E7%AD%89%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h1 id="解决composer-npm等包管理工具下载失败的问题"><a href="#解决composer-npm等包管理工具下载失败的问题" class="headerlink" title="解决composer-npm等包管理工具下载失败的问题"></a>解决composer-npm等包管理工具下载失败的问题</h1><p>使用composer npm进行下载依赖包的时候经常需要翻墙。不过国内已经有了很多国内源来加速下载，比如阿里云的国内镜像等。</p>
<p>不过有时候国内镜像并不能解决问题。</p>
<p>还有的时候就算你挂了全局翻墙也不行。</p>
<p>这是因为你使用命令行的时候，是用不到翻墙工具的。</p>
<p>如果你有翻墙工具，那么可以在命令行上面设置一下，使用代理就可以了。</p>
<p>在gitbash上面的设置。</p>
<blockquote>
<p>export http_proxy&#x3D;<a href="http://127.0.0.1:41091/">http://127.0.0.1:41091</a>  &#x2F;&#x2F;这个端口是你本地代理工具提供的端口<br>export https_proxy&#x3D;<a href="http://127.0.0.1:41091/">http://127.0.0.1:41091</a> &#x2F;&#x2F;这个端口是你本地代理工具提供的端口</p>
</blockquote>
<p>在cmd上的设置</p>
<blockquote>
<p>set http_proxy&#x3D;<a href="http://127.0.0.1:41091/">http://127.0.0.1:41091</a>  &#x2F;&#x2F;这个端口是你本地代理工具提供的端口<br>set https_proxy&#x3D;<a href="http://127.0.0.1:41091/">http://127.0.0.1:41091</a> &#x2F;&#x2F;这个端口是你本地代理工具提供的端口</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>javascript</tag>
        <tag>npm</tag>
        <tag>composer</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之简单工厂模式--利用工厂解耦实例化对象</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%E5%88%A9%E7%94%A8%E5%B7%A5%E5%8E%82%E8%A7%A3%E8%80%A6%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1.html</url>
    <content><![CDATA[<h1 id="设计模式之简单工厂模式–利用工厂解耦实例化对象"><a href="#设计模式之简单工厂模式–利用工厂解耦实例化对象" class="headerlink" title="设计模式之简单工厂模式–利用工厂解耦实例化对象"></a>设计模式之简单工厂模式–利用工厂解耦实例化对象</h1><p><code>简单工厂模式</code>是最常被提起的一个设计模式，他的意思是</p>
<blockquote>
<p>利用简单工厂来决定实例化哪个类，而不是由外部程序来决定，把创建对象的操作内聚，解耦到工厂类中。</p>
</blockquote>
<h2 id="为什么要使用简单工厂模式"><a href="#为什么要使用简单工厂模式" class="headerlink" title="为什么要使用简单工厂模式"></a>为什么要使用简单工厂模式</h2><p>工厂模式除了<code>简单工厂模式</code>还有<code>工厂方法模式</code>,<code>抽象工厂模式</code>。</p>
<p>简单工厂模式有什么好处呢？</p>
<p>简单，非常简单。并且拥有工厂模式的特性，解耦对象的生成。</p>
<p>如果不使用工厂模式，那么对象的创建散落在程序的各个地方，如果需要修改，那么很麻烦。</p>
<p>我们在设计类的时候，为了遵循<code>单一职责原则</code>，我们应该把类划分的尽可能单一，拿一个实际应用例子来说，支付场景。</p>
<h3 id="支付场景"><a href="#支付场景" class="headerlink" title="支付场景"></a>支付场景</h3><p>我们需要在小程序端使用小程序支付，公众号端使用h5支付，pc端使用扫码支付。</p>
<p>后端统一提供支付接口。代码类似下面这样。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wechatPay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...省略</span></span><br><span class="line">    <span class="keyword">if</span> (小程序) &#123;</span><br><span class="line">        <span class="comment">//小程序支付</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (公众号) &#123;</span><br><span class="line">        <span class="comment">//公众号支付</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pc) &#123;</span><br><span class="line">        <span class="comment">//扫码支付</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的是一个伪代码，这样写不管扩展性，维护性都不好，更不符合单一职责，所以我们应该把支付逻辑抽出来。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">pay</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pay</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">miniWechatPay</span> <span class="keyword">implements</span> <span class="title">pay</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//调用小程序支付</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">jsAPIPay</span> <span class="keyword">implements</span> <span class="title">pay</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//调用公众号，jsapi支付</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">nativePay</span> <span class="keyword">implements</span> <span class="title">pay</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//调用扫码支付</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//微信支付方法 省略了类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wechatPay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...省略</span></span><br><span class="line">    <span class="keyword">if</span> (小程序) &#123;</span><br><span class="line">        <span class="comment">//小程序支付</span></span><br><span class="line">        <span class="variable">$pay</span> = <span class="keyword">new</span> miniWechatPay;</span><br><span class="line">        <span class="variable">$pay</span>-&gt;<span class="title function_ invoke__">pay</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (公众号) &#123;</span><br><span class="line">        <span class="comment">//公众号支付</span></span><br><span class="line">        <span class="variable">$pay</span> = <span class="keyword">new</span> jsAPIPay;</span><br><span class="line">        <span class="variable">$pay</span>-&gt;<span class="title function_ invoke__">pay</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pc) &#123;</span><br><span class="line">        <span class="comment">//扫码支付</span></span><br><span class="line">        <span class="variable">$pay</span> = <span class="keyword">new</span> nativePay;</span><br><span class="line">        <span class="variable">$pay</span>-&gt;<span class="title function_ invoke__">pay</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在if判断里面有重复的地方，都是调用<code>pay</code>方法，我们可以抽出来。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//微信支付方法 省略了类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wechatPay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...省略</span></span><br><span class="line">    <span class="keyword">if</span> (小程序) &#123;</span><br><span class="line">        <span class="comment">//小程序支付</span></span><br><span class="line">        <span class="variable">$pay</span> = <span class="keyword">new</span> miniWechatPay;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (公众号) &#123;</span><br><span class="line">        <span class="comment">//公众号支付</span></span><br><span class="line">        <span class="variable">$pay</span> = <span class="keyword">new</span> jsAPIPay;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pc) &#123;</span><br><span class="line">        <span class="comment">//扫码支付</span></span><br><span class="line">        <span class="variable">$pay</span> = <span class="keyword">new</span> nativePay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$pay</span>-&gt;<span class="title function_ invoke__">pay</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果接下来我们还要增加刷脸支付等等其他支付怎么办呢，我们只能修改这个方法，这显然是不对的，违反了<code>开闭原则</code>。</p>
<p>增加支付其实和这个业务逻辑不是一个紧耦合的，我们应该增加他的复用性，如果我们要在其他地方支付呢。应该把实例化这部分也抽出来。就形成了<code>简单工厂类</code>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//简单工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">static</span> <span class="title">createPay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (小程序) &#123;</span><br><span class="line">            <span class="comment">//小程序支付</span></span><br><span class="line">            <span class="variable">$pay</span> = <span class="keyword">new</span> miniWechatPay;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (公众号) &#123;</span><br><span class="line">            <span class="comment">//公众号支付</span></span><br><span class="line">            <span class="variable">$pay</span> = <span class="keyword">new</span> jsAPIPay;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pc) &#123;</span><br><span class="line">            <span class="comment">//扫码支付</span></span><br><span class="line">            <span class="variable">$pay</span> = <span class="keyword">new</span> nativePay;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$pay</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//微信支付方法 省略了类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wechatPay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...省略</span></span><br><span class="line">    <span class="variable">$pay</span> = factory::<span class="title function_ invoke__">createPay</span>();</span><br><span class="line">    <span class="variable">$pay</span>-&gt;<span class="title function_ invoke__">pay</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样拆分有什么好处呢？</p>
<p>虽然增加支付的时候依旧需要修改代码，但是只需要修改简单工厂类，而不用修改业务逻辑类，避免了因为修改业务逻辑类而产生的业务逻辑bug。使得实例化对象和具体业务无关。</p>
<p>增加了代码的复用性，维护性，灵活性，测试性等。</p>
<p>代码放在了我的github上面。</p>
<ul>
<li><a href="https://github.com/Thepatterraining/design-pattern">设计模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之单例模式--php实现单例模式</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-php%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="设计模式之单例模式–php实现单例模式"><a href="#设计模式之单例模式–php实现单例模式" class="headerlink" title="设计模式之单例模式–php实现单例模式"></a>设计模式之单例模式–php实现单例模式</h1><p><code>单例模式</code>是最常被提起的一个设计模式，他的意思是</p>
<blockquote>
<p>一个类只有一个实例，所有人共用这同一个实例。不让外部创建类的实例，并且提供一个外部的全局访问点。</p>
</blockquote>
<h2 id="为什么要使用单例模式"><a href="#为什么要使用单例模式" class="headerlink" title="为什么要使用单例模式"></a>为什么要使用单例模式</h2><p>单例模式有什么好处呢？</p>
<p>单例模式是为了全局唯一，如果你需要一个全局唯一的类那么就需要单例模式了。而且单例模式还可以节省资源，因为这个类只有一个对象。</p>
<p>比如你需要一个全局唯一的id生成器，如果创建了多个实例，那么生成的id可能就不是全局唯一了。</p>
<p>比如你需要一个全局配置信息，需要全局缓存信息，全局日志文件写入等等。</p>
<h2 id="普通类"><a href="#普通类" class="headerlink" title="普通类"></a>普通类</h2><p>下面是一个普通的类的实现和使用。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Common</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span>;  <span class="comment">//年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;age = <span class="variable">$age</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;姓名：&#x27;</span>.<span class="variable language_">$this</span>-&gt;name);</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;年龄：&#x27;</span>.<span class="variable language_">$this</span>-&gt;age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj1</span> = <span class="keyword">new</span> <span class="title class_">Common</span>(<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;18&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$obj1</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj2</span> = <span class="keyword">new</span> <span class="title class_">Common</span>(<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;20&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$obj1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到普通类可以<code>new</code>多个对象，并且每个对象都不一样，拥有自己的属性。</p>
<h2 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h2><p>首先，单例类是一种特殊的类，单例类只允许<code>new</code>一次。怎么实现只能<code>new</code>一次呢，从上面的代码中可以看到，<code>new</code>这个操作是在我们的业务中进行的，这是个无法掌控的操作。</p>
<p>我们要让<code>new</code>操作在类中实现，由这个单例类来决定，来操作对象的实例化。而不是在业务中进行。</p>
<p>只有自己才能决定自己<code>new</code>不<code>new</code>，自己决定自己的人生，而不是交给别人，使得无法掌控。</p>
<p>从这个分析中可以知道，单例类要完成下面的操作：</p>
<ul>
<li>自己创建实例化，供外部全局访问</li>
<li>不允许外部实例化</li>
</ul>
<p>第一点简单，实现一个方法<code>new</code>自己，然后存起来返回就可以了。</p>
<p>第二点在php中怎么实现呢，不允许外部实例化可以通过将<code>__construct</code>方法设置为<code>private</code>权限。因为这个方法外部访问不到，所以外部就无法实例化了。</p>
<p>简单实现一下单例类。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span>;  <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">static</span> <span class="variable">$instance</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;age = <span class="variable">$age</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="built_in">self</span>::<span class="variable">$instance</span>)) &#123;</span><br><span class="line">            <span class="built_in">self</span>::<span class="variable">$instance</span> = <span class="keyword">new</span> <span class="built_in">self</span>(<span class="variable">$name</span>, <span class="variable">$age</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">self</span>::<span class="variable">$instance</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;姓名：&#x27;</span>.<span class="variable language_">$this</span>-&gt;name);</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;年龄：&#x27;</span>.<span class="variable language_">$this</span>-&gt;age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj1</span> = <span class="title class_">Singleton</span>::<span class="title function_ invoke__">getInstance</span>(<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;18&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$obj1</span>);</span><br><span class="line"><span class="variable">$obj2</span> = <span class="title class_">Singleton</span>::<span class="title function_ invoke__">getInstance</span>(<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;20&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$obj2</span>);</span><br></pre></td></tr></table></figure>

<p>这是把上面的普通类改成了单例类，现在这个单例类还有些问题。</p>
<ul>
<li>参数上面第二个参数没有生效</li>
</ul>
<p>单例类一般不会出现这种需要各种参数的，需要参数也建议通过配置文件来搞定参数，而不是传参。<strong>如果有传参需求，需要的是不同的参数是不同的对象，同一个参数是单例对象，那么需要维护一个单例对象的数组</strong>。为什么不提供修改参数的方法呢，因为提供这个方法太危险，全局使用同一个对象，如果某个地方不慎更改了属性，那么会导致其他地方出现未知bug。</p>
<ul>
<li>并没有完全禁止外部实例化，php还有魔术方法__clone。</li>
</ul>
<p>把__clone方法设置成<code>private</code></p>
<p>根据上面的我们在修改一下这个单例类。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$name</span>; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$age</span>;  <span class="comment">//年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来存放全局唯一对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">static</span> <span class="variable">$instance</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造函数使得外部无法new对象</span></span><br><span class="line"><span class="comment">     * 构造函数去掉参数，参数从配置文件读取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;name = <span class="title function_ invoke__">config</span>(<span class="string">&#x27;design.singleton.name&#x27;</span>);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;age = <span class="title function_ invoke__">config</span>(<span class="string">&#x27;design.singleton.age&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化克隆函数使得外部无法克隆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__clone</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取全局唯一对象的时候不需要传参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="built_in">self</span>::<span class="variable">$instance</span>)) &#123;</span><br><span class="line">            <span class="built_in">self</span>::<span class="variable">$instance</span> = <span class="keyword">new</span> <span class="built_in">self</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">self</span>::<span class="variable">$instance</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;姓名：&#x27;</span>.<span class="variable language_">$this</span>-&gt;name);</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;年龄：&#x27;</span>.<span class="variable language_">$this</span>-&gt;age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj1</span> = <span class="title class_">Singleton</span>::<span class="title function_ invoke__">getInstance</span>();</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$obj1</span>);</span><br><span class="line"><span class="variable">$obj2</span> = <span class="title class_">Singleton</span>::<span class="title function_ invoke__">getInstance</span>();</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$obj2</span>);</span><br></pre></td></tr></table></figure>

<p>到现在，我们就完成了一个基于php的单例类，这个单例类支持延迟加载。如果不需要延迟加载，那么实现更简单。看下面的<code>饿汉式单例类</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$name</span>; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$age</span>;  <span class="comment">//年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来存放全局唯一对象 饿汉式单例直接在这里new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">static</span> <span class="variable">$instance</span> = <span class="keyword">new</span> <span class="built_in">self</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造函数使得外部无法new对象</span></span><br><span class="line"><span class="comment">     * 构造函数去掉参数，参数从配置文件读取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;name = <span class="title function_ invoke__">config</span>(<span class="string">&#x27;design.singleton.name&#x27;</span>);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;age = <span class="title function_ invoke__">config</span>(<span class="string">&#x27;design.singleton.age&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化克隆函数使得外部无法克隆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__clone</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取全局唯一对象的时候不需要传参</span></span><br><span class="line"><span class="comment">     * 这里只需要直接返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">self</span>::<span class="variable">$instance</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;姓名：&#x27;</span>.<span class="variable language_">$this</span>-&gt;name);</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;年龄：&#x27;</span>.<span class="variable language_">$this</span>-&gt;age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们支持延迟加载的其实还有些问题，那就是缺少锁，如果很多请求同时进来，那么后面的会覆盖前面的单例对象。如果再加上锁的话实现是下面这样。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$name</span>; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$age</span>;  <span class="comment">//年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来存放全局唯一对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">static</span> <span class="variable">$instance</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造函数使得外部无法new对象</span></span><br><span class="line"><span class="comment">     * 构造函数去掉参数，参数从配置文件读取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;name = <span class="title function_ invoke__">config</span>(<span class="string">&#x27;design.singleton.name&#x27;</span>);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;age = <span class="title function_ invoke__">config</span>(<span class="string">&#x27;design.singleton.age&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化克隆函数使得外部无法克隆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__clone</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取全局唯一对象的时候不需要传参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//先加锁</span></span><br><span class="line">        <span class="variable">$lock</span> = <span class="keyword">new</span> lock;</span><br><span class="line">        <span class="variable">$lock</span>-&gt;<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="built_in">self</span>::<span class="variable">$instance</span>)) &#123;</span><br><span class="line">            <span class="built_in">self</span>::<span class="variable">$instance</span> = <span class="keyword">new</span> <span class="built_in">self</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        <span class="variable">$lock</span>-&gt;<span class="title function_ invoke__">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">self</span>::<span class="variable">$instance</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;姓名：&#x27;</span>.<span class="variable language_">$this</span>-&gt;name);</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;年龄：&#x27;</span>.<span class="variable language_">$this</span>-&gt;age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话因为锁的原因会造成性能比较低，所以又有了下面的方式，叫做<code>双重检测</code>。也就是拿锁之前先判断一下有没有实例化，如果有了就不需要锁了。为什么不直接在第一个判断里面加呢，因为锁加晚了没有意义了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$name</span>; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$age</span>;  <span class="comment">//年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来存放全局唯一对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">static</span> <span class="variable">$instance</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造函数使得外部无法new对象</span></span><br><span class="line"><span class="comment">     * 构造函数去掉参数，参数从配置文件读取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;name = <span class="title function_ invoke__">config</span>(<span class="string">&#x27;design.singleton.name&#x27;</span>);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;age = <span class="title function_ invoke__">config</span>(<span class="string">&#x27;design.singleton.age&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化克隆函数使得外部无法克隆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__clone</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取全局唯一对象的时候不需要传参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//先判断</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="built_in">self</span>::<span class="variable">$instance</span>)) &#123;</span><br><span class="line">            <span class="comment">//先加锁</span></span><br><span class="line">            <span class="variable">$lock</span> = <span class="keyword">new</span> lock;</span><br><span class="line">            <span class="variable">$lock</span>-&gt;<span class="title function_ invoke__">lock</span>();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="built_in">self</span>::<span class="variable">$instance</span>)) &#123;</span><br><span class="line">                <span class="built_in">self</span>::<span class="variable">$instance</span> = <span class="keyword">new</span> <span class="built_in">self</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            <span class="variable">$lock</span>-&gt;<span class="title function_ invoke__">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">self</span>::<span class="variable">$instance</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;姓名：&#x27;</span>.<span class="variable language_">$this</span>-&gt;name);</span><br><span class="line">        <span class="title function_ invoke__">dump</span>(<span class="string">&#x27;年龄：&#x27;</span>.<span class="variable language_">$this</span>-&gt;age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是整个单例模式。四种实现：</p>
<ul>
<li>饿汉式 在类加载的时候实例化</li>
<li>懒汉式 支持延迟加载</li>
<li>带锁懒汉式 延迟加载的时候加锁</li>
<li>双重检测 两次判断</li>
</ul>
<p>代码放在了我的github上面。</p>
<ul>
<li><a href="https://github.com/Thepatterraining/design-pattern">设计模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则之KISS原则和YAGNI原则</title>
    <url>/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8BKISS%E5%8E%9F%E5%88%99%E5%92%8CYAGNI%E5%8E%9F%E5%88%99.html</url>
    <content><![CDATA[<h1 id="设计原则之KISS原则和YAGNI原则"><a href="#设计原则之KISS原则和YAGNI原则" class="headerlink" title="设计原则之KISS原则和YAGNI原则"></a>设计原则之KISS原则和YAGNI原则</h1><h2 id="KISS原则"><a href="#KISS原则" class="headerlink" title="KISS原则"></a>KISS原则</h2><p><code>KISS(Keep It simple and Stupid)原则</code>总的来说就是简单，你的代码要写的简单易懂。增加代码的可读性。</p>
<p>并不一定是代码量的多少来判断简单，而是通过可读性，如果这个代码可读性很好，比如你一下子就能看懂，这就说明符合KISS原则。</p>
<p>这个原则也比较主观，因为如果看代码的人水平比较差可能看不懂，而比你水平好的则可能一下子看懂。就像我们读框架源码读不懂并不是框架源码写的不好而是我们水平不够，哈哈哈哈。</p>
<p>怎么让代码简洁易懂呢？</p>
<ul>
<li>命名清晰易懂</li>
<li>可以写一些注释辅助看懂</li>
<li>遵守代码规范</li>
<li>统一团队风格</li>
</ul>
<p>我们要写出可读性好的代码而不是一些复杂的代码。我们的目的是写出实现需求的代码。</p>
<h2 id="YAGNI原则"><a href="#YAGNI原则" class="headerlink" title="YAGNI原则"></a>YAGNI原则</h2><p><code>YAGNI（You Ain&#39;t Gonna Need It）原则</code>的意思是你不需要他的时候就不要提前写好，不要做过度设计。我们可以基于扩展性留好’坑’，方便以后扩展新的代码。比如我们现在使用了微信支付，以后可能会接入支付宝支付，我们可以基于接口编程方便扩展，但不用直接写好支付宝支付的代码。</p>
<p>同样的，我们不要在代码中依赖不需要的东西，比如包管理，我们只需要当前需要的扩展包，不要把现在不需要的都加入进来。</p>
<p>比如<code>vue</code>的组件化设计，引入一些组件的时候，比如<code>element ui</code>组件，可以选择全部引入也可以选择按需加载。</p>
<p>还有各种懒加载，比如图片懒加载，树形结构的懒加载，我们只加载当前需要的东西。</p>
<p>参考资料：</p>
<ul>
<li>极客时间设计模式之美</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则之迪米特法则--我只依赖我需要的类</title>
    <url>/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8B%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99-%E6%88%91%E5%8F%AA%E4%BE%9D%E8%B5%96%E6%88%91%E9%9C%80%E8%A6%81%E7%9A%84%E7%B1%BB.html</url>
    <content><![CDATA[<h1 id="设计原则之迪米特法则–我只依赖我需要的类"><a href="#设计原则之迪米特法则–我只依赖我需要的类" class="headerlink" title="设计原则之迪米特法则–我只依赖我需要的类"></a>设计原则之迪米特法则–我只依赖我需要的类</h1><p><code>迪米特法则（Law of Demeter） LOD</code>。这个原则是说我只依赖我确实需要的类，也叫最小知识原则。</p>
<p>这个原则的英文<strong>Each unit should have only limited knowledge about other units:only units ‘closely’ related to the current unit. Or:Each unit should only talk to its friends; Don’t talk to strangers.</strong></p>
<p>每个模块之应该了解哪些与他关系密切的模块的有限知识。或者说，每个模块只和自己的朋友说话，而不和陌生人说话。</p>
<p>如果说用好了<code>单一职责</code>可以写出高内聚的代码，那么用好了<code>迪米特</code>就可以实现低耦合。</p>
<p>在类的结构上，<strong>每一个类都应当尽量降低成员的访问权限</strong>。这样可以避免别人调用不应该调用的方法。我们只对外暴露应该暴露的方法。</p>
<p>这么做有什么好处呢？如果你的依赖越少，或者依赖你的类越少，那么当你修改的时候，你影响到的也越少，出bug的概率也越少。</p>
<p>我们应该设计好类之间的依赖关系。谁也不想管理一团乱麻的代码。如果你现在的项目依赖关系混乱，那么你可能根本不敢修改任何一个地方，生怕整个系统崩溃。依赖关系过多也会导致不好测试。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则之依赖倒置原则--我的依赖被反转了</title>
    <url>/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8B%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99-%E6%88%91%E7%9A%84%E4%BE%9D%E8%B5%96%E8%A2%AB%E5%8F%8D%E8%BD%AC%E4%BA%86.html</url>
    <content><![CDATA[<h1 id="设计原则之依赖倒置原则–我的依赖被反转了"><a href="#设计原则之依赖倒置原则–我的依赖被反转了" class="headerlink" title="设计原则之依赖倒置原则–我的依赖被反转了"></a>设计原则之依赖倒置原则–我的依赖被反转了</h1><p><code>依赖倒置原则（Dependency Inversion Principle）DIP</code>。这个原则的英文是<code>high-level modules shouldn&#39;t depend on low-level modules. both modules should depend on abstractions. In addition, abstractions shouldn&#39;t depend on details.Details depend on abstractions.</code>。意思是高层模块不要依赖底层模块。高层模块和底层模块都应该依赖抽象。抽象不要依赖具体实现，具体实现应该依赖抽象。</p>
<h2 id="什么是依赖倒置原则"><a href="#什么是依赖倒置原则" class="headerlink" title="什么是依赖倒置原则"></a>什么是依赖倒置原则</h2><p>通常来说，调用者属于高层模块，被调用者就是低层模块。为什么叫依赖倒置或者依赖反转呢？正常开发来说类A调用类B，类A属于高层模块，类B是低层模块。高层模块依赖低层模块，需要调用低层模块的方法。直接和低层模块高度耦合。</p>
<p>如果这时候我们的低层模块需要适配不同的高层模块，那么就无法复用。因为低层模块和以前的高层模块耦合在一起，如果修改适配新模块可能会导致以前的高层模块出现问题。</p>
<p>依赖倒置原则就是把这个依赖关系进行反转。以前是高层模块依赖低层模块，现在我不依赖你了。咋俩都依赖抽象。我们使用抽象类或者接口。我们的实现都基于这个接口来进行，而不是产生直接的依赖关系。我们都依赖同样的接口，同样的抽象。</p>
<p>比如我们的电脑有CPU,键盘，鼠标，内存，硬盘，显示器这些东西，我们只要组装起来就是电脑，这些东西就像高内聚的程序。内聚在一起，他们依赖相同的接口进行调用，你的<code>罗技鼠标</code>和<code>雷蛇鼠标</code>都使用同一个接口。那么电脑就可以正常运转。</p>
<h2 id="如何使用依赖倒置原则"><a href="#如何使用依赖倒置原则" class="headerlink" title="如何使用依赖倒置原则"></a>如何使用依赖倒置原则</h2><p>我们进行软件设计的时候应该由上而下的设计，先进行抽象设计，然后来具体实现。如果先写出具体实现在进行抽象设计，那么抽象出来的东西就容易依赖具体实现。因为具体实现很可能会变，但是抽象一般不会改变。所以抽象使得程序更加稳定。</p>
<p>那么为什么抽象一般不会改变呢？这就是之前说的<a href="https://blog.csdn.net/Thepatterraining/article/details/105880396">里氏替换原则</a>。子类可以替换父类，需要改变我们只需要扩展具体实现就可以而不是修改抽象。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//电脑需要一个能插入usb接口的鼠标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">computer</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">USB <span class="variable">$mouse</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;mouse = <span class="variable">$mouse</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">usb</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//雷蛇鼠标实现了usb接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">snakeMouse</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">usb</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//罗技鼠标实现了usb接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">luoMouse</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">usb</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，不管是哪个鼠标都可以使用，如果我们依赖具体的鼠标，那么就无法灵活更换了。两边，调用者和被调用者，高层模块和低层模块都依赖抽象。</p>
<p>参考资料：</p>
<ul>
<li>大话设计模式</li>
<li>极客时间设计模式之美</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则之接口隔离原则--如何通过接口隔离职责</title>
    <url>/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8B%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E8%81%8C%E8%B4%A3.html</url>
    <content><![CDATA[<h1 id="设计原则之接口隔离原则–如何通过接口隔离职责"><a href="#设计原则之接口隔离原则–如何通过接口隔离职责" class="headerlink" title="设计原则之接口隔离原则–如何通过接口隔离职责"></a>设计原则之接口隔离原则–如何通过接口隔离职责</h1><p><code>接口隔离原则（Interface Segregation Principle） ISP</code>。这个原则是说客户端不应该依赖他不需要的接口。</p>
<p>这个原则的英文是<code>Clients should not be forced to depend upon interfaces that they do not use</code>。</p>
<h2 id="如何使用接口隔离原则"><a href="#如何使用接口隔离原则" class="headerlink" title="如何使用接口隔离原则"></a>如何使用接口隔离原则</h2><p>这里面的接口不同于我们的API接口，也不是电脑的USB接口这种，而是我们程序中使用的<code>接口Interface</code>。</p>
<p>我们通过让程序实现不同的接口来完成不同的职责。这个原则和单一职责原则也有点类似。比如一个类既有查询功能还有修改功能。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么现在有一个类需要使用这个类的查询功能。它只需要使用查询，但是他还是可以知道这个类有修改功能，可以使用他的修改功能。另外有一个类只需要修改却同样被迫加载了查询功能。</p>
<p>如果我们增加两个接口。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">list</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">interface</span> <span class="title">update</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">class</span> <span class="title">demo</span> <span class="title">implements</span> <span class="title">list</span>, <span class="title">update</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"><span class="keyword">list</span> <span class="variable">$demo</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$demo</span>-&gt;<span class="keyword">list</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testUpdate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">update <span class="variable">$demo</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$demo</span>-&gt;<span class="title function_ invoke__">update</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，我们通过接口将查询和更新分离开，查询方只依赖查询接口，只能感知到查询操作，更新方只依赖更新接口，只能感知到更新操作，不需要知道这个类其他的功能，也防止了误操作。</p>
<p>参考资料：</p>
<ul>
<li>大话设计模式</li>
<li>极客时间设计模式之美</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则之里氏替换原则--子类可以替换父类吗</title>
    <url>/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8B%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99-%E5%AD%90%E7%B1%BB%E5%8F%AF%E4%BB%A5%E6%9B%BF%E6%8D%A2%E7%88%B6%E7%B1%BB%E5%90%97.html</url>
    <content><![CDATA[<h1 id="设计原则之里氏替换原则–子类可以替换父类吗"><a href="#设计原则之里氏替换原则–子类可以替换父类吗" class="headerlink" title="设计原则之里氏替换原则–子类可以替换父类吗"></a>设计原则之里氏替换原则–子类可以替换父类吗</h1><p><code>里氏替换原则（Liskov Substitution Principle）LSP</code>，这个原则是说子类应该可以替换父类进行使用。</p>
<p>这个原则的英文描述是<code>functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it</code>。子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。</p>
<h2 id="为什么要使用里氏替换原则"><a href="#为什么要使用里氏替换原则" class="headerlink" title="为什么要使用里氏替换原则"></a>为什么要使用里氏替换原则</h2><p>在我们的日常开发中很常用<code>依赖注入</code>，简单来说就是通过外部传入对象而不是内部<code>new</code>对象。传入参数的时候我们可以通过标识父类或者接口。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">Idemo <span class="variable">$demo</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$demo</span>-&gt;<span class="title function_ invoke__">run</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数中，我不关心你传进来的是个什么玩意，只要你实现了Idemo这个接口的对象就可以。或者是继承了Idemo这个类的自类对象也可以，只要你实现了run这个方法，并且属于Idemo这个类或者接口。我们经常使用这个方法来增加程序的测试行，扩展性，灵活性。比如我们需要一个支付接口的时候。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buy</span>(<span class="params">Payment <span class="variable">$payment</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$payment</span>-&gt;<span class="title function_ invoke__">pay</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们购买东西的时候，只要知道我要支付就可以了，至于你传进来的是支付宝支付还是微信支付我不需要知道。</p>
<p>在这里面，支付宝或者微信支付就是具体的自类，而<code>Payment</code>就是他们的父类。这些子类对象可以替换他们的父类对象，并且保证原来程序的逻辑行为不变及正确性不被破坏。</p>
<h2 id="里氏替换和多态"><a href="#里氏替换和多态" class="headerlink" title="里氏替换和多态"></a>里氏替换和多态</h2><p>其实我们上面使用的就是面向对象里面的<code>多态</code>。但是多态并不是里氏替换。类的多态特性允许我们重新实现父类的函数，我们可以根据不同的需求来改写。但是里氏替换原则要求不能修改原来的逻辑行为和正确性。</p>
<p>比如父类中这个函数返回了异常而子类没有，那么这就违反了里氏替换原则。</p>
<p>比如原来内容是123，而子类改成了456，那么同样违反了里氏替换原则。</p>
<p>参考资料：</p>
<ul>
<li>大话设计模式</li>
<li>极客时间设计模式之美</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则之开闭原则--对扩展开发对修改关闭</title>
    <url>/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8B%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99-%E5%AF%B9%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E5%AF%B9%E4%BF%AE%E6%94%B9%E5%85%B3%E9%97%AD.html</url>
    <content><![CDATA[<h1 id="设计原则之开闭原则–对扩展开发对修改关闭"><a href="#设计原则之开闭原则–对扩展开发对修改关闭" class="headerlink" title="设计原则之开闭原则–对扩展开发对修改关闭"></a>设计原则之开闭原则–对扩展开发对修改关闭</h1><p><code>开闭原则(Open Closed Principle) OCP</code>，这个原则是说对扩展可以开放，但是对修改要关闭。</p>
<p>这个原则的英文描述是<code>software entities(modules,classes,functions,etc.) should be open for extension, but closed for modification.</code>。</p>
<h2 id="为什么要使用开闭原则"><a href="#为什么要使用开闭原则" class="headerlink" title="为什么要使用开闭原则"></a>为什么要使用开闭原则</h2><p>引用<code>大话设计模式</code>书中的故事。在香港澳门回归的时候，我国使用了<code>一国两制</code>的方针。<strong>这其实就是没有修改任何地方，但却扩展了我国的领土。</strong>这也就是对修改关闭，对扩展开放。</p>
<p><code>开放封闭原则</code>，是说软件实体应该可以扩展，但是不可修改。</p>
<p>在现在的开发中，改需求是一个很常见的事情，我们经常需要<strong>这个需求要改成这样，明天上线！！</strong>这种事情。这时候我们加班加点改完一个类实现了新需求。这个时候发现由于这个类的依赖太多，我们的修改引起了其他地方的bug，那我们需要整体测试，然后各种修改，还可能引起更多的bug，如此耗时耗力。</p>
<p>在思考另外一个场景，同样我们实现了需求，这个时候没出其他问题，但是！！！<strong>这个需求要改回去，你把之前的代码拿出来吧</strong>。我相信你一定很不爽的，如果我们可以通过git来回滚到之前的代码还好，如果我们之前的代码在本地没有提交这个时候我们又修改完了，那，呵呵，再改回去吧，鬼知道之前代码啥样。</p>
<p>如果我们遵循<code>开闭原则</code>，不是通过修改类来完成，而是通过扩展类的方式来完成这个新需求，那么我们就避免了这些问题，扩展不会引起其他的未知bug。不会影响到其他的类。如果要改回去我们原来的代码也还在。这就是开闭原则的好处了。</p>
<h2 id="如何使用开闭原则"><a href="#如何使用开闭原则" class="headerlink" title="如何使用开闭原则"></a>如何使用开闭原则</h2><p>无论模块是多么的封闭，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对那种变化封闭做出选择。<strong>它必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离哪些变化</strong>。</p>
<p>我们开发中，最开始的时候，很难预测接下来的变化。但是，一旦发生变化我们可以根据变化来采取行动，进行抽象重构。使得接下来通过扩展和少量的必要修改来应对需求的变化。</p>
<p>开闭原则是面向对象设计的核心所在。<strong>遵循这个原则可以带来面向对象技术所生成的巨大好处，也就是可维护，可扩展，可复用，灵活性好。</strong>我们应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于程序中的每个部分都刻意的进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。</p>
<p>我们可以在开发的开始阶段对接下来能预测到的变化留出扩展空间，然后再不断的持续重构开发代码中一直遵循开闭原则。</p>
<p>很多设计模式都是以提高扩展性为目的。最常用的方法有：多态，依赖注入，基于接口编程等。</p>
<p>参考资料：</p>
<ul>
<li>大话设计模式</li>
<li>极客时间设计模式之美</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则之单一职责--为什么要设计成单一职责</title>
    <url>/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8B%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%88%90%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3.html</url>
    <content><![CDATA[<h1 id="设计原则之单一职责–为什么要设计成单一职责"><a href="#设计原则之单一职责–为什么要设计成单一职责" class="headerlink" title="设计原则之单一职责–为什么要设计成单一职责"></a>设计原则之单一职责–为什么要设计成单一职责</h1><p><code>单一职责原则(Single Responsibility Principle) SRP</code>的意思是，就一个类而言，应该仅有一个引起他变化的原因。</p>
<p>这个原则的英文描述是<code>A class or module should have a single reponsibility</code>。一个类或者模块只有一个职责。</p>
<h2 id="为什么要使用单一职责"><a href="#为什么要使用单一职责" class="headerlink" title="为什么要使用单一职责"></a>为什么要使用单一职责</h2><p>借用<code>大话设计模式</code>一书中使用的例子。比如现在科技高度发达，<code>手机</code>成为了日常使用中不可替代的产品。手机的功能很多，可以拍照，可以上网，可以打电话，聊天，打游戏等。假设我们没有手机，那么我们拍照需要摄像机，打游戏需要游戏机，听歌需要mp3，但是现在不用带这么多东西，只需要一个手机就搞定了。觉得很方便。但是呢，手机的拍照功能并没有单反好，游戏性能和游戏数量也比不上ps4和xbox以及ns。</p>
<p>如果放在代码中就是你的所有代码都写在一起，像一团乱麻一样。严重影响了可读性，扩展性，维护性等。相信没有人喜欢看到这样的代码。所以这就是<code>单一职责</code>。对代码要有结构，要清晰明了，其实代码中到处都体现了这个原则。比如<code>mvc</code>的分层架构，比如前后端分离，比如<code>docker</code>的兴起，比如我们日常使用的框架也分离了我们的职责，使得我们只需要关注一些实现就好了。再生活中也有比如公司分成了各个部门，人类分成了男人女人，由各个职业。每个人只需要关注自己的事情，简单明了。这就是单一职责的好处。</p>
<p>如果一个类承担的<code>职责</code>过多，就等于把这些职责耦合在一起，一个变化会引起其他意想不到的变化，使得整个程序脆弱不堪。我们经常说要写<code>高内聚，低耦合</code>的代码，如果违反了单一职责那么就只能写出高耦合的代码了。</p>
<h2 id="如何使用单一职责"><a href="#如何使用单一职责" class="headerlink" title="如何使用单一职责"></a>如何使用单一职责</h2><p><strong>如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责</strong>。如果类的职责多了，我们就需要把他们分离开来，当然了，这个原则比较具有主观性。有的人觉得这个类不是单一职责，有的人觉得是单一职责。</p>
<p>判断是否单一职责要结合具体的业务场景和使用，如果你有多个引起这个类变化的地方，那么就需要重新考虑一下这个类是否符合单一职责了。</p>
<p>在我们平常开发中，没必要一开始纠结是否符合单一职责，随着开发的演进，程序越来越庞大，我们需要随着业务的发展将类分的越来越细才好，要持续重构。一定不要等到已经往一个类里面塞了很多代码才考虑划分成单一职责。那样的话拆分起来很费劲而且耗时耗力。<strong>在添加新功能的时候要想一想这个功能应该添加到哪里，是否符合单一职责</strong>。</p>
<p>开发中可以根据下面几点来判断是否满足单一职责：</p>
<ul>
<li>类中的代码过多，影响了代码的可读性和维护性。</li>
<li>和这个类有依赖关系的类比较多，耦合过高。</li>
<li>比较难给类命名，不清楚这个类是干啥的了。</li>
<li>类中大量的方法都是集中操作类的某几个属性。</li>
</ul>
<h2 id="类的职责是否越单一越好"><a href="#类的职责是否越单一越好" class="headerlink" title="类的职责是否越单一越好"></a>类的职责是否越单一越好</h2><p>显然不是的，如果一个类过于职责单一，比如加密类，有一个加密方法和解密方法。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hash</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">encode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">decode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们执着于单一职责，要把这个类拆分成两个类。一个加密类一个解密类。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashDecode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">decode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashEncode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">encode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果这时候根据新的需求，我们的加密算法需要改变，那么解密算法也需要改变，我们要同时改变两个类，如果忘记其中一个，那么整个程序就会崩溃。我们的最终目标是写出<code>高内聚低耦合</code>的代码。而不是生搬硬套某一个设计原则或者设计模式。<strong>设计原则是总结出来指导我们进行程序设计的方针。合理使用可以使得我们的程序更加健壮</strong>。</p>
<p>参考资料：</p>
<ul>
<li>大话设计模式</li>
<li>极客时间设计模式之美</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD领域驱动设计和充血模型</title>
    <url>/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B.html</url>
    <content><![CDATA[<h1 id="贫血模型"><a href="#贫血模型" class="headerlink" title="贫血模型"></a>贫血模型</h1><p>什么是<code>贫血模型</code>？</p>
<p><code>贫血模型</code>就是缺血了，缺东西，也就是只有数据但是没有业务逻辑或者有业务逻辑但是没有数据。</p>
<p>比如你有一个计算类，他有一个加法计算的方法。但是他不持有计算的数据。</p>
<p>和贫血模型对应的就是充血模型。</p>
<p>什么是<code>充血模型</code>？</p>
<p><code>充血模型</code>就是不缺血了，有数据同样有业务逻辑。</p>
<p>比如你的计算类现在不只有加法计算，还有需要的数据。</p>
<p>我们现在进行的开发基本上都是基于贫血模型开发的。</p>
<p>比如一个电商系统，有商品模型，但是一个商品模型只有商品的基本信息，数据。如果需要获取一个商品的总价，那么我们需要调用model里面的一个方法来计算。这就是典型的贫血模型。</p>
<p>如果我们在商品模型里面提供一个计算总价的方法。把数据和业务逻辑放在一起，这就是充血模型。</p>
<h1 id="充血模型"><a href="#充血模型" class="headerlink" title="充血模型"></a>充血模型</h1><p>充血模型要将数据和业务高度内聚在一个类中，使得类更加饱满，也是高内聚低耦合的一种实践。不过充血模型需要更好的设计整个类才能实现。因为要考虑到扩展性，测试性，可读性，复用性等。充血模型注定比贫血模型更加耗费时间，更加难以实现。</p>
<p>现在更推崇敏捷开发。快速实现需求，慢慢迭代升级。如果使用充血模型也容易搞得四不像。也因此贫血模型更让人喜欢。贫血模型也更容易设计和实现，日常开发中随便写的都是贫血模型。而充血模型需要进行好好的设计。那怎么设计充血模型呢？可以根据<code>DDD领域驱动设计</code>来实现。</p>
<h1 id="领域驱动设计DDD"><a href="#领域驱动设计DDD" class="headerlink" title="领域驱动设计DDD"></a>领域驱动设计DDD</h1><p>DDD的概念很早就有了，但是一直没有火起来。现在又出现了<code>充血模型</code>的概念。</p>
<p>DDD的核心思想其实就是根据不同的领域，功能来设计建模，划分模块。微服务的划分就可以借鉴DDD的思想，根据不同的业务领域来划分。</p>
<p>DDD可以用来指导我们如果做软件设计，但是想要用好DDD，需要对自身的业务足够理解，足够熟练。</p>
<p><code>领域</code>是一个组织所做的事情以及其包含的一切。领域驱动设计就是从自身的领域出发，分析自身领域内的一切关联关系，根据其设计我们的软件。构造充血模型。也就是充血模型是和业务高度耦合的，完全从自身的领域出发进行设计。可以先将自身的领域细分出多个子领域，然后再每个子领域中设计出各自的领域模型。也就是充血模型。</p>
<p>比如电商领域可以分成用户，商品，订单，物流等子领域。然后设计出各自的实体对象，根据全局领域的上下文来分析需要承担哪些责任也就是哪些数据和业务逻辑。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么很多人不推荐mysql连表join查询</title>
    <url>/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E4%BA%BA%E4%B8%8D%E6%8E%A8%E8%8D%90mysql%E8%BF%9E%E8%A1%A8join%E6%9F%A5%E8%AF%A2.html</url>
    <content><![CDATA[<h1 id="为什么很多人不推荐mysql连表join查询"><a href="#为什么很多人不推荐mysql连表join查询" class="headerlink" title="为什么很多人不推荐mysql连表join查询"></a>为什么很多人不推荐mysql连表join查询</h1><p>join查询是什么？是连表查询，我们需要两个表的数据，就会使用join来进行连表。那么mysql里面是怎么连表的呢？它和我们自己查询出一张表的数据在遍历去查询另外一个表是不是一样呢？</p>
<h2 id="join查询"><a href="#join查询" class="headerlink" title="join查询"></a>join查询</h2><p>join查询还可以写成left join，表示的是根据左边的表来查询右边的表。但实际上，优化器会进行优化，选择合适的表来做驱动表，不一定是左边的表。</p>
<h3 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested-Loop Join"></a>Index Nested-Loop Join</h3><p>NLJ算法，这是一种基于索引的算法，如果你的连表用到了索引，则会使用这个算法。</p>
<p>比如下面的查询语句：</p>
<p>b.uid字段有索引，并且假设a是小表，优化器选择了a表作为驱动表，b表作为被驱动表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">left</span> <span class="keyword">join</span> b <span class="keyword">on</span> a.id <span class="operator">=</span> b.uid;</span><br></pre></td></tr></table></figure>

<p>执行流程大致如下：</p>
<ol>
<li>读取表a的第一行数据</li>
<li>使用表a的id去b表的索引树上查询到对应的b表id</li>
<li>通过查询的b表id回表查询b表数据</li>
<li>把a表和b表数据放在一起</li>
<li>重复上面的步骤直到a表遍历完成</li>
<li>返回数据</li>
</ol>
<p>可以看到这和我们自己查询出一张表然后遍历查询过程是一样的。</p>
<p>但是它的优势是省略了多次连接数据库，连接数据库是比较耗费资源和时间的，这样来看，使用join是更加好的选择。当然前提是你的join被驱动表有索引。</p>
<p>这个过程扫描了整个表a和表a的id对应的每一行表b。假设a表的数据量是n，那么扫描了n + n行，当然不算回表。如果算上回表其实相当于n + n + n行。</p>
<p>我们再看一下这个算法的时间复杂度。</p>
<p>b+树中，定位一个记录的时间复杂度大约是log(m)。m是b表的数据行数。为什么这里使用了b表的数据行数而不是上面说的a表的行数呢，因为这里指的是b表索引树的时间复杂度，当然是跟b表索引树大小挂钩也就是b表数据大小挂钩了。如果在算上回表查询，那么时间复杂度大约是2log(m)。</p>
<p>a表要进行全表扫描，那么a表的时间复杂度就是n，再加上每一行要去b表中查询，那么去b表查询的时间就是n * 2log(m)。加起来就是n + (2nlog(m))。</p>
<p>这里面2是常量可以忽略不记，而且2是因为回表造成的，如果我们使用覆盖索引，那么这个2就可以去掉了。</p>
<p>nlog(m) 比 n小，所以显然n的影响是最大的。也就是说n越小，那么我们连表的速度就越快。所以我们连表的时候要使用更小的那张表作为驱动表，然后给被驱动表的连表字段上面加上索引或者覆盖索引。这样我们的连表其实还是很快的。</p>
<h3 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested-Loop Join"></a>Block Nested-Loop Join</h3><p>如果你的被驱动表字段上面没有索引，那么mysql就会使用另外一种算法。这个算法叫BNL算法。</p>
<p>本来没有索引的情况下，按照上面的流程应该是下面这样：</p>
<ol>
<li>读取表a的第一行数据</li>
<li>使用表a的id去b表上进行全表扫描查询到对应的b表数据</li>
<li>把a表和b表数据放在一起</li>
<li>重复上面的步骤直到a表遍历完成</li>
<li>返回数据</li>
</ol>
<p>这样的话对于每一行表a的数据都要进行b表的全表扫描，也就是如果表a记为n行，表b记为m行，那么需要扫描n * m + n行数据。和上面的n + (2nlog(m))相比，可以看到慢了多少倍。</p>
<p>所以mysql使用了另外一种方法，也就是BNL算法，这个算法做了一下优化，流程变成了下面这样：</p>
<ol>
<li>读取表a的所有数据放入join buffer</li>
<li>对表b进行全表扫描，然后把每一条数据和join buffer中的数据做对比。</li>
<li>把满足条件的数据返回。</li>
</ol>
<p>这样的话，也就是扫描了一遍表a和表b，那么需要扫描n + m行数据。可以看到比上面的n + (n<em>m)来说少了n倍的扫描量。当然了，这个算法，还需要在join buffer中进行n</em>m次对比数据，但是这样内存判断也要比上面的方法好很多。</p>
<p>同样的这个算法对于两张表都是全表扫描，也就无所谓上面说的需要小表做驱动表了，反正都一样，都要全表扫描。</p>
<p>join buffer存在内存中，那么他就有大小的限制，参数<code>join_buffer_size</code>就是限制join buffer大小的。默认值是256k。如果表a的数据大于join buffer的大小，那么就会分段，也就是分多次进行。</p>
<p>但是分多次执行就会有一个问题了。比如分成了c次，那么表b就要经历c次的全表扫描。所以内存允许，当然Join buffer大一点速度会快一些。</p>
<p>这样的话就不是上面的n + m了，而是变成了n + (c*m)，c是根据join buffer大小和n的大小来决定的。如果n越小或者join buffer size越大，那么c就越小。也就是说，如果我们使用小表作为驱动表，那么在遇到数据量超过join buffer的时候，速度也会比较快。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，Join的时候注意下面几点：</p>
<ul>
<li>总是用小表作为驱动表比较好。</li>
<li>能加索引就在被驱动表join字段上面加索引，使用NLJ算法而不是BNL算法。</li>
<li>在没有索引，并且驱动表数据量过大时，可以通过调大join_buffer_size的值来加速连表查询。</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysqlorderby详解-sortbuffer是什么东西</title>
    <url>/mysqlorderby%E8%AF%A6%E8%A7%A3-sortbuffer%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF.html</url>
    <content><![CDATA[<h1 id="mysql是怎么操作order-by来进行排序的"><a href="#mysql是怎么操作order-by来进行排序的" class="headerlink" title="mysql是怎么操作order by来进行排序的"></a>mysql是怎么操作order by来进行排序的</h1><p>mysql的排序用到了sort buffer，sort buffer是一个内存块。</p>
<p>mysql会先取出需要排序的数据，然后把数据放入sort buffer，当所有数据都放入sort buffer或者sort buffer满了就开始排序，然后将排序好的结果返回给客户端。</p>
<p>参数<code>sort_buffer_size</code>显示的就是sort buffer的大小。</p>
<p>如果数据量超过sort buffer，那么就会通过磁盘临时文件辅助进行排序，如果数据量比较小，则可以直接在内存中进行。</p>
<p>在内存中排序会使用<code>快排算法</code>，而通过磁盘临时文件则会使用<code>归并排序算法</code>。</p>
<p>排序步骤可以分为以下几步：</p>
<ol>
<li>取出select的数据存入sort buffer。</li>
<li>在sort buffer中进行快排或者归并排序算法。</li>
<li>如果有limit按照limit取相应的结果集进行返回。</li>
</ol>
<h3 id="rowid排序算法"><a href="#rowid排序算法" class="headerlink" title="rowid排序算法"></a>rowid排序算法</h3><p>这里面select出来的数据量可能会很大，跟你要查询的列多少有关，如果你的列很多，那么mysql可能会使用另外一种排序方法，叫做<code>rowid</code>排序。</p>
<p>rowid算法不管你查询出来的结果集，它只把必要的字段放入sort buffer中，这样sort buffer就可以存入更多的数据来进行排序。</p>
<p>必要的字段也就是你排序需要的字段和主键字段，比如<code>order by time</code>那么他只会放入id 和 time，然后按照time字段排序完成后再通过主键id回表查询一遍数据，然后返回数据。</p>
<p>显然rowid算法还需要再次回表，所以效率上要低一些，所以不是mysql默认使用的排序方法。</p>
<p>只有当你的内存不够用，查询的列太多的时候，mysql才会使用这种算法。</p>
<p>排序步骤可以分为以下几步：</p>
<ol>
<li>取出排序的字段和id存入sort buffer。</li>
<li>在sort buffer中进行快排或者归并排序算法。</li>
<li>按照排序结果和limit数量回表查询然后返回数据。</li>
</ol>
<h3 id="不需要排序的方法"><a href="#不需要排序的方法" class="headerlink" title="不需要排序的方法"></a>不需要排序的方法</h3><p>既然这样，我们为了更快速，可以避免mysql排序。</p>
<p>innoDB的索引是有序的，也就是说，如果我们要排序的字段本身就是有序的，那么就不用排序了。</p>
<p>所以我们可以在排序字段上建立索引，而如果我们查询的字段不多，甚至可以建立覆盖索引，那么速度会快很多。</p>
<p>mysql到底有没有进行排序，可以通过explain的执行计划来看。如果最后有using filesort，就表示使用了排序算法。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>一文带你搞懂为什么大家都推荐count*而不是countid</title>
    <url>/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%90%9E%E6%87%82%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%AE%B6%E9%83%BD%E6%8E%A8%E8%8D%90count-%E8%80%8C%E4%B8%8D%E6%98%AFcountid.html</url>
    <content><![CDATA[<h1 id="一文带你搞懂为什么大家都推荐count-而不是count-id"><a href="#一文带你搞懂为什么大家都推荐count-而不是count-id" class="headerlink" title="一文带你搞懂为什么大家都推荐count(*)而不是count(id)"></a>一文带你搞懂为什么大家都推荐count(*)而不是count(id)</h1><p>在开发中，我们经常用到count这个函数来计算行数，尤其是后台列表展示。</p>
<p>那么究竟应该使用count(<em>)还是count(id)呢？很多人，很多书籍都推荐使用count(</em>)。</p>
<h3 id="count"><a href="#count" class="headerlink" title="count(*)"></a>count(*)</h3><p>在每个引擎里面其实是不一样的，比如myisam引擎，会把总行数存起来，如果你需要总行数，那么直接返回，那速度嗖嗖嗖的。</p>
<p>我们常用的innoDB引擎呢，他就真的是一行行计数了。</p>
<p>那为什么一行行计数还推荐count(*)呢？</p>
<p>innoDB是索引树组织表，不仅有主键索引树还有其他索引树，而count(*)反正是要全表扫描，那么优化器会去遍历最小的索引树，普通索引树的叶子节点只有id，当然要更小一些。</p>
<p>执行这个的时候innoDB遍历全表，但不取值，并且不判断，因为count(*)肯定不是null，直接累加。</p>
<h3 id="count-id"><a href="#count-id" class="headerlink" title="count(id)"></a>count(id)</h3><p>执行这个的时候innoDB遍历全表，把每一行数据的id值取出来返回给mysql，mysql拿到数据以后判断不为空则+1。累加后返回。</p>
<h3 id="count-1"><a href="#count-1" class="headerlink" title="count(1)"></a>count(1)</h3><p>执行这个的时候innoDB遍历全表，但不取值，直接返回给mysql，mysql收到返回值，给返回值赋值1，然后判断，累加。</p>
<h3 id="count-字段"><a href="#count-字段" class="headerlink" title="count(字段)"></a>count(字段)</h3><p>这个和count(id)类似，只不过如果允许为空的话，需要把值取出来做个判断，多个判断。如果不允许为空，那就一样了。</p>
<p>这么一对比，就看出来了，显然count(<em>)更快，这也是因为mysql对count(</em>)这个语句专门做了优化。所以更推荐count(*)</p>
<blockquote>
<p>count(字段) 慢于 count(id) 慢于 count(1) 慢于 count(*)</p>
</blockquote>
<p>除了这些我们同样可以自己实现计数。</p>
<p>我们可以使用缓存系统，将计数放入缓存，然后持久化。比如redis。</p>
<p>我们也可以直接创建一个计数的表，把计数字段放入表里。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐一些学习网站</title>
    <url>/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99.html</url>
    <content><![CDATA[<h1 id="推荐一些学习网站"><a href="#推荐一些学习网站" class="headerlink" title="推荐一些学习网站"></a>推荐一些学习网站</h1><h2 id="coursera"><a href="#coursera" class="headerlink" title="coursera"></a>coursera</h2><p><a href="https://www.coursera.org/">coursera</a>是国际最大的高校慕课网站。上面有很多很火的课程，可以选择免费旁听，只不过免费的没法做作业。但是课件都是一样的，很多都有了中文字幕。也可以选择付费学习或者申请助学金，如果申请助学金成功就不用掏钱了。</p>
<p><img src="/../images/coursera.png" alt="coursera"></p>
<h2 id="edx"><a href="#edx" class="headerlink" title="edx"></a>edx</h2><p><a href="https://www.edx.org/">edX</a>是麻省理工和哈佛大学于2012年4月联手创建的大规模开放在线课堂平台。</p>
<p>这上面也有很多免费的优秀课程。</p>
<p><img src="/../images/edx.png" alt="coursera"></p>
<h2 id="优达学城"><a href="#优达学城" class="headerlink" title="优达学城"></a>优达学城</h2><p><a href="https://cn.udacity.com/courses/all">优达学城 Udacity</a> 是来自硅谷的前沿技术平台，由 Google无人车之父 Sebastian Thrun 创立，与 Google、Facebook、Amazon 等全球顶尖技术公司联合开发了一系列的专业认证项目，为前沿技术领域培育了数万名顶尖专业人才，已与百度、腾讯、滴滴出行等中国前沿技术企业开发了一系列的课程项目</p>
<h2 id="中国大学mooc"><a href="#中国大学mooc" class="headerlink" title="中国大学mooc"></a>中国大学mooc</h2><p><a href="https://www.icourse163.org/">中国大学mooc</a>是国内高校慕课平台，里面都是高校老师授课，还是免费的。让你在家学习高校课程。</p>
<h2 id="学堂在线"><a href="#学堂在线" class="headerlink" title="学堂在线"></a>学堂在线</h2><p><a href="https://next.xuetangx.com/">学堂在线</a>是由清华大学研发出的中文MOOC（大规模开放在线课程，简称慕课）平台，于2013年10月10日正式启动，面向全球提供在线课程。任何拥有上网条件的学生均可通过该平台，在网上学习课程视频。</p>
<h2 id="极客时间"><a href="#极客时间" class="headerlink" title="极客时间"></a>极客时间</h2><p><a href="https://time.geekbang.org/">极客时间</a>极客邦科技出品的 IT 类知识服务产品，内容包含专栏订阅、极客新闻、热点专题、直播、视频和音频等多种形式的知识服务。 [1]  产品形态包括移动 App，移动端网站、PC 端网站、微信平台等。</p>
<p>不过极客时间是收费的，虽然不贵，学生还有半价优惠，平时也有活动。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>javascript</tag>
        <tag>vscode</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql索引详解-你的数据库用对索引了嘛</title>
    <url>/mysql%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3-%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%94%A8%E5%AF%B9%E7%B4%A2%E5%BC%95%E4%BA%86%E5%98%9B.html</url>
    <content><![CDATA[<h1 id="mysql索引详解-你的数据库用对索引了嘛"><a href="#mysql索引详解-你的数据库用对索引了嘛" class="headerlink" title="mysql索引详解-你的数据库用对索引了嘛"></a>mysql索引详解-你的数据库用对索引了嘛</h1><p>mysql的索引一般分为主键索引，唯一索引，普通索引，联合索引，覆盖索引等。</p>
<p>索引这么多，到底该怎么用，用哪个索引适合，需不需要索引呢？</p>
<h2 id="innoDB的索引"><a href="#innoDB的索引" class="headerlink" title="innoDB的索引"></a>innoDB的索引</h2><p>innoDB里面一般采用b+树索引模型，当然还有其它比如哈希索引，全文索引，空间索引。但是常用的还是b+树索引。</p>
<p>B+树是一个N叉平衡树。为什么不用二叉平衡树呢，因为二叉平衡树高度太高了，n叉平衡树可以控制树的高度，大概在3-4的高度，而树的根节点一般存在内存中，这样只需要做2-3次磁盘操作就可以了。大量的减少了磁盘操作。</p>
<h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p><code>主键索引</code>是一种聚簇索引，什么是<code>聚簇索引</code>呢，就是和数据放在一起的。b+树的叶子节点存放的是页，每个页的默认大小是16kb。主键索引树的叶子节点存放的是主键id和数据。一般我们都会用id做为主键。如果一个表不指定主键，Innodb会使用row id作为主键。</p>
<p>我们使用主键查询数据，来看一下执行计划。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> auth_users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/mysql03.png" alt="执行计划"></p>
<p>可以看到里面key列显示的是primary，表示使用了主键索引。row列是1，表示扫描了一行。通过树搜索的方式快速定位了主键id的位置并且取出数据进行了返回。</p>
<p>为什么主键推荐使用<code>递增id</code>呢，这是因为对索引树的增删改查要更加快速。所以一般使用自增主键。也避免了插入引起的<code>页分裂</code>和删除引起的<code>页合并</code>。</p>
<p>如果现在表里有id&#x3D;4,5,6的数据，你插入了一条id&#x3D;3的数据。这时候存放id&#x3D;4,5,6数据的数据页满了，就需要页分裂，变成两个数据页。</p>
<p>页合并就是相邻的两个数据页的数据都挺少的，可以合并到一起，那么就会页合并。</p>
<p>使用自增主键则只需要不断往后写入就可以了，不需要担心中间的插入。而且自增主键占用的空间同样相对较小。</p>
<h4 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h4><p><code>二级索引</code>也是<code>非聚簇索引</code>。包括<code>唯一索引</code>和<code>普通索引</code>。他们同样是b+树的方式存放，只是他们的叶子节点中存放的并不是真正的数据，而是主键id。那么通过这种索引怎么找到数据呢，其实是先找到对应的主键id，再去主键索引树中通过主键id找到对应的数据，也叫<code>回表</code>。</p>
<p>唯一索引和普通索引的区别在于查询的时候，唯一索引查询到条件对应的数据后不会接着查询了，而普通索引会接着查询，直到不满足条件为止。</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p><code>覆盖索引</code>是一种优化的手段。覆盖索引也是一种<code>联合索引</code>。</p>
<p>比如我们查询用户信息的时候，如果需要根据用户名查询用户名和密码。我们在用户名字段创建了一个索引。那么查询的时候就会走索引，但是查到的是id，还需要再去主键中找到数据，取出用户名和密码两个字段。</p>
<p>如果我们在用户名的索引树中不仅存了id，还存了我们需要的密码字段，不就不需要再去回表了吗？那我们就需要创建一个<code>用户名和密码的联合索引</code>。这样我们就不需要再回表了，这也就是覆盖索引。覆盖了我们要查询的字段。当然，你通过索引查询的时候，执行计划显示的行数还是1.这是因为回表这个操作是在innoDB里面做的，mysql是感觉不到的。</p>
<h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>索引下推也是一种优化。比如我们要查询<code>用户名是张三</code>，<code>密码是123456</code>的用户。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span> <span class="keyword">and</span> pwd <span class="operator">=</span> <span class="string">&#x27;123456&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在mysql5.6以前，只能查询到张三这个数据以后回表找到数据在判断密码。</p>
<p>而mysqll5.6增加索引下推的优化之后，可以在索引遍历过程中，对name和pwd两个字段同时做判断。</p>
<h2 id="唯一索引和普通索引"><a href="#唯一索引和普通索引" class="headerlink" title="唯一索引和普通索引"></a>唯一索引和普通索引</h2><p>这两个索引到底该怎么选择，比如用户名字段，用户名当然是不能重复的了。那么它应该使用唯一索引还是普通索引呢？</p>
<p>一般用户注册的时候我们会判断用户名是否重复。所以用户名字段加唯一索引的价值并不大，我们的业务已经能保证它不重复了。</p>
<p>我们在上面说过，查询的时候，唯一索引查询到数据直接就返回了，显然要比普通索引快一些。</p>
<p>但是真的也就快了那么一点，因为InnoDB引擎在读取的时候，是读取一个数据页的数据。它会先把一个数据页读取到内存中，然后查询，那么在内存中多查一次其实没啥感觉。</p>
<p>在看一下更新的时候。</p>
<h4 id="数据在内存里面"><a href="#数据在内存里面" class="headerlink" title="数据在内存里面"></a>数据在内存里面</h4><p>如果数据在内存中，那么唯一索引会判断更新后是否会破坏唯一性，如果不破坏则更新。</p>
<p>普通索引则直接更新。</p>
<p>这里显示普通索引更好，不用判断。但是这个影响页很小，和上面一样，在内存中操作的。</p>
<h4 id="数据不在内存中"><a href="#数据不在内存中" class="headerlink" title="数据不在内存中"></a>数据不在内存中</h4><p>如果数据不在内存中，那么唯一索引就需要从磁盘读取数据，然后判断，更新。</p>
<p>普通索引则直接写入<code>change buffer</code>，然后就完成了，而change buffer则是在内存中，内存操作，少了磁盘操作。</p>
<p>整体来看，普通索引貌似比唯一索引更友好，唯一索引为了唯一性牺牲了插入和修改的性能。</p>
<h4 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h4><p>这个是一块内存中的空间，顾名思义，他就是为了修改而生的，如果你修改了数据，不需要直接更新磁盘，而是放入change buffer.change buffer满了，或者一定时间，或者当出现查询操作的时候，会merge数据，比如你更新了手机号，然后要查询这个用户的手机号。那么这时候内存中没有这个数据，从磁盘查询，磁盘查询到的是以前的手机号，因为数据没有更新到磁盘。这时候change buffer就会把更新数据合并到内存中的数据，使得查询到的是最新数据。</p>
<p>那么为什么唯一索引不适用change buffer，因为他需要判断唯一性。</p>
<p>但是向刚才举得例子，更新完立即查询，其实和唯一索引的更新没有啥区别了，反而因为change buffer还麻烦了。所以，change buffer更适合更新完不立即查询的场景。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql事务详解-4种事务隔离界别该怎么选择</title>
    <url>/mysql%E4%BA%8B%E5%8A%A1%E8%AF%A6%E8%A7%A3-4%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%95%8C%E5%88%AB%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9.html</url>
    <content><![CDATA[<h1 id="mysql事务详解-4种事务隔离级别该怎么选择"><a href="#mysql事务详解-4种事务隔离级别该怎么选择" class="headerlink" title="mysql事务详解-4种事务隔离级别该怎么选择"></a>mysql事务详解-4种事务隔离级别该怎么选择</h1><p>事务要保证ACID,其中就有隔离性。</p>
<p>当我们有多个事务在执行的时候，如果保证每个事务都是隔离的，而不是数据混乱的呢？sql标准的四种隔离级别如下：</p>
<ul>
<li>读未提交 RU(Read Uncommitted),在这个级别下，是所有数据共享的，A事务在执行的任何操作，B事务都能看见，不管有没有提交。</li>
<li>读已提交 RC(Read Committed),在这个级别下，只有A事务提交的数据，B事务才能看见。提交前的数据对其他事务是不可见的。</li>
<li>可重复读 RR(Repeatable Read),在这个级别下，一个事务内读取的数据都是重复的，也就是都是一致的，就算别的事务提交了数据，你读取的还是原来的数据。</li>
<li>串行化 (serializable)， 对于同一行记录，写会加写锁，读会加读锁。</li>
</ul>
<h2 id="事务隔离的原理"><a href="#事务隔离的原理" class="headerlink" title="事务隔离的原理"></a>事务隔离的原理</h2><p>这些是怎么做到的呢？因为事务是具备回滚功能的，如果一旦事务出错就会回滚整个事务。</p>
<p>用过github的应该都知道，github上的代码是具备回滚功能的，如果上线之后发现bug，会回滚到上一个版本，github就是基于版本控制的。</p>
<p>事务同样是基于版本控制的。有一个<code>undo log</code>回滚日志来记录这些版本。比如对于一行用户数据：</p>
<blockquote>
<p>{id: 1, name: 张三, mobile:13245678976, pwd: 123456}</p>
</blockquote>
<p>事务1进行了修改手机号操作,这时候还没有提交。数据库就会有两个版本的数据。这些都记录在undo log里面，这也就是所谓的<code>MVCC</code>的概念。</p>
<blockquote>
<p>{id: 1, name: 张三, mobile:13245678976, pwd: 123456} 原始版本<br>{id: 1, name: 张三, mobile:12322223333, pwd: 123456} 事务1版本</p>
</blockquote>
<p>事务2同时启动，但是稍后进行查询操作，获取用户信息，如果你是读未提交级别，那么读取的是事务1版本数据：</p>
<blockquote>
<p>{id: 1, name: 张三, mobile:12322223333, pwd: 123456} 事务1版本</p>
</blockquote>
<p>如果你是其他级别，那么你读取的是原始版本数据：</p>
<blockquote>
<p>{id: 1, name: 张三, mobile:13245678976, pwd: 123456} 原始版本</p>
</blockquote>
<p>如果事务1已经提交了修改，那么事务2在读已提交级别下获取的也是事务1版本数据。</p>
<p>这个是怎么判断的呢？</p>
<p>每个事务有自己的事务id，这个id是单调递增的。在每行数据的版本上会记录事务id。在事务启动的时候，会维护一个已经启动但没有提交的事务的<code>有序数组</code>。有序也就是从小到大，排好序了。如果事务id小于这个数组中第一个id，那么这个事务一定是一个已经提交的事务。如果事务id大于这个数组，那么这个事务是在我之后启动的事务。如果事务id在这个数组中，那么他在我启动的时候一定是未提交的。</p>
<p>拿上面的数据举例，原始版本的事务id为100，事务1的事务id为101，事务2的事务id为102。</p>
<blockquote>
<p>{id: 1, name: 张三, mobile:13245678976, pwd: 123456} 原始版本 100<br>{id: 1, name: 张三, mobile:12322223333, pwd: 123456} 事务1版本 101</p>
</blockquote>
<p>当事务2启动后，事务数组为[101]，假设这时候事务1未提交。</p>
<p>如果是可重复读级别下，那么当查询到最新版本事务id&#x3D;101,在数组中，那么不可见，接着查询上一个版本，上一个版本事务id &#x3D; 100，发现小于数组最小值，那么这个值是正确的，取出这个版本的数据。</p>
<p>这样就算后面有事务提交，但是它提交后的版本的事务id不满足要求，那么查看到的数据永远都是同一个版本的数据，这也就是<code>一致性读</code>。</p>
<p>但是如果你在事务2中先更新了密码再执行查询，那么就会有三个版本的数据</p>
<blockquote>
<p>{id: 1, name: 张三, mobile:13245678976, pwd: 123456} 原始版本 100<br>{id: 1, name: 张三, mobile:12322223333, pwd: 123456} 事务1版本 101<br>{id: 1, name: 张三, mobile:12322223333, pwd: 123456789} 事务2版本 102</p>
</blockquote>
<p>这时候查询，事务数组为[101,102]。</p>
<p>再可重复读级别下，查询到最新数据事务id&#x3D;102，发现和自己的一样，那么是可见的。因为是自己修改的，自己修改的不能不让自己看到啊，所以这时候查询到的数据会是最新数据。这也就是<code>当前读</code>。</p>
<p>可重复读级别和读已提交级别的区别如下：</p>
<ul>
<li>可重复读是再事务开始时候创建一致性视图，数组，这些东西，它只认事务启动前提交的数据。</li>
<li>读已提交级别则是每次执行sql语句的时候创建一致性视图，数组，这些东西，它认的是语句启动前提交的数据。</li>
</ul>
<p>这四个隔离级别，常用的就是读已提交和可重复读两个级别。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql事务怎么实现的，什么是两阶段提交</title>
    <url>/mysql%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.html</url>
    <content><![CDATA[<h1 id="mysql事务怎么实现的，什么是两阶段提交"><a href="#mysql事务怎么实现的，什么是两阶段提交" class="headerlink" title="mysql事务怎么实现的，什么是两阶段提交"></a>mysql事务怎么实现的，什么是两阶段提交</h1><p>我们都知道使用mysql的事务，准确来说是innoDB引擎的事务，可以保证数据的一致性，原子性等。那么为什么呢？</p>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>innoDB里面用到了一个叫做<code>redo log</code>（重做日志）的东西。</p>
<p>当你进行数据库操作的时候，innoDB并不会直接操作磁盘数据，因为这样很慢很慢。它使用了<code>wal</code>的机制，所有的操作先记录在redo log。等没事干了或者redo log满了再把数据刷到磁盘里面。这样的话他刷盘的时候就是顺序io，避免了使用随机io。redo log的大小我们可以通过参数设置。</p>
<h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>在innoDB里面还有一个缓冲池，buffer_pool，这个缓冲池是在内存中的。为啥有缓冲池，因为磁盘的速度太慢了，如果每次都直接操作磁盘，那就完犊子了。就需要用到内存来缓冲一下，提升性能。</p>
<p>从innoDB里面读取数据的时候，实际上读取的是缓冲池，只有当缓冲池中没有记录的时候，才会读取磁盘，并且将记录放入缓冲池方便下次读取。</p>
<p>缓冲池的大小可以通过<code>innodb_buffer_pool_size</code>参数来指定。</p>
<p>缓存池中基本有以下组件：</p>
<ul>
<li>索引页</li>
<li>数据页</li>
<li>undo页</li>
<li>插入缓冲（insert buffer)</li>
<li>自适应哈希索引</li>
<li>锁信息</li>
<li>数据字典</li>
<li>redo log buffer</li>
</ul>
<p>缓冲池既然是在内存中，有固定大小，就会有淘汰机制，缓冲池使用的是LRU机制，也就是最近最少使用的会被淘汰掉。</p>
<p>这里面还有一个redo log buffer，这里面存储的就是上面说的redo log的信息了，会先写入这个buffer，然后再刷入redo log里面。有一个参数<code>innodb_log_buffer_size</code>来控制redo log buffer的大小。这个不用太大，因为一般每秒都会把这里面的刷新到redo log。</p>
<p>redo log buffer刷新到redo log的三种情况：</p>
<ul>
<li>每秒刷新</li>
<li>事务提交时候刷新</li>
<li>当redo log buffer剩余空间少于一半的时候刷新</li>
</ul>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>redo log是innoDB引擎的日志，那mysql自己同样有日志，就是这个binlog日志。binlog 里面记载了mysql的所有变化，可以用来恢复数据库，创建备库，从库等。可以查看我的<a href="https://blog.csdn.net/Thepatterraining/article/details/105248917">mysql读写分离</a>。</p>
<p>那为什么有两个日志呢，这是因为mysql最开始默认使用的是myisam引擎，myisam引擎没有redo log，mysql就有自己的binlog。innoDB引擎是后来加入mysql的。所以他们各自有各自的日志。</p>
<p>这两个日志有什么区别呢？</p>
<ol>
<li>rodo log是innoDB引擎的，binlog 是mysql的，binlog所有引擎都可以使用。</li>
<li>redo log记录的是“再某个数据页上修改了啥”，binlog记录的是你的sql。</li>
<li>redo log是固定大小，循环写入的，binlog没有大小限制，不断追加。</li>
</ol>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>那一个事务怎么执行的呢，比如更新一个登录时间。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> login_time <span class="operator">=</span> ? <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>走完了前面的连接器，分析器，优化器，执行器。执行器会去innoDB更新数据了。</li>
<li>他会先取出这条数据，取出id &#x3D; 1的数据，id是主键索引，和数据在一起。innoDB直接查找主键索引树找到对应数据就返回了。当然，如果数据再缓冲池，那么直接返回了。</li>
<li>执行器拿到以后再修改登陆时间，然后再次调用innoDB引擎的接口。</li>
<li>innoDB把数据更新到内存中，同时更新redo log，把redo log标记成待提交状态。</li>
<li>执行器写入binlog。</li>
<li>执行器调用innoDB引擎的接口，innoDB把redo log标记成提交状态。</li>
</ul>
<p>这个时候整个更新事务完成。</p>
<p>为什么要这么做呢？</p>
<p>因为有两个日志的原因，所以两个日志都要写入，要保证这两个日志的一致性。那么如果不使用两阶段提交的方式，直接写入redo log然后写入binlog有什么问题呢？</p>
<p>假设，写完redo log，系统挂了。那么重启后innoDB引擎会根据redo log日志来恢复数据库。这时候数据库里面的数据是正确的。但是binlog丢失了啊。如果你有从库，那么从库的数据就错误了。因为从库的数据是通过binlog同步的。</p>
<p>如果把这两个步骤反过来呢，先写入binlog 再写入redo log呢？</p>
<p>那么就会redo log丢失，数据库实际上没有更新。但是从库通过binlog更新了。还是数据不一致。</p>
<p>所以需要<code>两阶段提交</code>来保证数据一致性。如果这时候写完redo log后挂掉了，因为redo log和binlog都没有数据，所以会回滚事务。<br>如果binlog和redo log都写入了，但是没有提交，那么重启后会提交事务。这样binlog和数据库就都有数据了。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>一条mysql语句的奇幻之旅</title>
    <url>/%E4%B8%80%E6%9D%A1mysql%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%A5%87%E5%B9%BB%E4%B9%8B%E6%97%85.html</url>
    <content><![CDATA[<h1 id="一条mysql语句的奇幻之旅"><a href="#一条mysql语句的奇幻之旅" class="headerlink" title="一条mysql语句的奇幻之旅"></a>一条mysql语句的奇幻之旅</h1><p>我们平常都会用到mysql，但是你真的知道sql语句是怎么执行的吗？</p>
<p>比如下面的sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users;</span><br></pre></td></tr></table></figure>

<p>这条sql语句大致会经过下面的阶段：</p>
<ol>
<li>连接器 – 连接器负责建立，管理mysql的连接，你首先要连接到mysql服务器，才能操作mysql。</li>
<li>分析器 – 分析器会进行词法分析和语法分析，语法错误会在这个阶段被返回。</li>
<li>优化器 – 优化器会自动优化我们的sql语句，如果它发现你的sql语句可以进行优化的话。优化器选择是否使用索引，索引怎么用。优化器还会选择更优的执行计划，最后会输出一个执行计划。</li>
<li>执行器 – 执行器会根据输出的执行计划进行最终的执行。他会调用底层存储引擎的接口，比如innoDB引擎。</li>
</ol>
<p>当我们最开始连接数据库实例的时候，我们要输入用户名密码，这时候连接器会从数据库的用户信息中判断你是否有<code>权限</code>连接数据库进行操作，有哪些权限。</p>
<p>如果你输入的用户名密码错误或者没有权限，那么你会收到下面的报错信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Access denied <span class="keyword">for</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>(<span class="keyword">using</span> password: YES)</span><br></pre></td></tr></table></figure>

<p>这里我们要搞清楚一个概念，数据库和数据库实例，我们使用的都是数据库实例，用实例来操作数据库。</p>
<p>连接成功以后开始执行上面的查询语句。<code>分析器</code>会分析这个语句的词法，语法，语义这些信息。通俗来讲就是看到<code>select</code>,<code>update</code>这些关键字，知道你要来干啥，看看你是不是来搞破坏的，来捣蛋的。看看你是查询哪个表啊，有什么条件啊，这些玩意。最后会输出一个词法树。当然了这一步还会分析你的语法有没有错误，比如你把<code>select</code>打错试试。打成<code>elect</code>，会出现下面的报错信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax: <span class="keyword">check</span> the maual that corresponds <span class="keyword">to</span> your MySQL server version <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> use near <span class="string">&#x27;elect * from users&#x27;</span> <span class="keyword">at</span> line <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>遇到这种<code>sql</code>语法错误，他会告诉你在哪出现了错误，其实就是分析器往后分析的时候发现，这不对啊，这不是我要的东西啊，你这偷梁换柱啊。</p>
<p>当这一步的考验你也通过了，那么骚年，你离飞升不远了。。。</p>
<p>进入优化器阶段，优化器接过语法树，会调整你的语法，比如他觉得你这么写它执行起来慢，执行的不爽，那么他会换个姿势再来一次。包括你的语法，执行的顺序，使用的索引，连表怎么连。最终优化完成会输出一个执行计划。</p>
<p>这个执行计划我们可以通过<code>explain</code>关键字查看，比如执行下面的语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users;</span><br></pre></td></tr></table></figure>

<p>他会输出下面的信息。我们可以看到<code>type</code>这一列是<code>all</code>。这代表全表扫描。</p>
<p><img src="/../images/mysql01.png" alt="Image text"></p>
<p>我们现在在执行另外一个看看。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看看这个执行结果。可以看到<code>type</code>这一列是<code>const</code>。这代表是常量。还有<code>key</code>这一列是<code>primary</code>，这代表我们这次使用了主键索引。而主键索引是聚簇索引，他的<code>page</code>页里面存储的就是这一行信息，所以只会查询一次。</p>
<p><img src="/../images/mysql02.png" alt="Image text"></p>
<p>上面输出的执行计划会最终由执行器来执行，执行器会调用<code>存储引擎</code>层的接口。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>其实，在这中间还有一个缓存组件。最开始查询的时候会先查询缓存组件的信息，如果没有缓存，才会走到分析器，然后往下走。如果命中缓存，那么直接返回，也就没后面什么事情了。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>laravel-react实战打造企业级高并发分布式电商小程序（三）--权限管理的前端</title>
    <url>/laravel-react%E5%AE%9E%E6%88%98%E6%89%93%E9%80%A0%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%AB%98%E5%B9%B6%E5%8F%91%E5%88%86%E5%B8%83%E5%BC%8F%E7%94%B5%E5%95%86%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%9A%84%E5%89%8D%E7%AB%AF.html</url>
    <content><![CDATA[<h1 id="laravel-react实战打造企业级高并发分布式电商小程序（三）–权限管理的前端"><a href="#laravel-react实战打造企业级高并发分布式电商小程序（三）–权限管理的前端" class="headerlink" title="laravel-react实战打造企业级高并发分布式电商小程序（三）–权限管理的前端"></a>laravel-react实战打造企业级高并发分布式电商小程序（三）–权限管理的前端</h1><h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><p>我们前端使用<code>react</code>来做，我们这个后台基于<code>antd pro</code>。使用<code>npm</code>创建它。</p>
<blockquote>
<p>npm create umi</p>
</blockquote>
<p>选择 <code>ant-design-pro</code></p>
<hr>
<p> Select the boilerplate type (Use arrow keys)<br>❯ ant-design-pro  - Create project with an layout-only ant-design-pro boilerplate, use together with umi block.<br>  app             - Create project with a simple boilerplate, support typescript.<br>  block           - Create a umi block.<br>  library         - Create a library with umi.<br>  plugin          - Create a umi plugin.</p>
<hr>
<p>Ant Design Pro 脚手架将会自动安装。</p>
<h5 id="本地开发"><a href="#本地开发" class="headerlink" title="本地开发"></a>本地开发</h5><blockquote>
<p>npm install<br>npm start</p>
</blockquote>
<p>启动完成后会自动打开浏览器访问 <a href="http://localhost:8000，你看到下面的页面就代表成功了。">http://localhost:8000，你看到下面的页面就代表成功了。</a></p>
<p><img src="/../images/laravel-react07.png" alt="Image text"></p>
]]></content>
      <categories>
        <category>laravel+react实战打造企业级高并发分布式电商小程序</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>laravel</tag>
        <tag>javascript</tag>
        <tag>react</tag>
        <tag>高并发</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode无法执行npm等脚本的问题</title>
    <url>/vscode%E6%97%A0%E6%B3%95%E6%89%A7%E8%A1%8Cnpm%E7%AD%89%E8%84%9A%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h1 id="vscode无法执行npm等脚本的问题"><a href="#vscode无法执行npm等脚本的问题" class="headerlink" title="vscode无法执行npm等脚本的问题"></a>vscode无法执行npm等脚本的问题</h1><p>这是因为在windows系统上面powershell的执行策略问题。</p>
<p>可以运行下面的命令查看当前执行策略</p>
<blockquote>
<p>Get-ExecutionPolicy</p>
</blockquote>
<p>使用下面的命令更改执行策略</p>
<blockquote>
<p>Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser</p>
</blockquote>
<p><code>-scope</code>参数是 限制在当前用户下面更改 策略更改为<code>RemoteSigned</code>策略。</p>
<h5 id="RemoteSigned"><a href="#RemoteSigned" class="headerlink" title="RemoteSigned"></a>RemoteSigned</h5><ul>
<li>Windows服务器计算机的默认执行策略。</li>
<li>脚本可以运行。</li>
<li>需要从可信任的发布者处获得从互联网下载的脚本和配置文件的数字签名，其中包括电子邮件和即时消息传递程序。</li>
<li>不需要在本地计算机上编写且未从Internet下载的脚本上进行数字签名。</li>
<li>如果脚本不受阻碍（例如使用Unblock-Filecmdlet），则运行从Internet下载且未签名的脚本。</li>
<li>可能会运行来自Internet以外的其他来源的未签名脚本和可能有害的已签名脚本。</li>
</ul>
<h5 id="Restricted"><a href="#Restricted" class="headerlink" title="Restricted"></a>Restricted</h5><ul>
<li>Windows客户端计算机的默认执行策略。</li>
<li>允许使用单个命令，但不允许使用脚本。</li>
<li>阻止运行所有脚本文件，包括格式和配置文件（.ps1xml），模块脚本文件（.psm1）和PowerShell配置文件（.ps1）。</li>
</ul>
<h5 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h5><ul>
<li>当前范围中未设置执行策略。</li>
<li>如果所有作用域中的执行策略均为Undefined，则有效的执行策略为Restricted，这是默认的执行策略。</li>
</ul>
<h5 id="Unrestricted"><a href="#Unrestricted" class="headerlink" title="Unrestricted"></a>Unrestricted</h5><ul>
<li>非Windows计算机的默认执行策略，不能更改。</li>
<li>未签名的脚本可以运行。有运行恶意脚本的风险。</li>
<li>在运行非本地Intranet区域中的脚本和配置文件之前警告用户。</li>
</ul>
<p>更多问题可以参考<code>powershell</code>的官方文档</p>
<blockquote>
<p><a href="https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7">https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7</a></p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>javascript</tag>
        <tag>vscode</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>laravel+react实战打造企业级高并发分布式电商小程序（一）--基础建设</title>
    <url>/laravel-react%E5%AE%9E%E6%88%98%E6%89%93%E9%80%A0%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%AB%98%E5%B9%B6%E5%8F%91%E5%88%86%E5%B8%83%E5%BC%8F%E7%94%B5%E5%95%86%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89-%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE.html</url>
    <content><![CDATA[<h1 id="laravel-react实战打造企业级高并发分布式电商小程序（一）"><a href="#laravel-react实战打造企业级高并发分布式电商小程序（一）" class="headerlink" title="laravel+react实战打造企业级高并发分布式电商小程序（一）"></a>laravel+react实战打造企业级高并发分布式电商小程序（一）</h1><p>整体使用laravel7+react打造整个电商小程序。里面会涉及到高并发的知识，mysql的分库分表，主从读写分离的配置，redis集群的使用，缓存系统的使用，队列系统的使用等。</p>
<p>先初始化一个laravel的项目。然后配置好<code>.env</code>文件。</p>
<h2 id="基础建设"><a href="#基础建设" class="headerlink" title="基础建设"></a>基础建设</h2><p>我们使用前后端分离就要考虑跨域问题和安全问题。跨域使用<code>cors</code>解决，laravel7里面内置了<code>cors</code>的解决方案，我们只要修改<code>config/cors.php</code>配置文件就好了。</p>
<p>把里面的值更改一下。修改这个值的原因是因为我们会使用jwt传一个token的请求头过来进行验证。这个时候还是报跨域的错误，所以将<code>supports_credentials</code>值修改为true，如果不报错就不需要修改了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&#x27;supports_credentials&#x27;</span> =&gt; <span class="literal">true</span>,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>把这个参数的值修改为true。</p>
<p>安全问题使用<code>jwt</code>的解决方案，安装<code>jwt</code>的包。</p>
<blockquote>
<p>composer require lcobucci&#x2F;jwt</p>
</blockquote>
<p>在routes&#x2F;api.php路由文件中增加下面的路由</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//获取jwt token</span></span><br><span class="line"><span class="title class_">Route</span>::<span class="title function_ invoke__">post</span>(<span class="string">&#x27;/require_token&#x27;</span>, <span class="string">&#x27;JWT\RequireTokenController@requireToken&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在config下面新建<code>jwt.php</code>文件，里面内容如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="string">&#x27;JWT_SECRET&#x27;</span> =&gt; <span class="title function_ invoke__">env</span>(<span class="string">&#x27;JWT_SECRET&#x27;</span>,<span class="string">&#x27;DvYUz+woS7vVJe6ldY+PqWoUbhIyY9rShzM0NAfzxdU=&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;JWT_EXP_TIME&#x27;</span> =&gt; <span class="title function_ invoke__">env</span>(<span class="string">&#x27;JWT_EXP_TIME&#x27;</span>,<span class="string">&#x27;36000&#x27;</span>),</span><br><span class="line">];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>.env</code>中增加下面的内容</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># jwt</span></span><br><span class="line">JWT_SECRET=DvYUz+woS7vVJe6ldY+PqWoUbhIyY9rShzM0NAfzxdU=   </span><br><span class="line">JWT_EXP_TIME=<span class="number">36000</span>  <span class="comment">//过期时间</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>app/http/middleware</code>中创建中间件<code>jwtCheck.php</code>,内容如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">App</span>\<span class="title class_">Http</span>\<span class="title class_">Middleware</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">Sys</span>\<span class="title">ErrorModel</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Closure</span>;</span><br><span class="line"><span class="keyword">use</span> \<span class="title">Lcobucci</span>\<span class="title">JWT</span>\<span class="title">Parser</span>;</span><br><span class="line"><span class="keyword">use</span> \<span class="title">Lcobucci</span>\<span class="title">JWT</span>\<span class="title">Signer</span>\<span class="title">Hmac</span>\<span class="title">Sha256</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">jwtCheck</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Handle an incoming request.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  \Illuminate\Http\Request  $request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  \Closure  $next</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"><span class="variable">$request</span>, <span class="built_in">Closure</span> <span class="variable">$next</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$parser</span> = <span class="keyword">new</span> Parser;</span><br><span class="line">        <span class="variable">$signer</span> = <span class="keyword">new</span> Sha256;</span><br><span class="line">        <span class="variable">$secret</span> = <span class="title function_ invoke__">config</span>(<span class="string">&#x27;jwt.JWT_SECRET&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$request</span>-&gt;<span class="title function_ invoke__">hasHeader</span>(<span class="string">&#x27;Authorization&#x27;</span>))&#123;</span><br><span class="line">            <span class="variable">$token</span> = <span class="variable">$request</span>-&gt;<span class="title function_ invoke__">header</span>(<span class="string">&#x27;Authorization&#x27;</span>);</span><br><span class="line">            <span class="comment">//解析token</span></span><br><span class="line">            <span class="variable">$parse</span> = <span class="variable">$parser</span>-&gt;<span class="title function_ invoke__">parse</span>(<span class="variable">$token</span>);</span><br><span class="line">            <span class="comment">//验证token合法性</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="variable">$parse</span>-&gt;<span class="title function_ invoke__">verify</span>(<span class="variable">$signer</span>, <span class="variable">$secret</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">response</span>()-&gt;<span class="title function_ invoke__">json</span>([<span class="string">&#x27;code&#x27;</span>=&gt;<span class="title class_">ErrorModel</span>::JWT_ERROR, <span class="string">&#x27;msg&#x27;</span>=&gt;<span class="string">&#x27;令牌错误！&#x27;</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//验证是否已经过期</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$parse</span>-&gt;<span class="title function_ invoke__">isExpired</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">response</span>()-&gt;<span class="title function_ invoke__">json</span>([<span class="string">&#x27;code&#x27;</span>=&gt;<span class="title class_">ErrorModel</span>::JWT_ERROR, <span class="string">&#x27;msg&#x27;</span>=&gt;<span class="string">&#x27;令牌过期！&#x27;</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">response</span>()-&gt;<span class="title function_ invoke__">json</span>([<span class="string">&#x27;code&#x27;</span>=&gt;<span class="title class_">ErrorModel</span>::JWT_ERROR, <span class="string">&#x27;msg&#x27;</span>=&gt;<span class="string">&#x27;令牌缺失！&#x27;</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把token放到参数里面</span></span><br><span class="line">        <span class="title function_ invoke__">request</span>()-&gt;<span class="title function_ invoke__">offsetSet</span>(<span class="string">&#x27;token&#x27;</span>, <span class="variable">$token</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$next</span>(<span class="variable">$request</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>app/http</code>下面的<code>Kernel.php</code>文件里面的<code>$routeMiddleware</code>变量里面增加下面内容，把中间件注册到系统中。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;jwtCheck&#x27;</span> =&gt; \App\Http\Middleware\jwt<span class="title class_">Check</span>::<span class="variable language_">class</span>,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><p>创建控制器</p>
<p>在<code>app/http/controller</code>下面创建<code>jwt</code>文件夹，然后在<code>jwt</code>文件夹里面创建<code>RequireTokenController.php</code>文件。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">App</span>\<span class="title class_">Http</span>\<span class="title class_">Controllers</span>\<span class="title class_">JWT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Controller</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"><span class="keyword">use</span> \<span class="title">Lcobucci</span>\<span class="title">JWT</span>\<span class="title">Builder</span>;</span><br><span class="line"><span class="keyword">use</span> \<span class="title">Lcobucci</span>\<span class="title">JWT</span>\<span class="title">Signer</span>\<span class="title">Hmac</span>\<span class="title">Sha256</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Redis</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequireTokenController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">requireToken</span>(<span class="params">Builder <span class="variable">$builder</span>, Sha256 <span class="variable">$signer</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$secret</span> = <span class="title function_ invoke__">config</span>(<span class="string">&#x27;jwt.JWT_SECRET&#x27;</span>);</span><br><span class="line">        <span class="variable">$time</span> = <span class="title function_ invoke__">time</span>();</span><br><span class="line">        <span class="variable">$expTime</span> = <span class="title function_ invoke__">config</span>(<span class="string">&#x27;jwt.JWT_EXP_TIME&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//设置header和payload，以下的字段都可以自定义</span></span><br><span class="line">            <span class="variable">$builder</span>-&gt;<span class="title function_ invoke__">setIssuer</span>(<span class="string">&quot;cmp.wliot.com&quot;</span>) <span class="comment">//发布者</span></span><br><span class="line">                    -&gt;<span class="title function_ invoke__">setAudience</span>(<span class="string">&quot;cmp.wliot.com&quot;</span>) <span class="comment">//接收者</span></span><br><span class="line">                    -&gt;<span class="title function_ invoke__">setId</span>(<span class="string">&quot;abc&quot;</span>, <span class="literal">true</span>) <span class="comment">//对当前token设置的标识</span></span><br><span class="line">                    -&gt;<span class="title function_ invoke__">setIssuedAt</span>(<span class="variable">$time</span>) <span class="comment">//token创建时间</span></span><br><span class="line">                    -&gt;<span class="title function_ invoke__">setExpiration</span>(<span class="variable">$time</span> + <span class="variable">$expTime</span>) <span class="comment">//过期时间</span></span><br><span class="line">                    <span class="comment">// -&gt;setNotBefore($time + 5) //当前时间在这个时间前，token不能使用</span></span><br><span class="line">                    -&gt;<span class="title function_ invoke__">set</span>(<span class="string">&#x27;uid&#x27;</span>, <span class="number">30061</span>); <span class="comment">//自定义数据</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置签名</span></span><br><span class="line">            <span class="variable">$builder</span>-&gt;<span class="title function_ invoke__">sign</span>(<span class="variable">$signer</span>, <span class="variable">$secret</span>);</span><br><span class="line">            <span class="comment">//获取加密后的token，转为字符串</span></span><br><span class="line">            <span class="variable">$token</span> = (<span class="keyword">string</span>)<span class="variable">$builder</span>-&gt;<span class="title function_ invoke__">getToken</span>();</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="title class_">Redis</span>::<span class="title function_ invoke__">exists</span>(<span class="variable">$token</span>));</span><br><span class="line">        <span class="comment">//存入redis</span></span><br><span class="line">        <span class="comment">// Redis::setex($token, $expTime, json_encode([]));</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">success</span>(<span class="variable">$token</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里面使用到了<code>$this-&gt;success()</code>方法，这个方法来自controller类，我们需要编写这个方法。</p>
<p>在<code>app/http</code>下面创建<code>Utils</code>文件夹，在里面创建<code>Success.php</code>文件。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">App</span>\<span class="title class_">Http</span>\<span class="title class_">Utils</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">Sys</span>\<span class="title">ErrorModel</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Success</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params"><span class="variable">$data</span> = []</span>) </span>&#123;</span><br><span class="line">        <span class="variable">$res</span> = [<span class="string">&#x27;code&#x27;</span>=&gt;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;msg&#x27;</span>=&gt;<span class="string">&#x27;请求成功！&#x27;</span>, <span class="string">&#x27;data&#x27;</span>=&gt;<span class="variable">$data</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">response</span>()-&gt;<span class="title function_ invoke__">json</span>(<span class="variable">$res</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改<code>app/http/controllers/controller.php</code>文件</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Utils</span>\<span class="title">Success</span>;  <span class="comment">//引入刚才的文件</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span> <span class="keyword">extends</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">AuthorizesRequests</span>, <span class="title">DispatchesJobs</span>, <span class="title">ValidatesRequests</span>, <span class="title">Success</span>;  <span class="comment">//在这里添加Success 也就是刚才的文件。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在这里面使用到了redis，所以我们需要启动你本地的redis服务器。启动之后就可以访问我们上面填写的路由了，使用postman访问你的路由。</p>
<p><img src="/../images/laravel-react01.png" alt="Image text"></p>
<p>可以看到返回了正确的token。</p>
<p>在后面的访问请求中我们需要使用这个token。我们把它加入请求头。在请求头新建一个<code>Authorization</code>的key，他的值就是我们的token。</p>
]]></content>
      <categories>
        <category>laravel+react实战打造企业级高并发分布式电商小程序</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>laravel</tag>
        <tag>javascript</tag>
        <tag>react</tag>
        <tag>高并发</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>laravel+react实战打造企业级高并发分布式电商小程序（二）--权限管理</title>
    <url>/laravel-react%E5%AE%9E%E6%88%98%E6%89%93%E9%80%A0%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%AB%98%E5%B9%B6%E5%8F%91%E5%88%86%E5%B8%83%E5%BC%8F%E7%94%B5%E5%95%86%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86.html</url>
    <content><![CDATA[<h1 id="laravel-react实战打造企业级高并发分布式电商小程序（二）"><a href="#laravel-react实战打造企业级高并发分布式电商小程序（二）" class="headerlink" title="laravel+react实战打造企业级高并发分布式电商小程序（二）"></a>laravel+react实战打造企业级高并发分布式电商小程序（二）</h1><p>整体使用laravel7+react打造整个电商小程序。里面会涉及到高并发的知识，mysql的分库分表，主从读写分离的配置，redis集群的使用，缓存系统的使用，队列系统的使用等。</p>
<p>先初始化一个laravel的项目。然后配置好<code>.env</code>文件。</p>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>既然是电商肯定有后台，要做权限管理这块。</p>
<p>先创建表，这里使用<code>laravel</code>的<code>migration</code>。下面是后台用户表。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Migrations</span>\<span class="title">Migration</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Schema</span>\<span class="title">Blueprint</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Schema</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateUsersTable</span> <span class="keyword">extends</span> <span class="title">Migration</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">up</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title class_">Schema</span>::<span class="title function_ invoke__">create</span>(<span class="string">&#x27;auth_users&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">Blueprint <span class="variable">$table</span></span>) </span>&#123;</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="title function_ invoke__">bigIncrements</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="keyword">string</span>(<span class="string">&#x27;name&#x27;</span>, <span class="number">100</span>)-&gt;<span class="title function_ invoke__">unique</span>();</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="keyword">string</span>(<span class="string">&#x27;email&#x27;</span>, <span class="number">100</span>)-&gt;<span class="title function_ invoke__">unique</span>();</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="title function_ invoke__">timestamp</span>(<span class="string">&#x27;email_verified_at&#x27;</span>)-&gt;<span class="title function_ invoke__">nullable</span>();</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="keyword">string</span>(<span class="string">&#x27;password&#x27;</span>);</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="title function_ invoke__">rememberToken</span>();</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="title function_ invoke__">timestamps</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reverse the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">down</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title class_">Schema</span>::<span class="title function_ invoke__">dropIfExists</span>(<span class="string">&#x27;auth_users&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是角色表</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Migrations</span>\<span class="title">Migration</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Schema</span>\<span class="title">Blueprint</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Schema</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateRolesTable</span> <span class="keyword">extends</span> <span class="title">Migration</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">up</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title class_">Schema</span>::<span class="title function_ invoke__">create</span>(<span class="string">&#x27;auth_roles&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">Blueprint <span class="variable">$table</span></span>) </span>&#123;</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="title function_ invoke__">bigIncrements</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="keyword">string</span>(<span class="string">&#x27;name&#x27;</span>, <span class="number">100</span>)-&gt;<span class="title function_ invoke__">unique</span>();</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="title function_ invoke__">timestamps</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reverse the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">down</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title class_">Schema</span>::<span class="title function_ invoke__">dropIfExists</span>(<span class="string">&#x27;auth_roles&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是权限表</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Migrations</span>\<span class="title">Migration</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Schema</span>\<span class="title">Blueprint</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Schema</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreatePermissionsTable</span> <span class="keyword">extends</span> <span class="title">Migration</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">up</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title class_">Schema</span>::<span class="title function_ invoke__">create</span>(<span class="string">&#x27;auth_permissions&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">Blueprint <span class="variable">$table</span></span>) </span>&#123;</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="title function_ invoke__">bigIncrements</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="keyword">string</span>(<span class="string">&#x27;name&#x27;</span>,<span class="number">100</span>)-&gt;<span class="title function_ invoke__">unique</span>();</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="title function_ invoke__">timestamps</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reverse the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">down</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title class_">Schema</span>::<span class="title function_ invoke__">dropIfExists</span>(<span class="string">&#x27;auth_permissions&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是用户角色关联表</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Migrations</span>\<span class="title">Migration</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Schema</span>\<span class="title">Blueprint</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Schema</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateUserRolesTable</span> <span class="keyword">extends</span> <span class="title">Migration</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">up</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title class_">Schema</span>::<span class="title function_ invoke__">create</span>(<span class="string">&#x27;auth_user_roles&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">Blueprint <span class="variable">$table</span></span>) </span>&#123;</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="title function_ invoke__">bigIncrements</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="title function_ invoke__">bigInteger</span>(<span class="string">&#x27;user_id&#x27;</span>);</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="title function_ invoke__">bigInteger</span>(<span class="string">&#x27;role_id&#x27;</span>);</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="title function_ invoke__">timestamps</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reverse the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">down</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title class_">Schema</span>::<span class="title function_ invoke__">dropIfExists</span>(<span class="string">&#x27;auth_user_roles&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是角色和权限关联表</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Migrations</span>\<span class="title">Migration</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Schema</span>\<span class="title">Blueprint</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Schema</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateRolePerimissionsTable</span> <span class="keyword">extends</span> <span class="title">Migration</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">up</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title class_">Schema</span>::<span class="title function_ invoke__">create</span>(<span class="string">&#x27;auth_role_permissions&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">Blueprint <span class="variable">$table</span></span>) </span>&#123;</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="title function_ invoke__">bigIncrements</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="title function_ invoke__">bigInteger</span>(<span class="string">&#x27;user_id&#x27;</span>)-&gt;<span class="keyword">default</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="title function_ invoke__">bigInteger</span>(<span class="string">&#x27;role_id&#x27;</span>);</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="title function_ invoke__">bigInteger</span>(<span class="string">&#x27;perimission_id&#x27;</span>);</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="title function_ invoke__">timestamps</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reverse the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">down</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title class_">Schema</span>::<span class="title function_ invoke__">dropIfExists</span>(<span class="string">&#x27;auth_role_permissions&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面这张是系统错误信息表，这里会返回错误信息，这些错误信息全部存放在这张表里。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Migrations</span>\<span class="title">Migration</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Schema</span>\<span class="title">Blueprint</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Schema</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateSysErrorsTable</span> <span class="keyword">extends</span> <span class="title">Migration</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">up</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title class_">Schema</span>::<span class="title function_ invoke__">create</span>(<span class="string">&#x27;sys_errors&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">Blueprint <span class="variable">$table</span></span>) </span>&#123;</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="title function_ invoke__">bigIncrements</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="keyword">string</span>(<span class="string">&#x27;code&#x27;</span>,<span class="number">100</span>)-&gt;<span class="title function_ invoke__">unique</span>()-&gt;<span class="title function_ invoke__">comment</span>(<span class="string">&#x27;错误编码&#x27;</span>);</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="keyword">string</span>(<span class="string">&#x27;msg&#x27;</span>)-&gt;<span class="title function_ invoke__">comment</span>(<span class="string">&#x27;错误信息&#x27;</span>);</span><br><span class="line">            <span class="variable">$table</span>-&gt;<span class="title function_ invoke__">timestamps</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reverse the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">down</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title class_">Schema</span>::<span class="title function_ invoke__">dropIfExists</span>(<span class="string">&#x27;sys_errors&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建完这些执行迁移命令就可以了。</p>
<blockquote>
<p>php artisan migrate</p>
</blockquote>
<p>当然了，在这之前确保你的<code>.env</code>文件已经配置好了数据库连接。</p>
<p>我们有了后台数据还需要一个管理员账户，使用<code>seed</code>填充。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">Auth</span>\<span class="title">UserModel</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Seeder</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Hash</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UsersTableSeeder</span> <span class="keyword">extends</span> <span class="title">Seeder</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the database seeds.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">UserModel <span class="variable">$user</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$user</span>-&gt;name = <span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line">        <span class="variable">$user</span>-&gt;email = <span class="string">&#x27;admin@admin.com&#x27;</span>;</span><br><span class="line">        <span class="variable">$user</span>-&gt;password = <span class="title class_">Hash</span>::<span class="title function_ invoke__">make</span>(<span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line">        <span class="variable">$user</span>-&gt;<span class="title function_ invoke__">save</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行填充命令</p>
<blockquote>
<p>php artisan db:seed</p>
</blockquote>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>这里我们使用一个<code>laravel</code>的扩展包，使用composer安装他</p>
<blockquote>
<p>composer require thepatter&#x2F;query-common</p>
</blockquote>
<p>安装完后查看我的这个文章来使用这个包，根据文章里面做完之后再回来看下面的内容。</p>
<blockquote>
<p><a href="https://blog.csdn.net/Thepatterraining/article/details/105408363">https://blog.csdn.net/Thepatterraining/article/details/105408363</a></p>
</blockquote>
<p>接下来使用<code>artisan</code>命令创建我们的控制器。</p>
<blockquote>
<p>php artisan make:queryController Auth&#x2F;UserController</p>
</blockquote>
<p>创建完之后在创建model</p>
<blockquote>
<p>php artisan make:model Models&#x2F;Auth&#x2F;UserModel</p>
</blockquote>
<p>修改刚才的<code>Auth/UserModel</code>，在里面增加<code>table</code>属性。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">App</span>\<span class="title class_">Models</span>\<span class="title class_">Auth</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Eloquent</span>\<span class="title">Model</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserModel</span> <span class="keyword">extends</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$table</span> = <span class="string">&#x27;auth_users&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改刚才的<code>Auth/UserController</code>控制器。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">App</span>\<span class="title class_">Http</span>\<span class="title class_">Controllers</span>\<span class="title class_">Auth</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">QueryCommon</span>\<span class="title">QueryController</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">Auth</span>\<span class="title">UserModel</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">Auth</span>\<span class="title">UserRoleModel</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">QueryController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字典数组</span></span><br><span class="line"><span class="comment">     * [&#x27;表里的字段名&#x27; =&gt; &#x27;字典code&#x27;,...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$dicArr</span> = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字段映射 可选，不填默认转成下划线格式</span></span><br><span class="line"><span class="comment">     * [&#x27;搜索字段&#x27; =&gt; &#x27;表字段&#x27;,...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$filedsAdapter</span> = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建时候的字段映射 可选，不填默认转成下划线格式</span></span><br><span class="line"><span class="comment">     * [&#x27;输入字段&#x27; =&gt; &#x27;表字段&#x27;]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$createAdapter</span> = [</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;email&#x27;</span> =&gt; <span class="string">&#x27;email&#x27;</span>,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义表名 格式: table as t</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$shortTableName</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getModel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;model = <span class="keyword">new</span> UserModel;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;model;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时候我们对用户的增删改查操作就完成了，是不是超级简单呢。这主要依赖于我们的<code>query-common</code>扩展包。</p>
<p>我们接下来只需要添加对应的路由就可以了。在<code>routes</code>下面创建<code>Api/Auth</code>文件夹。在里面创建<code>index.php</code>路由文件。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Route</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Route</span>::<span class="title function_ invoke__">prefix</span>(<span class="string">&#x27;auth&#x27;</span>)-&gt;<span class="title function_ invoke__">namespace</span>(<span class="string">&#x27;Auth&#x27;</span>)-&gt;<span class="title function_ invoke__">group</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//后台创建用户</span></span><br><span class="line">    <span class="title class_">Route</span>::<span class="title function_ invoke__">post</span>(<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;UserController@createInfo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后台查询管理员列表</span></span><br><span class="line">    <span class="title class_">Route</span>::<span class="title function_ invoke__">get</span>(<span class="string">&#x27;users&#x27;</span>, <span class="string">&#x27;UserController@queryList&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后台更新管理员信息</span></span><br><span class="line">    <span class="title class_">Route</span>::<span class="title function_ invoke__">put</span>(<span class="string">&#x27;user/&#123;id&#125;&#x27;</span>, <span class="string">&#x27;UserController@updateInfo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后台删除管理员</span></span><br><span class="line">    <span class="title class_">Route</span>::<span class="title function_ invoke__">delete</span>(<span class="string">&#x27;user/&#123;id&#125;&#x27;</span>, <span class="string">&#x27;UserController@deleteInfo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>添加完路由文件后我们需要自动加载路由文件，请看我的这篇文章，路由自动加载。</p>
<blockquote>
<p><a href="https://blog.csdn.net/Thepatterraining/article/details/105386868">https://blog.csdn.net/Thepatterraining/article/details/105386868</a></p>
</blockquote>
<p>接下来可以使用<code>postman</code>来测试了。</p>
<p>获取用户列表</p>
<p><img src="/../images/laravel-react02.png" alt="Image text"></p>
<p>其他的就不放图了。</p>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>有了用户就有角色了，我们的角色表在之前已经创建好了，我们现在同样的方法创建controller和model。</p>
<p>执行下面的命令。<code>-m</code>参数是model，这里指定model后，如果model不存在会自动创建。</p>
<blockquote>
<p>php artisan make:queryController Auth&#x2F;RoleController -m Models&#x2F;Auth&#x2F;RoleModel</p>
</blockquote>
<p>修改刚才的<code>Auth/RoleModel</code>，在里面增加<code>table</code>属性。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">App</span>\<span class="title class_">Models</span>\<span class="title class_">Auth</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Eloquent</span>\<span class="title">Model</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoleModel</span> <span class="keyword">extends</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$table</span> = <span class="string">&#x27;auth_roles&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>app/Http/Controllers/Auth/RoleController</code>文件内容如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">App</span>\<span class="title class_">Http</span>\<span class="title class_">Controllers</span>\<span class="title class_">Auth</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">QueryCommon</span>\<span class="title">QueryController</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">Auth</span>\<span class="title">RoleModel</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoleController</span> <span class="keyword">extends</span> <span class="title">QueryController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字典数组</span></span><br><span class="line"><span class="comment">     * [&#x27;表里的字段名&#x27; =&gt; &#x27;字典code&#x27;,...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$dicArr</span> = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字段映射 可选，不填默认转成下划线格式</span></span><br><span class="line"><span class="comment">     * [&#x27;搜索字段&#x27; =&gt; &#x27;表字段&#x27;,...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$filedsAdapter</span> = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建时候的字段映射 可选，不填默认转成下划线格式</span></span><br><span class="line"><span class="comment">     * [&#x27;输入字段&#x27; =&gt; &#x27;表字段&#x27;]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$createAdapter</span> = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义表名 格式: table as t</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$shortTableName</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getModel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;model = <span class="keyword">new</span> <span class="title class_">RoleModel</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;model;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着在刚才的<code>routes/Api/Auth/index</code>路由文件中增加下面的内容</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//后台查询角色列表</span></span><br><span class="line">    <span class="title class_">Route</span>::<span class="title function_ invoke__">get</span>(<span class="string">&#x27;roles&#x27;</span>, <span class="string">&#x27;RoleController@queryList&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建角色</span></span><br><span class="line">    <span class="title class_">Route</span>::<span class="title function_ invoke__">post</span>(<span class="string">&#x27;role&#x27;</span>, <span class="string">&#x27;RoleController@createInfo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新角色</span></span><br><span class="line">    <span class="title class_">Route</span>::<span class="title function_ invoke__">put</span>(<span class="string">&#x27;role/&#123;id&#125;&#x27;</span>, <span class="string">&#x27;RoleController@updateInfo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除角色</span></span><br><span class="line">    <span class="title class_">Route</span>::<span class="title function_ invoke__">delete</span>(<span class="string">&#x27;role/&#123;id&#125;&#x27;</span>, <span class="string">&#x27;RoleController@deleteInfo&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>增加后是下图这样</p>
<p><img src="/../images/laravel-react03.png" alt="Image text"></p>
<p>同样使用postman测试。</p>
<p><img src="/../images/laravel-react04.png" alt="Image text"></p>
<h4 id="用户和角色关联"><a href="#用户和角色关联" class="headerlink" title="用户和角色关联"></a>用户和角色关联</h4><p>有了用户和角色就要把这两个关联起来了，我们通过在创建用户和修改用户的时候关联角色，在这时候就要更改之前的<code>Auth/UserController</code>了。</p>
<p>增加下面的函数。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建完用户后执行的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">createAfter</span>(<span class="params"><span class="variable">$id</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">userRole</span>(<span class="variable">$id</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新完主表之后可以进行的操作</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">updateAfter</span>(<span class="params"><span class="variable">$id</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//更新完用户信息需要更新用户角色关联</span></span><br><span class="line">    <span class="comment">//先删除所有关联，再重新创建</span></span><br><span class="line">    <span class="title class_">UserRoleModel</span>::<span class="title function_ invoke__">where</span>(<span class="string">&#x27;user_id&#x27;</span>, <span class="variable">$id</span>)-&gt;<span class="title function_ invoke__">delete</span>();</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">userRole</span>(<span class="variable">$id</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户角色操作，先删除用户的所有角色，再创建角色关联</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int $id 用户id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">userRole</span>(<span class="params"><span class="variable">$id</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$ids</span> = <span class="variable language_">$this</span>-&gt;request-&gt;<span class="title function_ invoke__">input</span>(<span class="string">&#x27;roleIds&#x27;</span>);</span><br><span class="line">    <span class="comment">//组织数据</span></span><br><span class="line">    <span class="variable">$insertDatas</span> = [];</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$ids</span> <span class="keyword">as</span> <span class="variable">$roleId</span>) &#123;</span><br><span class="line">        <span class="variable">$insertData</span> = [];</span><br><span class="line">        <span class="variable">$insertData</span>[<span class="string">&#x27;user_id&#x27;</span>] = <span class="variable">$id</span>;</span><br><span class="line">        <span class="variable">$insertData</span>[<span class="string">&#x27;role_id&#x27;</span>] = <span class="variable">$roleId</span>;</span><br><span class="line">        <span class="variable">$insertData</span>[<span class="string">&#x27;created_at&#x27;</span>] = <span class="title function_ invoke__">date</span>(<span class="string">&#x27;Y-m-d H:i:s&#x27;</span>);</span><br><span class="line">        <span class="variable">$insertDatas</span>[] = <span class="variable">$insertData</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一次性插入</span></span><br><span class="line">    <span class="title class_">UserRoleModel</span>::<span class="title function_ invoke__">insert</span>(<span class="variable">$insertDatas</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createAfter</code>方法是在创建完用户后执行的，<code>updateAfter</code>方法是更新完用户信息后执行的。传入用户id。我们在这里删除之前的用户和角色关联，把新的循环添加到数组中，一次性插入数据库。因为循环插入会进行多次<code>数据库io</code>操作，而数据库io是比较耗费资源和时间的，所以我们尽可能少进行数据库操作。</p>
<p>在创建和更新时候我们还需要验证参数，我们再添加下面的方法。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在创建之前调用，用来验证参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">createBefore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//检测页码和每页数量</span></span><br><span class="line">    <span class="variable">$rules</span> = [</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;required|unique:auth_users,name&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;email&#x27;</span> =&gt; <span class="string">&#x27;required|email|unique:auth_users,email&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;password&#x27;</span> =&gt; <span class="string">&#x27;required&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;roleIds&#x27;</span> =&gt; <span class="string">&#x27;required|array&#x27;</span>,</span><br><span class="line">    ];</span><br><span class="line">    <span class="variable">$messages</span> = [</span><br><span class="line">        <span class="string">&#x27;name.required&#x27;</span> =&gt; <span class="string">&#x27;用户名为必填项&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;name.unique&#x27;</span> =&gt; <span class="string">&#x27;用户已经存在&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;email.required&#x27;</span> =&gt; <span class="string">&#x27;邮箱为必填项&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;email.unique&#x27;</span> =&gt; <span class="string">&#x27;邮箱已经存在&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;email.email&#x27;</span> =&gt; <span class="string">&#x27;请输入正确的邮箱格式&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;password.required&#x27;</span> =&gt; <span class="string">&#x27;密码为必填项&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;roleIds.required&#x27;</span> =&gt; <span class="string">&#x27;角色为必填项&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;roleIds.array&#x27;</span> =&gt; <span class="string">&#x27;角色必须是数组类型&#x27;</span>,</span><br><span class="line">    ];</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">valid</span>(<span class="variable">$rules</span>, <span class="variable">$messages</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断角色数组是不是在数据库都存在</span></span><br><span class="line">    <span class="variable">$roleNum</span> = <span class="title class_">RoleModel</span>::<span class="title function_ invoke__">whereIn</span>(<span class="string">&#x27;id&#x27;</span>, <span class="variable language_">$this</span>-&gt;request-&gt;roleIds)-&gt;<span class="title function_ invoke__">count</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$roleNum</span> != <span class="title function_ invoke__">count</span>(<span class="variable language_">$this</span>-&gt;request-&gt;roleIds)) &#123;</span><br><span class="line">        <span class="comment">//角色id不对</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CommonException</span>(<span class="title class_">ErrorModel</span>::ROLE_NOT_FOUND);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在创建之前调用，用来验证参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">updateBefore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//检测页码和每页数量</span></span><br><span class="line">    <span class="variable">$rules</span> = [</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;required&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;email&#x27;</span> =&gt; <span class="string">&#x27;required|email&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;roleIds&#x27;</span> =&gt; <span class="string">&#x27;required|array&#x27;</span>,</span><br><span class="line">    ];</span><br><span class="line">    <span class="variable">$messages</span> = [</span><br><span class="line">        <span class="string">&#x27;name.required&#x27;</span> =&gt; <span class="string">&#x27;用户名为必填项&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;email.required&#x27;</span> =&gt; <span class="string">&#x27;邮箱为必填项&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;email.email&#x27;</span> =&gt; <span class="string">&#x27;请输入正确的邮箱格式&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;roleIds.required&#x27;</span> =&gt; <span class="string">&#x27;角色为必填项&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;roleIds.array&#x27;</span> =&gt; <span class="string">&#x27;角色必须是数组类型&#x27;</span>,</span><br><span class="line">    ];</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">valid</span>(<span class="variable">$rules</span>, <span class="variable">$messages</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断角色数组是不是在数据库都存在</span></span><br><span class="line">    <span class="variable">$roleNum</span> = <span class="title class_">RoleModel</span>::<span class="title function_ invoke__">whereIn</span>(<span class="string">&#x27;id&#x27;</span>, <span class="variable language_">$this</span>-&gt;request-&gt;roleIds)-&gt;<span class="title function_ invoke__">count</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$roleNum</span> != <span class="title function_ invoke__">count</span>(<span class="variable language_">$this</span>-&gt;request-&gt;roleIds)) &#123;</span><br><span class="line">        <span class="comment">//角色id不对</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CommonException</span>(<span class="title class_">ErrorModel</span>::ROLE_NOT_FOUND);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createBefore</code>方法在创建用户之前调用，<code>updateBefore</code>方法在更新之前调用，用来验证参数信息。验证角色在数据库中不存在后要返回错误，直接throw抛出异常即可，因为在外部已经用<code>try catch</code>捕获了，这里返回的是一个<code>error code</code>，在<code>Sys/ErrorModel</code>中定义一个错误信息。为了方便管理，所有的错误以常量的方式定义在errorModel里面。真正的错误信息在我们一开始创建的<code>sys_error</code>数据表中。我们在数据表中添加一条错误信息，<code>code</code>是100002的，<code>msg</code>是角色未定义！</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">ROLE_NOT_FOUND</span> = <span class="string">&#x27;100002&#x27;</span>; <span class="comment">//角色未定义！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以传一些错误的角色id给到接口中，使用postman来测试一下。因为这个用户已经创建了，所以返回了用户已经存在的错误信息。</p>
<p><img src="/../images/laravel-react05.png" alt="Image text"></p>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>我们使用同样的方式创建权限的<code>controller</code>和<code>model</code>。</p>
<blockquote>
<p>php artisan make:queryController Auth&#x2F;PermissionController -m Models&#x2F;Auth&#x2F;PermissionModel</p>
</blockquote>
<p>和上面一样，修改刚才的<code>Auth/PermissionModel</code>，在里面增加<code>table</code>属性。后面的就不再说这里了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">App</span>\<span class="title class_">Models</span>\<span class="title class_">Auth</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Eloquent</span>\<span class="title">Model</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PermissionModel</span> <span class="keyword">extends</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$table</span> = <span class="string">&#x27;auth_permissions&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>增加路由。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//后台查询权限列表</span></span><br><span class="line"><span class="title class_">Route</span>::<span class="title function_ invoke__">get</span>(<span class="string">&#x27;permissions&#x27;</span>, <span class="string">&#x27;PermissionController@queryList&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建权限</span></span><br><span class="line"><span class="title class_">Route</span>::<span class="title function_ invoke__">post</span>(<span class="string">&#x27;permission&#x27;</span>, <span class="string">&#x27;PermissionController@createInfo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新权限</span></span><br><span class="line"><span class="title class_">Route</span>::<span class="title function_ invoke__">put</span>(<span class="string">&#x27;permission/&#123;id&#125;&#x27;</span>, <span class="string">&#x27;PermissionController@updateInfo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除权限</span></span><br><span class="line"><span class="title class_">Route</span>::<span class="title function_ invoke__">delete</span>(<span class="string">&#x27;permission/&#123;id&#125;&#x27;</span>, <span class="string">&#x27;PermissionController@deleteInfo&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用postman测试。</p>
<p><img src="/../images/laravel-react06.png" alt="Image text"></p>
<p>现在呢，我们权限管理的后端接口就算做完了，当然了，后面还会根据需要调整。</p>
]]></content>
      <categories>
        <category>laravel+react实战打造企业级高并发分布式电商小程序</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>laravel</tag>
        <tag>javascript</tag>
        <tag>react</tag>
        <tag>高并发</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>带你解密laravel数据库动静态混合调用的秘密</title>
    <url>/%E5%B8%A6%E4%BD%A0%E8%A7%A3%E5%AF%86laravel%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8A%A8%E9%9D%99%E6%80%81%E6%B7%B7%E5%90%88%E8%B0%83%E7%94%A8%E7%9A%84%E7%A7%98%E5%AF%86.html</url>
    <content><![CDATA[<h1 id="laravel-orm"><a href="#laravel-orm" class="headerlink" title="laravel orm"></a>laravel orm</h1><p>laravel 使用 orm 调用数据库查询的时候很方便，我们只需要配置完数据库连接后创建model。</p>
<p>比如我们查询用户，我们首先要有一个<code>user model</code>。</p>
<p>可以使用 <code>artisan</code>创建</p>
<blockquote>
<p>php artisan make:model userModel</p>
</blockquote>
<p>如果我们需要查询一个用户信息，只需要这样</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">user<span class="title class_">Model</span>::<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id&#x27;</span>, <span class="number">1</span>)-&gt;<span class="title function_ invoke__">first</span>();</span><br><span class="line">(<span class="keyword">new</span> userModel)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id&#x27;</span>, <span class="number">1</span>)-&gt;<span class="title function_ invoke__">first</span>();</span><br></pre></td></tr></table></figure>

<p>上面的两种方法都可以实现查询用户id为1的用户信息。那他们有什么区别呢？第一种方法更为优雅。</p>
<p>那这个是怎么实现的呢，一般我们要么定义一个静态方法用来静态调用，要么定义一个对象方法需要使用对象调用。</p>
<p>其实很简单，他只是用到了<code>php</code>的<code>魔术方法</code>。</p>
<p>来看一下下面两个魔术方法：</p>
<ul>
<li>__call()</li>
<li>__callStatic()</li>
</ul>
<p>看一下php文档中的介绍</p>
<h3 id="call"><a href="#call" class="headerlink" title="__call()"></a>__call()</h3><p>在对象中调用一个不可访问方法时，__call() 会被调用。</p>
<blockquote>
<p>public __call ( string $name , array $arguments ) : mixed</p>
</blockquote>
<h3 id="callStatic"><a href="#callStatic" class="headerlink" title="__callStatic()"></a>__callStatic()</h3><p>在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用。</p>
<blockquote>
<p>public static __callStatic ( string $name , array $arguments ) : mixed</p>
</blockquote>
<p>$name 参数是要调用的方法名称。$arguments 参数是一个枚举数组，包含着要传递给方法 $name 的参数。</p>
<p>我们要让一个对象方法可以静态调用就要通过<code>__callStatic()</code>魔术方法了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">__callStatic</span>(<span class="params"> <span class="keyword">string</span> <span class="variable">$name</span> , <span class="keyword">array</span> <span class="variable">$arguments</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> <span class="built_in">static</span>)-&gt;<span class="variable">$name</span>(...<span class="variable">$arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样的话当我们调用<code>userModel::where()</code>的时候实际上它内部会创建一个对象然后再对象调用<code>where</code>。</p>
<p>但是这样会产生一个问题，如果当我们调用的方法不存在的时候怎么办呢。</p>
<p>可以通过<code>try catch</code>来捕获错误进行错误处理。laravel内部就是这么实现的。在laravel的model文件下，是这么运用<code>__call()</code>的。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Handle dynamic method calls into the model.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  string  $method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  array  $parameters</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$method</span>, <span class="variable">$parameters</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">in_array</span>(<span class="variable">$method</span>, [<span class="string">&#x27;increment&#x27;</span>, <span class="string">&#x27;decrement&#x27;</span>])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="variable">$method</span>(...<span class="variable">$parameters</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">forwardCallTo</span>(<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">newQuery</span>(), <span class="variable">$method</span>, <span class="variable">$parameters</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>他里面调用了<code>forwardCallTo</code>方法，我们来看一下这个方法。</p>
<p>这个方法存在<code>ForwardsCalls</code>这个<code>trait</code>中。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Forward a method call to the given object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  mixed  $object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  string  $method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  array  $parameters</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> \BadMethodCallException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">forwardCallTo</span>(<span class="params"><span class="variable">$object</span>, <span class="variable">$method</span>, <span class="variable">$parameters</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$object</span>-&gt;&#123;<span class="variable">$method</span>&#125;(...<span class="variable">$parameters</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="built_in">Error</span> | <span class="built_in">BadMethodCallException</span> <span class="variable">$e</span>) &#123;</span><br><span class="line">            <span class="variable">$pattern</span> = <span class="string">&#x27;~^Call to undefined method (?P&lt;class&gt;[^:]+)::(?P&lt;method&gt;[^\(]+)\(\)$~&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="title function_ invoke__">preg_match</span>(<span class="variable">$pattern</span>, <span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>(), <span class="variable">$matches</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="variable">$e</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$matches</span>[<span class="string">&#x27;class&#x27;</span>] != <span class="title function_ invoke__">get_class</span>(<span class="variable">$object</span>) ||</span><br><span class="line">                <span class="variable">$matches</span>[<span class="string">&#x27;method&#x27;</span>] != <span class="variable">$method</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="variable">$e</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">static</span>::<span class="title function_ invoke__">throwBadMethodCallException</span>(<span class="variable">$method</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>他在调用的时候通过try catch来捕获错误。</p>
<p>还有另外一种方法同样可以判断这个类有没有这个方法，那就是先通过<code>get_class_methods($className)</code>这个函数获取到类的所有方法，然后我们就可以自己判断了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$method</span>, <span class="variable">$parameters</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$classFuns</span> = <span class="title function_ invoke__">get_class_methods</span>(<span class="variable language_">$this</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">in_array</span>(<span class="variable">$method</span>, <span class="variable">$classFuns</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;没有这个方法&quot;</span>; <span class="comment">//返回错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="variable">$method</span>(...<span class="variable">$parameters</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样也不失为一种方法啊，大家还有其他好方法的话欢迎交流。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title>laravel神器教你一秒搞定增删改查业务模块</title>
    <url>/laravel%E7%A5%9E%E5%99%A8%E6%95%99%E4%BD%A0%E4%B8%80%E7%A7%92%E6%90%9E%E5%AE%9A%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E4%B8%9A%E5%8A%A1%E6%A8%A1%E5%9D%97.html</url>
    <content><![CDATA[<h1 id="laravel神器教你一秒搞定增删改查业务模块"><a href="#laravel神器教你一秒搞定增删改查业务模块" class="headerlink" title="laravel神器教你一秒搞定增删改查业务模块"></a>laravel神器教你一秒搞定增删改查业务模块</h1><p>还在为了不断写增删改查而烦恼不堪嘛？还在为了重复写代码而头疼嘛？这个laravel神器拯救你的大脑，解放你的双手。让你有更多的时间去写出更好的代码。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先使用composer安装</p>
<blockquote>
<p>composer require thepatter&#x2F;query-common</p>
</blockquote>
<p>安装之后创建一个command</p>
<blockquote>
<p>php artisan make:command MakeQueryCommand</p>
</blockquote>
<span id="more"></span>

<p>把下面的内容复制粘贴进去</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">App</span>\<span class="title class_">Console</span>\<span class="title class_">Commands</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Str</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">InvalidArgumentException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Console</span>\<span class="title">GeneratorCommand</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Symfony</span>\<span class="title">Component</span>\<span class="title">Console</span>\<span class="title">Input</span>\<span class="title">InputOption</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MakeQueryCommand</span> <span class="keyword">extends</span> <span class="title">GeneratorCommand</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The console command name.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$name</span> = <span class="string">&#x27;make:queryController&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The console command description.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$description</span> = <span class="string">&#x27;Create a new queryController class&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The type of class being generated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$type</span> = <span class="string">&#x27;QueryController&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the stub file for the generator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getStub</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">resource_path</span>(<span class="string">&#x27;stubs/queryController.stub&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the default namespace for the class.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  string  $rootNamespace</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getDefaultNamespace</span>(<span class="params"><span class="variable">$rootNamespace</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$rootNamespace</span>.<span class="string">&#x27;\Http\Controllers&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Build the class with the given name.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Remove the base controller import if we are already in base namespace.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  string  $name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">buildClass</span>(<span class="params"><span class="variable">$name</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$controllerNamespace</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getNamespace</span>(<span class="variable">$name</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$replace</span> = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">option</span>(<span class="string">&#x27;model&#x27;</span>)) &#123;</span><br><span class="line">            <span class="variable">$replace</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">buildModelReplacements</span>(<span class="variable">$replace</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$replace</span>[<span class="string">&quot;use <span class="subst">&#123;$controllerNamespace&#125;</span>\Controller;\n&quot;</span>] = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">str_replace</span>(</span><br><span class="line">            <span class="title function_ invoke__">array_keys</span>(<span class="variable">$replace</span>), <span class="title function_ invoke__">array_values</span>(<span class="variable">$replace</span>), <span class="built_in">parent</span>::<span class="title function_ invoke__">buildClass</span>(<span class="variable">$name</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Build the model replacement values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  array  $replace</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">buildModelReplacements</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$replace</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$modelClass</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">parseModel</span>(<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">option</span>(<span class="string">&#x27;model&#x27;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (! <span class="title function_ invoke__">class_exists</span>(<span class="variable">$modelClass</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">confirm</span>(<span class="string">&quot;A <span class="subst">&#123;$modelClass&#125;</span> model does not exist. Do you want to generate it?&quot;</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">call</span>(<span class="string">&#x27;make:model&#x27;</span>, [<span class="string">&#x27;name&#x27;</span> =&gt; <span class="variable">$modelClass</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">array_merge</span>(<span class="variable">$replace</span>, [</span><br><span class="line">            <span class="string">&#x27;DummyFullModelClass&#x27;</span> =&gt; <span class="variable">$modelClass</span>,</span><br><span class="line">        ]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the fully-qualified model class name.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  string  $model</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">parseModel</span>(<span class="params"><span class="variable">$model</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// if (preg_match(&#x27;([^A-Za-z0-9_/\\\\])&#x27;, $model)) &#123;</span></span><br><span class="line">        <span class="comment">//     throw new InvalidArgumentException(&#x27;Model name contains invalid characters.&#x27;);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="variable">$model</span> = <span class="title function_ invoke__">trim</span>(<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;\\&#x27;</span>, <span class="variable">$model</span>), <span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (! <span class="title class_">Str</span>::<span class="title function_ invoke__">startsWith</span>(<span class="variable">$model</span>, <span class="variable">$rootNamespace</span> = <span class="variable language_">$this</span>-&gt;laravel-&gt;<span class="title function_ invoke__">getNamespace</span>())) &#123;</span><br><span class="line">            <span class="variable">$model</span> = <span class="variable">$rootNamespace</span>.<span class="variable">$model</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$model</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the console command options.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getOptions</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            [<span class="string">&#x27;model&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="title class_">InputOption</span>::VALUE_OPTIONAL, <span class="string">&#x27;Generate a query controller for the given model.&#x27;</span>],</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在resources文件夹下创建stubs文件夹，在stubs文件夹下面创建QueryController.stub文件，把下面内容复制粘贴进去</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">DummyNamespace</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">DummyRootNamespaceHttp</span>\<span class="title">Controllers</span>\<span class="title">QueryList</span>\<span class="title">QueryController</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Exceptions</span>\<span class="title">CommonException</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DummyClass</span> <span class="keyword">extends</span> <span class="title">QueryController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字典数组</span></span><br><span class="line"><span class="comment">     * [&#x27;表里的字段名&#x27; =&gt; &#x27;字典code&#x27;,...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$dicArr</span> = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字段映射 可选，不填默认转成下划线格式</span></span><br><span class="line"><span class="comment">     * [&#x27;搜索字段&#x27; =&gt; &#x27;表字段&#x27;,...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$filedsAdapter</span> = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建时候的字段映射 可选，不填默认转成下划线格式</span></span><br><span class="line"><span class="comment">     * [&#x27;输入字段&#x27; =&gt; &#x27;表字段&#x27;]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$createAdapter</span> = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义表名 格式: table as t</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$shortTableName</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getModel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="string">&quot;DummyFullModelClass&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 查询列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@route</span> get.api/lists</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getList</span>(<span class="params">Request <span class="variable">$request</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//检查页码，搜索条件等</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">pageValid</span>();</span><br><span class="line">            <span class="comment">//返回数据</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">success</span>(<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">pageList</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="built_in">Exception</span> <span class="variable">$ex</span>) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@route</span> post.api/info</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createInfo</span>(<span class="params">Request <span class="variable">$request</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">create</span>(<span class="variable">$request</span>-&gt;<span class="title function_ invoke__">all</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">success</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(<span class="built_in">Exception</span> <span class="variable">$ex</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@route</span> put.api/info/&#123;id&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">updateInfo</span>(<span class="params">Request <span class="variable">$request</span>, <span class="variable">$id</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//查询记录</span></span><br><span class="line">            <span class="variable">$detail</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getModel</span>()-&gt;<span class="title function_ invoke__">find</span>(<span class="variable">$id</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$detail</span>)) &#123;</span><br><span class="line">                <span class="comment">//补充错误信息</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CommonException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">update</span>(<span class="variable">$id</span>,<span class="variable">$request</span>-&gt;<span class="title function_ invoke__">all</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">success</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(<span class="built_in">Exception</span> <span class="variable">$ex</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询一条记录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@route</span> get.api/info</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">detail</span>(<span class="params">Request <span class="variable">$request</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="variable">$rules</span> = [</span><br><span class="line">                <span class="string">&#x27;id&#x27;</span>=&gt;<span class="string">&#x27;required&#x27;</span>,</span><br><span class="line">            ];</span><br><span class="line">            <span class="variable">$messages</span> = [</span><br><span class="line">                <span class="string">&#x27;id.required&#x27;</span>=&gt;<span class="string">&#x27;id为必填项&#x27;</span>,</span><br><span class="line">            ];</span><br><span class="line">            <span class="comment">//验证</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">valid</span>(<span class="variable">$request</span>, <span class="variable">$rule</span>, <span class="variable">$messages</span>);</span><br><span class="line">            <span class="comment">//查询记录</span></span><br><span class="line">            <span class="variable">$detail</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getModel</span>()-&gt;<span class="title function_ invoke__">find</span>(<span class="variable">$id</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$detail</span>)) &#123;</span><br><span class="line">                <span class="comment">//补充错误信息</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CommonException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">success</span>(<span class="variable">$detail</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(<span class="built_in">Exception</span> <span class="variable">$ex</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除一条记录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@route</span> delete.api/info/&#123;id&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">deleteInfo</span>(<span class="params">Request <span class="variable">$request</span>, <span class="variable">$id</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//查询记录</span></span><br><span class="line">            <span class="variable">$model</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getModel</span>();</span><br><span class="line">            <span class="variable">$detail</span> = <span class="variable">$model</span>-&gt;<span class="title function_ invoke__">find</span>(<span class="variable">$id</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$detail</span>)) &#123;</span><br><span class="line">                <span class="comment">//补充错误信息</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CommonException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行删除</span></span><br><span class="line">            <span class="variable">$res</span> = <span class="variable">$model</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id&#x27;</span>, <span class="variable">$id</span>)-&gt;<span class="title function_ invoke__">delete</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">success</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(<span class="built_in">Exception</span> <span class="variable">$ex</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建业务逻辑"><a href="#创建业务逻辑" class="headerlink" title="创建业务逻辑"></a>创建业务逻辑</h2><p>这时候执行创建的<code>artisan</code>命令就可以了</p>
<blockquote>
<p>php artisan make:queryController your controller path -m your model path</p>
</blockquote>
<p>这时候在你的Controller下面就会多出一个Controller文件，你只需要在路由中添加路由就可以了。</p>
<p>这个库的github地址在下面，感兴趣的朋友可以看一下。</p>
<blockquote>
<p><a href="https://github.com/Thepatterraining/queryCommon">https://github.com/Thepatterraining/queryCommon</a></p>
</blockquote>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title>laravel路由自动加载</title>
    <url>/laravel%E8%B7%AF%E7%94%B1%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD.html</url>
    <content><![CDATA[<h1 id="laravel路由自动加载"><a href="#laravel路由自动加载" class="headerlink" title="laravel路由自动加载"></a>laravel路由自动加载</h1><p>laravel 自带的路由文件有四个</p>
<ul>
<li>api.php 文件存放 api 路由，会自动加载api前缀和一些中间件。</li>
<li>channels.php 文件用于注册应用支持的所有事件广播频道。</li>
<li>console.php 文件用于定义所有基于闭包的控制台命令，每个闭包都被绑定到一个控制台命令并且允许与命令行 IO 方法进行交互，尽管这个文件并不定义 HTTP 路由，但是它定义了基于控制台的应用入口（路由）。</li>
<li>web.php 如果应用无需提供无状态的、RESTful 风格的 API，那么路由基本上都要定义在 web.php 文件中。会自动加载web中间件。</li>
</ul>
<p>我们常用的无非是api和web路由，一开始我们可以都写在里面，那当程序不断扩大，路由达到几千个，几万个甚至更多，放在一个文件里显示难以维护，难以查找。</p>
<p>这时候我们需要把路由分到不同的路由文件中去，我们在routes目录下创建api文件夹，来存放相关的api路由。</p>
<span id="more"></span>

<p>这时候我们自己创建的路由文件是不被框架认可的，不被加载的。那我们怎么做呢，最简单的方法是加载到api.php路由文件内。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Route</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span> <span class="title function_ invoke__">base_path</span>(<span class="string">&#x27;routes/api/user.php&#x27;</span>);  <span class="comment">//加载api文件夹下的用户路由</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">|--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">| API Routes</span></span><br><span class="line"><span class="comment">|--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">|</span></span><br><span class="line"><span class="comment">| Here is where you can register API routes for your application. These</span></span><br><span class="line"><span class="comment">| routes are loaded by the RouteServiceProvider within a group which</span></span><br><span class="line"><span class="comment">| is assigned the &quot;api&quot; middleware group. Enjoy building your API!</span></span><br><span class="line"><span class="comment">|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Route</span>::<span class="title function_ invoke__">middleware</span>(<span class="string">&#x27;auth:api&#x27;</span>)-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;/user&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">Request <span class="variable">$request</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$request</span>-&gt;<span class="title function_ invoke__">user</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是这样的方式有着很大的缺点，难道我们每增加一个路由文件，都要修改这个api.php文件嘛？</p>
<p>我们还有更好的方式，在laravel中，服务提供者是一个很重要的模块，其实这里的所有路由都是通过<code>RouteServiceProvider.php</code>这个服务提供者来加载的。所以我们只需要更改这个服务提供者就可以了。</p>
<p>这里面有一个<code>mapApiRoutes</code>函数来加载api路由，我们可以写一个函数<code>requireRoutes</code>来加载我们自己创建的路由。然后在<code>mapApiRoutes</code>函数里面调用。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Define the &quot;api&quot; routes for the application.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * These routes are typically stateless.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">mapApiRoutes</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="title class_">Route</span>::<span class="title function_ invoke__">prefix</span>(<span class="string">&#x27;api&#x27;</span>)     <span class="comment">//前缀</span></span><br><span class="line">           -&gt;<span class="title function_ invoke__">middleware</span>(<span class="string">&#x27;api&#x27;</span>)  <span class="comment">//中间件</span></span><br><span class="line">           -&gt;<span class="title function_ invoke__">namespace</span>(<span class="variable language_">$this</span>-&gt;<span class="keyword">namespace</span>)  //命名空间</span><br><span class="line">           -&gt;<span class="title class_">group</span>(<span class="title class_">base_path</span>(&#x27;<span class="title class_">routes</span>/<span class="title class_">api</span>.<span class="title class_">php</span>&#x27;));</span><br><span class="line"></span><br><span class="line">       <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">requireRoutes</span>(<span class="string">&#x27;routes/Api&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 遍历文件夹</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">requireRoutes</span>(<span class="params"><span class="variable">$path</span></span>) </span>&#123;</span><br><span class="line">       <span class="variable">$dirs</span> = <span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">base_path</span>(<span class="variable">$path</span>));</span><br><span class="line">       <span class="keyword">foreach</span> (<span class="variable">$dirs</span> <span class="keyword">as</span> <span class="variable">$dir</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="title function_ invoke__">is_dir</span>(<span class="title function_ invoke__">base_path</span>(<span class="variable">$path</span>.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$dir</span>))) &#123;</span><br><span class="line">               <span class="keyword">if</span>(<span class="variable">$dir</span>==<span class="string">&#x27;.&#x27;</span> || <span class="variable">$dir</span>==<span class="string">&#x27;..&#x27;</span>)&#123;<span class="comment">//判断是否为系统隐藏的文件.和..  如果是则跳过否则就继续往下走，防止无限循环再这里。</span></span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">requireRoutes</span>(<span class="variable">$path</span>.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$dir</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//文件，加载进来</span></span><br><span class="line">               <span class="title class_">Route</span>::<span class="title function_ invoke__">prefix</span>(<span class="string">&#x27;api&#x27;</span>)</span><br><span class="line">               -&gt;<span class="title function_ invoke__">middleware</span>(<span class="string">&#x27;api&#x27;</span>)</span><br><span class="line">               -&gt;<span class="title function_ invoke__">middleware</span>(<span class="string">&#x27;jwtCheck&#x27;</span>)</span><br><span class="line">               -&gt;<span class="title function_ invoke__">namespace</span>(<span class="variable language_">$this</span>-&gt;<span class="keyword">namespace</span>)</span><br><span class="line">               -&gt;<span class="title class_">group</span>(<span class="title class_">base_path</span>($<span class="title class_">path</span>.&#x27;/&#x27;.$<span class="title class_">dir</span>));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title>基于docker快速搭建多平台laravel环境-laradock</title>
    <url>/%E5%9F%BA%E4%BA%8Edocker%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%A4%9A%E5%B9%B3%E5%8F%B0laravel%E7%8E%AF%E5%A2%83-laradock.html</url>
    <content><![CDATA[<h1 id="基于docker快速搭建多平台laravel环境-laradock"><a href="#基于docker快速搭建多平台laravel环境-laradock" class="headerlink" title="基于docker快速搭建多平台laravel环境-laradock"></a>基于docker快速搭建多平台laravel环境-laradock</h1><p>现在docker技术越来越火，docker的应用也越来越多。</p>
<p>我们为什么要用docker呢，因为它能提供你一个纯净的环境，能统一所有开发人员的环境，公司的技术有很多人，那每个人装的环境都可能不一样，你是php7.3，他是php7.0，你是mysql8.0，他是mysql5.6，这些环境上的差异有时候会导致代码的错误。</p>
<p>还有环境这东西装一次就够用了，你家里的电脑环境和公司的环境也有可能不一致。使用docker装环境之后，我们可以装完之后打包起来，在任何一个docker上运行这个配置文件都可以生成相同的环境。</p>
<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><blockquote>
<p> git clone <a href="https://github.com/Laradock/laradock.git">https://github.com/Laradock/laradock.git</a></p>
</blockquote>
<span id="more"></span>

<p>把这个库克隆下来以后，进入目录</p>
<blockquote>
<p>cd [your work]&#x2F;laradock</p>
</blockquote>
<p>复制env-example文件到.env文件</p>
<blockquote>
<p>cp env-example .env</p>
</blockquote>
<p>修改.env配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DB_HOST=mysql</span><br><span class="line">REDIS_HOST=redis</span><br></pre></td></tr></table></figure>

<p>在.env中配置工作目录,如果你的目录wwwroot和laradock目录同级则这样设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APP_CODE_PATH_HOST=../wwwroot</span><br></pre></td></tr></table></figure>

<p>配置nginx文件，打开 .&#x2F;nginx&#x2F;sites&#x2F;default.conf，修改下面两行</p>
<p><code>/var/www</code>目录相当于上面配置的..&#x2F;wwwroot目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server_name your server name;</span><br><span class="line">root /var/www/[your dir]/public;</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>启动docker 程序</p>
<blockquote>
<p>docker-compose up -d nginx redis mysql</p>
</blockquote>
<p>如果启动中报错</p>
<blockquote>
<p>ERROR: Service ‘mysql’ failed to build: Get <a href="https://registry-1.docker.io/v2/">https://registry-1.docker.io/v2/</a>: net&#x2F;http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)</p>
</blockquote>
<p>报这种错误，那么你需要一个docker镜像加速器了，可以使用daocloud的加速器。</p>
<blockquote>
<p><a href="https://www.daocloud.io/mirror#accelerator-doc">https://www.daocloud.io/mirror#accelerator-doc</a></p>
</blockquote>
<p>按照配置添加完以后再次运行命令就可以了</p>
<h2 id="env文件参数介绍"><a href="#env文件参数介绍" class="headerlink" title=".env文件参数介绍"></a>.env文件参数介绍</h2><p>PHP_VERSION&#x3D;7.3 这个参数是php的版本，默认php7.3</p>
<p>PHALCON_VERSION&#x3D;3.4.5 phalcon的版本</p>
<p>PHP_INTERPRETER&#x3D;php-fpm php解释器，默认php-fpm</p>
<p>nginx 配置</p>
<p>NGINX_HOST_HTTP_PORT&#x3D;80  &#x2F;&#x2F;nginx http 端口<br>NGINX_HOST_HTTPS_PORT&#x3D;443 &#x2F;&#x2F;nginx https 端口<br>NGINX_HOST_LOG_PATH&#x3D;.&#x2F;logs&#x2F;nginx&#x2F;  &#x2F;&#x2F;nginx 日志<br>NGINX_SITES_PATH&#x3D;.&#x2F;nginx&#x2F;sites&#x2F;   &#x2F;&#x2F;nginx 配置<br>NGINX_PHP_UPSTREAM_CONTAINER&#x3D;php-fpm &#x2F;&#x2F;nginx 使用php-fpm连接php<br>NGINX_PHP_UPSTREAM_PORT&#x3D;9000  &#x2F;&#x2F;php端口<br>NGINX_SSL_PATH&#x3D;.&#x2F;nginx&#x2F;ssl&#x2F; &#x2F;&#x2F;ssl</p>
<p>mysql配置</p>
<p>MYSQL_VERSION&#x3D;5.7    mysql版本 默认是8.0 建议修改成5.7<br>MYSQL_DATABASE&#x3D;default  数据库<br>MYSQL_USER&#x3D;default      用户名<br>MYSQL_PASSWORD&#x3D;secret   密码<br>MYSQL_PORT&#x3D;3306         mysql 端口<br>MYSQL_ROOT_PASSWORD&#x3D;root mysql root 密码<br>MYSQL_ENTRYPOINT_INITDB&#x3D;.&#x2F;mysql&#x2F;docker-entrypoint-initdb.d</p>
<p>REDIS_PORT&#x3D;6379 redis端口</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>laravel</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的队列使用技巧</title>
    <url>/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.html</url>
    <content><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><blockquote>
<p>队列是一种先进先出的数据结构</p>
</blockquote>
<p>我们的程序在什么情况下会用到队列呢？<code>异步处理</code>。</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>我们一般写的web程序都是同步执行的，比如前端发送一个登录请求，后端一步一步的处理，查询用户，判断密码等等，返回登陆成功或者错误信息，前端阻塞等到后端返回后进行下一步处理。</p>
<p>那么这种程序有一个什么问题呢，首先，前后端建立的http连接是有超时时间的，当后端处理请求时间过长会返回超时错误。</p>
<p>就算没有超时的限制，对于用户体验来讲，当你的程序响应很慢，那么用户就会觉得，这什么玩意，真垃圾！！！</p>
<h3 id="导出场景"><a href="#导出场景" class="headerlink" title="导出场景"></a>导出场景</h3><p>基于这些原因，我们可以需要快速的处理用户请求。像导出大文件的时候，没办法很快的给用户响应怎么办呢，我们可以用异步的方式处理，先给用户返回正在导出，或者导出成功。</p>
<p>这个时候我们后台程序真的导出了嘛？没有，我们可以将这个导出请求放入一个队列中，等待另外一个处理程序将队列中的数据取出进行处理，这个处理程序一直监听队列，如果发现队列有消息，就去取出来进行处理。在处理程序中可以根据数据类型的不同，把它送到具体的处理类中，比如导出数据，处理程序会分发给导出类进行处理，由导出类处理完成后，返回处理完成。</p>
<span id="more"></span>

<p>这时候我们可以有一个下载管理进行下载，或者发送站内信，邮件等方式将导出文件发给用户。</p>
<p>这个案例中，用户发起导出请求后，可以快速得到响应，而且这种方式还有一个作用，那就是<code>松耦合</code>，他将我们的具体处理程序分离开了，不在耦合到一起。</p>
<p>除了这个还有什么作用嘛，有，秒杀！</p>
<h3 id="秒杀场景"><a href="#秒杀场景" class="headerlink" title="秒杀场景"></a>秒杀场景</h3><p>我们经常能遇到10点秒杀，限量100件这种。那他是怎么实现的呢，要知道，当9点59的时候，很多用户就会不断刷新，等待10点开枪。</p>
<p>首先，不断刷新页面，就会有不断的请求过来，几千万的查询请求一瞬间涌入服务器，这个还好说，可以用缓存解决。那一到10点，他们全部都发出购买请求，但是这时候，我们只有100件卖出，100个人能买到，其他人都买不到。这时候我们也可以使用消息队列，先将购买请求放入消息队列，返回正在抢购，然后队列处理程序取出消息进行处理，取出一条就卖出相应的数量，进行库存的删减。我们在做这些操作的时候，为了防止超卖，最好是加上锁，只有拿到锁的程序才可以进行处理，后面的程序会阻塞直到锁被解开。这样的话数量上就会有保证了，但是这样会消耗性能。</p>
<p>这次消息队列使用其实相当于把瞬间的高并发流量挡住了，然后慢慢处理，缓解我们服务器的压力。</p>
<h3 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h3><p>其实很多时候都可以使用消息队列来解耦，异步处理。只要我们的主要流程不受影响就可以了。比如我之前的一个项目，在注册时候，如果填写了邀请码就会发放优惠券，这个步骤就是可以放到消息队列中处理的。还有比如群发通知这种，也可以放到消息队列来处理。</p>
<p>总结来说：</p>
<ul>
<li>解耦</li>
<li>异步处理</li>
<li>削峰填谷</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>消息队列虽然有这些好处，但是也存在问题，比如注册发放优惠券，但是优惠券没有发放成功怎么办，为什么出现这种问题呢，有可能是消息丢失，或者处理失败。</p>
<ul>
<li>消息放入消息队列的时候丢失</li>
<li>消息在消息队列中丢失</li>
<li>消息在处理的时候丢失</li>
</ul>
<h3 id="消息在放入消息队列的时候丢失"><a href="#消息在放入消息队列的时候丢失" class="headerlink" title="消息在放入消息队列的时候丢失"></a>消息在放入消息队列的时候丢失</h3><p>这种时候消息丢失一般是因为网络抖动，队列宕机才会发生。为了防止因为这些产生的消息丢失，可以发送没成功的时候重复发送几次，一般重试2-3次就可以了。</p>
<p>但是这样可能会导致消息处理端重复处理，为了解决这种情况，可以给每一个消息生产一个唯一id。</p>
<h3 id="消息在消息队列中丢失"><a href="#消息在消息队列中丢失" class="headerlink" title="消息在消息队列中丢失"></a>消息在消息队列中丢失</h3><p>消息存储在消息队列中的时候，不是立即写入磁盘的。为了减少磁盘io，会先将信息写入系统的Page Cache，当Page Cache中的数据达到一定量或者达到一定时间的时候会一起写入磁盘中进行持久化的存储，那再还没有写入磁盘，系统宕机导致系统的Page Cache丢失，那这时候这些数据就会丢失了。</p>
<p>解决方案：</p>
<p>可以布置队列的集群，这样就算一个宕机还有其他的存储着信息不会导致信息丢失。</p>
<p>Kafka集群中，由leader负责写入和消费，有多个follower负责数据的备份，有些follower被叫做ISR(in-sync replicas)。消息进入kafka会由leader先写入，然后异步的同步给其他follower，当leader挂掉之后，会从ISR中选取新的leader，由于leader是异步发送给follower的，那如果还没发送leader就挂掉了，消息还是会丢失。kafka中提供了’acks’这么一个选项，这个选项设置为’all’的话，会等到leader同步给所有follower之后才返回写入成功，这样会保证消息不丢失，但是会降低性能。</p>
<h3 id="消息在处理的时候丢失"><a href="#消息在处理的时候丢失" class="headerlink" title="消息在处理的时候丢失"></a>消息在处理的时候丢失</h3><p>这里除了消息丢失还有消息重复的问题，消息丢失可能是网络抖动或者处理程序错误引起的。</p>
<p>消息重复是因为消息重复放入了队列，前面也提到了，可以给每一个消息生产一个唯一id。我们收到消息之后先判断这个id是否被处理过，如果已经处理就丢弃这个消息。如果没有处理，则进行处理。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在使用队列的时候，我们需要监控队列的使用情况，比如队列中堆积了多少未处理信息，当堆积信息越来越多的时候我们就要思考为什么堆积了，是什么原因导致的。</p>
<p>除了看堆积信息，还可以发送特殊的监控信息到队列中，处理程序接受到监控信息的时候，对比它的进入时间，看看时间差是多少，如果超过了一定阈值，那么就需要注意了，我们的程序可能处理太慢了。</p>
<p>解决方案：</p>
<ul>
<li><p>横向扩展<br>横向扩展其实有点类似集群，我们可以部署多个处理程序，来加快处理进度</p>
</li>
<li><p>纵向扩展<br>纵向扩展就是提高我们处理程序的性能，优化他的代码，加快处理时间。</p>
</li>
</ul>
<p>还可以提高队列的存储介质，这样也可以加快队列的速度。</p>
<p>一个消息从队列取出的过程：</p>
<ul>
<li>读取存储到系统缓冲区</li>
<li>从系统缓冲区到用户缓冲区</li>
<li>从用户缓冲区到socket缓冲区</li>
<li>从socket缓冲区到网卡缓冲区</li>
</ul>
<p>我们如果能加快这四个步骤，也是可以加快队列的速度的。</p>
<p>比如操作系统提供的<code>sendfile</code>函数。</p>
]]></content>
      <categories>
        <category>队列</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>分布式</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.html</url>
    <content><![CDATA[<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>上一节提到了缓存穿透的问题，如果查询不存在的值怎么办，布隆过滤器可以完美解决这个问题。</p>
<p>当查询的时候，我们只需要确定这个值不存在，那我们就不用再查询了，也就减少了数据库，缓存的压力，减少了服务器压力，避免了一些攻击。</p>
<p><code>布隆过滤器</code>是个什么东西呢，它是由一串<code>二进制</code>组成的串，这个串中，只有<code>0</code>和<code>1</code>。</p>
<p>0代表不存在，1代表存在。</p>
<p>我们用hash算法计算之后，对布隆过滤器的长度进行取余操作，确定这个值应该存在布隆过滤器的哪个位置上。确定之后，将这个位置的值设置为<code>1</code>。</p>
<p>例如：</p>
<p>有一个长度为32的布隆过滤器</p>
<span id="more"></span>

<blockquote>
<p>00000 00000 00000 00000 00000 00000 00</p>
</blockquote>
<p>我们缓存了值<code>张三</code></p>
<blockquote>
<p>hash(张三) % 32 &#x3D; 2</p>
</blockquote>
<p><code>布隆过滤器</code>变成下面这样</p>
<blockquote>
<p>01000 00000 00000 00000 00000 00000 00</p>
</blockquote>
<p>我们又缓存了<code>李四</code></p>
<blockquote>
<p>hash(李四) % 32 &#x3D; 8</p>
</blockquote>
<p><code>布隆过滤器</code>变成下面这样</p>
<blockquote>
<p>01000 00100 00000 00000 00000 00000 00</p>
</blockquote>
<p>当我们查询<code>张三</code>的时候我们进行hash取余操作后是2，那我们就只要确定布隆过滤器的第二位是不是1就行了。</p>
<p>如果是<code>1</code>，代表了<code>张三</code>这个值有可能存在，为什么是有可能呢，因为我们不能保证hash冲突，也就是别的值经过hash取余操作后也是2。比如<code>王五</code>hash后也是2，那么我们查询王五的时候，不能确定是王五存在还是张三存在，但是我们能确定，他有存在的可能。</p>
<p>如果是<code>0</code>，代表了<code>张三</code>这个值一定不存在。</p>
<p>这样已经达到了我们的目的，我们就是想把不存在的筛出去。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>判断元素有误判的可能</li>
</ol>
<p>上面也说了，有hash冲突，那么怎么办呢？</p>
<p>我们可以经过多次hash，如果多次hash后取余的结果都是<code>1</code>，那么可能存在，这种方法可以减少hash冲突的概率。</p>
<p>不过只要我们的需求是要筛选掉<code>一定不存在</code>的，那么这个缺点就无所谓了。</p>
<ol start="2">
<li>不支持删除操作</li>
</ol>
<p>这个和上面的问题点类似，因为有误判的可能，如果删除，那么可能会影响到其他值。</p>
<p>解决方案：</p>
<p>我们可以存储计数器，不再使用二进制。</p>
<p>比如<code>张三</code>, <code>王五</code>都命中了2，那么布隆过滤器变成下面这样：</p>
<blockquote>
<p>02000 00100 00000 00000 00000 00000 00</p>
</blockquote>
<p>当我们删除的时候，计数器减1就好了</p>
<p>这样也存在问题，本身二进制存储很节省空间，但是存储数值类型的话，空间耗费就会增加了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用之前先思考一下使用场景，布隆过滤器适用于筛除<code>一定不存在</code>的元素。比如我们的缓存穿透。</p>
<p>布隆过滤器有误判的风险，可以使用多个hash来减少误判的概率。</p>
<p>布隆过滤器不支持删除操作，可以用耗费空间的方式使它支持。</p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的会用缓存吗</title>
    <url>/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8%E7%BC%93%E5%AD%98%E5%90%97.html</url>
    <content><![CDATA[<h1 id="缓存的使用"><a href="#缓存的使用" class="headerlink" title="缓存的使用"></a>缓存的使用</h1><p>当数据的读取量非常大的时候，为了缓解数据库的压力，会大量的使用到缓存。</p>
<p>那什么是缓存呢，我觉得是这样的</p>
<blockquote>
<p>两种存储介质a,b，只要a比b快，就可以用a来做b的缓存</p>
</blockquote>
<p>数据库一般都是存储在磁盘上面，但是磁盘的访问速度比较慢，当我们想快速获取到数据的时候，显然磁盘已经满足不了我们的需求了。</p>
<p>这时候我们一般会用到Redis, Memchached这种把数据存放在内存之中的NoSql数据库，用他们来缓存我们的数据，因为内存中的读取要比磁盘快的多。</p>
<p>那么缓存到底要怎么用呢？是只要把数据放到Redis里面，然后读取就可以了吗？</p>
<p>如果只是这么简单就好了，在缓存的时候我们要考虑几点东西。</p>
<p>缓存既然是在内存中，那么他们能存储的量就不大，那么哪些数据要放在缓存中呢？缓存的命中率应该达到多少呢？</p>
<p>在什么时候写入缓存呢？该怎么读取缓存呢？</p>
<p>怎么防止缓存穿透和缓存雪崩呢？</p>
<span id="more"></span>

<h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h2><h3 id="Cache-Aside-旁路缓存-策略"><a href="#Cache-Aside-旁路缓存-策略" class="headerlink" title="Cache Aside(旁路缓存)策略"></a>Cache Aside(旁路缓存)策略</h3><p>当我们有缓存的时候，我们就要考虑怎么写入缓存，更新缓存，删除缓存，查询缓存。</p>
<p>写入缓存一般是在创建数据的时候，比如这么一个场景，我之前的一个项目跟房产有关，房产数据在创建的时候写入缓存。</p>
<p>这时候，缓存中存在这么一条数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;id:1,name:1号房产,space:80,price:10000&#125; //80平米，每平米单价1万</span><br></pre></td></tr></table></figure>

<p>这时候这个房子的价格变动了，更新为每平米2万了，那么我们更新数据库，那这时候缓存要不要更新呢。</p>
<ul>
<li>更新缓存</li>
</ul>
<p>当并发线程的时候更新，两个线程同时更新就会导致脏数据的产生。</p>
<p>a要修改成2万，b要修改成3万，a先修改，b在修改，但是b的程序执行的快，b先修改了缓存中的数据，a才修改了缓存中的数据，那么这时候数据库是3万，缓存是2万。</p>
<p>解决方案，直接删除缓存，将缓存删除，查询的时候再回种到缓存中，保证缓存和数据库信息的一致性。</p>
<p>这就是<code>Cache Aside策略</code>。</p>
<p>当写入的时候：</p>
<ul>
<li>写入数据库信息</li>
<li>写入缓存信息</li>
</ul>
<p>当更新的时候：</p>
<ul>
<li>更新数据库信息</li>
<li>删除缓存信息</li>
</ul>
<p>当读取的时候：</p>
<ul>
<li>读取缓存</li>
<li>缓存存在直接返回数据</li>
<li>缓存不存在读取数据库</li>
<li>创建缓存，返回数据</li>
</ul>
<p>但是这个策略也存在问题，当更新很多数据的时候，会导致很多缓存失效，那么数据库的压力会增加。</p>
<p>解决方案：</p>
<ul>
<li>更新的时候更新缓存信息，但是增加锁机制，同一时间只有一个程序在更新缓存，但是对性能有影响。</li>
<li>更新的时候更新缓存信息，给缓存的过期时间设置的短一些，就算有脏数据也会尽快过期，会产生脏数据。</li>
</ul>
<h3 id="Read-x2F-Write-Through（读穿-x2F-写穿-策略）"><a href="#Read-x2F-Write-Through（读穿-x2F-写穿-策略）" class="headerlink" title="Read&#x2F;Write Through（读穿&#x2F;写穿 策略）"></a>Read&#x2F;Write Through（读穿&#x2F;写穿 策略）</h3><p>这个策略是你的程序只和缓存打交道，你只读写缓存，然后由缓存把数据同步给数据库。</p>
<p>写入的时候有两种做法：</p>
<ul>
<li>写入缓存 让缓存同步给数据库</li>
<li>写入数据库，当读取的时候回种缓存，这种速度快，因为没写入缓存</li>
</ul>
<p>更新的时候：</p>
<ul>
<li>更新缓存数据</li>
</ul>
<p>读取的时候：</p>
<ul>
<li>读取缓存</li>
<li>缓存存在直接返回数据</li>
<li>缓存不存在读取数据库</li>
<li>创建缓存，返回数据</li>
</ul>
<h3 id="Write-Back-回写策略"><a href="#Write-Back-回写策略" class="headerlink" title="Write Back (回写策略)"></a>Write Back (回写策略)</h3><p>这个策略是写入数据时候只写入缓存，然后将缓存标记为脏。当下次使用的时候把脏缓存的数据写入到数据库。</p>
<p>写入的时候：</p>
<ul>
<li>写入缓存</li>
<li>标记为脏</li>
</ul>
<p>更新的时候：</p>
<ul>
<li>判断缓存是否为脏</li>
<li>如果是脏，将缓存数据写入数据库，然后更新缓存</li>
<li>如果不是脏，直接更新缓存，并标记为脏</li>
</ul>
<p>读取的时候：</p>
<ul>
<li>读取缓存</li>
<li>缓存存在直接返回数据</li>
<li>缓存不存在，寻找一个可用的缓存块，判断缓存是否为脏</li>
<li>如果是脏，将缓存数据写入数据库，查询数据库信息，回写缓存</li>
<li>如果不是脏，查询数据库信息，回写缓存</li>
<li>返回数据</li>
</ul>
<p>这个策略读取的时候有一些改变，当缓存命中，没有改变。</p>
<p>缓存没有命中会寻找一个缓存块，查看是否是脏缓存，脏缓存意味着缓存信息有变动，需要同步到数据库，所以先同步到数据库在查询。如果不是脏缓存，意味着缓存已经同步到数据库，可以直接查询回写缓存。</p>
<p>上面几种策略其实都是写入更新时候有变动，只有最后一个策略在读取的时候稍微有改变。</p>
<p>一般情况下，使用前两种已经足够。</p>
<h2 id="缓存可用性"><a href="#缓存可用性" class="headerlink" title="缓存可用性"></a>缓存可用性</h2><p>如果这时候，缓存挂掉了，就会有大量请求穿透到数据库层，严重情况下，会导致整个系统挂掉。那么这种情况怎么办呢。</p>
<p>我们可以横向扩展缓存，分布式布置多个缓存节点，那么其中一个节点挂掉，我们还有其他的缓存节点可以使用。</p>
<h3 id="客户端方案"><a href="#客户端方案" class="headerlink" title="客户端方案"></a>客户端方案</h3><p>这里的客户端指的是使用缓存的客户端，也就是我们的服务器。</p>
<h4 id="写入的时候"><a href="#写入的时候" class="headerlink" title="写入的时候"></a>写入的时候</h4><p>当写入分布式缓存的时候，我们要怎么写入呢。</p>
<p>这个和分库分表差不多，都是横向扩展嘛，那我们写入也可以差不多啊，使用<code>hash取余算法</code>，来计算数据写入哪个节点。</p>
<p>但是这样存在一个问题，当我们的节点需要增加或者减少的时候怎么办，我们要重新取余，数据重新存储，这就难搞了啊。</p>
<p>解决方案：</p>
<ul>
<li>一致性哈希算法</li>
</ul>
<p>我们假设一个环，将所有节点<code>hash取余</code>之后放到环上，将要缓存的数据也<code>hash取余</code>之后放到环上，怎么确定数据存在哪个节点呢？将数据顺时针移动，遇到的第一个节点就是数据存储的节点。</p>
<p>这个算法增加或减少节点的时候会发生什么呢</p>
<ul>
<li>增加的时候，部分数据移动到新增节点</li>
<li>减少的时候，减少的节点的数据移动到另一个节点</li>
</ul>
<p>看上去好像没什么问题，但是如果环上的节点分布不均匀，某一个节点数据很多，当这个节点宕机后，他的数据转移到下一个节点，下一个节点压力骤增，如果节点扛不住，那么重复这些操作，会导致整个缓存系统的雪崩。</p>
<p>解决方案：</p>
<p>上面说了，是环上的节点分布不均匀导致的，那我们就让他分布均匀就好了。或者将一个节点放在环上多个位置，这样的话，这个节点挂掉，他的数据会移动到其他很多节点上，每个节点的压力就不会大增了。</p>
<h4 id="读取的时候"><a href="#读取的时候" class="headerlink" title="读取的时候"></a>读取的时候</h4><p>读取缓存的时候也可以像mysql学习，配置<code>主从读取</code>，先从从库读取，读取不到再从主库读取，这样就算从库挂掉，那么还有主库可以读取缓存，读流量不会直接到数据库层。</p>
<p>除了配置主从，还可以配置<code>多副本</code>，副本也就是缓存的缓存，我们在缓存层前面再加一层缓存层，如果这个副本读取不到再去读取主从，回写副本，这样副本中都是最热的缓存，基于成本的考虑，副本容量一般很小。</p>
<h3 id="中间层方案"><a href="#中间层方案" class="headerlink" title="中间层方案"></a>中间层方案</h3><p>客户端方案已经可以支撑分布式缓存，但是客户端方案存在一个问题，他受限于语言，如果将他单拿出来，那么所有的请求经过中间层，就不会受限于语言了</p>
<h3 id="服务端方案"><a href="#服务端方案" class="headerlink" title="服务端方案"></a>服务端方案</h3><p>redis sentinel是redis 2.4版本中增加的，这个东西可以在redis master节点挂掉之后，在从节点中选取新的主节点，不至于主节点挂掉整个程序挂掉。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>当缓存发生缓存穿透怎么办，前面已经说了一致性hash算法中会引起的缓存雪崩及解决方案，这里就来看看缓存穿透。</p>
<p>如果查询一条数据库不存在的数据，就肯定会引起缓存穿透，因为数据库都没有，缓存更没有了。</p>
<p>这种情况可以<code>回写空值</code>，这样虽然数据库没有，但是缓存有，请求就会被拦截在缓存层中。</p>
<p>但是空值会占用空间而且无意义，如果缓存中存在大量空值，将会占用大量空间。</p>
<p>除了<code>回写空值</code>，还可以使用布隆过滤器。</p>
<p>下一篇文章讲布隆过滤器。</p>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式必备发号器</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BF%85%E5%A4%87%E5%8F%91%E5%8F%B7%E5%99%A8.html</url>
    <content><![CDATA[<h1 id="发号器"><a href="#发号器" class="headerlink" title="发号器"></a>发号器</h1><p>生成唯一id的需求很多，我们经常会用到，不管是单库单表中的唯一，还是分布式的唯一。</p>
<h2 id="SnowFlake-算法"><a href="#SnowFlake-算法" class="headerlink" title="SnowFlake 算法"></a>SnowFlake 算法</h2><p>说一下SnowFlake算法，这个算法是一个生成唯一id的算法。</p>
<p>使用的是一个64位的二进制串，把这个串分成了几个部分。</p>
<ul>
<li>符号位 占一个位置 0 为正</li>
<li>时间戳位 占41个位置，使用毫秒级时间戳</li>
<li>机器位 占10个位置， 可以支持2的10次方-1个机器使用</li>
<li>序号位 占12个位置， 同一毫秒内可以生成2的12次方-1个id</li>
</ul>
<span id="more"></span>

<p>但是我们的业务很少用到这个级别的发号器，所以可以把时间改为秒级，下面是我改版后的SnowFlake算法组成：</p>
<ul>
<li>符号位 占一个位置 0 为正</li>
<li>时间戳位 占38个位置，使用秒级时间戳</li>
<li>机器位 占5个位置， 可以支持2的5次方-1个机器使用</li>
<li>业务位 占8个位置， 可以支持2的8次方-1个业务</li>
<li>序号位 占12个位置， 同一毫秒内可以生成2的12次方-1个id</li>
</ul>
<p>我这里面增加了业务位，因为这样可以把每个业务都分开，保证每个业务每个机器每秒内可以生成1024个id。</p>
<p>看一下我们php的实现代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnowFlake</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">FIRST</span> = <span class="number">0</span>; <span class="comment">//首位 符号位 表示正负0为正 1为负</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">TIME_LENGTH</span> = <span class="number">38</span>; <span class="comment">//时间戳位数 二进制的位数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">MACHINE_LENGTH</span> = <span class="number">5</span>; <span class="comment">//机器码位数 二进制的位数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">BUSINESS_LENGTH</span> = <span class="number">8</span>; <span class="comment">//业务位数 二进制的位数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">SEQUENCE_LENGTH</span> = <span class="number">12</span>; <span class="comment">//序列号位数 二进制的位数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$machineId</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上一次发号时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$oldTime</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$sequence</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//业务对应的业务id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$businessArr</span> = [</span><br><span class="line">        <span class="string">&#x27;order&#x27;</span> =&gt; <span class="number">1</span>,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$machineId</span> = <span class="number">1</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">strlen</span>(<span class="title function_ invoke__">decbin</span>(<span class="variable">$machineId</span>)) &gt; <span class="built_in">self</span>::<span class="variable constant_">MACHINE_LENGTH</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;机器id超长！&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;machineId = <span class="variable">$machineId</span>;</span><br><span class="line">        <span class="comment">//初始化时间戳</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;oldTime = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getTime</span>();</span><br><span class="line">        <span class="comment">//初始化序号</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;sequence = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成唯一id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $businessType 业务类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params"><span class="variable">$businessType</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$time</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getTime</span>();</span><br><span class="line">        <span class="comment">//比较时间戳</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$time</span> == <span class="variable language_">$this</span>-&gt;oldTime) &#123;</span><br><span class="line">            <span class="comment">//在同一毫秒内创建，序号递增</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">strlen</span>(<span class="title function_ invoke__">decbin</span>(<span class="variable language_">$this</span>-&gt;sequence)) &gt;= <span class="built_in">self</span>::<span class="variable constant_">SEQUENCE_LENGTH</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;到达最大发号个数&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++<span class="variable language_">$this</span>-&gt;sequence; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//到达下一个时间，重置序号</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;sequence = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="variable">$businessId</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getBusinessId</span>(<span class="variable">$businessType</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//字符位偏移量</span></span><br><span class="line">        <span class="variable">$firstShift</span> = <span class="built_in">self</span>::<span class="variable constant_">TIME_LENGTH</span> + <span class="built_in">self</span>::<span class="variable constant_">MACHINE_LENGTH</span> + <span class="built_in">self</span>::<span class="variable constant_">BUSINESS_LENGTH</span> + <span class="built_in">self</span>::<span class="variable constant_">SEQUENCE_LENGTH</span>;</span><br><span class="line">        <span class="comment">//时间戳偏移量</span></span><br><span class="line">        <span class="variable">$timeShift</span> = <span class="built_in">self</span>::<span class="variable constant_">MACHINE_LENGTH</span> + <span class="built_in">self</span>::<span class="variable constant_">BUSINESS_LENGTH</span> + <span class="built_in">self</span>::<span class="variable constant_">SEQUENCE_LENGTH</span>;</span><br><span class="line">        <span class="comment">//机器位偏移量</span></span><br><span class="line">        <span class="variable">$machineShift</span> = <span class="built_in">self</span>::<span class="variable constant_">BUSINESS_LENGTH</span> + <span class="built_in">self</span>::<span class="variable constant_">SEQUENCE_LENGTH</span>;</span><br><span class="line">        <span class="comment">//业务偏移量</span></span><br><span class="line">        <span class="variable">$businessShift</span> = <span class="built_in">self</span>::<span class="variable constant_">SEQUENCE_LENGTH</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$res</span> = <span class="built_in">self</span>::<span class="variable constant_">FIRST</span> &lt;&lt; <span class="variable">$firstShift</span> | <span class="variable">$time</span> &lt;&lt; <span class="variable">$timeShift</span> | <span class="variable language_">$this</span>-&gt;machineId &lt;&lt; <span class="variable">$machineShift</span> | <span class="variable">$businessId</span> &lt;&lt; <span class="variable">$businessShift</span> | <span class="variable language_">$this</span>-&gt;sequence;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入时间</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;oldTime = <span class="variable">$time</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$res</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取毫秒级时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">time</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取业务id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getBusinessId</span>(<span class="params"><span class="variable">$businessType</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;businessArr[<span class="variable">$businessType</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>最后一步是把每个部分归位，左移相应的偏移量，到达相应的位置，比如时间戳：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1011110100000010111110100010100 &lt;&lt; 25 = 10111101000000101111101000101000000000000000000000000000</span><br></pre></td></tr></table></figure>

<p>机器位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 &lt;&lt; 20 = 100000000000000000000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>业务位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 &lt;&lt; 12 = 1000000000000</span><br></pre></td></tr></table></figure>

<p>序号位不用左移</p>
<p>最后将这些进行<code>或操作</code>，二进制的<code>或操作</code>就是将每一位进行对比，如果都是0则返回0，有一个1就返回1，两个都是1也返回1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">时间戳或上机器位就是这个结果，这也相当于两个加在一起了</span><br><span class="line">10111101000000101111101000101000000000000000000000000000 | 100000000000000000000 = 10111101000000101111101000101000000100000000000000000000</span><br><span class="line"></span><br><span class="line">再或上业务位和符号位</span><br><span class="line"></span><br><span class="line">10111101000000101111101000101000000100000000000000000000 | 1000000000000 | 1 = 10111101000000101111101000101000000100000010000000000001</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后把每部分<code>或操作</code>之后就是我们要的最终结果，不管是左移操作还是或操作，实际上都是对变量里面的二进制进行的操作，操作之后会转换成我们看到的十进制消息，也就是<code>53202044035534850</code>。</p>
<p>在这里面还用到了<code>decbin()</code>这个函数，这个函数的作用就是将十进制转换成二进制。</p>
<p>我们使用这个发号器生成的唯一id隐含了我们的业务性，也保证了唯一性，如果你的业务很庞大，可以使用毫秒级时间戳或者扩大序号位，都可以根据实际使用情况调整。</p>
<p>下面是这个算法的github地址</p>
<blockquote>
<p><a href="https://github.com/Thepatterraining/design-pattern/tree/master/app/Http/Models/SnowFlake">https://github.com/Thepatterraining/design-pattern/tree/master/app/Http/Models/SnowFlake</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>高并发</tag>
        <tag>分布式</tag>
        <tag>SnowFlake</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql分库分表</title>
    <url>/mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.html</url>
    <content><![CDATA[<h3 id="mysql-分库分表"><a href="#mysql-分库分表" class="headerlink" title="mysql 分库分表"></a>mysql 分库分表</h3><p>上一篇文章我们介绍了mysql的主从读写分离，这里我们介绍分库分表的应用。</p>
<p>什么是分库分表呢，分就是拆分，也就是将一个数据表（库）拆分成多个。那有什么作用呢，可以分散流量，和主从类似，主从是将读写流量分开，方便扩展，这里是将表（库）分开方便扩展。同时流量分散，比如一张上亿数据的表，那么查询起来肯定很慢，但是要是水平拆分成多张表，每张表的数据量就会很小，查询速度就会变快。</p>
<p>分库分表一般分为两种，一种是水平拆分，一种是垂直拆分。</p>
<span id="more"></span>

<h4 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h4><p>垂直拆分，比如你现在所有的表都放在一个库中，那么这个库会很庞大，那我们可以按照业务来拆分成多个数据库，比如用户相关的用户库，交易相关的交易库等等。</p>
<p>这种拆分理念和微服务的理念差不多，微服务同样是按照业务来划分。</p>
<p>这样处理用户相关的只会访问用户库，不会对其他数据库造成压力，同样的，我们用户库有压力也方便单独扩展。</p>
<p>表的垂直拆分同样的道理，不过一般在表设计的时候就已经拆分好了，不应该出现一张表还能进行拆分的情况。</p>
<h4 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h4><p>水平拆分，比如你现在表数据量过大，一张表拥有上亿的数据量，这时候就要把一张表拆分成多张表。</p>
<p>怎么拆分呢，一般有两种方法，比如</p>
<h6 id="取余法"><a href="#取余法" class="headerlink" title="取余法"></a>取余法</h6><p>假设我们现在将一张千万级的表拆分成100个表，每张表的数据大概在十万量级。那我们怎么确定一条数据应该存在哪张表中呢，我们可以对数据的id进行取余操作，也就是 id % 100 &#x3D; 1那就存放在一号表中， 2就放在2号表，以此类推。也可以hash一下再取余，比如hash(id) % 100。</p>
<h6 id="分段法"><a href="#分段法" class="headerlink" title="分段法"></a>分段法</h6><p>也就是我们确定区间，比如前十万用户存在一号表，然后十万十万的类推，或者根据时间，每个月的用户一张表都可以。</p>
<h4 id="join问题"><a href="#join问题" class="headerlink" title="join问题"></a>join问题</h4><p>那现在有一个问题，比如查询用户的时候需要查询出用户的余额，以前我们是join的方式联查，那现在分成多个表之后就没法join了，我们只能先查询出用户信息，然后再查询出这个用户的余额</p>
<h4 id="条件查询问题"><a href="#条件查询问题" class="headerlink" title="条件查询问题"></a>条件查询问题</h4><p>经过分表之后，数据分布在不同的地方，我们如果是查询id是5的用户，很简单，5 % 100就可以知道在哪张表中了，但是我们要查询姓名是张三的用户怎么办呢。我们要去查询哪张表呢，这个时候我们就需要做一个映射了，比如有一张表存储id 和 姓名的映射，我们通过这张映射表查询到张三的id，在id % 100来确定查询哪张表。这张映射表同样要分表，那我们怎么确定张三在哪张映射表中呢，我们可以用hash(张三) % 100的方式确定在哪张映射表中。</p>
<h4 id="主键唯一问题"><a href="#主键唯一问题" class="headerlink" title="主键唯一问题"></a>主键唯一问题</h4><p>还有一个问题，原来我们在一张表中，主键只要做到表唯一，我们现在100张表，怎么保证这条记录的主键id在这100张表中都是唯一的呢。</p>
<p>有一种方法，我们生成唯一的uuid就可以了，但是这样有几个问题</p>
<ul>
<li>有序性</li>
</ul>
<p>一般来说，我们都会使用自增id，保持id有序并且单调递增，为什么呢，因为mysql的innoDb引擎使用B+树存储索引数据，而主键就是一种索引。</p>
<p>索引数据在B+树种有序存储，这样不管是写入还是查询的效率都会很高，而如果是无序的，那么写入和查询的效率就会降低。</p>
<p>因为有序的时候可以使用很多搜索算法提高查询效率。</p>
<ul>
<li>表达性</li>
</ul>
<p>uuid不具备任何表达性，没办法看到从种看到这个uuid是属于哪个业务的。</p>
<p>知道了问题所在，我们就可以解决了。</p>
<p>在一下篇文章中会介绍snowFlake算法来解决这个问题。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql主从读写分离</title>
    <url>/mysql%E4%B8%BB%E4%BB%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.html</url>
    <content><![CDATA[<h3 id="mysql主从读写分离"><a href="#mysql主从读写分离" class="headerlink" title="mysql主从读写分离"></a>mysql主从读写分离</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>mysql主从复制的常见使用场景，当我们的读写流量过大的情况下，尤其是读流量过大的情况下，mysql主从读写分离就很有必要了。</p>
<p>我们使用主库写入，读取从库来分离读写流量，而这时候读流量不断增加，那我们只需要扩展从库就可以了。</p>
<span id="more"></span>


<h4 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h4><p>数据库是怎么完成主从复制的呢，这里就要说到binlog了，这是存储数据库行为的二进制日志文件。从库会有一个io线程来读取这个binlog，读取之后写入一个叫做<code>relay log</code>的日志文件中，而主库也会创建一个log dump的线程来发送binlog给从库；同时，从库会创建一个sql线程将<code>relay log</code>中的内容写入从库。来实现主库数据到从库数据的一致性。</p>
<p>log dump线程是异步操作，也就是当你有数据写入主库的时候，不会等到数据同步到从库之后再返回写入成功，而是直接返回写入成功。</p>
<p>从库获取数据先写入<code>relay log</code>是因为直接写入从库可能很耗时，导致主从同步的延迟变长。</p>
<p>既然写入主库之后就返回成功，然后同步数据，那这时候就有可能发送主从数据不一致的问题，因为如果主库的数据还没有写入到binlog文件中的时候主库宕机了，那么就会导致binlog文件缺失，从而从库数据和主库数据不一致的问题，但是这种情况很少很少，<code>而基于性能来考虑，这种情况还在我们可接受范围之内</code>。</p>
<h4 id="主从读写分离的优缺点"><a href="#主从读写分离的优缺点" class="headerlink" title="主从读写分离的优缺点"></a>主从读写分离的优缺点</h4><p>主从读写分离固然可以让我们更好的应对大量的读写请求，但是读请求量非常大的情况下，并不是盲目的扩展从库就可以了，因为大量的从库会有大量的<code>io线程</code>来读取binlog，这样主库的压力就会变大。</p>
<p>还有主从数据库的同步肯定会有一些延迟，考虑以下情况，我之前的一个项目，用到了分红功能，后台审核之后会给用户发放分红，这是一个异步操作，我们会在审核之后把分红数据的id放到队列中，然后取出队列中的分红id到从库之中查询分红数据，那么这时候从库要是没有同步到数据，就会出现查到的数据状态不对或者数据不存在的问题。那么分红就进行不下去了。</p>
<p>怎么办呢，我们后来采用了直接将所有分红数据放到队列之中的方法，这样取出来就不用再次查询了，但是这样的弊端就是队列中的数据量会变大，但是这在我们的可接受范围之内。</p>
<p>除此之外还有其他的办法，比如将数据放到缓存之中，取出来id到缓存中查询，但是这样缓存也会很大。而且要保证缓存数据的一致性，那么像更新这种操作就会很危险，建议只有创建操作使用缓存。</p>
<p>还有一种方法是取出来查询的时候直接查询主库，但是这样主从读写分离就失去了意义。</p>
<p>总结一下三种方法：</p>
<ul>
<li>数据冗余到队列中，免去再次查询的步骤</li>
<li>数据放到缓存中，直接查询缓存保证一致性</li>
<li>直接查询主库，不查询从库</li>
</ul>
<p>这里我们分析了主从读写分离的执行过程和优缺点，今天就到这里啦</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的javascript</title>
    <url>/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript.html</url>
    <content><![CDATA[<h1 id="你不知道的-javascript"><a href="#你不知道的-javascript" class="headerlink" title="你不知道的 javascript"></a>你不知道的 javascript</h1><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域了解了 lhs 和 rhs 两种查找方式</p>
<ul>
<li>lhs, 赋值左侧查找，需要找到变量，然后进行赋值，如果没找到，在非严格模式下会创建变量，严格模式会抛出 ReferenceError 异常</li>
<li>rhs，非赋值左侧查找，在引用的时候使用这种查找，在作用域里面如果没有查到，会直接抛出 ReferenceError 异常，而如果你查到了，但是操作不合法，比如试图对一个非函数类型的值进行函数调用，或者引用 null 或 undefined 类型的值中的属性，那么会抛出 TypeError 异常</li>
</ul>
<p><code>ReferenceError</code>和作用域的判别失败有关，而<code>TypeError</code>则是代表作用域里面找到了，但是对结果的操作是非法或者不合理的</p>
<span id="more"></span>

<h3 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h3><p>动态作用域和词法作用域的区别，词法作用域是在写代码或者说定义时候确定的，而动态作用域是在运行时确定的。（this 也是），词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行</p>
<p>比如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<p>基于词法作用域的规则，函数 bar 可以访问外部的变量 a(这个例子中的 a 是一个 rhs 查询)</p>
<p>上面的代码从技术来讲，也许是闭包，但根据前面的定义，确切的说并不是。</p>
<p>下面的代码清晰的展示了闭包</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">baz</span>(); <span class="comment">//2           这就是闭包的效果</span></span><br></pre></td></tr></table></figure>

<p>函数 bar()的词法作用域能够访问 foo()的内部作用域。然后我们将 bar()函数本身当作一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数本身当作返回值</p>
<p>在 foo()执行后，其返回值（也就是内部的 bar()函数）赋值给变量 baz 并调用 baz()，实际上只是通过不同的标识符引用调用了内部的函数 bar()</p>
<p>bar()显然可以被正常执行，但是在这个例子中，他在自己定义的词法作用域以外的地方执行。</p>
<p>在 foo()执行后，通常会期待 foo()的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器来释放不再使用的内存空间。由于看上去 foo()的内容不会再被使用，所以很自然的会考虑对其进行回收。</p>
<p>拜 bar()所声明的位置所赐，它拥有涵盖 foo()内部作用域的闭包，使得该作用域能够一直存活，以供 bar()在之后任何时间进行引用</p>
<p>bar()依然持有对该作用域的引用，而这个引用就叫做闭包</p>
<pre><code>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。
</code></pre>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>首先是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则</p>
<p>思考一下下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<p>你应该注意到的，当我们调用 foo()时，this.a 被解析成了全局变量 a。为什么？因为在本例中，函数调用时应用了 this 的默认绑定，因此 this 指向全局对象。</p>
<p>在代码中，foo()是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则</p>
<p>如果使用严格模式，那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">//typeError: this is undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p>另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导</p>
<p>思考下面代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">foo</span>(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>这个代码里面，使用 obj.foo()来调用，调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象“拥有”或者“包含”它</p>
<p>无论你如何称呼这个模式，当 foo()被调用时，它的落脚点确实指向 obj 对象。当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调用 foo()时，this 被绑定到 obj，因此 this.a 和 obj.a 时一样的</p>
<p>对象属性引用链中只有最顶层或者说最后一层会影响调用位置。举例来说：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">obj2</span>: obj2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.<span class="property">obj2</span>.<span class="title function_">foo</span>(); <span class="comment">//42</span></span><br></pre></td></tr></table></figure>

<h6 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h6><p>一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式</p>
<p>思考下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = obj.<span class="property">foo</span>; <span class="comment">//函数别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;oops, global&quot;</span>; <span class="comment">//a是全局对象的属性</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">//oops global</span></span><br></pre></td></tr></table></figure>

<p>一种更微妙，更常见并且更出乎意料的情况发生在传入回调函数时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doFoo</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="comment">//fn其实引用的是foo</span></span><br><span class="line">  <span class="title function_">fn</span>(); <span class="comment">//调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;oops, global&quot;</span>; <span class="comment">//a是全局对象的属性</span></span><br><span class="line"><span class="title function_">doFoo</span>(obj.<span class="property">foo</span>); <span class="comment">//oops, global</span></span><br></pre></td></tr></table></figure>

<p>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样</p>
<p>如果把函数传入语言内置的函数而不是你自己声明的函数，会发生什么呢？结果是一样的，没有区别：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;oops, global&quot;</span>; <span class="comment">//a是全局对象的属性</span></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">foo</span>, <span class="number">100</span>); <span class="comment">//oops, global</span></span><br></pre></td></tr></table></figure>

<p>js 内置的 setTimeout 函数实现和下面的伪代码类似：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setTimeout</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="comment">//等待delay毫秒</span></span><br><span class="line">  <span class="title function_">fn</span>(); <span class="comment">//调用位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像我们看到的，回调函数丢失 this 绑定是非常常见的。无论哪种情况，this 的改变都是意想不到的，实际上你无法控制回调函数的执行方式，因此就没有办法控制会影响绑定的调用位置，之后我们会介绍如何通过固定 this 来修复这个问题</p>
<h4 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h4><p>js 中的“所有”函数都有一些有用的特性，可以用来显示绑定，比如 call 和 apply 方法。严格来说，js 的宿主环境有时会提供一些非常特殊的函数，它们并没有这两个方法。但是这样的函数非常罕见。</p>
<p>可惜，显示绑定仍然无法解决我们之前提出的丢失绑定问题</p>
<p>但是显示绑定的一个变种可以解决这个问题</p>
<h5 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h5><p>思考下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  foo.<span class="title function_">call</span>(obj);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">setTimeout</span>(bar, <span class="number">100</span>); <span class="comment">//2</span></span><br><span class="line"><span class="comment">//硬绑定的bar不可能再修改它的this</span></span><br><span class="line">bar.<span class="title function_">call</span>(<span class="variable language_">window</span>); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>由于硬绑定是一种非常常用的模式，所以在 es5 中内置了 Function.prototype.bind 方法，bind 返回一个硬编码的新韩淑，他会把参数设置 this 的上下文并调用原始函数</p>
<h4 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h4><p>这是最后一条 this 的绑定规则，在讲解它之前我们首先需要澄清一个非常常见的关于 js 中函数和对象的误解</p>
<p>在传统的面向类的语言中，“构造函数”是类中的一些特殊方法，使用 new 初始化类时会调用类中的构造函数。通常的形式是这样的：</p>
<pre><code>something = new MyClass()
</code></pre>
<p>js 也有一个 new 操作符，使用方法看起来一样，然而，js 中 new 的机制实际上和面向类的语言完全不同</p>
<p>js 中的构造函数只是一些使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，他们甚至都不能说时一种特殊的构造函数，他们只是被 new 的普通函数而已。</p>
<p>这里有一个重要但是非常细微的区别：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”</p>
<p>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作</p>
<ol>
<li>创建一个全新的对象</li>
<li>这个新对象会被执行【【原型】】连接</li>
<li>这个新对象会绑定到函数调用的 this</li>
<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象</li>
</ol>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>这些规则如果同时出现，就需要一个优先级类进行判断是用的哪一条规则</p>
<p>毫无疑问，默认绑定的优先级是最低的，所以我们可以先不考虑它</p>
<p>隐式和显示哪个优先级更高呢，我们来测试一下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.<span class="title function_">foo</span>(); <span class="comment">//2</span></span><br><span class="line">obj2.<span class="title function_">foo</span>(); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">obj1.<span class="property">foo</span>.<span class="title function_">call</span>(obj2); <span class="comment">//3</span></span><br><span class="line">obj2.<span class="property">foo</span>.<span class="title function_">call</span>(obj1); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>可以看到，显示的优先级更高，也就是说在判断时应当先考虑是否可以应用显示绑定</p>
<p>现在我们需要搞清楚 new 绑定和隐式绑定的优先级</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj1.<span class="title function_">foo</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">obj1.<span class="property">foo</span>.<span class="title function_">call</span>(obj2, <span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">a</span>); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> obj1.<span class="title function_">foo</span>(<span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>); <span class="comment">//2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">a</span>); <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<p>可以看到 new 绑定比隐式绑定优先级高。但是 new 绑定和显示绑定谁的优先级更高呢</p>
<p>我们可以用硬绑定来试一下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(obj1);</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> <span class="title function_">bar</span>(<span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>); <span class="comment">//2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz.<span class="property">a</span>); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>判断 this</p>
<ol>
<li>如果用 new，那么 this 绑定的是新创建的对象</li>
<li>如果通过 call,apply 或者 bind，this 绑定的是指定的对象</li>
<li>函数是否在某个上下文对象中调用，如果是的话，绑定的是上下文对象，比如 obj.foo()</li>
<li>如果都不是，那么默认绑定到全局对象，如果严格模式，就绑定到 undefined</li>
</ol>
<h3 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h3><p>规则总有例外，这里也一样</p>
<p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call,apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo.<span class="title function_">call</span>(<span class="literal">null</span>); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决定 this</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//this 继承自foo()</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">call</span>(obj1);</span><br><span class="line"></span><br><span class="line">bar.<span class="title function_">call</span>(obj2); <span class="comment">//2 不是 3</span></span><br></pre></td></tr></table></figure>

<p>foo 内部的箭头函数会捕获调用时 foo 的 this，由于 foo 的 this 绑定到 obj1,bar 的 this 也会绑定到 obj1，箭头函数的绑定无法被修改</p>
<p>箭头函数最常用于回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//这里的this继承自foo</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">call</span>(obj); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>箭头函数的重要性体现在它用更常见的词法作用域取代了传统的 this 机制。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>js 一开始就没有设计成面向类的语言，所以也没有<code>class</code>, <code>extends</code>这种继承机制，但是<code>class</code>是一个一切皆对象的语言。<br>class 需要<code>new</code>来实例化一个对象，而<code>new</code>的过程中会执行构造函数，所以 js 的<code>new</code>操作符，就是直接把<code>普通函数</code>当成<code>构造函数</code>执行，用这样的方式来实现实例化，那么怎么实现<code>继承</code>机制呢，就引入了<code>prototype</code>，prototype 指向一个新的对象，这个对象里面存放了可以<code>共享</code>的属性。我们一般把 prototype 指向的这个属性叫做<code>原型对象</code>。</p>
<p>看下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，obj 有一个<strong>proto</strong>属性指向 Foo.prototype 这个对象，这就是原型链，<strong>proto</strong>这个属性可以一直往上查找，直到原型链的顶层 Object.prototype 这里，这也就是在 js 里面可以用 map,foreach 这些方法的原因，他们本身是没有这些方法的，所以 js 会通过原型链进行查找，直到找到这个方法进行调用，如果没有找到，则会抛出 TypeError 异常，比如在上面的 obj 对象中调用 obj.log 方法，就会报错了。</p>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>在 es6 中，引入了 class 语法，让 js 用起来像其他的面向对象一样，但其实不一样的，class 只是一个语法糖，他本身还是使用的 prototype 来实现的。</p>
<h3 id="对象委托"><a href="#对象委托" class="headerlink" title="对象委托"></a>对象委托</h3><p>js 里面完全可以使用一种对象委托的方式来实现继承，而不是类的形式，比如用类来完成一件事的话大概像下面一样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">msg</span> = msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">identify</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`I am <span class="subst">$&#123;<span class="variable language_">this</span>.msg&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Bar</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">  <span class="title class_">Foo</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Bar</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Bar</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">speak</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.identify()&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> <span class="title class_">Bar</span>(<span class="string">&quot;b1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="keyword">new</span> <span class="title class_">Bar</span>(<span class="string">&quot;b2&quot;</span>);</span><br><span class="line"></span><br><span class="line">b1.<span class="title function_">speak</span>();</span><br><span class="line">b2.<span class="title function_">speak</span>();</span><br></pre></td></tr></table></figure>

<p>子类 Bar 继承了父类 Foo，然后生成了 b1,b2 两个实例</p>
<p>下面我们看看使用对象委托的方式来写同样的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="title function_">init</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">msg</span> = msg;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`I am <span class="subst">$&#123;<span class="variable language_">this</span>.msg&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Bar</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Foo</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Bar</span>.<span class="property">speak</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.identify()&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Bar</span>);</span><br><span class="line">b1.<span class="title function_">init</span>(<span class="string">&quot;b1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Bar</span>);</span><br><span class="line">b2.<span class="title function_">init</span>(<span class="string">&quot;b2&quot;</span>);</span><br><span class="line"></span><br><span class="line">b1.<span class="title function_">speak</span>();</span><br><span class="line">b2.<span class="title function_">speak</span>();</span><br></pre></td></tr></table></figure>

<p>这段代码看起来是不是简洁了呢，我们只是把对象关联了起来，而不用再去模仿类的行为。</p>
<p>当然了，es6 引入的 class 语法也会让你觉得简洁</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">msg</span> = msg;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`I am <span class="subst">$&#123;<span class="variable language_">this</span>.msg&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;I am&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.identify()&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> <span class="title class_">Bar</span>(<span class="string">&quot;b1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="keyword">new</span> <span class="title class_">Bar</span>(<span class="string">&quot;b2&quot;</span>);</span><br><span class="line"></span><br><span class="line">b1.<span class="title function_">speak</span>();</span><br><span class="line">b2.<span class="title function_">speak</span>();</span><br></pre></td></tr></table></figure>

<p>但是 class 只是把内部实现隐藏了起来，他的本质依旧是我们上面写的那样，依旧是使用的 prototype。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我觉得 class 和对象委托这两种设计模式，他们的本质都是使用 prototype，只不过一种是在模仿类，而一种则是不用模仿类，我遇到这个请求的时候，我就把请求委托给另外一个对象。</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>js</tag>
        <tag>你不知道的javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>vue 的一些事儿</title>
    <url>/vue-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E5%84%BF.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>node面试总结</title>
    <url>/node%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>k8s之etcd节点竞选</title>
    <url>/k8s%E4%B9%8Betcd%E8%8A%82%E7%82%B9%E7%AB%9E%E9%80%89.html</url>
    <content><![CDATA[<h3 id="竞选流程"><a href="#竞选流程" class="headerlink" title="竞选流程"></a>竞选流程</h3><p>etcd内部采用raft协议来实现，所以在etcd里面，节点有3个状态，一开始都是follower节点，然后接收leader的心跳信息，如果接收不到，就进入candidate进入下一轮term发起竞选，等到收到集群多数节点的投票时，该节点就会转变成新的leader节点。leader节点有可能出现故障，导致follower接收不到心跳，这时候就会发生上面的竞选，新的leader产生以后，旧的leader就会变成follower。其实就是有新的leader之后，所有其他节点都会变成follower。</p>
<p>成为leader也是有条件的，比如你的数据完整性，在竞选投票的时候，如果其他节点发现你的数据不完整，是不会给你投票的。</p>
<h3 id="节点损坏"><a href="#节点损坏" class="headerlink" title="节点损坏"></a>节点损坏</h3><p>节点可能会因为各种原因损坏，导致无法正常工作。如果是leader节点那么就会导致follower收不到心跳而触发竞选机制，如果是follower节点，那么我们可以将这个节点删除以后在创建新的节点。因为损坏的节点依然会被计算在etcd总节点之中。</p>
<p>etcd采用基于仲裁模型的分布式共识，即（n + 1) &#x2F; 2成员（多数）必须就提案一致才能提交给集群。因此当有follower损坏的时候，我们需要先删除在创建，而不能先创建在删除。</p>
<p>比如：如果有一个3个成员的集群，有一个成员损坏，那么这个集群仍然可以正常工作，这个时候删除损坏成员，该集群依然可以正常工作，然后添加新节点，这个行为是存在风险的，因为他可能会导致配置错误或无法加入集群，这种情况下，集群依然可以正常工作。而如果正确加入，依然可以正常工作。那我们想一下先增加新成员，如果增加失败，那么该集群总成员数量变成4个，而其中有1个早已损坏，还有一个刚添加的同样算是损坏，这将会使仲裁失效，所以默认情况下，etcd会拒绝这种成员的添加。</p>
<span id="more"></span>


<h3 id="读写流程"><a href="#读写流程" class="headerlink" title="读写流程"></a>读写流程</h3><p>etcd采用强一致性，实时同步，所以读的话，你从哪个节点读取都一样。对于写入来说，写入请求总会被leader先获取，然后leader节点广播给其他节点，当多数节点通过以后，这次写入会被提交，然后同步follower节点。一个已提交的数据才是真正存储下来的数据。</p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>etcd旨在可靠地存储不经常更新的数据并提供可靠的监视查询。etcd公开了以前版本的键值对，以支持快照和观看历史事件（“时间旅行查询”）。持久的多版本并发控制数据模型非常适合这些用例。</p>
<p>etcd将数据存储在多版本持久键值存储中。持久键值存储在其值被新数据取代时，保留键值对的先前版本。键值存储实际上是不可变的; 它的操作不会直接更新结构，而是始终生成新的结构。所有以前版本的密钥仍然可以访问，并且在修改后可以观看。为了防止数据存储随着时间的推移无限增长以及维护旧版本，可以压缩存储以删除最旧版本的数据。</p>
<h4 id="逻辑视图"><a href="#逻辑视图" class="headerlink" title="逻辑视图"></a>逻辑视图</h4><p>对于数据的存储保留了多个版本，每个原子变异操作（例如，事务操作可以包含多个操作）在<code>key space</code>上创建新的版本。之前修订的所有数据保持不变。旧版本的<code>key</code>仍可通过以前的版本访问。同样，版本也被编入索引; 对观察者进行修订是有效的。如果压缩存储以节省空间，则将删除紧凑版本之前的版本。版本在群集的生命周期内单调递增。</p>
<p>一个<code>key</code>的生命周期，从创造到删除。每个key可以有一个或多个生命周期。创建key会增加该key的版本，如果当前版本中不存在key，则从1开始。删除key会生成key的逻辑删除，通过将key的版本重制为0来结束key的当前生命周期。key的每次修改都会增加其版本；因此，版本在key的一个生命周期中单调增加。一旦压缩发生，之前设置的值将被删除。</p>
<h4 id="物理视图"><a href="#物理视图" class="headerlink" title="物理视图"></a>物理视图</h4><p>etcd将物理数据存储为持久b+树中的键值对。存储状态的每个版本仅包含其先前版本的增量，以实现高效。单个版本可以对应于树中的多个键。</p>
<p>键值对的关键是3元组（major, sub, type）。Major是持有key的存储版本。Sub在同一版本中的键之间进行区分。Type是特殊值的可选后缀。键值对的值包含先前版本的修改，因此是先前版本的一个增量。b+树按词汇顺序，字节顺序排序。对版本增量的远程查找很快; 这样可以快速找到从一个特定版本到另一个版本，压缩删除过时的键值对。</p>
<p>etcd还保留了辅助内存中的<code>btree</code>索引，以加快对key的范围查询。btree索引中的键是向用户公开的存储的键。该值是指向持久性b+树的修改的指针。压缩删除死指针。</p>
<h3 id="关于WAL"><a href="#关于WAL" class="headerlink" title="关于WAL"></a>关于WAL</h3><p>WAL(Write Ahead Log)预写式日志，是etcd的数据存储方式。除了在内存中存有所有数据的状态以及节点的索引外，etcd就通过WAL进行持久化存储。WAL 中，所有的数据提交前都会事先记录日志。Snapshot 是为了防止数据过多而进行的状态快照；Entry 表示存储的具体日志内容。</p>
<p>在 WAL 的体系中，所有的数据在提交之前都会进行日志记录。在 etcd 的持久化存储目录中，有两个子目录。一个是 WAL，存储着所有事务的变化记录；另一个则是 snapshot，用于存储某一个时刻 etcd 所有目录的数据。通过 WAL 和 snapshot 相结合的方式，etcd 可以有效的进行数据存储和节点故障恢复等操作。</p>
<p>既然有了 WAL 实时存储了所有的变更，为什么还需要 snapshot 呢？随着使用量的增加，WAL 存储的数据会暴增，为了防止磁盘很快就爆满，etcd 默认每 10000 条记录做一次 snapshot，经过 snapshot 以后的 WAL 文件就可以删除。</p>
<h4 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h4><p>在 etcd 的数据目录中，WAL 文件以$seq-$index.wal的格式存储。最初始的 WAL 文件是0000000000000000-0000000000000000.wal，表示是所有 WAL 文件中的第 0 个，初始的 Raft 状态编号为 0。运行一段时间后可能需要进行日志切分，把新的条目放到一个新的 WAL 文件中。</p>
<p>假设，当集群运行到 Raft 状态为 20 时，需要进行 WAL 文件的切分时，下一份 WAL 文件就会变为0000000000000001-0000000000000021.wal。如果在 10 次操作后又进行了一次日志切分，那么后一次的 WAL 文件名会变为0000000000000002-0000000000000031.wal。可以看到-符号前面的数字是每次切分后自增 1，而-符号后面的数字则是根据实际存储的 Raft 起始状态来定。</p>
<p>snapshot 的存储命名则比较容易理解，以$term-$index.wal格式进行命名存储。term 和 index 就表示存储 snapshot 时数据所在的 raft 节点状态，当前的任期编号以及数据项位置信息。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><blockquote>
<p><a href="https://www.infoq.cn/article/etcd-interpretation-application-scenario-implement-principle">https://www.infoq.cn/article/etcd-interpretation-application-scenario-implement-principle</a></p>
</blockquote>
]]></content>
      <categories>
        <category>etcd</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s之etcd基本操作</title>
    <url>/k8s%E4%B9%8Betcd-%E4%B8%80.html</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>可以参考etcd的github </p>
<blockquote>
<p><a href="https://github.com/etcd-io/etcd">https://github.com/etcd-io/etcd</a></p>
</blockquote>
<p>如果是mac的话，简单的方式应该是运行如下命令</p>
<blockquote>
<p>brew install etcd</p>
</blockquote>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>etcd是一个分布式键值存储，旨在可靠，快速地保存和提供对关键数据的访问。它通过分布式锁定，领导者选举和写入障碍实现可靠的分布式协调。etcd集群旨在实现高可用性和永久数据存储和检索。</p>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>可以使用<code>goreman</code>来在本地启动多个节点</p>
<span id="more"></span>


<p><a href="https://github.com/mattn/goremam">goreman</a> 是一个go写的多进程管理，是foreman的go版本，运行如下代码进行下载</p>
<blockquote>
<p>go get github.com&#x2F;mattn&#x2F;goreman</p>
</blockquote>
<p>启动goreman</p>
<blockquote>
<p>goreman start</p>
</blockquote>
<p>启动的时候需要提供一个Procfile文件可以使用-f参数，默认是使用当前目录下的Procfile文件</p>
<p>我们来创建一个Procfile文件，然后写入如下内容</p>
<pre><code> # Use goreman to run `go get github.com/mattn/goreman`
etcd1: etcd --name infra1 --listen-client-urls http://127.0.0.1:2379 --advertise-client-urls http://127.0.0.1:2379 --listen-peer-urls http://127.0.0.1:12380 --initial-advertise-peer-urls http://127.0.0.1:12380 --initial-cluster-token etcd-cluster-1 --initial-cluster &#39;infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380&#39; --initial-cluster-state new --enable-pprof
etcd2: etcd --name infra2 --listen-client-urls http://127.0.0.1:22379 --advertise-client-urls http://127.0.0.1:22379 --listen-peer-urls http://127.0.0.1:22380 --initial-advertise-peer-urls http://127.0.0.1:22380 --initial-cluster-token etcd-cluster-1 --initial-cluster &#39;infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380&#39; --initial-cluster-state new --enable-pprof
etcd3: etcd --name infra3 --listen-client-urls http://127.0.0.1:32379 --advertise-client-urls http://127.0.0.1:32379 --listen-peer-urls http://127.0.0.1:32380 --initial-advertise-peer-urls http://127.0.0.1:32380 --initial-cluster-token etcd-cluster-1 --initial-cluster &#39;infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380&#39; --initial-cluster-state new --enable-pprof
#proxy: etcd grpc-proxy start --endpoints=127.0.0.1:2379,127.0.0.1:22379,127.0.0.1:32379 --listen-addr=127.0.0.1:23790 --advertise-client-url=127.0.0.1:23790 --enable-pprof
</code></pre>
<p>然后保存在启动goreman</p>
<p>上面的内容我们是定义了3个etcd的节点</p>
<pre><code>etcd1: etcd --name infra1 --listen-client-urls http://127.0.0.1:2379 --advertise-client-urls http://127.0.0.1:2379 --listen-peer-urls http://127.0.0.1:12380 --initial-advertise-peer-urls http://127.0.0.1:12380 --initial-cluster-token etcd-cluster-1 --initial-cluster &#39;infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380&#39; --initial-cluster-state new --enable-pprof
</code></pre>
<p>我们来看一下这些参数</p>
<ul>
<li>name  节点的名称</li>
<li>listen-client-urls 指定etcd服务器绑定的本地地址以接受传入连接。要侦听所有接口的端口，请指定0.0.0.0侦听IP地址。</li>
<li>advertise-client-urls 建议用于客户端通信的url列表，该值用于etcd代理或etcd成员与节点通信,不可以使用localhost这种，因为这种地址无法从远程计算机进行访问</li>
<li>listen-peer-urls 指定etcd服务器绑定的本地地址以接受传入连接。要侦听所有接口的端口，请指定0.0.0.0侦听IP地址。</li>
<li>initial-advertise-peer-urls 建议用于节点之间通信的url列表，不可以使用localhost这种，因为这种地址无法从远程计算机进行访问</li>
<li>initial-cluster-token 集群的token值，用来区分不同的集群</li>
<li>initial-cluster 集群中所有initial-advertise-peer-urls的合集</li>
<li>initial-cluster-state 集群状态 new是新建</li>
</ul>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="使用etcdctl工具进行操作"><a href="#使用etcdctl工具进行操作" class="headerlink" title="使用etcdctl工具进行操作"></a>使用etcdctl工具进行操作</h2><p>etcdctl默认是v2,我们先调整到v3</p>
<blockquote>
<p>export ETCDCTL_API&#x3D;3</p>
</blockquote>
<h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h3><p>etcdctl version</p>
<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>写入使用put指令，put后面跟键值对</p>
<blockquote>
<p>etcdctl put foo bar</p>
</blockquote>
<h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>使用get指令读取，get后面跟要读取的键</p>
<blockquote>
<p>etcdctl get foo</p>
</blockquote>
<p>如果想读取十六进制，使用–hex参数</p>
<blockquote>
<p>etcdctl get foo –hex</p>
</blockquote>
<p>如果想只读取值，使用–print-value-only参数</p>
<blockquote>
<p>etcdctl get foo –print-value-only</p>
</blockquote>
<p>如果想根据前缀获取，使用–prefix</p>
<blockquote>
<p>etcdctl get foo –prefix</p>
</blockquote>
<p>还可以使用limit参数限制数量</p>
<blockquote>
<p>etcdctl get foo –prefix –liimit&#x3D;2</p>
</blockquote>
<h4 id="读取之前版本的记录"><a href="#读取之前版本的记录" class="headerlink" title="读取之前版本的记录"></a>读取之前版本的记录</h4><p>可以使用–rev参数来获取之前操作时候的值,比如</p>
<pre><code>etcdctl put foo bar
etcdctl put foo bar1
etcdctl put foo bar2
</code></pre>
<p>这个时候我们读取，给我们的值肯定是bar2</p>
<blockquote>
<p>etcdctl get foo</p>
</blockquote>
<p>我们可以通过–rev&#x3D;3参数来获取之前的bar1值，–rev&#x3D;2来获取bar值</p>
<blockquote>
<p>etcdctl get foo –rev&#x3D;3</p>
</blockquote>
<h4 id="读取大于等于给定键的键值对"><a href="#读取大于等于给定键的键值对" class="headerlink" title="读取大于等于给定键的键值对"></a>读取大于等于给定键的键值对</h4><p>可以使用参数 –from-key来获取大于等于给定键的键值，这个参数是使用键的字节进行比较</p>
<blockquote>
<p>etcdctl get foo –from-key</p>
</blockquote>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>使用del指令删除键值对</p>
<blockquote>
<p>etcdctl del foo</p>
</blockquote>
<p>可以使用上面提到的–prefix来删除所有这个前缀的键值，还有–from-key参数也可以使用。这里面有一个新参数–prev-kv，这个参数返回删除的键值</p>
<blockquote>
<p>etcdctl del foo –prev-kv</p>
</blockquote>
<h3 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h3><p>使用watch指令可以观测指定键的操作，注意这个应该在另外一个终端中进行，而且同样要改变成v3版本，不然默认v2是监测不到改变的</p>
<blockquote>
<p>etcdctl watch foo</p>
</blockquote>
<p>可以是使用-i参数进入交互模式</p>
<blockquote>
<p>etcdctl watch -i<br>然后输入你要监测的键<br>watch foo</p>
</blockquote>
<h4 id="观察历史记录"><a href="#观察历史记录" class="headerlink" title="观察历史记录"></a>观察历史记录</h4><p>这个操作也可以使用上面的–rev参数，它会把之前的历史操作都显示出来，也会继续观察之后的操作</p>
<blockquote>
<p>etcdctl watch foo –rev&#x3D;1</p>
</blockquote>
<h1 id="关于通信"><a href="#关于通信" class="headerlink" title="关于通信"></a>关于通信</h1><p>etcd本身使用grpc作为其消息传递协议，也就是我们在项目中使用的时候，使用grpc进行和etcd的通信。对于没有grpc支持的语言，或者你不想使用grpc的话，etcd也提供了json grpc网关。此网关提供restful代理，将http&#x2F;json请求转换为grpc消息。<br>详细使用方法，直接去github上面看吧</p>
<blockquote>
<p><a href="https://github.com/etcd-io/etcd/blob/master/Documentation/dev-guide/api_grpc_gateway.md">https://github.com/etcd-io/etcd/blob/master/Documentation/dev-guide/api_grpc_gateway.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>etcd</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>素数对猜想</title>
    <url>/%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3.html</url>
    <content><![CDATA[<h1 id="素数对猜想"><a href="#素数对猜想" class="headerlink" title="素数对猜想"></a>素数对猜想</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。现给定任意正整数<code>N</code>(&lt;10<sup>5</sup>)，请计算不超过N的满足猜想的素数对的个数。</p>
<h2 id="输入例子"><a href="#输入例子" class="headerlink" title="输入例子"></a>输入例子</h2><pre><code>20
</code></pre>
<h2 id="输出例子"><a href="#输出例子" class="headerlink" title="输出例子"></a>输出例子</h2><pre><code>4
</code></pre>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个比较简单，看题目，能确定一点，一个素数对，有两个相差 2 的素数组成。那么接下来就可以用 <code>n</code>除以<code>2</code>到<code>根号n</code>之中的任意一个数，如果能被整除，那么就不是素数，如果不能被整除，那么就是一个素数。如果发现了一个素数，那么就用这个素数相差2的数再去判断，如果还是素数，那么就有了一个素数对。</p>
<span id="more"></span>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 判断是不是一个素数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;int&#125; $num</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params"><span class="variable">$num</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果 n &lt; 2 那么它不是一个素数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$num</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果 n 能整除 2 到 根号n 之中的任意一个数 那么他就不是 素数</span></span><br><span class="line">    <span class="comment">//sqrt 函数 用来 开平方根</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">2</span>; <span class="variable">$i</span> &lt;= <span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">sqrt</span>(<span class="variable">$num</span>)); <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$num</span> % <span class="variable">$i</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"><span class="variable">$num</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="variable">$num</span>; <span class="variable">$i</span> &gt;= <span class="number">5</span>; <span class="variable">$i</span>--) &#123;</span><br><span class="line">        <span class="comment">//如果 n 和 n - 2 都是素数，那么就有一个素数对</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">isPrime</span>(<span class="variable">$i</span>) &amp;&amp; <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">isPrime</span>(<span class="variable">$i</span> - <span class="number">2</span>)) &#123;</span><br><span class="line">            ++<span class="variable">$count</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">printf</span>(<span class="variable">$count</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>打印沙漏</title>
    <url>/%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F.html</url>
    <content><![CDATA[<h1 id="打印沙漏"><a href="#打印沙漏" class="headerlink" title="打印沙漏"></a>打印沙漏</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>顾名思义，就是要输出一个<code>沙漏</code>，那么什么是沙漏呢，就是下面的样子了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*****</span><br><span class="line"> ***</span><br><span class="line">  *</span><br><span class="line"> ***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>

<p>也就是要给我们n个<code>*</code>，这个沙漏每一行的 符号 数量都是奇数，因此是有规律的。</p>
<span id="more"></span>


<h2 id="输入例子"><a href="#输入例子" class="headerlink" title="输入例子"></a>输入例子</h2><p>  19 &#x2F;&#x2F;多少个符号 *</p>
<h2 id="输出例子"><a href="#输出例子" class="headerlink" title="输出例子"></a>输出例子</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//打印出一个沙漏</span><br><span class="line">*****</span><br><span class="line"> ***</span><br><span class="line">  *</span><br><span class="line"> ***</span><br><span class="line">***** </span><br><span class="line">2 //剩余没有用掉的符号数量</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个解题思路是我在网上看到的，他把这个沙漏 具像化，*号用坐标来显示，那么上面的例子就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（0，0）（0，1）（0，2）（0，3）（0，4）</span><br><span class="line">       （1，1）（1，2）（1，3）</span><br><span class="line">              （2，2）</span><br><span class="line">       （3，1）（3，2）（3，3）</span><br><span class="line">（4，0）（4，1）（4，2）（4，3）（4，4）</span><br></pre></td></tr></table></figure>

<p>这样的话，继续观察一下，发现他可以上下对折，左右对折变成下面这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（0，0）（0，1）（0，2）</span><br><span class="line">       （1，1）（1，2）</span><br><span class="line">              （2，2）</span><br></pre></td></tr></table></figure>

<p>发现了什么，列 &gt;&#x3D; 行，然后接下来左右对称，上下对称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当 行坐标 &gt; 行数 / 2 也就是过半的时候， 这时的行坐标 = 总行数 - 当前行数 - 1，比如下一行 行坐标 3 = 5 - 3 -1 = 1 所以 行坐标 3 的行和行坐标 1 的行对称。</span><br></pre></td></tr></table></figure>

<p>列也是一样 因为列数 &#x3D; 行数 所以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当 列坐标 &gt; 行数 / 2 也就是过半的时候， 这时的列坐标 = 总行数 - 当前列数 - 1，比如下一列 列坐标 3 = 5 - 3 - 1 = 1 所以列坐标 3 的列和列坐标 1 的列对称。</span><br></pre></td></tr></table></figure>

<p>当然了，中间那一行（列）没有对称</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>下面是 我用 <code>php</code> 实现的代码，任何语言都大同小异。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"><span class="variable">$count</span>, <span class="variable">$symbol</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$maxRow</span> = <span class="number">1</span>; <span class="comment">//最大行 即 最小行</span></span><br><span class="line">        <span class="variable">$maxCount</span> = <span class="number">1</span>; <span class="comment">//最大个数 即 最小个数</span></span><br><span class="line">        <span class="comment">//先判断 数量 如果是小于 最小个数 那么输出 数量</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$count</span> &lt; <span class="variable">$maxCount</span>) &#123;</span><br><span class="line">            <span class="title function_ invoke__">printf</span>(<span class="variable">$count</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//循环 算出 最大行数 统计最大个数 后面用来算剩余个数</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">//可以输出</span></span><br><span class="line">                <span class="comment">//下一行的数量 = 之前的数量 + 下一行所需的数量（（行数 + 2） 是下一行的数量，但是沙漏需要上下两行，所以 * 2）</span></span><br><span class="line">                <span class="variable">$nextCount</span> = (<span class="variable">$maxRow</span> + <span class="number">2</span>) * <span class="number">2</span> + <span class="variable">$maxCount</span>;</span><br><span class="line">                <span class="comment">//判断不够了 结束</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">$count</span> &lt; <span class="variable">$nextCount</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">elseif</span> (<span class="variable">$count</span> == <span class="variable">$nextCount</span>) &#123;</span><br><span class="line">                    <span class="comment">//刚好够 数量增加 行增加</span></span><br><span class="line">                    <span class="variable">$maxRow</span> += <span class="number">2</span>;</span><br><span class="line">                    <span class="variable">$maxCount</span> = <span class="variable">$nextCount</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//完全够 数量增加 行增加 然后继续循环</span></span><br><span class="line">                    <span class="variable">$maxRow</span> += <span class="number">2</span>;</span><br><span class="line">                    <span class="variable">$maxCount</span> = <span class="variable">$nextCount</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//开始输出</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$maxRow</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">                <span class="comment">//循环所有行</span></span><br><span class="line">                <span class="variable">$row</span> = <span class="variable">$i</span>; <span class="comment">//当前行</span></span><br><span class="line">                <span class="comment">//判断 当前行 到一半了，那么把行数倒过来，让它向上跑</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">$i</span> &gt; <span class="variable">$maxRow</span> / <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="variable">$row</span> = <span class="variable">$maxRow</span> - <span class="variable">$row</span> - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="variable">$j</span> = <span class="number">0</span>; <span class="variable">$j</span> &lt; <span class="variable">$maxRow</span>; <span class="variable">$j</span>++) &#123;</span><br><span class="line">                    <span class="comment">//循环所有列</span></span><br><span class="line">                    <span class="variable">$col</span> = <span class="variable">$j</span>;</span><br><span class="line">                    <span class="comment">//列和行一样 做个判断</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="variable">$col</span> &gt; <span class="variable">$maxRow</span> / <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="variable">$col</span> = <span class="variable">$maxRow</span> - <span class="variable">$col</span> - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果 当前列 &lt; 当前行</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="variable">$col</span> &lt; <span class="variable">$row</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果 到了 最后 就要换行 在 前面 则输出 空格</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="variable">$j</span> &gt; <span class="variable">$maxRow</span> / <span class="number">2</span>) &#123;</span><br><span class="line">                            <span class="title function_ invoke__">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="title function_ invoke__">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//列 &gt; 行 直接输出 符号</span></span><br><span class="line">                        <span class="title function_ invoke__">printf</span>(<span class="variable">$symbol</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//输出完 最后一个符号后 换行 当列 = 最后一行的时候</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="variable">$j</span> == <span class="variable">$maxRow</span> - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="title function_ invoke__">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出 剩余的 符号数量</span></span><br><span class="line">            <span class="title function_ invoke__">printf</span>(<span class="variable">$count</span> - <span class="variable">$maxCount</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>我只是略作更改，最小使用1个*，和一些变量使用上的微调 下面原文c语言的链接</p>
<blockquote>
<p><a href="https://blog.csdn.net/hcy2319964421/article/details/53103641">https://blog.csdn.net/hcy2319964421/article/details/53103641</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>node-xlsx 使用node.js导出excel</title>
    <url>/node-xlsx-%E4%BD%BF%E7%94%A8node-js%E5%AF%BC%E5%87%BAexcel.html</url>
    <content><![CDATA[<h1 id="导出excel"><a href="#导出excel" class="headerlink" title="导出excel"></a>导出excel</h1><p>关于excel，相信这玩意大家都用过，我们这边，主要运营那边，对这些数据导出很有需要，之前拿php做过，因为现在改用node了，所以这边要用node来搞。</p>
<h2 id="export-xlsx"><a href="#export-xlsx" class="headerlink" title="export-xlsx"></a>export-xlsx</h2><p><code>excel-export</code> 这个库你们也可以用用，简单实用，我一开始用的这个，只不过后来不满足我的需求了，所以改用了<code>node-xlsx</code></p>
<blockquote>
<p><a href="https://github.com/functionscope/Node-Excel-Export">https://github.com/functionscope/Node-Excel-Export</a></p>
</blockquote>
<h2 id="node-xlsx"><a href="#node-xlsx" class="headerlink" title="node-xlsx"></a>node-xlsx</h2><p>来说说<code>node-xlsx</code>这个东西吧，非常简单上手，我这种node新人也可以用明白，不容易啊，哈哈。</p>
<span id="more"></span>


<h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install node-xlsx</span><br></pre></td></tr></table></figure>
<p>或者</p>
<blockquote>
<p><a href="https://github.com/mgcrea/node-xlsx">https://github.com/mgcrea/node-xlsx</a></p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>直接安装该模块，然后进入代码阶段，其实这个也很简单，使用起来简单粗暴</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   import nodeExcel from &#x27;node-xlsx&#x27;</span><br><span class="line">   import fs from &#x27;fs&#x27;</span><br><span class="line">   import path from &#x27;path&#x27;</span><br><span class="line"></span><br><span class="line">   const EXPORT_PATH = &#x27;../../static&#x27;</span><br><span class="line"></span><br><span class="line">   //创建一个buffer name是你的sheet的名称，data是你的内容，一个二维数组，我是把数据库查询出来的转成了二维数组</span><br><span class="line">   //data = [[name,age][章三,11]]</span><br><span class="line">let buffer = nodeExcel.build([&#123; name: &#x27;mySheetName&#x27;, data: arr &#125;])</span><br><span class="line">//写入一个文件</span><br><span class="line">   //filePath 是你的文件路径，自己定义一下就好了</span><br><span class="line">   //fileName 是你的文件名，带后缀xlsx的哦</span><br><span class="line">   let filePath = path.resolve(__dirname, EXPORT_PATH, fileName)</span><br><span class="line">fs.writeFileSync(filePath, buffer, &#x27;binary&#x27;)</span><br></pre></td></tr></table></figure>

<p>这样就完成转换成这个文件了，接下来你可以把文件路径返回给前端，或者把文件流返回给前端</p>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>node-xlsx</tag>
      </tags>
  </entry>
  <entry>
    <title>git 命令行简写</title>
    <url>/git-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AE%80%E5%86%99.html</url>
    <content><![CDATA[<p>常用的 <code>git</code> 命令不多，反正我就是那几个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git branch</span><br><span class="line">git checkout</span><br><span class="line">git commit</span><br><span class="line">git diff</span><br></pre></td></tr></table></figure>

<p>虽然看起来也不长，但是我还是喜欢简写，哈哈，说一下怎么配置</p>
<span id="more"></span>


<blockquote>
<p>vim ~&#x2F;.gitconfig    打开配置文件</p>
</blockquote>
<p>输入如下</p>
<pre><code>[alias]
        br = branch
        st = status
        co = checkout
        cm = commit
        df = diff
        dt = difftool
[diff]
        tool = vimdiff

[user]
        name = xxx
        email = xxx
</code></pre>
<p><code>alias</code> 就是简写啦，这样的话，使用就方便多了，<code>diff</code> 和 <code>user</code> 大家可以不用管，哈哈</p>
<h2 id="推荐个小工具"><a href="#推荐个小工具" class="headerlink" title="推荐个小工具"></a>推荐个小工具</h2><p>给大家安利个小工具 <code>gitbash</code> , 用起来很方便，他会在你的命令行里面直接显示出你的分支。下面是 github 的地址，操作简单,大家照着弄一下就好了</p>
<blockquote>
<p><a href="https://github.com/mocheng/gitbash">https://github.com/mocheng/gitbash</a></p>
</blockquote>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>config</tag>
      </tags>
  </entry>
  <entry>
    <title>评论来啦 -- 关于 hexo next 集成 gitment</title>
    <url>/%E8%AF%84%E8%AE%BA%E6%9D%A5%E5%95%A6.html</url>
    <content><![CDATA[<h1 id="全新的gitment-评论上线啦！"><a href="#全新的gitment-评论上线啦！" class="headerlink" title="全新的gitment 评论上线啦！"></a>全新的gitment 评论上线啦！</h1><p>小伙伴们可以评论啦，开不开心，惊不惊喜，本来看网上说用 多说 的，结果发现 多说 没了？ 没了？ 没了？ excuse me?<br>然后，苦逼的我只能继续找，就发现了这个 gitment ，感觉不错，来用一用，瞬间高大上啊，这个 next 主题 好像已经集成好 gitment 了，<br>我们只用简单设置一下就能用了，舒服。</p>
<h3 id="注册OAuth-Application"><a href="#注册OAuth-Application" class="headerlink" title="注册OAuth Application"></a>注册OAuth Application</h3><pre><code>https://github.com/settings/applications/new
</code></pre>
<p>上面的连接，点击注册，会让你输入4个东西</p>
<pre><code>Application name
Homepage URL
Application description
Authorization callback URL
</code></pre>
<p>最后 这个东西 要填你 博客的 url ，点进去之后 都会有说明。弄完之后 会出现两个东西</p>
<pre><code>Client ID
Client Secret
</code></pre>
<p>这两个东西 大家 要记住了。接下来配置的时候会用到。</p>
<h3 id="配置-next"><a href="#配置-next" class="headerlink" title="配置 next"></a>配置 next</h3><p>打开我们的站点配置文件 _config.yml 然后找到 gitment。</p>
<pre><code>enable: true
mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway
count: true # Show comments count in post meta area
lazy: false # Comments lazy loading with a button
cleanly: false # Hide &#39;Powered by ...&#39; on footer, and more
language: 语言
github_user: 你的 github 名
github_repo: 你的仓库名
client_id: 刚刚的 Client ID
client_secret: 刚刚的 Client Secret
</code></pre>
<p>配置完之后 就可以 看一下效果了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>来看一下 这玩意有哪些坑吧<br>在配置的时候 blog&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_third-party&#x2F;comments&#x2F;gitment.swig 这个文件的时候，下面这些取得都是配置里面设置的，一定要一一对应哦</p>
<pre><code>&#123;% set owner = theme.gitment.github_user %&#125;
&#123;% set repo = theme.gitment.github_repo %&#125;
&#123;% set cid = theme.gitment.client_id %&#125;
&#123;% set cs = theme.gitment.client_secret %&#125;
</code></pre>
<p>错误</p>
<pre><code>error:not found
</code></pre>
<p>这个错误的话，你就要仔细检查上面的参数啦，一定是owner 和 repo 这两个参数有问题，和你github上面的用户名和仓库名 不一样导致的</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>关于初始化，这个评论是需要初始化的，嗯，每个文章你都要去初始化，很麻烦。对于我这种没几个文章的来说，还行。<br>在 gitment.swig 这个文件里面 有这样一处代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gitment = <span class="keyword">new</span> <span class="title class_">Gitment</span>(&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;&#123;&#123;page.article&#125;&#125;&#x27;</span>,</span><br><span class="line">    <span class="attr">owner</span>: <span class="string">&#x27;&#123;&#123;owner&#125;&#125;&#x27;</span>,</span><br><span class="line">    <span class="attr">repo</span>: <span class="string">&#x27;&#123;&#123;repo&#125;&#125;&#x27;</span>,</span><br><span class="line">    <span class="attr">oauth</span>: &#123;</span><br><span class="line">        <span class="attr">client_id</span>: <span class="string">&#x27;&#123;&#123;cid&#125;&#125;&#x27;</span>,</span><br><span class="line">        <span class="attr">client_secret</span>: <span class="string">&#x27;&#123;&#123;cs&#125;&#125;&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个里面 有个 id 的设置 他默认的是 <code>location.href</code>，这个时候大家注意了，因为这个东西 本质是创建一个 issue,然后他创建的时候，会有一个 label 传过去，来区分你每个文章的评论，他传的是什么呢，是一个数组, 最最重要的是，这tm有长度限制，你用 href 的话，基本是超出的，反正我是，然后我试了一下 pathname ，依然超出。</p>
<p>网上有人用的是时间，也有标题，我就不一样了，我给每个文章加了个 article 来区分他们。使用方法就是上面那样。我也用过时间，然后他告诉我 不是 string or object ，晕，标题，万一没控制好超长了就不好玩了。大家根据需求来就行了，有问题的欢迎评论。</p>
<pre><code>[
    gitment,
    你写的id
]
</code></pre>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>gitment</tag>
      </tags>
  </entry>
  <entry>
    <title>window php 环境搭建一</title>
    <url>/window%20php%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%80.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="开始写博客了，激动ing–此处省略一万字……"><a href="#开始写博客了，激动ing–此处省略一万字……" class="headerlink" title="开始写博客了，激动ing–此处省略一万字……"></a>开始写博客了，激动ing–此处省略一万字……</h3><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>直接说环境吧，每次到一个公司，配置环境是最烦的，嗯，博主比较菜，这个配置完n久都不在用的，一会就忘了，所以，你懂的。。环境清单如下：</p>
<pre><code>php
nginx
mysql
redis
mongo
rabbitMq队列
</code></pre>
<p>下载 没什么好说的，百度官网，直接下载就行了，我相信大家都知道。</p>
<p><code>php</code> 下载之后 直接复制 一个 php.ini-development 或者 php.ini-production 然后改名成 php.ini，你们猜的没错，这就是我们的配置啦。扩展之类的 从 Pecl下载好 ，然后在配置里面打开就好了。<br>下载 nginx 同上，一样官网下载，然后在你下载之后，里面有 conf 文件夹 里面的 nginx.conf 就是 nginx 的配置文件了。暂时什么都不用改，启动 nginx 然后访问 localhost 就会出现 nginx 的欢迎页面了。</p>
<p><code>mysql</code> 下载是一样的，在安装的时候 要注意选择需要的东西安装就好了，博主只用了server and bench。安装的时候会设置 root 用户的密码。</p>
<p><code>redis</code> 同样官网下载，之后咋们主要看 2个东西 redis-server.exe and redis-cli.exe ，一个服务器一个客户端。然后还有一个隐藏小boss，redis.windows.conf 启动 redis 服务的时候要带上这玩意，所以我们就要用 cmd 了， 打开 cmd 输入如下：</p>
<blockquote>
<p>路径\redis-server.exe redis.windows.conf</p>
</blockquote>
<p>好了，然后点击 <code>redis-cli.exe</code> 就可以用了。完美。</p>
<p><code>mongo</code> 同上，下载完之后 在 <code>bin</code> 文件夹里面 有 <code>mongod.exe</code> and <code>mongo.exe</code> 也是 服务器和客户端，对于 <code>mongo</code> 我们要建一个 <code>data\db</code> 这两个文件夹</p>
<p>最后到了 <code>rabbitMq</code> 了, 安装这个之前，要先安装 <code>erlang</code> ，直接下载安装， 然后就可以安装 <code>rabbitMq</code> 了，然后 我们 安装 <code>rabbitMq-plugins</code> 打开 cmd 输入</p>
<blockquote>
<p>路径\rabbitMq_server\sbin\rabbitmq-plugins enable rabbitmq_management</p>
</blockquote>
<p>然后就会安装成功了。</p>
<p>说一下问题。<br>首先这些 环境变量 一定要弄上。<br>然后 <code>rabbitmq</code> 要先启动 在安装 <code>rabbitmq-plugins</code> ，我也忘了是不是了，你们根据情况来吧。</p>
<blockquote>
<p>安装完之后 进入浏览器 localhost:15672 就能访问管理页面了。</p>
</blockquote>
<p>哈哈，其实还是有一些坑的，只不过写的时候想不起来了，所以这篇没什么干货。。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><blockquote>
<p>想起来一个东西，所有的命令输入 绝对路径 或者 进入相应文件夹 用 .*.exe 的命令来执行</p>
</blockquote>
<p>如果有什么想问的 欢迎加博主的qq and 微信</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>php</tag>
        <tag>nginx</tag>
        <tag>redis</tag>
        <tag>mongo</tag>
        <tag>rabbitMq</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
