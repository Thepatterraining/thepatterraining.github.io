---
title: 深入理解计算机系统（一）
date: 2023-06-21 10:12:47
tags: ['csapp']
category: csapp
article: 深入理解计算机系统（一）
---

# 计算机系统漫游

计算机系统是由硬件和系统软件组成的，它们共同工作来运行应用程序。。虽然系统的 具体实现方式随着时间不断变化，但是系统内在的概念却没有改变。所有计算机系统都有 相似的硬件和软件组件，它们又执行着相似的功能。

## 第一个c程序

一般第一个程序都是输出`hello world`，这里我们使用c语言输出一个`hello world`。后面在来讲这里面都发生了什么。

```c
#include <stdio.h>

int main(void)
{
    printf("hello world\n");
    return 0;
}
```

# 信息的表示和处理

无符号整型和有符号整型的二进制表示

![无符号整型和有符号整型的二进制表示](../images/csapp/csapp1-1.png)

## bit

可以用bit来表示集合，并用位操作来表示集合的操作。

p && *p可以避免空指针

左移1位等于乘2

右移1位等于除2，且向下取整

逻辑右移：右移后补0，java中 -3 >> 1 = -2
算术右移：右移后补符号位,java中 -3 >>> 1 = 2147483646

## 大端表示和小端表示

- 最高有效字节在最前面的方式，称为大端表示。
- 低有效字节在最前面的方式，称为小端表示。

![大端表示和小端表示](../images/csapp/csapp1-2.png)

可以通过下面的代码来测试自己的机器是大端还是小端的。

```c
#include <stdio.h>

typedef unsigned char *pointer;

void show_bytes(pointer start, size_t len) {
	size_t i;
	for (i = 0; i < len; i++)
		printf("%p\t0x%.2x\n", start+i, start[i]);
	printf("\n");
}

int main() {
    int a = 15213;
    printf("int a = 15213;\n");
    show_bytes((pointer) &a, sizeof(int));
    return 0;
}
```

## float

101.11表示5又3/4，也就是23/4。前面的101表示5，小数点后面的11表示3/4,小数点后面第1个1表示1/2，第二个1表示1/4，所以相加就是3/4

![float](../images/csapp/csapp1-3.png)

浮点数表示由`IEEE`制定。

IEEE浮点标准用`V = (-1)的s次方 * M * 2的E次方`来表示。

所以存储就有了3部分
- 符号位，1位，0表示正数，1表示负数，表示s
- 尾数significand，尾数通常是1-2之间或0-1之间。encodes M，但不等于M
- 阶码exponent，encodes E，但不等于E

![IEEE float](../images/csapp/csapp1-4.png)

### 表示方式

#### 规格化表示(Normalized)

当阶码不等于全0或不等于全1的时候，就表示规格化的浮点数。

E的计算方式
- E = 阶码 - Bias
- Bias = 2的k-1次方 - 1，单精度是127，双精度是1023
- 单精度下，假设阶码为 0000 0001, 那么E = 1 - 127 = -126

M的计算方式
- M = 1.XXXXXX
- 尾数就是 XXXXXX
- 假设 尾数为 0000 0000 0000 0000 0000 001，那么M = 1.00000000000000000000001

假设符号为0表示正数，那么这个浮点数为 V = 1 * M * 2的E次方 
= 1 * 1.00000000000000000000001 * 2的-126次方 
= 1.00000000000000000000001 * 2的-126次方 
= 0.000...00100000000000000000000001 （小数点左移126位）
这等于非常非常小的一个浮点数了

如何表示15213.0呢。首先符号位为0，然后计算尾数和阶码。
- 15213.0 换成二进制表示为 11 1011 0110 1101.0
- 接下里移动小数点为 1.1101 1011 0110 1 * 2的13次方，因为小数点左移动了13位。
- 所以尾数为 1101 1011 0110 1000 0000 000
- E = 13，所以阶码 = E + Bias = 13 + 127 = 140.
- 所以阶码为 140，二进制表示为 1000 1100

15213.0的浮点数表示为：

0 1000 1100 1101 1011 0110 1000 0000 000


#### 非规格化表示(Denormalized)

当阶码等于全0的时候，就表示非规格化的浮点数。

E的计算方式，他跟阶码没关系了，因为阶码永远是0
- E = 1 - Bias
- Bias = 2的k-1次方 - 1，单精度是127，双精度是1023
- 阶码永远为 0000 0000, E = 1 - 127 = -126

M的计算方式
- M = 0.XXXXXX
- 尾数就是 XXXXXX
- 假设 尾数为 0000 0000 0000 0000 0000 001，那么M = 0.00000000000000000000001

假设符号为0表示正数，那么这个浮点数为 V = 1 * M * 2的E次方 
= 1 * 0.00000000000000000000001 * 2的-126次方 
= 0.00000000000000000000001 * 2的-126次方 
= 0.000...00000000000000000000000001 （小数点左移126位）
这等于非常非常小的一个浮点数了，比上一个规格化的更小

如果尾数也等于全0，那么就表示浮点数0

#### 特殊值

当阶码等于全1的时候，就表示特殊的浮点数。
- 当尾数全0，就表示无穷大
- 当尾数为其他值的时候，就表示 NaN(Not a Number)

用数轴表示如下：

![IEEE float 表示](../images/csapp/csapp1-5.png)

## 练习题

 习题2.54 假定变量x,f和d的类型分别是int、float 和cioubile。除了f和d都 不 能 等 于 十∞ 、 、 一 ∞ 或 者 N a N ， 它 们 的 值 是 任 意 的 。 对 于 下 面 每 个 C 表 达 式， 证 明 它 总 是 为 真 ( 也 就 是 求 值 为 1 )， 或 者 给 出 一 个 使 表 达 式 不 为 真 的 值 ( 也 就 是 求 值 为 0 )。

 类型中long > double > int > float

1. x == (int) (double) x // true
2. x == (int) (float) x // false
3. d == (double) (float) d // false
4. f == ( float ) ( double ) f // true
5. f == -(-f) //true 只改变了符号位
6. 1.0/2 == 1/2.0 //true
7. d*d >= 0.0 // true
8. ( f + d ) - f == d //false浮点数不满足结合律

# 程序的机器级表示

## 历史

从最早的16位处理器8086到现在的64位处理器x86-64
- 8086(1978年 ， 29 K个晶体管 )。 是 第 一代单芯片、16 位微处理器之一。8088是8086的一个变种，在8086上增加了一个8位外部总线，构成最初的IBM个人计算机的心脏。 BM与当时还不强大的微软签订合同，开发MS DOS 操作系统。最初的机器型号有32768 字节的内存和两个软驱 (没有硬盘驱动器)。 从体系结构上来说，这些机器只有655360字节的地址间 -- 地址只有20位长(可寻址范围为1048576字节)，而操作系统保留了393216字节自用。1980年 ，Intel提出了8087浮点协处理器 (45 K个晶体管)，它与一个8086或8088处理器一同运行，执行浮点指令。8087 建立了x86 系列的浮点模型，通常被称为 “x87”
- 80286(1982 年，134K个晶体管)。增加了更多的寻址模式(现在已经废弃了)，构成了IBM PC- AT个人计算机的基础，这种计算机是 MS Windows 最初的使用平台。
- i386 (1985 年，275K 个晶体管) 。将体系结构扩展到32位。增加了平坦寻址模式(flat addressingmodel)，Linux 和最近版本的Windows 操作系统都是使用的这种模式。这是 Intel 系列中第 一台全面支持Unix操作系统的机器。
- i486(1989 年，1.2M个晶体管)。改善了性能，同时将浮点单元集成到了处理器芯片上，但是指令集没有明显的改变。
- Pentium(1993 年，3.1M个晶体管)。改善了性能，不过只对指令集进行了小的扩展
- PentiumPro( 1995 年，5.5M个晶体管)。引人全新的处理器设计，在内部被称为P6 微体系结构。指令集中增加了一类“ 条件传送(conditional move)” 指令
- Pentium/ MMX ( 1997年，4.5M个晶体管 )。 在 Pentium处理器中增加了一类新的处理整数向量的指令。每个数据大小可以是1、2或4字节。每个向量总长64位
- Pentium II ( 1997 年 ，7M 个晶体管 )。 P6微体系结构的延伸
- Pentium III (1999年，8.2M个晶体管)。引人了SSE，这是一类处理整数或浮点数向 量的指令。每个数据可以是1、2或4个字节，打包成128位的向量。由于芯片上包括了 二 级高速绥存，这种芯片后来的版本最多使用 了24M 个晶体管
- Pentium4 ( 2000年 ， 42M个晶体管 )。 SSE 扩展到了 SSE2，增加了新的数据类型 (包括双精度浮点数)，以及针对这些格式的 144 条新指令。有了这些扩展，编译器可以使用 SSE 指令(而不是x87 指令)，来编译浮点代码
- Pentium 4E(2004年，125M个晶体管)。增加了超线程(hyperthreading)，这种技术 可以在一个处理器上同时运行两个程序;还增加 了EM64T ，它是 Intel 对 AMD 提出的对 IA32的64 位扩展的实现，我们称之为x86-64。
- Core2( 2006年 ， 291M 个晶体管 )。 回归到类似于 P6 的微体系结构 。Intel的第一个多核微处理器，即多处理器实现在一个芯片上。但不支持超线程。
- Core i7，Nehalem(2008年，781M个晶体管)。既支持超线程，也有多核，最初的版 本支持每个核上执行两个程序，每个芯片上最多四个核
- Core i7, Sandy Bridge(2011年，1.17G 个晶体管)。引入了AVX，这是对SSE 的扩 展，支持把数据封装进 256 位的向量。
- Corei7, Haswel(2013年，1.4G个晶体管)。将AVX扩展至AVX2，增加了更多的指令和指令格式.

## 机器级代码


