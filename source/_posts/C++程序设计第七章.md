---
title: 学堂在线C++程序设计第七章学习笔记
date: 2021-08-02 10:12:47
tags: ['C++']
category: C++
article: 学堂在线C++程序设计第七章学习笔记
---

# 学堂在线C++程序设计第七章学习笔记

## 数组的定义与初始化

数组是具有一定顺序关系的若干相同类型变量的集合体，组成数组的变量称为该数组的元素

数组的定义

类型说明符 数组名[常量表达式] [常量表达式]...
数组名的构成方法与一般变量名相同

例如：
- int a[10]
- int a[5][3]


数组的使用
- 数组必须先定义，后使用
- 可以逐个引用数组元素
- 例如：
a[0] = a[5] + a[7]

### 数组的存储和初始化

一位数组的存储

`数组元素`在内存中顺次存放，它们的`地址是连续`的。元素间物理地址上的相邻，对应着逻辑次序上的相邻

`数组名字`是数组`首元素`的内存地址

`数组名字`是一个常量，不能被赋值


一维数组初始化

- 列出全部值
    - static int a[5] = {0,1,2,3,4}
- 可以只给一部分元素初始化
    - static int a[5] = {0,1,2}
- 列出全部值时，可以不指定长度
    - static int a[] = {0,1,2,3,4}


二维数组的存储
- 按行存放

二维数组的初始化
- 列出全部值，按照顺序初始化
    - static int a[3][2] = {0,1,2,3,4,5}
- 分行列出二维数组元素的初值
    - static int a[3][2] = { {0,1},{2,3},{4,5} }
- 可以只对部分元素初始化
    - static int a[3][2] = { {0},{1,2},{3} }
- 列出全部初始值，第一维下标可以省略
    - static int a[][2] = {0,1,2,3,4,5}
    - static int a[][2] = { {0,1},{2,3},{4,5} }
- 如果不做任何初始化，局部作用域非静态数组中会存在垃圾数据，static 数组中的数据默认初始化为0
- 如果只对部分元素初始化，剩下的将自动被初始化为0


### 对象数组

对象数组的定义和访问
- 定义对象数组
    - 类名 数组名[元素个数]
- 访问对象数组
    - 通过下标访问 数组名[下标].成员名

对象数组初始化
- 数组中每一个元素对象被创建时，系统都会调用类构造函数初始化该对象
- 通过初始化列表赋值
    - 例如：Point a[2] = {Point{1,2}, Point{3,4}}
- 如果没有为数组元素指定显式初始值，数组元素便使用默认值初始化（调用默认构造函数）


数组元素的构造和析构
- 构造数组时，元素所属的类未声明构造函数，则采用默认构造函数
- 各元素对象的初值要求为相同的值时，可以声明具有默认形参值得构造函数
- 各元素对象的初值要求为不同的值时，需要声明带形参的构造函数
- 当数组中每一个对象被删除时，系统需要调用一次析构函数


### 基于范围的for循环

C++11 提供的

自动遍历整个容器

```C++
int main(){
    int array[3] = {1,2,3}
    int *p;
    for (p = array;p < array + sizeof(array) / sizeof(int); ++p) {
        *p += 2;
        std::cout << *p << std::endl;
    }
    return 0;
}
```

如果用基于范围的

```C++
int main(){
    int array[3] = {1,2,3};
    for(int & e : array) {
        e+=2;
        std::cout <<e <<std::endl;
    }
    return 0;
}
```

### 指针的定义和运算

内存空间的访问形式：
- 通过变量名访问
- 通过地址访问


指针的概念：
- 指针：内存地址，用于间接访问内存单元
- 指针变量：用于存放地址的变量

```C++
static int i;
static int* ptr = &i; //指向int变量的指针
```

指针运算符 *：表示该变量内存里存储的是地址，并操作存储地址对应的内存空间

地址运算符 &: 表示该变量的地址

### 指针的初始化和赋值

指针变量的初始化
- 语法形式
    - 存储类型 数据类型 *指针名 = 初始地址
    - 例如：int *pa = &a
- 注意事项
    - 用变量地址作为初始值时，该变量必须在指针初始化之前已声明过，且变量类型应与指针类型一致
    - 可以用一个已有合法值的指针去初始化另一个指针变量
    - 不要用一个内部非静态变量去初始化 static 指针

指针变量的赋值运算
- 语法形式 指针名 = 地址
- 注意：
    - `地址` 中存放的数据类型与指针类型必须相符
    - 向指针变量赋值必须是地址常量或变量，不能是普通整数
- 例如：
    - 通过地址运算 `&` 求得已定义的变量和对象的起始地址
    - 动态内存分配成功时返回的地址
- 例外：整数0可以赋值给指针，表示空指针
- 允许定义或声明指向 void 类型的指针。该指针可以被赋予任何类型对象的地址
    - void *general;


指向常量的指针
- const 指针
- 不能通过指向常量的指针改变所指对象的值，但指针本身可以改变，可以指向另外的对象
- 例如：
```C++
int a;
const int *p = &a;
int b;
p = &b
*p = 2; //编译出错
```

指针类型的常量
- 声明指针常量，则指针本身的值不能被改变
- 例如：
```C++
int a;
int * const p2 = *a;
p2 = &b; //错误
```

### 指针的运算

指针的算术运算
- 指针与整数的加减运算
    - 指针p 加上或减去 n：指针当前指向位置的前方或后方第n个数据的起始位置
- 指针++，--运算
    - 指向下一个或前一个完整数据的起始位置
- 运算的结果值取决于指针指向的数据类型，总是指向一个完整数据的起始位置
- 当指针指向连续存储的同类型数据时，指针与整数的加减运算和自增自减才有意义


指针的关系运算
- 指向相同类型数据的指针之间可以进行各种关系运算
- 指向不同数据类型的指针，以及指针与一般整形变量之间的关系运算是无意义的
- 指针可以和零之间进行等于或不等于的关系运算，判断空指针

